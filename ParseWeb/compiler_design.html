<!DOCTYPE html><html><body><title>Compiler Design</title>

<h4 style="margin:0px 2px 3px -2px!important;">Quick Links</h4>

<h1>Audience</h1>

<h1>Instructor</h1>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Compiler Design Tutorial</title>

<h1>Compiler Design Tutorial</h1>

<p>A compiler translates the code written in one language to some other language without changing the meaning of the program. It is also expected that a compiler should make the target code efficient and optimized in terms of time and space.</p>

<p>Compiler design principles provide an in-depth view of translation and optimization process. Compiler design covers basic translation mechanism and error detection &amp; recovery. It includes lexical, syntax, and semantic analysis as front end, and code generation and optimization as back-end.</p>

<h1>Audience</h1>

<p>This tutorial is designed for students interested in learning the basic principles of compilers.Enthusiastic readers who would like to know more about compilers and those who wish to design a compiler themselves may start from here.</p>

<h1>Prerequisites</h1>

<p>This tutorial requires no prior knowledge of compiler design but requires basic understanding of at least one programming language such as C, Java etc.It would be an additional advantage if you have had prior exposure to Assembly Programming.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Compiler Design - Overview</title>

<h1>Compiler Design - Overview</h1>

<p>Computers are a balanced mix of software and hardware. Hardware is just a piece of mechanical device and its functions are being controlled by a compatible software. Hardware understands instructions in the form of electronic charge, which is the counterpart of binary language in software programming. Binary language has only two alphabets, 0 and 1. To instruct, the hardware codes must be written in binary format, which is simply a series of 1s and 0s. It would be a difficult and cumbersome task for computer programmers to write such codes, which is why we have compilers to write such codes.</p>

<h2>Language Processing System</h2>

<p>We have learnt that any computer system is made of hardware and software. The hardware understands a language, which humans cannot understand. So we write programs in high-level language, which is easier for us to understand and remember. These programs are then fed into a series of tools and OS components to get the desired code that can be used by the machine. This is known as Language Processing System.</p>

<p>The high-level language is converted into binary language in various phases. A <b>compiler</b> is a program that converts high-level language to assembly language. Similarly, an <b>assembler</b> is a program that converts the assembly language to machine-level language.</p>

<p>Let us first understand how a program, using C compiler, is executed on a host machine.</p>

<p>User writes a program in C language (high-level language).</p>

<p>The C compiler, compiles the program and translates it to assembly program (low-level language).</p>

<p>An assembler then translates the assembly program into machine code (object).</p>

<p>A linker tool is used to link all the parts of the program together for execution (executable machine code).</p>

<p>A loader loads all of them into memory and then the program is executed.</p>

<p>Before diving straight into the concepts of compilers, we should understand a few other tools that work closely with compilers.</p>

<h3>Preprocessor</h3>

<p>A preprocessor, generally considered as a part of compiler, is a tool that produces input for compilers. It deals with macro-processing, augmentation, file inclusion, language extension, etc.</p>

<h3>Interpreter</h3>

<p>An interpreter, like a compiler, translates high-level language into low-level machine language. The difference lies in the way they read the source code or input. A compiler reads the whole source code at once, creates tokens, checks semantics, generates intermediate code, executes the whole program and may involve many passes. In contrast, an interpreter reads a statement from the input, converts it to an intermediate code, executes it, then takes the next statement in sequence. If an error occurs, an interpreter stops execution and reports it. whereas a compiler reads the whole program even if it encounters several errors.</p>

<h3>Assembler</h3>

<p>An assembler translates assembly language programs into machine code.The output of an assembler is called an object file, which contains a combination of machine instructions as well as the data required to place these instructions in memory.</p>

<h3>Linker</h3>

<p>Linker is a computer program that links and merges various object files together in order to make an executable file. All these files might have been compiled by separate assemblers. The major task of a linker is to search and locate referenced module/routines in a program and to determine the memory location where these codes will be loaded, making the program instruction to have absolute references.</p>

<h3>Loader</h3>

<p>Loader is a part of operating system and is responsible for loading executable files into memory and execute them. It calculates the size of a program (instructions and data) and creates memory space for it. It initializes various registers to initiate execution.</p>

<h3>Cross-compiler</h3>

<p>A compiler that runs on platform (A) and is capable of generating executable code for platform (B) is called a cross-compiler.</p>

<h3>Source-to-source Compiler</h3>

<p>A compiler that takes the source code of one programming language and translates it into the source code of another programming language is called a source-to-source compiler.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Compiler Design - Architecture</title>

<h1>Compiler Design - Architecture</h1>

<p>A compiler can broadly be divided into two phases based on the way they compile.</p>

<h3>Analysis Phase</h3>

<p>Known as the front-end of the compiler, the <b>analysis</b> phase of the compiler reads the source program, divides it into core parts and then checks for lexical, grammar and syntax errors.The analysis phase generates an intermediate representation of the source program and symbol table, which should be fed to the Synthesis phase as input.</p>

<h3>Synthesis Phase</h3>

<p>Known as the back-end of the compiler, the <b>synthesis</b> phase generates the target program with the help of intermediate source code representation and symbol table.</p>

<p>A compiler can have many phases and passes.</p>

<p><b>Pass</b> : A pass refers to the traversal of a compiler through the entire program.</p>

<p><b>Phase</b> : A phase of a compiler is a distinguishable stage, which takes input from the previous stage, processes and yields output that can be used as input for the next stage. A pass can have more than one phase.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Compiler Design - Phases of Compiler</title>

<h1>Compiler Design - Phases of Compiler</h1>

<p>The compilation process is a sequence of various phases. Each phase takes input from its previous stage, has its own representation of source program, and feeds its output to the next phase of the compiler. Let us understand the phases of a compiler.</p>

<h3>Lexical Analysis</h3>

<p>The first phase of scanner works as a text scanner. This phase scans the source code as a stream of characters and converts it into meaningful lexemes. Lexical analyzer represents these lexemes in the form of tokens as:</p>

<h3>Syntax Analysis</h3>

<p>The next phase is called the syntax analysis or <b>parsing</b>. It takes the token produced by lexical analysis as input and generates a parse tree (or syntax tree). In this phase, token arrangements are checked against the source code grammar, i.e. the parser checks if the expression made by the tokens is syntactically correct.</p>

<h3>Semantic Analysis</h3>

<p>Semantic analysis checks whether the parse tree constructed follows the rules of language. For example, assignment of values is between compatible data types, and adding string to an integer. Also, the semantic analyzer keeps track of identifiers, their types and expressions; whether identifiers are declared before use or not etc. The semantic analyzer produces an annotated syntax tree as an output.</p>

<h3>Intermediate Code Generation</h3>

<p>After semantic analysis the compiler generates an intermediate code of the source code for the target machine. It represents a program for some abstract machine. It is in between the high-level language and the machine language. This intermediate code should be generated in such a way that it makes it easier to be translated into the target machine code.</p>

<h3>Code Optimization</h3>

<p>The next phase does code optimization of the intermediate code. Optimization can be assumed as something that removes unnecessary code lines, and arranges the sequence of statements in order to speed up the program execution without wasting resources (CPU, memory).</p>

<h3>Code Generation</h3>

<p>In this phase, the code generator takes the optimized representation of the intermediate code and maps it to the target machine language. The code generator translates the intermediate code into a sequence of (generally) re-locatable machine code. Sequence of instructions of machine code performs the task as the intermediate code would do.</p>

<h3>Symbol Table</h3>

<p>It is a data-structure maintained throughout all the phases of a compiler. All the identifier's names along with their types are stored here. The symbol table makes it easier for the compiler to quickly search the identifier record and retrieve it. The symbol table is also used for scope management.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
&lt;token-name, attribute-value&gt;
</pre>

<title>Compiler Design - Lexical Analysis</title>

<h1>Compiler Design - Lexical Analysis</h1>

<p>Lexical analysis is the first phase of a compiler. It takes the modified source code from language preprocessors that are written in the form of sentences. The lexical analyzer breaks these syntaxes into a series of tokens, by removing any whitespace or comments in the source code.</p>

<p>If the lexical analyzer finds a token invalid, it generates an error. The lexical analyzer works closely with the syntax analyzer. It reads character streams from the source code, checks for legal tokens, and passes the data to the syntax analyzer when it demands.</p>

<h2>Tokens</h2>

<p>Lexemes are said to be a sequence of characters (alphanumeric) in a token. There are some predefined rules for every lexeme to be identified as a valid token. These rules are defined by grammar rules, by means of a pattern. A pattern explains what can be a token, and these patterns are defined by means of regular expressions.</p>

<p>In programming language, keywords, constants, identifiers, strings, numbers, operators and punctuations symbols can be considered as tokens.</p>

<p>For example, in C language, the variable declaration line</p>

<p>contains the tokens:</p>

<h2>Specifications of Tokens</h2>

<p>Let us understand how the language theory undertakes the following terms:</p>

<h3>Alphabets</h3>

<p>Any finite set of symbols {0,1} is a set of binary alphabets, {0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F} is a set of Hexadecimal alphabets, {a-z, A-Z} is a set of English language alphabets.</p>

<h3>Strings</h3>

<p>Any finite sequence of alphabets is called a string. Length of the string is the total number of occurrence of alphabets, e.g., the length of the string tutorialspoint is 14 and is denoted by |tutorialspoint| = 14. A string having no alphabets, i.e. a string of zero length is known as an empty string and is denoted by ε (epsilon).</p>

<h3>Special Symbols</h3>

<p>A typical high-level language contains the following symbols:-</p>

<h3>Language</h3>

<h2>Longest Match Rule</h2>

<p>When the lexical analyzer read the source-code, it scans the code letter by letter; and when it encounters a whitespace, operator symbol, or special symbols, it decides that a word is completed.</p>

<p><b>For example:</b></p>

<p>While scanning both lexemes till ‘int’, the lexical analyzer cannot determine whether it is a keyword <i>int</i> or the initials of identifier int value.</p>

<p>The Longest Match Rule states that the lexeme scanned should be determined based on the longest match among all the tokens available.</p>

<p>The lexical analyzer also follows <b>rule priority</b> where a reserved word, e.g., a keyword, of a language is given priority over user input. That is, if the lexical analyzer finds a lexeme that matches with any existing reserved word, it should generate an error.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
int value = 100;
</pre>
<p>contains the tokens:</p>
<pre class="prettyprint notranslate">
int (keyword), value (identifier), = (operator), 100 (constant) and ; (symbol).
</pre>
<h2>Specifications of Tokens</h2>
<p>Let us understand how the language theory undertakes the following terms:</p>
<h3>Alphabets</h3>
<p>Any finite set of symbols {0,1} is a set of binary alphabets, {0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F} is a set of Hexadecimal alphabets, {a-z, A-Z} is a set of English language alphabets.</p>
<h3>Strings</h3>
<p>Any finite sequence of alphabets is called a string. Length of the string is the total number of occurrence of alphabets, e.g., the length of the string tutorialspoint is 14 and is denoted by |tutorialspoint| = 14. A string having no alphabets, i.e. a string of zero length is known as an empty string and is denoted by ε (epsilon).</p>
<h3>Special Symbols</h3>
<p>A typical high-level language contains the following symbols:-</p>
<table class="table table-bordered">
<tr>
<td style="width:26%;">Arithmetic Symbols</td>
<td>Addition(+), Subtraction(-), Modulo(%), Multiplication(*), Division(/)</td>
</tr>
<tr>
<td>Punctuation</td>
<td>Comma(,), Semicolon(;), Dot(.), Arrow(->)</td>
</tr>
<tr>
<td>Assignment</td>
<td>=</td>
</tr>
<tr>
<td>Special Assignment</td>
<td>+=, /=, *=, -=</td>
</tr>
<tr>
<td>Comparison</td>
<td>==, !=, <, <=, >, >=</td>
</tr>
<tr>
<td>Preprocessor</td>
<td>#</td>
</tr>
<tr>
<td>Location Specifier</td>
<td>&amp; </td>
</tr>
<tr>
<td>Logical</td>
<td>&amp;, &amp;&amp;, |, ||, !</td>
</tr>
<tr>
<td>Shift Operator</td>
<td>>>, >>>, <<, <<<</td>
</tr>
</table>
<h3>Language</h3>
<p>A language is considered as a finite set of strings over some finite set of alphabets.
Computer languages are considered as finite sets, and mathematically set operations can be performed on them. Finite languages can be described by means of regular expressions.</p>
<h2>Longest Match Rule</h2>
<p>When the lexical analyzer read the source-code, it scans the code letter by letter; and when it encounters a whitespace, operator symbol, or special symbols, it decides that a word is completed.</p>
<p><b>For example:</b></p>
<pre class="prettyprint notranslate">
int intvalue;
</pre>

<title>Compiler Design - Regular Expressions</title>

<h1>Compiler Design - Regular Expressions</h1>

<p>The lexical analyzer needs to scan and identify only a finite set of valid string/token/lexeme that belong to the language in hand. It searches for the pattern defined by the language rules.</p>

<p>Regular expressions have the capability to express finite languages by defining a pattern for finite strings of symbols. The grammar defined by regular expressions is known as <b>regular grammar</b>. The language defined by regular grammar is known as <b>regular language</b>.</p>

<p>Regular expression is an important notation for specifying patterns. Each pattern matches a set of strings, so regular expressions serve as names for a set of strings. Programming language tokens can be described by regular languages. The specification of regular expressions is an example of a recursive definition. Regular languages are easy to understand and have efficient implementation.</p>

<p>There are a number of algebraic laws that are obeyed by regular expressions, which can be used to manipulate regular expressions into equivalent forms.</p>

<h2>Operations</h2>

<p>The various operations on languages are:</p>

<p>Union of two languages L and M is written as</p>

<p>L U M = {s | s is in L or s is in M}</p>

<p>Concatenation of two languages L and M is written as</p>

<p>LM = {st | s is in L and t is in M}</p>

<p>The Kleene Closure of a language L is written as</p>

<p>L* = Zero or more occurrence of language L.</p>

<h2>Notations</h2>

<p>If r and s are regular expressions denoting the languages L(r) and L(s), then</p>

<p><b>Union</b> : (r)|(s) is a regular expression denoting L(r) U L(s)</p>

<p><b>Concatenation</b> : (r)(s) is a regular expression denoting L(r)L(s)</p>

<p><b>Kleene closure</b> : (r)* is a regular expression denoting (L(r))*</p>

<p>(r) is a regular expression denoting L(r)</p>

<h2>Precedence and Associativity</h2>

<h3>Representing valid tokens of a language in regular expression</h3>

<p>If x is a regular expression, then:</p>

<p>x* means zero or more occurrence of x.</p>

<p>i.e., it can generate { e, x, xx, xxx, xxxx, … }</p>

<p>x+ means one or more occurrence of x.</p>

<p>i.e., it can generate { x, xx, xxx, xxxx … } or x.x*</p>

<p>x? means at most one occurrence of x</p>

<p>i.e., it can generate either {x} or {e}.</p>

<p>[a-z] is all lower-case alphabets of English language.</p>

<p>[A-Z] is all upper-case alphabets of English language.</p>

<p>[0-9] is all natural digits used in mathematics.</p>

<h3>Representing occurrence of symbols using regular expressions</h3>

<p>letter = [a – z] or [A – Z]</p>

<p>digit  = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 or [0-9]</p>

<p>sign = [ + | - ]</p>

<h3>Representing language tokens using regular expressions</h3>

<p>Decimal = (sign)<sup>?</sup>(digit)<sup>+</sup></p>

<p>Identifier = (letter)(letter | digit)*</p>

<p>The only problem left with the lexical analyzer is how to verify the validity of a regular expression used in specifying the patterns of keywords of a language. A well-accepted solution is to use finite automata for verification.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Compiler Design - Finite Automata</title>

<h1>Compiler Design - Finite Automata</h1>

<p>Finite automata is a state machine that takes a string of symbols as input and changes its state accordingly. Finite automata is a recognizer for regular expressions. When a regular expression string is fed into finite automata, it changes its state for each literal. If the input string is successfully processed and the automata reaches its final state, it is accepted, i.e., the string just fed was said to be a valid token of the language in hand.</p>

<p>The mathematical model of finite automata consists of:</p>

<p>The transition function (δ) maps the finite set of state (Q) to a finite set of input symbols (Σ), Q × Σ ➔ Q</p>

<h3>Finite Automata Construction</h3>

<p>Let L(r) be a regular language recognized by some finite automata (FA).</p>

<p><b>States</b> : States of FA are represented by circles. State names are written inside circles.</p>

<p><b>Start state</b> : The state from where the automata starts, is known as the start state. Start state has an arrow pointed towards it.</p>

<p><b>Intermediate states</b> : All intermediate states have at least two arrows; one pointing to and another pointing out from them.</p>

<p><b>Final state</b> : If the input string is successfully parsed, the automata is expected to be in this state. Final state is represented by double circles. It may have any odd number of arrows pointing to it and even number of arrows pointing out from it. The number of odd arrows are one greater than even, i.e. <b>odd = even+1</b>.</p>

<p><b>Transition</b> : The transition from one state to another state happens when a desired symbol in the input is found. Upon transition, automata can either move to the next state or stay in the same state. Movement from one state to another is shown as a directed arrow, where the arrows points to the destination state. If automata stays on the same state, an arrow pointing from a state to itself is drawn.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Compiler Design - Syntax Analysis</title>

<h1>Compiler Design - Syntax Analysis</h1>

<p>Syntax analysis or parsing is the second phase of a compiler. In this chapter, we shall learn the basic concepts used in the construction of a parser.</p>

<p>We have seen that a lexical analyzer can identify tokens with the help of regular expressions and pattern rules. But a lexical analyzer cannot check the syntax of a given sentence due to the limitations of the regular expressions. Regular expressions cannot check balancing tokens, such as parenthesis. Therefore, this phase uses context-free grammar (CFG), which is recognized by push-down automata.</p>

<p>CFG, on the other hand, is a superset of Regular Grammar, as depicted below:</p>

<p>It implies that every Regular Grammar is also context-free, but there exists some problems, which are  beyond the scope of Regular Grammar. CFG is a helpful tool in describing the syntax of programming languages.</p>

<h2>Context-Free Grammar</h2>

<p>In this section, we will first see the definition of context-free grammar and introduce terminologies used in parsing technology.</p>

<p>A context-free grammar has four components:</p>

<p>A set of <b>non-terminals</b> (V). Non-terminals are syntactic variables that denote sets of strings. The non-terminals define sets of strings that help define the language generated by the grammar.</p>

<p>A set of tokens, known as <b>terminal symbols</b> (Σ). Terminals are the basic symbols from which strings are formed.</p>

<p>A set of <b>productions</b> (P). The productions of a grammar specify the manner in which the terminals and non-terminals can be combined to form strings. Each production consists of a <b>non-terminal</b> called the left side of the production, an arrow, and a sequence of tokens and/or <b>on- terminals</b>, called the right side of the production.</p>

<p>One of the non-terminals is designated as the start symbol (S); from where the production begins.</p>

<p>The strings are derived from the start symbol by repeatedly replacing a non-terminal (initially the start symbol) by the right side of a production, for that non-terminal.</p>

<h3>Example</h3>

<p>We take the problem of palindrome language, which cannot be described by means of Regular Expression. That is, L = { w | w = w<sup>R</sup> } is not a regular language. But it can be described by means of CFG, as illustrated below:</p>

<p>Where:</p>

<p>This grammar describes palindrome language, such as: 1001, 11100111, 00100, 1010101, 11111, etc.</p>

<h2>Syntax Analyzers</h2>

<p>A syntax analyzer or parser takes the input from a lexical analyzer in the form of token streams. The parser analyzes the source code (token stream) against the production rules to detect any errors in the code. The output of this phase is a <b>parse tree</b>.</p>

<p>This way, the parser accomplishes two tasks, i.e., parsing the code, looking for errors and generating a parse tree as the output of the phase.</p>

<p>Parsers are expected to parse the whole code even if some errors exist in the program. Parsers use error recovering strategies, which we will learn later in this chapter.</p>

<h2>Derivation</h2>

<p>A derivation is basically a sequence of production rules, in order to get the input string. During parsing, we take two decisions for some sentential form of input:</p>

<p>To decide which non-terminal to be replaced with production rule, we can have two options.</p>

<h3>Left-most Derivation</h3>

<p>If the sentential form of an input is scanned and replaced from left to right, it is called left-most derivation. The sentential form derived by the left-most derivation is called the left-sentential form.</p>

<h3>Right-most Derivation</h3>

<p>If we scan and replace the input with production rules, from right to left, it is known as right-most derivation. The sentential form derived from the right-most derivation is called the right-sentential form.</p>

<p><b>Example</b></p>

<p>Production rules:</p>

<p>Input string: id + id * id</p>

<p>The left-most derivation is:</p>

<p>Notice that the left-most side non-terminal is always processed first.</p>

<p>The right-most derivation is:</p>

<h2>Parse Tree</h2>

<p>A parse tree is a graphical depiction of a derivation. It is convenient to see how strings are derived from the start symbol. The start symbol of the derivation becomes the root of the parse tree. Let us see this by an example from the last topic.</p>

<p>We take the left-most derivation of a + b * c</p>

<p>The left-most derivation is:</p>

<p>Step 1:</p>

<p>Step 2:</p>

<p>Step 3:</p>

<p>Step 4:</p>

<p>Step 5:</p>

<p>In a parse tree:</p>

<p>A parse tree depicts associativity and precedence of operators. The deepest sub-tree is traversed first, therefore the operator in that sub-tree gets precedence over the operator which is in the parent nodes.</p>

<h2>Ambiguity</h2>

<p>A grammar G is said to be ambiguous if it has more than one parse tree (left or right derivation) for at least one string.</p>

<p><b>Example</b></p>

<p>For the string id + id – id, the above grammar generates two parse trees:</p>

<p>The language generated by an ambiguous grammar is said to be <b>inherently ambiguous</b>. Ambiguity in grammar is not good for a compiler construction. No method can detect and remove ambiguity automatically, but it can be removed by either re-writing the whole grammar without ambiguity, or by setting and following associativity and precedence constraints.</p>

<h2>Associativity</h2>

<p>If an operand has operators on both sides, the side on which the operator takes this operand is decided by the associativity of those operators. If the operation is left-associative, then the operand will be taken by the left operator or if the operation is right-associative, the right operator will take the operand.</p>

<p><b>Example</b></p>

<p>Operations such as Addition, Multiplication, Subtraction, and Division are left associative. If the expression contains:</p>

<p>it will be evaluated as:</p>

<p>For example, (id + id) + id</p>

<p>Operations like Exponentiation are right associative, i.e., the order of evaluation in the same expression will be:</p>

<p>For example, id ^ (id ^ id)</p>

<h2>Precedence</h2>

<p>If two different operators share a common operand, the precedence of operators decides which will take the operand. That is, 2+3*4 can have two different parse trees, one corresponding to (2+3)*4 and another corresponding to 2+(3*4). By setting precedence among operators, this problem can be easily removed. As in the previous example, mathematically * (multiplication) has precedence over + (addition), so the expression 2+3*4 will always be interpreted as:</p>

<p>These methods decrease the chances of ambiguity in a language or its grammar.</p>

<h2>Left Recursion</h2>

<p>A grammar becomes left-recursive if it has any non-terminal ‘A’ whose derivation contains ‘A’ itself as the left-most symbol. Left-recursive grammar is considered to be a problematic situation for top-down parsers. Top-down parsers start parsing from the Start symbol, which in itself is non-terminal. So, when the parser encounters the same non-terminal in its derivation, it becomes hard for it to judge when to stop parsing the left non-terminal and it goes into an infinite loop.</p>

<p><b>Example:</b></p>

<p>(1) is an example of immediate left recursion, where A is any non-terminal symbol and α represents a string of non-terminals.</p>

<p>(2) is an example of indirect-left recursion.</p>

<p>A top-down parser will first parse the A, which in-turn will yield a string consisting of A itself and the parser may go into a loop forever.</p>

<h3>Removal of Left Recursion</h3>

<p>One way to remove left recursion is to use the following technique:</p>

<p>The production</p>

<p>is converted into following productions</p>

<p>This does not impact the strings derived from the grammar, but it removes immediate left recursion.</p>

<p>Second method is to use the following algorithm, which should eliminate all direct and indirect left recursions.</p>

<p><b>Example</b></p>

<p>The production set</p>

<p>after applying the above algorithm, should become</p>

<p>and then, remove immediate left recursion using the first technique.</p>

<p>Now none of the production has either direct or indirect left recursion.</p>

<h2>Left Factoring</h2>

<p>If more than one grammar production rules has a common prefix string, then the top-down parser cannot make a choice as to which of the production it should take to parse the string in hand.</p>

<p><b>Example</b></p>

<p>If a top-down parser encounters a production like</p>

<p>Then it cannot determine which production to follow to parse the string as both productions are starting from the same terminal (or non-terminal). To remove this confusion, we use a technique called left factoring.</p>

<p>Left factoring transforms the grammar to make it useful for top-down parsers. In this technique, we make one production for each common prefixes and the rest of the derivation is added by new productions.</p>

<p><b>Example</b></p>

<p>The above productions can be written as</p>

<p>Now the parser has only one production per prefix which makes it easier to take decisions.</p>

<h2>First and Follow Sets</h2>

<p>An important part of parser table construction is to create first and follow sets.  These sets can provide the actual position of any terminal in the derivation. This is done to create the parsing table where the decision of replacing T[A, t] = α with some production rule.</p>

<h3>First Set</h3>

<p>This set is created to know what terminal symbol is derived in the first position by a non-terminal. For example,</p>

<p>That is α derives t (terminal) in the very first position. So, t ∈ FIRST(α).</p>

<h4>Algorithm for calculating First set</h4>

<p>Look at the definition of FIRST(α) set:</p>

<p>First set can be seen as:</p>

<h3>Follow Set</h3>

<p>Likewise, we calculate what terminal symbol immediately follows a non-terminal α in production rules. We do not consider what the non-terminal can generate but instead, we see what would be the next terminal symbol that follows the productions of a non-terminal.</p>

<h4>Algorithm for calculating Follow set:</h4>

<p>if α is a start symbol, then FOLLOW() = $</p>

<p>if α is a non-terminal and has a production α → AB, then FIRST(B) is in FOLLOW(A) except ℇ.</p>

<p>if α is a non-terminal and has a production α → AB, where B  ℇ, then FOLLOW(A) is in FOLLOW(α).</p>

<p>Follow set can be seen as: FOLLOW(α) = { t | S   *αt*}</p>

<h2>Limitations of Syntax Analyzers</h2>

<p>Syntax analyzers receive their inputs, in the form of tokens, from lexical analyzers. Lexical analyzers are responsible for the validity of a token supplied by the syntax analyzer. Syntax analyzers have the following drawbacks -</p>

<p>These tasks are accomplished by the semantic analyzer, which we shall study in Semantic Analysis.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
G = ( V, Σ, P, S )
</pre>
<p>Where:</p>
<pre class="result notranslate">
V = { Q, Z, N }
Σ = { 0, 1 }
P = { Q → Z | Q → N | Q → ℇ | Z → 0Q0 | N → 1Q1 }
S = { Q }
</pre>
<p>This grammar describes palindrome language, such as: 1001, 11100111, 00100, 1010101, 11111, etc.</p>
<h2>Syntax Analyzers</h2>
<p>A syntax analyzer or parser takes the input from a lexical analyzer in the form of token streams. The parser analyzes the source code (token stream) against the production rules to detect any errors in the code. The output of this phase is a <b>parse tree</b>.</p>
<img src="/compiler_design/images/syntax_analyzer.jpg" alt="Syntax Analyzer" />

<p>This way, the parser accomplishes two tasks, i.e., parsing the code, looking for errors and generating a parse tree as the output of the phase.</p>
<p>Parsers are expected to parse the whole code even if some errors exist in the program. Parsers use error recovering strategies, which we will learn later in this chapter.</p>
<h2>Derivation</h2>
<p>A derivation is basically a sequence of production rules, in order to get the input string. During parsing, we take two decisions for some sentential form of input:</p>
<ul class="list">
<li>Deciding the non-terminal which is to be replaced.</li>
<li>Deciding the production rule, by which, the non-terminal will be replaced.</li>
</ul>
<p>To decide which non-terminal to be replaced with production rule, we can have two options.</p>
<h3>Left-most Derivation</h3>
<p>If the sentential form of an input is scanned and replaced from left to right, it is called left-most derivation. The sentential form derived by the left-most derivation is called the left-sentential form.</p>
<h3>Right-most Derivation</h3>
<p>If we scan and replace the input with production rules, from right to left, it is known as right-most derivation. The sentential form derived from the right-most derivation is called the right-sentential form.</p>
<p><b>Example</b></p>
<p>Production rules:</p>
<pre class="prettyprint notranslate">
E → E + E
E → E * E
E → id 
</pre>
<p>Input string: id + id * id</p>
<p>The left-most derivation is:</p>
<pre class="prettyprint notranslate">
E → E * E
E → E + E * E
E → id + E * E
E → id + id * E
E → id + id * id
</pre>
<p>Notice that the left-most side non-terminal is always processed first.</p>
<p>The right-most derivation is:</p>
<pre class="prettyprint notranslate">
E → E + E
E → E + E * E
E → E + E * id
E → E + id * id
E → id + id * id
</pre>
<h2>Parse Tree</h2>
<p>A parse tree is a graphical depiction of a derivation. It is convenient to see how strings are derived from the start symbol. The start symbol of the derivation becomes the root of the parse tree. Let us see this by an example from the last topic.</p>
<p>We take the left-most derivation of a + b * c</p>
<p>The left-most derivation is:</p>
<pre class="prettyprint notranslate">
E → E * E
E → E + E * E
E → id + E * E
E → id + id * E
E → id + id * id
</pre>
<p>Step 1:</p>
<table class="table table-bordered">
<tr><td width="50%" style="vertical-align:middle">E → E * E</td><td><img src="/compiler_design/images/parse_tree_step_1.jpg" alt="Parse Tree Construction" /></td></tr>
</table>

<p>Step 2:</p>
<table class="table table-bordered">
<tr><td width="50%" style="vertical-align:middle">E → E + E * E</td><td><img src="/compiler_design/images/parse_tree_step_2.jpg" alt="Parse Tree Construction" /></td></tr>
</table>

<p>Step 3:</p>
<table class="table table-bordered">
<tr><td width="50%" style="vertical-align:middle">E → id + E * E</td><td><img src="/compiler_design/images/parse_tree_step_3.jpg" alt="Parse Tree Construction" /></td></tr>
</table>

<p>Step 4:</p>
<table class="table table-bordered">
<tr><td width="50%" style="vertical-align:middle">E → id + id * E</td><td><img src="/compiler_design/images/parse_tree_step_4.jpg" alt="Parse Tree Construction" /></td></tr>
</table>

<p>Step 5:</p>
<table class="table table-bordered">
<tr><td width="50%" style="vertical-align:middle">E → id + id * id</td><td><img src="/compiler_design/images/parse_tree_step_5.jpg" alt="Parse Tree Construction" /></td></tr>
</table>

<p>In a parse tree:</p>
<ul class="list">
<li>All leaf nodes are terminals.</li>
<li>All interior nodes are non-terminals.</li>
<li>In-order traversal gives original input string.</li>
</ul>
<p>A parse tree depicts associativity and precedence of operators. The deepest sub-tree is traversed first, therefore the operator in that sub-tree gets precedence over the operator which is in the parent nodes.</p>
<h2>Ambiguity</h2>
<p>A grammar G is said to be ambiguous if it has more than one parse tree (left or right derivation) for at least one string.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
E → E + E
E → E – E
E → id
</pre>
<p>For the string id + id – id, the above grammar generates two parse trees:</p>
<img src="/compiler_design/images/parse_tree_ambiguity.jpg" alt="Parse Tree Construction" />
   
<p>The language generated by an ambiguous grammar is said to be <b>inherently ambiguous</b>. Ambiguity in grammar is not good for a compiler construction. No method can detect and remove ambiguity automatically, but it can be removed by either re-writing the whole grammar without ambiguity, or by setting and following associativity and precedence constraints.</p>
<h2>Associativity</h2>
<p>If an operand has operators on both sides, the side on which the operator takes this operand is decided by the associativity of those operators. If the operation is left-associative, then the operand will be taken by the left operator or if the operation is right-associative, the right operator will take the operand.</p>
<p><b>Example</b></p>
<p>Operations such as Addition, Multiplication, Subtraction, and Division are left associative. If the expression contains:</p>
<pre class="prettyprint notranslate">
id op id op id
</pre>
<p>it will be evaluated as:</p>
<pre class="prettyprint notranslate">
(id op id) op id
</pre>
<p>For example, (id + id) + id</p>
<p>Operations like Exponentiation are right associative, i.e., the order of evaluation in the same expression will be:</p>
<pre class="prettyprint notranslate">
id op (id op id)
</pre>
<p>For example, id ^ (id ^ id)</p>
<h2>Precedence</h2> 
<p>If two different operators share a common operand, the precedence of operators decides which will take the operand. That is, 2+3*4 can have two different parse trees, one corresponding to (2+3)*4 and another corresponding to 2+(3*4). By setting precedence among operators, this problem can be easily removed. As in the previous example, mathematically * (multiplication) has precedence over + (addition), so the expression 2+3*4 will always be interpreted as:</p>
<pre class="prettyprint notranslate">
2 + (3 * 4)
</pre>
<p>These methods decrease the chances of ambiguity in a language or its grammar.</p>
<h2>Left Recursion</h2>
<p>A grammar becomes left-recursive if it has any non-terminal ‘A’ whose derivation contains ‘A’ itself as the left-most symbol. Left-recursive grammar is considered to be a problematic situation for top-down parsers. Top-down parsers start parsing from the Start symbol, which in itself is non-terminal. So, when the parser encounters the same non-terminal in its derivation, it becomes hard for it to judge when to stop parsing the left non-terminal and it goes into an infinite loop.</p>
<p><b>Example:</b></p>
<pre class="result notranslate">
(1) A => Aα | β

(2) S => Aα | β 
    A => Sd 
</pre>
<p>(1) is an example of immediate left recursion, where A is any non-terminal symbol and α represents a string of non-terminals.</p>
<p>(2) is an example of indirect-left recursion.</p>
<img src="/compiler_design/images/left_recursion.jpg" alt="Left Recursion" />
<p>A top-down parser will first parse the A, which in-turn will yield a string consisting of A itself and the parser may go into a loop forever.</p>
<h3>Removal of Left Recursion</h3>
<p>One way to remove left recursion is to use the following technique:</p>
<p>The production</p>
<pre class="result notranslate">
A => Aα | β
</pre>
<p>is converted into following productions</p>
<pre class="result notranslate">
A => βA'
A'=> αA' | &epsilon;
</pre>
<p>This does not impact the strings derived from the grammar, but it removes immediate left recursion.</p>
<p>Second method is to use the following algorithm, which should eliminate all direct and indirect left recursions.</p>
<pre class="result notranslate">
START

Arrange non-terminals in some order like A1, A2, A3,…, A<sub>n</sub>

   for each i from 1 to n
      {
      for each j from 1 to i-1
         {
         replace each production of form A<sub>i</sub> ⟹Aj𝜸
         with A<sub>i</sub> ⟹ δ1𝜸  | δ2𝜸 | δ3𝜸 |…| 𝜸 
         where A<sub>j</sub> ⟹ δ<sub>1</sub> | δ<sub>2</sub>|…| δ<sub>n</sub>  are current A<sub>j</sub> productions
         }
      }
   eliminate immediate left-recursion
   
END
</pre>
<p><b>Example</b></p>
<p>The production set</p>
<pre class="result notranslate">
S => Aα | β 
A => Sd
</pre>
<p>after applying the above algorithm, should become</p>
<pre class="result notranslate">
S => Aα | β 
A => Aαd | βd
</pre>
<p>and then, remove immediate left recursion using the first technique.</p>
<pre class="result notranslate">
A  => βdA'
A' => αdA' | &epsilon;
</pre>
<p>Now none of the production has either direct or indirect left recursion.</p>
<h2>Left Factoring</h2>
<p>If more than one grammar production rules has a common prefix string, then the top-down parser cannot make a choice as to which of the production it should take to parse the string in hand.</p>
<p><b>Example</b></p>
<p>If a top-down parser encounters a production like</p>
<pre class="result notranslate">
A ⟹ αβ | α𝜸 | …
</pre>
<p>Then it cannot determine which production to follow to parse the string as both productions are starting from the same terminal (or non-terminal). To remove this confusion, we use a technique called left factoring.</p>
<p>Left factoring transforms the grammar to make it useful for top-down parsers. In this technique, we make one production for each common prefixes and the rest of the derivation is added by new productions.</p>
<p><b>Example</b></p>
<p>The above productions can be written as</p>
<pre class="result notranslate">
A => αA'
A'=> β | 𝜸 | … 
</pre>
<p>Now the parser has only one production per prefix which makes it easier to take decisions.</p>
<h2>First and Follow Sets</h2>
<p>An important part of parser table construction is to create first and follow sets.  These sets can provide the actual position of any terminal in the derivation. This is done to create the parsing table where the decision of replacing T[A, t] = α with some production rule.</p>
<h3>First Set</h3>
<p>This set is created to know what terminal symbol is derived in the first position by a non-terminal. For example,</p>
<pre class="result notranslate">
α → t β
</pre>

<title>Compiler Design - Types of Parsing</title>

<h1>Compiler Design - Types of Parsing</h1>

<p>Syntax analyzers follow production rules defined by means of context-free grammar. The way the production rules are implemented (derivation) divides parsing into two types : top-down parsing and bottom-up parsing.</p>

<h3>Top-down Parsing</h3>

<p>When the parser starts constructing the parse tree from the start symbol and then tries to transform the start symbol to the input, it is called top-down parsing.</p>

<p><b>Recursive descent parsing</b> : It is a common form of top-down parsing. It is called recursive as it uses recursive procedures to process the input. Recursive descent parsing suffers from backtracking.</p>

<h3>Bottom-up Parsing</h3>

<p>As the name suggests, bottom-up parsing starts with the input symbols and tries to construct the parse tree up to the start symbol.</p>

<p><b>Example:</b></p>

<p>Input string : a + b * c</p>

<p>Production rules:</p>

<p>Let us start bottom-up parsing</p>

<p>Read the input and check if any production matches with the input:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
S → E
E → E + T
E → E * T
E → T
T → id
</pre>
<p>Let us start bottom-up parsing</p>
<pre class="prettyprint notranslate">
a + b * c
</pre>
<p>Read the input and check if any production matches with the input:</p>
<pre class="prettyprint notranslate">
a + b * c
T + b * c
E + b * c
E + T * c
E * c
E * T
E
S
</pre>

<title>Compiler Design - Top-Down Parser</title>

<h1>Compiler Design - Top-Down Parser</h1>

<p>We have learnt in the last chapter that the top-down parsing technique parses the input, and starts constructing a parse tree from the root node gradually moving down to the leaf nodes. The types of top-down parsing are depicted below:</p>

<h3>Recursive Descent Parsing</h3>

<p>Recursive descent is a top-down parsing technique that constructs the parse tree from the top and the input is read from left to right. It uses procedures for every terminal and non-terminal entity. This parsing technique recursively parses the input to make a parse tree, which may or may not require back-tracking. But the grammar associated with it (if not left factored) cannot avoid back-tracking. A form of recursive-descent parsing that does not require any back-tracking is known as <b>predictive parsing</b>.</p>

<p>This parsing technique is regarded recursive as it uses context-free grammar which is recursive in nature.</p>

<h3>Back-tracking</h3>

<p>Top- down parsers start from the root node (start symbol) and match the input string against the production rules to replace them (if matched). To understand this, take the following example of CFG:</p>

<p>For an input string: read, a top-down parser, will behave like this:</p>

<p>It will start with S from the production rules and will match its yield to the left-most letter of the input, i.e. ‘r’.  The very production of S (S → rXd) matches with it. So the top-down parser advances to the next input letter (i.e. ‘e’). The parser tries to expand non-terminal ‘X’ and checks its production from the left (X → oa). It does not match with the next input symbol. So the top-down parser backtracks to obtain the next production rule of X, (X → ea).</p>

<p>Now the parser matches all the input letters in  an ordered manner. The string is accepted.</p>

<h3>Predictive Parser</h3>

<p>Predictive parser is a recursive descent parser, which has the capability to predict which production is to be used to replace the input string. The predictive parser does not suffer from backtracking.</p>

<p>To accomplish its tasks, the predictive parser uses a look-ahead pointer, which points to the next input symbols. To make the parser back-tracking free, the predictive parser puts some constraints on the grammar and accepts only a class of grammar known as LL(k) grammar.</p>

<p>Predictive parsing uses a stack and a parsing table to parse the input and generate a parse tree. Both the stack and the input contains an end symbol <b>$</b> to denote that the stack is empty and the input is consumed. The parser refers to the parsing table to take any decision on the input and stack element combination.</p>

<p>In recursive descent parsing, the parser may have more than one production to choose from for a single instance of input, whereas in predictive parser, each step has at most one production to choose. There might be instances where there is no production matching the input string, making the parsing procedure to fail.</p>

<h3>LL Parser</h3>

<p>An LL Parser accepts LL grammar. LL grammar is a subset of context-free grammar but with some restrictions to get the simplified version, in order to achieve easy implementation. LL grammar can be implemented by means of both algorithms namely, recursive-descent or table-driven.</p>

<p>LL parser is denoted as LL(k). The first L in LL(k) is parsing the input from left to right, the second L in LL(k) stands for left-most derivation and k itself represents the number of look aheads. Generally k = 1, so LL(k) may also be written as LL(1).</p>

<h3>LL Parsing Algorithm</h3>

<p>We may stick to deterministic LL(1) for parser explanation, as the size of table grows exponentially with the value of k. Secondly, if a given grammar is not LL(1), then usually, it is not LL(k), for any given k.</p>

<p>Given below is an algorithm for LL(1) Parsing:</p>

<p>A grammar G is LL(1) if A &rarr; α | β are two distinct productions of G:</p>

<p>for no terminal, both α and β derive strings beginning with a.</p>

<p>at most one of α and β can derive empty string.</p>

<p>if  β &rarr; t, then α does not derive any string beginning with a terminal in FOLLOW(A).</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
S → rXd | rZd
X → oa | ea
Z → ai
</pre>
<p>For an input string: read, a top-down parser, will behave like this:</p>
<p>It will start with S from the production rules and will match its yield to the left-most letter of the input, i.e. ‘r’.  The very production of S (S → rXd) matches with it. So the top-down parser advances to the next input letter (i.e. ‘e’). The parser tries to expand non-terminal ‘X’ and checks its production from the left (X → oa). It does not match with the next input symbol. So the top-down parser backtracks to obtain the next production rule of X, (X → ea).</p>
<p>Now the parser matches all the input letters in  an ordered manner. The string is accepted.</p>
<table class="table table-bordered">
<tr>
<td>
<img src="/compiler_design/images/back_tracking_1.jpg" alt="Back Tracking" />
</td>
<td>
<img src="/compiler_design/images/back_tracking_2.jpg" alt="Back Tracking" />
</td>
<td>
<img src="/compiler_design/images/back_tracking_3.jpg" alt="Back Tracking" />
</td>
<td>
<img src="/compiler_design/images/back_tracking_4.jpg" alt="Back Tracking" />
</td>
</tr>
</table>
<h3>Predictive Parser</h3>
<p>Predictive parser is a recursive descent parser, which has the capability to predict which production is to be used to replace the input string. The predictive parser does not suffer from backtracking.</p>
<p>To accomplish its tasks, the predictive parser uses a look-ahead pointer, which points to the next input symbols. To make the parser back-tracking free, the predictive parser puts some constraints on the grammar and accepts only a class of grammar known as LL(k) grammar.</p>
<img src="/compiler_design/images/predictive_parser.jpg" alt="Predictive Parser" />
<p>Predictive parsing uses a stack and a parsing table to parse the input and generate a parse tree. Both the stack and the input contains an end symbol <b>$</b> to denote that the stack is empty and the input is consumed. The parser refers to the parsing table to take any decision on the input and stack element combination.</p>
<img src="/compiler_design/images/top_down_parser_construction.jpg" alt="Top-Down Parser Construction" />
<p>In recursive descent parsing, the parser may have more than one production to choose from for a single instance of input, whereas in predictive parser, each step has at most one production to choose. There might be instances where there is no production matching the input string, making the parsing procedure to fail.</p>
<h3>LL Parser</h3>
<p>An LL Parser accepts LL grammar. LL grammar is a subset of context-free grammar but with some restrictions to get the simplified version, in order to achieve easy implementation. LL grammar can be implemented by means of both algorithms namely, recursive-descent or table-driven.</p>
<p>LL parser is denoted as LL(k). The first L in LL(k) is parsing the input from left to right, the second L in LL(k) stands for left-most derivation and k itself represents the number of look aheads. Generally k = 1, so LL(k) may also be written as LL(1).</p>
<img src="/compiler_design/images/ll_parser.jpg" alt="LL Parser" />
<h3>LL Parsing Algorithm</h3>
<p>We may stick to deterministic LL(1) for parser explanation, as the size of table grows exponentially with the value of k. Secondly, if a given grammar is not LL(1), then usually, it is not LL(k), for any given k.</p>
<p>Given below is an algorithm for LL(1) Parsing:</p>
<pre class="prettyprint notranslate">
Input: 
   string ω 
   parsing table M for grammar G

Output:
   If ω is in L(G) then left-most derivation of ω,
   error otherwise.

Initial State : $S on stack (with S being start symbol)
   ω$ in the input buffer

SET ip to point the first symbol of ω$.

repeat
   let X be the top stack symbol and a the symbol pointed by ip.

   if X&isin; V<sub>t</sub> or $
      if X = a
         POP X and advance ip.
      else
         error()
      endif
      
   else	/* X is non-terminal */
      if M[X,a] = X → Y1, Y2,... Yk    
         POP X
         PUSH Yk, Yk-1,... Y1 /* Y1 on top */
         Output the production X → Y1, Y2,... Yk 
      else
         error()
      endif
   endif
until X = $	/* empty stack */
</pre>

<title>Compiler Design - Bottom-Up Parser</title>

<h1>Compiler Design - Bottom-Up Parser</h1>

<p>Bottom-up parsing starts from the leaf nodes of a tree and works in upward direction till it reaches the root node. Here, we start from a sentence and then apply production rules in reverse manner in order to reach the start symbol. The image given below depicts the bottom-up parsers available.</p>

<h3>Shift-Reduce Parsing</h3>

<p>Shift-reduce parsing uses two unique steps for bottom-up parsing. These steps are known as shift-step and reduce-step.</p>

<p><b>Shift step</b>: The shift step refers to the advancement of the input pointer to the next input symbol, which is called the shifted symbol. This symbol is pushed onto the stack. The shifted symbol is treated as a single node of the parse tree.</p>

<p><b>Reduce step</b> : When the parser finds a complete grammar rule (RHS) and replaces it to (LHS), it is known as reduce-step. This occurs when the top of the stack contains a handle. To reduce, a POP function is performed on the stack which pops off the handle and replaces it with LHS non-terminal symbol.</p>

<h3>LR Parser</h3>

<p>The LR parser is a non-recursive, shift-reduce, bottom-up parser. It uses a wide class of context-free grammar which makes it the most efficient syntax analysis technique. LR parsers are also known as LR(k) parsers, where L stands for left-to-right scanning of the input stream; R stands for the construction of right-most derivation in reverse, and k denotes the number of lookahead symbols to make decisions.</p>

<p>There are three widely used algorithms available for constructing an LR parser:</p>

<h3>LR Parsing Algorithm</h3>

<p>Here we describe a skeleton algorithm of an LR parser:</p>

<h3>LL vs. LR</h3>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
token = next_token()

repeat forever
   s = top of stack
   
   if action[s, token] = “shift si” then
      PUSH token
      PUSH si 
      token = next_token()
      
   else if action[s, token] = “reduce A::= β“ then 
      POP 2 * |β| symbols
      s = top of stack
      PUSH A
      PUSH goto[s,A]
      
   else if action[s, token] = “accept” then
      return
      
   else
      error()
</pre>

<title>Compiler Design - Error Recovery</title>

<h1>Compiler Design - Error Recovery</h1>

<p>A parser should be able to detect and report any error in the program. It is expected that when an error is encountered, the parser should be able to handle it and carry on parsing the rest of the input. Mostly it is expected from the parser to check for errors but errors may be encountered at various stages of the compilation process. A program may have the following kinds of errors at various stages:</p>

<p><b>Lexical</b> : name of some identifier typed incorrectly</p>

<p><b>Syntactical</b> : missing semicolon or unbalanced parenthesis</p>

<p><b>Semantical</b> : incompatible value assignment</p>

<p><b>Logical</b> : code not reachable, infinite loop</p>

<p>There are four common error-recovery strategies that can be implemented in the parser to deal with errors in the code.</p>

<h3>Panic mode</h3>

<p>When a parser encounters an error anywhere in the statement, it ignores the rest of the statement by not processing input from erroneous input to delimiter, such as semi-colon. This is the easiest way of error-recovery and also, it prevents the parser from developing infinite loops.</p>

<h3>Statement mode</h3>

<p>When a parser encounters an error, it tries to take corrective measures so that the rest of inputs of statement allow the parser to parse ahead. For example, inserting a missing semicolon, replacing comma with a semicolon etc. Parser designers have to be careful here because one wrong correction may lead to an infinite loop.</p>

<h3>Error productions</h3>

<p>Some common errors are known to the compiler designers that may occur in the code. In addition, the designers can create augmented grammar to be used, as productions that generate erroneous constructs when these errors are encountered.</p>

<h3>Global correction</h3>

<p>The parser considers the program in hand as a whole and tries to figure out what the program is intended to do and tries to find out a closest match for it, which is error-free. When an erroneous input (statement) X is fed, it creates a parse tree for some closest error-free statement Y. This may allow the parser to make minimal changes in the source code, but due to the complexity (time and space) of this strategy, it has not been implemented in practice yet.</p>

<h3>Abstract Syntax Trees</h3>

<p>Parse tree representations are not easy to be parsed by the compiler, as they contain more details than actually needed. Take the following parse tree as an example:</p>

<p>If watched closely, we find most of the leaf nodes are single child to their parent nodes. This information can be eliminated before feeding it to the next phase. By hiding extra information, we can obtain a tree as shown below:</p>

<p>Abstract tree can be represented as:</p>

<p>ASTs are important data structures in a compiler with least unnecessary information. ASTs are more compact than a parse tree and can be easily used by a compiler.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Compiler Design - Semantic Analysis</title>

<h1>Compiler Design - Semantic Analysis</h1>

<p>We have learnt how a parser constructs parse trees in the syntax analysis phase. The plain parse-tree constructed in that phase is generally of no use for a compiler, as it does not carry any information of how to evaluate the tree. The productions of context-free grammar, which makes the rules of the language, do not accommodate how to interpret them.</p>

<p>For example</p>

<p>The above CFG production has no semantic rule associated with it, and it cannot help in making any sense of the production.</p>

<h2>Semantics</h2>

<p>Semantics of a language provide meaning to its constructs, like tokens and syntax structure. Semantics help interpret symbols, their types, and their relations with each other. Semantic analysis judges whether the syntax structure constructed in the source program derives any meaning or not.</p>

<p>For example:</p>

<p>should not issue an error in lexical and syntax analysis phase, as it is lexically and structurally correct, but it should generate a semantic error as the type of the assignment differs. These rules are set by the grammar of the language and evaluated in semantic analysis. The following tasks should be performed in semantic analysis:</p>

<h2>Semantic Errors</h2>

<p>We have mentioned some of the semantics errors that the semantic analyzer is expected to recognize:</p>

<h2>Attribute Grammar</h2>

<p>Attribute grammar is a special form of context-free grammar where some additional information (attributes) are appended to one or more of its non-terminals in order to provide context-sensitive information. Each attribute has well-defined domain of values, such as integer, float, character, string, and expressions.</p>

<p>Attribute grammar is a medium to provide semantics to the context-free grammar and it can help specify the syntax and semantics of a programming language. Attribute grammar (when viewed as a parse-tree) can pass values or information among the nodes of a tree.</p>

<p><b>Example:</b></p>

<p>The right part of the CFG contains the semantic rules that specify how the grammar should be interpreted. Here, the values of non-terminals E and T are added together and the result is copied to the non-terminal E.</p>

<p>Semantic attributes may be assigned to their values from their domain at the time of parsing and evaluated at the time of assignment or conditions. Based on the way the attributes get their values, they can be broadly divided into two categories : synthesized attributes and inherited attributes.</p>

<h3>Synthesized attributes</h3>

<p>These attributes get values from the attribute values of their child nodes. To illustrate, assume the following production:</p>

<p>If S is taking values from its child nodes (A,B,C), then it is said to be a synthesized attribute, as the values of ABC are synthesized to S.</p>

<p>As in our previous example (E → E + T), the parent node E gets its value from its child node. Synthesized attributes never take values from their parent nodes or any sibling nodes.</p>

<h3>Inherited attributes</h3>

<p>In contrast to synthesized attributes, inherited attributes can take values from parent and/or siblings. As in the following production,</p>

<p>A can get values from S, B and C. B can take values from S, A, and C. Likewise, C can take values from S, A, and B.</p>

<p><b>Expansion</b> : When a non-terminal is expanded to terminals as per a grammatical rule</p>

<p><b>Reduction</b> : When a terminal is reduced to its corresponding non-terminal according to grammar rules. Syntax trees are parsed top-down and left to right. Whenever reduction occurs, we apply its corresponding semantic rules (actions).</p>

<p>Semantic analysis uses Syntax Directed Translations to perform the above tasks.</p>

<p>Semantic analyzer receives AST (Abstract Syntax Tree) from its previous stage (syntax analysis).</p>

<p>Semantic analyzer attaches attribute information with AST, which are called Attributed AST.</p>

<p>Attributes are two tuple value, &lt;attribute name, attribute value&gt;</p>

<p>For example:</p>

<p>For every production, we attach a semantic rule.</p>

<h2>S-attributed SDT</h2>

<p>If an SDT uses only synthesized attributes, it is called as S-attributed SDT. These attributes are evaluated using S-attributed SDTs that have their semantic actions written after the production (right hand side).</p>

<p>As depicted above, attributes in S-attributed SDTs are evaluated in bottom-up parsing, as the values of the parent nodes depend upon the values of the child nodes.</p>

<h2>L-attributed SDT</h2>

<p>This form of SDT uses both synthesized and inherited attributes with restriction of not taking values from right siblings.</p>

<p>In L-attributed SDTs, a non-terminal can get values from its parent, child, and sibling nodes. As in the following production</p>

<p>S can take values from A, B, and C (synthesized). A can take values from S only. B can take values from S and A. C can get values from S, A, and B. No non-terminal can get values from the sibling to its right.</p>

<p>Attributes in L-attributed SDTs are evaluated by depth-first and left-to-right parsing manner.</p>

<p>We may conclude that if a definition is S-attributed, then it is also L-attributed as L-attributed definition encloses S-attributed definitions.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
E → E + T
</pre>
<p>The above CFG production has no semantic rule associated with it, and it cannot help in making any sense of the production.</p>
<h2>Semantics</h2>
<p>Semantics of a language provide meaning to its constructs, like tokens and syntax structure. Semantics help interpret symbols, their types, and their relations with each other. Semantic analysis judges whether the syntax structure constructed in the source program derives any meaning or not.</p>
<pre class="prettyprint notranslate">
CFG + semantic rules = Syntax Directed Definitions
</pre>
<p>For example:</p>
<pre class="prettyprint notranslate">
int a = “value”;
</pre>
<p>should not issue an error in lexical and syntax analysis phase, as it is lexically and structurally correct, but it should generate a semantic error as the type of the assignment differs. These rules are set by the grammar of the language and evaluated in semantic analysis. The following tasks should be performed in semantic analysis:</p>
<ul class="list">
<li>Scope resolution</li>
<li>Type checking</li>
<li>Array-bound checking<li>
</ul>
<h2>Semantic Errors</h2>
<p>We have mentioned some of the semantics errors that the semantic analyzer is expected to recognize:</p>
<ul class="list">
<li>Type mismatch</li>
<li>Undeclared variable</li>
<li>Reserved identifier misuse.</li>
<li>Multiple declaration of variable in a scope.</li>
<li>Accessing an out of scope variable.</li>
<li>Actual and formal parameter mismatch.</li>
</ul>
<h2>Attribute Grammar</h2>
<p>Attribute grammar is a special form of context-free grammar where some additional information (attributes) are appended to one or more of its non-terminals in order to provide context-sensitive information. Each attribute has well-defined domain of values, such as integer, float, character, string, and expressions.</p>
<p>Attribute grammar is a medium to provide semantics to the context-free grammar and it can help specify the syntax and semantics of a programming language. Attribute grammar (when viewed as a parse-tree) can pass values or information among the nodes of a tree.</p>
<p><b>Example:</b></p>
<pre class="prettyprint notranslate">
E → E + T { E.value = E.value + T.value }
</pre>
<p>The right part of the CFG contains the semantic rules that specify how the grammar should be interpreted. Here, the values of non-terminals E and T are added together and the result is copied to the non-terminal E.</p>
<p>Semantic attributes may be assigned to their values from their domain at the time of parsing and evaluated at the time of assignment or conditions. Based on the way the attributes get their values, they can be broadly divided into two categories : synthesized attributes and inherited attributes.</p>
<h3>Synthesized attributes</h3>
<p>These attributes get values from the attribute values of their child nodes. To illustrate, assume the following production:</p>
<pre class="prettyprint notranslate">
S → ABC
</pre>
<p>If S is taking values from its child nodes (A,B,C), then it is said to be a synthesized attribute, as the values of ABC are synthesized to S.</p>
<p>As in our previous example (E → E + T), the parent node E gets its value from its child node. Synthesized attributes never take values from their parent nodes or any sibling nodes.</p>
<h3>Inherited attributes</h3>
<p>In contrast to synthesized attributes, inherited attributes can take values from parent and/or siblings. As in the following production,</p>
<pre class="prettyprint notranslate">
S → ABC
</pre>
<p>A can get values from S, B and C. B can take values from S, A, and C. Likewise, C can take values from S, A, and B.</p>
<p><b>Expansion</b> : When a non-terminal is expanded to terminals as per a grammatical rule</p>
<img src="/compiler_design/images/inherited_attributes.jpg" alt="Inherited Attributes" />
<p><b>Reduction</b> : When a terminal is reduced to its corresponding non-terminal according to grammar rules. Syntax trees are parsed top-down and left to right. Whenever reduction occurs, we apply its corresponding semantic rules (actions).</p>
<p>Semantic analysis uses Syntax Directed Translations to perform the above tasks.</p>
<p>Semantic analyzer receives AST (Abstract Syntax Tree) from its previous stage (syntax analysis).</p>
<p>Semantic analyzer attaches attribute information with AST, which are called Attributed AST.</p>
<p>Attributes are two tuple value, &lt;attribute name, attribute value&gt;</p>
<p>For example:</p>
<pre class="prettyprint notranslate">
int value  = 5;
&lt;type, “integer”&gt;
&lt;presentvalue, “5”&gt;
</pre>
<p>For every production, we attach a semantic rule.</p>
<h2>S-attributed SDT</h2>
<p>If an SDT uses only synthesized attributes, it is called as S-attributed SDT. These attributes are evaluated using S-attributed SDTs that have their semantic actions written after the production (right hand side).</p>
<img src="/compiler_design/images/s_attributed_sdt.jpg" alt="S-attributed SDT" />
<p>As depicted above, attributes in S-attributed SDTs are evaluated in bottom-up parsing, as the values of the parent nodes depend upon the values of the child nodes.</p>
<h2>L-attributed SDT</h2>
<p>This form of SDT uses both synthesized and inherited attributes with restriction of not taking values from right siblings.</p>
<p>In L-attributed SDTs, a non-terminal can get values from its parent, child, and sibling nodes. As in the following production</p>
<pre class="prettyprint notranslate">
S → ABC
</pre>

<title>Compiler Design - Run-Time Environment</title>

<h1>Compiler Design - Run-Time Environment</h1>

<p>A program as a source code is merely a collection of text (code, statements etc.) and to make it alive, it requires actions to be performed on the target machine. A program needs memory resources to execute instructions. A program contains names for procedures, identifiers etc., that require mapping with the actual memory location at runtime.</p>

<p>By runtime, we mean a program in execution. Runtime environment is a state of the target machine, which may include software libraries, environment variables, etc., to provide services to the processes running in the system.</p>

<p>Runtime support system is a package, mostly generated with the executable program itself and facilitates the process communication between the process and the runtime environment. It takes care of memory allocation and de-allocation while the program is being executed.</p>

<h2>Activation Trees</h2>

<p>A program is a sequence of instructions combined into a number of procedures.  Instructions in a procedure are executed sequentially. A procedure has a start and an end delimiter and everything inside it is called the body of the procedure. The procedure identifier and the sequence of finite instructions inside it make up the body of the procedure.</p>

<p>The execution of a procedure is called its activation. An activation record contains all the necessary information required to call a procedure. An activation record may contain the following units (depending upon the source language used).</p>

<p>Whenever a procedure is executed, its activation record is stored on the stack, also known as control stack. When a procedure calls another procedure, the execution of the caller is suspended until the called procedure finishes execution. At this time, the activation record of the called procedure is stored on the stack.</p>

<p>We assume that the program control flows in a sequential manner and when a procedure is called, its control is transferred to the called procedure. When a called procedure is executed, it returns the control back to the caller. This type of control flow makes it easier to represent a series of activations in the form of a tree, known as the <b>activation tree</b>.</p>

<p>To understand this concept, we take a piece of code as an example:</p>

<p>Below is the activation tree of the code given.</p>

<p>Now we understand that procedures are executed in depth-first manner, thus stack allocation is the best suitable form of storage for procedure activations.</p>

<h2>Storage Allocation</h2>

<p>Runtime environment manages runtime memory requirements for the following entities:</p>

<p><b>Code</b> : It is known as the text part of a program that does not change at runtime. Its memory requirements are known at the compile time.</p>

<p><b>Procedures</b> : Their text part is static but they are called in a random manner. That is why, stack storage is used to manage procedure calls and activations.</p>

<p><b>Variables</b> : Variables are known at the runtime only, unless they are global or constant. Heap memory allocation scheme is used for managing allocation and de-allocation of memory for variables in runtime.</p>

<h2>Static Allocation</h2>

<p>In this allocation scheme, the compilation data is bound to a fixed location in the memory and it does not change when the program executes. As the memory requirement and storage locations are known in advance, runtime support package for memory allocation and de-allocation is not required.</p>

<h2>Stack Allocation</h2>

<p>Procedure calls and their activations are managed by means of stack memory allocation. It works in last-in-first-out (LIFO) method and this allocation strategy is very useful for recursive procedure calls.</p>

<h2>Heap Allocation</h2>

<p>Variables local to a procedure are allocated and de-allocated only at runtime. Heap allocation is used to dynamically allocate memory to the variables and claim it back when the variables are no more required.</p>

<p>Except statically allocated memory area, both stack and heap memory can grow and shrink dynamically and unexpectedly. Therefore, they cannot be provided with a fixed amount of memory in the system.</p>

<p>As shown in the image above, the text part of the code is allocated a fixed amount of memory. Stack and heap memory are arranged at the extremes of total memory allocated to the program. Both shrink and grow against each other.</p>

<h2>Parameter Passing</h2>

<p>The communication medium among procedures is known as parameter passing. The values of the variables from a calling procedure are transferred to the called procedure by some mechanism. Before moving ahead, first go through some basic terminologies pertaining to the values in a program.</p>

<h3>r-value</h3>

<p>The value of an expression is called its r-value. The value contained in a single variable also becomes an r-value if it appears on the right-hand side of the assignment operator. r-values can always be assigned to some other variable.</p>

<h3>l-value</h3>

<p>The location of memory (address) where an expression is stored is known as the l-value of that expression. It always appears at the left hand side of an assignment operator.</p>

<p>For example:</p>

<p>From this example, we understand that constant values like 1, 7, 12, and variables like day, week, month and year, all have r-values. Only variables have l-values as they also represent the memory location assigned to them.</p>

<p>For example:</p>

<p>is an l-value error, as the constant 7 does not represent any memory location.</p>

<h2>Formal Parameters</h2>

<p>Variables that take the information passed by the caller procedure are called formal parameters. These variables are declared in the definition of the called function.</p>

<h2>Actual Parameters</h2>

<p>Variables whose values or addresses are being passed to the called procedure are called actual parameters. These variables are specified in the function call as arguments.</p>

<p><b>Example:</b></p>

<p>Formal parameters hold the information of the actual parameter, depending upon the parameter passing technique used. It may be a value or an address.</p>

<h2>Pass by Value</h2>

<p>In pass by value mechanism, the calling procedure passes the r-value of actual parameters and the compiler puts that into the called procedure’s activation record. Formal parameters then hold the values passed by the calling procedure. If the values held by the formal parameters are changed, it should have no impact on the actual parameters.</p>

<h2>Pass by Reference</h2>

<p>In pass by reference mechanism, the l-value of the actual parameter is copied to the activation record of the called procedure. This way, the called procedure now has the address (memory location) of the actual parameter and the formal parameter refers to the same memory location. Therefore, if the value pointed by the formal parameter is changed, the impact should be seen on the actual parameter as they should also point to the same value.</p>

<h2>Pass by Copy-restore</h2>

<p>This parameter passing mechanism works similar to ‘pass-by-reference’ except that the changes to actual parameters are made when the called procedure ends. Upon function call, the values of actual parameters are copied in the activation record of the called procedure. Formal parameters if manipulated have no real-time effect on actual parameters (as l-values are passed), but when the called procedure ends, the l-values of formal parameters are copied to the l-values of actual parameters.</p>

<p><b>Example:</b></p>

<p>When this function ends, the l-value of formal parameter x is copied to the actual parameter y. Even if the value of y is changed before the procedure ends, the l-value of x is copied to the l-value of y making it behave like call by reference.</p>

<h2>Pass by Name</h2>

<p>Languages like Algol provide a new kind of parameter passing mechanism that works like preprocessor in C language. In pass by name mechanism, the name of the procedure being called is replaced by its actual body. Pass-by-name textually substitutes the argument expressions in a procedure call for the corresponding parameters in the body of the procedure so that it can now work on actual parameters, much like pass-by-reference.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
. . .
printf(“Enter Your Name: “);
scanf(“%s”, username);
show_data(username);
printf(“Press any key to continue…”);
. . .
int show_data(char *user)
   {
   printf(“Your name is %s”, username);
   return 0;
   }
. . . 
</pre>
<p>Below is the activation tree of the code given.</p>
<img src="/compiler_design/images/activation_tree.jpg" alt="Activation Tree" />
<p>Now we understand that procedures are executed in depth-first manner, thus stack allocation is the best suitable form of storage for procedure activations.</p>
<h2>Storage Allocation</h2>
<p>Runtime environment manages runtime memory requirements for the following entities:</p>
<ul class="list">
<li><p><b>Code</b> : It is known as the text part of a program that does not change at runtime. Its memory requirements are known at the compile time.</p></li>
<li><p><b>Procedures</b> : Their text part is static but they are called in a random manner. That is why, stack storage is used to manage procedure calls and activations.</p></li>
<li><p><b>Variables</b> : Variables are known at the runtime only, unless they are global or constant. Heap memory allocation scheme is used for managing allocation and de-allocation of memory for variables in runtime.</p></li>
</ul>
<h2>Static Allocation</h2>
<p>In this allocation scheme, the compilation data is bound to a fixed location in the memory and it does not change when the program executes. As the memory requirement and storage locations are known in advance, runtime support package for memory allocation and de-allocation is not required.</p>
<h2>Stack Allocation</h2>
<p>Procedure calls and their activations are managed by means of stack memory allocation. It works in last-in-first-out (LIFO) method and this allocation strategy is very useful for recursive procedure calls.</p>
<h2>Heap Allocation</h2>
<p>Variables local to a procedure are allocated and de-allocated only at runtime. Heap allocation is used to dynamically allocate memory to the variables and claim it back when the variables are no more required.</p>
<p>Except statically allocated memory area, both stack and heap memory can grow and shrink dynamically and unexpectedly. Therefore, they cannot be provided with a fixed amount of memory in the system.</p>
<img src="/compiler_design/images/heap_allocation.jpg" alt="Heap Allocation" />
<p>As shown in the image above, the text part of the code is allocated a fixed amount of memory. Stack and heap memory are arranged at the extremes of total memory allocated to the program. Both shrink and grow against each other.</p>
<h2>Parameter Passing</h2>
<p>The communication medium among procedures is known as parameter passing. The values of the variables from a calling procedure are transferred to the called procedure by some mechanism. Before moving ahead, first go through some basic terminologies pertaining to the values in a program.</p>
<h3>r-value</h3>
<p>The value of an expression is called its r-value. The value contained in a single variable also becomes an r-value if it appears on the right-hand side of the assignment operator. r-values can always be assigned to some other variable.</p>
<h3>l-value</h3>
<p>The location of memory (address) where an expression is stored is known as the l-value of that expression. It always appears at the left hand side of an assignment operator.</p>
<p>For example:</p>
<pre class="prettyprint notranslate">
day = 1;
week = day * 7;
month = 1;
year = month * 12;
</pre>
<p>From this example, we understand that constant values like 1, 7, 12, and variables like day, week, month and year, all have r-values. Only variables have l-values as they also represent the memory location assigned to them.</p>
<p>For example:</p>
<pre class="prettyprint notranslate">
7 = x + y;
</pre>
<p>is an l-value error, as the constant 7 does not represent any memory location.</p>
<h2>Formal Parameters</h2>
<p>Variables that take the information passed by the caller procedure are called formal parameters. These variables are declared in the definition of the called function.</p>
<h2>Actual Parameters</h2>
<p>Variables whose values or addresses are being passed to the called procedure are called actual parameters. These variables are specified in the function call as arguments.</p>
<p><b>Example:</b></p>
<pre class="prettyprint notranslate">
fun_one()
{
   int actual_parameter = 10;
   call fun_two(int actual_parameter);
}
   fun_two(int formal_parameter)
{
   print formal_parameter;
}
</pre>
<p>Formal parameters hold the information of the actual parameter, depending upon the parameter passing technique used. It may be a value or an address.</p>
<h2>Pass by Value</h2>
<p>In pass by value mechanism, the calling procedure passes the r-value of actual parameters and the compiler puts that into the called procedure’s activation record. Formal parameters then hold the values passed by the calling procedure. If the values held by the formal parameters are changed, it should have no impact on the actual parameters.</p>
<h2>Pass by Reference</h2>
<p>In pass by reference mechanism, the l-value of the actual parameter is copied to the activation record of the called procedure. This way, the called procedure now has the address (memory location) of the actual parameter and the formal parameter refers to the same memory location. Therefore, if the value pointed by the formal parameter is changed, the impact should be seen on the actual parameter as they should also point to the same value.</p>
<h2>Pass by Copy-restore</h2>
<p>This parameter passing mechanism works similar to ‘pass-by-reference’ except that the changes to actual parameters are made when the called procedure ends. Upon function call, the values of actual parameters are copied in the activation record of the called procedure. Formal parameters if manipulated have no real-time effect on actual parameters (as l-values are passed), but when the called procedure ends, the l-values of formal parameters are copied to the l-values of actual parameters.</p>
<p><b>Example:</b></p>
<pre class="prettyprint notranslate">
int y; 
calling_procedure() 
{
   y = 10;     
   copy_restore(y); //l-value of y is passed
   printf y; //prints 99 
}
copy_restore(int x) 
{     
   x = 99; // y still has value 10 (unaffected)
   y = 0; // y is now 0 
}
</pre>

<title>Compiler Design - Symbol Table</title>

<h1>Compiler Design - Symbol Table</h1>

<p>Symbol table is an important data structure created and maintained by compilers in order to store information about the occurrence of various entities such as variable names, function names, objects, classes, interfaces, etc. Symbol table is used by both the analysis and the synthesis parts of a compiler.</p>

<p>A symbol table may serve the following purposes depending upon the language in hand:</p>

<p>To store the names of all entities in a structured form at one place.</p>

<p>To verify if a variable has been declared.</p>

<p>To implement type checking, by verifying assignments and expressions in the source code are semantically correct.</p>

<p>To determine the scope of a name (scope resolution).</p>

<p>A symbol table is simply a table which can be either linear or a hash table. It maintains an entry for each name in the following format:</p>

<p>For example, if a symbol table has to store information about the following variable declaration:</p>

<p>then it should store the entry such as:</p>

<p>The attribute clause contains the entries related to the name.</p>

<h2>Implementation</h2>

<p>If a compiler is to handle a small amount of data, then the symbol table can be implemented as an unordered list, which is easy to code, but it is only suitable for small tables only. A symbol table can be implemented in one of the following ways:</p>

<p>Among all, symbol tables are mostly implemented as hash tables, where the source code symbol itself is treated as a key for the hash function and the return value is the information about the symbol.</p>

<h2>Operations</h2>

<p>A symbol table, either linear or hash, should provide the following operations.</p>

<h3>insert()</h3>

<p>This operation is more frequently used by analysis phase, i.e., the first half of the compiler where tokens are identified and names are stored in the table. This operation is used to add information in the symbol table about unique names occurring in the source code. The format or structure in which the names are stored depends upon the compiler in hand.</p>

<p>An attribute for a symbol in the source code is the information associated with that symbol. This information contains the value, state, scope, and type about the symbol. The insert() function takes the symbol and its attributes as arguments and stores the information in the symbol table.</p>

<p>For example:</p>

<p>should be processed by the compiler as:</p>

<h3>lookup()</h3>

<p>lookup() operation is used to search a name in the symbol table to determine:</p>

<p>The format of lookup() function varies according to the programming language. The basic format should match the following:</p>

<p>This method returns 0 (zero) if the symbol does not exist in the symbol table. If the symbol exists in the symbol table, it returns its attributes stored in the table.</p>

<h2>Scope Management</h2>

<p>A compiler maintains two types of symbol tables: a <b>global symbol table</b> which can be accessed by all the procedures and <b>scope symbol tables</b> that are created for each scope in the program.</p>

<p>To determine the scope of a name, symbol tables are arranged in hierarchical structure as shown in the example below:</p>

<p>The above program can be represented in a hierarchical structure of symbol tables:</p>

<p>The global symbol table contains names for one global variable (int value) and two procedure names, which should be available to all the child nodes shown above. The names mentioned in the pro_one symbol table (and all its child tables) are not available for pro_two symbols and its child tables.</p>

<p>This symbol table data structure hierarchy is stored in the semantic analyzer and whenever a name needs to be searched in a symbol table, it is searched using the following algorithm:</p>

<p>first a symbol will be searched in the current scope, i.e. current symbol table.</p>

<p>if a name is found, then search is completed, else it will be searched in the parent symbol table until,</p>

<p>either the name is found or global symbol table has been searched for the name.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
&lt;symbol name,  type,  attribute&gt;
</pre>
<p>For example, if a symbol table has to store information about the following variable declaration:</p>
<pre class="prettyprint notranslate">
static int interest;
</pre>
<p>then it should store the entry such as:</p>
<pre class="prettyprint notranslate">
&lt;interest, int, static&gt;
</pre>
<p>The attribute clause contains the entries related to the name.</p>
<h2>Implementation</h2>
<p>If a compiler is to handle a small amount of data, then the symbol table can be implemented as an unordered list, which is easy to code, but it is only suitable for small tables only. A symbol table can be implemented in one of the following ways:</p>
<ul class="list">
<li>Linear (sorted or unsorted) list</li>
<li>Binary Search Tree</li>
<li>Hash table</li>
</ul>
<p>Among all, symbol tables are mostly implemented as hash tables, where the source code symbol itself is treated as a key for the hash function and the return value is the information about the symbol.</p>
<h2>Operations</h2>
<p>A symbol table, either linear or hash, should provide the following operations.</p>
<h3>insert()</h3>
<p>This operation is more frequently used by analysis phase, i.e., the first half of the compiler where tokens are identified and names are stored in the table. This operation is used to add information in the symbol table about unique names occurring in the source code. The format or structure in which the names are stored depends upon the compiler in hand.</p>
<p>An attribute for a symbol in the source code is the information associated with that symbol. This information contains the value, state, scope, and type about the symbol. The insert() function takes the symbol and its attributes as arguments and stores the information in the symbol table.</p>
<p>For example:</p>
<pre class="prettyprint notranslate">
int a;
</pre>
<p>should be processed by the compiler as:</p>
<pre class="prettyprint notranslate">
insert(a, int);
</pre>
<h3>lookup()</h3>
<p>lookup() operation is used to search a name in the symbol table to determine:</p>
<ul class="list">
<li>if the symbol exists in the table.</li>
<li>if it is declared before it is being used.</li>
<li>if the name is used in the scope.</li>
<li>if the symbol is initialized.</li>
<li>if the symbol declared multiple times.</li>
</ul>
<p>The format of lookup() function varies according to the programming language. The basic format should match the following:</p>
<pre class="prettyprint notranslate">
lookup(symbol)
</pre>
<p>This method returns 0 (zero) if the symbol does not exist in the symbol table. If the symbol exists in the symbol table, it returns its attributes stored in the table.</p>
<h2>Scope Management</h2>
<p>A compiler maintains two types of symbol tables: a <b>global symbol table</b> which can be accessed by all the procedures and <b>scope symbol tables</b> that are created for each scope in the program.</p>
<p>To determine the scope of a name, symbol tables are arranged in hierarchical structure as shown in the example below:</p>
<pre class="prettyprint notranslate">
. . . 
int value=10;

void pro_one()
   {
   int one_1;
   int one_2;
   
      {              \
      int one_3;      |_  inner scope 1 
      int one_4;      | 
      }              /
      
   int one_5; 
   
      {              \   
      int one_6;      |_  inner scope 2
      int one_7;      |
      }              /
   }
   
void pro_two()
   {
   int two_1;
   int two_2;
   
      {              \
      int two_3;      |_  inner scope 3
      int two_4;      |
      }              /
      
   int two_5;
   }
. . . 
</pre>

<title>Compiler Design - Intermediate Code Generation</title>

<h1>Compiler - Intermediate Code Generation</h1>

<p>A source code can directly be translated into its target machine code, then why at all we need to translate the source code into an intermediate code which is then translated to its target code? Let us see the reasons why we need an intermediate code.</p>

<p>If a compiler translates the source language to its target machine language without having the option for generating intermediate code, then for each new machine, a full native compiler is required.</p>

<p>Intermediate code eliminates the need of a new full compiler for every unique machine by keeping the analysis portion same for all the compilers.</p>

<p>The second part of compiler, synthesis, is changed according to the target machine.</p>

<p>It becomes easier to apply the source code modifications to improve code performance by applying code optimization techniques on the intermediate code.</p>

<h2>Intermediate Representation</h2>

<p>Intermediate codes can be represented in a variety of ways and they have their own benefits.</p>

<p><b>High Level IR</b> -	High-level intermediate code representation is very close to the source language itself. They can be easily generated from the source code and we can easily apply code modifications to enhance performance. But for target machine optimization, it is less preferred.</p>

<p><b>Low Level IR</b> -	This one is close to the target machine, which makes it suitable for register and memory allocation, instruction set selection, etc. It is good for machine-dependent optimizations.</p>

<p>Intermediate code can be either language specific (e.g., Byte Code for Java) or language independent (three-address code).</p>

<h2>Three-Address Code</h2>

<p>Intermediate code generator receives input from its predecessor phase, semantic analyzer, in the form of an annotated syntax tree. That syntax tree then can be converted into a linear representation, e.g., postfix notation. Intermediate code tends to be machine independent code. Therefore, code generator assumes to have unlimited number of memory storage (register) to generate code.</p>

<p>For example:</p>

<p>The intermediate code generator will try to divide this expression into sub-expressions and then generate the corresponding code.</p>

<p>r being used as registers in the target program.</p>

<p>A three-address code has at most three address locations to calculate the expression. A three-address code can be represented in two forms : quadruples and triples.</p>

<h3>Quadruples</h3>

<p>Each instruction in quadruples presentation is divided into four fields: operator, arg1, arg2, and result. The above example is represented below in quadruples format:</p>

<h3>Triples</h3>

<p>Triples face the problem of code immovability while optimization, as the results are positional and changing the order or position of an expression may cause problems.</p>

<h3>Indirect Triples</h3>

<p>This representation is an enhancement over triples representation. It uses pointers instead of position to store results. This enables the optimizers to freely re-position the sub-expression to produce an optimized code.</p>

<h2>Declarations</h2>

<p>A variable or procedure has to be declared before it can be used. Declaration involves allocation of space in memory and entry of type and name in the symbol table. A program may be coded and designed keeping the target machine structure in mind, but it may not always be possible to accurately convert a source code to its target language.</p>

<p>Taking the whole program as a collection of procedures and sub-procedures, it becomes possible to declare all the names local to the procedure. Memory allocation is done in a consecutive manner and names are allocated to memory in the sequence they are declared in the program. We use offset variable and set it to zero {offset = 0} that denote the base address.</p>

<p>The source programming language and the target machine architecture may vary in the way names are stored, so relative addressing is used. While the first name is allocated memory starting from the memory location 0 {offset=0}, the next name declared later, should be allocated memory next to the first one.</p>

<p><b>Example:</b></p>

<p>We take the example of C programming language where an integer variable is assigned 2 bytes of memory and a float variable is assigned 4 bytes of memory.</p>

<p>To enter this detail in a symbol table, a procedure <i>enter</i> can be used. This method may have the following structure:</p>

<p>This procedure should create an entry in the symbol table, for variable <i>name</i>, having its type set to type and relative address <i>offset</i> in its data area.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
a = b + c * d;
</pre>
<p>The intermediate code generator will try to divide this expression into sub-expressions and then generate the corresponding code.</p>
<pre class="prettyprint notranslate">
r1 = c * d;
r2 = b + r1;
a = r2
</pre>
<p>r being used as registers in the target program.</p>
<p>A three-address code has at most three address locations to calculate the expression. A three-address code can be represented in two forms : quadruples and triples.</p>
<h3>Quadruples</h3>
<p>Each instruction in quadruples presentation is divided into four fields: operator, arg1, arg2, and result. The above example is represented below in quadruples format:</p>
<table class="table table-bordered">
<tr>
<td>Op</td>
<td>arg<sub>1</sub></td>
<td>arg<sub>2</sub></td>
<td>result</td>
</tr>
<tr>
<td>*</td>
<td>c</td>
<td>d</td>
<td>r1</td>
</tr>
<tr>
<td>+</td>
<td>b</td>
<td>r1</td>
<td>r2</td>
</tr>
<tr>
<td>+</td>
<td>r2</td>
<td>r1</td>
<td>r3</td>
</tr>
<tr>
<td>=</td>
<td>r3</td>
<td></td>
<td>a</td>
</tr>
</table>
<h3>Triples</h3>
<p>Each instruction in triples presentation has three fields : op, arg1, and arg2.The results of respective sub-expressions are denoted by the position of expression. Triples
represent similarity with DAG and syntax tree. They are equivalent to DAG while representing expressions.</p>
<table class="table table-bordered">
<tr>
<td>Op</td>
<td>arg<sub>1</sub></td>
<td>arg<sub>2</sub></td>
</tr>
<tr>
<td>*</td>
<td>c</td>
<td>d</td>
</tr>
<tr>
<td>+</td>
<td>b</td>
<td>(0)</td>
</tr>
<tr>
<td>+</td>
<td>(1)</td>
<td>(0)</td>
</tr>
<tr>
<td>=</td>
<td>(2)</td>
<td></td>
</tr>
</table>
<p>Triples face the problem of code immovability while optimization, as the results are positional and changing the order or position of an expression may cause problems.</p>
<h3>Indirect Triples</h3>
<p>This representation is an enhancement over triples representation. It uses pointers instead of position to store results. This enables the optimizers to freely re-position the sub-expression to produce an optimized code.</p>
<h2>Declarations</h2>
<p>A variable or procedure has to be declared before it can be used. Declaration involves allocation of space in memory and entry of type and name in the symbol table. A program may be coded and designed keeping the target machine structure in mind, but it may not always be possible to accurately convert a source code to its target language.</p>
<p>Taking the whole program as a collection of procedures and sub-procedures, it becomes possible to declare all the names local to the procedure. Memory allocation is done in a consecutive manner and names are allocated to memory in the sequence they are declared in the program. We use offset variable and set it to zero {offset = 0} that denote the base address.</p> 
<p>The source programming language and the target machine architecture may vary in the way names are stored, so relative addressing is used. While the first name is allocated memory starting from the memory location 0 {offset=0}, the next name declared later, should be allocated memory next to the first one.</p>
<p><b>Example:</b></p>
<p>We take the example of C programming language where an integer variable is assigned 2 bytes of memory and a float variable is assigned 4 bytes of memory.</p>
<pre class="prettyprint notranslate">
int a;
float b;

Allocation process:
{offset = 0}

   int a;
   id.type = int
   id.width = 2

offset = offset + id.width 
{offset = 2}

   float b;
   id.type = float
   id.width = 4
   
offset = offset + id.width 
{offset = 6}
</pre>
<p>To enter this detail in a symbol table, a procedure <i>enter</i> can be used. This method may have the following structure:</p>
<pre class="prettyprint notranslate">
enter(name, type, offset)
</pre>

<title>Compiler Design - Code Generation</title>

<h1>Compiler Design - Code Generation</h1>

<p>Code generation can be considered as the final phase of compilation. Through post code generation, optimization process can be applied on the code, but that can be seen as a part of code generation phase itself. The code generated by the compiler is an object code of some lower-level programming language, for example, assembly language. We have seen that the source code written in a higher-level language is transformed into a lower-level language that results in a lower-level object code, which should have the following minimum properties:</p>

<p>We will now see how the intermediate code is transformed into target object code (assembly code, in this case).</p>

<h2>Directed Acyclic Graph</h2>

<p>Directed Acyclic Graph (DAG) is a tool that depicts the structure of basic blocks, helps to see the flow of values flowing among the basic blocks, and offers optimization too. DAG provides easy transformation on basic blocks. DAG can be understood here:</p>

<p>Leaf nodes represent identifiers, names or constants.</p>

<p>Interior nodes represent operators.</p>

<p>Interior nodes also represent the results of expressions or the identifiers/name where the values are to be stored or assigned.</p>

<p><b>Example:</b></p>

<p>[t<sub>0</sub> = a + b]</p>

<p>[t<sub>1</sub> = t<sub>0</sub> + c]</p>

<p>[d = t<sub>0</sub> + t<sub>1</sub>]</p>

<h2>Peephole Optimization</h2>

<p>This optimization technique works locally on the source code to transform it into an optimized code. By locally, we mean a small portion of the code block at hand. These methods can be applied on intermediate codes as well as on target codes. A bunch of statements is analyzed and are checked for the following possible optimization:</p>

<h3>Redundant instruction elimination</h3>

<p>At source code level, the following can be done by the user:</p>

<p>At compilation level, the compiler searches for instructions redundant in nature. Multiple loading and storing of instructions may carry the same meaning even if some of them are removed. For example:</p>

<p>We can delete the first instruction and re-write the sentence as:</p>

<h3>Unreachable code</h3>

<p>Unreachable code is a part of the program code that is never accessed because of programming constructs. Programmers may have accidently written a piece of code that can never be reached.</p>

<p><b>Example:</b></p>

<p>In this code segment, the <b>printf</b> statement will never be executed as the program control returns back before it can execute, hence <b>printf</b> can be removed.</p>

<h3>Flow of control optimization</h3>

<p>There are instances in a code where the program control jumps back and forth without performing any significant task. These jumps can be removed. Consider the following chunk of code:</p>

<p>In this code,label L1 can be removed as it  passes the control to L2. So instead of jumping to L1 and then to L2, the control can directly reach L2, as shown below:</p>

<h3>Algebraic expression simplification</h3>

<p>There are occasions where algebraic expressions can be made simple. For example, the expression <b>a = a + 0</b> can be replaced by <b>a</b> itself and the expression a = a + 1 can simply be replaced by INC a.</p>

<h3>Strength reduction</h3>

<p>There are operations that consume more time and space. Their ‘strength’ can be reduced by replacing them with other operations that consume less time and space, but produce the same result.</p>

<p>For example, <b>x * 2</b> can be replaced by <b>x << 1</b>, which involves only one left shift. Though the output of a * a and a<sup>2</sup> is same, a<sup>2</sup> is much more efficient to implement.</p>

<h3>Accessing machine instructions</h3>

<p>The target machine can deploy more sophisticated instructions, which can have the capability to perform specific operations much efficiently. If the target code can accommodate those instructions directly, that will not only improve the quality of code, but also yield more efficient results.</p>

<h2>Code Generator</h2>

<p>A code generator is expected to have an understanding of the target machine’s runtime environment and its instruction set. The code generator should take the following things into consideration to generate the code:</p>

<p><b>Target language</b> : The code generator has to be aware of the nature of the target language for which the code is to be transformed. That language may facilitate some machine-specific instructions to help the compiler generate the code in a more convenient way. The target machine can have either CISC or RISC processor architecture.</p>

<p><b>IR Type</b> :	Intermediate representation has various forms. It can be in Abstract Syntax Tree (AST) structure, Reverse Polish Notation, or 3-address code.</p>

<p><b>Selection of instruction</b> : The code generator takes Intermediate Representation as input and converts (maps) it into target machine’s instruction set. One representation can have many ways (instructions) to convert it, so it becomes the responsibility of the code generator to choose the appropriate instructions wisely.</p>

<p><b>Register allocation</b> :	A program has a number of values to be maintained during the execution. The target machine’s architecture may not allow all of the values to be kept in the CPU memory or registers. Code generator decides what values to keep in the registers. Also, it decides the registers to be used to keep these values.</p>

<p><b>Ordering of instructions</b> : At last, the code generator decides the order in which the instruction will be executed. It creates schedules for instructions to execute them.</p>

<h2>Descriptors</h2>

<p>The code generator has to track both the registers (for availability) and addresses (location of values) while generating the code. For both of them, the following two descriptors are used:</p>

<p><b>Register descriptor</b> :	Register descriptor is used to inform the code generator about the availability of registers. Register descriptor keeps track of values stored in each register. Whenever a new register is required during code generation, this descriptor is consulted for register availability.</p>

<p><b>Address descriptor</b> : Values of the names (identifiers) used in the program might be stored at different locations while in execution. Address descriptors are used to keep track of memory locations where the values of identifiers are stored. These locations may include CPU registers, heaps, stacks, memory or a combination of the mentioned locations.</p>

<p>Code generator keeps both the descriptor updated in real-time. For a load statement, LD R1, x, the code generator:</p>

<h2>Code Generation</h2>

<p>Basic blocks comprise of a sequence of three-address instructions. Code generator takes these sequence of instructions as input.</p>

<p><b>Note</b> : If the value of a name is found at more than one place (register, cache, or memory), the register’s value will be preferred over the cache and main memory. Likewise cache’s value will be preferred over the main memory. Main memory is barely given any preference.</p>

<p><b>getReg</b> : Code generator uses <i>getReg</i> function to determine the status of available registers and the location of name values. <i>getReg</i> works as follows:</p>

<p>If variable Y is already in register R, it uses that register.</p>

<p>Else if some register R is available, it uses that register.</p>

<p>Else if both the above options are not possible, it chooses a register that requires minimal number of load and store instructions.</p>

<p>For an instruction x = y OP z, the code generator may perform the following actions. Let us assume that L is the location (preferably register) where the output of y OP z is to be saved:</p>

<p>Call function getReg, to decide the location of L.</p>

<p>Determine the present location (register or memory) of <b>y</b> by consulting the Address Descriptor of <b>y</b>. If <b>y</b> is not presently in register <b>L</b>, then generate the following instruction to copy the value of <b>y</b> to <b>L</b>:</p>

<p>MOV y’, L</p>

<p>where <b>y’</b> represents the copied value of <b>y</b>.</p>

<p>Determine the present location of <b>z</b> using the same method used in step 2 for <b>y</b> and generate the following instruction:</p>

<p>OP z’, L</p>

<p>where <b>z’</b> represents the copied value of <b>z</b>.</p>

<p>Now L contains the value of y OP z, that is intended to be assigned to <b>x</b>. So, if L is a register, update its descriptor to indicate that it contains the value of <b>x</b>. Update the descriptor of <b>x</b> to indicate that it is stored at location <b>L</b>.</p>

<p>If y and z has no further use, they can be given back to the system.</p>

<p>Other code constructs like loops and conditional statements are transformed into assembly language in general assembly way.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
t<sub>0</sub> = a + b
t<sub>1</sub> = t<sub>0</sub> + c
d = t<sub>0</sub> + t<sub>1</sub>
</pre>
<table class="table table-bordered">
<tr>
<td>
<img src="/compiler_design/images/directed_acyclic_graph_1.jpg" alt="Directed Acyclic Graph" />
<p>[t<sub>0</sub> = a + b]</p>
</td>
<td>
<img src="/compiler_design/images/directed_acyclic_graph_2.jpg" alt="Directed Acyclic Graph" />
<p>[t<sub>1</sub> = t<sub>0</sub> + c]</p>
</td>
<td>
<img src="/compiler_design/images/directed_acyclic_graph_3.jpg" alt="Directed Acyclic Graph" />
<p>[d = t<sub>0</sub> + t<sub>1</sub>]</p>
</td>
</tr>
</table>
<h2>Peephole Optimization</h2>
<p>This optimization technique works locally on the source code to transform it into an optimized code. By locally, we mean a small portion of the code block at hand. These methods can be applied on intermediate codes as well as on target codes. A bunch of statements is analyzed and are checked for the following possible optimization:</p>
<h3>Redundant instruction elimination</h3>
<p>At source code level, the following can be done by the user:</p>
<table class="table table-bordered">
<tr>
<td style="padding:3px;">
<pre class="prettyprint notranslate">
int add_ten(int x)
   {
   int y, z;
   y = 10;
   z = x + y;
   return z;
   }
</pre>
</td>
<td style="padding:3px;">
<pre class="prettyprint notranslate">
int add_ten(int x)
   {
   int y;
   y = 10;
   y = x + y;
   return y;
   }
</pre>
</td>
<td style="padding:3px;">
<pre class="prettyprint notranslate">
int add_ten(int x)
   {
   int y = 10;
   return x + y;
   }
   
   
</pre>
</td>
<td style="padding:3px;">
<pre class="prettyprint notranslate">
int add_ten(int x)
   {
   return x + 10;
   }
   
   
   
</pre>
</td>
</tr>
</table>
<p>At compilation level, the compiler searches for instructions redundant in nature. Multiple loading and storing of instructions may carry the same meaning even if some of them are removed. For example:</p>
<ul class="list">
<li>MOV x, R0</li>
<li>MOV R0, R1</li>
</ul>
<p>We can delete the first instruction and re-write the sentence as:</p>
<pre class="prettyprint notranslate">
MOV x, R1
</pre>

<h3>Unreachable code</h3>
<p>Unreachable code is a part of the program code that is never accessed because of programming constructs. Programmers may have accidently written a piece of code that can never be reached.</p>
<p><b>Example:</b></p>
<pre class="prettyprint notranslate">
void add_ten(int x)
{
   return x + 10;
   printf(“value of x is %d”, x);
}
</pre>
<p>In this code segment, the <b>printf</b> statement will never be executed as the program control returns back before it can execute, hence <b>printf</b> can be removed.</p>
<h3>Flow of control optimization</h3>
<p>There are instances in a code where the program control jumps back and forth without performing any significant task. These jumps can be removed. Consider the following chunk of code:</p>
<pre class="prettyprint notranslate">
...		
MOV R1, R2
GOTO L1
...
L1 :   GOTO L2
L2 :   INC R1
</pre>
<p>In this code,label L1 can be removed as it  passes the control to L2. So instead of jumping to L1 and then to L2, the control can directly reach L2, as shown below:</p>
<pre class="prettyprint notranslate">
...		
MOV R1, R2
GOTO L2
...
L2 :   INC R1
</pre>

<title>Compiler Design - Code Optimization</title>

<h1>Compiler Design - Code Optimization</h1>

<p>Optimization is a program transformation technique, which tries to improve the code by making it consume less resources (i.e. CPU, Memory) and deliver high speed.</p>

<p>In optimization, high-level general programming constructs are replaced by very efficient low-level programming codes. A code optimizing process must follow the three rules given below:</p>

<p>The output code must not, in any way, change the meaning of the program.</p>

<p>Optimization should increase the speed of the program and if possible, the program should demand less number of resources.</p>

<p>Optimization should itself be fast and should not delay the overall compiling process.</p>

<p>Efforts for an optimized code can be made at various levels of compiling the process.</p>

<p>At the beginning, users can change/rearrange the code or use better algorithms to write the code.</p>

<p>After generating intermediate code, the compiler can modify the intermediate code by address calculations and improving loops.</p>

<p>While producing the target machine code, the compiler can make use of memory hierarchy and CPU registers.</p>

<p>Optimization can be categorized broadly into two types : machine independent and machine dependent.</p>

<h2>Machine-independent Optimization</h2>

<p>In this optimization, the compiler takes in the intermediate code and transforms a part of the code that does not involve any CPU registers and/or absolute memory locations. For example:</p>

<p>This code involves repeated assignment of the identifier item, which if we put this way:</p>

<p>should not only save the CPU cycles, but  can be used on any processor.</p>

<h2>Machine-dependent Optimization</h2>

<p>Machine-dependent optimization is done after the target code has been generated and when the code is transformed according to the target machine architecture. It involves CPU registers and may have absolute memory references rather than relative references. Machine-dependent optimizers put efforts to take maximum advantage of memory hierarchy.</p>

<h2>Basic Blocks</h2>

<p>Source codes generally have a number of instructions, which are always executed in sequence and are considered as the basic blocks of the code. These basic blocks do not have any jump statements among them, i.e., when the first instruction is executed, all the instructions in the same basic block will be executed in their sequence of appearance without losing the flow control of the program.</p>

<p>A program can have various constructs as basic blocks, like IF-THEN-ELSE, SWITCH-CASE conditional statements and loops such as DO-WHILE, FOR, and REPEAT-UNTIL, etc.</p>

<h3>Basic block identification</h3>

<p>We may use the following algorithm to find the basic blocks in a program:</p>

<p>Search header statements of all the basic blocks from where a basic block starts:</p>

<p>Header statements and the statements following them form a basic block.</p>

<p>A basic block does not include any header statement of any other basic block.</p>

<p>Basic blocks are important concepts from both code generation and optimization point of view.</p>

<p>Basic blocks play an important role in identifying variables, which are being used more than once in a single basic block. If any variable is being used more than once, the register memory allocated to that variable need not be emptied unless the block finishes execution.</p>

<h3>Control Flow Graph</h3>

<p>Basic blocks in a program can be represented by means of control flow graphs. A control flow graph depicts how the program control is being passed among the blocks. It is a useful tool that helps in optimization by help locating any unwanted loops in the program.</p>

<h2>Loop Optimization</h2>

<p>Most programs run as a loop in the system. It becomes necessary to optimize the loops in order to save CPU cycles and memory. Loops can be optimized by the following techniques:</p>

<p><b>Invariant code</b> : A fragment of code that resides in the loop and computes the same value at each iteration is called a loop-invariant code. This code can be moved out of the loop by saving it to be computed only once, rather than with each iteration.</p>

<p><b>Induction analysis</b> : A variable is called an induction variable if its value is altered within the loop by a loop-invariant value.</p>

<p><b>Strength reduction</b> : There are expressions that consume more CPU cycles, time, and memory. These expressions should be replaced with cheaper expressions without compromising the output of expression. For example, multiplication (x * 2) is expensive in terms of CPU cycles than (x << 1) and yields the same result.</p>

<h2>Dead-code Elimination</h2>

<p>Dead code is one or more than one code statements, which are:</p>

<p>Thus, dead code plays no role in any program operation and therefore it can simply be eliminated.</p>

<h3>Partially dead code</h3>

<p>There are some code statements whose computed values are used only under certain circumstances, i.e., sometimes the values are used and sometimes they are not. Such codes are known as partially dead-code.</p>

<p>The above control flow graph depicts a chunk of program where variable ‘a’ is used to assign the output of expression ‘x * y’. Let us assume that the value assigned to ‘a’ is never used inside the loop.Immediately after the control leaves the loop, ‘a’ is assigned the value of variable ‘z’, which would be used later in the program. We conclude here that the assignment code of ‘a’ is never used anywhere, therefore it is eligible to be eliminated.</p>

<p>Likewise, the picture above depicts that the conditional statement is always false, implying that the code, written in true case, will never be executed, hence it can be removed.</p>

<h2>Partial Redundancy</h2>

<p>Redundant expressions are computed more than once in parallel path, without any change in operands.whereas partial-redundant expressions are computed more than once in a path, without any change in operands. For example,</p>

<p>Loop-invariant code is partially redundant and can be eliminated by using a code-motion technique.</p>

<p>Another example of a partially redundant code can be:</p>

<p>We assume that the values of operands (<b>y</b> and <b>z</b>) are not changed from assignment of variable <b>a</b> to variable <b>c</b>. Here, if the condition statement is true, then y OP z is computed twice, otherwise once. Code motion can be used to eliminate this redundancy, as shown below:</p>

<p>Here, whether the condition is true or false; y OP z should be computed only once.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
do
{
   item = 10;
   value = value + item; 
} while(value<100);
</pre>
<p>This code involves repeated assignment of the identifier item, which if we put this way:</p>
<pre class="prettyprint notranslate">
Item = 10;
do
{
   value = value + item; 
} while(value<100);
</pre>
<p>should not only save the CPU cycles, but  can be used on any processor.</p>
<h2>Machine-dependent Optimization</h2>
<p>Machine-dependent optimization is done after the target code has been generated and when the code is transformed according to the target machine architecture. It involves CPU registers and may have absolute memory references rather than relative references. Machine-dependent optimizers put efforts to take maximum advantage of memory hierarchy.</p>
<h2>Basic Blocks</h2>
<p>Source codes generally have a number of instructions, which are always executed in sequence and are considered as the basic blocks of the code. These basic blocks do not have any jump statements among them, i.e., when the first instruction is executed, all the instructions in the same basic block will be executed in their sequence of appearance without losing the flow control of the program.</p>
<p>A program can have various constructs as basic blocks, like IF-THEN-ELSE, SWITCH-CASE conditional statements and loops such as DO-WHILE, FOR, and REPEAT-UNTIL, etc.</p>
<h3>Basic block identification</h3>
<p>We may use the following algorithm to find the basic blocks in a program:</p>
<ul class="list">
<li><p>Search header statements of all the basic blocks from where a basic block starts:</p>
<ul class="list">
<li>First statement of a program.</li>
<li>Statements that are target of any branch (conditional/unconditional).</li>
<li>Statements that follow any branch statement.</li>
</ul>
</li>
<li><p>Header statements and the statements following them form a basic block.</p></li>
<li><p>A basic block does not include any header statement of any other basic block.</p></li>
</ul>
<p>Basic blocks are important concepts from both code generation and optimization point of view.</p>
<img src="/compiler_design/images/basic_blocks.jpg" alt="Basic Blocks" />
<p>Basic blocks play an important role in identifying variables, which are being used more than once in a single basic block. If any variable is being used more than once, the register memory allocated to that variable need not be emptied unless the block finishes execution.</p>
<h3>Control Flow Graph</h3>
<p>Basic blocks in a program can be represented by means of control flow graphs. A control flow graph depicts how the program control is being passed among the blocks. It is a useful tool that helps in optimization by help locating any unwanted loops in the program.</p>
<img src="/compiler_design/images/control_flow_graph.jpg" alt="Control Flow Graph" />
<h2>Loop Optimization</h2>
<p>Most programs run as a loop in the system. It becomes necessary to optimize the loops in order to save CPU cycles and memory. Loops can be optimized by the following techniques:</p>
<ul class="list">
<li><p><b>Invariant code</b> : A fragment of code that resides in the loop and computes the same value at each iteration is called a loop-invariant code. This code can be moved out of the loop by saving it to be computed only once, rather than with each iteration.</p></li>
<li><p><b>Induction analysis</b> : A variable is called an induction variable if its value is altered within the loop by a loop-invariant value.</p></li>
<li><p><b>Strength reduction</b> : There are expressions that consume more CPU cycles, time, and memory. These expressions should be replaced with cheaper expressions without compromising the output of expression. For example, multiplication (x * 2) is expensive in terms of CPU cycles than (x << 1) and yields the same result.</p></li>
</ul>
<h2>Dead-code Elimination</h2>
<p>Dead code is one or more than one code statements, which are:</p>
<ul class="list">
<li>Either never executed or unreachable,</li>
<li>Or if executed, their output is never used.</li>
</ul>
<p>Thus, dead code plays no role in any program operation and therefore it can simply be eliminated.</p>
<h3>Partially dead code</h3>
<p>There are some code statements whose computed values are used only under certain circumstances, i.e., sometimes the values are used and sometimes they are not. Such codes are known as partially dead-code.</p>
<img src="/compiler_design/images/partially_dead_code.jpg" alt="Partially Dead Code" />
<p>The above control flow graph depicts a chunk of program where variable ‘a’ is used to assign the output of expression ‘x * y’. Let us assume that the value assigned to ‘a’ is never used inside the loop.Immediately after the control leaves the loop, ‘a’ is assigned the value of variable ‘z’, which would be used later in the program. We conclude here that the assignment code of ‘a’ is never used anywhere, therefore it is eligible to be eliminated.</p>
<img src="/compiler_design/images/dead_code.jpg" alt="Dead Code" />
<p>Likewise, the picture above depicts that the conditional statement is always false, implying that the code, written in true case, will never be executed, hence it can be removed.</p>
<h2>Partial Redundancy</h2>
<p>Redundant expressions are computed more than once in parallel path, without any change in operands.whereas partial-redundant expressions are computed more than once in a path, without any change in operands. For example,</p>
<table class="table table-bordered">
<tr>
<td>
<img src="/compiler_design/images/redundant_expression.jpg" alt="Redundant Expression" />
<p style="text-align:center;">[redundant expression]</p>
</td>
<td>
<img src="/compiler_design/images/partially_redundant_expression.jpg" alt="Partially Redundant Expression" />
<p style="text-align:center;">[partially redundant expression]</p>
</td>
</tr>
</table>
<p>Loop-invariant code is partially redundant and can be eliminated by using a code-motion technique.</p>
<p>Another example of a partially redundant code can be:</p>
<pre class="prettyprint notranslate">
If (condition)
{
   a = y OP z;
}
else
{
   ...
}
c = y OP z;
</pre>
<p>We assume that the values of operands (<b>y</b> and <b>z</b>) are not changed from assignment of variable <b>a</b> to variable <b>c</b>. Here, if the condition statement is true, then y OP z is computed twice, otherwise once. Code motion can be used to eliminate this redundancy, as shown below:</p>
<pre class="prettyprint notranslate">
If (condition)
{
   ...
   tmp = y OP z;
   a = tmp;
   ...
}
else
{
   ...
   tmp = y OP z;
}
c = tmp;
</pre>

<title>Compiler Design - Quick Guide</title>

<h1>Compiler Design - Quick Guide</h1>

<h1>Compiler Design - Overview</h1>

<p>Computers are a balanced mix of software and hardware. Hardware is just a piece of mechanical device and its functions are being controlled by a compatible software. Hardware understands instructions in the form of electronic charge, which is the counterpart of binary language in software programming. Binary language has only two alphabets, 0 and 1. To instruct, the hardware codes must be written in binary format, which is simply a series of 1s and 0s. It would be a difficult and cumbersome task for computer programmers to write such codes, which is why we have compilers to write such codes.</p>

<h2>Language Processing System</h2>

<p>We have learnt that any computer system is made of hardware and software. The hardware understands a language, which humans cannot understand. So we write programs in high-level language, which is easier for us to understand and remember. These programs are then fed into a series of tools and OS components to get the desired code that can be used by the machine. This is known as Language Processing System.</p>

<p>The high-level language is converted into binary language in various phases. A <b>compiler</b> is a program that converts high-level language to assembly language. Similarly, an <b>assembler</b> is a program that converts the assembly language to machine-level language.</p>

<p>Let us first understand how a program, using C compiler, is executed on a host machine.</p>

<p>User writes a program in C language (high-level language).</p>

<p>The C compiler, compiles the program and translates it to assembly program (low-level language).</p>

<p>An assembler then translates the assembly program into machine code (object).</p>

<p>A linker tool is used to link all the parts of the program together for execution (executable machine code).</p>

<p>A loader loads all of them into memory and then the program is executed.</p>

<p>Before diving straight into the concepts of compilers, we should understand a few other tools that work closely with compilers.</p>

<h3>Preprocessor</h3>

<p>A preprocessor, generally considered as a part of compiler, is a tool that produces input for compilers. It deals with macro-processing, augmentation, file inclusion, language extension, etc.</p>

<h3>Interpreter</h3>

<p>An interpreter, like a compiler, translates high-level language into low-level machine language. The difference lies in the way they read the source code or input. A compiler reads the whole source code at once, creates tokens, checks semantics, generates intermediate code, executes the whole program and may involve many passes. In contrast, an interpreter reads a statement from the input, converts it to an intermediate code, executes it, then takes the next statement in sequence. If an error occurs, an interpreter stops execution and reports it. whereas a compiler reads the whole program even if it encounters several errors.</p>

<h3>Assembler</h3>

<p>An assembler translates assembly language programs into machine code.The output of an assembler is called an object file, which contains a combination of machine instructions as well as the data required to place these instructions in memory.</p>

<h3>Linker</h3>

<p>Linker is a computer program that links and merges various object files together in order to make an executable file. All these files might have been compiled by separate assemblers. The major task of a linker is to search and locate referenced module/routines in a program and to determine the memory location where these codes will be loaded, making the program instruction to have absolute references.</p>

<h3>Loader</h3>

<p>Loader is a part of operating system and is responsible for loading executable files into memory and execute them. It calculates the size of a program (instructions and data) and creates memory space for it. It initializes various registers to initiate execution.</p>

<h3>Cross-compiler</h3>

<p>A compiler that runs on platform (A) and is capable of generating executable code for platform (B) is called a cross-compiler.</p>

<h3>Source-to-source Compiler</h3>

<p>A compiler that takes the source code of one programming language and translates it into the source code of another programming language is called a source-to-source compiler.</p>

<h2>Compiler Architecture</h2>

<p>A compiler can broadly be divided into two phases based on the way they compile.</p>

<h3>Analysis Phase</h3>

<p>Known as the front-end of the compiler, the <b>analysis</b> phase of the compiler reads the source program, divides it into core parts and then checks for lexical, grammar and syntax errors.The analysis phase generates an intermediate representation of the source program and symbol table, which should be fed to the Synthesis phase as input.</p>

<h3>Synthesis Phase</h3>

<p>Known as the back-end of the compiler, the <b>synthesis</b> phase generates the target program with the help of intermediate source code representation and symbol table.</p>

<p>A compiler can have many phases and passes.</p>

<p><b>Pass</b> : A pass refers to the traversal of a compiler through the entire program.</p>

<p><b>Phase</b> : A phase of a compiler is a distinguishable stage, which takes input from the previous stage, processes and yields output that can be used as input for the next stage. A pass can have more than one phase.</p>

<h2>Phases of Compiler</h2>

<p>The compilation process is a sequence of various phases. Each phase takes input from its previous stage, has its own representation of source program, and feeds its output to the next phase of the compiler. Let us understand the phases of a compiler.</p>

<h3>Lexical Analysis</h3>

<p>The first phase of scanner works as a text scanner. This phase scans the source code as a stream of characters and converts it into meaningful lexemes. Lexical analyzer represents these lexemes in the form of tokens as:</p>

<h3>Syntax Analysis</h3>

<p>The next phase is called the syntax analysis or <b>parsing</b>. It takes the token produced by lexical analysis as input and generates a parse tree (or syntax tree). In this phase, token arrangements are checked against the source code grammar, i.e. the parser checks if the expression made by the tokens is syntactically correct.</p>

<h3>Semantic Analysis</h3>

<p>Semantic analysis checks whether the parse tree constructed follows the rules of language. For example, assignment of values is between compatible data types, and adding string to an integer. Also, the semantic analyzer keeps track of identifiers, their types and expressions; whether identifiers are declared before use or not etc. The semantic analyzer produces an annotated syntax tree as an output.</p>

<h3>Intermediate Code Generation</h3>

<p>After semantic analysis the compiler generates an intermediate code of the source code for the target machine. It represents a program for some abstract machine. It is in between the high-level language and the machine language. This intermediate code should be generated in such a way that it makes it easier to be translated into the target machine code.</p>

<h3>Code Optimization</h3>

<p>The next phase does code optimization of the intermediate code. Optimization can be assumed as something that removes unnecessary code lines, and arranges the sequence of statements in order to speed up the program execution without wasting resources (CPU, memory).</p>

<h3>Code Generation</h3>

<p>In this phase, the code generator takes the optimized representation of the intermediate code and maps it to the target machine language. The code generator translates the intermediate code into a sequence of (generally) re-locatable machine code. Sequence of instructions of machine code performs the task as the intermediate code would do.</p>

<h3>Symbol Table</h3>

<p>It is a data-structure maintained throughout all the phases of a compiler. All the identifier's names along with their types are stored here. The symbol table makes it easier for the compiler to quickly search the identifier record and retrieve it. The symbol table is also used for scope management.</p>

<h1>Compiler Design - Lexical Analysis</h1>

<p>Lexical analysis is the first phase of a compiler. It takes the modified source code from language preprocessors that are written in the form of sentences. The lexical analyzer breaks these syntaxes into a series of tokens, by removing any whitespace or comments in the source code.</p>

<p>If the lexical analyzer finds a token invalid, it generates an error. The lexical analyzer works closely with the syntax analyzer. It reads character streams from the source code, checks for legal tokens, and passes the data to the syntax analyzer when it demands.</p>

<h2>Tokens</h2>

<p>Lexemes are said to be a sequence of characters (alphanumeric) in a token. There are some predefined rules for every lexeme to be identified as a valid token. These rules are defined by grammar rules, by means of a pattern. A pattern explains what can be a token, and these patterns are defined by means of regular expressions.</p>

<p>In programming language, keywords, constants, identifiers, strings, numbers, operators and punctuations symbols can be considered as tokens.</p>

<p>For example, in C language, the variable declaration line</p>

<p>contains the tokens:</p>

<h2>Specifications of Tokens</h2>

<p>Let us understand how the language theory undertakes the following terms:</p>

<h3>Alphabets</h3>

<p>Any finite set of symbols {0,1} is a set of binary alphabets, {0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F} is a set of Hexadecimal alphabets, {a-z, A-Z} is a set of English language alphabets.</p>

<h3>Strings</h3>

<p>Any finite sequence of alphabets is called a string. Length of the string is the total number of occurrence of alphabets, e.g., the length of the string tutorialspoint is 14 and is denoted by |tutorialspoint| = 14. A string having no alphabets, i.e. a string of zero length is known as an empty string and is denoted by ε (epsilon).</p>

<h3>Special Symbols</h3>

<p>A typical high-level language contains the following symbols:-</p>

<h3>Language</h3>

<h2>Regular Expressions</h2>

<p>The lexical analyzer needs to scan and identify only a finite set of valid string/token/lexeme that belong to the language in hand. It searches for the pattern defined by the language rules.</p>

<p>Regular expressions have the capability to express finite languages by defining a pattern for finite strings of symbols. The grammar defined by regular expressions is known as <b>regular grammar</b>. The language defined by regular grammar is known as <b>regular language</b>.</p>

<p>Regular expression is an important notation for specifying patterns. Each pattern matches a set of strings, so regular expressions serve as names for a set of strings. Programming language tokens can be described by regular languages. The specification of regular expressions is an example of a recursive definition. Regular languages are easy to understand and have efficient implementation.</p>

<p>There are a number of algebraic laws that are obeyed by regular expressions, which can be used to manipulate regular expressions into equivalent forms.</p>

<h2>Operations</h2>

<p>The various operations on languages are:</p>

<p>Union of two languages L and M is written as</p>

<p>L U M = {s | s is in L or s is in M}</p>

<p>Concatenation of two languages L and M is written as</p>

<p>LM = {st | s is in L and t is in M}</p>

<p>The Kleene Closure of a language L is written as</p>

<p>L* = Zero or more occurrence of language L.</p>

<h2>Notations</h2>

<p>If r and s are regular expressions denoting the languages L(r) and L(s), then</p>

<p><b>Union</b> : (r)|(s) is a regular expression denoting L(r) U L(s)</p>

<p><b>Concatenation</b> : (r)(s) is a regular expression denoting L(r)L(s)</p>

<p><b>Kleene closure</b> : (r)* is a regular expression denoting (L(r))*</p>

<p>(r) is a regular expression denoting L(r)</p>

<h2>Precedence and Associativity</h2>

<h3>Representing valid tokens of a language in regular expression</h3>

<p>If x is a regular expression, then:</p>

<p>x* means zero or more occurrence of x.</p>

<p>i.e., it can generate { e, x, xx, xxx, xxxx, … }</p>

<p>x+ means one or more occurrence of x.</p>

<p>i.e., it can generate { x, xx, xxx, xxxx … } or x.x*</p>

<p>x? means at most one occurrence of x</p>

<p>i.e., it can generate either {x} or {e}.</p>

<p>[a-z] is all lower-case alphabets of English language.</p>

<p>[A-Z] is all upper-case alphabets of English language.</p>

<p>[0-9] is all natural digits used in mathematics.</p>

<h3>Representing occurrence of symbols using regular expressions</h3>

<p>letter = [a – z] or [A – Z]</p>

<p>digit  = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 or [0-9]</p>

<p>sign = [ + | - ]</p>

<h3>Representing language tokens using regular expressions</h3>

<p>Decimal = (sign)<sup>?</sup>(digit)<sup>+</sup></p>

<p>Identifier = (letter)(letter | digit)*</p>

<p>The only problem left with the lexical analyzer is how to verify the validity of a regular expression used in specifying the patterns of keywords of a language. A well-accepted solution is to use finite automata for verification.</p>

<h2>Finite Automata</h2>

<p>Finite automata is a state machine that takes a string of symbols as input and changes its state accordingly. Finite automata is a recognizer for regular expressions. When a regular expression string is fed into finite automata, it changes its state for each literal. If the input string is successfully processed and the automata reaches its final state, it is accepted, i.e., the string just fed was said to be a valid token of the language in hand.</p>

<p>The mathematical model of finite automata consists of:</p>

<p>The transition function (δ) maps the finite set of state (Q) to a finite set of input symbols (Σ), Q × Σ ➔ Q</p>

<h3>Finite Automata Construction</h3>

<p>Let L(r) be a regular language recognized by some finite automata (FA).</p>

<p><b>States</b> : States of FA are represented by circles. State names are written inside circles.</p>

<p><b>Start state</b> : The state from where the automata starts, is known as the start state. Start state has an arrow pointed towards it.</p>

<p><b>Intermediate states</b> : All intermediate states have at least two arrows; one pointing to and another pointing out from them.</p>

<p><b>Final state</b> : If the input string is successfully parsed, the automata is expected to be in this state. Final state is represented by double circles. It may have any odd number of arrows pointing to it and even number of arrows pointing out from it. The number of odd arrows are one greater than even, i.e. <b>odd = even+1</b>.</p>

<p><b>Transition</b> : The transition from one state to another state happens when a desired symbol in the input is found. Upon transition, automata can either move to the next state or stay in the same state. Movement from one state to another is shown as a directed arrow, where the arrows points to the destination state. If automata stays on the same state, an arrow pointing from a state to itself is drawn.</p>

<h3>Longest Match Rule</h3>

<p>When the lexical analyzer read the source-code, it scans the code letter by letter; and when it encounters a whitespace, operator symbol, or special symbols, it decides that a word is completed.</p>

<p><b>For example:</b></p>

<p>While scanning both lexemes till ‘int’, the lexical analyzer cannot determine whether it is a keyword <i>int</i> or the initials of identifier int value.</p>

<p>The Longest Match Rule states that the lexeme scanned should be determined based on the longest match among all the tokens available.</p>

<p>The lexical analyzer also follows <b>rule priority</b> where a reserved word, e.g., a keyword, of a language is given priority over user input. That is, if the lexical analyzer finds a lexeme that matches with any existing reserved word, it should generate an error.</p>

<h1>Compiler Design - Syntax Analysis</h1>

<p>Syntax analysis or parsing is the second phase of a compiler. In this chapter, we shall learn the basic concepts used in the construction of a parser.</p>

<p>We have seen that a lexical analyzer can identify tokens with the help of regular expressions and pattern rules. But a lexical analyzer cannot check the syntax of a given sentence due to the limitations of the regular expressions. Regular expressions cannot check balancing tokens, such as parenthesis. Therefore, this phase uses context-free grammar (CFG), which is recognized by push-down automata.</p>

<p>CFG, on the other hand, is a superset of Regular Grammar, as depicted below:</p>

<p>It implies that every Regular Grammar is also context-free, but there exists some problems, which are  beyond the scope of Regular Grammar. CFG is a helpful tool in describing the syntax of programming languages.</p>

<h2>Context-Free Grammar</h2>

<p>In this section, we will first see the definition of context-free grammar and introduce terminologies used in parsing technology.</p>

<p>A context-free grammar has four components:</p>

<p>A set of <b>non-terminals</b> (V). Non-terminals are syntactic variables that denote sets of strings. The non-terminals define sets of strings that help define the language generated by the grammar.</p>

<p>A set of tokens, known as <b>terminal symbols</b> (Σ). Terminals are the basic symbols from which strings are formed.</p>

<p>A set of <b>productions</b> (P). The productions of a grammar specify the manner in which the terminals and non-terminals can be combined to form strings. Each production consists of a <b>non-terminal</b> called the left side of the production, an arrow, and a sequence of tokens and/or <b>on- terminals</b>, called the right side of the production.</p>

<p>One of the non-terminals is designated as the start symbol (S); from where the production begins.</p>

<p>The strings are derived from the start symbol by repeatedly replacing a non-terminal (initially the start symbol) by the right side of a production, for that non-terminal.</p>

<h3>Example</h3>

<p>We take the problem of palindrome language, which cannot be described by means of Regular Expression. That is, L = { w | w = w<sup>R</sup> } is not a regular language. But it can be described by means of CFG, as illustrated below:</p>

<p>Where:</p>

<p>This grammar describes palindrome language, such as: 1001, 11100111, 00100, 1010101, 11111, etc.</p>

<h2>Syntax Analyzers</h2>

<p>A syntax analyzer or parser takes the input from a lexical analyzer in the form of token streams. The parser analyzes the source code (token stream) against the production rules to detect any errors in the code. The output of this phase is a <b>parse tree</b>.</p>

<p>This way, the parser accomplishes two tasks, i.e., parsing the code, looking for errors and generating a parse tree as the output of the phase.</p>

<p>Parsers are expected to parse the whole code even if some errors exist in the program. Parsers use error recovering strategies, which we will learn later in this chapter.</p>

<h2>Derivation</h2>

<p>A derivation is basically a sequence of production rules, in order to get the input string. During parsing, we take two decisions for some sentential form of input:</p>

<p>To decide which non-terminal to be replaced with production rule, we can have two options.</p>

<h3>Left-most Derivation</h3>

<p>If the sentential form of an input is scanned and replaced from left to right, it is called left-most derivation. The sentential form derived by the left-most derivation is called the left-sentential form.</p>

<h3>Right-most Derivation</h3>

<p>If we scan and replace the input with production rules, from right to left, it is known as right-most derivation. The sentential form derived from the right-most derivation is called the right-sentential form.</p>

<p><b>Example</b></p>

<p>Production rules:</p>

<p>Input string: id + id * id</p>

<p>The left-most derivation is:</p>

<p>Notice that the left-most side non-terminal is always processed first.</p>

<p>The right-most derivation is:</p>

<h2>Parse Tree</h2>

<p>A parse tree is a graphical depiction of a derivation. It is convenient to see how strings are derived from the start symbol. The start symbol of the derivation becomes the root of the parse tree. Let us see this by an example from the last topic.</p>

<p>We take the left-most derivation of a + b * c</p>

<p>The left-most derivation is:</p>

<p>Step 1:</p>

<p>Step 2:</p>

<p>Step 3:</p>

<p>Step 4:</p>

<p>Step 5:</p>

<p>In a parse tree:</p>

<p>A parse tree depicts associativity and precedence of operators. The deepest sub-tree is traversed first, therefore the operator in that sub-tree gets precedence over the operator which is in the parent nodes.</p>

<h2>Types of Parsing</h2>

<p>Syntax analyzers follow production rules defined by means of context-free grammar. The way the production rules are implemented (derivation) divides parsing into two types : top-down parsing and bottom-up parsing.</p>

<h3>Top-down Parsing</h3>

<p>When the parser starts constructing the parse tree from the start symbol and then tries to transform the start symbol to the input, it is called top-down parsing.</p>

<p><b>Recursive descent parsing</b> : It is a common form of top-down parsing. It is called recursive as it uses recursive procedures to process the input. Recursive descent parsing suffers from backtracking.</p>

<h3>Bottom-up Parsing</h3>

<p>As the name suggests, bottom-up parsing starts with the input symbols and tries to construct the parse tree up to the start symbol.</p>

<p><b>Example:</b></p>

<p>Input string : a + b * c</p>

<p>Production rules:</p>

<p>Let us start bottom-up parsing</p>

<p>Read the input and check if any production matches with the input:</p>

<h3>Ambiguity</h3>

<p>A grammar G is said to be ambiguous if it has more than one parse tree (left or right derivation) for at least one string.</p>

<p><b>Example</b></p>

<p>For the string id + id – id, the above grammar generates two parse trees:</p>

<p>The language generated by an ambiguous grammar is said to be <b>inherently ambiguous</b>. Ambiguity in grammar is not good for a compiler construction. No method can detect and remove ambiguity automatically, but it can be removed by either re-writing the whole grammar without ambiguity, or by setting and following associativity and precedence constraints.</p>

<h3>Associativity</h3>

<p>If an operand has operators on both sides, the side on which the operator takes this operand is decided by the associativity of those operators. If the operation is left-associative, then the operand will be taken by the left operator or if the operation is right-associative, the right operator will take the operand.</p>

<p><b>Example</b></p>

<p>Operations such as Addition, Multiplication, Subtraction, and Division are left associative. If the expression contains:</p>

<p>it will be evaluated as:</p>

<p>For example, (id + id) + id</p>

<p>Operations like Exponentiation are right associative, i.e., the order of evaluation in the same expression will be:</p>

<p>For example, id ^ (id ^ id)</p>

<h3>Precedence</h3>

<p>If two different operators share a common operand, the precedence of operators decides which will take the operand. That is, 2+3*4 can have two different parse trees, one corresponding to (2+3)*4 and another corresponding to 2+(3*4). By setting precedence among operators, this problem can be easily removed. As in the previous example, mathematically * (multiplication) has precedence over + (addition), so the expression 2+3*4 will always be interpreted as:</p>

<p>These methods decrease the chances of ambiguity in a language or its grammar.</p>

<h3>Left Recursion</h3>

<p>A grammar becomes left-recursive if it has any non-terminal ‘A’ whose derivation contains ‘A’ itself as the left-most symbol. Left-recursive grammar is considered to be a problematic situation for top-down parsers. Top-down parsers start parsing from the Start symbol, which in itself is non-terminal. So, when the parser encounters the same non-terminal in its derivation, it becomes hard for it to judge when to stop parsing the left non-terminal and it goes into an infinite loop.</p>

<p><b>Example:</b></p>

<p>(1) is an example of immediate left recursion, where A is any non-terminal symbol and α represents a string of non-terminals.</p>

<p>(2) is an example of indirect-left recursion.</p>

<p>A top-down parser will first parse the A, which in-turn will yield a string consisting of A itself and the parser may go into a loop forever.</p>

<h3>Removal of Left Recursion</h3>

<p>One way to remove left recursion is to use the following technique:</p>

<p>The production</p>

<p>is converted into following productions</p>

<p>This does not impact the strings derived from the grammar, but it removes immediate left recursion.</p>

<p>Second method is to use the following algorithm, which should eliminate all direct and indirect left recursions.</p>

<p><b>Example</b></p>

<p>The production set</p>

<p>after applying the above algorithm, should become</p>

<p>and then, remove immediate left recursion using the first technique.</p>

<p>Now none of the production has either direct or indirect left recursion.</p>

<h3>Left Factoring</h3>

<p>If more than one grammar production rules has a common prefix string, then the top-down parser cannot make a choice as to which of the production it should take to parse the string in hand.</p>

<p><b>Example</b></p>

<p>If a top-down parser encounters a production like</p>

<p>Then it cannot determine which production to follow to parse the string as both productions are starting from the same terminal (or non-terminal). To remove this confusion, we use a technique called left factoring.</p>

<p>Left factoring transforms the grammar to make it useful for top-down parsers. In this technique, we make one production for each common prefixes and the rest of the derivation is added by new productions.</p>

<p><b>Example</b></p>

<p>The above productions can be written as</p>

<p>Now the parser has only one production per prefix which makes it easier to take decisions.</p>

<h2>First and Follow Sets</h2>

<p>An important part of parser table construction is to create first and follow sets.  These sets can provide the actual position of any terminal in the derivation. This is done to create the parsing table where the decision of replacing T[A, t] = α with some production rule.</p>

<h3>First Set</h3>

<p>This set is created to know what terminal symbol is derived in the first position by a non-terminal. For example,</p>

<p>That is α derives t (terminal) in the very first position. So, t ∈ FIRST(α).</p>

<h4>Algorithm for calculating First set</h4>

<p>Look at the definition of FIRST(α) set:</p>

<p>First set can be seen as: FIRST(α) = { t | α  &rarr;<sup>*</sup> t β } ∪ { ℇ | α &rarr;<sup>*</sup> &epsilon;}</p>

<h3>Follow Set</h3>

<p>Likewise, we calculate what terminal symbol immediately follows a non-terminal α in production rules. We do not consider what the non-terminal can generate but instead, we see what would be the next terminal symbol that follows the productions of a non-terminal.</p>

<h4>Algorithm for calculating Follow set:</h4>

<p>if α is a start symbol, then FOLLOW() = $</p>

<p>if α is a non-terminal and has a production α → AB, then FIRST(B) is in FOLLOW(A) except ℇ.</p>

<p>if α is a non-terminal and has a production α → AB, where B  ℇ, then FOLLOW(A) is in FOLLOW(α).</p>

<p>Follow set can be seen as: FOLLOW(α) = { t | S   *αt*}</p>

<h2>Error-recovery Strategies</h2>

<p>A parser should be able to detect and report any error in the program. It is expected that when an error is encountered, the parser should be able to handle it and carry on parsing the rest of the input. Mostly it is expected from the parser to check for errors but errors may be encountered at various stages of the compilation process. A program may have the following kinds of errors at various stages:</p>

<p><b>Lexical</b> : name of some identifier typed incorrectly</p>

<p><b>Syntactical</b> : missing semicolon or unbalanced parenthesis</p>

<p><b>Semantical</b> : incompatible value assignment</p>

<p><b>Logical</b> : code not reachable, infinite loop</p>

<p>There are four common error-recovery strategies that can be implemented in the parser to deal with errors in the code.</p>

<h3>Panic mode</h3>

<p>When a parser encounters an error anywhere in the statement, it ignores the rest of the statement by not processing input from erroneous input to delimiter, such as semi-colon. This is the easiest way of error-recovery and also, it prevents the parser from developing infinite loops.</p>

<h3>Statement mode</h3>

<p>When a parser encounters an error, it tries to take corrective measures so that the rest of inputs of statement allow the parser to parse ahead. For example, inserting a missing semicolon, replacing comma with a semicolon etc. Parser designers have to be careful here because one wrong correction may lead to an infinite loop.</p>

<h3>Error productions</h3>

<p>Some common errors are known to the compiler designers that may occur in the code. In addition, the designers can create augmented grammar to be used, as productions that generate erroneous constructs when these errors are encountered.</p>

<h3>Global correction</h3>

<p>The parser considers the program in hand as a whole and tries to figure out what the program is intended to do and tries to find out a closest match for it, which is error-free. When an erroneous input (statement) X is fed, it creates a parse tree for some closest error-free statement Y. This may allow the parser to make minimal changes in the source code, but due to the complexity (time and space) of this strategy, it has not been implemented in practice yet.</p>

<h3>Abstract Syntax Trees</h3>

<p>Parse tree representations are not easy to be parsed by the compiler, as they contain more details than actually needed. Take the following parse tree as an example:</p>

<p>If watched closely, we find most of the leaf nodes are single child to their parent nodes. This information can be eliminated before feeding it to the next phase. By hiding extra information, we can obtain a tree as shown below:</p>

<p>Abstract tree can be represented as:</p>

<p>ASTs are important data structures in a compiler with least unnecessary information. ASTs are more compact than a parse tree and can be easily used by a compiler.</p>

<h2>Limitations of Syntax Analyzers</h2>

<p>Syntax analyzers receive their inputs, in the form of tokens, from lexical analyzers. Lexical analyzers are responsible for the validity of a token supplied by the syntax analyzer. Syntax analyzers have the following drawbacks:</p>

<p>These tasks are accomplished by the semantic analyzer, which we shall study in Semantic Analysis.</p>

<h1>Compiler Design - Semantic Analysis</h1>

<p>We have learnt how a parser constructs parse trees in the syntax analysis phase. The plain parse-tree constructed in that phase is generally of no use for a compiler, as it does not carry any information of how to evaluate the tree. The productions of context-free grammar, which makes the rules of the language, do not accommodate how to interpret them.</p>

<p>For example</p>

<p>The above CFG production has no semantic rule associated with it, and it cannot help in making any sense of the production.</p>

<h2>Semantics</h2>

<p>Semantics of a language provide meaning to its constructs, like tokens and syntax structure. Semantics help interpret symbols, their types, and their relations with each other. Semantic analysis judges whether the syntax structure constructed in the source program derives any meaning or not.</p>

<p>For example:</p>

<p>should not issue an error in lexical and syntax analysis phase, as it is lexically and structurally correct, but it should generate a semantic error as the type of the assignment differs. These rules are set by the grammar of the language and evaluated in semantic analysis. The following tasks should be performed in semantic analysis:</p>

<h2>Semantic Errors</h2>

<p>We have mentioned some of the semantics errors that the semantic analyzer is expected to recognize:</p>

<h2>Attribute Grammar</h2>

<p>Attribute grammar is a special form of context-free grammar where some additional information (attributes) are appended to one or more of its non-terminals in order to provide context-sensitive information. Each attribute has well-defined domain of values, such as integer, float, character, string, and expressions.</p>

<p>Attribute grammar is a medium to provide semantics to the context-free grammar and it can help specify the syntax and semantics of a programming language. Attribute grammar (when viewed as a parse-tree) can pass values or information among the nodes of a tree.</p>

<p><b>Example:</b></p>

<p>The right part of the CFG contains the semantic rules that specify how the grammar should be interpreted. Here, the values of non-terminals E and T are added together and the result is copied to the non-terminal E.</p>

<p>Semantic attributes may be assigned to their values from their domain at the time of parsing and evaluated at the time of assignment or conditions. Based on the way the attributes get their values, they can be broadly divided into two categories : synthesized attributes and inherited attributes.</p>

<h3>Synthesized attributes</h3>

<p>These attributes get values from the attribute values of their child nodes. To illustrate, assume the following production:</p>

<p>If S is taking values from its child nodes (A,B,C), then it is said to be a synthesized attribute, as the values of ABC are synthesized to S.</p>

<p>As in our previous example (E → E + T), the parent node E gets its value from its child node. Synthesized attributes never take values from their parent nodes or any sibling nodes.</p>

<h3>Inherited attributes</h3>

<p>In contrast to synthesized attributes, inherited attributes can take values from parent and/or siblings. As in the following production,</p>

<p>A can get values from S, B and C. B can take values from S, A, and C. Likewise, C can take values from S, A, and B.</p>

<p><b>Expansion</b> : When a non-terminal is expanded to terminals as per a grammatical rule</p>

<p><b>Reduction</b> : When a terminal is reduced to its corresponding non-terminal according to grammar rules. Syntax trees are parsed top-down and left to right. Whenever reduction occurs, we apply its corresponding semantic rules (actions).</p>

<p>Semantic analysis uses Syntax Directed Translations to perform the above tasks.</p>

<p>Semantic analyzer receives AST (Abstract Syntax Tree) from its previous stage (syntax analysis).</p>

<p>Semantic analyzer attaches attribute information with AST, which are called Attributed AST.</p>

<p>Attributes are two tuple value, &lt;attribute name, attribute value&gt;</p>

<p>For example:</p>

<p>For every production, we attach a semantic rule.</p>

<h2>S-attributed SDT</h2>

<p>If an SDT uses only synthesized attributes, it is called as S-attributed SDT. These attributes are evaluated using S-attributed SDTs that have their semantic actions written after the production (right hand side).</p>

<p>As depicted above, attributes in S-attributed SDTs are evaluated in bottom-up parsing, as the values of the parent nodes depend upon the values of the child nodes.</p>

<h2>L-attributed SDT</h2>

<p>This form of SDT uses both synthesized and inherited attributes with restriction of not taking values from right siblings.</p>

<p>In L-attributed SDTs, a non-terminal can get values from its parent, child, and sibling nodes. As in the following production</p>

<p>S can take values from A, B, and C (synthesized). A can take values from S only. B can take values from S and A. C can get values from S, A, and B. No non-terminal can get values from the sibling to its right.</p>

<p>Attributes in L-attributed SDTs are evaluated by depth-first and left-to-right parsing manner.</p>

<p>We may conclude that if a definition is S-attributed, then it is also L-attributed as L-attributed definition encloses S-attributed definitions.</p>

<h1>Compiler Design - Parser</h1>

<p>In the previous chapter, we understood the basic concepts involved in parsing. In this chapter, we will learn the various types of parser construction methods available.</p>

<p>Parsing can be defined as top-down or bottom-up based on how the parse-tree is constructed.</p>

<h2>Top-Down Parsing</h2>

<p>We have learnt in the last chapter that the top-down parsing technique parses the input, and starts constructing a parse tree from the root node gradually moving down to the leaf nodes. The types of top-down parsing are depicted below:</p>

<h3>Recursive Descent Parsing</h3>

<p>Recursive descent is a top-down parsing technique that constructs the parse tree from the top and the input is read from left to right. It uses procedures for every terminal and non-terminal entity. This parsing technique recursively parses the input to make a parse tree, which may or may not require back-tracking. But the grammar associated with it (if not left factored) cannot avoid back-tracking. A form of recursive-descent parsing that does not require any back-tracking is known as <b>predictive parsing</b>.</p>

<p>This parsing technique is regarded recursive as it uses context-free grammar which is recursive in nature.</p>

<h3>Back-tracking</h3>

<p>Top- down parsers start from the root node (start symbol) and match the input string against the production rules to replace them (if matched). To understand this, take the following example of CFG:</p>

<p>For an input string: read, a top-down parser, will behave like this:</p>

<p>It will start with S from the production rules and will match its yield to the left-most letter of the input, i.e. ‘r’.  The very production of S (S → rXd) matches with it. So the top-down parser advances to the next input letter (i.e. ‘e’). The parser tries to expand non-terminal ‘X’ and checks its production from the left (X → oa). It does not match with the next input symbol. So the top-down parser backtracks to obtain the next production rule of X, (X → ea).</p>

<p>Now the parser matches all the input letters in  an ordered manner. The string is accepted.</p>

<h3>Predictive Parser</h3>

<p>Predictive parser is a recursive descent parser, which has the capability to predict which production is to be used to replace the input string. The predictive parser does not suffer from backtracking.</p>

<p>To accomplish its tasks, the predictive parser uses a look-ahead pointer, which points to the next input symbols. To make the parser back-tracking free, the predictive parser puts some constraints on the grammar and accepts only a class of grammar known as LL(k) grammar.</p>

<p>Predictive parsing uses a stack and a parsing table to parse the input and generate a parse tree. Both the stack and the input contains an end symbol <b>$</b> to denote that the stack is empty and the input is consumed. The parser refers to the parsing table to take any decision on the input and stack element combination.</p>

<p>In recursive descent parsing, the parser may have more than one production to choose from for a single instance of input, whereas in predictive parser, each step has at most one production to choose. There might be instances where there is no production matching the input string, making the parsing procedure to fail.</p>

<h3>LL Parser</h3>

<p>An LL Parser accepts LL grammar. LL grammar is a subset of context-free grammar but with some restrictions to get the simplified version, in order to achieve easy implementation. LL grammar can be implemented by means of both algorithms namely, recursive-descent or table-driven.</p>

<p>LL parser is denoted as LL(k). The first L in LL(k) is parsing the input from left to right, the second L in LL(k) stands for left-most derivation and k itself represents the number of look aheads. Generally k = 1, so LL(k) may also be written as LL(1).</p>

<h3>LL Parsing Algorithm</h3>

<p>We may stick to deterministic LL(1) for parser explanation, as the size of table grows exponentially with the value of k. Secondly, if a given grammar is not LL(1), then usually, it is not LL(k), for any given k.</p>

<p>Given below is an algorithm for LL(1) Parsing:</p>

<p>A grammar G is LL(1) if A-> alpha | b are two distinct productions of G:</p>

<p>for no terminal, both alpha and beta derive strings beginning with a.</p>

<p>at most one of alpha and beta can derive empty string.</p>

<p>if beta=> t, then alpha does not derive any string beginning with a terminal in FOLLOW(A).</p>

<h2>Bottom-up Parsing</h2>

<p>Bottom-up parsing starts from the leaf nodes of a tree and works in upward direction till it reaches the root node. Here, we start from a sentence and then apply production rules in reverse manner in order to reach the start symbol. The image given below depicts the bottom-up parsers available.</p>

<h3>Shift-Reduce Parsing</h3>

<p>Shift-reduce parsing uses two unique steps for bottom-up parsing. These steps are known as shift-step and reduce-step.</p>

<p><b>Shift step</b>: The shift step refers to the advancement of the input pointer to the next input symbol, which is called the shifted symbol. This symbol is pushed onto the stack. The shifted symbol is treated as a single node of the parse tree.</p>

<p><b>Reduce step</b> : When the parser finds a complete grammar rule (RHS) and replaces it to (LHS), it is known as reduce-step. This occurs when the top of the stack contains a handle. To reduce, a POP function is performed on the stack which pops off the handle and replaces it with LHS non-terminal symbol.</p>

<h3>LR Parser</h3>

<p>The LR parser is a non-recursive, shift-reduce, bottom-up parser. It uses a wide class of context-free grammar which makes it the most efficient syntax analysis technique. LR parsers are also known as LR(k) parsers, where L stands for left-to-right scanning of the input stream; R stands for the construction of right-most derivation in reverse, and k denotes the number of lookahead symbols to make decisions.</p>

<p>There are three widely used algorithms available for constructing an LR parser:</p>

<h3>LR Parsing Algorithm</h3>

<p>Here we describe a skeleton algorithm of an LR parser:</p>

<h3>LL vs. LR</h3>

<h1>Compiler Design - Run-Time Environment</h1>

<p>A program as a source code is merely a collection of text (code, statements etc.) and to make it alive, it requires actions to be performed on the target machine. A program needs memory resources to execute instructions. A program contains names for procedures, identifiers etc., that require mapping with the actual memory location at runtime.</p>

<p>By runtime, we mean a program in execution. Runtime environment is a state of the target machine, which may include software libraries, environment variables, etc., to provide services to the processes running in the system.</p>

<p>Runtime support system is a package, mostly generated with the executable program itself and facilitates the process communication between the process and the runtime environment. It takes care of memory allocation and de-allocation while the program is being executed.</p>

<h2>Activation Trees</h2>

<p>A program is a sequence of instructions combined into a number of procedures.  Instructions in a procedure are executed sequentially. A procedure has a start and an end delimiter and everything inside it is called the body of the procedure. The procedure identifier and the sequence of finite instructions inside it make up the body of the procedure.</p>

<p>The execution of a procedure is called its activation. An activation record contains all the necessary information required to call a procedure. An activation record may contain the following units (depending upon the source language used).</p>

<p>Whenever a procedure is executed, its activation record is stored on the stack, also known as control stack. When a procedure calls another procedure, the execution of the caller is suspended until the called procedure finishes execution. At this time, the activation record of the called procedure is stored on the stack.</p>

<p>We assume that the program control flows in a sequential manner and when a procedure is called, its control is transferred to the called procedure. When a called procedure is executed, it returns the control back to the caller. This type of control flow makes it easier to represent a series of activations in the form of a tree, known as the <b>activation tree</b>.</p>

<p>To understand this concept, we take a piece of code as an example:</p>

<p>Below is the activation tree of the code given.</p>

<p>Now we understand that procedures are executed in depth-first manner, thus stack allocation is the best suitable form of storage for procedure activations.</p>

<h2>Storage Allocation</h2>

<p>Runtime environment manages runtime memory requirements for the following entities:</p>

<p><b>Code</b> : It is known as the text part of a program that does not change at runtime. Its memory requirements are known at the compile time.</p>

<p><b>Procedures</b> : Their text part is static but they are called in a random manner. That is why, stack storage is used to manage procedure calls and activations.</p>

<p><b>Variables</b> : Variables are known at the runtime only, unless they are global or constant. Heap memory allocation scheme is used for managing allocation and de-allocation of memory for variables in runtime.</p>

<h2>Static Allocation</h2>

<p>In this allocation scheme, the compilation data is bound to a fixed location in the memory and it does not change when the program executes. As the memory requirement and storage locations are known in advance, runtime support package for memory allocation and de-allocation is not required.</p>

<h2>Stack Allocation</h2>

<p>Procedure calls and their activations are managed by means of stack memory allocation. It works in last-in-first-out (LIFO) method and this allocation strategy is very useful for recursive procedure calls.</p>

<h2>Heap Allocation</h2>

<p>Variables local to a procedure are allocated and de-allocated only at runtime. Heap allocation is used to dynamically allocate memory to the variables and claim it back when the variables are no more required.</p>

<p>Except statically allocated memory area, both stack and heap memory can grow and shrink dynamically and unexpectedly. Therefore, they cannot be provided with a fixed amount of memory in the system.</p>

<p>As shown in the image above, the text part of the code is allocated a fixed amount of memory. Stack and heap memory are arranged at the extremes of total memory allocated to the program. Both shrink and grow against each other.</p>

<h2>Parameter Passing</h2>

<p>The communication medium among procedures is known as parameter passing. The values of the variables from a calling procedure are transferred to the called procedure by some mechanism. Before moving ahead, first go through some basic terminologies pertaining to the values in a program.</p>

<h3>r-value</h3>

<p>The value of an expression is called its r-value. The value contained in a single variable also becomes an r-value if it appears on the right-hand side of the assignment operator. r-values can always be assigned to some other variable.</p>

<h3>l-value</h3>

<p>The location of memory (address) where an expression is stored is known as the l-value of that expression. It always appears at the left hand side of an assignment operator.</p>

<p>For example:</p>

<p>From this example, we understand that constant values like 1, 7, 12, and variables like day, week, month and year, all have r-values. Only variables have l-values as they also represent the memory location assigned to them.</p>

<p>For example:</p>

<p>is an l-value error, as the constant 7 does not represent any memory location.</p>

<h2>Formal Parameters</h2>

<p>Variables that take the information passed by the caller procedure are called formal parameters. These variables are declared in the definition of the called function.</p>

<h2>Actual Parameters</h2>

<p>Variables whose values or addresses are being passed to the called procedure are called actual parameters. These variables are specified in the function call as arguments.</p>

<p><b>Example:</b></p>

<p>Formal parameters hold the information of the actual parameter, depending upon the parameter passing technique used. It may be a value or an address.</p>

<h2>Pass by Value</h2>

<p>In pass by value mechanism, the calling procedure passes the r-value of actual parameters and the compiler puts that into the called procedure’s activation record. Formal parameters then hold the values passed by the calling procedure. If the values held by the formal parameters are changed, it should have no impact on the actual parameters.</p>

<h2>Pass by Reference</h2>

<p>In pass by reference mechanism, the l-value of the actual parameter is copied to the activation record of the called procedure. This way, the called procedure now has the address (memory location) of the actual parameter and the formal parameter refers to the same memory location. Therefore, if the value pointed by the formal parameter is changed, the impact should be seen on the actual parameter as they should also point to the same value.</p>

<h2>Pass by Copy-restore</h2>

<p>This parameter passing mechanism works similar to ‘pass-by-reference’ except that the changes to actual parameters are made when the called procedure ends. Upon function call, the values of actual parameters are copied in the activation record of the called procedure. Formal parameters if manipulated have no real-time effect on actual parameters (as l-values are passed), but when the called procedure ends, the l-values of formal parameters are copied to the l-values of actual parameters.</p>

<p><b>Example:</b></p>

<p>When this function ends, the l-value of formal parameter x is copied to the actual parameter y. Even if the value of y is changed before the procedure ends, the l-value of x is copied to the l-value of y making it behave like call by reference.</p>

<h2>Pass by Name</h2>

<p>Languages like Algol provide a new kind of parameter passing mechanism that works like preprocessor in C language. In pass by name mechanism, the name of the procedure being called is replaced by its actual body. Pass-by-name textually substitutes the argument expressions in a procedure call for the corresponding parameters in the body of the procedure so that it can now work on actual parameters, much like pass-by-reference.</p>

<h1>Compiler Design - Symbol Table</h1>

<p>Symbol table is an important data structure created and maintained by compilers in order to store information about the occurrence of various entities such as variable names, function names, objects, classes, interfaces, etc. Symbol table is used by both the analysis and the synthesis parts of a compiler.</p>

<p>A symbol table may serve the following purposes depending upon the language in hand:</p>

<p>To store the names of all entities in a structured form at one place.</p>

<p>To verify if a variable has been declared.</p>

<p>To implement type checking, by verifying assignments and expressions in the source code are semantically correct.</p>

<p>To determine the scope of a name (scope resolution).</p>

<p>A symbol table is simply a table which can be either linear or a hash table. It maintains an entry for each name in the following format:</p>

<p>For example, if a symbol table has to store information about the following variable declaration:</p>

<p>then it should store the entry such as:</p>

<p>The attribute clause contains the entries related to the name.</p>

<h2>Implementation</h2>

<p>If a compiler is to handle a small amount of data, then the symbol table can be implemented as an unordered list, which is easy to code, but it is only suitable for small tables only. A symbol table can be implemented in one of the following ways:</p>

<p>Among all, symbol tables are mostly implemented as hash tables, where the source code symbol itself is treated as a key for the hash function and the return value is the information about the symbol.</p>

<h2>Operations</h2>

<p>A symbol table, either linear or hash, should provide the following operations.</p>

<h3>insert()</h3>

<p>This operation is more frequently used by analysis phase, i.e., the first half of the compiler where tokens are identified and names are stored in the table. This operation is used to add information in the symbol table about unique names occurring in the source code. The format or structure in which the names are stored depends upon the compiler in hand.</p>

<p>An attribute for a symbol in the source code is the information associated with that symbol. This information contains the value, state, scope, and type about the symbol. The insert() function takes the symbol and its attributes as arguments and stores the information in the symbol table.</p>

<p>For example:</p>

<p>should be processed by the compiler as:</p>

<h3>lookup()</h3>

<p>lookup() operation is used to search a name in the symbol table to determine:</p>

<p>The format of lookup() function varies according to the programming language. The basic format should match the following:</p>

<p>This method returns 0 (zero) if the symbol does not exist in the symbol table. If the symbol exists in the symbol table, it returns its attributes stored in the table.</p>

<h2>Scope Management</h2>

<p>A compiler maintains two types of symbol tables: a <b>global symbol table</b> which can be accessed by all the procedures and <b>scope symbol tables</b> that are created for each scope in the program.</p>

<p>To determine the scope of a name, symbol tables are arranged in hierarchical structure as shown in the example below:</p>

<p>The above program can be represented in a hierarchical structure of symbol tables:</p>

<p>The global symbol table contains names for one global variable (int value) and two procedure names, which should be available to all the child nodes shown above. The names mentioned in the pro_one symbol table (and all its child tables) are not available for pro_two symbols and its child tables.</p>

<p>This symbol table data structure hierarchy is stored in the semantic analyzer and whenever a name needs to be searched in a symbol table, it is searched using the following algorithm:</p>

<p>first a symbol will be searched in the current scope, i.e. current symbol table.</p>

<p>if a name is found, then search is completed, else it will be searched in the parent symbol table until,</p>

<p>either the name is found or global symbol table has been searched for the name.</p>

<h1>Compiler - Intermediate Code Generation</h1>

<p>A source code can directly be translated into its target machine code, then why at all we need to translate the source code into an intermediate code which is then translated to its target code? Let us see the reasons why we need an intermediate code.</p>

<p>If a compiler translates the source language to its target machine language without having the option for generating intermediate code, then for each new machine, a full native compiler is required.</p>

<p>Intermediate code eliminates the need of a new full compiler for every unique machine by keeping the analysis portion same for all the compilers.</p>

<p>The second part of compiler, synthesis, is changed according to the target machine.</p>

<p>It becomes easier to apply the source code modifications to improve code performance by applying code optimization techniques on the intermediate code.</p>

<h2>Intermediate Representation</h2>

<p>Intermediate codes can be represented in a variety of ways and they have their own benefits.</p>

<p><b>High Level IR</b> -	High-level intermediate code representation is very close to the source language itself. They can be easily generated from the source code and we can easily apply code modifications to enhance performance. But for target machine optimization, it is less preferred.</p>

<p><b>Low Level IR</b> -	This one is close to the target machine, which makes it suitable for register and memory allocation, instruction set selection, etc. It is good for machine-dependent optimizations.</p>

<p>Intermediate code can be either language specific (e.g., Byte Code for Java) or language independent (three-address code).</p>

<h2>Three-Address Code</h2>

<p>Intermediate code generator receives input from its predecessor phase, semantic analyzer, in the form of an annotated syntax tree. That syntax tree then can be converted into a linear representation, e.g., postfix notation. Intermediate code tends to be machine independent code. Therefore, code generator assumes to have unlimited number of memory storage (register) to generate code.</p>

<p>For example:</p>

<p>The intermediate code generator will try to divide this expression into sub-expressions and then generate the corresponding code.</p>

<p>r being used as registers in the target program.</p>

<p>A three-address code has at most three address locations to calculate the expression. A three-address code can be represented in two forms : quadruples and triples.</p>

<h3>Quadruples</h3>

<p>Each instruction in quadruples presentation is divided into four fields: operator, arg1, arg2, and result. The above example is represented below in quadruples format:</p>

<h3>Triples</h3>

<p>Triples face the problem of code immovability while optimization, as the results are positional and changing the order or position of an expression may cause problems.</p>

<h3>Indirect Triples</h3>

<p>This representation is an enhancement over triples representation. It uses pointers instead of position to store results. This enables the optimizers to freely re-position the sub-expression to produce an optimized code.</p>

<h2>Declarations</h2>

<p>A variable or procedure has to be declared before it can be used. Declaration involves allocation of space in memory and entry of type and name in the symbol table. A program may be coded and designed keeping the target machine structure in mind, but it may not always be possible to accurately convert a source code to its target language.</p>

<p>Taking the whole program as a collection of procedures and sub-procedures, it becomes possible to declare all the names local to the procedure. Memory allocation is done in a consecutive manner and names are allocated to memory in the sequence they are declared in the program. We use offset variable and set it to zero {offset = 0} that denote the base address.</p>

<p>The source programming language and the target machine architecture may vary in the way names are stored, so relative addressing is used. While the first name is allocated memory starting from the memory location 0 {offset=0}, the next name declared later, should be allocated memory next to the first one.</p>

<p><b>Example:</b></p>

<p>We take the example of C programming language where an integer variable is assigned 2 bytes of memory and a float variable is assigned 4 bytes of memory.</p>

<p>To enter this detail in a symbol table, a procedure <i>enter</i> can be used. This method may have the following structure:</p>

<p>This procedure should create an entry in the symbol table, for variable <i>name</i>, having its type set to type and relative address <i>offset</i> in its data area.</p>

<h1>Compiler Design - Code Generation</h1>

<p>Code generation can be considered as the final phase of compilation. Through post code generation, optimization process can be applied on the code, but that can be seen as a part of code generation phase itself. The code generated by the compiler is an object code of some lower-level programming language, for example, assembly language. We have seen that the source code written in a higher-level language is transformed into a lower-level language that results in a lower-level object code, which should have the following minimum properties:</p>

<p>We will now see how the intermediate code is transformed into target object code (assembly code, in this case).</p>

<h2>Directed Acyclic Graph</h2>

<p>Directed Acyclic Graph (DAG) is a tool that depicts the structure of basic blocks, helps to see the flow of values flowing among the basic blocks, and offers optimization too. DAG provides easy transformation on basic blocks. DAG can be understood here:</p>

<p>Leaf nodes represent identifiers, names or constants.</p>

<p>Interior nodes represent operators.</p>

<p>Interior nodes also represent the results of expressions or the identifiers/name where the values are to be stored or assigned.</p>

<p><b>Example:</b></p>

<p>[t<sub>0</sub> = a + b]</p>

<p>[t<sub>1</sub> = t<sub>0</sub> + c]</p>

<p>[d = t<sub>0</sub> + t<sub>1</sub>]</p>

<h2>Peephole Optimization</h2>

<p>This optimization technique works locally on the source code to transform it into an optimized code. By locally, we mean a small portion of the code block at hand. These methods can be applied on intermediate codes as well as on target codes. A bunch of statements is analyzed and are checked for the following possible optimization:</p>

<h3>Redundant instruction elimination</h3>

<p>At source code level, the following can be done by the user:</p>

<p>At compilation level, the compiler searches for instructions redundant in nature. Multiple loading and storing of instructions may carry the same meaning even if some of them are removed. For example:</p>

<p>We can delete the first instruction and re-write the sentence as:</p>

<h3>Unreachable code</h3>

<p>Unreachable code is a part of the program code that is never accessed because of programming constructs. Programmers may have accidently written a piece of code that can never be reached.</p>

<p><b>Example:</b></p>

<p>In this code segment, the <b>printf</b> statement will never be executed as the program control returns back before it can execute, hence <b>printf</b> can be removed.</p>

<h3>Flow of control optimization</h3>

<p>There are instances in a code where the program control jumps back and forth without performing any significant task. These jumps can be removed. Consider the following chunk of code:</p>

<p>In this code,label L1 can be removed as it  passes the control to L2. So instead of jumping to L1 and then to L2, the control can directly reach L2, as shown below:</p>

<h3>Algebraic expression simplification</h3>

<p>There are occasions where algebraic expressions can be made simple. For example, the expression <b>a = a + 0</b> can be replaced by <b>a</b> itself and the expression a = a + 1 can simply be replaced by INC a.</p>

<h3>Strength reduction</h3>

<p>There are operations that consume more time and space. Their ‘strength’ can be reduced by replacing them with other operations that consume less time and space, but produce the same result.</p>

<p>For example, <b>x * 2</b> can be replaced by <b>x << 1</b>, which involves only one left shift. Though the output of a * a and a<sup>2</sup> is same, a<sup>2</sup> is much more efficient to implement.</p>

<h3>Accessing machine instructions</h3>

<p>The target machine can deploy more sophisticated instructions, which can have the capability to perform specific operations much efficiently. If the target code can accommodate those instructions directly, that will not only improve the quality of code, but also yield more efficient results.</p>

<h2>Code Generator</h2>

<p>A code generator is expected to have an understanding of the target machine’s runtime environment and its instruction set. The code generator should take the following things into consideration to generate the code:</p>

<p><b>Target language</b> : The code generator has to be aware of the nature of the target language for which the code is to be transformed. That language may facilitate some machine-specific instructions to help the compiler generate the code in a more convenient way. The target machine can have either CISC or RISC processor architecture.</p>

<p><b>IR Type</b> :	Intermediate representation has various forms. It can be in Abstract Syntax Tree (AST) structure, Reverse Polish Notation, or 3-address code.</p>

<p><b>Selection of instruction</b> : The code generator takes Intermediate Representation as input and converts (maps) it into target machine’s instruction set. One representation can have many ways (instructions) to convert it, so it becomes the responsibility of the code generator to choose the appropriate instructions wisely.</p>

<p><b>Register allocation</b> :	A program has a number of values to be maintained during the execution. The target machine’s architecture may not allow all of the values to be kept in the CPU memory or registers. Code generator decides what values to keep in the registers. Also, it decides the registers to be used to keep these values.</p>

<p><b>Ordering of instructions</b> : At last, the code generator decides the order in which the instruction will be executed. It creates schedules for instructions to execute them.</p>

<h2>Descriptors</h2>

<p>The code generator has to track both the registers (for availability) and addresses (location of values) while generating the code. For both of them, the following two descriptors are used:</p>

<p><b>Register descriptor</b> :	Register descriptor is used to inform the code generator about the availability of registers. Register descriptor keeps track of values stored in each register. Whenever a new register is required during code generation, this descriptor is consulted for register availability.</p>

<p><b>Address descriptor</b> : Values of the names (identifiers) used in the program might be stored at different locations while in execution. Address descriptors are used to keep track of memory locations where the values of identifiers are stored. These locations may include CPU registers, heaps, stacks, memory or a combination of the mentioned locations.</p>

<p>Code generator keeps both the descriptor updated in real-time. For a load statement, LD R1, x, the code generator:</p>

<h2>Code Generation</h2>

<p>Basic blocks comprise of a sequence of three-address instructions. Code generator takes these sequence of instructions as input.</p>

<p><b>Note</b> : If the value of a name is found at more than one place (register, cache, or memory), the register’s value will be preferred over the cache and main memory. Likewise cache’s value will be preferred over the main memory. Main memory is barely given any preference.</p>

<p><b>getReg</b> : Code generator uses <i>getReg</i> function to determine the status of available registers and the location of name values. <i>getReg</i> works as follows:</p>

<p>If variable Y is already in register R, it uses that register.</p>

<p>Else if some register R is available, it uses that register.</p>

<p>Else if both the above options are not possible, it chooses a register that requires minimal number of load and store instructions.</p>

<p>For an instruction x = y OP z, the code generator may perform the following actions. Let us assume that L is the location (preferably register) where the output of y OP z is to be saved:</p>

<p>Call function getReg, to decide the location of L.</p>

<p>Determine the present location (register or memory) of <b>y</b> by consulting the Address Descriptor of <b>y</b>. If <b>y</b> is not presently in register <b>L</b>, then generate the following instruction to copy the value of <b>y</b> to <b>L</b>:</p>

<p>MOV y’, L</p>

<p>where <b>y’</b> represents the copied value of <b>y</b>.</p>

<p>Determine the present location of <b>z</b> using the same method used in step 2 for <b>y</b> and generate the following instruction:</p>

<p>OP z’, L</p>

<p>where <b>z’</b> represents the copied value of <b>z</b>.</p>

<p>Now L contains the value of y OP z, that is intended to be assigned to <b>x</b>. So, if L is a register, update its descriptor to indicate that it contains the value of <b>x</b>. Update the descriptor of <b>x</b> to indicate that it is stored at location <b>L</b>.</p>

<p>If y and z has no further use, they can be given back to the system.</p>

<p>Other code constructs like loops and conditional statements are transformed into assembly language in general assembly way.</p>

<h1>Compiler Design - Code Optimization</h1>

<p>Optimization is a program transformation technique, which tries to improve the code by making it consume less resources (i.e. CPU, Memory) and deliver high speed.</p>

<p>In optimization, high-level general programming constructs are replaced by very efficient low-level programming codes. A code optimizing process must follow the three rules given below:</p>

<p>The output code must not, in any way, change the meaning of the program.</p>

<p>Optimization should increase the speed of the program and if possible, the program should demand less number of resources.</p>

<p>Optimization should itself be fast and should not delay the overall compiling process.</p>

<p>Efforts for an optimized code can be made at various levels of compiling the process.</p>

<p>At the beginning, users can change/rearrange the code or use better algorithms to write the code.</p>

<p>After generating intermediate code, the compiler can modify the intermediate code by address calculations and improving loops.</p>

<p>While producing the target machine code, the compiler can make use of memory hierarchy and CPU registers.</p>

<p>Optimization can be categorized broadly into two types : machine independent and machine dependent.</p>

<h2>Machine-independent Optimization</h2>

<p>In this optimization, the compiler takes in the intermediate code and transforms a part of the code that does not involve any CPU registers and/or absolute memory locations. For example:</p>

<p>This code involves repeated assignment of the identifier item, which if we put this way:</p>

<p>should not only save the CPU cycles, but  can be used on any processor.</p>

<h2>Machine-dependent Optimization</h2>

<p>Machine-dependent optimization is done after the target code has been generated and when the code is transformed according to the target machine architecture. It involves CPU registers and may have absolute memory references rather than relative references. Machine-dependent optimizers put efforts to take maximum advantage of memory hierarchy.</p>

<h2>Basic Blocks</h2>

<p>Source codes generally have a number of instructions, which are always executed in sequence and are considered as the basic blocks of the code. These basic blocks do not have any jump statements among them, i.e., when the first instruction is executed, all the instructions in the same basic block will be executed in their sequence of appearance without losing the flow control of the program.</p>

<p>A program can have various constructs as basic blocks, like IF-THEN-ELSE, SWITCH-CASE conditional statements and loops such as DO-WHILE, FOR, and REPEAT-UNTIL, etc.</p>

<h3>Basic block identification</h3>

<p>We may use the following algorithm to find the basic blocks in a program:</p>

<p>Search header statements of all the basic blocks from where a basic block starts:</p>

<p>Header statements and the statements following them form a basic block.</p>

<p>A basic block does not include any header statement of any other basic block.</p>

<p>Basic blocks are important concepts from both code generation and optimization point of view.</p>

<p>Basic blocks play an important role in identifying variables, which are being used more than once in a single basic block. If any variable is being used more than once, the register memory allocated to that variable need not be emptied unless the block finishes execution.</p>

<h3>Control Flow Graph</h3>

<p>Basic blocks in a program can be represented by means of control flow graphs. A control flow graph depicts how the program control is being passed among the blocks. It is a useful tool that helps in optimization by help locating any unwanted loops in the program.</p>

<h2>Loop Optimization</h2>

<p>Most programs run as a loop in the system. It becomes necessary to optimize the loops in order to save CPU cycles and memory. Loops can be optimized by the following techniques:</p>

<p><b>Invariant code</b> : A fragment of code that resides in the loop and computes the same value at each iteration is called a loop-invariant code. This code can be moved out of the loop by saving it to be computed only once, rather than with each iteration.</p>

<p><b>Induction analysis</b> : A variable is called an induction variable if its value is altered within the loop by a loop-invariant value.</p>

<p><b>Strength reduction</b> : There are expressions that consume more CPU cycles, time, and memory. These expressions should be replaced with cheaper expressions without compromising the output of expression. For example, multiplication (x * 2) is expensive in terms of CPU cycles than (x << 1) and yields the same result.</p>

<h2>Dead-code Elimination</h2>

<p>Dead code is one or more than one code statements, which are:</p>

<p>Thus, dead code plays no role in any program operation and therefore it can simply be eliminated.</p>

<h3>Partially dead code</h3>

<p>There are some code statements whose computed values are used only under certain circumstances, i.e., sometimes the values are used and sometimes they are not. Such codes are known as partially dead-code.</p>

<p>The above control flow graph depicts a chunk of program where variable ‘a’ is used to assign the output of expression ‘x * y’. Let us assume that the value assigned to ‘a’ is never used inside the loop.Immediately after the control leaves the loop, ‘a’ is assigned the value of variable ‘z’, which would be used later in the program. We conclude here that the assignment code of ‘a’ is never used anywhere, therefore it is eligible to be eliminated.</p>

<p>Likewise, the picture above depicts that the conditional statement is always false, implying that the code, written in true case, will never be executed, hence it can be removed.</p>

<h2>Partial Redundancy</h2>

<p>Redundant expressions are computed more than once in parallel path, without any change in operands.whereas partial-redundant expressions are computed more than once in a path, without any change in operands. For example,</p>

<p>Loop-invariant code is partially redundant and can be eliminated by using a code-motion technique.</p>

<p>Another example of a partially redundant code can be:</p>

<p>We assume that the values of operands (<b>y</b> and <b>z</b>) are not changed from assignment of variable <b>a</b> to variable <b>c</b>. Here, if the condition statement is true, then y OP z is computed twice, otherwise once. Code motion can be used to eliminate this redundancy, as shown below:</p>

<p>Here, whether the condition is true or false; y OP z should be computed only once.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
&lt;token-name, attribute-value&gt;
</pre>
<h3>Syntax Analysis</h3>
<p>The next phase is called the syntax analysis or <b>parsing</b>. It takes the token produced by lexical analysis as input and generates a parse tree (or syntax tree). In this phase, token arrangements are checked against the source code grammar, i.e. the parser checks if the expression made by the tokens is syntactically correct.</p>
<h3>Semantic Analysis</h3>
<p>Semantic analysis checks whether the parse tree constructed follows the rules of language. For example, assignment of values is between compatible data types, and adding string to an integer. Also, the semantic analyzer keeps track of identifiers, their types and expressions; whether identifiers are declared before use or not etc. The semantic analyzer produces an annotated syntax tree as an output.</p>
<h3>Intermediate Code Generation</h3>
<p>After semantic analysis the compiler generates an intermediate code of the source code for the target machine. It represents a program for some abstract machine. It is in between the high-level language and the machine language. This intermediate code should be generated in such a way that it makes it easier to be translated into the target machine code.</p>
<h3>Code Optimization</h3>
<p>The next phase does code optimization of the intermediate code. Optimization can be assumed as something that removes unnecessary code lines, and arranges the sequence of statements in order to speed up the program execution without wasting resources (CPU, memory).</p>
<h3>Code Generation</h3>
<p>In this phase, the code generator takes the optimized representation of the intermediate code and maps it to the target machine language. The code generator translates the intermediate code into a sequence of (generally) re-locatable machine code. Sequence of instructions of machine code performs the task as the intermediate code would do.</p>
<h3>Symbol Table</h3>
<p>It is a data-structure maintained throughout all the phases of a compiler. All the identifier's names along with their types are stored here. The symbol table makes it easier for the compiler to quickly search the identifier record and retrieve it. The symbol table is also used for scope management.</p>
<h1>Compiler Design - Lexical Analysis</h1>
<p>Lexical analysis is the first phase of a compiler. It takes the modified source code from language preprocessors that are written in the form of sentences. The lexical analyzer breaks these syntaxes into a series of tokens, by removing any whitespace or comments in the source code.</p>
<p>If the lexical analyzer finds a token invalid, it generates an error. The lexical analyzer works closely with the syntax analyzer. It reads character streams from the source code, checks for legal tokens, and passes the data to the syntax analyzer when it demands.</p>
<img src="/compiler_design/images/token_passing.jpg" alt="Token passing in compiler" />
<h2>Tokens</h2>
<p>Lexemes are said to be a sequence of characters (alphanumeric) in a token. There are some predefined rules for every lexeme to be identified as a valid token. These rules are defined by grammar rules, by means of a pattern. A pattern explains what can be a token, and these patterns are defined by means of regular expressions.</p>
<p>In programming language, keywords, constants, identifiers, strings, numbers, operators and punctuations symbols can be considered as tokens.</p>
<p>For example, in C language, the variable declaration line</p>
<pre class="prettyprint notranslate">
int value = 100;
</pre>
<p>contains the tokens:</p>
<pre class="prettyprint notranslate">
int (keyword), value (identifier), = (operator), 100 (constant) and ; (symbol).
</pre>
<h2>Specifications of Tokens</h2>
<p>Let us understand how the language theory undertakes the following terms:</p>
<h3>Alphabets</h3>
<p>Any finite set of symbols {0,1} is a set of binary alphabets, {0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F} is a set of Hexadecimal alphabets, {a-z, A-Z} is a set of English language alphabets.</p>
<h3>Strings</h3>
<p>Any finite sequence of alphabets is called a string. Length of the string is the total number of occurrence of alphabets, e.g., the length of the string tutorialspoint is 14 and is denoted by |tutorialspoint| = 14. A string having no alphabets, i.e. a string of zero length is known as an empty string and is denoted by ε (epsilon).</p>
<h3>Special Symbols</h3>
<p>A typical high-level language contains the following symbols:-</p>
<table class="table table-bordered">
<tr>
<td style="width:26%;">Arithmetic Symbols</td>
<td>Addition(+), Subtraction(-), Modulo(%), Multiplication(*), Division(/)</td>
</tr>
<tr>
<td>Punctuation</td>
<td>Comma(,), Semicolon(;), Dot(.), Arrow(->)</td>
</tr>
<tr>
<td>Assignment</td>
<td>=</td>
</tr>
<tr>
<td>Special Assignment</td>
<td>+=, /=, *=, -=</td>
</tr>
<tr>
<td>Comparison</td>
<td>==, !=, <, <=, >, >=</td>
</tr>
<tr>
<td>Preprocessor</td>
<td>#</td>
</tr>
<tr>
<td>Location Specifier</td>
<td>&amp; </td>
</tr>
<tr>
<td>Logical</td>
<td>&amp;, &amp;&amp;, |, ||, !</td>
</tr>
<tr>
<td>Shift Operator</td>
<td>>>, >>>, <<, <<<</td>
</tr>
</table>
<h3>Language</h3>
<p>A language is considered as a finite set of strings over some finite set of alphabets.
Computer languages are considered as finite sets, and mathematically set operations can be performed on them. Finite languages can be described by means of regular expressions.</p>
<h2>Regular Expressions</h2>
<p>The lexical analyzer needs to scan and identify only a finite set of valid string/token/lexeme that belong to the language in hand. It searches for the pattern defined by the language rules.</p>
<p>Regular expressions have the capability to express finite languages by defining a pattern for finite strings of symbols. The grammar defined by regular expressions is known as <b>regular grammar</b>. The language defined by regular grammar is known as <b>regular language</b>.</p>
<p>Regular expression is an important notation for specifying patterns. Each pattern matches a set of strings, so regular expressions serve as names for a set of strings. Programming language tokens can be described by regular languages. The specification of regular expressions is an example of a recursive definition. Regular languages are easy to understand and have efficient implementation.</p>
<p>There are a number of algebraic laws that are obeyed by regular expressions, which can be used to manipulate regular expressions into equivalent forms.</p>
<h2>Operations</h2>
<p>The various operations on languages are:</p>
<ul class="list">
<li><p>Union of two languages L and M is written as</p>
<p>L U M = {s | s is in L or s is in M}</p></li>
<li><p>Concatenation of two languages L and M is written as</p>
<p>LM = {st | s is in L and t is in M}</p></li>
<li><p>The Kleene Closure of a language L is written as</p>
<p>L* = Zero or more occurrence of language L.</p></li>
</ul>
<h2>Notations</h2>
<p>If r and s are regular expressions denoting the languages L(r) and L(s), then</p>
<ul class="list">
<li><p><b>Union</b> : (r)|(s) is a regular expression denoting L(r) U L(s)</p></li>
<li><p><b>Concatenation</b> : (r)(s) is a regular expression denoting L(r)L(s)</p></li>
<li><p><b>Kleene closure</b> : (r)* is a regular expression denoting (L(r))*</p></li>
<li><p>(r) is a regular expression denoting L(r)</p></li>
</ul>
<h2>Precedence and Associativity</h2>
<ul class="list">
<li>*, concatenation (.), and | (pipe sign) are left associative</li>
<li>* has the highest precedence</li>
<li>Concatenation (.) has the second highest precedence.</li>
<li>| (pipe sign) has the lowest precedence of all.</li>
</ul>
<h3>Representing valid tokens of a language in regular expression</h3>
<p>If x is a regular expression, then:</p>
<ul class="list">
   <li><p>x* means zero or more occurrence of x.</p>
<p>i.e., it can generate { e, x, xx, xxx, xxxx, … }</p>
</li>
   <li><p>x+ means one or more occurrence of x.</p>
<p>i.e., it can generate { x, xx, xxx, xxxx … } or x.x*</p>
</li>
<li><p>x? means at most one occurrence of x</p>
<p>i.e., it can generate either {x} or {e}.</p>
</li>
<p>[a-z] is all lower-case alphabets of English language.</p>
<p>[A-Z] is all upper-case alphabets of English language.</p>
<p>[0-9] is all natural digits used in mathematics.</p>
</ul>
<h3>Representing occurrence of symbols using regular expressions</h3>
<p>letter = [a – z] or [A – Z]</p>
<p>digit  = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 or [0-9]</p>
<p>sign = [ + | - ]</p>
<h3>Representing language tokens using regular expressions</h3>
<p>Decimal = (sign)<sup>?</sup>(digit)<sup>+</sup></p>
<p>Identifier = (letter)(letter | digit)*</p>
<p>The only problem left with the lexical analyzer is how to verify the validity of a regular expression used in specifying the patterns of keywords of a language. A well-accepted solution is to use finite automata for verification.</p>
<h2>Finite Automata</h2>
<p>Finite automata is a state machine that takes a string of symbols as input and changes its state accordingly. Finite automata is a recognizer for regular expressions. When a regular expression string is fed into finite automata, it changes its state for each literal. If the input string is successfully processed and the automata reaches its final state, it is accepted, i.e., the string just fed was said to be a valid token of the language in hand.</p>
<p>The mathematical model of finite automata consists of:</p>
<ul class="list">
<li>Finite set of states (Q)</li>
<li>Finite set of input symbols (Σ)</li>
<li>One Start state (q0)</li>
<li>Set of final states (qf)</li>
<li>Transition function (δ)</li>
</ul>
<p>The transition function (δ) maps the finite set of state (Q) to a finite set of input symbols (Σ), Q × Σ ➔ Q</p>
<h3>Finite Automata Construction</h3>
<p>Let L(r) be a regular language recognized by some finite automata (FA).</p>
<ul class="list">
<li><p><b>States</b> : States of FA are represented by circles. State names are written inside circles.</p></li>
<li><p><b>Start state</b> : The state from where the automata starts, is known as the start state. Start state has an arrow pointed towards it.</p></li>
<li><p><b>Intermediate states</b> : All intermediate states have at least two arrows; one pointing to and another pointing out from them.</p></li>
<li><p><b>Final state</b> : If the input string is successfully parsed, the automata is expected to be in this state. Final state is represented by double circles. It may have any odd number of arrows pointing to it and even number of arrows pointing out from it. The number of odd arrows are one greater than even, i.e. <b>odd = even+1</b>.</p></li>
<li><p><b>Transition</b> : The transition from one state to another state happens when a desired symbol in the input is found. Upon transition, automata can either move to the next state or stay in the same state. Movement from one state to another is shown as a directed arrow, where the arrows points to the destination state. If automata stays on the same state, an arrow pointing from a state to itself is drawn.</p></li>
</ul>
<p><b>Example</b> : We assume FA accepts any three digit binary value ending in digit 1.
FA = {Q(q<sub>0</sub>, q<sub>f</sub>), Σ(0,1), q<sub>0</sub>, q<sub>f</sub>, δ}</p>
<img src="/compiler_design/images/finite_automata.jpg" alt="Finite automata construction" />
<h3>Longest Match Rule</h3>
<p>When the lexical analyzer read the source-code, it scans the code letter by letter; and when it encounters a whitespace, operator symbol, or special symbols, it decides that a word is completed.</p>
<p><b>For example:</b></p>
<pre class="prettyprint notranslate">
int intvalue;
</pre>
<p>While scanning both lexemes till ‘int’, the lexical analyzer cannot determine whether it is a keyword <i>int</i> or the initials of identifier int value.</p>
<p>The Longest Match Rule states that the lexeme scanned should be determined based on the longest match among all the tokens available.</p>
<p>The lexical analyzer also follows <b>rule priority</b> where a reserved word, e.g., a keyword, of a language is given priority over user input. That is, if the lexical analyzer finds a lexeme that matches with any existing reserved word, it should generate an error.</p>
<h1>Compiler Design - Syntax Analysis</h1>
<p>Syntax analysis or parsing is the second phase of a compiler. In this chapter, we shall learn the basic concepts used in the construction of a parser.</p>
<p>We have seen that a lexical analyzer can identify tokens with the help of regular expressions and pattern rules. But a lexical analyzer cannot check the syntax of a given sentence due to the limitations of the regular expressions. Regular expressions cannot check balancing tokens, such as parenthesis. Therefore, this phase uses context-free grammar (CFG), which is recognized by push-down automata.</p>
<p>CFG, on the other hand, is a superset of Regular Grammar, as depicted below:</p>
<img src="/compiler_design/images/CFG_regular_grammar.jpg" alt="Relation of CFG and Regular Grammar" />
<p>It implies that every Regular Grammar is also context-free, but there exists some problems, which are  beyond the scope of Regular Grammar. CFG is a helpful tool in describing the syntax of programming languages.</p>
<h2>Context-Free Grammar</h2>
<p>In this section, we will first see the definition of context-free grammar and introduce terminologies used in parsing technology.</p>
<p>A context-free grammar has four components:</p>
<ul class="list">
<li><p>A set of <b>non-terminals</b> (V). Non-terminals are syntactic variables that denote sets of strings. The non-terminals define sets of strings that help define the language generated by the grammar.</p></li>
<li><p>A set of tokens, known as <b>terminal symbols</b> (Σ). Terminals are the basic symbols from which strings are formed.</p></li>
<li><p>A set of <b>productions</b> (P). The productions of a grammar specify the manner in which the terminals and non-terminals can be combined to form strings. Each production consists of a <b>non-terminal</b> called the left side of the production, an arrow, and a sequence of tokens and/or <b>on- terminals</b>, called the right side of the production.</p></li>
<li><p>One of the non-terminals is designated as the start symbol (S); from where the production begins.</p></li>
</ul>
<p>The strings are derived from the start symbol by repeatedly replacing a non-terminal (initially the start symbol) by the right side of a production, for that non-terminal.</p>
<h3>Example</h3>
<p>We take the problem of palindrome language, which cannot be described by means of Regular Expression. That is, L = { w | w = w<sup>R</sup> } is not a regular language. But it can be described by means of CFG, as illustrated below:</p>
<pre class="prettyprint notranslate">
G = ( V, Σ, P, S )
</pre>
<p>Where:</p>
<pre class="prettyprint notranslate">
V = { Q, Z, N }
Σ = { 0, 1 }
P = { Q → Z | Q → N | Q → ℇ | Z → 0Q0 | N → 1Q1 }
S = { Q }
</pre>
<p>This grammar describes palindrome language, such as: 1001, 11100111, 00100, 1010101, 11111, etc.</p>
<h2>Syntax Analyzers</h2>
<p>A syntax analyzer or parser takes the input from a lexical analyzer in the form of token streams. The parser analyzes the source code (token stream) against the production rules to detect any errors in the code. The output of this phase is a <b>parse tree</b>.</p>
<img src="/compiler_design/images/syntax_analyzer.jpg" alt="Syntax Analyzer" />

<p>This way, the parser accomplishes two tasks, i.e., parsing the code, looking for errors and generating a parse tree as the output of the phase.</p>
<p>Parsers are expected to parse the whole code even if some errors exist in the program. Parsers use error recovering strategies, which we will learn later in this chapter.</p>
<h2>Derivation</h2>
<p>A derivation is basically a sequence of production rules, in order to get the input string. During parsing, we take two decisions for some sentential form of input:</p>
<ul class="list">
<li>Deciding the non-terminal which is to be replaced.</li>
<li>Deciding the production rule, by which, the non-terminal will be replaced.</li>
</ul>
<p>To decide which non-terminal to be replaced with production rule, we can have two options.</p>
<h3>Left-most Derivation</h3>
<p>If the sentential form of an input is scanned and replaced from left to right, it is called left-most derivation. The sentential form derived by the left-most derivation is called the left-sentential form.</p>
<h3>Right-most Derivation</h3>
<p>If we scan and replace the input with production rules, from right to left, it is known as right-most derivation. The sentential form derived from the right-most derivation is called the right-sentential form.</p>
<p><b>Example</b></p>
<p>Production rules:</p>
<pre class="prettyprint notranslate">
E → E + E
E → E * E
E → id 
</pre>
<p>Input string: id + id * id</p>
<p>The left-most derivation is:</p>
<pre class="prettyprint notranslate">
E → E * E
E → E + E * E
E → id + E * E
E → id + id * E
E → id + id * id
</pre>
<p>Notice that the left-most side non-terminal is always processed first.</p>
<p>The right-most derivation is:</p>
<pre class="prettyprint notranslate">
E → E + E
E → E + E * E
E → E + E * id
E → E + id * id
E → id + id * id
</pre>
<h2>Parse Tree</h2>
<p>A parse tree is a graphical depiction of a derivation. It is convenient to see how strings are derived from the start symbol. The start symbol of the derivation becomes the root of the parse tree. Let us see this by an example from the last topic.</p>
<p>We take the left-most derivation of a + b * c</p>
<p>The left-most derivation is:</p>
<pre class="prettyprint notranslate">
E → E * E
E → E + E * E
E → id + E * E
E → id + id * E
E → id + id * id
</pre>
<p>Step 1:</p>
<table class="table table-bordered">
<tr><td width="50%" style="vertical-align:middle">E → E * E</td><td><img src="/compiler_design/images/parse_tree_step_1.jpg" alt="Parse Tree Construction" /></td></tr>
</table>

<p>Step 2:</p>
<table class="table table-bordered">
<tr><td width="50%" style="vertical-align:middle">E → E + E * E</td><td><img src="/compiler_design/images/parse_tree_step_2.jpg" alt="Parse Tree Construction" /></td></tr>
</table>

<p>Step 3:</p>
<table class="table table-bordered">
<tr><td width="50%" style="vertical-align:middle">E → id + E * E</td><td><img src="/compiler_design/images/parse_tree_step_3.jpg" alt="Parse Tree Construction" /></td></tr>
</table>

<p>Step 4:</p>
<table class="table table-bordered">
<tr><td width="50%" style="vertical-align:middle">E → id + id * E</td><td><img src="/compiler_design/images/parse_tree_step_4.jpg" alt="Parse Tree Construction" /></td></tr>
</table>

<p>Step 5:</p>
<table class="table table-bordered">
<tr><td width="50%" style="vertical-align:middle">E → id + id * id</td><td><img src="/compiler_design/images/parse_tree_step_5.jpg" alt="Parse Tree Construction" /></td></tr>
</table>

<p>In a parse tree:</p>
<ul class="list">
<li>All leaf nodes are terminals.</li>
<li>All interior nodes are non-terminals.</li>
<li>In-order traversal gives original input string.</li>
</ul>
<p>A parse tree depicts associativity and precedence of operators. The deepest sub-tree is traversed first, therefore the operator in that sub-tree gets precedence over the operator which is in the parent nodes.</p>
<h2>Types of Parsing</h2>
<p>Syntax analyzers follow production rules defined by means of context-free grammar. The way the production rules are implemented (derivation) divides parsing into two types : top-down parsing and bottom-up parsing.</p>
<h3>Top-down Parsing</h3>
<p>When the parser starts constructing the parse tree from the start symbol and then tries to transform the start symbol to the input, it is called top-down parsing.</p>
<ul class="list">
<li><p><b>Recursive descent parsing</b> : It is a common form of top-down parsing. It is called recursive as it uses recursive procedures to process the input. Recursive descent parsing suffers from backtracking.</p></li>
<li><p><b>Backtracking</b> : It means, if one derivation of a production fails, the syntax analyzer restarts the process using different rules of same production. This technique may process the input string more than once to determine the right production.
</p></li>
</ul>
<h3>Bottom-up Parsing</h3>
<p>As the name suggests, bottom-up parsing starts with the input symbols and tries to construct the parse tree up to the start symbol.</p>
<p><b>Example:</b></p>
<p>Input string : a + b * c</p>
<p>Production rules:</p>
<pre class="prettyprint notranslate">
S → E
E → E + T
E → E * T
E → T
T → id
</pre>
<p>Let us start bottom-up parsing</p>
<pre class="prettyprint notranslate">
a + b * c
</pre>
<p>Read the input and check if any production matches with the input:</p>
<pre class="prettyprint notranslate">
a + b * c
T + b * c
E + b * c
E + T * c
E * c
E * T
E
S
</pre>
<h3>Ambiguity</h3>
<p>A grammar G is said to be ambiguous if it has more than one parse tree (left or right derivation) for at least one string.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
E → E + E
E → E – E
E → id
</pre>
<p>For the string id + id – id, the above grammar generates two parse trees:</p>
<img src="/compiler_design/images/parse_tree_ambiguity.jpg" alt="Parse Tree Construction" />
   
<p>The language generated by an ambiguous grammar is said to be <b>inherently ambiguous</b>. Ambiguity in grammar is not good for a compiler construction. No method can detect and remove ambiguity automatically, but it can be removed by either re-writing the whole grammar without ambiguity, or by setting and following associativity and precedence constraints.</p>
<h3>Associativity</h3>
<p>If an operand has operators on both sides, the side on which the operator takes this operand is decided by the associativity of those operators. If the operation is left-associative, then the operand will be taken by the left operator or if the operation is right-associative, the right operator will take the operand.</p>
<p><b>Example</b></p>
<p>Operations such as Addition, Multiplication, Subtraction, and Division are left associative. If the expression contains:</p>
<pre class="prettyprint notranslate">
id op id op id
</pre>
<p>it will be evaluated as:</p>
<pre class="prettyprint notranslate">
(id op id) op id
</pre>
<p>For example, (id + id) + id</p>
<p>Operations like Exponentiation are right associative, i.e., the order of evaluation in the same expression will be:</p>
<pre class="prettyprint notranslate">
id op (id op id)
</pre>
<p>For example, id ^ (id ^ id)</p>
<h3>Precedence</h3> 
<p>If two different operators share a common operand, the precedence of operators decides which will take the operand. That is, 2+3*4 can have two different parse trees, one corresponding to (2+3)*4 and another corresponding to 2+(3*4). By setting precedence among operators, this problem can be easily removed. As in the previous example, mathematically * (multiplication) has precedence over + (addition), so the expression 2+3*4 will always be interpreted as:</p>
<pre class="prettyprint notranslate">
2 + (3 * 4)
</pre>
<p>These methods decrease the chances of ambiguity in a language or its grammar.</p>
<h3>Left Recursion</h3>
<p>A grammar becomes left-recursive if it has any non-terminal ‘A’ whose derivation contains ‘A’ itself as the left-most symbol. Left-recursive grammar is considered to be a problematic situation for top-down parsers. Top-down parsers start parsing from the Start symbol, which in itself is non-terminal. So, when the parser encounters the same non-terminal in its derivation, it becomes hard for it to judge when to stop parsing the left non-terminal and it goes into an infinite loop.</p>
<p><b>Example:</b></p>
<pre class="prettyprint notranslate">
(1) A => Aα | β

(2) S => Aα | β 
    A => Sd 
</pre>
<p>(1) is an example of immediate left recursion, where A is any non-terminal symbol and α represents a string of non-terminals.</p>
<p>(2) is an example of indirect-left recursion.</p>
<img src="/compiler_design/images/left_recursion.jpg" alt="Left Recursion" />
<p>A top-down parser will first parse the A, which in-turn will yield a string consisting of A itself and the parser may go into a loop forever.</p>
<h3>Removal of Left Recursion</h3>
<p>One way to remove left recursion is to use the following technique:</p>
<p>The production</p>
<pre class="prettyprint notranslate">
A => Aα | β
</pre>
<p>is converted into following productions</p>
<pre class="prettyprint notranslate">
A => βA’
A => αA’ | &epsilon;
</pre>
<p>This does not impact the strings derived from the grammar, but it removes immediate left recursion.</p>
<p>Second method is to use the following algorithm, which should eliminate all direct and indirect left recursions.</p>
<pre class="prettyprint notranslate">
Algorithm
START
Arrange non-terminals in some order like A1, A2, A3,…, An
for each i from 1 to n
{
for each j from 1 to i-1
   {
   replace each production of form Ai⟹Aj𝜸
   with Ai ⟹ δ1𝜸  | δ2𝜸 | δ3𝜸 |…| 𝜸 
   where Aj ⟹ δ1 | δ2|…| δn  are current Aj productions
}
   }
   eliminate immediate left-recursion
END
</pre>
<p><b>Example</b></p>
<p>The production set</p>
<pre class="prettyprint notranslate">
S => Aα | β 
A => Sd
</pre>
<p>after applying the above algorithm, should become</p>
<pre class="prettyprint notranslate">
S => Aα | β 
A => Aαd | βd
</pre>
<p>and then, remove immediate left recursion using the first technique.</p>
<pre class="prettyprint notranslate">
A => βdA’
A => αdA’ | &epsilon;
</pre>
<p>Now none of the production has either direct or indirect left recursion.</p>
<h3>Left Factoring</h3>
<p>If more than one grammar production rules has a common prefix string, then the top-down parser cannot make a choice as to which of the production it should take to parse the string in hand.</p>
<p><b>Example</b></p>
<p>If a top-down parser encounters a production like</p>
<pre class="prettyprint notranslate">
A ⟹ αβ | α𝜸 | …
</pre>
<p>Then it cannot determine which production to follow to parse the string as both productions are starting from the same terminal (or non-terminal). To remove this confusion, we use a technique called left factoring.</p>
<p>Left factoring transforms the grammar to make it useful for top-down parsers. In this technique, we make one production for each common prefixes and the rest of the derivation is added by new productions.</p>
<p><b>Example</b></p>
<p>The above productions can be written as</p>
<pre class="prettyprint notranslate">
A => αA’
A’=> β | 𝜸 | … 
</pre>
<p>Now the parser has only one production per prefix which makes it easier to take decisions.</p>
<h2>First and Follow Sets</h2>
<p>An important part of parser table construction is to create first and follow sets.  These sets can provide the actual position of any terminal in the derivation. This is done to create the parsing table where the decision of replacing T[A, t] = α with some production rule.</p>
<h3>First Set</h3>
<p>This set is created to know what terminal symbol is derived in the first position by a non-terminal. For example,</p>
<pre class="prettyprint notranslate">
α → t β
</pre>
<p>That is α derives t (terminal) in the very first position. So, t ∈ FIRST(α).</p>
<h4>Algorithm for calculating First set</h4>
<p>Look at the definition of FIRST(α) set:</p>
<ul class="list">
<li>if α is a terminal, then FIRST(α) = { α }.</li>
<li>if α is a non-terminal and α → ℇ is a production, then FIRST(α) = { ℇ }.</li>
<li>if α is a non-terminal and α →  𝜸1 𝜸2 𝜸3 … 𝜸n and any FIRST(𝜸) contains t then t is in FIRST(α).</li>
</ul>
<p>First set can be seen as: FIRST(α) = { t | α  &rarr;<sup>*</sup> t β } ∪ { ℇ | α &rarr;<sup>*</sup> &epsilon;}</p>
<h3>Follow Set</h3>
<p>Likewise, we calculate what terminal symbol immediately follows a non-terminal α in production rules. We do not consider what the non-terminal can generate but instead, we see what would be the next terminal symbol that follows the productions of a non-terminal.</p>
<h4>Algorithm for calculating Follow set:</h4>
<ul class="list">
<li><p>if α is a start symbol, then FOLLOW() = $</p></li>
<li><p>if α is a non-terminal and has a production α → AB, then FIRST(B) is in FOLLOW(A) except ℇ.</p></li>
<li><p>if α is a non-terminal and has a production α → AB, where B  ℇ, then FOLLOW(A) is in FOLLOW(α).</p></li>
</ul>
<p>Follow set can be seen as: FOLLOW(α) = { t | S   *αt*}</p>
<h2>Error-recovery Strategies</h2>
<p>A parser should be able to detect and report any error in the program. It is expected that when an error is encountered, the parser should be able to handle it and carry on parsing the rest of the input. Mostly it is expected from the parser to check for errors but errors may be encountered at various stages of the compilation process. A program may have the following kinds of errors at various stages:</p>
<ul class="list">
<li><p><b>Lexical</b> : name of some identifier typed incorrectly</p></li>
<li><p><b>Syntactical</b> : missing semicolon or unbalanced parenthesis</p></li>
<li><p><b>Semantical</b> : incompatible value assignment</p></li>
<li><p><b>Logical</b> : code not reachable, infinite loop</p></li>
</ul>
<p>There are four common error-recovery strategies that can be implemented in the parser to deal with errors in the code.</p>
<h3>Panic mode</h3>
<p>When a parser encounters an error anywhere in the statement, it ignores the rest of the statement by not processing input from erroneous input to delimiter, such as semi-colon. This is the easiest way of error-recovery and also, it prevents the parser from developing infinite loops.</p>
<h3>Statement mode</h3>
<p>When a parser encounters an error, it tries to take corrective measures so that the rest of inputs of statement allow the parser to parse ahead. For example, inserting a missing semicolon, replacing comma with a semicolon etc. Parser designers have to be careful here because one wrong correction may lead to an infinite loop.</p>
<h3>Error productions</h3>
<p>Some common errors are known to the compiler designers that may occur in the code. In addition, the designers can create augmented grammar to be used, as productions that generate erroneous constructs when these errors are encountered.</p>
<h3>Global correction</h3>
<p>The parser considers the program in hand as a whole and tries to figure out what the program is intended to do and tries to find out a closest match for it, which is error-free. When an erroneous input (statement) X is fed, it creates a parse tree for some closest error-free statement Y. This may allow the parser to make minimal changes in the source code, but due to the complexity (time and space) of this strategy, it has not been implemented in practice yet.</p>
<h3>Abstract Syntax Trees</h3>
<p>Parse tree representations are not easy to be parsed by the compiler, as they contain more details than actually needed. Take the following parse tree as an example:</p>
<img src="/compiler_design/images/parse_tree_step_5.jpg" alt="Parse Tree" />
<p>If watched closely, we find most of the leaf nodes are single child to their parent nodes. This information can be eliminated before feeding it to the next phase. By hiding extra information, we can obtain a tree as shown below:</p>
<img src="/compiler_design/images/abstract_syntax_tree.jpg" alt="Abstract Syntax Tree" />
<p>Abstract tree can be represented as:</p>
<img src="/compiler_design/images/abstract_syntax_tree_representation.jpg" alt="Abstract Syntax Tree Representation" />
<p>ASTs are important data structures in a compiler with least unnecessary information. ASTs are more compact than a parse tree and can be easily used by a compiler.</p>
<h2>Limitations of Syntax Analyzers</h2>
<p>Syntax analyzers receive their inputs, in the form of tokens, from lexical analyzers. Lexical analyzers are responsible for the validity of a token supplied by the syntax analyzer. Syntax analyzers have the following drawbacks:</p>
<ul class="list">
<li>it cannot determine if a token is valid,</li>
<li>it cannot determine if a token is declared before it is being used,</li>
<li>it cannot determine if a token is initialized before it is being used,</li>
<li>it cannot determine if an operation performed on a token type is valid or not.</li>
</ul>
<p>These tasks are accomplished by the semantic analyzer, which we shall study in Semantic Analysis.</p>
<h1>Compiler Design - Semantic Analysis</h1>
<p>We have learnt how a parser constructs parse trees in the syntax analysis phase. The plain parse-tree constructed in that phase is generally of no use for a compiler, as it does not carry any information of how to evaluate the tree. The productions of context-free grammar, which makes the rules of the language, do not accommodate how to interpret them.</p>
<p>For example</p>
<pre class="prettyprint notranslate">
E → E + T
</pre>
<p>The above CFG production has no semantic rule associated with it, and it cannot help in making any sense of the production.</p>
<h2>Semantics</h2>
<p>Semantics of a language provide meaning to its constructs, like tokens and syntax structure. Semantics help interpret symbols, their types, and their relations with each other. Semantic analysis judges whether the syntax structure constructed in the source program derives any meaning or not.</p>
<pre class="prettyprint notranslate">
CFG + semantic rules = Syntax Directed Definitions
</pre>
<p>For example:</p>
<pre class="prettyprint notranslate">
int a = “value”;
</pre>
<p>should not issue an error in lexical and syntax analysis phase, as it is lexically and structurally correct, but it should generate a semantic error as the type of the assignment differs. These rules are set by the grammar of the language and evaluated in semantic analysis. The following tasks should be performed in semantic analysis:</p>
<ul class="list">
<li>Scope resolution</li>
<li>Type checking</li>
<li>Array-bound checking<li>
</ul>
<h2>Semantic Errors</h2>
<p>We have mentioned some of the semantics errors that the semantic analyzer is expected to recognize:</p>
<ul class="list">
<li>Type mismatch</li>
<li>Undeclared variable</li>
<li>Reserved identifier misuse.</li>
<li>Multiple declaration of variable in a scope.</li>
<li>Accessing an out of scope variable.</li>
<li>Actual and formal parameter mismatch.</li>
</ul>
<h2>Attribute Grammar</h2>
<p>Attribute grammar is a special form of context-free grammar where some additional information (attributes) are appended to one or more of its non-terminals in order to provide context-sensitive information. Each attribute has well-defined domain of values, such as integer, float, character, string, and expressions.</p>
<p>Attribute grammar is a medium to provide semantics to the context-free grammar and it can help specify the syntax and semantics of a programming language. Attribute grammar (when viewed as a parse-tree) can pass values or information among the nodes of a tree.</p>
<p><b>Example:</b></p>
<pre class="prettyprint notranslate">
E → E + T { E.value = E.value + T.value }
</pre>
<p>The right part of the CFG contains the semantic rules that specify how the grammar should be interpreted. Here, the values of non-terminals E and T are added together and the result is copied to the non-terminal E.</p>
<p>Semantic attributes may be assigned to their values from their domain at the time of parsing and evaluated at the time of assignment or conditions. Based on the way the attributes get their values, they can be broadly divided into two categories : synthesized attributes and inherited attributes.</p>
<h3>Synthesized attributes</h3>
<p>These attributes get values from the attribute values of their child nodes. To illustrate, assume the following production:</p>
<pre class="prettyprint notranslate">
S → ABC
</pre>
<p>If S is taking values from its child nodes (A,B,C), then it is said to be a synthesized attribute, as the values of ABC are synthesized to S.</p>
<p>As in our previous example (E → E + T), the parent node E gets its value from its child node. Synthesized attributes never take values from their parent nodes or any sibling nodes.</p>
<h3>Inherited attributes</h3>
<p>In contrast to synthesized attributes, inherited attributes can take values from parent and/or siblings. As in the following production,</p>
<pre class="prettyprint notranslate">
S → ABC
</pre>
<p>A can get values from S, B and C. B can take values from S, A, and C. Likewise, C can take values from S, A, and B.</p>
<p><b>Expansion</b> : When a non-terminal is expanded to terminals as per a grammatical rule</p>
<img src="/compiler_design/images/inherited_attributes.jpg" alt="Inherited Attributes" />
<p><b>Reduction</b> : When a terminal is reduced to its corresponding non-terminal according to grammar rules. Syntax trees are parsed top-down and left to right. Whenever reduction occurs, we apply its corresponding semantic rules (actions).</p>
<p>Semantic analysis uses Syntax Directed Translations to perform the above tasks.</p>
<p>Semantic analyzer receives AST (Abstract Syntax Tree) from its previous stage (syntax analysis).</p>
<p>Semantic analyzer attaches attribute information with AST, which are called Attributed AST.</p>
<p>Attributes are two tuple value, &lt;attribute name, attribute value&gt;</p>
<p>For example:</p>
<pre class="prettyprint notranslate">
int value  = 5;
&lt;type, “integer”&gt;
&lt;presentvalue, “5”&gt;
</pre>
<p>For every production, we attach a semantic rule.</p>
<h2>S-attributed SDT</h2>
<p>If an SDT uses only synthesized attributes, it is called as S-attributed SDT. These attributes are evaluated using S-attributed SDTs that have their semantic actions written after the production (right hand side).</p>
<img src="/compiler_design/images/s_attributed_sdt.jpg" alt="S-attributed SDT" />
<p>As depicted above, attributes in S-attributed SDTs are evaluated in bottom-up parsing, as the values of the parent nodes depend upon the values of the child nodes.</p>
<h2>L-attributed SDT</h2>
<p>This form of SDT uses both synthesized and inherited attributes with restriction of not taking values from right siblings.</p>
<p>In L-attributed SDTs, a non-terminal can get values from its parent, child, and sibling nodes. As in the following production</p>
<pre class="prettyprint notranslate">
S → ABC
</pre>
<p>S can take values from A, B, and C (synthesized). A can take values from S only. B can take values from S and A. C can get values from S, A, and B. No non-terminal can get values from the sibling to its right.</p>
<p>Attributes in L-attributed SDTs are evaluated by depth-first and left-to-right parsing manner.</p>
<img src="/compiler_design/images/l_attributed_sdt.jpg" alt="L-attributed SDT" />
<p>We may conclude that if a definition is S-attributed, then it is also L-attributed as L-attributed definition encloses S-attributed definitions.</p>
<h1>Compiler Design - Parser</h1>
<p>In the previous chapter, we understood the basic concepts involved in parsing. In this chapter, we will learn the various types of parser construction methods available.</p>
<p>Parsing can be defined as top-down or bottom-up based on how the parse-tree is constructed.</p>
<img src="/compiler_design/images/types_of_parser.jpg" alt="Types of Parser" />
<h2>Top-Down Parsing</h2>
<p>We have learnt in the last chapter that the top-down parsing technique parses the input, and starts constructing a parse tree from the root node gradually moving down to the leaf nodes. The types of top-down parsing are depicted below:</p>
<img src="/compiler_design/images/top_down_parsing.jpg" alt="Top Down Parsing" />
<h3>Recursive Descent Parsing</h3>
<p>Recursive descent is a top-down parsing technique that constructs the parse tree from the top and the input is read from left to right. It uses procedures for every terminal and non-terminal entity. This parsing technique recursively parses the input to make a parse tree, which may or may not require back-tracking. But the grammar associated with it (if not left factored) cannot avoid back-tracking. A form of recursive-descent parsing that does not require any back-tracking is known as <b>predictive parsing</b>.</p>
<p>This parsing technique is regarded recursive as it uses context-free grammar which is recursive in nature.</p>
<h3>Back-tracking</h3>
<p>Top- down parsers start from the root node (start symbol) and match the input string against the production rules to replace them (if matched). To understand this, take the following example of CFG:</p>
<pre class="prettyprint notranslate">
S → rXd | rZd
X → oa | ea
Z → ai
</pre>
<p>For an input string: read, a top-down parser, will behave like this:</p>
<p>It will start with S from the production rules and will match its yield to the left-most letter of the input, i.e. ‘r’.  The very production of S (S → rXd) matches with it. So the top-down parser advances to the next input letter (i.e. ‘e’). The parser tries to expand non-terminal ‘X’ and checks its production from the left (X → oa). It does not match with the next input symbol. So the top-down parser backtracks to obtain the next production rule of X, (X → ea).</p>
<p>Now the parser matches all the input letters in  an ordered manner. The string is accepted.</p>
<table class="table table-bordered">
<tr>
<td>
<img src="/compiler_design/images/back_tracking_1.jpg" alt="Back Tracking" />
</td>
<td>
<img src="/compiler_design/images/back_tracking_2.jpg" alt="Back Tracking" />
</td>
<td>
<img src="/compiler_design/images/back_tracking_3.jpg" alt="Back Tracking" />
</td>
<td>
<img src="/compiler_design/images/back_tracking_4.jpg" alt="Back Tracking" />
</td>
</tr>
</table>
<h3>Predictive Parser</h3>
<p>Predictive parser is a recursive descent parser, which has the capability to predict which production is to be used to replace the input string. The predictive parser does not suffer from backtracking.</p>
<p>To accomplish its tasks, the predictive parser uses a look-ahead pointer, which points to the next input symbols. To make the parser back-tracking free, the predictive parser puts some constraints on the grammar and accepts only a class of grammar known as LL(k) grammar.</p>
<img src="/compiler_design/images/predictive_parser.jpg" alt="Predictive Parser" />
<p>Predictive parsing uses a stack and a parsing table to parse the input and generate a parse tree. Both the stack and the input contains an end symbol <b>$</b> to denote that the stack is empty and the input is consumed. The parser refers to the parsing table to take any decision on the input and stack element combination.</p>
<img src="/compiler_design/images/top_down_parser_construction.jpg" alt="Top-Down Parser Construction" />
<p>In recursive descent parsing, the parser may have more than one production to choose from for a single instance of input, whereas in predictive parser, each step has at most one production to choose. There might be instances where there is no production matching the input string, making the parsing procedure to fail.</p>
<h3>LL Parser</h3>
<p>An LL Parser accepts LL grammar. LL grammar is a subset of context-free grammar but with some restrictions to get the simplified version, in order to achieve easy implementation. LL grammar can be implemented by means of both algorithms namely, recursive-descent or table-driven.</p>
<p>LL parser is denoted as LL(k). The first L in LL(k) is parsing the input from left to right, the second L in LL(k) stands for left-most derivation and k itself represents the number of look aheads. Generally k = 1, so LL(k) may also be written as LL(1).</p>
<img src="/compiler_design/images/ll_parser.jpg" alt="LL Parser" />
<h3>LL Parsing Algorithm</h3>
<p>We may stick to deterministic LL(1) for parser explanation, as the size of table grows exponentially with the value of k. Secondly, if a given grammar is not LL(1), then usually, it is not LL(k), for any given k.</p>
<p>Given below is an algorithm for LL(1) Parsing:</p>
<pre class="prettyprint notranslate">
Input: 
string ω 
parsing table M for grammar G
Output:
   If ω is in L(G) then left-most derivation of ω,
   error otherwise.

Initial State : $S on stack (with S being start symbol)
   ω$ in the input buffer

SET ip to point the first symbol of ω$.
repeat
let X be the top stack symbol and a the symbol pointed by ip.
if X&isin; V<sub>t</sub> or $
if X = a
   POP X and advance ip.
	else
   error()
 	endif
else	/* X is non-terminal */
   if M[X,a] = X → Y1, Y2,... Yk    
POP X
PUSH Yk, Yk-1,... Y1 /* Y1 on top */
   Output the production X → Y1, Y2,... Yk 
   else
   error()
   endif
	endif
until X = $	/* empty stack */
</pre>
<p>A grammar G is LL(1) if A-> alpha | b are two distinct productions of G:</p>
<ul class="list">
<li><p>for no terminal, both alpha and beta derive strings beginning with a.</p></li>
<li><p>at most one of alpha and beta can derive empty string.</p></li>
<li><p>if beta=> t, then alpha does not derive any string beginning with a terminal in FOLLOW(A).</p></li> 
</ul>
<h2>Bottom-up Parsing</h2>
<p>Bottom-up parsing starts from the leaf nodes of a tree and works in upward direction till it reaches the root node. Here, we start from a sentence and then apply production rules in reverse manner in order to reach the start symbol. The image given below depicts the bottom-up parsers available.</p>
<img src="/compiler_design/images/bottom_up_parsing.jpg" alt="Bottom-Up Parsing" />
<h3>Shift-Reduce Parsing</h3>
<p>Shift-reduce parsing uses two unique steps for bottom-up parsing. These steps are known as shift-step and reduce-step.</p>
<ul class="list">
<li><p><b>Shift step</b>: The shift step refers to the advancement of the input pointer to the next input symbol, which is called the shifted symbol. This symbol is pushed onto the stack. The shifted symbol is treated as a single node of the parse tree.</p></li>
<li><p><b>Reduce step</b> : When the parser finds a complete grammar rule (RHS) and replaces it to (LHS), it is known as reduce-step. This occurs when the top of the stack contains a handle. To reduce, a POP function is performed on the stack which pops off the handle and replaces it with LHS non-terminal symbol.</p></li>
</ul>
<h3>LR Parser</h3>
<p>The LR parser is a non-recursive, shift-reduce, bottom-up parser. It uses a wide class of context-free grammar which makes it the most efficient syntax analysis technique. LR parsers are also known as LR(k) parsers, where L stands for left-to-right scanning of the input stream; R stands for the construction of right-most derivation in reverse, and k denotes the number of lookahead symbols to make decisions.</p>
<p>There are three widely used algorithms available for constructing an LR parser:</p>
<ul class="list">
<li>SLR(1) – Simple LR Parser:
<ul class="list">
<li>Works on smallest class of grammar</li>
<li>Few number of states, hence very small table</li>
<li>Simple and fast construction</li>
</ul>
</li>
<li>LR(1) – LR Parser:
<ul class="list">
<li>Works on complete set of LR(1) Grammar</li>
<li>Generates large table and large number of states</li>
<li>Slow construction</li>
</ul>
</li>
<li>LALR(1) – Look-Ahead LR Parser:
<ul class="list">
<li>Works on intermediate size of grammar</li>
<li>Number of states are same as in SLR(1)</li>
</ul>
</li>
</ul>
<h3>LR Parsing Algorithm</h3>
<p>Here we describe a skeleton algorithm of an LR parser:</p>
<pre class="prettyprint notranslate">
token = next_token()
repeat forever
   s = top of stack
   if action[s, token] = “shift si” then
   PUSH token
   PUSH si 
   token = next_token()
else if action[s, tpken] = “reduce A::= β“ then 
   POP 2 * |β| symbols
   s = top of stack
   PUSH A
	PUSH goto[s,A]
else if action[s, token] = “accept” then
	return
	else
   error()
</pre>
<h3>LL vs. LR</h3>
<table class="table table-bordered">
<tr>
<th>LL</th>
<th>LR</th>
</tr>
<tr>
<td>Does a leftmost derivation.</td>
<td>Does a rightmost derivation in reverse.</td>
</tr>
<tr>
<td>Starts with the root nonterminal on the stack.</td>
<td>Ends with the root nonterminal on the stack.</td>
</tr>
<tr>
<td>Ends when the stack is empty.</td>
<td>Starts with an empty stack.</td>
</tr>
<tr>
<td>Uses the stack for designating what is still to be expected.</td>
<td>Uses the stack for designating what is already seen.</td>
</tr>
<tr>
<td>Builds the parse tree top-down.</td>
<td>Builds the parse tree bottom-up.</td>
</tr>
<tr>
<td>Continuously pops a nonterminal off the stack, and pushes the corresponding right hand side.</td>
<td>Tries to recognize a right hand side on the stack, pops it, and pushes the corresponding nonterminal.</td>
</tr>
<tr>
<td>Expands the non-terminals.</td>
<td>Reduces the non-terminals.</td>
</tr>
<tr>
<td>Reads the terminals when it pops one off the stack.</td>
<td>Reads the terminals while it pushes them on the stack.</td>
</tr>
<tr>
<td>Pre-order traversal of the parse tree.</td>
<td>Post-order traversal of the parse tree.</td>
</tr>
</table>
<h1>Compiler Design - Run-Time Environment</h1>
<p>A program as a source code is merely a collection of text (code, statements etc.) and to make it alive, it requires actions to be performed on the target machine. A program needs memory resources to execute instructions. A program contains names for procedures, identifiers etc., that require mapping with the actual memory location at runtime.</p>
<p>By runtime, we mean a program in execution. Runtime environment is a state of the target machine, which may include software libraries, environment variables, etc., to provide services to the processes running in the system.</p>
<p>Runtime support system is a package, mostly generated with the executable program itself and facilitates the process communication between the process and the runtime environment. It takes care of memory allocation and de-allocation while the program is being executed.</p>
<h2>Activation Trees</h2>
<p>A program is a sequence of instructions combined into a number of procedures.  Instructions in a procedure are executed sequentially. A procedure has a start and an end delimiter and everything inside it is called the body of the procedure. The procedure identifier and the sequence of finite instructions inside it make up the body of the procedure.</p>
<p>The execution of a procedure is called its activation. An activation record contains all the necessary information required to call a procedure. An activation record may contain the following units (depending upon the source language used).</p>
<table class="table table-bordered">
<tr>
<td>Temporaries</td>
<td>Stores temporary and intermediate values of an expression.</td>
</tr>
<tr>
<td>Local Data</td>
<td>Stores local data of the called procedure.</td>
</tr>
<tr>
<td style="width:23%;">Machine Status</td>
<td>Stores machine status such as Registers, Program Counter etc., before the procedure is called.</td>
</tr>
<tr>
<td>Control Link</td>
<td>Stores the address of activation record of the caller procedure.</td>
</tr>
<tr>
<td>Access Link</td>
<td>Stores the information of data which is outside the local scope.</td>
</tr>
<tr>
<td>Actual Parameters</td>
<td>Stores actual parameters, i.e., parameters which are used to send input to the called procedure.</td>
</tr>
<tr>
<td>Return Value</td>
<td>Stores return values.</td>
</tr>
</table>
<p>Whenever a procedure is executed, its activation record is stored on the stack, also known as control stack. When a procedure calls another procedure, the execution of the caller is suspended until the called procedure finishes execution. At this time, the activation record of the called procedure is stored on the stack.</p>
<p>We assume that the program control flows in a sequential manner and when a procedure is called, its control is transferred to the called procedure. When a called procedure is executed, it returns the control back to the caller. This type of control flow makes it easier to represent a series of activations in the form of a tree, known as the <b>activation tree</b>.</p>
<p>To understand this concept, we take a piece of code as an example:</p>
<pre class="prettyprint notranslate">
. . .
printf(“Enter Your Name: “);
scanf(“%s”, username);
show_data(username);
printf(“Press any key to continue…”);
. . .
int show_data(char *user)
   {
   printf(“Your name is %s”, username);
   return 0;
   }
. . . 
</pre>
<p>Below is the activation tree of the code given.</p>
<img src="/compiler_design/images/activation_tree.jpg" alt="Activation Tree" />
<p>Now we understand that procedures are executed in depth-first manner, thus stack allocation is the best suitable form of storage for procedure activations.</p>
<h2>Storage Allocation</h2>
<p>Runtime environment manages runtime memory requirements for the following entities:</p>
<ul class="list">
<li><p><b>Code</b> : It is known as the text part of a program that does not change at runtime. Its memory requirements are known at the compile time.</p></li>
<li><p><b>Procedures</b> : Their text part is static but they are called in a random manner. That is why, stack storage is used to manage procedure calls and activations.</p></li>
<li><p><b>Variables</b> : Variables are known at the runtime only, unless they are global or constant. Heap memory allocation scheme is used for managing allocation and de-allocation of memory for variables in runtime.</p></li>
</ul>
<h2>Static Allocation</h2>
<p>In this allocation scheme, the compilation data is bound to a fixed location in the memory and it does not change when the program executes. As the memory requirement and storage locations are known in advance, runtime support package for memory allocation and de-allocation is not required.</p>
<h2>Stack Allocation</h2>
<p>Procedure calls and their activations are managed by means of stack memory allocation. It works in last-in-first-out (LIFO) method and this allocation strategy is very useful for recursive procedure calls.</p>
<h2>Heap Allocation</h2>
<p>Variables local to a procedure are allocated and de-allocated only at runtime. Heap allocation is used to dynamically allocate memory to the variables and claim it back when the variables are no more required.</p>
<p>Except statically allocated memory area, both stack and heap memory can grow and shrink dynamically and unexpectedly. Therefore, they cannot be provided with a fixed amount of memory in the system.</p>
<img src="/compiler_design/images/heap_allocation.jpg" alt="Heap Allocation" />
<p>As shown in the image above, the text part of the code is allocated a fixed amount of memory. Stack and heap memory are arranged at the extremes of total memory allocated to the program. Both shrink and grow against each other.</p>
<h2>Parameter Passing</h2>
<p>The communication medium among procedures is known as parameter passing. The values of the variables from a calling procedure are transferred to the called procedure by some mechanism. Before moving ahead, first go through some basic terminologies pertaining to the values in a program.</p>
<h3>r-value</h3>
<p>The value of an expression is called its r-value. The value contained in a single variable also becomes an r-value if it appears on the right-hand side of the assignment operator. r-values can always be assigned to some other variable.</p>
<h3>l-value</h3>
<p>The location of memory (address) where an expression is stored is known as the l-value of that expression. It always appears at the left hand side of an assignment operator.</p>
<p>For example:</p>
<pre class="prettyprint notranslate">
day = 1;
week = day * 7;
month = 1;
year = month * 12;
</pre>
<p>From this example, we understand that constant values like 1, 7, 12, and variables like day, week, month and year, all have r-values. Only variables have l-values as they also represent the memory location assigned to them.</p>
<p>For example:</p>
<pre class="prettyprint notranslate">
7 = x + y;
</pre>
<p>is an l-value error, as the constant 7 does not represent any memory location.</p>
<h2>Formal Parameters</h2>
<p>Variables that take the information passed by the caller procedure are called formal parameters. These variables are declared in the definition of the called function.</p>
<h2>Actual Parameters</h2>
<p>Variables whose values or addresses are being passed to the called procedure are called actual parameters. These variables are specified in the function call as arguments.</p>
<p><b>Example:</b></p>
<pre class="prettyprint notranslate">
fun_one()
{
   int actual_parameter = 10;
   call fun_two(int actual_parameter);
}
   fun_two(int formal_parameter)
{
   print formal_parameter;
}
</pre>
<p>Formal parameters hold the information of the actual parameter, depending upon the parameter passing technique used. It may be a value or an address.</p>
<h2>Pass by Value</h2>
<p>In pass by value mechanism, the calling procedure passes the r-value of actual parameters and the compiler puts that into the called procedure’s activation record. Formal parameters then hold the values passed by the calling procedure. If the values held by the formal parameters are changed, it should have no impact on the actual parameters.</p>
<h2>Pass by Reference</h2>
<p>In pass by reference mechanism, the l-value of the actual parameter is copied to the activation record of the called procedure. This way, the called procedure now has the address (memory location) of the actual parameter and the formal parameter refers to the same memory location. Therefore, if the value pointed by the formal parameter is changed, the impact should be seen on the actual parameter as they should also point to the same value.</p>
<h2>Pass by Copy-restore</h2>
<p>This parameter passing mechanism works similar to ‘pass-by-reference’ except that the changes to actual parameters are made when the called procedure ends. Upon function call, the values of actual parameters are copied in the activation record of the called procedure. Formal parameters if manipulated have no real-time effect on actual parameters (as l-values are passed), but when the called procedure ends, the l-values of formal parameters are copied to the l-values of actual parameters.</p>
<p><b>Example:</b></p>
<pre class="prettyprint notranslate">
int y; 
calling_procedure() 
{
   y = 10;     
   copy_restore(y); //l-value of y is passed
   printf y; //prints 99 
}
copy_restore(int x) 
{     
   x = 99; // y still has value 10 (unaffected)
   y = 0; // y is now 0 
}
</pre>
<p>When this function ends, the l-value of formal parameter x is copied to the actual parameter y. Even if the value of y is changed before the procedure ends, the l-value of x is copied to the l-value of y making it behave like call by reference.</p>
<h2>Pass by Name</h2>
<p>Languages like Algol provide a new kind of parameter passing mechanism that works like preprocessor in C language. In pass by name mechanism, the name of the procedure being called is replaced by its actual body. Pass-by-name textually substitutes the argument expressions in a procedure call for the corresponding parameters in the body of the procedure so that it can now work on actual parameters, much like pass-by-reference.</p>
<h1>Compiler Design - Symbol Table</h1>
<p>Symbol table is an important data structure created and maintained by compilers in order to store information about the occurrence of various entities such as variable names, function names, objects, classes, interfaces, etc. Symbol table is used by both the analysis and the synthesis parts of a compiler.</p>
<p>A symbol table may serve the following purposes depending upon the language in hand:</p>
<ul class="list">
<li><p>To store the names of all entities in a structured form at one place.</p></li>
<li><p>To verify if a variable has been declared.</p></li>
<li><p>To implement type checking, by verifying assignments and expressions in the source code are semantically correct.</p></li>
<li><p>To determine the scope of a name (scope resolution).</p></li>
</ul>
<p>A symbol table is simply a table which can be either linear or a hash table. It maintains an entry for each name in the following format:</p>
<pre class="prettyprint notranslate">
&lt;symbol name,  type,  attribute&gt;
</pre>
<p>For example, if a symbol table has to store information about the following variable declaration:</p>
<pre class="prettyprint notranslate">
static int interest;
</pre>
<p>then it should store the entry such as:</p>
<pre class="prettyprint notranslate">
&lt;interest, int, static&gt;
</pre>
<p>The attribute clause contains the entries related to the name.</p>
<h2>Implementation</h2>
<p>If a compiler is to handle a small amount of data, then the symbol table can be implemented as an unordered list, which is easy to code, but it is only suitable for small tables only. A symbol table can be implemented in one of the following ways:</p>
<ul class="list">
<li>Linear (sorted or unsorted) list</li>
<li>Binary Search Tree</li>
<li>Hash table</li>
</ul>
<p>Among all, symbol tables are mostly implemented as hash tables, where the source code symbol itself is treated as a key for the hash function and the return value is the information about the symbol.</p>
<h2>Operations</h2>
<p>A symbol table, either linear or hash, should provide the following operations.</p>
<h3>insert()</h3>
<p>This operation is more frequently used by analysis phase, i.e., the first half of the compiler where tokens are identified and names are stored in the table. This operation is used to add information in the symbol table about unique names occurring in the source code. The format or structure in which the names are stored depends upon the compiler in hand.</p>
<p>An attribute for a symbol in the source code is the information associated with that symbol. This information contains the value, state, scope, and type about the symbol. The insert() function takes the symbol and its attributes as arguments and stores the information in the symbol table.</p>
<p>For example:</p>
<pre class="prettyprint notranslate">
int a;
</pre>
<p>should be processed by the compiler as:</p>
<pre class="prettyprint notranslate">
insert(a, int);
</pre>
<h3>lookup()</h3>
<p>lookup() operation is used to search a name in the symbol table to determine:</p>
<ul class="list">
<li>if the symbol exists in the table.</li>
<li>if it is declared before it is being used.</li>
<li>if the name is used in the scope.</li>
<li>if the symbol is initialized.</li>
<li>if the symbol declared multiple times.</li>
</ul>
<p>The format of lookup() function varies according to the programming language. The basic format should match the following:</p>
<pre class="prettyprint notranslate">
lookup(symbol)
</pre>
<p>This method returns 0 (zero) if the symbol does not exist in the symbol table. If the symbol exists in the symbol table, it returns its attributes stored in the table.</p>
<h2>Scope Management</h2>
<p>A compiler maintains two types of symbol tables: a <b>global symbol table</b> which can be accessed by all the procedures and <b>scope symbol tables</b> that are created for each scope in the program.</p>
<p>To determine the scope of a name, symbol tables are arranged in hierarchical structure as shown in the example below:</p>
<pre class="prettyprint notranslate">
. . . 
int value=10;

void pro_one()
   {
   int one_1;
   int one_2;
   
      {              \
      int one_3;      |_  inner scope 1 
      int one_4;      | 
      }              /
      
   int one_5; 
   
      {              \   
      int one_6;      |_  inner scope 2
      int one_7;      |
      }              /
   }
   
void pro_two()
   {
   int two_1;
   int two_2;
   
      {              \
      int two_3;      |_  inner scope 3
      int two_4;      |
      }              /
      
   int two_5;
   }
. . . 
</pre>
<p>The above program can be represented in a hierarchical structure of symbol tables:</p>
<img src="/compiler_design/images/symbol_table.jpg" alt="Symbol Table" />
<p>The global symbol table contains names for one global variable (int value) and two procedure names, which should be available to all the child nodes shown above. The names mentioned in the pro_one symbol table (and all its child tables) are not available for pro_two symbols and its child tables.</p>
<p>This symbol table data structure hierarchy is stored in the semantic analyzer and whenever a name needs to be searched in a symbol table, it is searched using the following algorithm:</p>
<ul class="list">
<li><p>first a symbol will be searched in the current scope, i.e. current symbol table.</p></li>
<li><p>if a name is found, then search is completed, else it will be searched in the parent symbol table until,</p></li>
<li><p>either the name is found or global symbol table has been searched for the name.</p></li>
</ul>
<h1>Compiler - Intermediate Code Generation</h1>
<p>A source code can directly be translated into its target machine code, then why at all we need to translate the source code into an intermediate code which is then translated to its target code? Let us see the reasons why we need an intermediate code.</p>
<img src="/compiler_design/images/intermediate_code.jpg" alt="Intermediate Code" />
<ul class="list">
<li><p>If a compiler translates the source language to its target machine language without having the option for generating intermediate code, then for each new machine, a full native compiler is required.</p></li>
<li><p>Intermediate code eliminates the need of a new full compiler for every unique machine by keeping the analysis portion same for all the compilers.</p></li>
<li><p>The second part of compiler, synthesis, is changed according to the target machine.</p></li>
<li><p>It becomes easier to apply the source code modifications to improve code performance by applying code optimization techniques on the intermediate code.</p></li>
</ul>
<h2>Intermediate Representation</h2>
<p>Intermediate codes can be represented in a variety of ways and they have their own benefits.</p>
<ul class="list">
<li><p><b>High Level IR</b> -	High-level intermediate code representation is very close to the source language itself. They can be easily generated from the source code and we can easily apply code modifications to enhance performance. But for target machine optimization, it is less preferred.</p></li>
<li><p><b>Low Level IR</b> -	This one is close to the target machine, which makes it suitable for register and memory allocation, instruction set selection, etc. It is good for machine-dependent optimizations.</p></li>
</ul>
<p>Intermediate code can be either language specific (e.g., Byte Code for Java) or language independent (three-address code).</p>
<h2>Three-Address Code</h2>
<p>Intermediate code generator receives input from its predecessor phase, semantic analyzer, in the form of an annotated syntax tree. That syntax tree then can be converted into a linear representation, e.g., postfix notation. Intermediate code tends to be machine independent code. Therefore, code generator assumes to have unlimited number of memory storage (register) to generate code.</p>
<p>For example:</p>
<pre class="prettyprint notranslate">
a = b + c * d;
</pre>
<p>The intermediate code generator will try to divide this expression into sub-expressions and then generate the corresponding code.</p>
<pre class="prettyprint notranslate">
r1 = c * d;
r2 = b + r1;
a = r2
</pre>
<p>r being used as registers in the target program.</p>
<p>A three-address code has at most three address locations to calculate the expression. A three-address code can be represented in two forms : quadruples and triples.</p>
<h3>Quadruples</h3>
<p>Each instruction in quadruples presentation is divided into four fields: operator, arg1, arg2, and result. The above example is represented below in quadruples format:</p>
<table class="table table-bordered">
<tr>
<td>Op</td>
<td>arg<sub>1</sub></td>
<td>arg<sub>2</sub></td>
<td>result</td>
</tr>
<tr>
<td>*</td>
<td>c</td>
<td>d</td>
<td>r1</td>
</tr>
<tr>
<td>+</td>
<td>b</td>
<td>r1</td>
<td>r2</td>
</tr>
<tr>
<td>+</td>
<td>r2</td>
<td>r1</td>
<td>r3</td>
</tr>
<tr>
<td>=</td>
<td>r3</td>
<td></td>
<td>a</td>
</tr>
</table>
<h3>Triples</h3>
<p>Each instruction in triples presentation has three fields : op, arg1, and arg2.The results of respective sub-expressions are denoted by the position of expression. Triples
represent similarity with DAG and syntax tree. They are equivalent to DAG while representing expressions.</p>
<table class="table table-bordered">
<tr>
<td>Op</td>
<td>arg<sub>1</sub></td>
<td>arg<sub>2</sub></td>
</tr>
<tr>
<td>*</td>
<td>c</td>
<td>d</td>
</tr>
<tr>
<td>+</td>
<td>b</td>
<td>(0)</td>
</tr>
<tr>
<td>+</td>
<td>(1)</td>
<td>(0)</td>
</tr>
<tr>
<td>=</td>
<td>(2)</td>
<td></td>
</tr>
</table>
<p>Triples face the problem of code immovability while optimization, as the results are positional and changing the order or position of an expression may cause problems.</p>
<h3>Indirect Triples</h3>
<p>This representation is an enhancement over triples representation. It uses pointers instead of position to store results. This enables the optimizers to freely re-position the sub-expression to produce an optimized code.</p>
<h2>Declarations</h2>
<p>A variable or procedure has to be declared before it can be used. Declaration involves allocation of space in memory and entry of type and name in the symbol table. A program may be coded and designed keeping the target machine structure in mind, but it may not always be possible to accurately convert a source code to its target language.</p>
<p>Taking the whole program as a collection of procedures and sub-procedures, it becomes possible to declare all the names local to the procedure. Memory allocation is done in a consecutive manner and names are allocated to memory in the sequence they are declared in the program. We use offset variable and set it to zero {offset = 0} that denote the base address.</p> 
<p>The source programming language and the target machine architecture may vary in the way names are stored, so relative addressing is used. While the first name is allocated memory starting from the memory location 0 {offset=0}, the next name declared later, should be allocated memory next to the first one.</p>
<p><b>Example:</b></p>
<p>We take the example of C programming language where an integer variable is assigned 2 bytes of memory and a float variable is assigned 4 bytes of memory.</p>
<pre class="prettyprint notranslate">
int a;
float b;
Allocation process:
{offset = 0}
int a;
id.type = int
id.width = 2
offset = offset + id.width 
{offset = 2}
float b;
   id.type = float
   id.width = 4
   offset = offset + id.width 
{offset = 6}
</pre>
<p>To enter this detail in a symbol table, a procedure <i>enter</i> can be used. This method may have the following structure:</p>
<pre class="prettyprint notranslate">
enter(name, type, offset)
</pre>
<p>This procedure should create an entry in the symbol table, for variable <i>name</i>, having its type set to type and relative address <i>offset</i> in its data area.</p>
<h1>Compiler Design - Code Generation</h1>
<p>Code generation can be considered as the final phase of compilation. Through post code generation, optimization process can be applied on the code, but that can be seen as a part of code generation phase itself. The code generated by the compiler is an object code of some lower-level programming language, for example, assembly language. We have seen that the source code written in a higher-level language is transformed into a lower-level language that results in a lower-level object code, which should have the following minimum properties:</p>
<ul class="list">
<li>It should carry the exact meaning of the source code.</li>
<li>It should be efficient in terms of CPU usage and memory management.</li>
</ul>
<p>We will now see how the intermediate code is transformed into target object code (assembly code, in this case).</p>
<h2>Directed Acyclic Graph</h2>
<p>Directed Acyclic Graph (DAG) is a tool that depicts the structure of basic blocks, helps to see the flow of values flowing among the basic blocks, and offers optimization too. DAG provides easy transformation on basic blocks. DAG can be understood here:</p>
<ul class="list">
<li><p>Leaf nodes represent identifiers, names or constants.</p></li>
<li><p>Interior nodes represent operators.</p></li>
<li><p>Interior nodes also represent the results of expressions or the identifiers/name where the values are to be stored or assigned.</p></li>
</ul>
<p><b>Example:</b></p>
<pre class="prettyprint notranslate">
t<sub>0</sub> = a + b
t<sub>1</sub> = t<sub>0</sub> + c
d = t<sub>0</sub> + t<sub>1</sub>
</pre>
<table class="table table-bordered">
<tr>
<td>
<img src="/compiler_design/images/directed_acyclic_graph_1.jpg" alt="Directed Acyclic Graph" />
<p>[t<sub>0</sub> = a + b]</p>
</td>
<td>
<img src="/compiler_design/images/directed_acyclic_graph_2.jpg" alt="Directed Acyclic Graph" />
<p>[t<sub>1</sub> = t<sub>0</sub> + c]</p>
</td>
<td>
<img src="/compiler_design/images/directed_acyclic_graph_3.jpg" alt="Directed Acyclic Graph" />
<p>[d = t<sub>0</sub> + t<sub>1</sub>]</p>
</td>
</tr>
</table>
<h2>Peephole Optimization</h2>
<p>This optimization technique works locally on the source code to transform it into an optimized code. By locally, we mean a small portion of the code block at hand. These methods can be applied on intermediate codes as well as on target codes. A bunch of statements is analyzed and are checked for the following possible optimization:</p>
<h3>Redundant instruction elimination</h3>
<p>At source code level, the following can be done by the user:</p>
<table class="table table-bordered">
<tr>
<td style="padding:3px;">
<pre class="prettyprint notranslate">
int add_ten(int x)
   {
   int y, z;
   y = 10;
   z = x + y;
   return z;
   }
</pre>
</td>
<td style="padding:3px;">
<pre class="prettyprint notranslate">
int add_ten(int x)
   {
   int y;
   y = 10;
   y = x + y;
   return y;
   }
</pre>
</td>
<td style="padding:3px;">
<pre class="prettyprint notranslate">
int add_ten(int x)
   {
   int y = 10;
   return x + y;
   }
   
   
</pre>
</td>
<td style="padding:3px;">
<pre class="prettyprint notranslate">
int add_ten(int x)
   {
   return x + 10;
   }
   
   
   
</pre>
</td>
</tr>
</table>
<p>At compilation level, the compiler searches for instructions redundant in nature. Multiple loading and storing of instructions may carry the same meaning even if some of them are removed. For example:</p>
<ul class="list">
<li>MOV x, R0</li>
<li>MOV R0, R1</li>
</ul>
<p>We can delete the first instruction and re-write the sentence as:</p>
<pre class="prettyprint notranslate">
MOV x, R1
</pre>

<h3>Unreachable code</h3>
<p>Unreachable code is a part of the program code that is never accessed because of programming constructs. Programmers may have accidently written a piece of code that can never be reached.</p>
<p><b>Example:</b></p>
<pre class="prettyprint notranslate">
void add_ten(int x)
{
   return x + 10;
   printf(“value of x is %d”, x);
}
</pre>
<p>In this code segment, the <b>printf</b> statement will never be executed as the program control returns back before it can execute, hence <b>printf</b> can be removed.</p>
<h3>Flow of control optimization</h3>
<p>There are instances in a code where the program control jumps back and forth without performing any significant task. These jumps can be removed. Consider the following chunk of code:</p>
<pre class="prettyprint notranslate">
...		
MOV R1, R2
GOTO L1
...
L1 :   GOTO L2
L2 :   INC R1
</pre>
<p>In this code,label L1 can be removed as it  passes the control to L2. So instead of jumping to L1 and then to L2, the control can directly reach L2, as shown below:</p>
<pre class="prettyprint notranslate">
...		
MOV R1, R2
GOTO L2
...
L2 :   INC R1
</pre>
<h3>Algebraic expression simplification</h3>
<p>There are occasions where algebraic expressions can be made simple. For example, the expression <b>a = a + 0</b> can be replaced by <b>a</b> itself and the expression a = a + 1 can simply be replaced by INC a.</p>
<h3>Strength reduction</h3>
<p>There are operations that consume more time and space. Their ‘strength’ can be reduced by replacing them with other operations that consume less time and space, but produce the same result.</p>
<p>For example, <b>x * 2</b> can be replaced by <b>x << 1</b>, which involves only one left shift. Though the output of a * a and a<sup>2</sup> is same, a<sup>2</sup> is much more efficient to implement.</p>
<h3>Accessing machine instructions</h3>
<p>The target machine can deploy more sophisticated instructions, which can have the capability to perform specific operations much efficiently. If the target code can accommodate those instructions directly, that will not only improve the quality of code, but also yield more efficient results.</p>
<h2>Code Generator</h2>
<p>A code generator is expected to have an understanding of the target machine’s runtime environment and its instruction set. The code generator should take the following things into consideration to generate the code:</p>
<ul class="list">
<li><p><b>Target language</b> : The code generator has to be aware of the nature of the target language for which the code is to be transformed. That language may facilitate some machine-specific instructions to help the compiler generate the code in a more convenient way. The target machine can have either CISC or RISC processor architecture.</p></li>
<li><p><b>IR Type</b> :	Intermediate representation has various forms. It can be in Abstract Syntax Tree (AST) structure, Reverse Polish Notation, or 3-address code.</p></li>
<li><p><b>Selection of instruction</b> : The code generator takes Intermediate Representation as input and converts (maps) it into target machine’s instruction set. One representation can have many ways (instructions) to convert it, so it becomes the responsibility of the code generator to choose the appropriate instructions wisely.</p></li>
<li><p><b>Register allocation</b> :	A program has a number of values to be maintained during the execution. The target machine’s architecture may not allow all of the values to be kept in the CPU memory or registers. Code generator decides what values to keep in the registers. Also, it decides the registers to be used to keep these values.</p></li>
<li><p><b>Ordering of instructions</b> : At last, the code generator decides the order in which the instruction will be executed. It creates schedules for instructions to execute them.</p></li>
</ul>
<h2>Descriptors</h2>
<p>The code generator has to track both the registers (for availability) and addresses (location of values) while generating the code. For both of them, the following two descriptors are used:</p>
<ul class="list">
<li><p><b>Register descriptor</b> :	Register descriptor is used to inform the code generator about the availability of registers. Register descriptor keeps track of values stored in each register. Whenever a new register is required during code generation, this descriptor is consulted for register availability.</p></li>
<li><p><b>Address descriptor</b> : Values of the names (identifiers) used in the program might be stored at different locations while in execution. Address descriptors are used to keep track of memory locations where the values of identifiers are stored. These locations may include CPU registers, heaps, stacks, memory or a combination of the mentioned locations.</p></li>
</ul>
<p>Code generator keeps both the descriptor updated in real-time. For a load statement, LD R1, x, the code generator:</p>
<ul class="prettyprint notranslate">
<li>updates the Register Descriptor R1 that has value of x and</li>
<li>updates the Address Descriptor (x) to show that one instance of x is in R1.</li>
</ul>
<h2>Code Generation</h2>
<p>Basic blocks comprise of a sequence of three-address instructions. Code generator takes these sequence of instructions as input.</p>
<p><b>Note</b> : If the value of a name is found at more than one place (register, cache, or memory), the register’s value will be preferred over the cache and main memory. Likewise cache’s value will be preferred over the main memory. Main memory is barely given any preference.</p>
<p><b>getReg</b> : Code generator uses <i>getReg</i> function to determine the status of available registers and the location of name values. <i>getReg</i> works as follows:</p>
<ul class="list">
<li><p>If variable Y is already in register R, it uses that register.</p></li>
<li><p>Else if some register R is available, it uses that register.</p></li>
<li><p>Else if both the above options are not possible, it chooses a register that requires minimal number of load and store instructions.</p></li>
</ul>
<p>For an instruction x = y OP z, the code generator may perform the following actions. Let us assume that L is the location (preferably register) where the output of y OP z is to be saved:</p>
<ul class="list">
<li><p>Call function getReg, to decide the location of L.</p></li>
<li><p>Determine the present location (register or memory) of <b>y</b> by consulting the Address Descriptor of <b>y</b>. If <b>y</b> is not presently in register <b>L</b>, then generate the following instruction to copy the value of <b>y</b> to <b>L</b>:</p>
<p>MOV y’, L</p>
<p>where <b>y’</b> represents the copied value of <b>y</b>.</p>
</li>
<li><p>Determine the present location of <b>z</b> using the same method used in step 2 for <b>y</b> and generate the following instruction:</p>
<p>OP z’, L</p>
<p>where <b>z’</b> represents the copied value of <b>z</b>.</p>
</li>
<li><p>Now L contains the value of y OP z, that is intended to be assigned to <b>x</b>. So, if L is a register, update its descriptor to indicate that it contains the value of <b>x</b>. Update the descriptor of <b>x</b> to indicate that it is stored at location <b>L</b>.</p></li>
<li><p>If y and z has no further use, they can be given back to the system.</p></li>
</ul>
<p>Other code constructs like loops and conditional statements are transformed into assembly language in general assembly way.</p>
<h1>Compiler Design - Code Optimization</h1>
<p>Optimization is a program transformation technique, which tries to improve the code by making it consume less resources (i.e. CPU, Memory) and deliver high speed.</p>
<p>In optimization, high-level general programming constructs are replaced by very efficient low-level programming codes. A code optimizing process must follow the three rules given below:</p>
<ul class="list">
<li><p>The output code must not, in any way, change the meaning of the program.</p></li>
<li><p>Optimization should increase the speed of the program and if possible, the program should demand less number of resources.</p></li>
<li><p>Optimization should itself be fast and should not delay the overall compiling process.</p></li>
</ul>
<p>Efforts for an optimized code can be made at various levels of compiling the process.</p>
<ul class="list">
<li><p>At the beginning, users can change/rearrange the code or use better algorithms to write the code.</p></li>
<li><p>After generating intermediate code, the compiler can modify the intermediate code by address calculations and improving loops.</p></li>
<li><p>While producing the target machine code, the compiler can make use of memory hierarchy and CPU registers.</p></li>
</ul>
<p>Optimization can be categorized broadly into two types : machine independent and machine dependent.</p>
<h2>Machine-independent Optimization</h2>
<p>In this optimization, the compiler takes in the intermediate code and transforms a part of the code that does not involve any CPU registers and/or absolute memory locations. For example:</p>
<pre class="prettyprint notranslate">
do
{
   item = 10;
   value = value + item; 
}while(value<100);
</pre>
<p>This code involves repeated assignment of the identifier item, which if we put this way:</p>
<pre class="prettyprint notranslate">
Item = 10;
do
{
   value = value + item; 
} while(value<100);
</pre>
<p>should not only save the CPU cycles, but  can be used on any processor.</p>
<h2>Machine-dependent Optimization</h2>
<p>Machine-dependent optimization is done after the target code has been generated and when the code is transformed according to the target machine architecture. It involves CPU registers and may have absolute memory references rather than relative references. Machine-dependent optimizers put efforts to take maximum advantage of memory hierarchy.</p>
<h2>Basic Blocks</h2>
<p>Source codes generally have a number of instructions, which are always executed in sequence and are considered as the basic blocks of the code. These basic blocks do not have any jump statements among them, i.e., when the first instruction is executed, all the instructions in the same basic block will be executed in their sequence of appearance without losing the flow control of the program.</p>
<p>A program can have various constructs as basic blocks, like IF-THEN-ELSE, SWITCH-CASE conditional statements and loops such as DO-WHILE, FOR, and REPEAT-UNTIL, etc.</p>
<h3>Basic block identification</h3>
<p>We may use the following algorithm to find the basic blocks in a program:</p>
<ul class="list">
<li><p>Search header statements of all the basic blocks from where a basic block starts:</p>
<ul class="list">
<li>First statement of a program.</li>
<li>Statements that are target of any branch (conditional/unconditional).</li>
<li>Statements that follow any branch statement.</li>
</ul>
</li>
<li><p>Header statements and the statements following them form a basic block.</p></li>
<li><p>A basic block does not include any header statement of any other basic block.</p></li>
</ul>
<p>Basic blocks are important concepts from both code generation and optimization point of view.</p>
<img src="/compiler_design/images/basic_blocks.jpg" alt="Basic Blocks" />
<p>Basic blocks play an important role in identifying variables, which are being used more than once in a single basic block. If any variable is being used more than once, the register memory allocated to that variable need not be emptied unless the block finishes execution.</p>
<h3>Control Flow Graph</h3>
<p>Basic blocks in a program can be represented by means of control flow graphs. A control flow graph depicts how the program control is being passed among the blocks. It is a useful tool that helps in optimization by help locating any unwanted loops in the program.</p>
<img src="/compiler_design/images/control_flow_graph.jpg" alt="Control Flow Graph" />
<h2>Loop Optimization</h2>
<p>Most programs run as a loop in the system. It becomes necessary to optimize the loops in order to save CPU cycles and memory. Loops can be optimized by the following techniques:</p>
<ul class="list">
<li><p><b>Invariant code</b> : A fragment of code that resides in the loop and computes the same value at each iteration is called a loop-invariant code. This code can be moved out of the loop by saving it to be computed only once, rather than with each iteration.</p></li>
<li><p><b>Induction analysis</b> : A variable is called an induction variable if its value is altered within the loop by a loop-invariant value.</p></li>
<li><p><b>Strength reduction</b> : There are expressions that consume more CPU cycles, time, and memory. These expressions should be replaced with cheaper expressions without compromising the output of expression. For example, multiplication (x * 2) is expensive in terms of CPU cycles than (x << 1) and yields the same result.</p></li>
</ul>
<h2>Dead-code Elimination</h2>
<p>Dead code is one or more than one code statements, which are:</p>
<ul class="list">
<li>Either never executed or unreachable,</li>
<li>Or if executed, their output is never used.</li>
</ul>
<p>Thus, dead code plays no role in any program operation and therefore it can simply be eliminated.</p>
<h3>Partially dead code</h3>
<p>There are some code statements whose computed values are used only under certain circumstances, i.e., sometimes the values are used and sometimes they are not. Such codes are known as partially dead-code.</p>
<img src="/compiler_design/images/partially_dead_code.jpg" alt="Partially Dead Code" />
<p>The above control flow graph depicts a chunk of program where variable ‘a’ is used to assign the output of expression ‘x * y’. Let us assume that the value assigned to ‘a’ is never used inside the loop.Immediately after the control leaves the loop, ‘a’ is assigned the value of variable ‘z’, which would be used later in the program. We conclude here that the assignment code of ‘a’ is never used anywhere, therefore it is eligible to be eliminated.</p>
<img src="/compiler_design/images/dead_code.jpg" alt="Dead Code" />
<p>Likewise, the picture above depicts that the conditional statement is always false, implying that the code, written in true case, will never be executed, hence it can be removed.</p>
<h2>Partial Redundancy</h2>
<p>Redundant expressions are computed more than once in parallel path, without any change in operands.whereas partial-redundant expressions are computed more than once in a path, without any change in operands. For example,</p>
<table class="table table-bordered">
<tr>
<td>
<img src="/compiler_design/images/redundant_expression.jpg" alt="Redundant Expression" />
<p style="text-align:center;">[redundant expression]</p>
</td>
<td>
<img src="/compiler_design/images/partially_redundant_expression.jpg" alt="Partially Redundant Expression" />
<p style="text-align:center;">[partially redundant expression]</p>
</td>
</tr>
</table>
<p>Loop-invariant code is partially redundant and can be eliminated by using a code-motion technique.</p>
<p>Another example of a partially redundant code can be:</p>
<pre class="prettyprint notranslate">
If (condition)
{
   a = y OP z;
}
else
{
   ...
}
c = y OP z;
</pre>
<p>We assume that the values of operands (<b>y</b> and <b>z</b>) are not changed from assignment of variable <b>a</b> to variable <b>c</b>. Here, if the condition statement is true, then y OP z is computed twice, otherwise once. Code motion can be used to eliminate this redundancy, as shown below:</p>
<pre class="prettyprint notranslate">
If (condition)
{
   ...
   tmp = y OP z;
   a = tmp;
   ...
}
else
{
   ...
   tmp = y OP z;
}
c = tmp;
</pre>

<title>Compiler Design Useful Resources</title>

<h1>Compiler Design - Useful Resources</h1>

<p>The following resources contain additional information on Compiler Design. Please use them to get more in-depth knowledge on this topic.</p>

<h2>Useful Links on Compiler Design</h2>

<p><a target="_blank" rel="nofollow" href="http://codingground.tutorialspoint.com/">Coding Ground</a> - 70+ online compilers by Tutorials Point.</p>

<p><a target="_blank" rel="nofollow" href="http://en.wikipedia.org/wiki/Compiler">Wikipedia</a> - Wikipedia reference for Compilers.</p>

<h2>Useful Books on Compiler Design</h2>

<p>To enlist your site on this page, please drop an email to <b>contact@tutorialspoint.com</b></p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Discuss Compiler Design</title>

<h1>Discuss Compiler Design</h1>

<p>A compiler translates the code written in one language to some other language without changing the meaning of the program. It is also expected that a compiler should make the target code efficient and optimized in terms of time and space.</p>

<p>Compiler design principles provide an in-depth view of translation and optimization process. Compiler design covers basic translation mechanism and error detection &amp; recovery. It includes lexical, syntax, and semantic analysis as front end, and code generation and optimization as back-end.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

</body></html>