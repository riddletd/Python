<!DOCTYPE html><html><body><title>Fortran Tutorial</title>

<h1>Fortran Tutorial</h1>

<p>Fortran was originally developed by a team at IBM in 1957 for scientific calculations. Later developments made it into a high level programming language. In this tutorial, we will learn the basic concepts of Fortran and its programming code.</p>

<h1>Audience</h1>

<p>This tutorial is designed for the readers who wish to learn the basics of Fortran.</p>

<h1>Prerequisites</h1>

<p>This tutorial is designed for beginners. A general awareness of computer programming languages is the only prerequisite to make the most of this tutorial.</p>

<h1>Execute Fortran Online</h1>

<p>For most of the examples given in this tutorial you will find Try it option, so just make use of this option to execute your Fortran programs at the spot and enjoy your learning.</p>

<p>Try following example using Try it option available at the top right corner of the below sample code box &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate tryit">
program hello
   Print *, "Hello World!"
end program Hello
</pre>

<title>Fortran Overview</title>

<h1>Fortran - Overview</h1>

<p>Fortran, as derived from Formula Translating System, is a general-purpose, imperative programming language. It is used for numeric and scientific computing.</p>

<p>Fortran was originally developed by IBM in the 1950s for scientific and engineering applications. Fortran ruled this programming area for a long time and became very popular for high performance computing, because.</p>

<p>It supports:</p>

<h2>Facts about Fortran</h2>

<p>Fortran was created by a team, led by John Backus at IBM in 1957.</p>

<p>Initially the name used to be written in all capital, but current standards and implementations only require the first letter to be capital.</p>

<p>Fortran stands for FORmula TRANslator.</p>

<p>Originally developed for scientific calculations, it had very limited support for character strings and other structures needed for general purpose programming.</p>

<p>Later extensions and developments made it into a high level programming language with good degree of portability.</p>

<p>Original versions, Fortran I, II and III are considered obsolete now.</p>

<p>Oldest version still in use is Fortran IV, and Fortran 66.</p>

<p>Most commonly used versions today are : Fortran 77, Fortran 90, and Fortran 95.</p>

<p>Fortran 77 added strings as a distinct type.</p>

<p>Fortran 90 added various sorts of threading, and direct array processing.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Fortran - Environment Setup</title>

<h1>Fortran - Environment Setup</h1>

<h3>Try it Option Online</h3>

<p>We have set up the Fortran Programming environment online, so that you can compile and execute all the available examples online. It gives you confidence in what you are reading and enables you to verify the programs with different options. Feel free to modify any example and execute it online.</p>

<p>Try the following example using our online compiler available at <a href="http://www.tutorialspoint.com/codingground.htm">CodingGround</a></p>

<p>For most of the examples given in this tutorial, you will find a Try it option in our website code sections at the top right corner that will take you to the online compiler. So just make use of it and enjoy your learning.</p>

<h2>Setting up Fortran in Windows</h2>

<p>G95 is the GNU Fortran multi-architechtural compiler, used for setting up Fortran in Windows. The windows version emulates a unix environment using MingW under windows. The installer takes care of this and automatically adds g95 to the windows PATH variable.</p>

<p>You can get the stable version of G95 from here : <a href="http://www.fortran.com/the-fortran-company-homepage/whats-new/g95-windows-download/" rel="nofollow" target="_blank"></a></p>

<h2>How to use G95</h2>

<p>During installation, <b>g95</b> is automatically added to your PATH variable if you select the option “RECOMMENDED”. This means that you can simply open a new Command Prompt window and type “g95” to bring up the compiler. Find some basic commands below to get you started.</p>

<p><b>Command line options for G95:</b></p>

<p>Multiple source and object files can be specified at once. Fortran files are indicated by names ending in ".f", ".F", ".for", ".FOR", ".f90", ".F90", ".f95", ".F95", ".f03" and ".F03". Multiple source files can be specified. Object files can be specified as well and will be linked to form an executable file.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate tryit">
program hello
   Print *, "Hello World!"
end program Hello
</pre>
<p>For most of the examples given in this tutorial, you will find a Try it option in our website code sections at the top right corner that will take you to the online compiler. So just make use of it and enjoy your learning.</p>
</blockquote>
<h2>Setting up Fortran in Windows</h2>
<p>G95 is the GNU Fortran multi-architechtural compiler, used for setting up Fortran in Windows. The windows version emulates a unix environment using MingW under windows. The installer takes care of this and automatically adds g95 to the windows PATH variable.</p>
<p>You can get the stable version of G95 from here : <a href="http://www.fortran.com/the-fortran-company-homepage/whats-new/g95-windows-download/" rel="nofollow" target="_blank"></a></p>
<img src="/fortran/images/installer_setup.png" alt="installer setup" />
<img src="/fortran/images/mini_installer_setup.png" alt="mini installer setup" />
<h2>How to use G95</h2>
<p>During installation, <b>g95</b> is automatically added to your PATH variable if you select the option “RECOMMENDED”. This means that you can simply open a new Command Prompt window and type “g95” to bring up the compiler. Find some basic commands below to get you started.</p>
<table class="table table-bordered">
<tr>
<th>Command</th>
<th>Description</th>
</tr>
<tr>
<td>g95 –c hello.f90</td>
<td>Compiles hello.f90 to an object file named hello.o</td>
</tr>
<tr>
<td>g95 hello.f90</td>
<td>Compiles hello.f90 and links it to produce an executable a.out</td>
</tr>
<tr>
<td>g95 -c h1.f90 h2.f90 h3.f90</td>
<td>Compiles multiple source files. If all goes well, object files h1.o, h2.o and h3.o are created</td>
</tr>
<tr>
<td style="width:40%;">g95 -o hello h1.f90 h2.f90 h3.f90</td>
<td>Compiles multiple source files and links them together to an executable file named 'hello'</td>
</tr>
</table>
<p><b>Command line options for G95:</b></p>
<pre class="prettyprint notranslate">
-c Compile only, do not run the linker.
-o Specify the name of the output file, either an object file or the executable.
</pre>

<title>Fortran Basic Syntax</title>

<h1>Fortran - Basic Syntax</h1>

<p>A Fortran program is made of a collection of program units like a main program, modules, and external subprograms or procedures.</p>

<p>Each program contains one main program and may or may not contain other program units. The syntax of the main program is as follows:</p>

<h2>A Simple Program in Fortran</h2>

<p>Let’s write a program that adds two numbers and prints the result:</p>

<p>When you compile and execute the above program, it produces the following result:</p>

<p>Please note that:</p>

<p>All Fortran programs start with the keyword <b>program</b> and end with the keyword <b>end program,</b> followed by the name of the program.</p>

<p>The <b>implicit none</b> statement allows the compiler to check that all your variable types are declared properly. You must always use <b>implicit none</b> at the start of every program.</p>

<p>Comments in Fortran are started with the exclamation mark (!), as all characters after this (except in a character string) are ignored by the compiler.</p>

<p>The <b>print *</b> command displays data on the screen.</p>

<p>Indentation of code lines is a good practice for keeping a program readable.</p>

<p>Fortran allows both uppercase and lowercase letters. Fortran is case-insensitive, except for string literals.</p>

<h2>Basics</h2>

<p>The <b>basic character set</b> of Fortran contains:</p>

<p><b>Tokens</b> are made of characters in the basic character set. A token could be a keyword, an identifier, a constant, a string literal, or a symbol.</p>

<p>Program statements are made of tokens.</p>

<h2>Identifier</h2>

<p>An identifier is a name used to identify a variable, procedure, or any other user-defined item. A name in Fortran must follow the following rules:</p>

<p>It cannot be longer than 31 characters.</p>

<p>It must be composed of alphanumeric characters (all the letters of the alphabet, and the digits 0 to 9) and underscores (_).</p>

<p>First character of a name must be a letter.</p>

<p>Names are case-insensitive</p>

<h2>Keywords</h2>

<p>Keywords are special words, reserved for the language. These reserved words cannot be used as identifiers or names.</p>

<p>The following table, lists the Fortran keywords:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
program program_name
implicit none      

! type declaration statements      
! executable statements  

end program program_name
</pre>
<h2>A Simple Program in Fortran</h2>
<p>Let’s write a program that adds two numbers and prints the result:</p>
<pre class="prettyprint notranslate tryit">
program addNumbers

! This simple program adds two numbers     
   implicit none
   
! Type declarations
   real :: a, b, result 
   
! Executable statements 
   a = 12.0
   b = 15.0
   result = a + b
   print *, 'The total is ', result                   
   
end program addNumbers        
</pre>
<p>When you compile and execute the above program, it produces the following result:</p>
<pre class="result notranslate">
The total is 27.0000000    
</pre>

<title>Fortran Data Types</title>

<h1>Fortran - Data Types</h1>

<p>Fortran provides five intrinsic data types, however, you can derive your own data types as well. The five intrinsic types are:</p>

<h2>Integer Type</h2>

<p>The integer types can hold only integer values. The following example extracts the largest value that can be held in a usual four byte integer:</p>

<p>When you compile and execute the above program it produces the following result:</p>

<p>Note that the <b>huge()</b> function gives the largest number that can be held by the specific integer data type. You can also specify the number of bytes using the <b>kind</b> specifier. The following example demonstrates this:</p>

<p>When you compile and execute the above program, it produces the following result:</p>

<h2>Real Type</h2>

<p>It stores the floating point numbers, such as 2.0,  3.1415, -100.876, etc.</p>

<p>Traditionally there are two different real types, the default <b>real</b> type and <b>double precision</b> type.</p>

<p>However, Fortran 90/95 provides more control over the precision of real and integer data types through the<b>kind</b>specifier, which we will study in the chapter on Numbers.</p>

<p>The following example shows the use of real data type:</p>

<p>When you compile and execute the above program it produces the following result:</p>

<h2>Complex Type</h2>

<p>This is used for storing complex numbers. A complex number has two parts, the real part and the imaginary part. Two consecutive numeric storage units store these two parts.</p>

<p>For example, the complex number (3.0, -5.0) is equal to 3.0 – 5.0i</p>

<p>We will discuss Complex types in more detail, in the Numbers chapter.</p>

<h2>Logical Type</h2>

<p>There are only two logical values: <b>.true.</b> and <b>.false.</b></p>

<h2>Character Type</h2>

<p>The character type stores characters and strings. The length of the string can be specified by len specifier. If no length is specified, it is 1.</p>

<p><b>For example,</b></p>

<p>The expression, <b>name(1:4)</b> would give the substring “Zara”.</p>

<h2>Implicit Typing</h2>

<p>Older versions of Fortran allowed a feature called implicit typing, i.e., you do not have to declare the variables before use. If a variable is not declared, then the first letter of its name will determine its type.</p>

<p>Variable names starting with i, j, k, l, m, or n, are considered to be for integer variable and others are real variables. However, you must declare all the variables as it is good programming practice. For that you start your program with the statement:</p>

<p>This statement turns off implicit typing.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate tryit">
program testingInt
implicit none

   integer :: largeval
   print *, huge(largeval)
   
end program testingInt
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="result notranslate">
2147483647
</pre>
<p>Note that the <b>huge()</b> function gives the largest number that can be held by the specific integer data type. You can also specify the number of bytes using the <b>kind</b> specifier. The following example demonstrates this:</p>
<pre class="prettyprint notranslate tryit">
program testingInt
implicit none

   !two byte integer
   integer(kind=2) :: shortval
   
   !four byte integer
   integer(kind=4) :: longval
   
   !eight byte integer
   integer(kind=8) :: verylongval
   
   !sixteen byte integer
   integer(kind=16) :: veryverylongval
   
   !default integer 
   integer :: defval
        
   print *, huge(shortval)
   print *, huge(longval)
   print *, huge(verylongval)
   print *, huge(veryverylongval)
   print *, huge(defval)
   
end program testingInt
</pre>
<p>When you compile and execute the above program, it produces the following result:</p>
<pre class="result notranslate">
32767
2147483647
9223372036854775807
170141183460469231731687303715884105727
2147483647
</pre>
<h2>Real Type</h2>
<p>It stores the floating point numbers, such as 2.0,  3.1415, -100.876, etc.</p>
<p>Traditionally there are two different real types, the default <b>real</b> type and <b>double precision</b> type.</p>
<p>However, Fortran 90/95 provides more control over the precision of real and integer data types through the<b>kind</b>specifier, which we will study in the chapter on Numbers.</p>
<p>The following example shows the use of real data type:</p>
<pre class="prettyprint notranslate tryit">
program division   
implicit none  

   ! Define real variables   
   real :: p, q, realRes 
   
   ! Define integer variables  
   integer :: i, j, intRes  
   
   ! Assigning  values   
   p = 2.0 
   q = 3.0    
   i = 2 
   j = 3  
   
   ! floating point division
   realRes = p/q  
   intRes = i/j
   
   print *, realRes
   print *, intRes
   
end program division  
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="result notranslate">
0.666666687    
0
</pre>
<h2>Complex Type</h2>
<p>This is used for storing complex numbers. A complex number has two parts, the real part and the imaginary part. Two consecutive numeric storage units store these two parts.</p>
<p>For example, the complex number (3.0, -5.0) is equal to 3.0 – 5.0i</p>
<p>We will discuss Complex types in more detail, in the Numbers chapter.</p> 
<h2>Logical Type</h2>
<p>There are only two logical values: <b>.true.</b> and <b>.false.</b></p>
<h2>Character Type</h2>
<p>The character type stores characters and strings. The length of the string can be specified by len specifier. If no length is specified, it is 1.</p>
<p><b>For example,</b></p> 
<pre class="result notranslate">
character (len=40) :: name  
name = “Zara Ali”
</pre>
<p>The expression, <b>name(1:4)</b> would give the substring “Zara”.</p> 
<h2>Implicit Typing</h2>
<p>Older versions of Fortran allowed a feature called implicit typing, i.e., you do not have to declare the variables before use. If a variable is not declared, then the first letter of its name will determine its type.</p>
<p>Variable names starting with i, j, k, l, m, or n, are considered to be for integer variable and others are real variables. However, you must declare all the variables as it is good programming practice. For that you start your program with the statement:</p>
<pre class="prettyprint notranslate">
implicit none
</pre>

<title>Fortran Variables</title>

<h1>Fortran - Variables</h1>

<p>A variable is nothing but a name given to a storage area that our programs can manipulate. Each variable should have a specific type, which determines the size and layout of the variable's memory; the range of values that can be stored within that memory; and the set of operations that can be applied to the variable.</p>

<p>The name of a variable can be composed of letters, digits, and the underscore character. A name in Fortran must follow the following rules:</p>

<p>It cannot be longer than 31 characters.</p>

<p>It must be composed of alphanumeric characters (all the letters of the alphabet, and the digits 0 to 9) and underscores (_).</p>

<p>First character of a name must be a letter.</p>

<p>Names are case-insensitive.</p>

<p>Based on the basic types explained in previous chapter, following are the variable types:</p>

<h2>Variable Declaration</h2>

<p>Variables are declared at the beginning of a program (or subprogram) in a type declaration statement.</p>

<p>Syntax for variable declaration is as follows:</p>

<p><b>For example,</b></p>

<p>Later you can assign values to these variables, like,</p>

<p>You can also use the intrinsic function <b>cmplx,</b> to assign values to a complex variable:</p>

<p><b>Example</b></p>

<p>The following example demonstrates variable declaration, assignment and display on screen:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
type-specifier :: variable_name
</pre>
<p><b>For example,</b></p>
<pre class="result notranslate">
integer :: total  	
real :: average 
complex :: cx  
logical :: done 
character(len=80) :: message ! a string of 80 characters
</pre>
<p>Later you can assign values to these variables, like,</p>
<pre class="result notranslate">
total = 20000  
average = 1666.67   
done = .true.   
message = “A big Hello from Tutorials Point” 
cx = (3.0, 5.0) ! cx = 3.0 + 5.0i
</pre>
<p>You can also use the intrinsic function <b>cmplx,</b> to assign values to a complex variable:</p>
<pre class="result notranslate">
cx = cmplx (1.0/2.0, -7.0) ! cx = 0.5 – 7.0i 
cx = cmplx (x, y) ! cx = x + yi
</pre>
<p><b>Example</b></p>
<p>The following example demonstrates variable declaration, assignment and display on screen:</p>
<pre class="prettyprint notranslate tryit">
program variableTesting
implicit none

   ! declaring variables
   integer :: total      
   real :: average 
   complex :: cx  
   logical :: done 
   character(len=80) :: message ! a string of 80 characters
   
   !assigning values
   total = 20000  
   average = 1666.67   
   done = .true.   
   message = "A big Hello from Tutorials Point" 
   cx = (3.0, 5.0) ! cx = 3.0 + 5.0i

   Print *, total
   Print *, average
   Print *, cx
   Print *, done
   Print *, message
   
end program variableTesting
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
20000
1666.67004    
(3.00000000, 5.00000000 )
T
A big Hello from Tutorials Point         
</pre>

<title>Fortran Constants</title>

<h1>Fortran - Constants</h1>

<p>The constants refer to the fixed values that the program cannot alter during its execution. These fixed values are also called <b>literals</b>.</p>

<p>Constants can be of any of the basic data types like an integer constant, a floating constant, a character constant, a complex constant, or a string literal. There are only two logical constants : <b>.true.</b> and <b>.false.</b></p>

<p>The constants are treated just like regular variables, except that their values cannot be modified after their definition.</p>

<h2>Named Constants and Literals</h2>

<p>There are two types of constants:</p>

<p>A literal constant have a value, but no name.</p>

<p>For example, following are the literal constants:</p>

<p>"PQR" "a" "123'abc$%#@!"</p>

<p>" a quote "" "</p>

<p>'PQR' 'a' '123"abc$%#@!'</p>

<p>' an apostrophe '' '</p>

<p>A named constant has a value as well as a name.</p>

<p>Named constants should be declared at the beginning of a program or procedure, just like a variable type declaration, indicating its name and type. Named constants are declared with the parameter attribute. For example,</p>

<p><b>Example</b></p>

<p>The following program calculates the displacement due to vertical motion under gravity.</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
real, parameter :: pi = 3.1415927
</pre>
<p><b>Example</b></p>
<p>The following program calculates the displacement due to vertical motion under gravity.</p>
<pre class="prettyprint notranslate tryit">
program gravitationalDisp

! this program calculates vertical motion under gravity 
implicit none  

   ! gravitational acceleration
   real, parameter :: g = 9.81   
   
   ! variable declaration
   real :: s ! displacement   
   real :: t ! time  
   real :: u ! initial speed  
   
   ! assigning values 
   t = 5.0   
   u = 50  
   
   ! displacement   
   s = u * t - g * (t**2) / 2  
   
   ! output 
   print *, "Time = ", t
   print *, 'Displacement = ',s  
   
end program gravitationalDisp
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Time = 5.00000000    
Displacement = 127.374992    
</pre>

<title>Fortran Operators</title>

<h1>Fortran - Operators</h1>

<p>An operator is a symbol that tells the compiler to perform specific mathematical or logical manipulations. Fortran provides the following types of operators:</p>

<p>Let us look at all these types of operators one by one.</p>

<h2>Arithmetic Operators</h2>

<p>Following table shows all the arithmetic operators supported by Fortran. Assume variable <b>A</b> holds 5 and variable <b>B</b> holds 3 then:</p>

<p><a href="/fortran/fortran_arithmetic_operators.htm">Show Examples</a></p>

<h2>Relational Operators</h2>

<p>Following table shows all the relational operators supported by Fortran. Assume variable <b>A</b> holds 10 and variable <b>B</b> holds 20, then:</p>

<p><a href="/fortran/fortran_relational_operators.htm">Show Examples</a></p>

<h2>Logical Operators</h2>

<p>Logical operators in Fortran work only on logical values .true. and .false.</p>

<p>The following table shows all the logical operators supported by Fortran. Assume variable A holds .true. and variable B holds .false. , then:</p>

<p><a href="/fortran/fortran_logical_operators.htm">Show Examples</a></p>

<h2>Operators Precedence in Fortran</h2>

<p>Operator precedence determines the grouping of terms in an expression. This affects how an expression is evaluated. Certain operators have higher precedence than others; for example, the multiplication operator has higher precedence than the addition operator.</p>

<p>For example, x = 7 + 3 * 2; here, x is assigned 13, not 20 because operator * has higher precedence than +, so it first gets multiplied with 3*2 and then adds into 7.</p>

<p>Here, operators with the highest precedence appear at the top of the table, those with the lowest appear at the bottom. Within an expression, higher precedence operators will be evaluated first.</p>

<p><a href="/fortran/fortran_operators_precedence.htm">Show Examples</a></p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Fortran Decisions</title>

<h1>Fortran - Decisions</h1>

<p>Decision making structures require that the programmer specify one or more conditions to be evaluated or tested by the program, along with a statement or statements to be executed, if the condition is determined to be true, and optionally, other statements to be executed if the condition is determined to be false.</p>

<p>Following is the general form of a typical decision making structure found in most of the programming languages:</p>

<p>Fortran provides the following types of decision making constructs.</p>

<p><a href="/fortran/If_then_construct.htm">If… then construct</a></p>

<p><a href="/fortran/If_then_else_construct.htm">If… then...else construct</a></p>

<p><a href="/fortran/if_elseif_else_construct.htm">if...else if...else Statement</a></p>

<p><a href="/fortran/nested_if_construct.htm">nested if construct</a></p>

<p><a href="/fortran/select_case_construct.htm">select case construct</a></p>

<p><a href="/fortran/nested_select_case_construct.htm">nested select case construct</a></p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Fortran Loops</title>

<h1>Fortran - Loops</h1>

<p>There may be a situation, when you need to execute a block of code several number of times. In general, statements are executed sequentially : The first statement in a function is executed first, followed by the second, and so on.</p>

<p>A loop statement allows us to execute a statement or group of statements multiple times and following is the general form of a loop statement in most of the programming languages:</p>

<p>Fortran provides the following types of loop constructs to handle looping requirements. Click the following links to check their detail.</p>

<p><a href="/fortran/fortran_do_loop.htm">do loop</a></p>

<p><a href="/fortran/fortran_do_while_loop.htm">do while loop</a></p>

<p><a href="/fortran/fortran_nested_loop.htm">nested loops</a></p>

<h2>Loop Control Statements</h2>

<p>Loop control statements change execution from its normal sequence. When execution leaves a scope, all automatic objects that were created in that scope are destroyed.</p>

<p>Fortran supports the following control statements. Click the following links to check their detail.</p>

<p><a href="/fortran/fortran_exit.htm">exit</a></p>

<p><a href="/fortran/fortran_cycle.htm">cycle</a></p>

<p><a href="/fortran/fortran_stop.htm">stop</a></p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Fortran Numbers</title>

<h1>Fortran - Numbers</h1>

<p>Numbers in Fortran are represented by three intrinsic data types:</p>

<h2>Integer Type</h2>

<p>The integer types can hold only integer values. The following example extracts the largest value that could be hold in a usual four byte integer:</p>

<p>When you compile and execute the above program it produces the following result:</p>

<p>Please note that the <b>huge()</b> function gives the largest number that can be held by the specific integer data type. You can also specify the number of bytes using the <b>kind</b> specifier. The following example demonstrates this:</p>

<p>When you compile and execute the above program it produces the following result:</p>

<h2>Real Type</h2>

<p>It stores the floating point numbers, such as 2.0, 3.1415, -100.876, etc.</p>

<p>Traditionally there were two different <b>real</b> types : the default real type and <b>double precision</b> type.</p>

<p>However, Fortran 90/95 provides more control over the precision of real and integer data types through the <b>kind</b> specifier, which we will study shortly.</p>

<p>The following example shows the use of real data type:</p>

<p>When you compile and execute the above program it produces the following result:</p>

<h2>Complex Type</h2>

<p>This is used for storing complex numbers. A complex number has two parts : the real part and the imaginary part. Two consecutive numeric storage units store these two parts.</p>

<p>For example, the complex number (3.0, -5.0) is equal to 3.0 – 5.0i</p>

<p>The generic function <b>cmplx()</b> creates a complex number. It produces a result who’s real and imaginary parts are single precision, irrespective of the type of the input arguments.</p>

<p>When you compile and execute the above program it produces the following result:</p>

<p>The following program demonstrates complex number arithmetic:</p>

<p>When you compile and execute the above program it produces the following result:</p>

<h2>The Range, Precision and Size of Numbers</h2>

<p>The range on integer numbers, the precision and the size of floating point numbers depends on the number of bits allocated to the specific data type.</p>

<p>The following table displays the number of bits and range for integers:</p>

<p>The following table displays the number of bits, smallest and largest value, and the precision for real numbers.</p>

<p>The following examples demonstrate this:</p>

<p>When you compile and execute the above program it produces the following result:</p>

<p>Now let us use a smaller number:</p>

<p>When you compile and execute the above program it produces the following result:</p>

<p>Now let’s watch underflow:</p>

<p>When you compile and execute the above program it produces the following result:</p>

<h2>The Kind Specifier</h2>

<p>In scientific programming, one often needs to know the range and precision of data of the hardware platform on which the work is being done.</p>

<p>The intrinsic function <b>kind()</b> allows you to query the details of the hardware’s data representations before running a program.</p>

<p>When you compile and execute the above program it produces the following result:</p>

<p>You can also check the kind of all data types:</p>

<p>When you compile and execute the above program it produces the following result:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate tryit">
program testingInt
implicit none

   integer :: largeval
   print *, huge(largeval)
   
end program testingInt
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="result notranslate">
2147483647
</pre>
<p>Please note that the <b>huge()</b> function gives the largest number that can be held by the specific integer data type. You can also specify the number of bytes using the <b>kind</b> specifier. The following example demonstrates this:</p>
<pre class="prettyprint notranslate tryit">
program testingInt
implicit none

   !two byte integer
   integer(kind=2) :: shortval
   
   !four byte integer
   integer(kind=4) :: longval
   
   !eight byte integer
   integer(kind=8) :: verylongval
   
   !sixteen byte integer
   integer(kind=16) :: veryverylongval
   
   !default integer 
   integer :: defval
        
   print *, huge(shortval)
   print *, huge(longval)
   print *, huge(verylongval)
   print *, huge(veryverylongval)
   print *, huge(defval)
   
end program testingInt
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="result notranslate">
32767
2147483647
9223372036854775807
170141183460469231731687303715884105727
2147483647
</pre>
<h2>Real Type</h2>
<p>It stores the floating point numbers, such as 2.0, 3.1415, -100.876, etc.</p>
<p>Traditionally there were two different <b>real</b> types : the default real type and <b>double precision</b> type.</p>
<p>However, Fortran 90/95 provides more control over the precision of real and integer data types through the <b>kind</b> specifier, which we will study shortly.</p> 
<p>The following example shows the use of real data type:</p>
<pre class="prettyprint notranslate tryit">
program division   
implicit none

   ! Define real variables   
   real :: p, q, realRes 
   
   ! Define integer variables  
   integer :: i, j, intRes  
   
   ! Assigning  values   
   p = 2.0 
   q = 3.0    
   i = 2 
   j = 3  
   
   ! floating point division
   realRes = p/q  
   intRes = i/j
   
   print *, realRes
   print *, intRes
   
end program division  
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="result notranslate">
0.666666687    
0
</pre>
<h2>Complex Type</h2>
<p>This is used for storing complex numbers. A complex number has two parts : the real part and the imaginary part. Two consecutive numeric storage units store these two parts.</p> 
<p>For example, the complex number (3.0, -5.0) is equal to 3.0 – 5.0i</p>
<p>The generic function <b>cmplx()</b> creates a complex number. It produces a result who’s real and imaginary parts are single precision, irrespective of the type of the input arguments.</p>
<pre class="prettyprint notranslate tryit">
program createComplex
implicit none

   integer :: i = 10
   real :: x = 5.17
   print *, cmplx(i, x)
   
end program createComplex
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="result notranslate">
(10.0000000, 5.17000008)
</pre>
<p>The following program demonstrates complex number arithmetic:</p>
<pre class="prettyprint notranslate tryit">
program ComplexArithmatic
implicit none

   complex, parameter :: i = (0, 1)   ! sqrt(-1)   
   complex :: x, y, z 
   
   x = (7, 8); 
   y = (5, -7)   
   write(*,*) i * x * y
   
   z = x + y
   print *, "z = x + y = ", z
   
   z = x - y
   print *, "z = x - y = ", z 
   
   z = x * y
   print *, "z = x * y = ", z 
   
   z = x / y
   print *, "z = x / y = ", z 
   
end program ComplexArithmatic
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="result notranslate">
(9.00000000, 91.0000000)
z = x + y = (12.0000000, 1.00000000)
z = x - y = (2.00000000, 15.0000000)
z = x * y = (91.0000000, -9.00000000)
z = x / y = (-0.283783793, 1.20270276)
</pre>
<h2>The Range, Precision and Size of Numbers</h2>
<p>The range on integer numbers, the precision and the size of floating point numbers depends on the number of bits allocated to the specific data type.</p>
<p>The following table displays the number of bits and range for integers:</p>
<table class="table table-bordered">
<tr>
<th>Number of bits</th>
<th>Maximum value</th>
<th>Reason</th>
</tr>
<tr>
<td>64</td>
<td>9,223,372,036,854,774,807</td>
<td>(2**63)–1</td>
</tr>
<tr>
<td>32</td>
<td>2,147,483,647</td>
<td>(2**31)–1</td>
</tr>
</table>
<p>The following table displays the number of bits, smallest and largest value, and the precision for real numbers.</p>
<table class="table table-bordered">
<tr>
<th>Number of bits</th>
<th>Largest value</th>
<th>Smallest value</th>
<th>Precision</th>
</tr>
<tr>
<td>64</td>
<td>0.8E+308</td>
<td>0.5E–308</td>
<td>15–18</td>
</tr>
<tr>
<td>32</td>
<td>1.7E+38</td>
<td>0.3E–38</td>
<td>6-9</td>
</tr>
</table>
<p>The following examples demonstrate this:</p>
<pre class="prettyprint notranslate tryit">
program rangePrecision
implicit none

   real:: x, y, z
   x = 1.5e+40
   y = 3.73e+40
   z = x * y 
   print *, z
   
end program rangePrecision
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="result notranslate">
x = 1.5e+40
    1
Error : Real constant overflows its kind at (1)
main.f95:5.12:

y = 3.73e+40
    1
Error : Real constant overflows its kind at (1)
</pre>
<p>Now let us use a smaller number:</p>
<pre class="prettyprint notranslate tryit">
program rangePrecision
implicit none

   real:: x, y, z
   x = 1.5e+20
   y = 3.73e+20
   z = x * y 
   print *, z
   
   z = x/y
   print *, z
   
end program rangePrecision
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="result notranslate">
Infinity
0.402144760   
</pre>
<p>Now let’s watch underflow:</p>
<pre class="prettyprint notranslate tryit">
program rangePrecision
implicit none

   real:: x, y, z
   x = 1.5e-30
   y = 3.73e-60
   z = x * y 
   print *, z
   
   z = x/y
   print *, z

end program rangePrecision
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="result notranslate">
y = 3.73e-60
    1
Warning : Real constant underflows its kind at (1)

Executing the program....
$demo 

0.00000000E+00
Infinity
</pre>
<h2>The Kind Specifier</h2>
<p>In scientific programming, one often needs to know the range and precision of data of the hardware platform on which the work is being done.</p>
<p>The intrinsic function <b>kind()</b> allows you to query the details of the hardware’s data representations before running a program.</p>
<pre class="prettyprint notranslate tryit">
program kindCheck
implicit none
   
   integer :: i 
   real :: r 
   complex :: cp 
   print *,' Integer ', kind(i) 
   print *,' Real ', kind(r) 
   print *,' Complex ', kind(cp) 
   
end program kindCheck
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="result notranslate">
Integer 4
Real 4
Complex 4
</pre>
<p>You can also check the kind of all data types:</p>
<pre class="prettyprint notranslate tryit">
program checkKind
implicit none

   integer :: i 
   real :: r 
   character*1 :: c 
   logical :: lg 
   complex :: cp 
   
   print *,' Integer ', kind(i) 
   print *,' Real ', kind(r) 
   print *,' Complex ', kind(cp)
   print *,' Character ', kind(c) 
   print *,' Logical ', kind(lg)
   
end program checkKind
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="result notranslate">
Integer 4
Real 4
Complex 4
Character 1
Logical 4
</pre>

<title>Fortran Characters</title>

<h1>Fortran - Characters</h1>

<p>The Fortran language can treat characters as single character or contiguous strings. </p>

<p>Characters could be any symbol taken from the basic character set, i.e., from the letters, the decimal digits, the underscore, and 21 special characters.</p>

<p>A character constant is a fixed valued character string.</p>

<p>The intrinsic data type <b>character</b> stores characters and strings. The length of the string can be specified by <b>len</b> specifier. If no length is specified, it is 1. You can refer individual characters within a string referring by position; the left most character is at position 1.</p>

<h2>Character Declaration</h2>

<p>Declaring a character type data is same as other variables:</p>

<p>For example,</p>

<p>you can assign a value like,</p>

<p>The following example demonstrates declaration and use of character data type:</p>

<p>When you compile and execute the above program it produces the following result:</p>

<h2>Concatenation of Characters</h2>

<p>The concatenation operator //, concatenates characters.</p>

<p>The following example demonstrates this:</p>

<p>When you compile and execute the above program it produces the following result:</p>

<h2>Some Character Functions</h2>

<p>The following table shows some commonly used character functions along with the description:</p>

<p><b>Example 1</b></p>

<p>This example shows the use of the <b>index</b> function:</p>

<p>When you compile and execute the above program it produces the following result:</p>

<p><b>Example 2</b></p>

<p>This example demonstrates the use of the <b>trim</b> function:</p>

<p>When you compile and execute the above program it produces the following result:</p>

<p><b>Example 3</b></p>

<p>This example demonstrates the use of <b>achar</b> function</p>

<p>When you compile and execute the above program it produces the following result:</p>

<h2>Checking Lexical Order of Characters</h2>

<p>The following functions determine the lexical sequence of characters:</p>

<p><b>Example 4</b></p>

<p>The following function demonstrates the use:</p>

<p>When you compile and execute the above program it produces the following result:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
type-specifier :: variable_name
</pre>
<p>For example,</p>
<pre class="prettyprint notranslate">
character :: reply, sex
</pre>
<p>you can assign a value like,</p>
<pre class="prettyprint notranslate">
reply = ‘N’ 
sex = ‘F’
</pre>
<p>The following example demonstrates declaration and use of character data type:</p>
<pre class="prettyprint notranslate tryit">
program hello
implicit none

   character(len=15) :: surname, firstname 
   character(len=6) :: title 
   character(len=25)::greetings
   
   title = 'Mr. ' 
   firstname = 'Rowan ' 
   surname = 'Atkinson'
   greetings = 'A big hello from Mr. Bean'
   
   print *, 'Here is ', title, firstname, surname
   print *, greetings
   
end program hello
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="result notranslate">
Here is Mr. Rowan Atkinson       
A big hello from Mr. Bean
</pre>
<h2>Concatenation of Characters</h2>
<p>The concatenation operator //, concatenates characters.</p>
<p>The following example demonstrates this:</p>
<pre class="prettyprint notranslate tryit">
program hello
implicit none

   character(len=15) :: surname, firstname 
   character(len=6) :: title 
   character(len=40):: name
   character(len=25)::greetings
   
   title = 'Mr. ' 
   firstname = 'Rowan ' 
   surname = 'Atkinson'
   
   name = title//firstname//surname
   greetings = 'A big hello from Mr. Bean'
   
   print *, 'Here is ', name
   print *, greetings
   
end program hello
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="result notranslate">
Here is Mr.Rowan Atkinson       
A big hello from Mr.Bean
</pre>
<h2>Some Character Functions</h2>
<p>The following table shows some commonly used character functions along with the description:</p>
<table class="table table-bordered">
<tr>
<th>Function</th>
<th>Description</th>
</tr>
<tr>
<td>len(string)</td>
<td>It returns the length of a character string</td>
</tr>
<tr>
<td>index(string,sustring)</td>
<td>It ﬁnds the location of a substring in another string, returns 0 if not found.</td>
</tr>
<tr>
<td>achar(int)</td>
<td>It converts an integer into a character</td>
</tr>
<tr>
<td>iachar(c)</td>
<td>It converts a character into an integer</td>
</tr>
<tr>
<td>trim(string)</td>
<td>It returns the string with the trailing blanks removed.</td>
</tr>
<tr>
<td>scan(string, chars)</td>
<td>It searches the "string" from left to right (unless back=.true.) for the first occurrence of any character contained in "chars". It returns an integer giving the position of that character, or zero if none of the characters in "chars" have been found.</td>
</tr>
<tr>
<td>verify(string, chars)</td>
<td>It scans the "string" from left to right (unless back=.true.) for the first occurrence of any character not contained in "chars". It returns an integer giving the position of that character, or zero if only the characters in "chars" have been found</td>
</tr>
<tr>
<td>adjustl(string)</td>
<td>It left justifies characters contained in the "string"</td>
</tr>
<tr>
<td>adjustr(string)</td>
<td>It right justifies characters contained in the "string"</td>
</tr>
<tr>
<td>len_trim(string)</td>
<td>It returns an integer equal to the length of "string" (len(string)) minus the number of trailing blanks</td>
</tr>
<tr>
<td>repeat(string,ncopy)</td>
<td>It returns a string with length equal to "ncopy" times the length of "string", and containing "ncopy" concatenated copies of "string"</td>
</tr>
</table>
<p><b>Example 1</b></p>
<p>This example shows the use of the <b>index</b> function:</p> 
<pre class="prettyprint notranslate tryit">
program testingChars
implicit none

   character (80) :: text 
   integer :: i 
   
   text = 'The intrinsic data type character stores characters and   strings.'
   i=index(text,'character') 
   
   if (i /= 0) then
      print *, ' The word character found at position ',i 
      print *, ' in text: ', text 
   end if
   
end program testingChars
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="result notranslate">
The word character found at position 25
in text : The intrinsic data type character stores characters and strings.  
</pre>
<p><b>Example 2</b></p>
<p>This example demonstrates the use of the <b>trim</b> function:</p>
<pre class="prettyprint notranslate tryit">
program hello
implicit none

   character(len=15) :: surname, firstname 
   character(len=6) :: title 
   character(len=25)::greetings
   
   title = 'Mr.' 
   firstname = 'Rowan' 
   surname = 'Atkinson'
   
   print *, 'Here is', title, firstname, surname
   print *, 'Here is', trim(title),' ',trim(firstname),' ', trim(surname)
   
end program hello
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="result notranslate">
Here is Mr. Rowan Atkinson       
Here is Mr. Rowan Atkinson
</pre>
<p><b>Example 3</b></p>
<p>This example demonstrates the use of <b>achar</b> function</p>
<pre class="prettyprint notranslate tryit">
program testingChars
implicit none

   character:: ch
   integer:: i
   
   do i=65, 90
      ch = achar(i)
      print*, i, ' ', ch
   end do
   
end program testingChars
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="result notranslate">
65  A
66  B
67  C
68  D
69  E
70  F
71  G
72  H
73  I
74  J
75  K
76  L
77  M
78  N
79  O
80  P
81  Q
82  R
83  S
84  T
85  U
86  V
87  W
88  X
89  Y
90  Z
</pre>
<h2>Checking Lexical Order of Characters</h2>
<p>The following functions determine the lexical sequence of characters:</p>
<table class="table table-bordered">
<tr>
<th style="width:20%">Function</th>
<th>Description</th>
</tr>
<tr>
<td>lle(char, char)</td>
<td>Compares whether the first character is lexically less than or equal to the second</td>
</tr>
<tr>
<td>lge(char, char)</td>
<td>Compares whether the first character is lexically greater than or equal to the second</td>
</tr>
<tr>
<td>lgt(char, char)</td>
<td>Compares whether the first character is lexically greater than the second</td>
</tr>
<tr>
<td>llt(char, char)</td>
<td>Compares whether the first character is lexically less than the second</td>
</tr>
</table>
<p><b>Example 4</b></p>
<p>The following function demonstrates the use:</p>
<pre class="prettyprint notranslate tryit">
program testingChars
implicit none

   character:: a, b, c
   a = 'A'
   b = 'a'
   c = 'B'
   
   if(lgt(a,b)) then
      print *, 'A is lexically greater than a'
   else
      print *, 'a is lexically greater than A'
   end if
   
   if(lgt(a,c)) then
      print *, 'A is lexically greater than B'
   else
      print *, 'B is lexically greater than A'
   end if  
   
   if(llt(a,b)) then
      print *, 'A is lexically less than a'
   end if
   
   if(llt(a,c)) then
      print *, 'A is lexically less than B'
   end if
   
end program testingChars
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="result notranslate">
a is lexically greater than A
B is lexically greater than A
A is lexically less than a
A is lexically less than B
</pre>

<title>Fortran Strings</title>

<h1>Fortran - Strings</h1>

<p>The Fortran language can treat characters as single character or contiguous strings.</p>

<p>A character string may be only one character in length, or it could even be of zero length. In Fortran, character constants are given between a pair of double or single quotes.</p>

<p>The intrinsic data type <b>character</b> stores characters and strings. The length of the string can be specified by <b>len specifier</b>. If no length is specified, it is 1. You can refer individual characters within a string referring by position; the left most character is at position 1.</p>

<h2>String Declaration</h2>

<p>Declaring a string is same as other variables:</p>

<p>For example,</p>

<p>you can assign a value like,</p>

<p>The following example demonstrates declaration and use of character data type:</p>

<p>When you compile and execute the above program it produces the following result:</p>

<h2>String Concatenation</h2>

<p>The concatenation operator //, concatenates strings.</p>

<p>The following example demonstrates this:</p>

<p>When you compile and execute the above program it produces the following result:</p>

<h2>Extracting Substrings</h2>

<p>In Fortran, you can extract a substring from a string by indexing the string, giving the start and the end index of the substring in a pair of brackets. This is called extent specifier.</p>

<p>The following example shows how to extract the substring ‘world’ from the string ‘hello world’:</p>

<p>When you compile and execute the above program it produces the following result:</p>

<p><b>Example</b></p>

<p>The following example uses the <b>date_and_time</b> function to give the date and time string. We use extent specifiers to extract the year, date, month, hour, minutes and second information separately.</p>

<p>When you compile and execute the above program, it gives the detailed date and time information:</p>

<h2>Trimming Strings</h2>

<p>The <b>trim</b> function takes a string, and returns the input string after removing all trailing blanks.</p>

<p><b>Example</b></p>

<p>When you compile and execute the above program it produces the following result:</p>

<h2>Left and Right Adjustment of Strings</h2>

<p>The function <b>adjustl</b> takes a string and returns it by removing the leading blanks and appending them as trailing blanks.</p>

<p>The function <b>adjustr</b> takes a string and returns it by removing the trailing blanks and appending them as leading blanks.</p>

<p><b>Example</b></p>

<p>When you compile and execute the above program it produces the following result:</p>

<h2>Searching for a Substring in a String</h2>

<p>The index function takes two strings and checks if the second string is a substring of the first string. If the second argument is a substring of the first argument, then it returns an integer which is the starting index of the second string in the first string, else it returns zero.</p>

<p><b>Example</b></p>

<p>When you compile and execute the above program it produces the following result:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
type-specifier :: variable_name
</pre>
<p>For example,</p>
<pre class="result notranslate">
Character(len=20) :: firstname, surname
</pre>
<p>you can assign a value like,</p>
<pre class="result notranslate">
character (len=40) :: name  
name = “Zara Ali”
</pre>
<p>The following example demonstrates declaration and use of character data type:</p>
<pre class="prettyprint notranslate tryit">
program hello
implicit none

   character(len=15) :: surname, firstname 
   character(len=6) :: title 
   character(len=25)::greetings
   
   title = 'Mr.' 
   firstname = 'Rowan' 
   surname = 'Atkinson'
   greetings = 'A big hello from Mr. Beans'
   
   print *, 'Here is', title, firstname, surname
   print *, greetings
   
end program hello
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="result notranslate">
Here is Mr. Rowan Atkinson       
A big hello from Mr. Bean
</pre>
<h2>String Concatenation</h2>
<p>The concatenation operator //, concatenates strings.</p>
<p>The following example demonstrates this:</p>
<pre class="prettyprint notranslate tryit">
program hello
implicit none

   character(len=15) :: surname, firstname 
   character(len=6) :: title 
   character(len=40):: name
   character(len=25)::greetings
   
   title = 'Mr.' 
   firstname = 'Rowan' 
   surname = 'Atkinson'
   
   name = title//firstname//surname
   greetings = 'A big hello from Mr. Beans'
   
   print *, 'Here is', name
   print *, greetings
   
end program hello
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="result notranslate">
Here is Mr. Rowan Atkinson       
A big hello from Mr. Bean
</pre>
<h2>Extracting Substrings</h2>
<p>In Fortran, you can extract a substring from a string by indexing the string, giving the start and the end index of the substring in a pair of brackets. This is called extent specifier.</p>
<p>The following example shows how to extract the substring ‘world’ from the string ‘hello world’:</p>
<pre class="prettyprint notranslate tryit">
program subString

   character(len=11)::hello
   hello = "Hello World"
   print*, hello(7:11)
   
end program subString 
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="result notranslate">
World
</pre>
<p><b>Example</b></p>
<p>The following example uses the <b>date_and_time</b> function to give the date and time string. We use extent specifiers to extract the year, date, month, hour, minutes and second information separately.</p>
<pre class="prettyprint notranslate">
program  datetime
implicit none

   character(len = 8) :: dateinfo ! ccyymmdd
   character(len = 4) :: year, month*2, day*2

   character(len = 10) :: timeinfo ! hhmmss.sss
   character(len = 2)  :: hour, minute, second*6

   call  date_and_time(dateinfo, timeinfo)

   !  let’s break dateinfo into year, month and day.
   !  dateinfo has a form of ccyymmdd, where cc = century, yy = year
   !  mm = month and dd = day

   year  = dateinfo(1:4)
   month = dateinfo(5:6)
   day   = dateinfo(7:8)

   print*, 'Date String:', dateinfo
   print*, 'Year:', year
   print *,'Month:', month
   print *,'Day:', day

   !  let’s break timeinfo into hour, minute and second.
   !  timeinfo has a form of hhmmss.sss, where h = hour, m = minute
   !  and s = second

   hour   = timeinfo(1:2)
   minute = timeinfo(3:4)
   second = timeinfo(5:10)

   print*, 'Time String:', timeinfo
   print*, 'Hour:', hour
   print*, 'Minute:', minute
   print*, 'Second:', second   
   
end program  datetime
</pre>
<p>When you compile and execute the above program, it gives the detailed date and time information:</p>
<pre class="result notranslate">
Date String: 20140803
   Year: 2014
   Month: 08
   Day: 03
   Time String: 075835.466
   Hour: 07
   Minute: 58
   Second: 35.466
</pre>
<h2>Trimming Strings</h2>
<p>The <b>trim</b> function takes a string, and returns the input string after removing all trailing blanks.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate tryit">
program trimString
implicit none

   character (len=*), parameter :: fname="Susanne", sname="Rizwan"
   character (len=20) :: fullname 
   
   fullname=fname//" "//sname !concatenating the strings
   
   print*,fullname,", the beautiful dancer from the east!"
   print*,trim(fullname),", the beautiful dancer from the east!"
   
end program trimString
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="result notranslate">
Susanne Rizwan      , the beautiful dancer from the east!
 Susanne Rizwan, the beautiful dancer from the east!
</pre>
<h2>Left and Right Adjustment of Strings</h2>
<p>The function <b>adjustl</b> takes a string and returns it by removing the leading blanks and appending them as trailing blanks.</p>
<p>The function <b>adjustr</b> takes a string and returns it by removing the trailing blanks and appending them as leading blanks.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate tryit">
program hello
implicit none

   character(len=15) :: surname, firstname 
   character(len=6) :: title 
   character(len=40):: name
   character(len=25):: greetings
   
   title = 'Mr. ' 
   firstname = 'Rowan' 
   surname = 'Atkinson'
   greetings = 'A big hello from Mr. Beans'
   
   name = adjustl(title)//adjustl(firstname)//adjustl(surname)
   print *, 'Here is', name
   print *, greetings
   
   name = adjustr(title)//adjustr(firstname)//adjustr(surname)
   print *, 'Here is', name
   print *, greetings
   
   name = trim(title)//trim(firstname)//trim(surname)
   print *, 'Here is', name
   print *, greetings
   
end program hello
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="result notranslate">
Here is Mr. Rowan  Atkinson           
A big hello from Mr. Bean
Here is Mr. Rowan Atkinson    
A big hello from Mr. Bean
Here is Mr.RowanAtkinson                        
A big hello from Mr. Bean
</pre>
<h2>Searching for a Substring in a String</h2>
<p>The index function takes two strings and checks if the second string is a substring of the first string. If the second argument is a substring of the first argument, then it returns an integer which is the starting index of the second string in the first string, else it returns zero.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate tryit">
program hello
implicit none

   character(len=30) :: myString
   character(len=10) :: testString
   
   myString = 'This is a test'
   testString = 'test'
   
   if(index(myString, testString) == 0)then
      print *, 'test is not found'
   else
      print *, 'test is found at index: ', index(myString, testString)
   end if
   
end program hello
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="result notranslate">
test is found at index: 11
</pre>

<title>Fortran Arrays</title>

<h1>Fortran - Arrays</h1>

<p>Arrays can store a fixed-size sequential collection of elements of the same type. An array is used to store a collection of data, but it is often more useful to think of an array as a collection of variables of the same type.</p>

<p>All arrays consist of contiguous memory locations. The lowest address corresponds to the first element and the highest address to the last element.</p>

<p>Arrays can be one- dimensional (like vectors), two-dimensional (like matrices) and Fortran allows you to create up to 7-dimensional arrays.</p>

<h2>Declaring Arrays</h2>

<p>Arrays are declared with the <b>dimension</b> attribute.</p>

<p>For example, to declare a one-dimensional array named number, of real numbers containing 5 elements, you write,</p>

<p>The individual elements of arrays are referenced by specifying their subscripts. The first element of an array has a subscript of one. The array numbers contains five real variables –numbers(1), numbers(2), numbers(3), numbers(4), and numbers(5).</p>

<p>To create a 5 x 5 two-dimensional array of integers named matrix, you write:</p>

<p>You can also declare an array with some explicit lower bound, for example:</p>

<h2>Assigning Values</h2>

<p>You can either assign values to individual members, like,</p>

<p>or, you can use a loop,</p>

<p>One dimensional array elements can be directly assigned values using a short hand symbol, called array constructor, like,</p>

<p><b>please note that there are no spaces allowed between the brackets ‘( ‘and the back slash ‘/’</b></p>

<p><b>Example</b></p>

<p>The following example demonstrates the concepts discussed above.</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Some Array Related Terms</h2>

<p>The following table gives some array related terms:</p>

<h2>Passing Arrays to Procedures</h2>

<p>You can pass an array to a procedure as an argument. The following example demonstrates the concept:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>In the above example, the subroutine fillArray and printArray can only be called with arrays with dimension 5. However, to write subroutines that can be used for arrays of any size, you can rewrite it using the following technique:</p>

<p>Please note that the program is using the <b>size</b> function to get the size of the array.</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Array Sections</h2>

<p>So far we have referred to the whole array, Fortran provides an easy way to refer several elements, or a section of an array, using a single statement.</p>

<p>To access an array section, you need to provide the lower and the upper bound of the section, as well as a stride (increment), for all the dimensions. This notation is called a <b>subscript triplet:</b></p>

<p>When no lower and upper bounds are mentioned, it defaults to the extents you declared, and stride value defaults to 1.</p>

<p>The following example demonstrates the concept:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Array Intrinsic Functions</h2>

<p>Fortran 90/95 provides several intrinsic procedures. They can be divided into 7 categories.</p>

<p><a href="/fortran/vector_and_matrix_multiplication.htm">Vector and matrix multiplication</a></p>

<p><a href="/fortran/reduction.htm">Reduction</a></p>

<p><a href="/fortran/inquiry.htm">Inquiry</a></p>

<p><a href="/fortran/construction.htm">Construction</a></p>

<p><a href="/fortran/reshape.htm">Reshape</a></p>

<p><a href="/fortran/manipulation.htm">Manipulation</a></p>

<p><a href="/fortran/location.htm">Location</a></p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
real, dimension(5) :: numbers
</pre>
<p>The individual elements of arrays are referenced by specifying their subscripts. The first element of an array has a subscript of one. The array numbers contains five real variables –numbers(1), numbers(2), numbers(3), numbers(4), and numbers(5).</p>
<p>To create a 5 x 5 two-dimensional array of integers named matrix, you write:</p>
<pre class="result notranslate">
integer, dimension (5,5) :: matrix  
</pre>
<p>You can also declare an array with some explicit lower bound, for example:</p>
<pre class="result notranslate">
real, dimension(2:6) :: numbers
integer, dimension (-3:2,0:4) :: matrix  
</pre>
<h2>Assigning Values</h2>
<p>You can either assign values to individual members, like,</p>
<pre class="result notranslate">
numbers(1) = 2.0
</pre>
<p>or, you can use a loop,</p>
<pre class="prettyprint notranslate">
do i=1,5
   numbers(i) = i * 2.0
end do
</pre>
<p>One dimensional array elements can be directly assigned values using a short hand symbol, called array constructor, like,</p>
<pre class="result notranslate">
numbers = (/1.5, 3.2,4.5,0.9,7.2 /)
</pre>
<p><b>please note that there are no spaces allowed between the brackets ‘( ‘and the back slash ‘/’</b></p>
<p><b>Example</b></p>
<p>The following example demonstrates the concepts discussed above.</p>
<pre class="prettyprint notranslate tryit">
program arrayProg

   real :: numbers(5) !one dimensional integer array
   integer :: matrix(3,3), i , j !two dimensional real array
   
   !assigning some values to the array numbers
   do i=1,5
      numbers(i) = i * 2.0
   end do
   
   !display the values
   do i = 1, 5
      Print *, numbers(i)
   end do
   
   !assigning some values to the array matrix
   do i=1,3
      do j = 1, 3
         matrix(i, j) = i+j
      end do
   end do
   
   !display the values
   do i=1,3
      do j = 1, 3
         Print *, matrix(i,j)
      end do
   end do
   
   !short hand assignment
   numbers = (/1.5, 3.2,4.5,0.9,7.2 /)
   
   !display the values
   do i = 1, 5
      Print *, numbers(i)
   end do
   
end program arrayProg
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
 2.00000000    
 4.00000000    
 6.00000000    
 8.00000000    
 10.0000000    
         2
         3
         4
         3
         4
         5
         4
         5
         6
 1.50000000    
 3.20000005    
 4.50000000    
0.899999976    
 7.19999981    
</pre>
<h2>Some Array Related Terms</h2>
<p>The following table gives some array related terms:</p>
<table class="table table-bordered">
<tr>
<th>Term</th>
<th>Meaning</th>
</tr>
<tr>
<td>Rank</td>
<td>It is the number of dimensions an array has. For example, for the array named matrix, rank is 2, and for the array named numbers, rank is 1.</td>
</tr>
<tr>
<td>Extent</td>
<td>It is the number of elements along a dimension. For example, the array numbers has extent 5 and the array named matrix has extent 3 in both dimensions.</td>
</tr>
<tr>
<td>Shape</td>
<td>The shape of an array is a one-dimensional integer array, containing the number of elements (the extent) in each dimension. For example, for the array matrix, shape is (3, 3) and the array numbers it is (5).</td>
</tr>
<tr>
<td>Size</td>
<td>It is the number of elements an array contains. For the array matrix, it is 9, and for the array numbers, it is 5.</td>
</tr>
</table>
<h2>Passing Arrays to Procedures</h2>
<p>You can pass an array to a procedure as an argument. The following example demonstrates the concept:</p>
<pre class="prettyprint notranslate tryit">
program arrayToProcedure      
implicit none      

   integer, dimension (5) :: myArray  
   integer :: i
   
   call fillArray (myArray)      
   call printArray(myArray)
   
end program arrayToProcedure


subroutine fillArray (a)      
implicit none      

   integer, dimension (5), intent (out) :: a
   
   ! local variables     
   integer :: i     
   do i = 1, 5         
      a(i) = i      
   end do  
   
end subroutine fillArray 


subroutine printArray(a)

   integer, dimension (5) :: a  
   integer::i
   
   do i = 1, 5
      Print *, a(i)
   end do
   
end subroutine printArray
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
1
2
3
4
5
</pre>
<p>In the above example, the subroutine fillArray and printArray can only be called with arrays with dimension 5. However, to write subroutines that can be used for arrays of any size, you can rewrite it using the following technique:</p>
<pre class="prettyprint notranslate tryit">
program arrayToProcedure      
implicit  none    

   integer, dimension (10) :: myArray  
   integer :: i
   
   interface 
      subroutine fillArray (a)
         integer, dimension(:), intent (out) :: a 
         integer :: i         
      end subroutine fillArray      

      subroutine printArray (a)
         integer, dimension(:) :: a 
         integer :: i         
      end subroutine printArray   
   end interface 
   
   call fillArray (myArray)      
   call printArray(myArray)
   
end program arrayToProcedure


subroutine fillArray (a)      
implicit none      
   integer,dimension (:), intent (out) :: a      
   
   ! local variables     
   integer :: i, arraySize  
   arraySize = size(a)
   
   do i = 1, arraySize         
      a(i) = i      
   end do  
   
end subroutine fillArray 


subroutine printArray(a)
implicit none

   integer,dimension (:) :: a  
   integer::i, arraySize
   arraySize = size(a)
   
   do i = 1, arraySize
     Print *, a(i)
   end do
   
end subroutine printArray
</pre>
<p>Please note that the program is using the <b>size</b> function to get the size of the array.</p>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
1
2
3
4
5
6
7
8
9
10
</pre>
<h2>Array Sections</h2>
<p>So far we have referred to the whole array, Fortran provides an easy way to refer several elements, or a section of an array, using a single statement.</p>
<p>To access an array section, you need to provide the lower and the upper bound of the section, as well as a stride (increment), for all the dimensions. This notation is called a <b>subscript triplet:</b></p>
<pre class="prettyprint notranslate">
array ([lower]:[upper][:stride], ...)
</pre>
<p>When no lower and upper bounds are mentioned, it defaults to the extents you declared, and stride value defaults to 1.</p>
<p>The following example demonstrates the concept:</p>
<pre class="prettyprint notranslate tryit">
program arraySubsection

   real, dimension(10) :: a, b
   integer:: i, asize, bsize
   
   a(1:7) = 5.0 ! a(1) to a(7) assigned 5.0
   a(8:) = 0.0  ! rest are 0.0 
   b(2:10:2) = 3.9
   b(1:9:2) = 2.5
   
   !display
   asize = size(a)
   bsize = size(b)
   
   do i = 1, asize
      Print *, a(i)
   end do
   
   do i = 1, bsize
      Print *, b(i)
   end do
   
end program arraySubsection
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
5.00000000    
5.00000000    
5.00000000    
5.00000000    
5.00000000    
5.00000000    
5.00000000    
0.00000000E+00
0.00000000E+00
0.00000000E+00
2.50000000    
3.90000010    
2.50000000    
3.90000010    
2.50000000    
3.90000010    
2.50000000    
3.90000010    
2.50000000    
3.90000010 
</pre>

<title>Fortran Dynamic Arrays</title>

<h1>Fortran - Dynamic Arrays</h1>

<p>A <b>dynamic array</b> is an array, the size of which is not known at compile time, but will be known at execution time.</p>

<p>Dynamic arrays are declared with the attribute <b>allocatable</b>.</p>

<p>For example,</p>

<p>The rank of the array, i.e., the dimensions has to be mentioned however, to allocate memory to such an array, you use the <b>allocate</b> function.</p>

<p>After the array is used, in the program, the memory created should be freed using the <b>deallocate</b> function</p>

<p><b>Example</b></p>

<p>The following example demonstrates the concepts discussed above.</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Use of Data Statement</h2>

<p>The <b>data</b> statement can be used for initialising more than one array, or for array section initialisation.</p>

<p>The syntax of data statement is:</p>

<p><b>Example</b></p>

<p>The following example demonstrates the concept:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Use of Where Statement</h2>

<p>The <b>where</b> statement allows you to use some elements of an array in an expression, depending on the outcome of some logical condition. It allows the execution of the expression, on an element, if the given condition is true.</p>

<p><b>Example</b></p>

<p>The following example demonstrates the concept:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
real, dimension (:,:), allocatable :: darray    
</pre>
<p>The rank of the array, i.e., the dimensions has to be mentioned however, to allocate memory to such an array, you use the <b>allocate</b> function.</p>
<pre class="prettyprint notranslate">
allocate ( darray(s1,s2) )      
</pre>
<p>After the array is used, in the program, the memory created should be freed using the <b>deallocate</b> function</p>
<pre class="prettyprint notranslate">
deallocate (darray)  
</pre>
<p><b>Example</b></p>
<p>The following example demonstrates the concepts discussed above.</p>
<pre class="prettyprint notranslate">
program dynamic_array 
implicit none 

   !rank is 2, but size not known   
   real, dimension (:,:), allocatable :: darray    
   integer :: s1, s2     
   integer :: i, j     
   
   print*, "Enter the size of the array:"     
   read*, s1, s2      
   
   ! allocate memory      
   allocate ( darray(s1,s2) )      
   
   do i = 1, s1           
      do j = 1, s2                
         darray(i,j) = i*j               
         print*, "darray(",i,",",j,") = ", darray(i,j)           
      end do      
   end do      
   
   deallocate (darray)  
end program dynamic_array
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Enter the size of the array: 3,4
darray( 1 , 1 ) = 1.00000000    
darray( 1 , 2 ) = 2.00000000    
darray( 1 , 3 ) = 3.00000000    
darray( 1 , 4 ) = 4.00000000    
darray( 2 , 1 ) = 2.00000000    
darray( 2 , 2 ) = 4.00000000    
darray( 2 , 3 ) = 6.00000000    
darray( 2 , 4 ) = 8.00000000    
darray( 3 , 1 ) = 3.00000000    
darray( 3 , 2 ) = 6.00000000    
darray( 3 , 3 ) = 9.00000000    
darray( 3 , 4 ) = 12.0000000   
</pre>
<h2>Use of Data Statement</h2>
<p>The <b>data</b> statement can be used for initialising more than one array, or for array section initialisation.</p>
<p>The syntax of data statement is:</p>
<pre class="prettyprint notranslate">
data variable / list / ...
</pre>
<p><b>Example</b></p>
<p>The following example demonstrates the concept:</p>
<pre class="prettyprint notranslate tryit">
program dataStatement
implicit none

   integer :: a(5), b(3,3), c(10),i, j
   data a /7,8,9,10,11/ 
   
   data b(1,:) /1,1,1/ 
   data b(2,:)/2,2,2/ 
   data b(3,:)/3,3,3/ 
   data (c(i),i=1,10,2) /4,5,6,7,8/ 
   data (c(i),i=2,10,2)/5*2/
   
   Print *, 'The A array:'
   do j = 1, 5                
      print*, a(j)           
   end do 
   
   Print *, 'The B array:'
   do i = lbound(b,1), ubound(b,1)
      write(*,*) (b(i,j), j = lbound(b,2), ubound(b,2))
   end do

   Print *, 'The C array:' 
   do j = 1, 10                
      print*, c(j)           
   end do      
   
end program dataStatement
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
 The A array:
           7
           8
           9
          10
          11
 The B array:
           1           1           1
           2           2           2
           3           3           3
 The C array:
           4
           2
           5
           2
           6
           2
           7
           2
           8
           2
</pre>
<h2>Use of Where Statement</h2>
<p>The <b>where</b> statement allows you to use some elements of an array in an expression, depending on the outcome of some logical condition. It allows the execution of the expression, on an element, if the given condition is true.</p>
<p><b>Example</b></p>
<p>The following example demonstrates the concept:</p>
<pre class="prettyprint notranslate tryit">
program whereStatement
implicit none

   integer :: a(3,5), i , j
   
   do i = 1,3
      do j = 1, 5                
         a(i,j) = j-i          
      end do 
   end do
   
   Print *, 'The A array:'
   
   do i = lbound(a,1), ubound(a,1)
      write(*,*) (a(i,j), j = lbound(a,2), ubound(a,2))
   end do
   
   where( a&lt;0 ) 
      a = 1 
   elsewhere
      a = 5
   end where
  
   Print *, 'The A array:'
   do i = lbound(a,1), ubound(a,1)
      write(*,*) (a(i,j), j = lbound(a,2), ubound(a,2))
   end do   
   
end program whereStatement
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
 The A array:
           0           1           2           3           4
          -1           0           1           2           3
          -2          -1           0           1           2
 The A array:
           5           5           5           5           5
           1           5           5           5           5
           1           1           5           5           5
</pre>

<title>Fortran Derived Data Types</title>

<h1>Fortran - Derived Data Types</h1>

<p>Fortran allows you to define derived data types. A derived data type is also called a structure, and it can consist of data objects of different types.</p>

<p>Derived data types are used to represent a record. E.g. you want to keep track of your books in a library, you might want to track the following attributes about each book:</p>

<h2>Defining a Derived data type</h2>

<p>To define a derived data <b>type</b>, the type and <b>end type</b> statements are used. . The type statement defines a new data type, with more than one member for your program. The format of the type statement is this:</p>

<p>Here is the way you would declare the Book structure:</p>

<h2>Accessing Structure Members</h2>

<p>An object of a derived data type is called a structure</p>

<p>A structure of type Books can be created in a type declaration statement like:</p>

<p>The components of the structure can be accessed using the component selector character (%):</p>

<p><b>Note that there are no spaces before and after the % symbol.</b></p>

<p><b>Example</b></p>

<p>The following program illustrates the above concepts:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Array of Structures</h2>

<p>You can also create arrays of a derived type:</p>

<p>Individual elements of the array could be accessed as:</p>

<p>The following program illustrates the concept:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
type type_name      
   declarations
end type 
</pre>
<p>Here is the way you would declare the Book structure:</p>
<pre class="result notranslate">
type Books
   character(len=50) :: title
   character(len=50) :: author
   character(len=150) :: subject
   integer :: book_id
end type Books
</pre>
<h2>Accessing Structure Members</h2>
<p>An object of a derived data type is called a structure</p>
<p>A structure of type Books can be created in a type declaration statement like:</p>
<pre class="result notranslate">
type(Books) :: book1 
</pre>
<p>The components of the structure can be accessed using the component selector character (%):</p>
<pre class="result notranslate">
book1%title = "C Programming"
book1%author = "Nuha Ali"
book1%subject = "C Programming Tutorial"
book1%book_id = 6495407
</pre>
<p><b>Note that there are no spaces before and after the % symbol.</b></p>
<p><b>Example</b></p>
<p>The following program illustrates the above concepts:</p>
<pre class="prettyprint notranslate tryit">
program deriveDataType

   !type declaration
   type Books
      character(len=50) :: title
      character(len=50) :: author
      character(len=150) :: subject
      integer :: book_id
   end type Books
   
   !declaring type variables
   type(Books) :: book1 
   type(Books) :: book2 
   
   !accessing the components of the structure
   
   book1%title = "C Programming"
   book1%author = "Nuha Ali"
   book1%subject = "C Programming Tutorial"
   book1%book_id = 6495407 
   
   book2%title = "Telecom Billing"
   book2%author = "Zara Ali"
   book2%subject = "Telecom Billing Tutorial"
   book2%book_id = 6495700
  
   !display book info
   
   Print *, book1%title 
   Print *, book1%author 
   Print *, book1%subject 
   Print *, book1%book_id  
   
   Print *, book2%title 
   Print *, book2%author 
   Print *, book2%subject 
   Print *, book2%book_id  

end program deriveDataType
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
 C Programming                                     
 Nuha Ali                                          
 C Programming Tutorial            
     6495407
 Telecom Billing                                   
 Zara Ali                                          
 Telecom Billing Tutorial            
     6495700
</pre>
<h2>Array of Structures</h2>
<p>You can also create arrays of a derived type:</p>
<pre class="result notranslate">
type(Books), dimension(2) :: list
</pre>
<p>Individual elements of the array could be accessed as:</p>
<pre class="result notranslate">
list(1)%title = "C Programming"
list(1)%author = "Nuha Ali"
list(1)%subject = "C Programming Tutorial"
list(1)%book_id = 6495407
</pre>
<p>The following program illustrates the concept:</p>
<pre class="prettyprint notranslate tryit">
program deriveDataType

   !type declaration
   type Books
      character(len=50) :: title
      character(len=50) :: author
      character(len=150) :: subject
      integer :: book_id
   end type Books
   
   !declaring array of books
   type(Books), dimension(2) :: list 
    
   !accessing the components of the structure
   
   list(1)%title = "C Programming"
   list(1)%author = "Nuha Ali"
   list(1)%subject = "C Programming Tutorial"
   list(1)%book_id = 6495407 
   
   list(2)%title = "Telecom Billing"
   list(2)%author = "Zara Ali"
   list(2)%subject = "Telecom Billing Tutorial"
   list(2)%book_id = 6495700
  
   !display book info
   
   Print *, list(1)%title 
   Print *, list(1)%author 
   Print *, list(1)%subject 
   Print *, list(1)%book_id  
   
   Print *, list(1)%title 
   Print *, list(2)%author 
   Print *, list(2)%subject 
   Print *, list(2)%book_id  

end program deriveDataType
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
C Programming                                     
Nuha Ali                                          
C Programming Tutorial               
   6495407
C Programming                                     
Zara Ali                                          
Telecom Billing Tutorial                                      
   6495700
</pre>

<title>Fortran Pointers</title>

<h1>Fortran - Pointers</h1>

<p>In most programming languages, a pointer variable stores the memory address of an object. However, in Fortran, a pointer is a data object that has more functionalities than just storing the memory address. It contains more information about a particular object, like type, rank, extents, and memory address.</p>

<p>A pointer is associated with a target by allocation or pointer assignment.</p>

<h2>Declaring a Pointer Variable</h2>

<p>A pointer variable is declared with the pointer attribute.</p>

<p>The following examples shows declaration of pointer variables:</p>

<p>A pointer can point to:</p>

<h2>Allocating Space for a Pointer</h2>

<p>The <b>allocate</b> statement allows you to allocate space for a pointer object. For example:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>You should empty the allocated storage space by the <b>deallocate</b> statement when it is no longer required and avoid accumulation of unused and unusable memory space.</p>

<h2>Targets and Association</h2>

<p>A target is another normal variable, with space set aside for it. A target variable must be declared with the <b>target</b> attribute.</p>

<p>You associate a pointer variable with a target variable using the association operator (=>).</p>

<p>Let us rewrite the previous example, to demonstrate the concept:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>A pointer can be:</p>

<p>In the above program, we have <b>associated</b> the pointer p1, with the target t1, using the => operator. The function associated, tests a pointer’s association status.</p>

<p>The <b>nullify</b> statement disassociates a pointer from a target.</p>

<p>Nullify does not empty the targets as there could be more than one pointer pointing to the same target. However, emptying the pointer implies nullification also.</p>

<p><b>Example 1</b></p>

<p>The following example demonstrates the concepts:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>Please note that each time you run the code, the memory addresses will be different.</p>

<p><b>Example 2</b></p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
integer, pointer :: p1 ! pointer to integer  
real, pointer, dimension (:) :: pra ! pointer to 1-dim real array  
real, pointer, dimension (:,:) :: pra2 ! pointer to 2-dim real array
</pre>
<p>A pointer can point to:</p>
<ul class="list">
<li>an area of dynamically allocated memory</li>
<li>a data object of the same type as the pointer, with the <b>target</b> attribute</li>
</ul>
<h2>Allocating Space for a Pointer</h2>
<p>The <b>allocate</b> statement allows you to allocate space for a pointer object. For example:</p>
<pre class="prettyprint notranslate tryit">
program pointerExample
implicit none

   integer, pointer :: p1
   allocate(p1)
   
   p1 = 1
   Print *, p1
   
   p1 = p1 + 4
   Print *, p1
   
end program pointerExample
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
1
5
</pre>
<p>You should empty the allocated storage space by the <b>deallocate</b> statement when it is no longer required and avoid accumulation of unused and unusable memory space.</p>
<h2>Targets and Association</h2>
<p>A target is another normal variable, with space set aside for it. A target variable must be declared with the <b>target</b> attribute.</p>
<p>You associate a pointer variable with a target variable using the association operator (=>).</p>
<p>Let us rewrite the previous example, to demonstrate the concept:</p>
<pre class="prettyprint notranslate tryit">
program pointerExample
implicit none

   integer, pointer :: p1
   integer, target :: t1 
   
   p1=>t1
   p1 = 1
   
   Print *, p1
   Print *, t1
   
   p1 = p1 + 4
   
   Print *, p1
   Print *, t1
   
   t1 = 8
   
   Print *, p1
   Print *, t1
   
end program pointerExample
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
1
1
5
5
8
8
</pre>
<p>A pointer can be:</p>
<ul class="list">
<li>Undefined</li>
<li>Associated</li>
<li>Disassociated</li>
</ul>
<p>In the above program, we have <b>associated</b> the pointer p1, with the target t1, using the => operator. The function associated, tests a pointer’s association status.</p>
<p>The <b>nullify</b> statement disassociates a pointer from a target.</p>
<p>Nullify does not empty the targets as there could be more than one pointer pointing to the same target. However, emptying the pointer implies nullification also.</p>
<p><b>Example 1</b></p>
<p>The following example demonstrates the concepts:</p>
<pre class="prettyprint notranslate tryit">
program pointerExample
implicit none

   integer, pointer :: p1
   integer, target :: t1 
   integer, target :: t2
   
   p1=>t1
   p1 = 1
   
   Print *, p1
   Print *, t1
   
   p1 = p1 + 4
   Print *, p1
   Print *, t1
   
   t1 = 8
   Print *, p1
   Print *, t1
   
   nullify(p1)
   Print *, t1
   
   p1=>t2
   Print *, associated(p1)
   Print*, associated(p1, t1)
   Print*, associated(p1, t2)
   
   !what is the value of p1 at present
   Print *, p1
   Print *, t2
   
   p1 = 10
   Print *, p1
   Print *, t2
   
end program pointerExample
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
1
1
5
5
8
8
8
T
F
T
952754640
952754640
10
10
</pre>
<p>Please note that each time you run the code, the memory addresses will be different.</p>
<p><b>Example 2</b></p>
<pre class="prettyprint notranslate tryit">
program pointerExample
implicit none

   integer, pointer :: a, b
   integer, target :: t
   integer :: n
   
   t= 1
   a=>t
   t = 2
   b => t
   n = a + b
   
   Print *, a, b, t, n 
   
end program pointerExample
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
2  2  2  4
</pre>

<title>Fortran Basic Input Output</title>

<h1>Fortran - Basic Input Output</h1>

<p>We have so far seen that we can read data from keyboard using the <b>read *</b> statement, and display output to the screen using the <b>print*</b> statement, respectively. This form of input-output is <b>free format</b> I/O, and it is called <b>list-directed</b> input-output.</p>

<p>The free format simple I/O has the form:</p>

<p>However the formatted I/O gives you more flexibility over data transfer.</p>

<h2>Formatted Input Output</h2>

<p>Formatted input output has the syntax as follows:</p>

<p>Where,</p>

<p>fmt is the format specification</p>

<p>variable-list is a list of the variables to be read from keyboard or written on screen</p>

<p>Format specification defines the way in which formatted data is displayed. It consists of a string, containing a list of <b>edit descriptors</b> in parentheses.</p>

<p>An <b>edit descriptor</b> specifies the exact format, for example, width, digits after decimal point etc., in which characters and numbers are displayed.</p>

<p><b>For example:</b></p>

<p>The following table describes the descriptors:</p>

<p>This is used for real output in exponential notation. The ‘E’ descriptor statement takes the form ‘rEw.d’ where the meanings of r, w and d are given in the table below. Real values are right justiﬁed in their ﬁelds. If the ﬁeld width is not large enough to accommodate the real number then the ﬁeld is ﬁlled with asterisks.</p>

<p>Please note that, to print out a real number with three decimal places a ﬁeld width of at least ten is needed. One for the sign of the mantissa, two for the zero, four for the mantissa and two for the exponent itself. In general, w ≥ d + 7.</p>

<p>Following symbols are used with the format descriptors:</p>

<p><b>Example 1</b></p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p><b>Example 2</b></p>

<p>When the above code is compiled and executed, it produces the following result: (assume the user enters the name Zara)</p>

<p><b>Example 3</b></p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>The Format Statement</h2>

<p>The format statement allows you to mix and match character, integer and real output in one statement. The following example demonstrates this:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
read(*,*) item1, item2, item3...
print *, item1, item2, item3
write(*,*) item1, item2, item3...
</pre>
<p>However the formatted I/O gives you more flexibility over data transfer.</p>
<h2>Formatted Input Output</h2>
<p>Formatted input output has the syntax as follows:</p>
<pre class="result notranslate">
read fmt, variable_list 
print fmt, variable_list 
write fmt, variable_list 
</pre>
<p>Where,</p>
<ul class="list">
<li><p>fmt is the format specification</p></li>
<li><p>variable-list is a list of the variables to be read from keyboard or written on screen</p></li>
</ul>
<p>Format specification defines the way in which formatted data is displayed. It consists of a string, containing a list of <b>edit descriptors</b> in parentheses.</p>
<p>An <b>edit descriptor</b> specifies the exact format, for example, width, digits after decimal point etc., in which characters and numbers are displayed.</p>
<p><b>For example:</b></p>
<pre class="result notranslate">
Print "(f6.3)", pi
</pre>
<p>The following table describes the descriptors:</p>
<table class="table table-bordered">
<tr>
<th>Descriptor</th>
<th>Description</th>
<th>Example</th>
</tr>
<tr>
<td>I</td>
<td>This is used for integer output. This takes the form ‘rIw.m’ where the meanings of r, w and m are given in the table below. Integer values are right justiﬁed in their ﬁelds. If the ﬁeld width is not large enough to accommodate an integer then the ﬁeld is ﬁlled with asterisks.</td>
<td>print "(3i5)", i, j, k</td>
</tr>
<tr>
<td>F</td>
<td>This is used for real number output. This takes the form ‘rFw.d’ where the meanings of r, w and d are given in the table below. Real values are right justiﬁed in their ﬁelds. If the ﬁeld width is not large enough to accommodate the real number then the ﬁeld is ﬁlled with asterisks.</td>
<td>print "(f12.3)",pi</td>
</tr>
<tr>
<td>E</td>
<td><p>This is used for real output in exponential notation. The ‘E’ descriptor statement takes the form ‘rEw.d’ where the meanings of r, w and d are given in the table below. Real values are right justiﬁed in their ﬁelds. If the ﬁeld width is not large enough to accommodate the real number then the ﬁeld is ﬁlled with asterisks.</p>
<p>Please note that, to print out a real number with three decimal places a ﬁeld width of at least ten is needed. One for the sign of the mantissa, two for the zero, four for the mantissa and two for the exponent itself. In general, w ≥ d + 7.</p></td>
<td>print "(e10.3)",123456.0 gives ‘0.123e+06’</td>
</tr>
<tr>
<td>ES</td>
<td>This is used for real output (scientific notation). This takes the form ‘rESw.d’ where the meanings of r, w and d are given in the table below. The ‘E’ descriptor described above diﬀers slightly from the traditional well known ‘scientiﬁc notation’. Scientiﬁc notation has the mantissa in the range 1.0 to 10.0 unlike the E descriptor which has the mantissa in the range 0.1 to 1.0. Real values are right justiﬁed in their ﬁelds. If the ﬁeld width is not large enough to accommodate the real number then the ﬁeld is ﬁlled with asterisks. Here also, the width ﬁeld must satisfy the expression
w ≥ d + 7</td>
<td>print "(es10.3)",123456.0 gives ‘1.235e+05’</td>
</tr>
<tr>
<td>A</td>
<td>This is used for character output. This takes the form ‘rAw’ where the meanings of r and w are given in the table below. Character types are right justiﬁed in their ﬁelds. If the ﬁeld width is not large enough to accommodate the character string then the ﬁeld is ﬁlled with the ﬁrst ‘w’ characters of the string.</td>
<td>print "(a10)", str</td>
</tr>
<tr>
<td>X</td>
<td>This is used for space output. This takes the form ‘nX’ where ‘n’ is the number of desired spaces.</td>
<td>print "(5x, a10)", str</td>
</tr>
<tr>
<td>/</td>
<td>Slash descriptor – used to insert blank lines. This takes the form ‘/’ and forces the next data output to be on a new line.</td>
<td style="width:30%;">print "(/,5x, a10)", str</td>
</tr>
</table>
<p>Following symbols are used with the format descriptors:</p>
<table class="table table-bordered">
<tr>
<th>Symbol</th>
<th>Description</th>
</tr>
<tr>
<td>c</td>
<td>Column number</td>
</tr>
<tr>
<td>d</td>
<td>Number of digits to right of the decimal place for real input or output</td>
</tr>
<tr>
<td>m</td>
<td>Minimum number of digits to be displayed</td>
</tr>
<tr>
<td>n</td>
<td>Number of spaces to skip</td>
</tr>
<tr>
<td>r</td>
<td>Repeat count – the number of times to use a descriptor or group of descriptors</td>
</tr>
<tr>
<td>w</td>
<td>Field width – the number of characters to use for the input or output</td>
</tr>
</table>
<p><b>Example 1</b></p>
<pre class="prettyprint notranslate tryit">
program printPi

   pi = 3.141592653589793238 
   
   Print "(f6.3)", pi 
   Print "(f10.7)", pi
   Print "(f20.15)", pi 
   Print "(e16.4)", pi/100 
   
end program printPi
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
3.142
3.1415927
3.141592741012573
0.3142E-01
</pre>
<p><b>Example 2</b></p>
<pre class="prettyprint notranslate tryit">
program printName
implicit none

   character (len=15) :: first_name
   print *,' Enter your first name.' 
   print *,' Up to 20 characters, please'
   
   read *,first_name 
   print "(1x,a)",first_name
   
end program printName
</pre>
<p>When the above code is compiled and executed, it produces the following result: (assume the user enters the name Zara)</p>
<pre class="result notranslate">
Enter your first name.
Up to 20 characters, please
Zara 
</pre>
<p><b>Example 3</b></p>
<pre class="prettyprint notranslate tryit">
program formattedPrint
implicit none

   real :: c = 1.2786456e-9, d = 0.1234567e3 
   integer :: n = 300789, k = 45, i = 2
   character (len=15) :: str="Tutorials Point"
   
   print "(i6)", k 
   print "(i6.3)", k 
   print "(3i10)", n, k, i 
   print "(i10,i3,i5)", n, k, i 
   print "(a15)",str 
   print "(f12.3)", d
   print "(e12.4)", c 
   print '(/,3x,"n = ",i6, 3x, "d = ",f7.4)', n, d
   
end program formattedPrint
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
45
045
300789 45  2
300789 45  2
Tutorials Point
123.457
0.1279E-08

n = 300789 d = *******
</pre>
<h2>The Format Statement</h2>
<p>The format statement allows you to mix and match character, integer and real output in one statement. The following example demonstrates this:</p>
<pre class="prettyprint notranslate tryit">
program productDetails 
implicit none 

   character (len=15) :: name
   integer :: id 
   real :: weight
   name = 'Ardupilot'
   id = 1
   weight = 0.08
   
   print *,' The product details are' 
   
   print 100
   100 format (7x,'Name:', 7x, 'Id:', 1x, 'Weight:')
   
   print 200, name, id, weight 
   200 format(1x, a, 2x, i3, 2x, f5.2) 
   
end program productDetails
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
The product details are
Name:       Id:    Weight:
Ardupilot   1       0.08
</pre>

<title>Fortran File Input Output</title>

<h1>Fortran - File Input Output</h1>

<p>Fortran allows you to read data from, and write data into files.</p>

<p>In the last chapter, you have seen how to read data from, and write data to the terminal. In this chapter you will study file input and output functionalities provided by Fortran.</p>

<p>You can read and write to one or more files. The OPEN, WRITE, READ and CLOSE statements allow you to achieve this.</p>

<h2>Opening and Closing Files</h2>

<p>Before using a file you must open the file. The <b>open</b> command is used to open files for reading or writing. The simplest form of the command is:</p>

<p>However, the open statement may have a general form:</p>

<p>The following table describes the most commonly used specifiers:</p>

<p>After the file has been opened, it is accessed by read and write statements. Once done, it should be closed using the <b>close</b> statement.</p>

<p>The close statement has the following syntax:</p>

<p>Please note that the parameters in brackets are optional.</p>

<p><b>Example</b></p>

<p>This example demonstrates opening a new file for writing some data into the file.</p>

<p>When the above code is compiled and executed, it creates the file data1.dat and writes the x and y array values into it. And then closes the file.</p>

<p><b>Reading from and Writing into the File</b></p>

<p>The read and write statements respectively are used for reading from and writing into a file respectively.</p>

<p>They have the following syntax:</p>

<p>Most of the specifiers have already been discussed in the above table.</p>

<p>The END=s specifier is a statement label where the program jumps, when it reaches end-of-file.</p>

<p><b>Example</b></p>

<p>This example demonstrates reading from and writing into a file.</p>

<p>In this program we read from the file, we created in the last example, data1.dat, and display it on screen.</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
open (unit = number, file = "name").
</pre>
<p>However, the open statement may have a general form:</p>
<pre class="result notranslate">
open (list-of-specifiers)
</pre>
<p>The following table describes the most commonly used specifiers:</p>
<table class="table table-bordered">
<tr>
<th style width="20%">Specifier</th>
<th>Description</th>
</tr>
<tr>
<td>[UNIT=] u</td>
<td>The unit number u could be any number in the range 9-99 and it indicates the file, you may choose any number but every open file in the program must have a unique number</td>
</tr>
<tr>
<td>IOSTAT= ios</td>
<td>It is the I/O status identifier and should be an integer variable. If the open statement is successful then the ios value returned is zero else a non-zero value.</td>
</tr>
<tr>
<td>ERR = err</td>
<td>It is a label to which the control jumps in case of any error.</td>
</tr>
<tr>
<td>FILE = fname</td>
<td>File name, a character string.</td>
</tr>
<tr>
<td>STATUS = sta</td>
<td>It shows the prior status of the file. A character string and can have one of the three values NEW, OLD or SCRATCH. A scratch file is created and deleted when closed or the program ends.</td>
</tr>
<tr>
<td>ACCESS = acc</td>
<td>It is the file access mode. Can have either of the two values, SEQUENTIAL or DIRECT. The default is SEQUENTIAL.</td>
</tr>
<tr>
<td>FORM=    frm</td>
<td>It gives the formatting status of the file. Can have either of the two values FORMATTED or UNFORMATTED. The default is UNFORMATTED</td>
</tr>
<tr>
<td>RECL = rl</td>
<td>It specifies the length of each record in a direct access file.</td>
</tr>
</table>
<p>After the file has been opened, it is accessed by read and write statements. Once done, it should be closed using the <b>close</b> statement.</p>
<p>The close statement has the following syntax:</p>
<pre class="result notranslate">
close ([UNIT=]u[,IOSTAT=ios,ERR=err,STATUS=sta])
</pre>
<p>Please note that the parameters in brackets are optional.</p>
<p><b>Example</b></p>
<p>This example demonstrates opening a new file for writing some data into the file.</p>
<pre class="prettyprint notranslate">
program outputdata   
implicit none

   real, dimension(100) :: x, y  
   real, dimension(100) :: p, q
   integer :: i  
   
   ! data  
   do i=1,100  
      x(i) = i * 0.1 
      y(i) = sin(x(i)) * (1-cos(x(i)/3.0))  
   end do  
   
   ! output data into a file 
   open(1, file='data1.dat', status='new')  
   do i=1,100  
      write(1,*) x(i), y(i)   
   end do  
   
   close(1) 
   
end program outputdata
</pre>
<p>When the above code is compiled and executed, it creates the file data1.dat and writes the x and y array values into it. And then closes the file.</p>
<p><b>Reading from and Writing into the File</b></p>
<p>The read and write statements respectively are used for reading from and writing into a file respectively.</p>
<p>They have the following syntax:</p>
<pre class="result notranslate">
read ([UNIT=]u, [FMT=]fmt, IOSTAT=ios, ERR=err, END=s)
write([UNIT=]u, [FMT=]fmt, IOSTAT=ios, ERR=err, END=s)
</pre>
<p>Most of the specifiers have already been discussed in the above table.</p>
<p>The END=s specifier is a statement label where the program jumps, when it reaches end-of-file.</p>
<p><b>Example</b></p>
<p>This example demonstrates reading from and writing into a file.</p>
<p>In this program we read from the file, we created in the last example, data1.dat, and display it on screen.</p>
<pre class="prettyprint notranslate tryit">
program outputdata   
implicit none   

   real, dimension(100) :: x, y  
   real, dimension(100) :: p, q
   integer :: i  
   
   ! data  
   do i=1,100  
      x(i) = i * 0.1 
      y(i) = sin(x(i)) * (1-cos(x(i)/3.0))  
   end do  
   
   ! output data into a file 
   open(1, file='data1.dat', status='new')  
   do i=1,100  
      write(1,*) x(i), y(i)   
   end do  
   close(1) 

   ! opening the file for reading
   open (2, file='data1.dat', status='old')

   do i=1,100  
      read(2,*) p(i), q(i)
   end do 
   
   close(2)
   
   do i=1,100  
      write(*,*) p(i), q(i)
   end do 
   
end program outputdata
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
0.100000001  5.54589933E-05
0.200000003  4.41325130E-04
0.300000012  1.47636665E-03
0.400000006  3.45637114E-03
0.500000000  6.64328877E-03
0.600000024  1.12552457E-02
0.699999988  1.74576249E-02
0.800000012  2.53552198E-02
0.900000036  3.49861123E-02
1.00000000   4.63171229E-02
1.10000002   5.92407547E-02
1.20000005   7.35742599E-02
1.30000007   8.90605897E-02
1.39999998   0.105371222    
1.50000000   0.122110792    
1.60000002   0.138823599    
1.70000005   0.155002072    
1.80000007   0.170096487    
1.89999998   0.183526158    
2.00000000   0.194692180    
2.10000014   0.202990443    
2.20000005   0.207826138    
2.29999995   0.208628103    
2.40000010   0.204863414    
2.50000000   0.196052119    
2.60000014   0.181780845    
2.70000005   0.161716297    
2.79999995   0.135617107    
2.90000010   0.103344671    
3.00000000   6.48725405E-02
3.10000014   2.02930309E-02
3.20000005  -3.01767997E-02
3.29999995  -8.61928314E-02
3.40000010  -0.147283033    
3.50000000  -0.212848678    
3.60000014  -0.282169819    
3.70000005  -0.354410470    
3.79999995  -0.428629100    
3.90000010  -0.503789663    
4.00000000  -0.578774154    
4.09999990  -0.652400017    
4.20000029  -0.723436713    
4.30000019  -0.790623367    
4.40000010  -0.852691114    
4.50000000  -0.908382416    
4.59999990  -0.956472993    
4.70000029  -0.995793998    
4.80000019  -1.02525222    
4.90000010  -1.04385209    
5.00000000  -1.05071592    
5.09999990  -1.04510069    
5.20000029  -1.02641726    
5.30000019  -0.994243503    
5.40000010  -0.948338211    
5.50000000  -0.888650239    
5.59999990  -0.815326691    
5.70000029  -0.728716135    
5.80000019  -0.629372001    
5.90000010  -0.518047631    
6.00000000  -0.395693362    
6.09999990  -0.263447165    
6.20000029  -0.122622721    
6.30000019   2.53026206E-02
6.40000010   0.178709000    
6.50000000   0.335851669    
6.59999990   0.494883657    
6.70000029   0.653881252    
6.80000019   0.810866773    
6.90000010   0.963840425    
7.00000000   1.11080539    
7.09999990   1.24979746    
7.20000029   1.37891412    
7.30000019   1.49633956    
7.40000010   1.60037732    
7.50000000   1.68947268    
7.59999990   1.76223695    
7.70000029   1.81747139    
7.80000019   1.85418403    
7.90000010   1.87160957    
8.00000000   1.86922085    
8.10000038   1.84674001    
8.19999981   1.80414569    
8.30000019   1.74167395    
8.40000057   1.65982044    
8.50000000   1.55933595    
8.60000038   1.44121361    
8.69999981   1.30668485    
8.80000019   1.15719533    
8.90000057   0.994394958    
9.00000000   0.820112705    
9.10000038   0.636327863    
9.19999981   0.445154816    
9.30000019   0.248800844    
9.40000057   4.95488606E-02
9.50000000  -0.150278628    
9.60000038  -0.348357052    
9.69999981  -0.542378068    
9.80000019  -0.730095863    
9.90000057  -0.909344316    
10.0000000  -1.07807255    
</pre>

<title>Fortran Procedures</title>

<h1>Fortran - Procedures</h1>

<p>A <b>procedure</b> is a group of statements that perform a well-defined task and can be invoked from your program. Information (or data) is passed to the calling program, to the procedure as arguments.</p>

<p>There are two types of procedures:</p>

<h2>Function</h2>

<p>A function is a procedure that returns a single quantity. A function should not modify its arguments.</p>

<p>The returned quantity is known as <b>function value</b>, and it is denoted by the function name.</p>

<p><b>Syntax:</b></p>

<p>Syntax for a function is as follows:</p>

<p>The following example demonstrates a function named area_of_circle. It calculates the area of a circle with radius r.</p>

<p>When you compile and execute the above program, it produces the following result:</p>

<p>Please note that:</p>

<p>You must specify <b>implicit none</b> in both the main program as well as the procedure.</p>

<p>The argument r in the called function is called <b>dummy argument</b>.</p>

<p><b>The result Option</b></p>

<p>If you want the returned value to be stored in some other name than the function name, you can use the <b>result</b> option.</p>

<p>You can specify the return variable name as:</p>

<h2>Subroutine</h2>

<p>A subroutine does not return a value, however it can modify its arguments.</p>

<p><b>Syntax</b></p>

<p><b>Calling a Subroutine</b></p>

<p>You need to invoke a subroutine using the <b>call</b> statement.</p>

<p>The following example demonstrates the definition and use of a subroutine swap, that changes the values of its arguments.</p>

<p>When you compile and execute the above program, it produces the following result:</p>

<h2>Specifying the Intent of the Arguments</h2>

<p>The intent attribute allows you to specify the intention with which arguments are used in the procedure. The following table provides the values of the intent attribute: </p>

<p>The following example demonstrates the concept:</p>

<p>When you compile and execute the above program, it produces the following result:</p>

<h2>Recursive Procedures</h2>

<p>Recursion occurs when a programming languages allows you to call a function inside the same function. It is called recursive call of the function.</p>

<p>When a procedure calls itself, directly or indirectly, is called a recursive procedure. You should declare this type of procedures by preceding the word <b>recursive</b> before its declaration.</p>

<p>When a function is used recursively, the <b>result</b> option has to be used.</p>

<p>Following is an example, which calculates factorial for a given number using a recursive procedure:</p>

<h2>Internal Procedures</h2>

<p>When a procedure is contained within a program, it is called the internal procedure of the program. The syntax for containing an internal procedure is as follows:</p>

<p>The following example demonstrates the concept:</p>

<p>When you compile and execute the above program, it produces the following result:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
function name(arg1, arg2, ....)  
   [declarations, including those for the arguments]   
   [executable statements] 
end function [name]
</pre>
<p>The following example demonstrates a function named area_of_circle. It calculates the area of a circle with radius r.</p>
<pre class="prettyprint notranslate tryit">
program calling_func

   real :: a
   a = area_of_circle(2.0) 
   
   Print *, "The area of a circle with radius 2.0 is"
   Print *, a
   
end program calling_func


! this function computes the area of a circle with radius r  
function area_of_circle (r)  

! function result     
implicit none      

   ! dummy arguments        
   real :: area_of_circle   
   
   ! local variables 
   real :: r     
   real :: pi
   
   pi = 4 * atan (1.0)     
   area_of_circle = pi * r**2  
   
end function area_of_circle
</pre>
<p>When you compile and execute the above program, it produces the following result:</p>
<pre class="result notranslate">
The area of a circle with radius 2.0 is
   12.5663710   
</pre>
<p>Please note that:</p>
<ul class="list">
<li><p>You must specify <b>implicit none</b> in both the main program as well as the procedure.</p></li>
<li><p>The argument r in the called function is called <b>dummy argument</b>.</p></li>
</ul>
<p><b>The result Option</b></p>
<p>If you want the returned value to be stored in some other name than the function name, you can use the <b>result</b> option.</p>
<p>You can specify the return variable name as:</p>
<pre class="result notranslate">
function name(arg1, arg2, ....) result (return_var_name)  
   [declarations, including those for the arguments]   
   [executable statements] 
end function [name]
</pre>
<h2>Subroutine</h2>
<p>A subroutine does not return a value, however it can modify its arguments.</p>
<p><b>Syntax</b></p>
<pre class="result notranslate">
subroutine name(arg1, arg2, ....)    
   [declarations, including those for the arguments]    
   [executable statements]  
end subroutine [name]
</pre>
<p><b>Calling a Subroutine</b></p>
<p>You need to invoke a subroutine using the <b>call</b> statement.</p>
<p>The following example demonstrates the definition and use of a subroutine swap, that changes the values of its arguments.</p>
<pre class="prettyprint notranslate tryit">
program calling_func
implicit none

   real :: a, b
   a = 2.0
   b = 3.0
   
   Print *, "Before calling swap"
   Print *, "a = ", a
   Print *, "b = ", b
   
   call swap(a, b)
   
   Print *, "After calling swap"
   Print *, "a = ", a
   Print *, "b = ", b
   
end program calling_func


subroutine swap(x, y) 
implicit none

   real :: x, y, temp   
   
   temp = x  
   x = y 
   y = temp  
   
end subroutine swap
</pre>
<p>When you compile and execute the above program, it produces the following result:</p>
<pre class="result notranslate">
Before calling swap
a = 2.00000000    
b = 3.00000000    
After calling swap
a = 3.00000000    
b = 2.00000000   
</pre>
<h2>Specifying the Intent of the Arguments</h2>
<p>The intent attribute allows you to specify the intention with which arguments are used in the procedure. The following table provides the values of the intent attribute: </p>
<table class="table table-bordered">
<tr>
<th>Value</th>
<th>Used as</th>
<th>Explanation</th>
</tr>
<tr>
<td>in</td>
<td>intent(in)</td>
<td>Used as input values, not changed in the function</td>
</tr>
<tr>
<td>out</td>
<td>intent(out)</td>
<td>Used as output value, they are overwritten</td>
</tr>
<tr>
<td>inout</td>
<td>intent(inout)</td>
<td>Arguments are both used and overwritten</td>
</tr>
</table>
<p>The following example demonstrates the concept:</p>
<pre class="prettyprint notranslate tryit">
program calling_func
implicit none

   real :: x, y, z, disc
   
   x= 1.0
   y = 5.0
   z = 2.0
   
   call intent_example(x, y, z, disc)
   
   Print *, "The value of the discriminant is"
   Print *, disc
   
end program calling_func


subroutine intent_example (a, b, c, d)     
implicit none     

   ! dummy arguments      
   real, intent (in) :: a     
   real, intent (in) :: b      
   real, intent (in) :: c    
   real, intent (out) :: d   
   
   d = b * b - 4.0 * a * c 
   
end subroutine intent_example
</pre>
<p>When you compile and execute the above program, it produces the following result:</p>
<pre class="result notranslate">
The value of the discriminant is
   17.0000000    
</pre>
<h2>Recursive Procedures</h2>
<p>Recursion occurs when a programming languages allows you to call a function inside the same function. It is called recursive call of the function.</p>
<p>When a procedure calls itself, directly or indirectly, is called a recursive procedure. You should declare this type of procedures by preceding the word <b>recursive</b> before its declaration.</p>
<p>When a function is used recursively, the <b>result</b> option has to be used.</p>
<p>Following is an example, which calculates factorial for a given number using a recursive procedure:</p>
<pre class="prettyprint notranslate">
program calling_func
implicit none

   integer :: i, f
   i = 15
   
   Print *, "The value of factorial 15 is"
   f = myfactorial(15)
   Print *, f
   
end program calling_func

! computes the factorial of n (n!)      
recursive function myfactorial (n) result (fac)  
! function result     
implicit none     

   ! dummy arguments     
   integer :: fac     
   integer, intent (in) :: n     
   
   select case (n)         
      case (0:1)         
         fac = 1         
      case default    
         fac = n * myfactorial (n-1)  
   end select 
   
end function myfactorial
</pre>
<h2>Internal Procedures</h2>
<p>When a procedure is contained within a program, it is called the internal procedure of the program. The syntax for containing an internal procedure is as follows:</p>
<pre class="result notranslate">
program program_name     
   implicit none         
   ! type declaration statements         
   ! executable statements    
   . . .     
   contains         
   ! internal procedures      
   . . .  
end program program_name
</pre>
<p>The following example demonstrates the concept:</p>
<pre class="prettyprint notranslate tryit">
program mainprog  
implicit none 

   real :: a, b 
   a = 2.0
   b = 3.0
   
   Print *, "Before calling swap"
   Print *, "a = ", a
   Print *, "b = ", b
   
   call swap(a, b)
   
   Print *, "After calling swap"
   Print *, "a = ", a
   Print *, "b = ", b
 
contains   
   subroutine swap(x, y)     
      real :: x, y, temp      
      temp = x 
      x = y  
      y = temp   
   end subroutine swap 
   
end program mainprog   
</pre>
<p>When you compile and execute the above program, it produces the following result:</p>
<pre class="result notranslate">
Before calling swap
a = 2.00000000    
b = 3.00000000    
After calling swap
a = 3.00000000    
b = 2.00000000   
</pre>

<title>Fortran Modules</title>

<h1>Fortran - Modules</h1>

<p>A module is like a package where you can keep your functions and subroutines, in case you are writing a very big program, or your functions or subroutines can be used in more than one program.</p>

<p>Modules provide you a way of splitting your programs between multiple files.</p>

<p>Modules are used for:</p>

<h3>Syntax of a Module</h3>

<p>A module consists of two parts:</p>

<p>The general form of a module is:</p>

<h2>Using a Module into your Program</h2>

<p>You can incorporate a module in a program or subroutine by the use statement:</p>

<p>Please note that</p>

<p>You can add as many modules as needed, each will be in separate files and compiled separately.</p>

<p>A module can be used in various different programs.</p>

<p>A module can be used many times in the same program.</p>

<p>The variables declared in a module specification part, are global to the module.</p>

<p>The variables declared in a module become global variables in any program or routine where the module is used.</p>

<p>The use statement can appear in the main program, or any other subroutine or module which uses the routines or variables declared in a particular module.</p>

<p><b>Example</b></p>

<p>The following example demonstrates the concept:</p>

<p>When you compile and execute the above program, it produces the following result:</p>

<h2>Accessibility of Variables and Subroutines in a Module</h2>

<p>By default, all the variables and subroutines in a module is made available to the program that is using the module code, by the <b>use</b> statement.</p>

<p>However, you can control the accessibility of module code using the <b>private</b> and <b>public</b> attributes. When you declare some variable or subroutine as private, it is not available outside the module.</p>

<p><b>Example</b></p>

<p>The following example illustrates the concept:</p>

<p>In the previous example, we had two module variables, <b>e</b> and <b>pi.</b> Let us make them private and observe the output:</p>

<p>When you compile and execute the above program, it gives the following error message:</p>

<p>Since <b>e</b> and <b>pi,</b> both are declared private, the program module_example cannot access these variables anymore.</p>

<p>However, other module subroutines can access them:</p>

<p>When you compile and execute the above program, it produces the following result:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
module name     
   [statement declarations]  
   [contains [subroutine and function definitions] ] 
end module [name]
</pre>
<h2>Using a Module into your Program</h2>
<p>You can incorporate a module in a program or subroutine by the use statement:</p>
<pre class="result notranslate">
use name  
</pre>
<p>Please note that</p>
<ul class="list">
<li><p>You can add as many modules as needed, each will be in separate files and compiled separately.</p></li>  
<li><p>A module can be used in various different programs.</p></li> 
<li><p>A module can be used many times in the same program.</p></li>   
<li><p>The variables declared in a module specification part, are global to the module.</p></li>  
<li><p>The variables declared in a module become global variables in any program or routine where the module is used.</p></li> 
<li><p>The use statement can appear in the main program, or any other subroutine or module which uses the routines or variables declared in a particular module.</p></li> 
</ul>
<p><b>Example</b></p>
<p>The following example demonstrates the concept:</p>
<pre class="prettyprint notranslate tryit">
module constants  
implicit none 

   real, parameter :: pi = 3.1415926536  
   real, parameter :: e = 2.7182818285 
   
contains      
   subroutine show_consts()          
      print*, "Pi = ", pi          
      print*,  "e = ", e     
   end subroutine show_consts 
   
end module constants 


program module_example     
use constants      
implicit none     

   real :: x, ePowerx, area, radius 
   x = 2.0
   radius = 7.0
   ePowerx = e ** x
   area = pi * radius**2     
   
   call show_consts() 
   
   print*, "e raised to the power of 2.0 = ", ePowerx
   print*, "Area of a circle with radius 7.0 = ", area  
   
end program module_example
</pre>
<p>When you compile and execute the above program, it produces the following result:</p>
<pre class="result notranslate">
Pi = 3.14159274    
e =  2.71828175    
e raised to the power of 2.0 = 7.38905573    
Area of a circle with radius 7.0 = 153.938049   
</pre>
<h2>Accessibility of Variables and Subroutines in a Module</h2>
<p>By default, all the variables and subroutines in a module is made available to the program that is using the module code, by the <b>use</b> statement.</p>
<p>However, you can control the accessibility of module code using the <b>private</b> and <b>public</b> attributes. When you declare some variable or subroutine as private, it is not available outside the module.</p>
<p><b>Example</b></p>
<p>The following example illustrates the concept:</p>
<p>In the previous example, we had two module variables, <b>e</b> and <b>pi.</b> Let us make them private and observe the output:</p>
<pre class="prettyprint notranslate">
module constants  
implicit none 

   real, parameter,private :: pi = 3.1415926536  
   real, parameter, private :: e = 2.7182818285 
   
contains      
   subroutine show_consts()          
      print*, "Pi = ", pi          
      print*, "e = ", e     
   end subroutine show_consts 
   
end module constants 


program module_example     
use constants      
implicit none     

   real :: x, ePowerx, area, radius 
   x = 2.0
   radius = 7.0
   ePowerx = e ** x
   area = pi * radius**2     
   
   call show_consts() 
   
   print*, "e raised to the power of 2.0 = ", ePowerx
   print*, "Area of a circle with radius 7.0 = ", area  
   
end program module_example
</pre>
<p>When you compile and execute the above program, it gives the following error message:</p>
<pre class="result notranslate">
   ePowerx = e ** x
   1
Error: Symbol 'e' at (1) has no IMPLICIT type
main.f95:19.13:

   area = pi * radius**2     
   1
Error: Symbol 'pi' at (1) has no IMPLICIT type
</pre>
<p>Since <b>e</b> and <b>pi,</b> both are declared private, the program module_example cannot access these variables anymore.</p>
<p>However, other module subroutines can access them:</p>
<pre class="prettyprint notranslate tryit">
module constants  
implicit none 

   real, parameter,private :: pi = 3.1415926536  
   real, parameter, private :: e = 2.7182818285 
   
contains      
   subroutine show_consts()          
      print*, "Pi = ", pi          
      print*, "e = ", e     
   end subroutine show_consts 
   
   function ePowerx(x)result(ePx) 
   implicit none
      real::x
      real::ePx
      ePx = e ** x
   end function ePowerx
    
   function areaCircle(r)result(a)  
   implicit none
      real::r
      real::a
      a = pi * r**2  
   end function areaCircle
    
end module constants 


program module_example     
use constants      
implicit none     

   call show_consts() 
   
   Print*, "e raised to the power of 2.0 = ", ePowerx(2.0)
   print*, "Area of a circle with radius 7.0 = ", areaCircle(7.0)  
   
end program module_example
</pre>
<p>When you compile and execute the above program, it produces the following result:</p>
<pre class="result notranslate">
Pi = 3.14159274    
e = 2.71828175    
e raised to the power of 2.0 = 7.38905573    
Area of a circle with radius 7.0 = 153.938049   
</pre>

<title>Fortran Intrinsic Functions</title>

<h1>Fortran - Intrinsic Functions</h1>

<p>Intrinsic functions are some common and important functions that are provided as a part of the Fortran language. We have already discussed some of these functions in the Arrays, Characters and String chapters.</p>

<p>Intrinsic functions can be categorised as:</p>

<p>We have discussed the array functions in the Arrays chapter. In the following section we provide brief descriptions of all these functions from other categories.</p>

<p>In the function name column,</p>

<h2>Numeric Functions</h2>

<p><b>Example</b></p>

<p>When you compile and execute the above program, it produces the following result:</p>

<h2>Mathematical Functions</h2>

<p><b>Example</b></p>

<p>The following program computes the horizontal and vertical position x and y respectively of a projectile after a time, t:</p>

<p>Where, x = u t cos a and y = u t sin a - g t2 / 2</p>

<p>When you compile and execute the above program, it produces the following result:</p>

<h2>Numeric Inquiry Functions</h2>

<p>These functions work with a certain model of integer and floating-point arithmetic. The functions return properties of numbers of the same kind as the variable X, which can be real and in some cases integer.</p>

<h2>Floating-Point Manipulation Functions</h2>

<h2>Bit Manipulation Functions</h2>

<h2>Character Functions</h2>

<h2>Kind Functions</h2>

<h2>Logical Function</h2>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate tryit">
program numericFunctions
implicit none  

   ! define constants  
   ! define variables
   real :: a, b 
   complex :: z
   
   ! values for a, b 
   a = 15.2345
   b = -20.7689
    
   write(*,*) 'abs(a): ',abs(a),' abs(b): ',abs(b)   
   write(*,*) 'aint(a): ',aint(a),' aint(b): ',aint(b) 
   write(*,*) 'ceiling(a): ',ceiling(a),' ceiling(b): ',ceiling(b)   
   write(*,*) 'floor(a): ',floor(a),' floor(b): ',floor(b)  
    
   z = cmplx(a, b)
   write(*,*) 'z: ',z   
   
end program numericFunctions
</pre>
<p>When you compile and execute the above program, it produces the following result:</p>
<pre class="result notranslate">
abs(a): 15.2344999   abs(b): 20.7688999    
aint(a): 15.0000000  aint(b): -20.0000000    
ceiling(a): 16  ceiling(b): -20
floor(a): 15  floor(b): -21
z: (15.2344999, -20.7688999)
</pre>
<h2>Mathematical Functions</h2>
<table class="table table-bordered">
<tr>
<th>Function</th>
<th>Description</th>
</tr>
<tr>
<td>ACOS (X)</td>
<td>It returns the inverse cosine in the range (0, π), in radians.</td>
</tr>
<tr>
<td>ASIN (X)</td>
<td>It returns the inverse sine in the range (-π/2, π/2), in radians.</td>
</tr>
<tr>
<td>ATAN (X)</td>
<td>It returns the inverse tangent in the range (-π/2, π/2), in radians.</td>
</tr>
<tr>
<td>ATAN2 (Y, X)</td>
<td>It returns the inverse tangent in the range (-π, π), in radians.</td>
</tr>
<tr>
<td>COS (X)</td>
<td>It returns the cosine of argument in radians.</td>
</tr>
<tr>
<td>COSH (X)</td>
<td>It returns the hyperbolic cosine of argument in radians.</td>
</tr>
<tr>
<td>EXP (X)</td>
<td>It returns the exponential value of X.</td>
</tr>
<tr>
<td>LOG (X)</td>
<td>It returns the natural logarithmic value of X.</td>
</tr>
<tr>
<td>LOG10 (X)</td>
<td>It returns the common logarithmic (base 10) value of X. </td>
</tr>
<tr>
<td>SIN (X)</td>
<td>It returns the sine of argument in radians.</td>
</tr>
<tr>
<td>SINH (X)</td>
<td>It returns the hyperbolic sine of argument in radians.</td>
</tr>
<tr>
<td>SQRT (X)</td>
<td>It returns square root of X.</td>
</tr>
<tr>
<td>TAN (X)</td>
<td>It returns the tangent of argument in radians.</td>
</tr>
<tr>
<td>TANH (X)</td>
<td>It returns the hyperbolic tangent of argument in radians.</td>
</tr>
</table>
<p><b>Example</b></p>
<p>The following program computes the horizontal and vertical position x and y respectively of a projectile after a time, t:</p>
<p>Where, x = u t cos a and y = u t sin a - g t2 / 2</p>
<pre class="prettyprint notranslate tryit">
program projectileMotion  
implicit none  

   ! define constants  
   real, parameter :: g = 9.8  
   real, parameter :: pi = 3.1415927  
   
   !define variables
   real :: a, t, u, x, y   
   
   !values for a, t, and u 
   a = 45.0
   t = 20.0
   u = 10.0
   
   ! convert angle to radians  
   a = a * pi / 180.0  
   x = u * cos(a) * t   
   y = u * sin(a) * t - 0.5 * g * t * t  
   
   write(*,*) 'x: ',x,'  y: ',y   
   
end program projectileMotion
</pre>
<p>When you compile and execute the above program, it produces the following result:</p>
<pre class="result notranslate">
x: 141.421356  y: -1818.57861  
</pre>

<title>Fortran Numeric Precision</title>

<h1>Fortran - Numeric Precision</h1>

<p>We have already discussed that, in older versions of Fortran, there were two <b>real</b> types: the default real type and <b>double precision</b> type.</p>

<p>However, Fortran 90/95 provides more control over the precision of real and integer data types through the <b>kind</b> specifie.</p>

<h2>The Kind Attribute</h2>

<p>Different kind of numbers are stored differently inside the computer. The <b>kind</b> attribute allows you to specify how a number is stored internally. For example,</p>

<p>In the above declaration, the real variables e, f and g have more precision than the real variables a, b and c. The integer variables l, m and n, can store larger values and have more digits for storage than the integer variables i, j and k. Although this is machine dependent.</p>

<p><b>Example</b></p>

<p>When you compile and execute the above program it produces the following result:</p>

<h2>Inquiring the Size of Variables</h2>

<p>There are a number of intrinsic functions that allows you to interrogate the size of numbers.</p>

<p>For example, the <b>bit_size(i)</b> intrinsic function specifies the number of bits used for storage. For real numbers, the <b>precision(x)</b> intrinsic function, returns the number of decimal digits of precision, while the <b>range(x)</b> intrinsic function returns the decimal range of the exponent.</p>

<p><b>Example</b></p>

<p>When you compile and execute the above program it produces the following result:</p>

<h2>Obtaining the Kind Value</h2>

<p>Fortran provides two more intrinsic functions to obtain the kind value for the required precision of integers and reals:</p>

<p>The selected_real_kind function returns an integer that is the kind type parameter value necessary for a given decimal precision p and decimal exponent range r.  The decimal precision is the number of significant digits, and the decimal exponent range specifies the smallest and largest representable number. The range is thus from 10-r to 10+r.</p>

<p>For example, selected_real_kind (p = 10, r = 99) returns the kind value needed for a precision of 10 decimal places, and a range of at least 10-99 to 10+99.</p>

<p><b>Example</b></p>

<p>When you compile and execute the above program it produces the following result:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
real, kind = 2 :: a, b, c
real, kind = 4 :: e, f, g
integer, kind = 2 :: i, j, k
integer, kind = 3 :: l, m, n
</pre>
<p>In the above declaration, the real variables e, f and g have more precision than the real variables a, b and c. The integer variables l, m and n, can store larger values and have more digits for storage than the integer variables i, j and k. Although this is machine dependent.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate tryit">
program kindSpecifier
implicit none

   real(kind = 4) :: a, b, c
   real(kind = 8) :: e, f, g
   integer(kind = 2) :: i, j, k
   integer(kind = 4) :: l, m, n
   integer :: kind_a, kind_i, kind_e, kind_l
   
   kind_a = kind(a)
   kind_i = kind(i)
   kind_e = kind(e)
   kind_l = kind(l)
   
   print *,'default kind for real is', kind_a
   print *,'default kind for int is', kind_i
   print *,'extended kind for real is', kind_e
   print *,'default kind for int is', kind_l
   
end program kindSpecifier
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="result notranslate">
default kind for real is 4
default kind for int is 2
extended kind for real is 8
default kind for int is 4
</pre>
<h2>Inquiring the Size of Variables</h2>
<p>There are a number of intrinsic functions that allows you to interrogate the size of numbers.</p>
<p>For example, the <b>bit_size(i)</b> intrinsic function specifies the number of bits used for storage. For real numbers, the <b>precision(x)</b> intrinsic function, returns the number of decimal digits of precision, while the <b>range(x)</b> intrinsic function returns the decimal range of the exponent.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate tryit">
program getSize
implicit none

   real (kind = 4) :: a
   real (kind = 8) :: b
   integer (kind = 2) :: i
   integer (kind = 4) :: j

   print *,'precision of real(4) =', precision(a)
   print *,'precision of real(8) =', precision(b)
   
   print *,'range of real(4) =', range(a)
   print *,'range of real(8) =', range(b)
   

   print *,'maximum exponent of real(4) =' , maxexponent(a)
   print *,'maximum exponent of real(8) =' , maxexponent(b)
  
   print *,'minimum exponent of real(4) =' , minexponent(a)
   print *,'minimum exponent of real(8) =' , minexponent(b)
   
   print *,'bits in integer(2) =' , bit_size(i)
   print *,'bits in integer(4) =' , bit_size(j)
   
end program getSize
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="result notranslate">
precision of real(4) = 6
precision of real(8) = 15
range of real(4) = 37
range of real(8) = 307
maximum exponent of real(4) = 128
maximum exponent of real(8) = 1024
minimum exponent of real(4) = -125
minimum exponent of real(8) = -1021
bits in integer(2) = 16
bits in integer(4) = 32
</pre>
<h2>Obtaining the Kind Value</h2>
<p>Fortran provides two more intrinsic functions to obtain the kind value for the required precision of integers and reals:</p>
<ul class="list">
<li>selected_int_kind (r)</li>
<li>selected_real_kind ([p, r])</li>
</ul>
<p>The selected_real_kind function returns an integer that is the kind type parameter value necessary for a given decimal precision p and decimal exponent range r.  The decimal precision is the number of significant digits, and the decimal exponent range specifies the smallest and largest representable number. The range is thus from 10-r to 10+r.</p>
<p>For example, selected_real_kind (p = 10, r = 99) returns the kind value needed for a precision of 10 decimal places, and a range of at least 10-99 to 10+99.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate tryit">
program getKind
implicit none

   integer:: i
   i = selected_real_kind (p = 10, r = 99) 
   print *,'selected_real_kind (p = 10, r = 99)', i
   
end program getKind
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="result notranslate">
selected_real_kind (p = 10, r = 99) 8
</pre>

<title>Fortran Program Libraries</title>

<h1>Fortran - Program Libraries</h1>

<p>There are various Fortran tools and libraries. Some are free and some are paid services.</p>

<p>Following are some free libraries:</p>

<p>The following libraries are not free:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Fortran Programming Style</title>

<h1>Fortran - Programming Style</h1>

<p>Programming style is all about following some rules while developing programs. These good practices impart values like readability, and unambiguity into your program.</p>

<p>A good program should have the following characteristics:</p>

<p>For example, if you make a comment like the following, it will not be of much help:</p>

<p>However, if you are calculating binomial coefficient, and need this loop for nCr then a comment like this will be helpful:</p>

<p>Indented code blocks to make various levels of code clear.</p>

<p>Self-checking codes to ensure there will be no numerical errors like division by zero, square root of a negative real number or logarithm of a negative real number.</p>

<p>Including codes that ensure variables do not take illegal or out of range values, i.e., input validation.</p>

<p>Not putting checks where it would be unnecessary and slows down the execution. For example:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
! loop from 1 to 10 
do i=1,10  
</pre>
<p>However, if you are calculating binomial coefficient, and need this loop for nCr then a comment like this will be helpful:</p>
<pre class="result notranslate">
! loop to calculate nCr 
do i=1,10
</pre>
<ul class="list">
<li><p>Indented code blocks to make various levels of code clear.</p></li>
<li><p>Self-checking codes to ensure there will be no numerical errors like division by zero, square root of a negative real number or logarithm of a negative real number.</p></li> 
<li><p>Including codes that ensure variables do not take illegal or out of range values, i.e., input validation.</p></li> 
<li><p>Not putting checks where it would be unnecessary and slows down the execution. For example:</p></li>
</ul>
<pre class="prettyprint notranslate">
real :: x 
x = sin(y) + 1.0

if (x >= 0.0) then
   z = sqrt(x)
end if
</pre>

<title>Fortran Debugging Program</title>

<h1>Fortran - Debugging Program</h1>

<p>A debugger tool is used to search for errors in the programs.</p>

<p>A debugger program steps through the code and allows you to examine the values in the variables and other data objects during execution of the program.</p>

<p>It loads the source code and you are supposed to run the program within the debugger. Debuggers debug a program by:</p>

<p>Breakpoints specify where the program should stop, specifically after a critical line of code. Program executions after the variables are checked at a breakpoint.</p>

<p>Debugger programs also check the source code line by line.</p>

<p>Watch points are the points where the values of some variables are needed to be checked, particularly after a read or write operation.</p>

<h2>The gdb Debugger</h2>

<p>The gdb debugger, the GNU debugger comes with Linux operating system. For X windows system, gdb comes with a graphical interface and the program is named xxgdb.</p>

<p>Following table provides some commands in gdb:</p>

<h2>The dbx Debugger</h2>

<p>There is another debugger, the dbx debugger, for Linux.</p>

<p>The following table provides some commands in dbx:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Fortran Quick Guide</title>

<h1>Fortran - Quick Guide</h1>

<h1>Fortran - Overview</h1>

<p>Fortran, as derived from Formula Translating System, is a general-purpose, imperative programming language. It is used for numeric and scientific computing.</p>

<p>Fortran was originally developed by IBM in the 1950s for scientific and engineering applications. Fortran ruled this programming area for a long time and became very popular for high performance computing, because.</p>

<p>It supports:</p>

<h2>Facts about Fortran</h2>

<p>Fortran was created by a team, led by John Backus at IBM in 1957.</p>

<p>Initially the name used to be written in all capital, but current standards and implementations only require the first letter to be capital.</p>

<p>Fortran stands for FORmula TRANslator.</p>

<p>Originally developed for scientific calculations, it had very limited support for character strings and other structures needed for general purpose programming.</p>

<p>Later extensions and developments made it into a high level programming language with good degree of portability.</p>

<p>Original versions, Fortran I, II and III are considered obsolete now.</p>

<p>Oldest version still in use is Fortran IV, and Fortran 66.</p>

<p>Most commonly used versions today are : Fortran 77, Fortran 90, and Fortran 95.</p>

<p>Fortran 77 added strings as a distinct type.</p>

<p>Fortran 90 added various sorts of threading, and direct array processing.</p>

<h1>Fortran - Environment Setup</h1>

<h2>Setting up Fortran in Windows</h2>

<p>G95 is the GNU Fortran multi-architechtural compiler, used for setting up Fortran in Windows. The windows version emulates a unix environment using MingW under windows. The installer takes care of this and automatically adds g95 to the windows PATH variable.</p>

<p>You can get the stable version of G95 from here : <a href="http://www.fortran.com/the-fortran-company-homepage/whats-new/g95-windows-download/" rel="nofollow" target="_blank"></a></p>

<h2>How to use G95</h2>

<p>During installation, <b>g95</b> is automatically added to your PATH variable if you select the option “RECOMMENDED”. This means that you can simply open a new Command Prompt window and type “g95” to bring up the compiler. Find some basic commands below to get you started.</p>

<p><b>Command line options for G95:</b></p>

<p>Multiple source and object files can be specified at once. Fortran files are indicated by names ending in ".f", ".F", ".for", ".FOR", ".f90", ".F90", ".f95", ".F95", ".f03" and ".F03". Multiple source files can be specified. Object files can be specified as well and will be linked to form an executable file.</p>

<h1>Fortran - Basic Syntax</h1>

<p>A Fortran program is made of a collection of program units like a main program, modules, and external subprograms or procedures.</p>

<p>Each program contains one main program and may or may not contain other program units. The syntax of the main program is as follows:</p>

<h2>A Simple Program in Fortran</h2>

<p>Let’s write a program that adds two numbers and prints the result:</p>

<p>When you compile and execute the above program, it produces the following result:</p>

<p>Please note that:</p>

<p>All Fortran programs start with the keyword <b>program</b> and end with the keyword <b>end program,</b> followed by the name of the program.</p>

<p>The <b>implicit none</b> statement allows the compiler to check that all your variable types are declared properly. You must always use <b>implicit none</b> at the start of every program.</p>

<p>Comments in Fortran are started with the exclamation mark (!), as all characters after this (except in a character string) are ignored by the compiler.</p>

<p>The <b>print *</b> command displays data on the screen.</p>

<p>Indentation of code lines is a good practice for keeping a program readable.</p>

<p>Fortran allows both uppercase and lowercase letters. Fortran is case-insensitive, except for string literals.</p>

<h2>Basics</h2>

<p>The <b>basic character set</b> of Fortran contains:</p>

<p><b>Tokens</b> are made of characters in the basic character set. A token could be a keyword, an identifier, a constant, a string literal, or a symbol.</p>

<p>Program statements are made of tokens.</p>

<h2>Identifier</h2>

<p>An identifier is a name used to identify a variable, procedure, or any other user-defined item. A name in Fortran must follow the following rules:</p>

<p>It cannot be longer than 31 characters.</p>

<p>It must be composed of alphanumeric characters (all the letters of the alphabet, and the digits 0 to 9) and underscores (_).</p>

<p>First character of a name must be a letter.</p>

<p>Names are case-insensitive</p>

<h2>Keywords</h2>

<p>Keywords are special words, reserved for the language. These reserved words cannot be used as identifiers or names.</p>

<p>The following table, lists the Fortran keywords:</p>

<h1>Fortran - Data Types</h1>

<p>Fortran provides five intrinsic data types, however, you can derive your own data types as well. The five intrinsic types are:</p>

<h2>Integer Type</h2>

<p>The integer types can hold only integer values. The following example extracts the largest value that can be held in a usual four byte integer:</p>

<p>When you compile and execute the above program it produces the following result:</p>

<p>Note that the <b>huge()</b> function gives the largest number that can be held by the specific integer data type. You can also specify the number of bytes using the <b>kind</b> specifier. The following example demonstrates this:</p>

<p>When you compile and execute the above program, it produces the following result:</p>

<h2>Real Type</h2>

<p>It stores the floating point numbers, such as 2.0,  3.1415, -100.876, etc.</p>

<p>Traditionally there are two different real types, the default <b>real</b> type and <b>double precision</b> type.</p>

<p>However, Fortran 90/95 provides more control over the precision of real and integer data types through the<b>kind</b>specifier, which we will study in the chapter on Numbers.</p>

<p>The following example shows the use of real data type:</p>

<p>When you compile and execute the above program it produces the following result:</p>

<h2>Complex Type</h2>

<p>This is used for storing complex numbers. A complex number has two parts, the real part and the imaginary part. Two consecutive numeric storage units store these two parts.</p>

<p>For example, the complex number (3.0, -5.0) is equal to 3.0 – 5.0i</p>

<p>We will discuss Complex types in more detail, in the Numbers chapter.</p>

<h2>Logical Type</h2>

<p>There are only two logical values: <b>.true.</b> and <b>.false.</b></p>

<h2>Character Type</h2>

<p>The character type stores characters and strings. The length of the string can be specified by len specifier. If no length is specified, it is 1.</p>

<p><b>For example,</b></p>

<p>The expression, <b>name(1:4)</b> would give the substring “Zara”.</p>

<h2>Implicit Typing</h2>

<p>Older versions of Fortran allowed a feature called implicit typing, i.e., you do not have to declare the variables before use. If a variable is not declared, then the first letter of its name will determine its type.</p>

<p>Variable names starting with i, j, k, l, m, or n, are considered to be for integer variable and others are real variables. However, you must declare all the variables as it is good programming practice. For that you start your program with the statement:</p>

<p>This statement turns off implicit typing.</p>

<h1>Fortran - Variables</h1>

<p>A variable is nothing but a name given to a storage area that our programs can manipulate. Each variable should have a specific type, which determines the size and layout of the variable's memory; the range of values that can be stored within that memory; and the set of operations that can be applied to the variable.</p>

<p>The name of a variable can be composed of letters, digits, and the underscore character. A name in Fortran must follow the following rules:</p>

<p>It cannot be longer than 31 characters.</p>

<p>It must be composed of alphanumeric characters (all the letters of the alphabet, and the digits 0 to 9) and underscores (_).</p>

<p>First character of a name must be a letter.</p>

<p>Names are case-insensitive.</p>

<p>Based on the basic types explained in previous chapter, following are the variable types:</p>

<h2>Variable Declaration</h2>

<p>Variables are declared at the beginning of a program (or subprogram) in a type declaration statement.</p>

<p>Syntax for variable declaration is as follows:</p>

<p><b>For example,</b></p>

<p>Later you can assign values to these variables, like,</p>

<p>You can also use the intrinsic function <b>cmplx,</b> to assign values to a complex variable:</p>

<p><b>Example</b></p>

<p>The following example demonstrates variable declaration, assignment and display on screen:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>Fortran - Constants</h1>

<p>The constants refer to the fixed values that the program cannot alter during its execution. These fixed values are also called <b>literals</b>.</p>

<p>Constants can be of any of the basic data types like an integer constant, a floating constant, a character constant, a complex constant, or a string literal. There are only two logical constants : <b>.true.</b> and <b>.false.</b></p>

<p>The constants are treated just like regular variables, except that their values cannot be modified after their definition.</p>

<h2>Named Constants and Literals</h2>

<p>There are two types of constants:</p>

<p>A literal constant have a value, but no name.</p>

<p>For example, following are the literal constants:</p>

<p>"PQR" "a" "123'abc$%#@!"</p>

<p>" a quote "" "</p>

<p>'PQR' 'a' '123"abc$%#@!'</p>

<p>' an apostrophe '' '</p>

<p>A named constant has a value as well as a name.</p>

<p>Named constants should be declared at the beginning of a program or procedure, just like a variable type declaration, indicating its name and type. Named constants are declared with the parameter attribute. For example,</p>

<p><b>Example</b></p>

<p>The following program calculates the displacement due to vertical motion under gravity.</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>Fortran - Operators</h1>

<p>An operator is a symbol that tells the compiler to perform specific mathematical or logical manipulations. Fortran provides the following types of operators:</p>

<p>Let us look at all these types of operators one by one.</p>

<h2>Arithmetic Operators</h2>

<p>Following table shows all the arithmetic operators supported by Fortran. Assume variable <b>A</b> holds 5 and variable <b>B</b> holds 3 then:</p>

<p><a href="/fortran/fortran_arithmetic_operators.htm">Show Examples</a></p>

<h2>Relational Operators</h2>

<p>Following table shows all the relational operators supported by Fortran. Assume variable <b>A</b> holds 10 and variable <b>B</b> holds 20, then:</p>

<p><a href="/fortran/fortran_relational_operators.htm">Show Examples</a></p>

<h2>Operators Precedence in Fortran</h2>

<p>Operator precedence determines the grouping of terms in an expression. This affects how an expression is evaluated. Certain operators have higher precedence than others; for example, the multiplication operator has higher precedence than the addition operator.</p>

<p>For example, x = 7 + 3 * 2; here, x is assigned 13, not 20 because operator * has higher precedence than +, so it first gets multiplied with 3*2 and then adds into 7.</p>

<p>Here, operators with the highest precedence appear at the top of the table, those with the lowest appear at the bottom. Within an expression, higher precedence operators will be evaluated first.</p>

<p><a href="/fortran/fortran_operators_precedence.htm">Show Examples</a></p>

<h1>Fortran - Decisions</h1>

<p>Decision making structures require that the programmer specify one or more conditions to be evaluated or tested by the program, along with a statement or statements to be executed, if the condition is determined to be true, and optionally, other statements to be executed if the condition is determined to be false.</p>

<p>Following is the general form of a typical decision making structure found in most of the programming languages:</p>

<p>Fortran provides the following types of decision making constructs.</p>

<h2>Fortran - if...else if...else Statement</h2>

<p>An <b>if</b> statement construct can have one or more optional <b>else-if</b>  constructs.  When the <b>if</b> condition fails, the immediately followed <b>else-if</b> is executed.  When the <b>else-if</b> also fails, its successor <b>else-if</b> statement (if any) is executed, and so on.</p>

<p>The optional else is placed at the end and it is executed when none of the above conditions hold true.</p>

<h3>Syntax:</h3>

<p>The syntax of an <b>if...else if...else</b> statement is:</p>

<p><b>Example</b></p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>Fortran - Loops</h1>

<p>There may be a situation, when you need to execute a block of code several number of times. In general, statements are executed sequentially : The first statement in a function is executed first, followed by the second, and so on.</p>

<p>A loop statement allows us to execute a statement or group of statements multiple times and following is the general form of a loop statement in most of the programming languages:</p>

<p>Fortran provides the following types of loop constructs to handle looping requirements. Click the following links to check their detail.</p>

<h2>Loop Control Statements</h2>

<p>Loop control statements change execution from its normal sequence. When execution leaves a scope, all automatic objects that were created in that scope are destroyed.</p>

<p>Fortran supports the following control statements. Click the following links to check their detail.</p>

<h1>Fortran - Numbers</h1>

<p>Numbers in Fortran are represented by three intrinsic data types:</p>

<h2>Integer Type</h2>

<p>The integer types can hold only integer values. The following example extracts the largest value that could be hold in a usual four byte integer:</p>

<p>When you compile and execute the above program it produces the following result:</p>

<p>Please note that the <b>huge()</b> function gives the largest number that can be held by the specific integer data type. You can also specify the number of bytes using the <b>kind</b> specifier. The following example demonstrates this:</p>

<p>When you compile and execute the above program it produces the following result:</p>

<h2>Real Type</h2>

<p>It stores the floating point numbers, such as 2.0, 3.1415, -100.876, etc.</p>

<p>Traditionally there were two different <b>real</b> types : the default real type and <b>double precision</b> type.</p>

<p>However, Fortran 90/95 provides more control over the precision of real and integer data types through the <b>kind</b> specifier, which we will study shortly.</p>

<p>The following example shows the use of real data type:</p>

<p>When you compile and execute the above program it produces the following result:</p>

<h2>Complex Type</h2>

<p>This is used for storing complex numbers. A complex number has two parts : the real part and the imaginary part. Two consecutive numeric storage units store these two parts.</p>

<p>For example, the complex number (3.0, -5.0) is equal to 3.0 – 5.0i</p>

<p>The generic function <b>cmplx()</b> creates a complex number. It produces a result who’s real and imaginary parts are single precision, irrespective of the type of the input arguments.</p>

<p>When you compile and execute the above program it produces the following result:</p>

<p>The following program demonstrates complex number arithmetic:</p>

<p>When you compile and execute the above program it produces the following result:</p>

<h2>The Range, Precision and Size of Numbers</h2>

<p>The range on integer numbers, the precision and the size of floating point numbers depends on the number of bits allocated to the specific data type.</p>

<p>The following table displays the number of bits and range for integers:</p>

<p>The following table displays the number of bits, smallest and largest value, and the precision for real numbers.</p>

<p>The following examples demonstrate this:</p>

<p>When you compile and execute the above program it produces the following result:</p>

<p>Now let us use a smaller number:</p>

<p>When you compile and execute the above program it produces the following result:</p>

<p>Now let’s watch underflow:</p>

<p>When you compile and execute the above program it produces the following result:</p>

<h2>The Kind Specifier</h2>

<p>In scientific programming, one often needs to know the range and precision of data of the hardware platform on which the work is being done.</p>

<p>The intrinsic function <b>kind()</b> allows you to query the details of the hardware’s data representations before running a program.</p>

<p>When you compile and execute the above program it produces the following result:</p>

<p>You can also check the kind of all data types:</p>

<p>When you compile and execute the above program it produces the following result:</p>

<h1>Fortran - Characters</h1>

<p>The Fortran language can treat characters as single character or contiguous strings. </p>

<p>Characters could be any symbol taken from the basic character set, i.e., from the letters, the decimal digits, the underscore, and 21 special characters.</p>

<p>A character constant is a fixed valued character string.</p>

<p>The intrinsic data type <b>character</b> stores characters and strings. The length of the string can be specified by <b>len</b> specifier. If no length is specified, it is 1. You can refer individual characters within a string referring by position; the left most character is at position 1.</p>

<h2>Character Declaration</h2>

<p>Declaring a character type data is same as other variables:</p>

<p>For example,</p>

<p>you can assign a value like,</p>

<p>The following example demonstrates declaration and use of character data type:</p>

<p>When you compile and execute the above program it produces the following result:</p>

<h2>Concatenation of Characters</h2>

<p>The concatenation operator //, concatenates characters.</p>

<p>The following example demonstrates this:</p>

<p>When you compile and execute the above program it produces the following result:</p>

<h2>Some Character Functions</h2>

<p>The following table shows some commonly used character functions along with the description:</p>

<p><b>Example 1</b></p>

<p>This example shows the use of the <b>index</b> function:</p>

<p>When you compile and execute the above program it produces the following result:</p>

<p><b>Example 2</b></p>

<p>This example demonstrates the use of the <b>trim</b> function:</p>

<p>When you compile and execute the above program it produces the following result:</p>

<p><b>Example 3</b></p>

<p>This example demonstrates the use of <b>achar</b> function</p>

<p>When you compile and execute the above program it produces the following result:</p>

<h2>Checking Lexical Order of Characters</h2>

<p>The following functions determine the lexical sequence of characters:</p>

<p><b>Example 4</b></p>

<p>The following function demonstrates the use:</p>

<p>When you compile and execute the above program it produces the following result:</p>

<h1>Fortran - Strings</h1>

<p>The Fortran language can treat characters as single character or contiguous strings.</p>

<p>A character string may be only one character in length, or it could even be of zero length. In Fortran, character constants are given between a pair of double or single quotes.</p>

<p>The intrinsic data type <b>character</b> stores characters and strings. The length of the string can be specified by <b>len specifier</b>. If no length is specified, it is 1. You can refer individual characters within a string referring by position; the left most character is at position 1.</p>

<h2>String Declaration</h2>

<p>Declaring a string is same as other variables:</p>

<p>For example,</p>

<p>you can assign a value like,</p>

<p>The following example demonstrates declaration and use of character data type:</p>

<p>When you compile and execute the above program it produces the following result:</p>

<h2>String Concatenation</h2>

<p>The concatenation operator //, concatenates strings.</p>

<p>The following example demonstrates this:</p>

<p>When you compile and execute the above program it produces the following result:</p>

<h2>Extracting Substrings</h2>

<p>In Fortran, you can extract a substring from a string by indexing the string, giving the start and the end index of the substring in a pair of brackets. This is called extent specifier.</p>

<p>The following example shows how to extract the substring ‘world’ from the string ‘hello world’:</p>

<p>When you compile and execute the above program it produces the following result:</p>

<p><b>Example</b></p>

<p>The following example uses the <b>date_and_time</b> function to give the date and time string. We use extent specifiers to extract the year, date, month, hour, minutes and second information separately.</p>

<p>When you compile and execute the above program, it gives the detailed date and time information:</p>

<h2>Trimming Strings</h2>

<p>The <b>trim</b> function takes a string, and returns the input string after removing all trailing blanks.</p>

<p><b>Example</b></p>

<p>When you compile and execute the above program it produces the following result:</p>

<h2>Left and Right Adjustment of Strings</h2>

<p>The function <b>adjustl</b> takes a string and returns it by removing the leading blanks and appending them as trailing blanks.</p>

<p>The function <b>adjustr</b> takes a string and returns it by removing the trailing blanks and appending them as leading blanks.</p>

<p><b>Example</b></p>

<p>When you compile and execute the above program it produces the following result:</p>

<h2>Searching for a Substring in a String</h2>

<p>The index function takes two strings and checks if the second string is a substring of the first string. If the second argument is a substring of the first argument, then it returns an integer which is the starting index of the second string in the first string, else it returns zero.</p>

<p><b>Example</b></p>

<p>When you compile and execute the above program it produces the following result:</p>

<h1>Fortran - Arrays</h1>

<p>Arrays can store a fixed-size sequential collection of elements of the same type. An array is used to store a collection of data, but it is often more useful to think of an array as a collection of variables of the same type.</p>

<p>All arrays consist of contiguous memory locations. The lowest address corresponds to the first element and the highest address to the last element.</p>

<p>Arrays can be one- dimensional (like vectors), two-dimensional (like matrices) and Fortran allows you to create up to 7-dimensional arrays.</p>

<h2>Declaring Arrays</h2>

<p>Arrays are declared with the <b>dimension</b> attribute.</p>

<p>For example, to declare a one-dimensional array named number, of real numbers containing 5 elements, you write,</p>

<p>The individual elements of arrays are referenced by specifying their subscripts. The first element of an array has a subscript of one. The array numbers contains five real variables –numbers(1), numbers(2), numbers(3), numbers(4), and numbers(5).</p>

<p>To create a 5 x 5 two-dimensional array of integers named matrix, you write:</p>

<p>You can also declare an array with some explicit lower bound, for example:</p>

<h2>Assigning Values</h2>

<p>You can either assign values to individual members, like,</p>

<p>or, you can use a loop,</p>

<p>One dimensional array elements can be directly assigned values using a short hand symbol, called array constructor, like,</p>

<p><b>please note that there are no spaces allowed between the brackets ‘( ‘and the back slash ‘/’</b></p>

<p><b>Example</b></p>

<p>The following example demonstrates the concepts discussed above.</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Some Array Related Terms</h2>

<p>The following table gives some array related terms:</p>

<h2>Passing Arrays to Procedures</h2>

<p>You can pass an array to a procedure as an argument. The following example demonstrates the concept:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>In the above example, the subroutine fillArray and printArray can only be called with arrays with dimension 5. However, to write subroutines that can be used for arrays of any size, you can rewrite it using the following technique:</p>

<p>Please note that the program is using the <b>size</b> function to get the size of the array.</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Array Sections</h2>

<p>So far we have referred to the whole array, Fortran provides an easy way to refer several elements, or a section of an array, using a single statement.</p>

<p>To access an array section, you need to provide the lower and the upper bound of the section, as well as a stride (increment), for all the dimensions. This notation is called a <b>subscript triplet:</b></p>

<p>When no lower and upper bounds are mentioned, it defaults to the extents you declared, and stride value defaults to 1.</p>

<p>The following example demonstrates the concept:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Array Intrinsic Functions</h2>

<p>Fortran 90/95 provides several intrinsic procedures. They can be divided into 7 categories.</p>

<p><a href="/fortran/vector_and_matrix_multiplication.htm">Vector and matrix multiplication</a></p>

<p><a href="/fortran/reduction.htm">Reduction</a></p>

<p><a href="/fortran/inquiry.htm">Inquiry</a></p>

<p><a href="/fortran/construction.htm">Construction</a></p>

<p><a href="/fortran/reshape.htm">Reshape</a></p>

<p><a href="/fortran/manipulation.htm">Manipulation</a></p>

<p><a href="/fortran/location.htm">Location</a></p>

<h1>Fortran - Dynamic Arrays</h1>

<p>A <b>dynamic array</b> is an array, the size of which is not known at compile time, but will be known at execution time.</p>

<p>Dynamic arrays are declared with the attribute <b>allocatable</b>.</p>

<p>For example,</p>

<p>The rank of the array, i.e., the dimensions has to be mentioned however, to allocate memory to such an array, you use the <b>allocate</b> function.</p>

<p>After the array is used, in the program, the memory created should be freed using the <b>deallocate</b> function</p>

<p><b>Example</b></p>

<p>The following example demonstrates the concepts discussed above.</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Use of Data Statement</h2>

<p>The <b>data</b> statement can be used for initialising more than one array, or for array section initialisation.</p>

<p>The syntax of data statement is:</p>

<p><b>Example</b></p>

<p>The following example demonstrates the concept:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Use of Where Statement</h2>

<p>The <b>where</b> statement allows you to use some elements of an array in an expression, depending on the outcome of some logical condition. It allows the execution of the expression, on an element, if the given condition is true.</p>

<p><b>Example</b></p>

<p>The following example demonstrates the concept:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>Fortran - Derived Data Types</h1>

<p>Fortran allows you to define derived data types. A derived data type is also called a structure, and it can consist of data objects of different types.</p>

<p>Derived data types are used to represent a record. E.g. you want to keep track of your books in a library, you might want to track the following attributes about each book:</p>

<h2>Defining a Derived data type</h2>

<p>To define a derived data <b>type</b>, the type and <b>end type</b> statements are used. . The type statement defines a new data type, with more than one member for your program. The format of the type statement is this:</p>

<p>Here is the way you would declare the Book structure:</p>

<h2>Accessing Structure Members</h2>

<p>An object of a derived data type is called a structure</p>

<p>A structure of type Books can be created in a type declaration statement like:</p>

<p>The components of the structure can be accessed using the component selector character (%):</p>

<p><b>Note that there are no spaces before and after the % symbol.</b></p>

<p><b>Example</b></p>

<p>The following program illustrates the above concepts:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Array of Structures</h2>

<p>You can also create arrays of a derived type:</p>

<p>Individual elements of the array could be accessed as:</p>

<p>The following program illustrates the concept:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>Fortran - Pointers</h1>

<p>In most programming languages, a pointer variable stores the memory address of an object. However, in Fortran, a pointer is a data object that has more functionalities than just storing the memory address. It contains more information about a particular object, like type, rank, extents, and memory address.</p>

<p>A pointer is associated with a target by allocation or pointer assignment.</p>

<h2>Declaring a Pointer Variable</h2>

<p>A pointer variable is declared with the pointer attribute.</p>

<p>The following examples shows declaration of pointer variables:</p>

<p>A pointer can point to:</p>

<h2>Allocating Space for a Pointer</h2>

<p>The <b>allocate</b> statement allows you to allocate space for a pointer object. For example:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>You should empty the allocated storage space by the <b>deallocate</b> statement when it is no longer required and avoid accumulation of unused and unusable memory space.</p>

<h2>Targets and Association</h2>

<p>A target is another normal variable, with space set aside for it. A target variable must be declared with the <b>target</b> attribute.</p>

<p>You associate a pointer variable with a target variable using the association operator (=>).</p>

<p>Let us rewrite the previous example, to demonstrate the concept:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>A pointer can be:</p>

<p>In the above program, we have <b>associated</b> the pointer p1, with the target t1, using the => operator. The function associated, tests a pointer’s association status.</p>

<p>The <b>nullify</b> statement disassociates a pointer from a target.</p>

<p>Nullify does not empty the targets as there could be more than one pointer pointing to the same target. However, emptying the pointer implies nullification also.</p>

<p><b>Example 1</b></p>

<p>The following example demonstrates the concepts:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>Please note that each time you run the code, the memory addresses will be different.</p>

<p><b>Example 2</b></p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>Fortran - Basic Input Output</h1>

<p>We have so far seen that we can read data from keyboard using the <b>read *</b> statement, and display output to the screen using the <b>print*</b> statement, respectively. This form of input-output is <b>free format</b> I/O, and it is called <b>list-directed</b> input-output.</p>

<p>The free format simple I/O has the form:</p>

<p>However the formatted I/O gives you more flexibility over data transfer.</p>

<h2>Formatted Input Output</h2>

<p>Formatted input output has the syntax as follows:</p>

<p>Where,</p>

<p>fmt is the format specification</p>

<p>variable-list is a list of the variables to be read from keyboard or written on screen</p>

<p>Format specification defines the way in which formatted data is displayed. It consists of a string, containing a list of <b>edit descriptors</b> in parentheses.</p>

<p>An <b>edit descriptor</b> specifies the exact format, for example, width, digits after decimal point etc., in which characters and numbers are displayed.</p>

<p><b>For example:</b></p>

<p>The following table describes the descriptors:</p>

<p>This is used for real output in exponential notation. The ‘E’ descriptor statement takes the form ‘rEw.d’ where the meanings of r, w and d are given in the table below. Real values are right justiﬁed in their ﬁelds. If the ﬁeld width is not large enough to accommodate the real number then the ﬁeld is ﬁlled with asterisks.</p>

<p>Please note that, to print out a real number with three decimal places a ﬁeld width of at least ten is needed. One for the sign of the mantissa, two for the zero, four for the mantissa and two for the exponent itself. In general, w ≥ d + 7.</p>

<p>Following symbols are used with the format descriptors:</p>

<p><b>Example 1</b></p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p><b>Example 2</b></p>

<p>When the above code is compiled and executed, it produces the following result: (assume the user enters the name Zara)</p>

<p><b>Example 3</b></p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>The Format Statement</h2>

<p>The format statement allows you to mix and match character, integer and real output in one statement. The following example demonstrates this:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>Fortran - File Input Output</h1>

<p>Fortran allows you to read data from, and write data into files.</p>

<p>In the last chapter, you have seen how to read data from, and write data to the terminal. In this chapter you will study file input and output functionalities provided by Fortran.</p>

<p>You can read and write to one or more files. The OPEN, WRITE, READ and CLOSE statements allow you to achieve this.</p>

<h2>Opening and Closing Files</h2>

<p>Before using a file you must open the file. The <b>open</b> command is used to open files for reading or writing. The simplest form of the command is:</p>

<p>However, the open statement may have a general form:</p>

<p>The following table describes the most commonly used specifiers:</p>

<p>After the file has been opened, it is accessed by read and write statements. Once done, it should be closed using the <b>close</b> statement.</p>

<p>The close statement has the following syntax:</p>

<p>Please note that the parameters in brackets are optional.</p>

<p><b>Example</b></p>

<p>This example demonstrates opening a new file for writing some data into the file.</p>

<p>When the above code is compiled and executed, it creates the file data1.dat and writes the x and y array values into it. And then closes the file.</p>

<p><b>Reading from and Writing into the File</b></p>

<p>The read and write statements respectively are used for reading from and writing into a file respectively.</p>

<p>They have the following syntax:</p>

<p>Most of the specifiers have already been discussed in the above table.</p>

<p>The END=s specifier is a statement label where the program jumps, when it reaches end-of-file.</p>

<p><b>Example</b></p>

<p>This example demonstrates reading from and writing into a file.</p>

<p>In this program we read from the file, we created in the last example, data1.dat, and display it on screen.</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>Fortran - Procedures</h1>

<p>A <b>procedure</b> is a group of statements that perform a well-defined task and can be invoked from your program. Information (or data) is passed to the calling program, to the procedure as arguments.</p>

<p>There are two types of procedures:</p>

<h2>Function</h2>

<p>A function is a procedure that returns a single quantity. A function should not modify its arguments.</p>

<p>The returned quantity is known as <b>function value</b>, and it is denoted by the function name.</p>

<p><b>Syntax:</b></p>

<p>Syntax for a function is as follows:</p>

<p>The following example demonstrates a function named area_of_circle. It calculates the area of a circle with radius r.</p>

<p>When you compile and execute the above program, it produces the following result:</p>

<p>Please note that:</p>

<p>You must specify <b>implicit none</b> in both the main program as well as the procedure.</p>

<p>The argument r in the called function is called <b>dummy argument</b>.</p>

<p><b>The result Option</b></p>

<p>If you want the returned value to be stored in some other name than the function name, you can use the <b>result</b> option.</p>

<p>You can specify the return variable name as:</p>

<h2>Subroutine</h2>

<p>A subroutine does not return a value, however it can modify its arguments.</p>

<p><b>Syntax</b></p>

<p><b>Calling a Subroutine</b></p>

<p>You need to invoke a subroutine using the <b>call</b> statement.</p>

<p>The following example demonstrates the definition and use of a subroutine swap, that changes the values of its arguments.</p>

<p>When you compile and execute the above program, it produces the following result:</p>

<h2>Specifying the Intent of the Arguments</h2>

<p>The intent attribute allows you to specify the intention with which arguments are used in the procedure. The following table provides the values of the intent attribute: </p>

<p>The following example demonstrates the concept:</p>

<p>When you compile and execute the above program, it produces the following result:</p>

<h2>Recursive Procedures</h2>

<p>Recursion occurs when a programming languages allows you to call a function inside the same function. It is called recursive call of the function.</p>

<p>When a procedure calls itself, directly or indirectly, is called a recursive procedure. You should declare this type of procedures by preceding the word <b>recursive</b> before its declaration.</p>

<p>When a function is used recursively, the <b>result</b> option has to be used.</p>

<p>Following is an example, which calculates factorial for a given number using a recursive procedure:</p>

<h2>Internal Procedures</h2>

<p>When a procedure is contained within a program, it is called the internal procedure of the program. The syntax for containing an internal procedure is as follows:</p>

<p>The following example demonstrates the concept:</p>

<p>When you compile and execute the above program, it produces the following result:</p>

<h1>Fortran - Modules</h1>

<p>A module is like a package where you can keep your functions and subroutines, in case you are writing a very big program, or your functions or subroutines can be used in more than one program.</p>

<p>Modules provide you a way of splitting your programs between multiple files.</p>

<p>Modules are used for:</p>

<h3>Syntax of a Module</h3>

<p>A module consists of two parts:</p>

<p>The general form of a module is:</p>

<h2>Using a Module into your Program</h2>

<p>You can incorporate a module in a program or subroutine by the use statement:</p>

<p>Please note that</p>

<p>You can add as many modules as needed, each will be in separate files and compiled separately.</p>

<p>A module can be used in various different programs.</p>

<p>A module can be used many times in the same program.</p>

<p>The variables declared in a module specification part, are global to the module.</p>

<p>The variables declared in a module become global variables in any program or routine where the module is used.</p>

<p>The use statement can appear in the main program, or any other subroutine or module which uses the routines or variables declared in a particular module.</p>

<p><b>Example</b></p>

<p>The following example demonstrates the concept:</p>

<p>When you compile and execute the above program, it produces the following result:</p>

<h2>Accessibility of Variables and Subroutines in a Module</h2>

<p>By default, all the variables and subroutines in a module is made available to the program that is using the module code, by the <b>use</b> statement.</p>

<p>However, you can control the accessibility of module code using the <b>private</b> and <b>public</b> attributes. When you declare some variable or subroutine as private, it is not available outside the module.</p>

<p><b>Example</b></p>

<p>The following example illustrates the concept:</p>

<p>In the previous example, we had two module variables, <b>e</b> and <b>pi.</b> Let us make them private and observe the output:</p>

<p>When you compile and execute the above program, it gives the following error message:</p>

<p>Since <b>e</b> and <b>pi,</b> both are declared private, the program module_example cannot access these variables anymore.</p>

<p>However, other module subroutines can access them:</p>

<p>When you compile and execute the above program, it produces the following result:</p>

<h1>Fortran - Intrinsic Functions</h1>

<p>Intrinsic functions are some common and important functions that are provided as a part of the Fortran language. We have already discussed some of these functions in the Arrays, Characters and String chapters.</p>

<p>Intrinsic functions can be categorised as:</p>

<p>We have discussed the array functions in the Arrays chapter. In the following section we provide brief descriptions of all these functions from other categories.</p>

<p>In the function name column,</p>

<h2>Numeric Functions</h2>

<p><b>Example</b></p>

<p>When you compile and execute the above program, it produces the following result:</p>

<h2>Mathematical Functions</h2>

<p><b>Example</b></p>

<p>The following program computes the horizontal and vertical position x and y respectively of a projectile after a time, t:</p>

<p>Where, x = u t cos a and y = u t sin a - g t2 / 2</p>

<p>When you compile and execute the above program, it produces the following result:</p>

<h2>Numeric Inquiry Functions</h2>

<p>These functions work with a certain model of integer and floating-point arithmetic. The functions return properties of numbers of the same kind as the variable X, which can be real and in some cases integer.</p>

<h2>Floating-Point Manipulation Functions</h2>

<h2>Bit Manipulation Functions</h2>

<h2>Character Functions</h2>

<h2>Kind Functions</h2>

<h2>Logical Function</h2>

<h1>Fortran - Numeric Precision</h1>

<p>We have already discussed that, in older versions of Fortran, there were two <b>real</b> types: the default real type and <b>double precision</b> type.</p>

<p>However, Fortran 90/95 provides more control over the precision of real and integer data types through the <b>kind</b> specifie.</p>

<h2>The Kind Attribute</h2>

<p>Different kind of numbers are stored differently inside the computer. The <b>kind</b> attribute allows you to specify how a number is stored internally. For example,</p>

<p>In the above declaration, the real variables e, f and g have more precision than the real variables a, b and c. The integer variables l, m and n, can store larger values and have more digits for storage than the integer variables i, j and k. Although this is machine dependent.</p>

<p><b>Example</b></p>

<p>When you compile and execute the above program it produces the following result:</p>

<h2>Inquiring the Size of Variables</h2>

<p>There are a number of intrinsic functions that allows you to interrogate the size of numbers.</p>

<p>For example, the <b>bit_size(i)</b> intrinsic function specifies the number of bits used for storage. For real numbers, the <b>precision(x)</b> intrinsic function, returns the number of decimal digits of precision, while the <b>range(x)</b> intrinsic function returns the decimal range of the exponent.</p>

<p><b>Example</b></p>

<p>When you compile and execute the above program it produces the following result:</p>

<h2>Obtaining the Kind Value</h2>

<p>Fortran provides two more intrinsic functions to obtain the kind value for the required precision of integers and reals:</p>

<p>The selected_real_kind function returns an integer that is the kind type parameter value necessary for a given decimal precision p and decimal exponent range r.  The decimal precision is the number of significant digits, and the decimal exponent range specifies the smallest and largest representable number. The range is thus from 10-r to 10+r.</p>

<p>For example, selected_real_kind (p = 10, r = 99) returns the kind value needed for a precision of 10 decimal places, and a range of at least 10-99 to 10+99.</p>

<p><b>Example</b></p>

<p>When you compile and execute the above program it produces the following result:</p>

<h1>Fortran - Program Libraries</h1>

<p>There are various Fortran tools and libraries. Some are free and some are paid services.</p>

<p>Following are some free libraries:</p>

<p>The following libraries are not free:</p>

<h1>Fortran - Programming Style</h1>

<p>Programming style is all about following some rules while developing programs. These good practices impart values like readability, and unambiguity into your program.</p>

<p>A good program should have the following characteristics:</p>

<p>For example, if you make a comment like the following, it will not be of much help:</p>

<p>However, if you are calculating binomial coefficient, and need this loop for nCr then a comment like this will be helpful:</p>

<p>Indented code blocks to make various levels of code clear.</p>

<p>Self-checking codes to ensure there will be no numerical errors like division by zero, square root of a negative real number or logarithm of a negative real number.</p>

<p>Including codes that ensure variables do not take illegal or out of range values, i.e., input validation.</p>

<p>Not putting checks where it would be unnecessary and slows down the execution. For example:</p>

<h1>Fortran - Debugging Program</h1>

<p>A debugger tool is used to search for errors in the programs.</p>

<p>A debugger program steps through the code and allows you to examine the values in the variables and other data objects during execution of the program.</p>

<p>It loads the source code and you are supposed to run the program within the debugger. Debuggers debug a program by:</p>

<p>Breakpoints specify where the program should stop, specifically after a critical line of code. Program executions after the variables are checked at a breakpoint.</p>

<p>Debugger programs also check the source code line by line.</p>

<p>Watch points are the points where the values of some variables are needed to be checked, particularly after a read or write operation.</p>

<h2>The gdb Debugger</h2>

<p>The gdb debugger, the GNU debugger comes with Linux operating system. For X windows system, gdb comes with a graphical interface and the program is named xxgdb.</p>

<p>Following table provides some commands in gdb:</p>

<h2>The dbx Debugger</h2>

<p>There is another debugger, the dbx debugger, for Linux.</p>

<p>The following table provides some commands in dbx:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
-c Compile only, do not run the linker.
-o Specify the name of the output file, either an object file or the executable.
</pre>
<p>Multiple source and object files can be specified at once. Fortran files are indicated by names ending in ".f", ".F", ".for", ".FOR", ".f90", ".F90", ".f95", ".F95", ".f03" and ".F03". Multiple source files can be specified. Object files can be specified as well and will be linked to form an executable file.</p>
<h1>Fortran - Basic Syntax</h1>
<p>A Fortran program is made of a collection of program units like a main program, modules, and external subprograms or procedures.</p>
<p>Each program contains one main program and may or may not contain other program units. The syntax of the main program is as follows:</p>
<pre class="prettyprint notranslate">
program program_name      
implicit none      
! type declaration statements      
! executable statements  
end program program_name
</pre>
<h2>A Simple Program in Fortran</h2>
<p>Let’s write a program that adds two numbers and prints the result:</p>
<pre class="prettyprint notranslate tryit">
program addNumbers                                          
! This simple program adds two numbers     
   implicit none
! Type declarations
   real :: a, b, result 
! Executable statements 
   a = 12.0
   b = 15.0
   result = a + b
   print *, 'The total is ', result                   
end program addNumbers        
</pre>
<p>When you compile and execute the above program, it produces the following result:</p>
<pre class="prettyprint notranslate">
The total is 27.0000000    
</pre>
<p>Please note that:</p>
<ul class="list">
<li><p>All Fortran programs start with the keyword <b>program</b> and end with the keyword <b>end program,</b> followed by the name of the program.</p></li>
<li><p>The <b>implicit none</b> statement allows the compiler to check that all your variable types are declared properly. You must always use <b>implicit none</b> at the start of every program.</p></li>
<li><p>Comments in Fortran are started with the exclamation mark (!), as all characters after this (except in a character string) are ignored by the compiler.</p></li>
<li><p>The <b>print *</b> command displays data on the screen.</p></li> 
<li><p>Indentation of code lines is a good practice for keeping a program readable.</p></li> 
<li><p>Fortran allows both uppercase and lowercase letters. Fortran is case-insensitive, except for string literals.</p></li> 
</ul>
<h2>Basics</h2>
<p>The <b>basic character set</b> of Fortran contains:</p>
<ul class="list">
<li>the letters A ... Z and a ... z </li>
<li>the digits 0 ... 9</li>
<li>the underscore (_) character</li>
<li>the special characters =  : + blank - * / ( ) [ ] , . $ ' ! "  % &  ; < >  ?</li>
</ul>
<p><b>Tokens</b> are made of characters in the basic character set. A token could be a keyword, an identifier, a constant, a string literal, or a symbol.</p> 
<p>Program statements are made of tokens.</p> 
<h2>Identifier</h2>
<p>An identifier is a name used to identify a variable, procedure, or any other user-defined item. A name in Fortran must follow the following rules:</p>
<ul class="list">
<li><p>It cannot be longer than 31 characters.</p></li>
<li><p>It must be composed of alphanumeric characters (all the letters of the alphabet, and the digits 0 to 9) and underscores (_).</p></li>
<li><p>First character of a name must be a letter.</p></li> 
<li><p>Names are case-insensitive</p></li>
</ul>
<h2>Keywords</h2>
<p>Keywords are special words, reserved for the language. These reserved words cannot be used as identifiers or names.</p>
<p>The following table, lists the Fortran keywords:</p>
<table class="table table-bordered">
<tr>
<th colspan="5">The non-I/O keywords</th>
</tr>
<tr>
<td>allocatable</td>
<td>allocate</td>
<td>assign</td>
<td>assignment</td>
<td>block data</td>
</tr>
<tr>
<td>call</td>
<td>case</td>
<td>character</td>
<td>common</td>
<td>complex</td>
</tr>
<tr>
<td>contains</td>
<td>continue</td>
<td>cycle</td>
<td>data</td>
<td>deallocate</td>
</tr>
<tr>
<td>default</td>
<td>do</td>
<td>double precision</td>
<td>else</td>
<td>else if</td>
</tr>
<tr>
<td>elsewhere</td>
<td>end block data</td>
<td>end do</td>
<td>end function</td>
<td>end if</td>
</tr>
<tr>
<td>end interface</td>
<td>end module</td>
<td>end program</td>
<td>end select</td>
<td>end subroutine</td>
</tr>
<tr>
<td>end type</td>
<td>end where</td>
<td>entry</td>
<td>equivalence</td>
<td>exit</td>
</tr>
<tr>
<td>external</td>
<td>function</td>
<td>go to</td>
<td>if </td>
<td>implicit</td>
</tr>
<tr>
<td>in</td>
<td>inout</td>
<td>integer</td>
<td>intent</td>
<td>interface</td>
</tr>
<tr>
<td>intrinsic</td>
<td>kind</td>
<td>len</td>
<td>logical</td>
<td>module</td>
</tr>
<tr>
<td>namelist</td>
<td>nullify</td>
<td>only</td>
<td>operator</td>
<td>optional</td>
</tr>
<tr>
<td>out</td>
<td>parameter</td>
<td>pause</td>
<td>pointer</td>
<td>private</td>
</tr>
<tr>
<td>program</td>
<td>public</td>
<td>real</td>
<td>recursive</td>
<td>result</td>
</tr>
<tr>
<td>return</td>
<td>save</td>
<td>select case</td>
<td>stop</td>
<td>subroutine</td>
</tr>
<tr>
<td>target</td>
<td>then</td>
<td>type</td>
<td>type()</td>
<td>use</td>
</tr>
<tr>
<td>Where</td>
<td>While</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<th colspan="5">The I/O related keywords</th>
</tr>
<tr>
<td>backspace</td>
<td>close</td>
<td>endfile</td>
<td>format</td>
<td>inquire</td>
</tr>
<tr>
<td>open</td>
<td>print</td>
<td>read</td>
<td>rewind</td>
<td>Write</td>
</tr>
</table>
<h1>Fortran - Data Types</h1>
<p>Fortran provides five intrinsic data types, however, you can derive your own data types as well. The five intrinsic types are:</p>
<ul class="list">
<li>Integer type</li>
<li>Real type</li>
<li>Complex type</li>
<li>Logical type</li>
<li>Character type</li>
</ul>
<h2>Integer Type</h2>
<p>The integer types can hold only integer values. The following example extracts the largest value that can be held in a usual four byte integer:</p>
<pre class="prettyprint notranslate tryit">
program testingInt
implicit none
   integer :: largeval
   print *, huge(largeval)
end program testingInt
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="prettyprint notranslate">
2147483647
</pre>
<p>Note that the <b>huge()</b> function gives the largest number that can be held by the specific integer data type. You can also specify the number of bytes using the <b>kind</b> specifier. The following example demonstrates this:</p>
<pre class="prettyprint notranslate tryit">
program testingInt
implicit none
   !two byte integer
   integer(kind=2) :: shortval
   !four byte integer
   integer(kind=4) :: longval
   !eight byte integer
   integer(kind=8) :: verylongval
   !sixteen byte integer
   integer(kind=16) :: veryverylongval
   !default integer 
   integer :: defval
        
   print *, huge(shortval)
   print *, huge(longval)
   print *, huge(verylongval)
   print *, huge(veryverylongval)
   print *, huge(defval)
end program testingInt
</pre>
<p>When you compile and execute the above program, it produces the following result:</p>
<pre class="prettyprint notranslate">
32767
2147483647
9223372036854775807
170141183460469231731687303715884105727
2147483647
</pre>
<h2>Real Type</h2>
<p>It stores the floating point numbers, such as 2.0,  3.1415, -100.876, etc.</p>
<p>Traditionally there are two different real types, the default <b>real</b> type and <b>double precision</b> type.</p>
<p>However, Fortran 90/95 provides more control over the precision of real and integer data types through the<b>kind</b>specifier, which we will study in the chapter on Numbers.</p>
<p>The following example shows the use of real data type:</p>
<pre class="prettyprint notranslate tryit">
program division   
implicit none  
   ! Define real variables   
   real :: p, q, realRes 
   ! Define integer variables  
   integer :: i, j, intRes  
   ! Assigning  values   
   p = 2.0 
   q = 3.0    
   i = 2 
   j = 3  
   ! floating point division
   realRes = p/q  
   intRes = i/j
   
   print *, realRes
   print *, intRes
end program division  
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="prettyprint notranslate">
0.666666687    
0
</pre>
<h2>Complex Type</h2>
<p>This is used for storing complex numbers. A complex number has two parts, the real part and the imaginary part. Two consecutive numeric storage units store these two parts.</p>
<p>For example, the complex number (3.0, -5.0) is equal to 3.0 – 5.0i</p>
<p>We will discuss Complex types in more detail, in the Numbers chapter.</p> 
<h2>Logical Type</h2>
<p>There are only two logical values: <b>.true.</b> and <b>.false.</b></p>
<h2>Character Type</h2>
<p>The character type stores characters and strings. The length of the string can be specified by len specifier. If no length is specified, it is 1.</p>
<p><b>For example,</b></p> 
<pre class="prettyprint notranslate">
character (len=40) :: name  
name = “Zara Ali”
</pre>
<p>The expression, <b>name(1:4)</b> would give the substring “Zara”.</p> 
<h2>Implicit Typing</h2>
<p>Older versions of Fortran allowed a feature called implicit typing, i.e., you do not have to declare the variables before use. If a variable is not declared, then the first letter of its name will determine its type.</p>
<p>Variable names starting with i, j, k, l, m, or n, are considered to be for integer variable and others are real variables. However, you must declare all the variables as it is good programming practice. For that you start your program with the statement:</p>
<pre class="prettyprint notranslate">
implicit none
</pre>
<p>This statement turns off implicit typing.</p> 
<h1>Fortran - Variables</h1>
<p>A variable is nothing but a name given to a storage area that our programs can manipulate. Each variable should have a specific type, which determines the size and layout of the variable's memory; the range of values that can be stored within that memory; and the set of operations that can be applied to the variable.</p>
<p>The name of a variable can be composed of letters, digits, and the underscore character. A name in Fortran must follow the following rules:</p>
<ul class="list">
<li><p>It cannot be longer than 31 characters.</p></li>
<li><p>It must be composed of alphanumeric characters (all the letters of the alphabet, and the digits 0 to 9) and underscores (_).</p></li>
<li><p>First character of a name must be a letter.</p></li> 
<li><p>Names are case-insensitive.</p></li>   
</ul>
<p>Based on the basic types explained in previous chapter, following are the variable types:</p>
<table class="table table-bordered">
<tr>
<th>Type</th>
<th>Description</th>
</tr>
<tr>
<td>Integer</td>
<td>It can hold only integer values.</td>
</tr>
<tr>
<td>Real</td>
<td>It stores the floating point numbers.</td>
</tr>
<tr>
<td>Complex</td>
<td>It is used for storing complex numbers.</td>
</tr>
<tr>
<td>Logical</td>
<td>It stores logical Boolean values.</td>
</tr>
<tr>
<td>Character</td>
<td>It stores characters or strings.</td>
</tr>
</table>
<h2>Variable Declaration</h2>
<p>Variables are declared at the beginning of a program (or subprogram) in a type declaration statement.</p> 
<p>Syntax for variable declaration is as follows:</p>
<pre class="prettyprint notranslate">
type-specifier :: variable_name
</pre>
<p><b>For example,</b></p>
<pre class="prettyprint notranslate">
integer :: total  	
real :: average 
complex :: cx  
logical :: done 
character(len=80) :: message ! a string of 80 characters
</pre>
<p>Later you can assign values to these variables, like,</p>
<pre class="prettyprint notranslate">
total = 20000  
average = 1666.67   
done = .true.   
message = “A big Hello from Tutorials Point” 
cx = (3.0, 5.0) ! cx = 3.0 + 5.0i
</pre>
<p>You can also use the intrinsic function <b>cmplx,</b> to assign values to a complex variable:</p>
<pre class="prettyprint notranslate">
cx = cmplx (1.0/2.0, -7.0) ! cx = 0.5 – 7.0i 
cx = cmplx (x, y) ! cx = x + yi
</pre>
<p><b>Example</b></p>
<p>The following example demonstrates variable declaration, assignment and display on screen:</p>
<pre class="prettyprint notranslate tryit">
program variableTesting
implicit none

   ! declaring variables
   integer :: total      
   real :: average 
   complex :: cx  
   logical :: done 
   character(len=80) :: message ! a string of 80 characters
   
   !assigning values
   total = 20000  
   average = 1666.67   
   done = .true.   
   message = "A big Hello from Tutorials Point" 
   cx = (3.0, 5.0) ! cx = 3.0 + 5.0i

   Print *, total
   Print *, average
   Print *, cx
   Print *, done
   Print *, message
end program variableTesting
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
20000
1666.67004    
(3.00000000, 5.00000000 )
T
A big Hello from Tutorials Point         
</pre>
<h1>Fortran - Constants</h1>
<p>The constants refer to the fixed values that the program cannot alter during its execution. These fixed values are also called <b>literals</b>.</p>
<p>Constants can be of any of the basic data types like an integer constant, a floating constant, a character constant, a complex constant, or a string literal. There are only two logical constants : <b>.true.</b> and <b>.false.</b></p>
<p>The constants are treated just like regular variables, except that their values cannot be modified after their definition.</p>
<h2>Named Constants and Literals</h2>
<p>There are two types of constants:</p>
<ul class="list">
<li>Literal constants</li>
<li>Named constants</li>
</ul>
<p>A literal constant have a value, but no name.</p>
<p>For example, following are the literal constants:</p>
<table class="table table-bordered">
<tr>
<th>Type</th>
<th>Example</th>
</tr>
<tr>
<td>Integer constants</td>
<td>0 1 -1 300 123456789</td>
</tr>
<tr>
<td>Real constants</td>
<td>0.0 1.0 -1.0 123.456 7.1E+10 -52.715E-30</td>
</tr>
<tr>
<td>Complex constants</td>
<td>(0.0, 0.0) (-123.456E+30, 987.654E-29)</td>
</tr>
<tr>
<td>Logical constants</td>
<td>.true. .false.</td>
</tr>
<tr>
<td>Character constants </td>
<td>
<p>"PQR" "a" "123'abc$%#@!"</p>   
<p>" a quote "" "</p>
<p>'PQR' 'a' '123"abc$%#@!'</p>     
<p>' an apostrophe '' '</p>
</td>
</tr>
</table>
<p>A named constant has a value as well as a name.</p>
<p>Named constants should be declared at the beginning of a program or procedure, just like a variable type declaration, indicating its name and type. Named constants are declared with the parameter attribute. For example,</p>
<pre class="prettyprint notranslate">
real, parameter :: pi = 3.1415927
</pre>
<p><b>Example</b></p>
<p>The following program calculates the displacement due to vertical motion under gravity.</p>
<pre class="prettyprint notranslate tryit">
program gravitationalDisp
! this program calculates vertical motion under gravity 
implicit none  
   ! gravitational acceleration
   real, parameter :: g = 9.81   
   ! variable declaration
   real :: s ! displacement   
   real :: t ! time  
   real :: u ! initial speed  
   ! assigning values 
   t = 5.0   
   u = 50  
   ! displacement   
   s = u * t - g * (t**2) / 2  
   ! output 
   print *, "Time = ", t
   print *, 'Displacement = ',s  
end program gravitationalDisp
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
Time = 5.00000000    
Displacement = 127.374992    
</pre>
<h1>Fortran - Operators</h1>
<p>An operator is a symbol that tells the compiler to perform specific mathematical or logical manipulations. Fortran provides the following types of operators:</p>
<ul class="list">
<li>Arithmetic Operators</li>
<li>Relational Operators</li>
<li>Logical Operators</li>
</ul>
<p>Let us look at all these types of operators one by one.</p>
<h2>Arithmetic Operators</h2>
<p>Following table shows all the arithmetic operators supported by Fortran. Assume variable <b>A</b> holds 5 and variable <b>B</b> holds 3 then:</p>
<p><a href="/fortran/fortran_arithmetic_operators.htm">Show Examples</a></p>
<table class="table table-bordered">
<tr>
<th>Operator</th>
<th>Description</th>
<th>Example</th>
</tr>
<tr>
<td>+</td>
<td>Addition Operator, adds two operands.</td>
<td style="width:24%;">A + B will give 8</td>
</tr>
<tr>
<td>-</td>
<td>Subtraction Operator, subtracts second operand from the first.</td>
<td>A - B will give 2</td>
</tr>
<tr>
<td>*</td>
<td>Multiplication Operator, multiplies both operands.</td>
<td>A * B will give 15</td>
</tr>
<tr>
<td>/</td>
<td>Division Operator, divides numerator by de-numerator.</td>
<td>A / B will give 1</td>
</tr>
<tr>
<td>**</td>
<td>Exponentiation Operator, raises one operand to the power of the other.</td>
<td>A ** B will give 125</td>
</tr>
</table>
<h2>Relational Operators</h2>
<p>Following table shows all the relational operators supported by Fortran. Assume variable <b>A</b> holds 10 and variable <b>B</b> holds 20, then:</p>
<p><a href="/fortran/fortran_relational_operators.htm">Show Examples</a></p>
<table class="table table-bordered">
<tr>
<th>Operator</th>
<th>Equivalent</th>
<th>Description</th>
<th>Example</th>
</tr>
<tr>
<td>==</td>
<td>.eq.</td>
<td>Checks if the values of two operands are equal or not, if yes then condition becomes true.</td>
<td>(A == B) is not true.</td>
</tr>
<tr>
<td>/=</td>
<td>.ne.</td>
<td>Checks if the values of two operands are equal or not, if values are not equal then condition becomes true.</td>
<td>(A != B) is true.</td>
</tr>
<tr>
<td>></td>
<td>.gt.</td>
<td>Checks if the value of left operand is greater than the value of right operand, if yes then condition becomes true.</td>
<td>(A > B) is not true.</td>
</tr>
<tr>
<td><</td>
<td>.lt.</td>
<td>Checks if the value of left operand is less than the value of right operand, if yes then condition becomes true.</td>
<td>(A < B) is true.</td>
</tr>
<tr>
<td>>=</td>
<td>.ge.</td>
<td>Checks if the value of left operand is greater than or equal to the value of right operand, if yes then condition becomes true.</td>
<td>(A >= B) is not true.</td>
</tr>
<tr>
<td><=</td>
<td>.le.</td>
<td>Checks if the value of left operand is less than or equal to the value of right operand, if yes then condition becomes true.</td>
<td>(A <= B) is true.</td>
</tr>
</table>
<h2>Operators Precedence in Fortran</h2>
<p>Operator precedence determines the grouping of terms in an expression. This affects how an expression is evaluated. Certain operators have higher precedence than others; for example, the multiplication operator has higher precedence than the addition operator.</p>
<p>For example, x = 7 + 3 * 2; here, x is assigned 13, not 20 because operator * has higher precedence than +, so it first gets multiplied with 3*2 and then adds into 7.</p>
<p>Here, operators with the highest precedence appear at the top of the table, those with the lowest appear at the bottom. Within an expression, higher precedence operators will be evaluated first.</p>
<p><a href="/fortran/fortran_operators_precedence.htm">Show Examples</a></p>
<table class="table table-bordered">
<tr>
<th>Category</th>
<th>Operator</th>
<th>Associativity</th>
</tr>
<tr>
<td>Logical NOT and negative sign</td>
<td>.not. (-)</td>
<td>Left to right</td>
</tr>
<tr>
<td>Exponentiation</td>
<td>**</td>
<td>Left to right</td>
</tr>
<tr>
<td>Multiplicative</td>
<td>* /</td>
<td>Left to right</td>
</tr>
<tr>
<td>Additive</td>
<td>+ -</td>
<td>Left to right</td>
</tr>
<tr>
<td>Relational</td>
<td>< <= > >=</td>
<td>Left to right</td>
</tr>
<tr>
<td>Equality</td>
<td>== !=</td>
<td>Left to right</td>
</tr>
<tr>
<td>Logical AND</td>
<td>.and.</td>
<td>Left to right</td>
</tr>
<tr>
<td>Logical OR</td>
<td>.or.</td>
<td>Left to right</td>
</tr>
<tr>
<td>Assignment</td>
<td>=</td>
<td>Right to left</td>
</tr>
</table>
<h1>Fortran - Decisions</h1>
<p>Decision making structures require that the programmer specify one or more conditions to be evaluated or tested by the program, along with a statement or statements to be executed, if the condition is determined to be true, and optionally, other statements to be executed if the condition is determined to be false.</p>
<p>Following is the general form of a typical decision making structure found in most of the programming languages:</p>
<img src="/fortran/images/decision_making.jpg" alt="Decision Making" />
<p>Fortran provides the following types of decision making constructs.</p>
<table class="table table-bordered">
<tr>
<th>Statement</th>
<th>Description</th>
</tr>
<tr>
<td style="width:30%;"><a href="/fortran/If_then_construct.htm">If… then construct</a></td>
<td>An <b>if… then… end if</b> statement consists of a logical expression followed by one or more statements.</td>
</tr>
<tr>
<td><a href="/fortran/If_then_else_construct.htm">If… then...else construct</a></td>
<td>An <b>if… then</b> statement can be followed by an optional <b>else statement,</b> which executes when the logical expression is false.</td>
</tr>
<tr>
<td><a href="/fortran/nested_if_construct.htm">nested if construct</a></td>
<td>You can use one <b>if</b> or <b>else if</b> statement inside another <b>if</b> or <b>else if</b> statement(s).</td>
</tr>
<tr>
<td><a href="/fortran/select_case_construct.htm">select case construct</a></td>
<td>A <b>select case</b> statement allows a variable to be tested for equality against a list of values.</td>
</tr>
<tr>
<td style="width:35%;"><a href="/fortran/nested_select_case_construct.htm">nested select case construct</a></td>
<td>You can use one <b>select case</b> statement inside another <b>select case</b> statement(s).</td>
</tr>
</table>
<h2>Fortran - if...else if...else Statement</h2>
<p>An <b>if</b> statement construct can have one or more optional <b>else-if</b>  constructs.  When the <b>if</b> condition fails, the immediately followed <b>else-if</b> is executed.  When the <b>else-if</b> also fails, its successor <b>else-if</b> statement (if any) is executed, and so on.</p>
<p>The optional else is placed at the end and it is executed when none of the above conditions hold true.</p>
<ul class="list">
<li>All else statements (else-if and else) are optional.</li>
<li><b>else-if</b> can be used one or more times</li>
<li><b>else</b> must always be placed at the end of construct and should appear only once.</li>
</ul>
<h3>Syntax:</h3>
<p>The syntax of an <b>if...else if...else</b> statement is:</p>
<pre class="prettyprint notranslate">
[name:] 
if (logical expression 1) then 
   ! block 1   
else if (logical expression 2) then       
   ! block 2   
else if (logical expression 3) then       
   ! block 3  
else       
   ! block 4   
end if [name]
</pre>
<p><b>Example</b></p>
<pre class="prettyprint notranslate tryit">
program ifElseIfElseProg
implicit none
   ! local variable declaration
   integer :: a = 100
 
   ! check the logical condition using if statement
   if( a == 10 ) then
  
   ! if condition is true then print the following 
   print*, "Value of a is 10" 
   
   else if( a == 20 ) then
  
   ! if else if condition is true 
   print*, "Value of a is 20" 
  
   else if( a == 30 ) then
   
   ! if else if condition is true  
   print*, "Value of a is 30" 
  
   else
   
   ! if none of the conditions is true 
   print*, "None of the values is matching" 
   end if
   
   print*, "exact value of a is ", a
 
end program ifElseIfElseProg
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
None of the values is matching
exact value of a is 100
</pre>
<h1>Fortran - Loops</h1>
<p>There may be a situation, when you need to execute a block of code several number of times. In general, statements are executed sequentially : The first statement in a function is executed first, followed by the second, and so on.</p>
<P>Programming languages provide various control structures that allow for more complicated execution paths.</p>
<p>A loop statement allows us to execute a statement or group of statements multiple times and following is the general form of a loop statement in most of the programming languages:</p>
<img src="/fortran/images/if_conditional.jpg" alt="If Conditional" />
<p>Fortran provides the following types of loop constructs to handle looping requirements. Click the following links to check their detail.</p>
<table class="table table-bordered">
<tr>
<th style="width:18%">Loop Type</th>
<th>Description</th>
</tr>
<tr>
<td><a href="/fortran/fortran_do_loop.htm">do loop</a></td>
<td>This construct enables a statement, or a series of statements, to be carried out iteratively, while a given condition is true.</td>
</tr>
<tr>
<td><a href="/fortran/fortran_do_while_loop.htm">do while loop</a></td>
<td>Repeats a statement or group of statements while a given condition is true. It tests the condition before executing the loop body.</td>
</tr>
<tr>
<td><a href="/fortran/fortran_nested_loop.htm">nested loops</a></td>
<td>You can use one or more loop construct inside any other loop construct.</td>
</tr>
</table>
<h2>Loop Control Statements</h2>
<p>Loop control statements change execution from its normal sequence. When execution leaves a scope, all automatic objects that were created in that scope are destroyed.</p>
<p>Fortran supports the following control statements. Click the following links to check their detail.</p>
<table class="table table-bordered">
<tr>
<th style="width:25%">Control Statement</th>
<th>Description</th>
</tr>
<tr>
<td><a href="/fortran/fortran_exit.htm">exit</a></td>
<td>If the exit statement is executed, the loop is exited, and the execution of the program continues at the first executable statement after the end do statement.</td>
</tr>
<tr>
<td><a href="/fortran/fortran_cycle.htm">cycle</a></td>
<td>If a cycle statement is executed, the program continues at the start of the next iteration.</td>
</tr>
<tr>
<td><a href="/fortran/fortran_stop.htm">stop</a></td>
<td>If you wish execution of your program to stop, you can insert a stop statement</td>
</tr>
</table>
<h1>Fortran - Numbers</h1>
<p>Numbers in Fortran are represented by three intrinsic data types:</p>
<ul class="list">
<li>Integer type</li>
<li>Real type</li>
<li>Complex type</li>
</ul>
<h2>Integer Type</h2>
<p>The integer types can hold only integer values. The following example extracts the largest value that could be hold in a usual four byte integer:</p>
<pre class="prettyprint notranslate tryit">
program testingInt
implicit none
   integer :: largeval
   print *, huge(largeval)
end program testingInt
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="prettyprint notranslate">
2147483647
</pre>
<p>Please note that the <b>huge()</b> function gives the largest number that can be held by the specific integer data type. You can also specify the number of bytes using the <b>kind</b> specifier. The following example demonstrates this:</p>
<pre class="prettyprint notranslate tryit">
program testingInt
implicit none
   !two byte integer
   integer(kind=2) :: shortval
   !four byte integer
   integer(kind=4) :: longval
   !eight byte integer
   integer(kind=8) :: verylongval
   !sixteen byte integer
   integer(kind=16) :: veryverylongval
   !default integer 
   integer :: defval
        
   print *, huge(shortval)
   print *, huge(longval)
   print *, huge(verylongval)
   print *, huge(veryverylongval)
   print *, huge(defval)
end program testingInt
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="prettyprint notranslate">
32767
2147483647
9223372036854775807
170141183460469231731687303715884105727
2147483647
</pre>
<h2>Real Type</h2>
<p>It stores the floating point numbers, such as 2.0, 3.1415, -100.876, etc.</p>
<p>Traditionally there were two different <b>real</b> types : the default real type and <b>double precision</b> type.</p>
<p>However, Fortran 90/95 provides more control over the precision of real and integer data types through the <b>kind</b> specifier, which we will study shortly.</p> 
<p>The following example shows the use of real data type:</p>
<pre class="prettyprint notranslate tryit">
program division   
implicit none  
   ! Define real variables   
   real :: p, q, realRes 
   ! Define integer variables  
   integer :: i, j, intRes  
   ! Assigning  values   
   p = 2.0 
   q = 3.0    
   i = 2 
   j = 3  
   ! floating point division
   realRes = p/q  
   intRes = i/j
   
   print *, realRes
   print *, intRes
end program division  
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="prettyprint notranslate">
0.666666687    
0
</pre>
<h2>Complex Type</h2>
<p>This is used for storing complex numbers. A complex number has two parts : the real part and the imaginary part. Two consecutive numeric storage units store these two parts.</p> 
<p>For example, the complex number (3.0, -5.0) is equal to 3.0 – 5.0i</p>
<p>The generic function <b>cmplx()</b> creates a complex number. It produces a result who’s real and imaginary parts are single precision, irrespective of the type of the input arguments.</p>
<pre class="prettyprint notranslate tryit">
program createComplex
implicit none
   integer :: i = 10
   real :: x = 5.17
   print *, cmplx(i, x)
end program createComplex
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="prettyprint notranslate">
(10.0000000, 5.17000008)
</pre>
<p>The following program demonstrates complex number arithmetic:</p>
<pre class="prettyprint notranslate tryit">
program ComplexArithmatic
implicit none
   complex, parameter :: i = (0, 1)   ! sqrt(-1)   
   complex :: x, y, z 
   x = (7, 8); 
   y = (5, -7)   
   write(*,*) i * x * y
   z = x + y
   print *, "z = x + y = ", z
   z = x - y
   print *, "z = x - y = ", z 
   z = x * y
   print *, "z = x * y = ", z 
   z = x / y
   print *, "z = x / y = ", z 
end program ComplexArithmatic
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="prettyprint notranslate">
(9.00000000, 91.0000000)
z = x + y = (12.0000000, 1.00000000)
z = x - y = (2.00000000, 15.0000000)
z = x * y = (91.0000000, -9.00000000)
z = x / y = (-0.283783793, 1.20270276)
</pre>
<h2>The Range, Precision and Size of Numbers</h2>
<p>The range on integer numbers, the precision and the size of floating point numbers depends on the number of bits allocated to the specific data type.</p>
<p>The following table displays the number of bits and range for integers:</p>
<table class="table table-bordered">
<tr>
<th>Number of bits</th>
<th>Maximum value</th>
<th>Reason</th>
</tr>
<tr>
<td>64</td>
<td>9,223,372,036,854,774,807</td>
<td>(2**63)–1</td>
</tr>
<tr>
<td>32</td>
<td>2,147,483,647</td>
<td>(2**31)–1</td>
</tr>
</table>
<p>The following table displays the number of bits, smallest and largest value, and the precision for real numbers.</p>
<table class="table table-bordered">
<tr>
<th>Number of bits</th>
<th>Largest value</th>
<th>Smallest value</th>
<th>Precision</th>
</tr>
<tr>
<td>64</td>
<td>0.8E+308</td>
<td>0.5E–308</td>
<td>15–18</td>
</tr>
<tr>
<td>32</td>
<td>1.7E+38</td>
<td>0.3E–38</td>
<td>6-9</td>
</tr>
</table>
<p>The following examples demonstrate this:</p>
<pre class="prettyprint notranslate tryit">
program rangePrecision
implicit none
real:: x, y, z
x = 1.5e+40
y = 3.73e+40
z = x * y 
print *, z
end program rangePrecision
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="prettyprint notranslate">
x = 1.5e+40
    1
Error : Real cos its kind at (1)
main.f95:5.12:

y = 3.73e+40
    1
Error : Real constant overflows its kind at (1)
</pre>
<p>Now let us use a smaller number:</p>
<pre class="prettyprint notranslate tryit">
program rangePrecision
implicit none
real:: x, y, z
x = 1.5e+20
y = 3.73e+20
z = x * y 
print *, z
z = x/y
print *, z
end program rangePrecision
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="prettyprint notranslate">
Infinity
0.402144760   
</pre>
<p>Now let’s watch underflow:</p>
<pre class="prettyprint notranslate tryit">
program rangePrecision
implicit none
real:: x, y, z
x = 1.5e-30
y = 3.73e-60
z = x * y 
print *, z
z = x/y
print *, z
end program rangePrecision
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="prettyprint notranslate">
y = 3.73e-60
    1
Warning : Real constant underflows its kind at (1)

Executing the program....
$demo 

0.00000000E+00
Infinity
</pre>
<h2>The Kind Specifier</h2>
<p>In scientific programming, one often needs to know the range and precision of data of the hardware platform on which the work is being done.</p>
<p>The intrinsic function <b>kind()</b> allows you to query the details of the hardware’s data representations before running a program.</p>
<pre class="prettyprint notranslate tryit">
program kindCheck
implicit none
   integer :: i 
   real :: r 
   complex :: cp 
   print *,' Integer ', kind(i) 
   print *,' Real ', kind(r) 
   print *,' Complex ', kind(cp) 
end program kindCheck
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="prettyprint notranslate">
Integer 4
Real 4
Complex 4
</pre>
<p>You can also check the kind of all data types:</p>
<pre class="prettyprint notranslate tryit">
program checkKind
implicit none
   integer :: i 
   real :: r 
   character*1 :: c 
   logical :: lg 
   complex :: cp 
   print *,' Integer ', kind(i) 
   print *,' Real ', kind(r) 
   print *,' Complex ', kind(cp)
   print *,' Character ', kind(c) 
   print *,' Logical ', kind(lg)
end program checkKind
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="prettyprint notranslate">
Integer 4
Real 4
Complex 4
Character 1
Logical 4
</pre>
<h1>Fortran - Characters</h1>
<p>The Fortran language can treat characters as single character or contiguous strings. </p>
<p>Characters could be any symbol taken from the basic character set, i.e., from the letters, the decimal digits, the underscore, and 21 special characters.</p>
<p>A character constant is a fixed valued character string.</p>
<p>The intrinsic data type <b>character</b> stores characters and strings. The length of the string can be specified by <b>len</b> specifier. If no length is specified, it is 1. You can refer individual characters within a string referring by position; the left most character is at position 1.</p>
<h2>Character Declaration</h2>
<p>Declaring a character type data is same as other variables:</p>
<pre class="prettyprint notranslate">
type-specifier :: variable_name
</pre>
<p>For example,</p>
<pre class="prettyprint notranslate">
character :: reply, sex
</pre>
<p>you can assign a value like,</p>
<pre class="prettyprint notranslate">
reply = ‘N’ 
sex = ‘F’
</pre>
<p>The following example demonstrates declaration and use of character data type:</p>
<pre class="prettyprint notranslate tryit">
program hello
implicit none
   character(len=15) :: surname, firstname 
   character(len=6) :: title 
   character(len=25)::greetings
   title = 'Mr. ' 
   firstname = 'Rowan ' 
   surname = 'Atkinson'
   greetings = 'A big hello from Mr. Bean'
   print *, 'Here is ', title, firstname, surname
   print *, greetings
end program hello
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="prettyprint notranslate">
Here is Mr. Rowan Atkinson       
A big hello from Mr. Bean
</pre>
<h2>Concatenation of Characters</h2>
<p>The concatenation operator //, concatenates characters.</p>
<p>The following example demonstrates this:</p>
<pre class="prettyprint notranslate tryit">
program hello
implicit none
   character(len=15) :: surname, firstname 
   character(len=6) :: title 
   character(len=40):: name
   character(len=25)::greetings
   title = 'Mr. ' 
   firstname = 'Rowan ' 
   surname = 'Atkinson'
   name = title//firstname//surname
   greetings = 'A big hello from Mr. Bean'
   print *, 'Here is ', name
   print *, greetings
end program hello
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="prettyprint notranslate">
Here is Mr.Rowan Atkinson       
A big hello from Mr.Bean
</pre>
<h2>Some Character Functions</h2>
<p>The following table shows some commonly used character functions along with the description:</p>
<table class="table table-bordered">
<tr>
<th>Function</th>
<th>Description</th>
</tr>
<tr>
<td>len(string)</td>
<td>It returns the length of a character string</td>
</tr>
<tr>
<td>index(string,sustring)</td>
<td>It ﬁnds the location of a substring in another string, returns 0 if not found.</td>
</tr>
<tr>
<td>achar(int)</td>
<td>It converts an integer into a character</td>
</tr>
<tr>
<td>iachar(c)</td>
<td>It converts a character into an integer</td>
</tr>
<tr>
<td>trim(string)</td>
<td>It returns the string with the trailing blanks removed.</td>
</tr>
<tr>
<td>scan(string, chars)</td>
<td>It searches the "string" from left to right (unless back=.true.) for the first occurrence of any character contained in "chars". It returns an integer giving the position of that character, or zero if none of the characters in "chars" have been found.</td>
</tr>
<tr>
<td>verify(string, chars)</td>
<td>It scans the "string" from left to right (unless back=.true.) for the first occurrence of any character not contained in "chars". It returns an integer giving the position of that character, or zero if only the characters in "chars" have been found</td>
</tr>
<tr>
<td>adjustl(string)</td>
<td>It left justifies characters contained in the "string"</td>
</tr>
<tr>
<td>adjustr(string)</td>
<td>It right justifies characters contained in the "string"</td>
</tr>
<tr>
<td>len_trim(string)</td>
<td>It returns an integer equal to the length of "string" (len(string)) minus the number of trailing blanks</td>
</tr>
<tr>
<td>repeat(string,ncopy)</td>
<td>It returns a string with length equal to "ncopy" times the length of "string", and containing "ncopy" concatenated copies of "string"</td>
</tr>
</table>
<p><b>Example 1</b></p>
<p>This example shows the use of the <b>index</b> function:</p> 
<pre class="prettyprint notranslate tryit">
program testingChars
implicit none
   character (80) :: text 
   integer :: i 
   text = 'The intrinsic data type character stores characters and   strings.'
   i=index(text,'character') 
   if (i /= 0) then
   print *, ' The word character found at position ',i 
   print *, ' in text: ', text 
   end if
end program testingChars
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="prettyprint notranslate">
The word character found at position 25
in text : The intrinsic data type character stores characters and strings.  
</pre>
<p><b>Example 2</b></p>
<p>This example demonstrates the use of the <b>trim</b> function:</p>
<pre class="prettyprint notranslate tryit">
program hello
implicit none
   character(len=15) :: surname, firstname 
   character(len=6) :: title 
   character(len=25)::greetings
   title = 'Mr.' 
   firstname = 'Rowan' 
   surname = 'Atkinson'
   print *, 'Here is', title, firstname, surname
   print *, 'Here is', trim(title),' ',trim(firstname),' ', trim(surname)
 end program hello
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="prettyprint notranslate">
Here is Mr. Rowan Atkinson       
Here is Mr. Rowan Atkinson
</pre>
<p><b>Example 3</b></p>
<p>This example demonstrates the use of <b>achar</b> function</p>
<pre class="prettyprint notranslate tryit">
program testingChars
implicit none
   character:: ch
   integer:: i
   do i=65, 90
   ch = achar(i)
   print*, i, ' ', ch
   end do
end program testingChars
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="prettyprint notranslate">
65  A
66  B
67  C
68  D
69  E
70  F
71  G
72  H
73  I
74  J
75  K
76  L
77  M
78  N
79  O
80  P
81  Q
82  R
83  S
84  T
85  U
86  V
87  W
88  X
89  Y
90  Z
</pre>
<h2>Checking Lexical Order of Characters</h2>
<p>The following functions determine the lexical sequence of characters:</p>
<table class="table table-bordered">
<tr>
<th style="width:20%">Function</th>
<th>Description</th>
</tr>
<tr>
<td>lle(char, char)</td>
<td>Compares whether the first character is lexically less than or equal to the second</td>
</tr>
<tr>
<td>lge(char, char)</td>
<td>Compares whether the first character is lexically greater than or equal to the second</td>
</tr>
<tr>
<td>lgt(char, char)</td>
<td>Compares whether the first character is lexically greater than the second</td>
</tr>
<tr>
<td>llt(char, char)</td>
<td>Compares whether the first character is lexically less than the second</td>
</tr>
</table>
<p><b>Example 4</b></p>
<p>The following function demonstrates the use:</p>
<pre class="prettyprint notranslate tryit">
program testingChars
implicit none
   character:: a, b, c
   a = 'A'
   b = 'a'
   c = 'B'
   
   if(lgt(a,b)) then
   print *, 'A is lexically greater than a'
   else
   print *, 'a is lexically greater than A'
   end if
   if(lgt(a,c)) then
   print *, 'A is lexically greater than B'
   else
   print *, 'B is lexically greater than A'
   end if  
   if(llt(a,b)) then
   print *, 'A is lexically less than a'
   end if
   if(llt(a,c)) then
   print *, 'A is lexically less than B'
   end if
end program testingChars
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="prettyprint notranslate">
a is lexically greater than A
B is lexically greater than A
A is lexically less than a
A is lexically less than B
</pre>
<h1>Fortran - Strings</h1>
<p>The Fortran language can treat characters as single character or contiguous strings.</p>
<p>A character string may be only one character in length, or it could even be of zero length. In Fortran, character constants are given between a pair of double or single quotes.</p>
<p>The intrinsic data type <b>character</b> stores characters and strings. The length of the string can be specified by <b>len specifier</b>. If no length is specified, it is 1. You can refer individual characters within a string referring by position; the left most character is at position 1.</p>
<h2>String Declaration</h2>
<p>Declaring a string is same as other variables:</p>
<pre class="prettyprint notranslate">
type-specifier :: variable_name
</pre>
<p>For example,</p>
<pre class="prettyprint notranslate">
Character(len=20) :: firstname, surname
</pre>
<p>you can assign a value like,</p>
<pre class="prettyprint notranslate">
character (len=40) :: name  
name = “Zara Ali”
</pre>
<p>The following example demonstrates declaration and use of character data type:</p>
<pre class="prettyprint notranslate tryit">
program hello
implicit none
   character(len=15) :: surname, firstname 
   character(len=6) :: title 
   character(len=25)::greetings
   title = 'Mr.' 
   firstname = 'Rowan' 
   surname = 'Atkinson'
   greetings = 'A big hello from Mr. Beans'
   print *, 'Here is', title, firstname, surname
   print *, greetings
end program hello
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="prettyprint notranslate">
Here is Mr. Rowan Atkinson       
 A big hello from Mr. Bean
</pre>
<h2>String Concatenation</h2>
<p>The concatenation operator //, concatenates strings.</p>
<p>The following example demonstrates this:</p>
<pre class="prettyprint notranslate tryit">
program hello
implicit none
   character(len=15) :: surname, firstname 
   character(len=6) :: title 
   character(len=40):: name
   character(len=25)::greetings
   title = 'Mr.' 
   firstname = 'Rowan' 
   surname = 'Atkinson'
   name = title//firstname//surname
   greetings = 'A big hello from Mr. Beans'
   print *, 'Here is', name
   print *, greetings
end program hello
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="prettyprint notranslate">
Here is Mr. Rowan Atkinson       
 A big hello from Mr. Bean
</pre>
<h2>Extracting Substrings</h2>
<p>In Fortran, you can extract a substring from a string by indexing the string, giving the start and the end index of the substring in a pair of brackets. This is called extent specifier.</p>
<p>The following example shows how to extract the substring ‘world’ from the string ‘hello world’:</p>
<pre class="prettyprint notranslate tryit">
program subString
   character(len=11)::hello
   hello = "Hello World"
   print*, hello(7:11)
end program subString 
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="prettyprint notranslate">
World
</pre>
<p><b>Example</b></p>
<p>The following example uses the <b>date_and_time</b> function to give the date and time string. We use extent specifiers to extract the year, date, month, hour, minutes and second information separately.</p>
<pre class="prettyprint notranslate">
program  datetime
   implicit none

   character(len = 8) :: dateinfo ! ccyymmdd
   character(len = 4) :: year, month*2, day*2

   character(len = 10) :: timeinfo ! hhmmss.sss
   character(len = 2)  :: hour, minute, second*6

   call  date_and_time(dateinfo, timeinfo)

!  let’s break dateinfo into year, month and day.
!  dateinfo has a form of ccyymmdd, where cc = century, yy = year
!  mm = month and dd = day

   year  = dateinfo(1:4)
   month = dateinfo(5:6)
   day   = dateinfo(7:8)

   print*, 'Date String:', dateinfo
   print*, 'Year:', year
   print *,'Month:', month
   print *,'Day:', day

!  let’s break timeinfo into hour, minute and second.
!  timeinfo has a form of hhmmss.sss, where h = hour, m = minute
!  and s = second

   hour   = timeinfo(1:2)
   minute = timeinfo(3:4)
   second = timeinfo(5:10)

   print*, 'Time String:', timeinfo
   print*, 'Hour:', hour
   print*, 'Minute:', minute
   print*, 'Second:', second   
end program  datetime
</pre>
<p>When you compile and execute the above program, it gives the detailed date and time information:</p>
<pre class="prettyprint notranslate">
Date String: 20140803
   Year: 2014
   Month: 08
   Day: 03
   Time String: 075835.466
   Hour: 07
   Minute: 58
	Second: 35.466
</pre>
<h2>Trimming Strings</h2>
<p>The <b>trim</b> function takes a string, and returns the input string after removing all trailing blanks.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate tryit">
program trimString
implicit none
   character (len=*), parameter :: fname="Susanne", sname="Rizwan"
   character (len=20) :: fullname 
   fullname=fname//" "//sname !concatenating the strings
   print*,fullname,", the beautiful dancer from the east!"
   print*,trim(fullname),", the beautiful dancer from the east!"
end program trimString
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="prettyprint notranslate">
Susanne Rizwan      , the beautiful dancer from the east!
 Susanne Rizwan, the beautiful dancer from the east!
</pre>
<h2>Left and Right Adjustment of Strings</h2>
<p>The function <b>adjustl</b> takes a string and returns it by removing the leading blanks and appending them as trailing blanks.</p>
<p>The function <b>adjustr</b> takes a string and returns it by removing the trailing blanks and appending them as leading blanks.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate tryit">
program hello
implicit none
   character(len=15) :: surname, firstname 
   character(len=6) :: title 
   character(len=40):: name
   character(len=25):: greetings
   title = 'Mr. ' 
   firstname = 'Rowan' 
   surname = 'Atkinson'
   greetings = 'A big hello from Mr. Beans'
   name = adjustl(title)//adjustl(firstname)//adjustl(surname)
   print *, 'Here is', name
   print *, greetings
   
   name = adjustr(title)//adjustr(firstname)//adjustr(surname)
   print *, 'Here is', name
   print *, greetings
   
   name = trim(title)//trim(firstname)//trim(surname)
   print *, 'Here is', name
   print *, greetings
end program hello
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="prettyprint notranslate">
Here is Mr. Rowan  Atkinson           
A big hello from Mr. Bean
Here is Mr. Rowan Atkinson    
A big hello from Mr. Bean
Here is Mr.RowanAtkinson                        
A big hello from Mr. Bean
</pre>
<h2>Searching for a Substring in a String</h2>
<p>The index function takes two strings and checks if the second string is a substring of the first string. If the second argument is a substring of the first argument, then it returns an integer which is the starting index of the second string in the first string, else it returns zero.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate tryit">
program hello
implicit none
   character(len=30) :: myString
   character(len=10) :: testString
   myString = 'This is a test'
   testString = 'test'
   
   if(index(myString, testString) == 0)then
   print *, 'test is not found'
   else
   print *, 'test is found at index: ', index(myString, testString)
   end if
   
end program hello
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="prettyprint notranslate">
test is found at index: 11
</pre>
<h1>Fortran - Arrays</h1>
<p>Arrays can store a fixed-size sequential collection of elements of the same type. An array is used to store a collection of data, but it is often more useful to think of an array as a collection of variables of the same type.</p>
<p>All arrays consist of contiguous memory locations. The lowest address corresponds to the first element and the highest address to the last element.</p>
<table class="table table-bordered">
<tr>
<td>Numbers(1)</td>
<td>Numbers(2)</td>
<td>Numbers(3)</td>
<td>Numbers(4)</td>
<td>…</td>
</tr>
</table>
<p>Arrays can be one- dimensional (like vectors), two-dimensional (like matrices) and Fortran allows you to create up to 7-dimensional arrays.</p>
<h2>Declaring Arrays</h2>
<p>Arrays are declared with the <b>dimension</b> attribute.</p>
<p>For example, to declare a one-dimensional array named number, of real numbers containing 5 elements, you write,</p>
<pre class="prettyprint notranslate">
real, dimension(5) :: numbers
</pre>
<p>The individual elements of arrays are referenced by specifying their subscripts. The first element of an array has a subscript of one. The array numbers contains five real variables –numbers(1), numbers(2), numbers(3), numbers(4), and numbers(5).</p>
<p>To create a 5 x 5 two-dimensional array of integers named matrix, you write:</p>
<pre class="prettyprint notranslate">
integer, dimension (5,5) :: matrix  
</pre>
<p>You can also declare an array with some explicit lower bound, for example:</p>
<pre class="prettyprint notranslate">
real, dimension(2:6) :: numbers
integer, dimension (-3:2,0:4) :: matrix  
</pre>
<h2>Assigning Values</h2>
<p>You can either assign values to individual members, like,</p>
<pre class="prettyprint notranslate">
numbers(1) = 2.0
</pre>
<p>or, you can use a loop,</p>
<pre class="prettyprint notranslate">
do i=1,5
   numbers(i) = i * 2.0
end do
</pre>
<p>One dimensional array elements can be directly assigned values using a short hand symbol, called array constructor, like,</p>
<pre class="prettyprint notranslate">
numbers = (/1.5, 3.2,4.5,0.9,7.2 /)
</pre>
<p><b>please note that there are no spaces allowed between the brackets ‘( ‘and the back slash ‘/’</b></p>
<p><b>Example</b></p>
<p>The following example demonstrates the concepts discussed above.</p>
<pre class="prettyprint notranslate tryit">
program arrayProg
   real :: numbers(5) !one dimensional integer array
   integer :: matrix(3,3), i , j !two dimensional real array
   
   !assigning some values to the array numbers
   do i=1,5
   numbers(i) = i * 2.0
   end do
   !display the values
   do i = 1, 5
   Print *, numbers(i)
   end do
   !assigning some values to the array matrix
   do i=1,3
   do j = 1, 3
   matrix(i, j) = i+j
   end do
   end do
   !display the values
   do i=1,3
   do j = 1, 3
   Print *, matrix(i,j)
   end do
   end do
   !short hand assignment
   numbers = (/1.5, 3.2,4.5,0.9,7.2 /)
   !display the values
   do i = 1, 5
   Print *, numbers(i)
   end do
end program arrayProg
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
 2.00000000    
 4.00000000    
 6.00000000    
 8.00000000    
 10.0000000    
         2
         3
         4
         3
         4
         5
         4
         5
         6
 1.50000000    
 3.20000005    
 4.50000000    
0.899999976    
 7.19999981    
</pre>
<h2>Some Array Related Terms</h2>
<p>The following table gives some array related terms:</p>
<table class="table table-bordered">
<tr>
<th>Term</th>
<th>Meaning</th>
</tr>
<tr>
<td>Rank</td>
<td>It is the number of dimensions an array has. For example, for the array named matrix, rank is 2, and for the array named numbers, rank is 1.</td>
</tr>
<tr>
<td>Extent</td>
<td>It is the number of elements along a dimension. For example, the array numbers has extent 5 and the array named matrix has extent 3 in both dimensions.</td>
</tr>
<tr>
<td>Shape</td>
<td>The shape of an array is a one-dimensional integer array, containing the number of elements (the extent) in each dimension. For example, for the array matrix, shape is (3, 3) and the array numbers it is (5).</td>
</tr>
<tr>
<td>Size</td>
<td>It is the number of elements an array contains. For the array matrix, it is 9, and for the array numbers, it is 5.</td>
</tr>
</table>
<h2>Passing Arrays to Procedures</h2>
<p>You can pass an array to a procedure as an argument. The following example demonstrates the concept:</p>
<pre class="prettyprint notranslate tryit">
program arrayToProcedure      
implicit none      
   integer, dimension (5) :: myArray  
   integer :: i
   call fillArray (myArray)      
   call printArray(myArray)
end program arrayToProcedure

subroutine fillArray (a)      
implicit none      
   integer, dimension (5), intent (out) :: a      
   ! local variables     
   integer :: i     
   do i = 1, 5         
   a(i) = i      
   end do  
end subroutine fillArray 

subroutine printArray(a)
   integer, dimension (5) :: a  
   integer::i
   do i = 1, 5
   Print *, a(i)
   end do
end subroutine printArray
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
1
2
3
4
5
</pre>
<p>In the above example, the subroutine fillArray and printArray can only be called with arrays with dimension 5. However, to write subroutines that can be used for arrays of any size, you can rewrite it using the following technique:</p>
<pre class="prettyprint notranslate tryit">
program arrayToProcedure      
implicit  none      
   integer, dimension (10) :: myArray  
   integer :: i
   
   interface 
   subroutine fillArray (a)
   integer, dimension(:), intent (out) :: a 
   integer :: i         
   end subroutine fillArray      
       
   subroutine printArray (a)
   integer, dimension(:) :: a 
   integer :: i         
   end subroutine printArray   
   end interface 
   call fillArray (myArray)      
   call printArray(myArray)
end program arrayToProcedure

subroutine fillArray (a)      
implicit none      
   integer,dimension (:), intent (out) :: a      
   ! local variables     
   integer :: i, arraySize  
   arraySize = size(a)
   do i = 1, arraySize         
   a(i) = i      
   end do  
end subroutine fillArray 

subroutine printArray(a)
implicit none
   integer,dimension (:) :: a  
   integer::i, arraySize
   arraySize = size(a)
   do i = 1, arraySize
   Print *, a(i)
   end do
end subroutine printArray
</pre>
<p>Please note that the program is using the <b>size</b> function to get the size of the array.</p>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
1
2
3
4
5
6
7
8
9
10
</pre>
<h2>Array Sections</h2>
<p>So far we have referred to the whole array, Fortran provides an easy way to refer several elements, or a section of an array, using a single statement.</p>
<p>To access an array section, you need to provide the lower and the upper bound of the section, as well as a stride (increment), for all the dimensions. This notation is called a <b>subscript triplet:</b></p>
<pre class="prettyprint notranslate">
array ([lower]:[upper][:stride], ...)
</pre>
<p>When no lower and upper bounds are mentioned, it defaults to the extents you declared, and stride value defaults to 1.</p>
<p>The following example demonstrates the concept:</p>
<pre class="prettyprint notranslate tryit">
program arraySubsection
   real, dimension(10) :: a, b
   integer:: i, asize, bsize
   a(1:7) = 5.0 ! a(1) to a(7) assigned 5.0
   a(8:) = 0.0  ! rest are 0.0 
   b(2:10:2) = 3.9
   b(1:9:2) = 2.5
   
   !display
   asize = size(a)
   bsize = size(b)
   do i = 1, asize
   Print *, a(i)
   end do
   do i = 1, bsize
   Print *, b(i)
   end do
end program arraySubsection
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
5.00000000    
5.00000000    
5.00000000    
5.00000000    
5.00000000    
5.00000000    
5.00000000    
0.00000000E+00
0.00000000E+00
0.00000000E+00
2.50000000    
3.90000010    
2.50000000    
3.90000010    
2.50000000    
3.90000010    
2.50000000    
3.90000010    
2.50000000    
3.90000010 
</pre>
<h2>Array Intrinsic Functions</h2>
<p>Fortran 90/95 provides several intrinsic procedures. They can be divided into 7 categories.</p>
<ul class="list">
<li><p><a href="/fortran/vector_and_matrix_multiplication.htm">Vector and matrix multiplication</a></p></li>
<li><p><a href="/fortran/reduction.htm">Reduction</a></p></li>
<li><p><a href="/fortran/inquiry.htm">Inquiry</a></p></li>
<li><p><a href="/fortran/construction.htm">Construction</a></p></li>
<li><p><a href="/fortran/reshape.htm">Reshape</a></p></li>
<li><p><a href="/fortran/manipulation.htm">Manipulation</a></p></li>
<li><p><a href="/fortran/location.htm">Location</a></p></li>
</ul>
<h1>Fortran - Dynamic Arrays</h1>
<p>A <b>dynamic array</b> is an array, the size of which is not known at compile time, but will be known at execution time.</p>
<p>Dynamic arrays are declared with the attribute <b>allocatable</b>.</p>
<p>For example,</p>
<pre class="prettyprint notranslate">
real, dimension (:,:), allocatable :: darray    
</pre>
<p>The rank of the array, i.e., the dimensions has to be mentioned however, to allocate memory to such an array, you use the <b>allocate</b> function.</p>
<pre class="prettyprint notranslate">
allocate ( darray(s1,s2) )      
</pre>
<p>After the array is used, in the program, the memory created should be freed using the <b>deallocate</b> function</p>
<pre class="prettyprint notranslate">
deallocate (darray)  
</pre>
<p><b>Example</b></p>
<p>The following example demonstrates the concepts discussed above.</p>
<pre class="prettyprint notranslate">
program dynamic_array 
implicit none 
   !rank is 2, but size not known   
   real, dimension (:,:), allocatable :: darray    
   integer :: s1, s2     
   integer :: i, j     
   print*, "Enter the size of the array:"     
   read*, s1, s2      
   ! allocate memory      
   allocate ( darray(s1,s2) )      
   do i = 1, s1           
   do j = 1, s2                
   darray(i,j) = i*j               
   print*, "darray(",i,",",j,") = ", darray(i,j)           
   end do      
   end do      
   deallocate (darray)  
end program dynamic_array
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
Enter the size of the array: 3,4
darray( 1 , 1 ) = 1.00000000    
darray( 1 , 2 ) = 2.00000000    
darray( 1 , 3 ) = 3.00000000    
darray( 1 , 4 ) = 4.00000000    
darray( 2 , 1 ) = 2.00000000    
darray( 2 , 2 ) = 4.00000000    
darray( 2 , 3 ) = 6.00000000    
darray( 2 , 4 ) = 8.00000000    
darray( 3 , 1 ) = 3.00000000    
darray( 3 , 2 ) = 6.00000000    
darray( 3 , 3 ) = 9.00000000    
darray( 3 , 4 ) = 12.0000000   
</pre>
<h2>Use of Data Statement</h2>
<p>The <b>data</b> statement can be used for initialising more than one array, or for array section initialisation.</p>
<p>The syntax of data statement is:</p>
<pre class="prettyprint notranslate">
data variable / list / ...
</pre>
<p><b>Example</b></p>
<p>The following example demonstrates the concept:</p>
<pre class="prettyprint notranslate tryit">
program dataStatement
implicit none
   integer :: a(5), b(3,3), c(10),i, j
   data a /7,8,9,10,11/ 
   
   data b(1,:) /1,1,1/ 
   data b(2,:)/2,2,2/ 
   data b(3,:)/3,3,3/ 
   data (c(i),i=1,10,2) /4,5,6,7,8/ 
   data (c(i),i=2,10,2)/5*2/
   
   Print *, 'The A array:'
   do j = 1, 5                
   print*, a(j)           
   end do 
   
   Print *, 'The B array:'
   do i = lbound(b,1), ubound(b,1)
   write(*,*) (b(i,j), j = lbound(b,2), ubound(b,2))
   end do

   Print *, 'The C array:' 
   do j = 1, 10                
   print*, c(j)           
   end do      
end program dataStatement
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
The A array:
           7
           8
           9
          10
          11
 The B array:
           1           1           1
           2           2           2
           3           3           3
 The C array:
           4
           2
           5
           2
           6
           2
           7
           2
           8
           2
</pre>
<h2>Use of Where Statement</h2>
<p>The <b>where</b> statement allows you to use some elements of an array in an expression, depending on the outcome of some logical condition. It allows the execution of the expression, on an element, if the given condition is true.</p>
<p><b>Example</b></p>
<p>The following example demonstrates the concept:</p>
<pre class="prettyprint notranslate tryit">
program whereStatement
implicit none
   integer :: a(3,5), i , j
   
   do i = 1,3
   do j = 1, 5                
   a(i,j) = j-i          
   end do 
   end do
   Print *, 'The A array:'
   do i = lbound(a,1), ubound(a,1)
   write(*,*) (a(i,j), j = lbound(a,2), ubound(a,2))
   end do
   
   where( a&lt;0 ) 
   a = 1 
   elsewhere
   a = 5
   end where
  
   Print *, 'The A array:'
   do i = lbound(a,1), ubound(a,1)
   write(*,*) (a(i,j), j = lbound(a,2), ubound(a,2))
   end do   
end program whereStatement
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
The A array:
           0           1           2           3           4
          -1           0           1           2           3
          -2          -1           0           1           2
 The A array:
           5           5           5           5           5
           1           5           5           5           5
           1           1           5           5           5
</pre>
<h1>Fortran - Derived Data Types</h1>
<p>Fortran allows you to define derived data types. A derived data type is also called a structure, and it can consist of data objects of different types.</p>
<p>Derived data types are used to represent a record. E.g. you want to keep track of your books in a library, you might want to track the following attributes about each book:</p>
<ul class="list">
<li>Title</li>
<li>Author</li>
<li>Subject</li>
<li>Book ID</li>
</ul>
<h2>Defining a Derived data type</h2>
<p>To define a derived data <b>type</b>, the type and <b>end type</b> statements are used. . The type statement defines a new data type, with more than one member for your program. The format of the type statement is this:</p>
<pre class="prettyprint notranslate">
type type_name      
   declarations
end type 
</pre>
<p>Here is the way you would declare the Book structure:</p>
<pre class="prettyprint notranslate">
type Books
   character(len=50) :: title
   character(len=50) :: author
   character(len=150) :: subject
   integer :: book_id
end type Books
</pre>
<h2>Accessing Structure Members</h2>
<p>An object of a derived data type is called a structure</p>
<p>A structure of type Books can be created in a type declaration statement like:</p>
<pre class="prettyprint notranslate">
type(Books) :: book1 
</pre>
<p>The components of the structure can be accessed using the component selector character (%):</p>
<pre class="prettyprint notranslate">
book1%title = "C Programming"
book1%author = "Nuha Ali"
book1%subject = "C Programming Tutorial"
book1%book_id = 6495407
</pre>
<p><b>Note that there are no spaces before and after the % symbol.</b></p>
<p><b>Example</b></p>
<p>The following program illustrates the above concepts:</p>
<pre class="prettyprint notranslate tryit">
program deriveDataType
   !type declaration
   type Books
   character(len=50) :: title
   character(len=50) :: author
   character(len=150) :: subject
   integer :: book_id
   end type Books
   !declaring type variables
   type(Books) :: book1 
   type(Books) :: book2 
   
   !accessing the components of the structure
   
   book1%title = "C Programming"
   book1%author = "Nuha Ali"
   book1%subject = "C Programming Tutorial"
   book1%book_id = 6495407 
   
   book2%title = "Telecom Billing"
   book2%author = "Zara Ali"
   book2%subject = "Telecom Billing Tutorial"
   book2%book_id = 6495700
  
   !display book info
   
   Print *, book1%title 
   Print *, book1%author 
   Print *, book1%subject 
   Print *, book1%book_id  
   
   Print *, book2%title 
   Print *, book2%author 
   Print *, book2%subject 
   Print *, book2%book_id  

end program deriveDataType
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
C Programming                                     
   Nuha Ali                                          
C Programming       Tutorial                                                                                                                                
   6495407
   Telecom Billing                                   
	Zara Ali                                          
   Telecom Billing Tutorial                                                                                                                              
   6495700
</pre>
<h2>Array of Structures</h2>
<p>You can also create arrays of a derived type:</p>
<pre class="prettyprint notranslate">
type(Books), dimension(2) :: list
</pre>
<p>Individual elements of the array could be accessed as:</p>
<pre class="prettyprint notranslate">
list(1)%title = "C Programming"
list(1)%author = "Nuha Ali"
list(1)%subject = "C Programming Tutorial"
list(1)%book_id = 6495407
</pre>
<p>The following program illustrates the concept:</p>
<pre class="prettyprint notranslate tryit">
program deriveDataType
   !type declaration
   type Books
   character(len=50) :: title
   character(len=50) :: author
   character(len=150) :: subject
   integer :: book_id
   end type Books
   !declaring array of books
   type(Books), dimension(2) :: list 
    
   !accessing the components of the structure
   
   list(1)%title = "C Programming"
   list(1)%author = "Nuha Ali"
   list(1)%subject = "C Programming Tutorial"
   list(1)%book_id = 6495407 
   
   list(2)%title = "Telecom Billing"
   list(2)%author = "Zara Ali"
   list(2)%subject = "Telecom Billing Tutorial"
   list(2)%book_id = 6495700
  
   !display book info
   
   Print *, list(1)%title 
   Print *, list(1)%author 
   Print *, list(1)%subject 
   Print *, list(1)%book_id  
   
   Print *, list(1)%title 
   Print *, list(2)%author 
   Print *, list(2)%subject 
   Print *, list(2)%book_id  

end program deriveDataType
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
C Programming                                     
   Nuha Ali                                          
C Programming Tutorial                                                                                                                                
   6495407
C Programming                                     
   Zara Ali                                          
   Telecom Billing Tutorial                                                                                                                              
   6495700
</pre>
<h1>Fortran - Pointers</h1>
<p>In most programming languages, a pointer variable stores the memory address of an object. However, in Fortran, a pointer is a data object that has more functionalities than just storing the memory address. It contains more information about a particular object, like type, rank, extents, and memory address.</p>
<p>A pointer is associated with a target by allocation or pointer assignment.</p>
<h2>Declaring a Pointer Variable</h2>
<p>A pointer variable is declared with the pointer attribute.</p>
<p>The following examples shows declaration of pointer variables:</p>
<pre class="prettyprint notranslate">
integer, pointer :: p1 ! pointer to integer  
real, pointer, dimension (:) :: pra ! pointer to 1-dim real array  
real, pointer, dimension (:,:) :: pra2 ! pointer to 2-dim real array
</pre>
<p>A pointer can point to:</p>
<ul class="list">
<li>an area of dynamically allocated memory</li>
<li>a data object of the same type as the pointer, with the <b>target</b> attribute</li>
</ul>
<h2>Allocating Space for a Pointer</h2>
<p>The <b>allocate</b> statement allows you to allocate space for a pointer object. For example:</p>
<pre class="prettyprint notranslate tryit">
program pointerExample
implicit none
   integer, pointer :: p1
   allocate(p1)
   p1 = 1
   Print *, p1
   p1 = p1 + 4
   Print *, p1
end program pointerExample
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
1
5
</pre>
<p>You should empty the allocated storage space by the <b>deallocate</b> statement when it is no longer required and avoid accumulation of unused and unusable memory space.</p>
<h2>Targets and Association</h2>
<p>A target is another normal variable, with space set aside for it. A target variable must be declared with the <b>target</b> attribute.</p>
<p>You associate a pointer variable with a target variable using the association operator (=>).</p>
<p>Let us rewrite the previous example, to demonstrate the concept:</p>
<pre class="prettyprint notranslate tryit">
program pointerExample
implicit none
   integer, pointer :: p1
   integer, target :: t1 
   p1=>t1
   p1 = 1
   Print *, p1
   Print *, t1
   p1 = p1 + 4
   Print *, p1
   Print *, t1
   t1 = 8
   Print *, p1
   Print *, t1
end program pointerExample
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
1
1
5
5
8
8
</pre>
<p>A pointer can be:</p>
<ul class="list">
<li>Undefined</li>
<li>Associated</li>
<li>Disassociated</li>
</ul>
<p>In the above program, we have <b>associated</b> the pointer p1, with the target t1, using the => operator. The function associated, tests a pointer’s association status.</p>
<p>The <b>nullify</b> statement disassociates a pointer from a target.</p>
<p>Nullify does not empty the targets as there could be more than one pointer pointing to the same target. However, emptying the pointer implies nullification also.</p>
<p><b>Example 1</b></p>
<p>The following example demonstrates the concepts:</p>
<pre class="prettyprint notranslate tryit">
program pointerExample
implicit none
   integer, pointer :: p1
   integer, target :: t1 
   integer, target :: t2
   p1=>t1
   p1 = 1
   Print *, p1
   Print *, t1
   p1 = p1 + 4
   Print *, p1
   Print *, t1
   t1 = 8
   Print *, p1
   Print *, t1
   nullify(p1)
   Print *, t1
   p1=>t2
   Print *, associated(p1)
   Print*, associated(p1, t1)
   Print*, associated(p1, t2)
   !what is the value of p1 at present
   Print *, p1
   Print *, t2
   p1 = 10
   Print *, p1
   Print *, t2
end program pointerExample
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
1
1
5
5
8
8
8
T
F
T
952754640
952754640
10
10
</pre>
<p>Please note that each time you run the code, the memory addresses will be different.</p>
<p><b>Example 2</b></p>
<pre class="prettyprint notranslate tryit">
program pointerExample
implicit none
   integer, pointer :: a, b
   integer, target :: t
   integer :: n
   t= 1
   a=>t
   t = 2
   b => t
   n = a + b
   Print *, a, b, t, n 
end program pointerExample
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
2  2  2  4
</pre>
<h1>Fortran - Basic Input Output</h1>
<p>We have so far seen that we can read data from keyboard using the <b>read *</b> statement, and display output to the screen using the <b>print*</b> statement, respectively. This form of input-output is <b>free format</b> I/O, and it is called <b>list-directed</b> input-output.</p>
<p>The free format simple I/O has the form:</p>
<pre class="prettyprint notranslate">
read(*,*) item1, item2, item3...
print *, item1, item2, item3
write(*,*) item1, item2, item3...
</pre>
<p>However the formatted I/O gives you more flexibility over data transfer.</p>
<h2>Formatted Input Output</h2>
<p>Formatted input output has the syntax as follows:</p>
<pre class="prettyprint notranslate">
read fmt, variable_list 
print fmt, variable_list 
write fmt, variable_list 
</pre>
<p>Where,</p>
<ul class="list">
<li><p>fmt is the format specification</p></li>
<li><p>variable-list is a list of the variables to be read from keyboard or written on screen</p></li>
</ul>
<p>Format specification defines the way in which formatted data is displayed. It consists of a string, containing a list of <b>edit descriptors</b> in parentheses.</p>
<p>An <b>edit descriptor</b> specifies the exact format, for example, width, digits after decimal point etc., in which characters and numbers are displayed.</p>
<p><b>For example:</b></p>
<pre class="prettyprint notranslate">
Print "(f6.3)", pi
</pre>
<p>The following table describes the descriptors:</p>
<table class="table table-bordered">
<tr>
<th>Descriptor</th>
<th>Description</th>
<th>Example</th>
</tr>
<tr>
<td>I</td>
<td>This is used for integer output. This takes the form ‘rIw.m’ where the meanings of r, w and m are given in the table below. Integer values are right justiﬁed in their ﬁelds. If the ﬁeld width is not large enough to accommodate an integer then the ﬁeld is ﬁlled with asterisks.</td>
<td>print "(3i5)", i, j, k</td>
</tr>
<tr>
<td>F</td>
<td>This is used for real number output. This takes the form ‘rFw.d’ where the meanings of r, w and d are given in the table below. Real values are right justiﬁed in their ﬁelds. If the ﬁeld width is not large enough to accommodate the real number then the ﬁeld is ﬁlled with asterisks.</td>
<td>print "(f12.3)",pi</td>
</tr>
<tr>
<td>E</td>
<td><p>This is used for real output in exponential notation. The ‘E’ descriptor statement takes the form ‘rEw.d’ where the meanings of r, w and d are given in the table below. Real values are right justiﬁed in their ﬁelds. If the ﬁeld width is not large enough to accommodate the real number then the ﬁeld is ﬁlled with asterisks.</p>
<p>Please note that, to print out a real number with three decimal places a ﬁeld width of at least ten is needed. One for the sign of the mantissa, two for the zero, four for the mantissa and two for the exponent itself. In general, w ≥ d + 7.</p></td>
<td>print "(e10.3)",123456.0 gives ‘0.123e+06’</td>
</tr>
<tr>
<td>ES</td>
<td>This is used for real output (scientific notation). This takes the form ‘rESw.d’ where the meanings of r, w and d are given in the table below. The ‘E’ descriptor described above diﬀers slightly from the traditional well known ‘scientiﬁc notation’. Scientiﬁc notation has the mantissa in the range 1.0 to 10.0 unlike the E descriptor which has the mantissa in the range 0.1 to 1.0. Real values are right justiﬁed in their ﬁelds. If the ﬁeld width is not large enough to accommodate the real number then the ﬁeld is ﬁlled with asterisks. Here also, the width ﬁeld must satisfy the expression
w ≥ d + 7</td>
<td>print "(es10.3)",123456.0 gives ‘1.235e+05’</td>
</tr>
<tr>
<td>A</td>
<td>This is used for character output. This takes the form ‘rAw’ where the meanings of r and w are given in the table below. Character types are right justiﬁed in their ﬁelds. If the ﬁeld width is not large enough to accommodate the character string then the ﬁeld is ﬁlled with the ﬁrst ‘w’ characters of the string.</td>
<td>print "(a10)", str</td>
</tr>
<tr>
<td>X</td>
<td>This is used for space output. This takes the form ‘nX’ where ‘n’ is the number of desired spaces.</td>
<td>print "(5x, a10)", str</td>
</tr>
<tr>
<td>/</td>
<td>Slash descriptor – used to insert blank lines. This takes the form ‘/’ and forces the next data output to be on a new line.</td>
<td style="width:30%;">print "(/,5x, a10)", str</td>
</tr>
</table>
<p>Following symbols are used with the format descriptors:</p>
<table class="table table-bordered">
<tr>
<th>Symbol</th>
<th>Description</th>
</tr>
<tr>
<td>c</td>
<td>Column number</td>
</tr>
<tr>
<td>d</td>
<td>Number of digits to right of the decimal place for real input or output</td>
</tr>
<tr>
<td>m</td>
<td>Minimum number of digits to be displayed</td>
</tr>
<tr>
<td>n</td>
<td>Number of spaces to skip</td>
</tr>
<tr>
<td>r</td>
<td>Repeat count – the number of times to use a descriptor or group of descriptors</td>
</tr>
<tr>
<td>w</td>
<td>Field width – the number of characters to use for the input or output</td>
</tr>
</table>
<p><b>Example 1</b></p>
<pre class="prettyprint notranslate tryit">
program printPi
   pi = 3.141592653589793238 
   
   Print "(f6.3)", pi 
   Print "(f10.7)", pi
   Print "(f20.15)", pi 
   Print "(e16.4)", pi/100 
end program printPi
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
3.142
3.1415927
3.141592741012573
0.3142E-01
</pre>
<p><b>Example 2</b></p>
<pre class="prettyprint notranslate tryit">
program printName
implicit none
character (len=15) :: first_name
   print *,' Enter your first name.' 
   print *,' Up to 20 characters, please'
   read *,first_name 
   print "(1x,a)",first_name
end program printName
</pre>
<p>When the above code is compiled and executed, it produces the following result: (assume the user enters the name Zara)</p>
<pre class="prettyprint notranslate">
Enter your first name.
   Up to 20 characters, please
   Zara 
</pre>
<p><b>Example 3</b></p>
<pre class="prettyprint notranslate tryit">
program formattedPrint
implicit none
real :: c = 1.2786456e-9, d = 0.1234567e3 
integer :: n = 300789, k = 45, i = 2
character (len=15) :: str="Tutorials Point"
print "(i6)", k 
print "(i6.3)", k 
print "(3i10)", n, k, i 
print "(i10,i3,i5)", n, k, i 
print "(a15)",str 
print "(f12.3)", d
print "(e12.4)", c 
print '(/,3x,"n = ",i6, 3x, "d = ",f7.4)', n, d
end program formattedPrint
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">

45
045
300789 45  2
300789 45  2
Tutorials Point
123.457
0.1279E-08

n = 300789 d = *******
</pre>
<h2>The Format Statement</h2>
<p>The format statement allows you to mix and match character, integer and real output in one statement. The following example demonstrates this:</p>
<pre class="prettyprint notranslate tryit">
program productDetails 
implicit none 
   character (len=15) :: name
   integer :: id 
   real :: weight
   name = 'Ardupilot'
   id = 1
   weight = 0.08
   print *,' The product details are' 
   print 100
   100 format (7x,'Name:', 7x, 'Id:', 1x, 'Weight:')
   print 200, name, id, weight 
   200 format(1x, a, 2x, i3, 2x, f5.2) 
end program productDetails
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
The product details are
Name:       Id:    Weight:
Ardupilot   1       0.08
</pre>
<h1>Fortran - File Input Output</h1>
<p>Fortran allows you to read data from, and write data into files.</p>
<p>In the last chapter, you have seen how to read data from, and write data to the terminal. In this chapter you will study file input and output functionalities provided by Fortran.</p>
<p>You can read and write to one or more files. The OPEN, WRITE, READ and CLOSE statements allow you to achieve this.</p>
<h2>Opening and Closing Files</h2>
<p>Before using a file you must open the file. The <b>open</b> command is used to open files for reading or writing. The simplest form of the command is:</p>
<pre class="prettyprint notranslate">
open (unit = number, file = "name").
</pre>
<p>However, the open statement may have a general form:</p>
<pre class="prettyprint notranslate">
open (list-of-specifiers)
</pre>
<p>The following table describes the most commonly used specifiers:</p>
<table class="table table-bordered">
<tr>
<th style width="20%">Specifier</th>
<th>Description</th>
</tr>
<tr>
<td>[UNIT=] u</td>
<td>The unit number u could be any number in the range 9-99 and it indicates the file, you may choose any number but every open file in the program must have a unique number</td>
</tr>
<tr>
<td>IOSTAT= ios</td>
<td>It is the I/O status identifier and should be an integer variable. If the open statement is successful then the ios value returned is zero else a non-zero value.</td>
</tr>
<tr>
<td>ERR = err</td>
<td>It is a label to which the control jumps in case of any error.</td>
</tr>
<tr>
<td>FILE = fname</td>
<td>File name, a character string.</td>
</tr>
<tr>
<td>STATUS = sta</td>
<td>It shows the prior status of the file. A character string and can have one of the three values NEW, OLD or SCRATCH. A scratch file is created and deleted when closed or the program ends.</td>
</tr>
<tr>
<td>ACCESS = acc</td>
<td>It is the file access mode. Can have either of the two values, SEQUENTIAL or DIRECT. The default is SEQUENTIAL.</td>
</tr>
<tr>
<td>FORM=    frm</td>
<td>It gives the formatting status of the file. Can have either of the two values FORMATTED or UNFORMATTED. The default is UNFORMATTED</td>
</tr>
<tr>
<td>RECL = rl</td>
<td>It specifies the length of each record in a direct access file.</td>
</tr>
</table>
<p>After the file has been opened, it is accessed by read and write statements. Once done, it should be closed using the <b>close</b> statement.</p>
<p>The close statement has the following syntax:</p>
<pre class="prettyprint notranslate">
close ([UNIT=]u[,IOSTAT=ios,ERR=err,STATUS=sta])
</pre>
<p>Please note that the parameters in brackets are optional.</p>
<p><b>Example</b></p>
<p>This example demonstrates opening a new file for writing some data into the file.</p>
<pre class="prettyprint notranslate">
program outputdata   
implicit none   
real, dimension(100) :: x, y  
real, dimension(100) :: p, q
integer :: i  
   ! data  
   do i=1,100  
   x(i) = i * 0.1 
   y(i) = sin(x(i)) * (1-cos(x(i)/3.0))  
   end do  
   ! output data into a file 
   open(1, file='data1.dat', status='new')  
   do i=1,100  
   write(1,*) x(i), y(i)   
   end do  
   close(1) 
end program outputdata
</pre>
<p>When the above code is compiled and executed, it creates the file data1.dat and writes the x and y array values into it. And then closes the file.</p>
<p><b>Reading from and Writing into the File</b></p>
<p>The read and write statements respectively are used for reading from and writing into a file respectively.</p>
<p>They have the following syntax:</p>
<pre class="prettyprint notranslate">
read ([UNIT=]u, [FMT=]fmt, IOSTAT=ios, ERR=err, END=s)
write([UNIT=]u, [FMT=]fmt, IOSTAT=ios, ERR=err, END=s)
</pre>
<p>Most of the specifiers have already been discussed in the above table.</p>
<p>The END=s specifier is a statement label where the program jumps, when it reaches end-of-file.</p>
<p><b>Example</b></p>
<p>This example demonstrates reading from and writing into a file.</p>
<p>In this program we read from the file, we created in the last example, data1.dat, and display it on screen.</p>
<pre class="prettyprint notranslate tryit">
program outputdata   
implicit none   
real, dimension(100) :: x, y  
real, dimension(100) :: p, q
integer :: i  
   ! data  
   do i=1,100  
   x(i) = i * 0.1 
   y(i) = sin(x(i)) * (1-cos(x(i)/3.0))  
   end do  
   ! output data into a file 
   open(1, file='data1.dat', status='new')  
   do i=1,100  
   write(1,*) x(i), y(i)   
   end do  
   close(1) 
  
   ! opening the file for reading
   open (2, file='data1.dat', status='old')
  
   do i=1,100  
   read(2,*) p(i), q(i)
   end do 
   close(2)
   do i=1,100  
   write(*,*) p(i), q(i)
   end do 
end program outputdata
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
0.100000001  5.54589933E-05
0.200000003  4.41325130E-04
0.300000012  1.47636665E-03
0.400000006  3.45637114E-03
0.500000000  6.64328877E-03
0.600000024  1.12552457E-02
0.699999988  1.74576249E-02
0.800000012  2.53552198E-02
0.900000036  3.49861123E-02
1.00000000   4.63171229E-02
1.10000002   5.92407547E-02
1.20000005   7.35742599E-02
1.30000007   8.90605897E-02
1.39999998   0.105371222    
1.50000000   0.122110792    
1.60000002   0.138823599    
1.70000005   0.155002072    
1.80000007   0.170096487    
1.89999998   0.183526158    
2.00000000   0.194692180    
2.10000014   0.202990443    
2.20000005   0.207826138    
2.29999995   0.208628103    
2.40000010   0.204863414    
2.50000000   0.196052119    
2.60000014   0.181780845    
2.70000005   0.161716297    
2.79999995   0.135617107    
2.90000010   0.103344671    
3.00000000   6.48725405E-02
3.10000014   2.02930309E-02
3.20000005  -3.01767997E-02
3.29999995  -8.61928314E-02
3.40000010  -0.147283033    
3.50000000  -0.212848678    
3.60000014  -0.282169819    
3.70000005  -0.354410470    
3.79999995  -0.428629100    
3.90000010  -0.503789663    
4.00000000  -0.578774154    
4.09999990  -0.652400017    
4.20000029  -0.723436713    
4.30000019  -0.790623367    
4.40000010  -0.852691114    
4.50000000  -0.908382416    
4.59999990  -0.956472993    
4.70000029  -0.995793998    
4.80000019  -1.02525222    
4.90000010  -1.04385209    
5.00000000  -1.05071592    
5.09999990  -1.04510069    
5.20000029  -1.02641726    
5.30000019  -0.994243503    
5.40000010  -0.948338211    
5.50000000  -0.888650239    
5.59999990  -0.815326691    
5.70000029  -0.728716135    
5.80000019  -0.629372001    
5.90000010  -0.518047631    
6.00000000  -0.395693362    
6.09999990  -0.263447165    
6.20000029  -0.122622721    
6.30000019   2.53026206E-02
6.40000010   0.178709000    
6.50000000   0.335851669    
6.59999990   0.494883657    
6.70000029   0.653881252    
6.80000019   0.810866773    
6.90000010   0.963840425    
7.00000000   1.11080539    
7.09999990   1.24979746    
7.20000029   1.37891412    
7.30000019   1.49633956    
7.40000010   1.60037732    
7.50000000   1.68947268    
7.59999990   1.76223695    
7.70000029   1.81747139    
7.80000019   1.85418403    
7.90000010   1.87160957    
8.00000000   1.86922085    
8.10000038   1.84674001    
8.19999981   1.80414569    
8.30000019   1.74167395    
8.40000057   1.65982044    
8.50000000   1.55933595    
8.60000038   1.44121361    
8.69999981   1.30668485    
8.80000019   1.15719533    
8.90000057   0.994394958    
9.00000000   0.820112705    
9.10000038   0.636327863    
9.19999981   0.445154816    
9.30000019   0.248800844    
9.40000057   4.95488606E-02
9.50000000  -0.150278628    
9.60000038  -0.348357052    
9.69999981  -0.542378068    
9.80000019  -0.730095863    
9.90000057  -0.909344316    
10.0000000  -1.07807255    
</pre>
<h1>Fortran - Procedures</h1>
<p>A <b>procedure</b> is a group of statements that perform a well-defined task and can be invoked from your program. Information (or data) is passed to the calling program, to the procedure as arguments.</p>
<p>There are two types of procedures:</p>
<ul class="list">
<li>Functions</li>
<li>Subroutines</li>
</ul>
<h2>Function</h2>
<p>A function is a procedure that returns a single quantity. A function should not modify its arguments.</p>
<p>The returned quantity is known as <b>function value</b>, and it is denoted by the function name.</p>
<p><b>Syntax:</b></p>
<p>Syntax for a function is as follows:</p>
<pre class="prettyprint notranslate">
function name(arg1, arg2, ....)  
   [declarations, including those for the arguments]   
   [executable statements] 
end function [name]
</pre>
<p>The following example demonstrates a function named area_of_circle. It calculates the area of a circle with radius r.</p>
<pre class="prettyprint notranslate tryit">
program calling_func
   real :: a
   a = area_of_circle(2.0) 
   Print *, "The area of a circle with radius 2.0 is"
   Print *, a
end program calling_func

function area_of_circle (r)  
! this function computes the area of a circle with radius r     
   implicit none      
! function result     
   real :: area_of_circle   
! dummy arguments     
   real :: r     
! local variables     
   real :: pi    
   pi = 4 * atan (1.0)     
   area_of_circle = pi * r**2  
end function area_of_circle
</pre>
<p>When you compile and execute the above program, it produces the following result:</p>
<pre class="prettyprint notranslate">
The area of a circle with radius 2.0 is
   12.5663710   
</pre>
<p>Please note that:</p>
<ul class="list">
<li><p>You must specify <b>implicit none</b> in both the main program as well as the procedure.</p></li>
<li><p>The argument r in the called function is called <b>dummy argument</b>.</p></li>
</ul>
<p><b>The result Option</b></p>
<p>If you want the returned value to be stored in some other name than the function name, you can use the <b>result</b> option.</p>
<p>You can specify the return variable name as:</p>
<pre class="prettyprint notranslate">
function name(arg1, arg2, ....) result (return_var_name)  
   [declarations, including those for the arguments]   
   [executable statements] 
end function [name]
</pre>
<h2>Subroutine</h2>
<p>A subroutine does not return a value, however it can modify its arguments.</p>
<p><b>Syntax</b></p>
<pre class="prettyprint notranslate">
subroutine name(arg1, arg2, ....)    
   [declarations, including those for the arguments]    
   [executable statements]  
end subroutine [name]
</pre>
<p><b>Calling a Subroutine</b></p>
<p>You need to invoke a subroutine using the <b>call</b> statement.</p>
<p>The following example demonstrates the definition and use of a subroutine swap, that changes the values of its arguments.</p>
<pre class="prettyprint notranslate tryit">
program calling_func
implicit none
   real :: a, b
   a = 2.0
   b = 3.0
   Print *, "Before calling swap"
   Print *, "a = ", a
   Print *, "b = ", b
   call swap(a, b)
   Print *, "After calling swap"
   Print *, "a = ", a
   Print *, "b = ", b
end program calling_func

   subroutine swap(x, y) 
   implicit none
   real :: x, y, temp   
   temp = x  
   x = y 
   y = temp  
end subroutine swap
</pre>
<p>When you compile and execute the above program, it produces the following result:</p>
<pre class="prettyprint notranslate">
Before calling swap
a = 2.00000000    
b = 3.00000000    
After calling swap
a = 3.00000000    
b = 2.00000000   
</pre>
<h2>Specifying the Intent of the Arguments</h2>
<p>The intent attribute allows you to specify the intention with which arguments are used in the procedure. The following table provides the values of the intent attribute: </p>
<table class="table table-bordered">
<tr>
<th>Value</th>
<th>Used as</th>
<th>Explanation</th>
</tr>
<tr>
<td>in</td>
<td>intent(in)</td>
<td>Used as input values, not changed in the function</td>
</tr>
<tr>
<td>out</td>
<td>intent(out)</td>
<td>Used as output value, they are overwritten</td>
</tr>
<tr>
<td>inout</td>
<td>intent(inout)</td>
<td>Arguments are both used and overwritten</td>
</tr>
</table>
<p>The following example demonstrates the concept:</p>
<pre class="prettyprint notranslate tryit">
program calling_func
implicit none
   real :: x, y, z, disc
   x= 1.0
   y = 5.0
   z = 2.0
   call intent_example(x, y, z, disc)
   Print *, "The value of the discriminant is"
   Print *, disc
end program calling_func

subroutine intent_example (a, b, c, d)     
   implicit none     
   ! dummy arguments      
   real, intent (in) :: a     
   real, intent (in) :: b      
   real, intent (in) :: c    
   real, intent (out) :: d   
   d = b*b - 4.0*a*c 
end subroutine intent_example
</pre>
<p>When you compile and execute the above program, it produces the following result:</p>
<pre class="prettyprint notranslate">
The value of the discriminant is
   17.0000000    
</pre>
<h2>Recursive Procedures</h2>
<p>Recursion occurs when a programming languages allows you to call a function inside the same function. It is called recursive call of the function.</p>
<p>When a procedure calls itself, directly or indirectly, is called a recursive procedure. You should declare this type of procedures by preceding the word <b>recursive</b> before its declaration.</p>
<p>When a function is used recursively, the <b>result</b> option has to be used.</p>
<p>Following is an example, which calculates factorial for a given number using a recursive procedure:</p>
<pre class="prettyprint notranslate">
program calling_func
implicit none
   integer :: i, f
   i = 15
   Print *, "The value of factorial 15 is"
   f = myfactorial(15)
   Print *, f
end program calling_func

recursive function myfactorial (n) result (fac)  
   ! computes the factorial of n (n!)      
   implicit none     
   ! function result     
   integer :: fac     
   ! dummy arguments     
   integer, intent (in) :: n     
   select case (n)         
   case (0:1)         
   fac = 1         
   case default    
   fac = n * myfactorial (n-1)  
   end select 
end function myfactorial
</pre>
<h2>Internal Procedures</h2>
<p>When a procedure is contained within a program, it is called the internal procedure of the program. The syntax for containing an internal procedure is as follows:</p>
<pre class="prettyprint notranslate">
program program_name     
   implicit none         
   ! type declaration statements         
   ! executable statements    
   . . .     
   contains         
   ! internal procedures      
   . . .  
end program program_name
</pre>
<p>The following example demonstrates the concept:</p>
<pre class="prettyprint notranslate tryit">
program mainprog  
implicit none 
real :: a, b 
   a = 2.0
   b = 3.0
   Print *, "Before calling swap"
   Print *, "a = ", a
   Print *, "b = ", b
   call swap(a, b)
   Print *, "After calling swap"
   Print *, "a = ", a
   Print *, "b = ", b
 
   contains   
   subroutine swap(x, y)     
   real :: x, y, temp      
   temp = x 
   x = y  
   y = temp   
   end subroutine swap 
end program mainprog   
</pre>
<p>When you compile and execute the above program, it produces the following result:</p>
<pre class="prettyprint notranslate">
Before calling swap
a = 2.00000000    
b = 3.00000000    
After calling swap
a = 3.00000000    
b = 2.00000000   
</pre>
<h1>Fortran - Modules</h1>
<p>A module is like a package where you can keep your functions and subroutines, in case you are writing a very big program, or your functions or subroutines can be used in more than one program.</p>
<p>Modules provide you a way of splitting your programs between multiple files.</p>
<p>Modules are used for:</p>
<ul class="list">
<li>Packaging subprograms, data and interface blocks.</li>  
<li>Defining global data that can be used by more than one routine.</li> 
<li>Declaring variables that can be made available within any routines you choose.</li>
<li>Importing a module entirely, for use, into another program or subroutine.</li>  
</ul>
<h3>Syntax of a Module</h3>
<p>A module consists of two parts:</p>
<ul class="list">
<li>a specification part for statements declaration</li> 
<li>a contains part for subroutine and function definitions</li>
</ul>
<p>The general form of a module is:</p>
<pre class="prettyprint notranslate">
module name     
   [statement declarations]  
   [contains [subroutine and function definitions] ] 
end module [name]
</pre>
<h2>Using a Module into your Program</h2>
<p>You can incorporate a module in a program or subroutine by the use statement:</p>
<pre class="prettyprint notranslate">
use name  
</pre>
<p>Please note that</p>
<ul class="list">
<li><p>You can add as many modules as needed, each will be in separate files and compiled separately.</p></li>  
<li><p>A module can be used in various different programs.</p></li> 
<li><p>A module can be used many times in the same program.</p></li>   
<li><p>The variables declared in a module specification part, are global to the module.</p></li>  
<li><p>The variables declared in a module become global variables in any program or routine where the module is used.</p></li> 
<li><p>The use statement can appear in the main program, or any other subroutine or module which uses the routines or variables declared in a particular module.</p></li> 
</ul>
<p><b>Example</b></p>
<p>The following example demonstrates the concept:</p>
<pre class="prettyprint notranslate tryit">
module constants  
implicit none 
   real, parameter :: pi = 3.1415926536  
   real, parameter :: e = 2.7182818285 
contains      
   subroutine show_consts()          
   print*, "Pi = ", pi          
   print*,  "e = ", e     
   end subroutine show_consts 
end module constants 

program module_example     
use constants      
implicit none     
   real :: x, ePowerx, area, radius 
   x = 2.0
   radius = 7.0
   ePowerx = e ** x
   area = pi * radius**2     
   call show_consts() 
   print*, "e raised to the power of 2.0 = ", ePowerx
   print*, "Area of a circle with radius 7.0 = ", area  
end program module_example
</pre>
<p>When you compile and execute the above program, it produces the following result:</p>
<pre class="prettyprint notranslate">
Pi = 3.14159274    
e =  2.71828175    
e raised to the power of 2.0 = 7.38905573    
Area of a circle with radius 7.0 = 153.938049   
</pre>
<h2>Accessibility of Variables and Subroutines in a Module</h2>
<p>By default, all the variables and subroutines in a module is made available to the program that is using the module code, by the <b>use</b> statement.</p>
<p>However, you can control the accessibility of module code using the <b>private</b> and <b>public</b> attributes. When you declare some variable or subroutine as private, it is not available outside the module.</p>
<p><b>Example</b></p>
<p>The following example illustrates the concept:</p>
<p>In the previous example, we had two module variables, <b>e</b> and <b>pi.</b> Let us make them private and observe the output:</p>
<pre class="prettyprint notranslate">
module constants  
implicit none 
   real, parameter,private :: pi = 3.1415926536  
   real, parameter, private :: e = 2.7182818285 
contains      
   subroutine show_consts()          
   print*, "Pi = ", pi          
   print*, "e = ", e     
   end subroutine show_consts 
end module constants 

program module_example     
use constants      
implicit none     
   real :: x, ePowerx, area, radius 
   x = 2.0
   radius = 7.0
   ePowerx = e ** x
   area = pi * radius**2     
   call show_consts() 
   print*, "e raised to the power of 2.0 = ", ePowerx
   print*, "Area of a circle with radius 7.0 = ", area  
end program module_example
</pre>
<p>When you compile and execute the above program, it gives the following error message:</p>
<pre class="prettyprint notranslate">
   ePowerx = e ** x
   1
Error: Symbol 'e' at (1) has no IMPLICIT type
main.f95:19.13:

   area = pi * radius**2     
   1
Error: Symbol 'pi' at (1) has no IMPLICIT type
</pre>
<p>Since <b>e</b> and <b>pi,</b> both are declared private, the program module_example cannot access these variables anymore.</p>
<p>However, other module subroutines can access them:</p>
<pre class="prettyprint notranslate tryit">
module constants  
implicit none 
   real, parameter,private :: pi = 3.1415926536  
   real, parameter, private :: e = 2.7182818285 
contains      
   subroutine show_consts()          
   print*, "Pi = ", pi          
   print*, "e = ", e     
   end subroutine show_consts 
   function ePowerx(x)result(ePx) 
   implicit none
   real::x
   real::ePx
   ePx = e ** x
   end function ePowerx
    
   function areaCircle(r)result(a)  
implicit none
   real::r
   real::a
   a = pi * r**2  
   end function areaCircle
    
end module constants 

program module_example     
use constants      
implicit none     
   call show_consts() 
   Print*, "e raised to the power of 2.0 = ", ePowerx(2.0)
   print*, "Area of a circle with radius 7.0 = ", areaCircle(7.0)  
end program module_example
</pre>
<p>When you compile and execute the above program, it produces the following result:</p>
<pre class="prettyprint notranslate">
Pi = 3.14159274    
e = 2.71828175    
e raised to the power of 2.0 = 7.38905573    
Area of a circle with radius 7.0 = 153.938049   
</pre>
<h1>Fortran - Intrinsic Functions</h1>
<p>Intrinsic functions are some common and important functions that are provided as a part of the Fortran language. We have already discussed some of these functions in the Arrays, Characters and String chapters.</p>
<p>Intrinsic functions can be categorised as:</p>
<ul class="list">
<li>Numeric Functions</li> 
<li>Mathematical Functions</li> 
<li>Numeric Inquiry Functions</li> 
<li>Floating-Point Manipulation Functions</li> 
<li>Bit Manipulation Functions</li> 
<li>Character Functions</li> 
<li>Kind Functions</li> 
<li>Logical Functions</li> 
<li>Array Functions.</li> 
</ul>
<p>We have discussed the array functions in the Arrays chapter. In the following section we provide brief descriptions of all these functions from other categories.</p>
<p>In the function name column,</p>
<ul class="list">
<li>A represents any type of numeric variable</li>
<li>R represents a real or integer variable</li>
<li>X and Y represent real variables</li>
<li>Z represents complex variable</li>
<li>W represents real or complex variable</li>
</ul>
<h2>Numeric Functions</h2>
<table class="table table-bordered">
<tr>
<th style width="27%">Function</th>
<th>Description</th>
</tr>
<tr>
<td>ABS (A)</td>
<td>It returns the absolute value of A</td>
</tr>
<tr>
<td>AIMAG (Z)</td>
<td>It returns the imaginary part of a complex number Z</td>
</tr>
<tr>
<td>AINT (A  [, KIND])</td>
<td>It truncates fractional part of A towards zero, returning a real, whole number.</td>
</tr>
<tr>
<td>ANINT (A [, KIND])</td>
<td>It returns a real value, the nearest integer or whole number.</td>
</tr>
<tr>
<td>CEILING (A  [, KIND])</td>
<td>It returns the least integer greater than or equal to number A.</td>
</tr>
<tr>
<td>CMPLX (X [, Y, KIND])</td>
<td>It converts the real variables X and Y to a complex number X+iY; if Y is absent, 0 is used.</td>
</tr>
<tr>
<td>CONJG (Z)</td>
<td>It returns the complex conjugate of any complex number Z.</td>
</tr>
<tr>
<td>DBLE (A)</td>
<td>It converts A to a double precision real number.</td>
</tr>
<tr>
<td>DIM (X, Y)</td>
<td>It returns the positive difference of X and Y.</td>
</tr>
<tr>
<td>DPROD (X, Y)</td>
<td>It returns the double precision real product of X and Y.</td>
</tr>
<tr>
<td>FLOOR (A  [, KIND])</td>
<td>It provides the greatest integer less than or equal to number A.</td>
</tr>
<tr>
<td>INT (A [, KIND])</td>
<td>It converts a number (real or integer) to integer, truncating the real part towards zero.</td>
</tr>
<tr>
<td>MAX (A1, A2 [, A3,...])</td>
<td>It returns the maximum value from the arguments, all being of same type.</td>
</tr>
<tr>
<td>MIN (A1, A2 [, A3,...])</td>
<td>It returns the minimum value from the arguments, all being of same type.</td>
</tr>
<tr>
<td>MOD (A, P)</td>
<td>It returns the remainder of A on division by P, both arguments  being of the same type (A-INT(A/P)*P)</td>
</tr>
<tr>
<td>MODULO (A, P)</td>
<td>It returns A modulo P: (A-FLOOR(A/P)*P)</td>
</tr>
<tr>
<td>NINT (A [, KIND])</td>
<td>It returns the nearest integer of number A</td>
</tr>
<tr>
<td>REAL (A [, KIND])</td>
<td>It Converts to real type</td>
</tr>
<tr>
<td>SIGN (A, B)</td>
<td>It returns the absolute value of A multiplied by the sign of P. Basically it transfers the of sign of B to A.</td>
</tr>
</table>
<p><b>Example</b></p>
<pre class="prettyprint notranslate tryit">
program numericFunctions
implicit none  
   ! define constants  
   !define variables
   real :: a, b 
   complex :: z
   !values for a, b 
   a = 15.2345
   b = -20.7689
    
   write(*,*) 'abs(a): ',abs(a),' abs(b): ',abs(b)   
   write(*,*) 'aint(a): ',aint(a),' aint(b): ',aint(b) 
   write(*,*) 'ceiling(a): ',ceiling(a),' ceiling(b): ',ceiling(b)   
   write(*,*) 'floor(a): ',floor(a),' floor(b): ',floor(b)  
    
   z = cmplx(a, b)
   write(*,*) 'z: ',z   
end program numericFunctions
</pre>
<p>When you compile and execute the above program, it produces the following result:</p>
<pre class="prettyprint notranslate">
abs(a): 15.2344999   abs(b): 20.7688999    
aint(a): 15.0000000  aint(b): -20.0000000    
ceiling(a): 16  ceiling(b): -20
floor(a): 15  floor(b): -21
z: (15.2344999, -20.7688999)
</pre>
<h2>Mathematical Functions</h2>
<table class="table table-bordered">
<tr>
<th>Function</th>
<th>Description</th>
</tr>
<tr>
<td>ACOS (X)</td>
<td>It returns the inverse cosine in the range (0, π), in radians.</td>
</tr>
<tr>
<td>ASIN (X)</td>
<td>It returns the inverse sine in the range (-π/2, π/2), in radians.</td>
</tr>
<tr>
<td>ATAN (X)</td>
<td>It returns the inverse tangent in the range (-π/2, π/2), in radians.</td>
</tr>
<tr>
<td>ATAN2 (Y, X)</td>
<td>It returns the inverse tangent in the range (-π, π), in radians.</td>
</tr>
<tr>
<td>COS (X)</td>
<td>It returns the cosine of argument in radians.</td>
</tr>
<tr>
<td>COSH (X)</td>
<td>It returns the hyperbolic cosine of argument in radians.</td>
</tr>
<tr>
<td>EXP (X)</td>
<td>It returns the exponential value of X.</td>
</tr>
<tr>
<td>LOG (X)</td>
<td>It returns the natural logarithmic value of X.</td>
</tr>
<tr>
<td>LOG10 (X)</td>
<td>It returns the common logarithmic (base 10) value of X. </td>
</tr>
<tr>
<td>SIN (X)</td>
<td>It returns the sine of argument in radians.</td>
</tr>
<tr>
<td>SINH (X)</td>
<td>It returns the hyperbolic sine of argument in radians.</td>
</tr>
<tr>
<td>SQRT (X)</td>
<td>It returns square root of X.</td>
</tr>
<tr>
<td>TAN (X)</td>
<td>It returns the tangent of argument in radians.</td>
</tr>
<tr>
<td>TANH (X)</td>
<td>It returns the hyperbolic tangent of argument in radians.</td>
</tr>
</table>
<p><b>Example</b></p>
<p>The following program computes the horizontal and vertical position x and y respectively of a projectile after a time, t:</p>
<p>Where, x = u t cos a and y = u t sin a - g t2 / 2</p>
<pre class="prettyprint notranslate tryit">
program projectileMotion  
implicit none  
   ! define constants  
   real, parameter :: g = 9.8  
   real, parameter :: pi = 3.1415927  
   !define variables
   real :: a, t, u, x, y   
   !values for a, t, and u 
   a = 45.0
   t = 20.0
   u = 10.0
   ! convert angle to radians  
   a = a * pi / 180.0  
   x = u * cos(a) * t   
   y = u * sin(a) * t - 0.5 * g * t * t  
   write(*,*) 'x: ',x,'  y: ',y   
end program projectileMotion
</pre>
<p>When you compile and execute the above program, it produces the following result:</p>
<pre class="prettyprint notranslate">
x: 141.421356  y: -1818.57861  
</pre>
<h2>Numeric Inquiry Functions</h2>
<p>These functions work with a certain model of integer and floating-point arithmetic. The functions return properties of numbers of the same kind as the variable X, which can be real and in some cases integer.</p>
<table class="table table-bordered">
<tr>
<th>Function</th>
<th>Description</th>
</tr>
<tr>
<td>DIGITS (X)</td>
<td>It returns the number of significant digits of the model.</td>
</tr>
<tr>
<td>EPSILON (X)</td>
<td>It returns the number that is almost negligible compared to one. In other words, it returns the smallest value such that REAL( 1.0, KIND(X)) + EPSILON(X) is not equal to REAL( 1.0, KIND(X)).</td>
</tr>
<tr>
<td>HUGE (X)</td>
<td>It returns the largest number of the model</td>
</tr>
<tr>
<td>MAXEXPONENT (X)</td>
<td>It returns the maximum exponent of the model</td>
</tr>
<tr>
<td style="width:25%;">MINEXPONENT (X)</td>
<td>It returns the minimum exponent of the model</td>
</tr>
<tr>
<td>PRECISION (X)</td>
<td>It returns the decimal precision</td>
</tr>
<tr>
<td>RADIX (X)</td>
<td>It returns the base of the model</td>
</tr>
<tr>
<td>RANGE (X)</td>
<td>It returns the decimal exponent range</td>
</tr>
<tr>
<td>TINY (X)</td>
<td>It returns the smallest positive number of the model</td>
</tr>
</table>
<h2>Floating-Point Manipulation Functions</h2>
<table class="table table-bordered">
<tr>
<th>Function</th>
<th>Description</th>
</tr>
<tr>
<td>EXPONENT (X)</td>
<td>It returns the exponent part of a model number</td>
</tr>
<tr>
<td>FRACTION (X)</td>
<td>It returns the fractional part of a number</td>
</tr>
<tr>
<td>NEAREST (X, S)</td>
<td>It returns the nearest different processor number in given direction</td>
</tr>
<tr>
<td>RRSPACING (X)</td>
<td>It returns the reciprocal of the relative spacing of model numbers near given number</td>
</tr>
<tr>
<td>SCALE (X, I)</td>
<td>It multiplies a real by its base to an integer power</td>
</tr>
<tr>
<td style="width:28%;">SET_EXPONENT (X, I)</td>
<td>it returns the exponent part of a number</td>
</tr>
<tr>
<td>SPACING (X)</td>
<td>It returns the absolute spacing of model numbers near given number</td>
</tr>
</table>
<h2>Bit Manipulation Functions</h2>
<table class="table table-bordered">
<tr>
<th>Function</th>
<th>Description</th>
</tr>
<tr>
<td>BIT_SIZE (I)</td>
<td>It returns the number of bits of the model</td>
</tr>
<tr>
<td>BTEST (I, POS)</td>
<td>Bit testing</td>
</tr>
<tr>
<td>IAND (I, J)</td>
<td>Logical AND</td>
</tr>
<tr>
<td>IBCLR (I, POS)</td>
<td>Clear bit</td>
</tr>
<tr>
<td>IBITS (I, POS, LEN)</td>
<td>Bit extraction</td>
</tr>
<tr>
<td>IBSET (I, POS)</td>
<td>Set bit</td>
</tr>
<tr>
<td>IEOR (I, J)</td>
<td>Exclusive OR</td>
</tr>
<tr>
<td>IOR (I, J)</td>
<td>Inclusive OR</td>
</tr>
<tr>
<td>ISHFT (I, SHIFT)</td>
<td>Logical shift</td>
</tr>
<tr>
<td>ISHFTC (I, SHIFT [, SIZE])</td>
<td>Circular shift</td>
</tr>
<tr>
<td>NOT (I)</td>
<td>Logical complement</td>
</tr>
</table>
<h2>Character Functions</h2>
<table class="table table-bordered">
<tr>
<th style width="35%">Function</th>
<th>Description</th>
</tr>
<tr>
<td>ACHAR (I)</td>
<td>It returns the Ith character in the ASCII collating sequence.</td>
</tr>
<tr>
<td>ADJUSTL (STRING)</td>
<td>It adjusts string left by removing any leading blanks and inserting trailing blanks</td>
</tr>
<tr>
<td>ADJUSTR (STRING)</td>
<td>It adjusts string right by removing trailing blanks and inserting leading blanks.</td>
</tr>
<tr>
<td>CHAR (I [, KIND])</td>
<td>It returns the Ith character in the machine speciﬁc collating sequence</td>
</tr>
<tr>
<td>IACHAR (C)</td>
<td>It returns the position of the character in the ASCII collating sequence.</td>
</tr>
<tr>
<td>ICHAR (C)</td>
<td>It returns the position of the character in the machine (processor) speciﬁc collating sequence.</td>
</tr>
<tr>
<td style="width:45%;">INDEX (STRING, SUBSTRING [, BACK])</td>
<td>It returns the leftmost (rightmost if BACK is .TRUE.) starting position of SUBSTRING within STRING.</td>
</tr>
<tr>
<td>LEN (STRING)</td>
<td>It returns the length of a string.</td>
</tr>
<tr>
<td>LEN_TRIM (STRING)</td>
<td>It returns the length of a string without trailing blank characters.</td>
</tr>
<tr>
<td>LGE (STRING_A, STRING_B)</td>
<td>Lexically greater than or equal</td>
</tr>
<tr>
<td>LGT (STRING_A, STRING_B)</td>
<td>Lexically greater than</td>
</tr>
<tr>
<td>LLE (STRING_A, STRING_B)</td>
<td>Lexically less than or equal</td>
</tr>
<tr>
<td>LLT (STRING_A, STRING_B)</td>
<td>Lexically less than</td>
</tr>
<tr>
<td>REPEAT (STRING, NCOPIES)</td>
<td>Repeated concatenation</td>
</tr>
<tr>
<td>SCAN (STRING, SET [, BACK])</td>
<td>It returns the index of the leftmost (rightmost if BACK is .TRUE.) character of STRING that belong to SET, or 0 if none belong.</td>
</tr>
<tr>
<td>TRIM (STRING)</td>
<td>Removes trailing blank characters</td>
</tr>
<tr>
<td>VERIFY (STRING, SET [, BACK])</td>
<td>Verifies the set of characters in a string</td>
</tr>
</table>
<h2>Kind Functions</h2>
<table class="table table-bordered">
<tr>
<th>Function</th>
<th>Description</th>
</tr>
<tr>
<td>KIND (X)</td>
<td>It returns the kind type parameter value.</td>
</tr>
<tr>
<td>SELECTED_INT_KIND (R)</td>
<td>It returns kind of type parameter for speciﬁed exponent range.</td>
</tr>
<tr>
<td style="width:35%;">SELECTED_REAL_KIND ([P, R])</td>
<td>Real kind type parameter value, given precision and range</td>
</tr>
</table>
<h2>Logical Function</h2>
<table class="table table-bordered">
<tr>
<th>Function</th>
<th>Description</th>
</tr>
<tr>
<td style="width:25%;">LOGICAL (L [, KIND])</td>
<td>Convert between objects of type logical with different kind type parameters</td>
</tr>
</table>
<h1>Fortran - Numeric Precision</h1>
<p>We have already discussed that, in older versions of Fortran, there were two <b>real</b> types: the default real type and <b>double precision</b> type.</p>
<p>However, Fortran 90/95 provides more control over the precision of real and integer data types through the <b>kind</b> specifie.</p>
<h2>The Kind Attribute</h2>
<p>Different kind of numbers are stored differently inside the computer. The <b>kind</b> attribute allows you to specify how a number is stored internally. For example,</p>
<pre class="prettyprint notranslate">
real, kind = 2 :: a, b, c
real, kind = 4 :: e, f, g
integer, kind = 2 :: i, j, k
integer, kind = 3 :: l, m, n
</pre>
<p>In the above declaration, the real variables e, f and g have more precision than the real variables a, b and c. The integer variables l, m and n, can store larger values and have more digits for storage than the integer variables i, j and k. Although this is machine dependent.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate tryit">
program kindSpecifier
implicit none
   real(kind = 4) :: a, b, c
   real(kind = 8) :: e, f, g
   integer(kind = 2) :: i, j, k
   integer(kind = 4) :: l, m, n
   integer :: kind_a, kind_i, kind_e, kind_l
   kind_a = kind(a)
   kind_i = kind(i)
   kind_e = kind(e)
   kind_l = kind(l)
   print *,'default kind for real is', kind_a
   print *,'default kind for int is', kind_i
   print *,'extended kind for real is', kind_e
   print *,'default kind for int is', kind_l
end program kindSpecifier
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="prettyprint notranslate">
default kind for real is 4
default kind for int is 2
extended kind for real is 8
default kind for int is 4
</pre>
<h2>Inquiring the Size of Variables</h2>
<p>There are a number of intrinsic functions that allows you to interrogate the size of numbers.</p>
<p>For example, the <b>bit_size(i)</b> intrinsic function specifies the number of bits used for storage. For real numbers, the <b>precision(x)</b> intrinsic function, returns the number of decimal digits of precision, while the <b>range(x)</b> intrinsic function returns the decimal range of the exponent.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate tryit">
program getSize
implicit none
   real (kind = 4) :: a
   real (kind = 8) :: b
   integer (kind = 2) :: i
   integer (kind = 4) :: j

   print *,'precision of real(4) =', precision(a)
   print *,'precision of real(8) =', precision(b)
   
   print *,'range of real(4) =', range(a)
   print *,'range of real(8) =', range(b)
   

   print *,'maximum exponent of real(4) =' , maxexponent(a)
   print *,'maximum exponent of real(8) =' , maxexponent(b)
  
   print *,'minimum exponent of real(4) =' , minexponent(a)
   print *,'minimum exponent of real(8) =' , minexponent(b)
   
   print *,'bits in integer(2) =' , bit_size(i)
   print *,'bits in integer(4) =' , bit_size(j)
   
end program getSize
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="prettyprint notranslate">
precision of real(4) = 6
precision of real(8) = 15
range of real(4) = 37
range of real(8) = 307
maximum exponent of real(4) = 128
maximum exponent of real(8) = 1024
minimum exponent of real(4) = -125
minimum exponent of real(8) = -1021
bits in integer(2) = 16
bits in integer(4) = 32
</pre>
<h2>Obtaining the Kind Value</h2>
<p>Fortran provides two more intrinsic functions to obtain the kind value for the required precision of integers and reals:</p>
<ul class="list">
<li>selected_int_kind (r)</li>
<li>selected_real_kind ([p, r])</li>
</ul>
<p>The selected_real_kind function returns an integer that is the kind type parameter value necessary for a given decimal precision p and decimal exponent range r.  The decimal precision is the number of significant digits, and the decimal exponent range specifies the smallest and largest representable number. The range is thus from 10-r to 10+r.</p>
<p>For example, selected_real_kind (p = 10, r = 99) returns the kind value needed for a precision of 10 decimal places, and a range of at least 10-99 to 10+99.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate tryit">
program getKind
implicit none
   integer:: i
   i = selected_real_kind (p = 10, r = 99) 
   print *,'selected_real_kind (p = 10, r = 99)', i
end program getKind
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="prettyprint notranslate">
selected_real_kind (p = 10, r = 99) 8
</pre>
<h1>Fortran - Program Libraries</h1>
<p>There are various Fortran tools and libraries. Some are free and some are paid services.</p>
<p>Following are some free libraries:</p>
<ul class="list">
<li>RANDLIB, random number and statistical distribution generators</li>
<li>BLAS</li>
<li>EISPACK</li>
<li>GAMS–NIST Guide to Available Math Software</li>
<li>Some statistical and other routines from NIST</li>
<li>LAPACK</li>
<li>LINPACK</li>
<li>MINPACK</li>
<li>MUDPACK</li>
<li>NCAR Mathematical Library</li>
<li>The Netlib collection of mathematical software, papers, and databases.</li>
<li>ODEPACK</li>
<li>ODERPACK, a set of routines for ranking and ordering.</li>
<li>Expokit for computing matrix exponentials</li>
<li>SLATEC</li>
<li>SPECFUN</li>
<li>STARPAC</li>
<li>StatLib statistical library</li>
<li>TOMS</li>
<li>Sorting and merging strings</li>
</ul>
<p>The following libraries are not free:</p>
<ul class="list">
<li>The NAG Fortran numerical library</li>
<li>The Visual Numerics IMSL library</li>
<li>Numerical Recipes</li>
</ul>
<h1>Fortran - Programming Style</h1>
<p>Programming style is all about following some rules while developing programs. These good practices impart values like readability, and unambiguity into your program.</p>
<p>A good program should have the following characteristics:</p>
<ul class="list">
<li>Readability</li> 
<li>Proper logical structure</li>
<li>Self-explanatory notes and comments</li>
</ul>
<p>For example, if you make a comment like the following, it will not be of much help:</p>
<pre class="prettyprint notranslate">
! loop from 1 to 10 
do i=1,10  
</pre>
<p>However, if you are calculating binomial coefficient, and need this loop for nCr then a comment like this will be helpful:</p>
<pre class="prettyprint notranslate">
! loop to calculate nCr 
do i=1,10
</pre>
<ul class="list">
<li><p>Indented code blocks to make various levels of code clear.</p></li>
<li><p>Self-checking codes to ensure there will be no numerical errors like division by zero, square root of a negative real number or logarithm of a negative real number.</p></li> 
<li><p>Including codes that ensure variables do not take illegal or out of range values, i.e., input validation.</p></li> 
<li><p>Not putting checks where it would be unnecessary and slows down the execution. For example:</p></li>
</ul>
<pre class="prettyprint notranslate">
real :: x 
x = sin(y) + 1.0
if (x >= 0.0) then
z = sqrt(x)
end if
</pre>

<title>Fortran Useful Resources</title>

<h1>Fortran - Useful Resources</h1>

<p>The following resources contain additional information on Fortran. Please use them to get more in-depth knowledge on this topic.</p>

<h2>Useful Links on Fortran</h2>

<p><a target="_blank" rel="nofollow" href="https://codingground.tutorialspoint.com">Online Fortran Compiler</a> - Free Fortran online compiler at Coding Ground.</p>

<p><a target="_blank" rel="nofollow" href="https://gcc.gnu.org/fortran/">GNU Fortran</a> - GNU Fortran Home Page.</p>

<p><a target="_blank" rel="nofollow" href="http://en.wikipedia.org/wiki/Fortran">Wikipedia</a> - Wikipedia reference for Fortran.</p>

<h2>Useful Books on Fortran</h2>

<p>To enlist your site on this page, please drop an email to <b>contact@tutorialspoint.com</b></p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Discuss Fortran</title>

<h1>Discuss Fortran</h1>

<p>Fortran was originally developed by a team at IBM in 1957 for scientific calculations. Later developments made it into a high level programming language. In this tutorial, we will learn the basic concepts of Fortran and its programming code.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

</body></html>