<!DOCTYPE html><html><body><title>C# Tutorial</title>

<h1>C# Tutorial</h1>

<p>C# is a simple, modern, general-purpose, object-oriented programming language developed by Microsoft within its .NET initiative led by Anders Hejlsberg. This tutorial will teach you basic C# programming and will also take you through various advanced concepts related to C# programming language.</p>

<h1>Audience</h1>

<p>This tutorial has been prepared for the beginners to help them understand basic C# programming.</p>

<h1>Prerequisites</h1>

<p>C# programming is very much based on C and C++ programming languages, so if you have a basic understanding of C or C++ programming, then it will be fun to learn C#.</p>

<h1>Execute C# Online</h1>

<p>For most of the examples given in this tutorial you will find Try it option, so just make use of this option to execute your C# programs at the spot and enjoy your learning.</p>

<p>Try following example using Try it option available at the top right corner of the below sample code box &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate tryit">
using System;
namespace HelloWorldApplication
{
   class HelloWorld
   {
      static void Main(string[] args)
      {
         /* my first program in C# */
         Console.WriteLine("Hello World");
         Console.ReadKey();
      }
   }
}
</pre>

<title>C# Overview</title>

<h1>C# - Overview</h1>

<p>C# is a modern, general-purpose, object-oriented programming language developed by Microsoft and approved by European Computer Manufacturers Association (ECMA) and International Standards Organization (ISO).</p>

<p>C# was developed by Anders Hejlsberg and his team during the development of .Net Framework.</p>

<p>C# is designed for Common Language Infrastructure (CLI), which consists of the executable code and runtime environment that allows use of various high-level languages on different computer platforms and architectures.</p>

<p>The following reasons make C# a widely used professional language:</p>

<h2>Strong Programming Features of C#</h2>

<p>Although C# constructs closely follow traditional high-level languages, C and C++ and being an object-oriented programming language. It has strong resemblance with Java, it has numerous strong programming features that make it endearing to a number of programmers worldwide.</p>

<p>Following is the list of few important features of C#:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>C# - Environment</title>

<h1>C# - Environment</h1>

<h3>Try it Option Online</h3>

<p>We have set up the C# Programming environment online, so that you can compile and execute all the available examples online. It gives you confidence in what you are reading and enables you to verify the programs with different options. Feel free to modify any example and execute it online.</p>

<p>Try the following example using our online compiler available at <a href="http://www.tutorialspoint.com/codingground.htm">CodingGround</a></p>

<p>For most of the examples given in this tutorial, you will find a Try it option in our website code sections at the top right corner that will take you to the online compiler. So just make use of it and enjoy your learning.</p>

<p>In this chapter, we will discuss the tools required for creating C# programming.  We have already mentioned that C# is part of .Net framework and is used for writing .Net applications. Therefore, before discussing the available tools for running a C# program, let us understand how C# relates to the .Net framework.</p>

<h2>The .Net Framework</h2>

<p>The .Net framework is a revolutionary platform that helps you to write the following types of applications:</p>

<p>The .Net framework applications are multi-platform applications. The framework has been designed in such a way that it can be used from any of the following languages: C#, C++, Visual Basic, Jscript, COBOL, etc. All these languages can access the framework as well as communicate with each other.</p>

<p>The .Net framework consists of an enormous library of codes used by the client languages such as C#. Following are some of the components of the .Net framework:</p>

<p>For the jobs each of these components perform, please see <a href="http://www.tutorialspoint.com/asp.net/asp.net_introduction.htm">ASP.Net - Introduction</a>, and for details of each component, please consult Microsoft's documentation.</p>

<h2>Integrated Development Environment (IDE) for C#</h2>

<p>Microsoft provides the following development tools for C# programming:</p>

<p>The last two are freely available from Microsoft official website. Using these tools, you can write all kinds of C# programs from simple command-line applications to more complex applications. You can also write C# source code files using a basic text editor, like Notepad, and compile the code into assemblies using the command-line compiler, which is again a part of the .NET Framework.</p>

<p>Visual C# Express and Visual Web Developer Express edition are trimmed down versions of Visual Studio and has the same appearance. They retain most features of Visual Studio. In this tutorial, we have used Visual C# 2010 Express.</p>

<p>You can download it from <a target="_blank" rel="nofollow" href="http://www.microsoft.com/visualstudio/eng/downloads">Microsoft Visual Studio</a>. It gets installed automatically on your machine.</p>

<p>Note: You need an active internet connection for installing the express edition.</p>

<h2>Writing C# Programs on Linux or Mac OS</h2>

<p>Although the.NET Framework runs on the Windows operating system, there are some alternative versions that work on other operating systems. <b>Mono</b> is an open-source version of the .NET Framework which includes a C# compiler and runs on several operating systems, including various flavors of Linux and Mac OS. Kindly check <a target="_blank" rel="nofollow" href="http://www.go-mono.com/mono-downloads/download.html">Go Mono</a>.</p>

<p>The stated purpose of Mono is not only to be able to run Microsoft .NET applications cross-platform, but also to bring better development tools for Linux developers. Mono can be run on many operating systems including Android, BSD, iOS, Linux, OS X, Windows, Solaris, and UNIX.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate tryit">
using System;
namespace HelloWorldApplication
{
   class HelloWorld
   {
      static void Main(string[] args)
      {
         /* my first program in C# */
         Console.WriteLine("Hello World");
         Console.ReadKey();
      }
   }
}
</pre>

<title>C# - Program Structure</title>

<h1>C# - Program Structure</h1>

<p>Before we study basic building blocks of the C# programming language, let us look at a bare minimum C# program structure so that we can take it as a reference in upcoming chapters.</p>

<h2>Creating Hello World Program</h2>

<p>A C# program consists of the following parts:</p>

<p>Let us look at a simple code that prints the words "Hello World":</p>

<p>When this code is compiled and executed, it produces the following result:</p>

<p>Let us look at the various parts of the given program:</p>

<p>The first line of the program <b>using System;</b> -  the <b>using</b> keyword is used to include the <b>System </b> namespace in the program. A program generally has multiple <b>using</b> statements.</p>

<p>The next line has the <b>namespace</b> declaration. A <b>namespace</b> is a collection of classes. The <i>HelloWorldApplication</i> namespace contains the class <i>HelloWorld</i>.</p>

<p>The next line has a <b>class</b> declaration, the class <i>HelloWorld</i> contains the data and method definitions that your program uses. Classes generally contain multiple methods. Methods define the behavior of the class. However, the <i>HelloWorld</i> class has only one method <b> Main</b>.</p>

<p>The next line defines the <b>Main</b> method, which is the <b>entry point</b> for all C# programs. The <b>Main </b> method states what the class does when executed.</p>

<p>The next line /*...*/ is ignored by the compiler and it is put to add <b> comments</b> in the program.</p>

<p><i>WriteLine</i> is a method of the <i>Console</i> class defined in the <i>System</i> namespace. This statement causes the message "Hello, World!" to be displayed on the screen.</p>

<p>The last line <b>Console.ReadKey();</b> is for the VS.NET Users. This makes the program wait for a key press and it prevents the screen from running and closing quickly when the program is launched from Visual Studio .NET.</p>

<p>It is worth to note the following points:</p>

<p>C# is case sensitive.</p>

<p>All statements and expression must end with a semicolon (;).</p>

<p>The program execution starts at the Main method.</p>

<p>Unlike Java, program file name could be different from the class name.</p>

<h2>Compiling and Executing the Program</h2>

<p>If you are using Visual Studio.Net for compiling and executing C# programs, take the following steps:</p>

<p>Start Visual Studio.</p>

<p>On the menu bar, choose File -&gt; New -&gt; Project.</p>

<p>Choose Visual C# from templates, and then choose Windows.</p>

<p>Choose Console Application.</p>

<p>Specify a name for your project and click OK button.</p>

<p>This creates a new project in Solution Explorer.</p>

<p>Write code in the Code Editor. </p>

<p>Click the Run button or press F5 key to execute the project. A Command Prompt window appears that contains the line Hello World.</p>

<p>You can compile a C# program by using the command-line instead of the Visual Studio IDE:</p>

<p>Open a text editor and add the above-mentioned code.</p>

<p>Save the file as <b>helloworld.cs</b></p>

<p>Open the command prompt tool and go to the directory where you saved the file.</p>

<p>Type <b>csc helloworld.cs</b> and press enter to compile your code.</p>

<p>If there are no errors in your code, the command prompt takes you to the next line and generates <b>helloworld.exe</b> executable file.</p>

<p>Type <b>helloworld</b> to execute your program.</p>

<p>You can see the output Hello World printed on the screen.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate tryit">
using System;
namespace HelloWorldApplication
{
   class HelloWorld
   {
      static void Main(string[] args)
      {
         /* my first program in C# */
         Console.WriteLine("Hello World");
         Console.ReadKey();
      }
   }
}
</pre>
<p>When this code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Hello World
</pre>

<title>C# - Basic Syntax</title>

<h1>C# - Basic Syntax</h1>

<p>C# is an object-oriented programming language. In Object-Oriented Programming methodology, a program consists of various objects that interact with each other by means of actions. The actions that an object may take are called methods. Objects of the same kind are said to have the same type or, are said to be in the same class.</p>

<p>For example, let us consider a Rectangle object. It has attributes such as length and width. Depending upon the design, it may need ways for accepting the values of these attributes, calculating the area, and displaying details.</p>

<p>Let us look at implementation of a Rectangle class and discuss C# basic syntax:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>The <i>using</i> Keyword</h2>

<p>The first statement in any C# program is</p>

<p>The <b>using</b> keyword is used for including the namespaces in the program. A program can include multiple using statements.</p>

<h2>The <i>class</i> Keyword</h2>

<p>The <b>class</b> keyword is used for declaring a class.</p>

<h2>Comments in C#</h2>

<p>Comments are used for explaining code. Compilers ignore the comment entries. The multiline comments in C# programs start with /* and terminates with the characters */ as shown below:</p>

<p>Single-line comments are indicated by the '//' symbol. For example,</p>

<h2>Member Variables</h2>

<p>Variables are attributes or data members of a class, used for storing data. In the preceding program, the <i>Rectangle</i> class has two member variables named <i>length</i> and <i>width</i>.</p>

<h2>Member Functions</h2>

<p>Functions are set of statements that perform a specific task. The member functions of a class are declared within the class. Our sample class Rectangle contains three member functions: <i> AcceptDetails</i>, <i>GetArea</i> and <i>Display</i>.</p>

<h2>Instantiating a Class</h2>

<p>In the preceding program, the class <i>ExecuteRectangle</i> contains the <i>Main()</i>  method and instantiates the <i>Rectangle</i> class.</p>

<h2>Identifiers</h2>

<p>An identifier is a name used to identify a class, variable, function, or any other user-defined item. The basic rules for naming classes in C# are as follows:</p>

<p>A name must begin with a letter that could be followed by a sequence of letters, digits (0 - 9) or underscore. The first character in an identifier cannot be a digit.</p>

<p>It must not contain any embedded space or symbol such as? - + ! @ # % ^ & * ( ) [ ] { } . ; : " ' / and \. However, an underscore ( _ ) can be used.</p>

<p>It should not be a C# keyword.</p>

<h2>C# Keywords</h2>

<p>Keywords are reserved words predefined to the C# compiler. These keywords cannot be used as identifiers. However, if you want to use these keywords as identifiers, you may prefix the keyword with the @ character.</p>

<p>In C#, some identifiers have special meaning in context of code, such as get and set are called contextual keywords.</p>

<p>The following table lists the reserved keywords and contextual keywords in C#:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate tryit">
using System;
namespace RectangleApplication
{
   class Rectangle 
   {
      // member variables
      double length;
      double width;
      public void Acceptdetails()
      {
         length = 4.5;    
         width = 3.5;
      }
      
      public double GetArea()
      {
         return length * width; 
      }
      
      public void Display()
      {
         Console.WriteLine("Length: {0}", length);
         Console.WriteLine("Width: {0}", width);
         Console.WriteLine("Area: {0}", GetArea());
      }
   }
   
   class ExecuteRectangle 
   {
      static void Main(string[] args) 
      {
         Rectangle r = new Rectangle();
         r.Acceptdetails();
         r.Display();
         Console.ReadLine(); 
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Length: 4.5
Width: 3.5
Area: 15.75
</pre>
<h2>The <i>using</i> Keyword</h2>
<p>The first statement in any C# program is</p>
<pre class="prettyprint notranslate">
using System;
</pre>
<p>The <b>using</b> keyword is used for including the namespaces in the program. A program can include multiple using statements.</p>
<h2>The <i>class</i> Keyword</h2>
<p>The <b>class</b> keyword is used for declaring a class.</p> 
<h2>Comments in C#</h2>
<p>Comments are used for explaining code. Compilers ignore the comment entries. The multiline comments in C# programs start with /* and terminates with the characters */ as shown below:</p>
<pre class="prettyprint notranslate">
/* This program demonstrates
The basic syntax of C# programming 
Language */
</pre>
<p>Single-line comments are indicated by the '//' symbol. For example,</p>
<pre class="prettyprint notranslate">
}//end class Rectangle    
</pre>

<title>C# - Data Types</title>

<h1>C# - Data Types</h1>

<p>The variables in C#, are categorized into the following types:</p>

<h2>Value Type</h2>

<p>Value type variables can be assigned a value directly. They are derived from the class <b> System.ValueType</b>.</p>

<p>The value types directly contain data. Some examples are <b>int, char, and float</b>, which stores numbers, alphabets, and floating point numbers, respectively. When you declare an <b>int</b> type, the system allocates memory to store the value.</p>

<p>The following table lists the available value types in C# 2010:</p>

<p>To get the exact size of a type or a variable on a particular platform, you can use the <b>sizeof</b> method. The expression <i>sizeof(type)</i> yields the storage size of the object or type in bytes. Following is an example to get the size of <i>int</i> type on any machine:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Reference Type</h2>

<p>The reference types do not contain the actual data stored in a variable, but they contain a reference to the variables.</p>

<p>In other words, they refer to a memory location. Using multiple variables, the reference types can refer to a memory location. If the data in the memory location is changed by one of the variables, the other variable automatically reflects this change in value. Example of <b>built-in</b> reference types are: <b>object</b>, <b>dynamic,</b> and <b>string</b>.</p>

<h3>Object Type</h3>

<p>The <b>Object Type</b> is the ultimate base class for all data types in C# Common Type System (CTS). Object is an alias for System.Object class. The object types can be assigned values of any other types, value types, reference types, predefined or user-defined types. However, before assigning values, it needs type conversion.</p>

<p>When a value type is converted to object type, it is called <b>boxing</b> and on the other hand, when an object type is converted to a value type, it is called <b>unboxing</b>.</p>

<h3>Dynamic Type</h3>

<p>You can store any type of value in the dynamic data type variable. Type checking for these types of variables takes place at run-time.</p>

<p>Syntax for declaring a dynamic type is:</p>

<p>For example,</p>

<p>Dynamic types are similar to object types except that type checking for object type variables takes place at compile time, whereas that for the dynamic type variables takes place at run time.</p>

<h3>String Type</h3>

<p>The <b>String Type</b> allows you to assign any string values to a variable. The string type is an alias for the System.String class. It is derived from object type. The value for a string type can be assigned using string literals in two forms: quoted and @quoted.</p>

<p>For example,</p>

<p>A @quoted string literal looks as follows:</p>

<p>The user-defined reference types are: class, interface, or delegate. We will discuss these types in later chapter.</p>

<h2>Pointer Type</h2>

<p>Pointer type variables store the memory address of another type. Pointers in C# have the same capabilities as the pointers in C or C++.</p>

<p>Syntax for declaring a pointer type is:</p>

<p>For example,</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate tryit">
using System;
namespace DataTypeApplication
{
   class Program 
   {
      static void Main(string[] args)
      {
         Console.WriteLine("Size of int: {0}", sizeof(int));
         Console.ReadLine();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Size of int: 4
</pre>
<h2>Reference Type</h2>
<p>The reference types do not contain the actual data stored in a variable, but they contain a reference to the variables.</p>
<p>In other words, they refer to a memory location. Using multiple variables, the reference types can refer to a memory location. If the data in the memory location is changed by one of the variables, the other variable automatically reflects this change in value. Example of <b>built-in</b> reference types are: <b>object</b>, <b>dynamic,</b> and <b>string</b>.</p>
<h3>Object Type</h3>
<p>The <b>Object Type</b> is the ultimate base class for all data types in C# Common Type System (CTS). Object is an alias for System.Object class. The object types can be assigned values of any other types, value types, reference types, predefined or user-defined types. However, before assigning values, it needs type conversion.</p>
<p>When a value type is converted to object type, it is called <b>boxing</b> and on the other hand, when an object type is converted to a value type, it is called <b>unboxing</b>.</p>
<pre class="prettyprint notranslate">
object obj;
obj = 100; // this is boxing
</pre>
<h3>Dynamic Type</h3>
<p>You can store any type of value in the dynamic data type variable. Type checking for these types of variables takes place at run-time.</p>
<p>Syntax for declaring a dynamic type is:</p>
<pre class="prettyprint notranslate">
dynamic &lt;variable_name&gt; = value;
</pre>
<p>For example,</p>
<pre class="prettyprint notranslate">
dynamic d = 20;
</pre>
<p>Dynamic types are similar to object types except that type checking for object type variables takes place at compile time, whereas that for the dynamic type variables takes place at run time.</p>
<h3>String Type</h3>
<p>The <b>String Type</b> allows you to assign any string values to a variable. The string type is an alias for the System.String class. It is derived from object type. The value for a string type can be assigned using string literals in two forms: quoted and @quoted.</p> 
<p>For example,</p>
<pre class="prettyprint notranslate">
String str = "Tutorials Point";
</pre>
<p>A @quoted string literal looks as follows:</p>
<pre class="prettyprint notranslate">
@"Tutorials Point";
</pre>
<p>The user-defined reference types are: class, interface, or delegate. We will discuss these types in later chapter.</p>
<h2>Pointer Type</h2>
<p>Pointer type variables store the memory address of another type. Pointers in C# have the same capabilities as the pointers in C or C++.</p>
<p>Syntax for declaring a pointer type is:</p>
<pre class="prettyprint notranslate">
type* identifier;
</pre>
<p>For example,</p>
<pre class="prettyprint notranslate">
char* cptr;
int* iptr;
</pre>

<title>C# - Type Conversion</title>

<h1>C# - Type Conversion</h1>

<p>Type conversion is converting one type of data to another type. It is also known as Type Casting. In C#, type casting has two forms:</p>

<p><b>Implicit type conversion</b> - These conversions are performed by C# in a type-safe manner. For example, are conversions from smaller to larger integral types and conversions from derived classes to base classes.</p>

<p><b>Explicit type conversion</b> - These conversions are done explicitly by users using the pre-defined functions. Explicit conversions require a cast operator.</p>

<p>The following example shows an explicit type conversion:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>C# Type Conversion Methods</h2>

<p>C# provides the following built-in type conversion methods:</p>

<p>Converts a type to a Boolean value, where possible.</p>

<p>Converts a type to a byte.</p>

<p>Converts a type to a single Unicode character, where possible.</p>

<p>Converts a type (integer or string type) to date-time structures.</p>

<p>Converts a floating point or integer type to a decimal type.</p>

<p>Converts a type to a double type.</p>

<p>Converts a type to a 16-bit integer.</p>

<p>Converts a type to a 32-bit integer.</p>

<p>Converts a type to a 64-bit integer.</p>

<p>Converts a type to a signed byte type.</p>

<p>Converts a type to a small floating point number.</p>

<p>Converts a type to a string.</p>

<p>Converts a type to a specified type.</p>

<p>Converts a type to an unsigned int type.</p>

<p>Converts a type to an unsigned long type.</p>

<p>Converts a type to an unsigned big integer.</p>

<p>The following example converts various value types to string type:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate tryit">
using System;
namespace TypeConversionApplication 
{
   class ExplicitConversion 
   {
      static void Main(string[] args) 
      {
         double d = 5673.74; 
         int i;
         
         // cast double to int.
         i = (int)d;
         Console.WriteLine(i);
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
5673
</pre>
<h2>C# Type Conversion Methods</h2>
<p>C# provides the following built-in type conversion methods:</p>
<table class="table table-bordered">
<tr>
<th style="width:5%;">Sr.No</th>
<th>Methods &amp; Description</th>
</tr>
<tr>
<td>1</td>
<td><b>ToBoolean</b>
<p>Converts a type to a Boolean value, where possible.</p>
</td>
</tr>
<tr>
<td>2</td>
<td><b>ToByte</b>
<p>Converts a type to a byte.</p>
</td>
</tr>
<tr>
<td>3</td>
<td><b>ToChar</b>
<p>Converts a type to a single Unicode character, where possible.</p>
</td>
</tr>
<tr>
<td>4</td>
<td><b>ToDateTime</b>
<p>Converts a type (integer or string type) to date-time structures.</p>
</td>
</tr>
<tr>
<td>5</td>
<td><b>ToDecimal</b>
<p>Converts a floating point or integer type to a decimal type.</p>
</td>
</tr>
<tr>
<td>6</td>
<td><b>ToDouble</b>
<p>Converts a type to a double type.</p>
</td>
</tr>
<tr>
<td>7</td>
<td><b>ToInt16</b>
<p>Converts a type to a 16-bit integer.</p>
</td>
</tr>
<tr>
<td>8</td>
<td><b>ToInt32</b>
<p>Converts a type to a 32-bit integer.</p>
</td>
</tr>
<tr>
<td>9</td>
<td><b>ToInt64</b>
<p>Converts a type to a 64-bit integer.</p>
</td>
</tr>
<tr>
<td>10</td>
<td><b>ToSbyte</b>
<p>Converts a type to a signed byte type.</p>
</td>
</tr>
<tr>
<td>11</td>
<td><b>ToSingle</b>
<p>Converts a type to a small floating point number.</p>
</td>
</tr>
<tr>
<td>12</td>
<td><b>ToString</b>
<p>Converts a type to a string.</p>
</td>
</tr>
<tr>
<td>13</td>
<td><b>ToType</b>
<p>Converts a type to a specified type.</p>
</td>
</tr>
<tr>
<td>14</td>
<td><b>ToUInt16</b>
<p>Converts a type to an unsigned int type.</p>
</td>
</tr>
<tr>
<td>15</td>
<td><b>ToUInt32</b>
<p>Converts a type to an unsigned long type.</p>
</td>
</tr>
<tr>
<td>16</td>
<td><b>ToUInt64</b>
<p>Converts a type to an unsigned big integer.</p>
</td>
</tr>
</table>
<p>The following example converts various value types to string type:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace TypeConversionApplication 
{
   class StringConversion
   {
      static void Main(string[] args)
      {
         int i = 75;
         float f = 53.005f;
         double d = 2345.7652;
         bool b = true;

         Console.WriteLine(i.ToString());
         Console.WriteLine(f.ToString());
         Console.WriteLine(d.ToString());
         Console.WriteLine(b.ToString());
         Console.ReadKey();
            
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
75
53.005
2345.7652
True
</pre>

<title>C# - Variables</title>

<h1>C# - Variables</h1>

<p>A variable is nothing but a name given to a storage area that our programs can manipulate. Each variable in C# has a specific type, which determines the size and layout of the variable's memory the range of values that can be stored within that memory and the set of operations that can be applied to the variable.</p>

<p>The basic value types provided in C# can be categorized as:</p>

<p>C# also allows defining other value types of variable such as <b>enum</b> and reference types of variables such as <b> class</b>, which we will cover in subsequent chapters.</p>

<h2>Defining Variables</h2>

<p>Syntax for variable definition in C# is:</p>

<p>Here, data_type must be a valid C# data type including char, int, float, double, or any user-defined data type, and variable_list may consist of one or more identifier names separated by commas.</p>

<p>Some valid variable definitions are shown here:</p>

<p>You can initialize a variable at the time of definition as:</p>

<h2>Initializing Variables</h2>

<p>Variables are initialized (assigned a value) with an equal sign followed by a constant expression. The general form of initialization is:</p>

<p>Variables can be initialized in their declaration. The initializer consists of an equal sign followed by a constant expression as:</p>

<p>Some examples are:</p>

<p>It is a good programming practice to initialize variables properly, otherwise sometimes program may produce unexpected result.</p>

<p>The following example uses various types of variables:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Accepting Values from User</h2>

<p>The <b>Console</b> class in the <b>System</b> namespace provides a function <b>ReadLine()</b> for accepting input from the user and store it into a variable.</p>

<p>For example,</p>

<p>The function <b>Convert.ToInt32()</b> converts the data entered by the user to int data type, because <b>Console.ReadLine()</b> accepts the data in string format.</p>

<h2>Lvalue and Rvalue Expressions in C#:</h2>

<p>There are two kinds of expressions in C#:</p>

<p><b>lvalue:</b> An expression that is an lvalue may appear as either the left-hand or right-hand side of an assignment.</p>

<p><b>rvalue:</b> An expression that is an rvalue may appear on the right- but not left-hand side of an assignment.</p>

<p>Variables are lvalues and hence they may appear on the left-hand side of an assignment. Numeric literals are rvalues and hence they may not be assigned and can not appear on the left-hand side. Following is a valid C# statement:</p>

<p>But following is not a valid statement and would generate compile-time error:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
&lt;data_type&gt; &lt;variable_list&gt;;
</pre>
<p>Here, data_type must be a valid C# data type including char, int, float, double, or any user-defined data type, and variable_list may consist of one or more identifier names separated by commas.</p>
<p>Some valid variable definitions are shown here:</p>
<pre class="prettyprint notranslate">
int i, j, k;
char c, ch;
float f, salary;
double d;
</pre>
<p>You can initialize a variable at the time of definition as:</p>
<pre class="prettyprint notranslate">
int i = 100;
</pre>
<h2>Initializing Variables</h2>
<p>Variables are initialized (assigned a value) with an equal sign followed by a constant expression. The general form of initialization is:</p>
<pre class="prettyprint notranslate">
variable_name = value;
</pre>
<p>Variables can be initialized in their declaration. The initializer consists of an equal sign followed by a constant expression as:</p>
<pre class="prettyprint notranslate">
&lt;data_type&gt; &lt;variable_name&gt; = value;
</pre>
<p>Some examples are:</p>
<pre class="prettyprint notranslate">
int d = 3, f = 5;    /* initializing d and f. */
byte z = 22;         /* initializes z. */
double pi = 3.14159; /* declares an approximation of pi. */
char x = 'x';        /* the variable x has the value 'x'. */
</pre>
<p>It is a good programming practice to initialize variables properly, otherwise sometimes program may produce unexpected result.</p>
<p>The following example uses various types of variables:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace VariableDefinition 
{
   class Program 
   {
      static void Main(string[] args) 
      {
         short a;
         int b ;
         double c;

         /* actual initialization */
         a = 10;
         b = 20;
         c = a + b;
         Console.WriteLine("a = {0}, b = {1}, c = {2}", a, b, c);
         Console.ReadLine();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
a = 10, b = 20, c = 30
</pre>
<h2>Accepting Values from User</h2>
<p>The <b>Console</b> class in the <b>System</b> namespace provides a function <b>ReadLine()</b> for accepting input from the user and store it into a variable.</p> 
<p>For example,</p>
<pre class="prettyprint notranslate">
int num;
num = Convert.ToInt32(Console.ReadLine());
</pre>
<p>The function <b>Convert.ToInt32()</b> converts the data entered by the user to int data type, because <b>Console.ReadLine()</b> accepts the data in string format.</p>
<h2>Lvalue and Rvalue Expressions in C#:</h2>
<p>There are two kinds of expressions in C#:</p>
<ul class="list">
<li><p><b>lvalue:</b> An expression that is an lvalue may appear as either the left-hand or right-hand side of an assignment.</p></li>
<li><p><b>rvalue:</b> An expression that is an rvalue may appear on the right- but not left-hand side of an assignment.</p></li>
</ul>
<p>Variables are lvalues and hence they may appear on the left-hand side of an assignment. Numeric literals are rvalues and hence they may not be assigned and can not appear on the left-hand side. Following is a valid C# statement:</p>
<pre class="prettyprint notranslate">
int g = 20;
</pre>
<p>But following is not a valid statement and would generate compile-time error:</p>
<pre class="prettyprint notranslate">
10 = 20;
</pre>

<title>C# - Constants and Literals</title>

<h1>C# - Constants and Literals</h1>

<p>The constants refer to fixed values that the program may not alter during its execution. These fixed values are also called literals. Constants can be of any of the basic data types like an integer constant, a floating constant, a character constant, or a string literal. There are also enumeration constants as well.</p>

<p>The constants are treated just like regular variables except that their values cannot be modified after their definition.</p>

<h2>Integer Literals</h2>

<p>An integer literal can be a decimal, or hexadecimal constant. A prefix specifies the base or radix: 0x or 0X for hexadecimal, and there is no prefix id for decimal.</p>

<p>An integer literal can also have a suffix that is a combination of U and L, for unsigned and long, respectively. The suffix can be uppercase or lowercase and can be in any order.</p>

<p>Here are some examples of integer literals:</p>

<p>Following are other examples of various types of Integer literals:</p>

<h2>Floating-point Literals</h2>

<p>A floating-point literal has an integer part, a decimal point, a fractional part, and an exponent part. You can represent floating point literals either in decimal form or exponential form.</p>

<p>Here are some examples of floating-point literals:</p>

<p>While representing in decimal form, you must include the decimal point, the exponent, or both; and while representing using exponential form you must include the integer part, the fractional part, or both. The signed exponent is introduced by e or E.</p>

<h2>Character Constants</h2>

<p>Character literals are enclosed in single quotes. For example, 'x' and can be stored in a simple variable of char type. A character literal can be a plain character (such as 'x'), an escape sequence (such as '\t'), or a universal character (such as '\u02C0').</p>

<p>There are certain characters in C# when they are preceded by a backslash. They have special meaning and they are used to represent like newline (\n) or tab (\t). Here, is a list of some of such escape sequence codes:</p>

<p>Following is the example to show few escape sequence characters:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>String Literals</h2>

<p>String literals or constants are enclosed in double quotes "" or with @"". A string contains characters that are similar to character literals: plain characters, escape sequences, and universal characters.</p>

<p>You can break a long line into multiple lines using string literals and separating the parts using whitespaces.</p>

<p>Here are some examples of string literals. All the three forms are identical strings.</p>

<h2>Defining Constants</h2>

<p>Constants are defined using the <b>const</b> keyword. Syntax for defining a constant is:</p>

<p>The following program demonstrates defining and using a constant in your program:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
212         /* Legal */
215u        /* Legal */
0xFeeL      /* Legal */
</pre>
<p>Following are other examples of various types of Integer literals:</p>
<pre class="prettyprint notranslate">
85         /* decimal */
0x4b       /* hexadecimal */
30         /* int */
30u        /* unsigned int */
30l        /* long */
30ul       /* unsigned long */
</pre>
<h2>Floating-point Literals</h2>
<p>A floating-point literal has an integer part, a decimal point, a fractional part, and an exponent part. You can represent floating point literals either in decimal form or exponential form.</p>
<p>Here are some examples of floating-point literals:</p>
<pre class="prettyprint notranslate">
3.14159       /* Legal */
314159E-5F    /* Legal */
510E          /* Illegal: incomplete exponent */
210f          /* Illegal: no decimal or exponent */
.e55          /* Illegal: missing integer or fraction */
</pre>
<p>While representing in decimal form, you must include the decimal point, the exponent, or both; and while representing using exponential form you must include the integer part, the fractional part, or both. The signed exponent is introduced by e or E.</p>
<h2>Character Constants</h2>
<p>Character literals are enclosed in single quotes. For example, 'x' and can be stored in a simple variable of char type. A character literal can be a plain character (such as 'x'), an escape sequence (such as '\t'), or a universal character (such as '\u02C0').</p>
<p>There are certain characters in C# when they are preceded by a backslash. They have special meaning and they are used to represent like newline (\n) or tab (\t). Here, is a list of some of such escape sequence codes:</p>
<table class="table table-bordered">
<tr>
<th style="width:25%">Escape sequence</th>
<th>Meaning</th>
</tr>
<tr>
<td>\\</td>
<td>\ character</td>
</tr>
<tr>
<td>\'</td>
<td> ' character</td>
</tr>
<tr>
<td>\"</td>
<td>" character</td>
</tr>
<tr>
<td>\?</td>
<td>? character</td>
</tr>
<tr>
<td>\a</td>
<td>Alert or bell</td>
</tr>
<tr>
<td>\b</td>
<td>Backspace</td>
</tr>
<tr>
<td>\f</td>
<td>Form feed</td></tr>
<tr>
<td>\n</td>
<td>Newline</td>
</tr>
<tr>
<td>\r</td>
<td>Carriage return</td>
</tr>
<tr>
<td>\t</td>
<td>Horizontal tab</td>
</tr>
<tr>
<td>\v</td>
<td>Vertical tab</td>
</tr>
<tr>
<td>\xhh . . .</td>
<td>Hexadecimal number of one or more digits</td>
</tr>
</table>
<p>Following is the example to show few escape sequence characters:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace EscapeChar 
{
   class Program
   {
      static void Main(string[] args)
      {
         Console.WriteLine("Hello\tWorld\n\n");
         Console.ReadLine();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Hello   World
</pre>
<h2>String Literals</h2>
<p>String literals or constants are enclosed in double quotes "" or with @"". A string contains characters that are similar to character literals: plain characters, escape sequences, and universal characters.</p>
<p>You can break a long line into multiple lines using string literals and separating the parts using whitespaces.</p>
<p>Here are some examples of string literals. All the three forms are identical strings.</p>
<pre class="prettyprint notranslate">
"hello, dear"
"hello, \
dear"
"hello, " "d" "ear"
@"hello dear"
</pre>
<h2>Defining Constants</h2>
<p>Constants are defined using the <b>const</b> keyword. Syntax for defining a constant is:</p>
<pre class="prettyprint notranslate">
const &lt;data_type&gt; &lt;constant_name&gt; = value;
</pre>
<p>The following program demonstrates defining and using a constant in your program:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace DeclaringConstants
{
    class Program
    {
        static void Main(string[] args)
        {
            const double pi = 3.14159;   
            
            // constant declaration 
            double r;
            Console.WriteLine("Enter Radius: ");
            r = Convert.ToDouble(Console.ReadLine());
            double areaCircle = pi * r * r;
            Console.WriteLine("Radius: {0}, Area: {1}", r, areaCircle);
            Console.ReadLine();
        }
    }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Enter Radius: 
3
Radius: 3, Area: 28.27431
</pre>

<title>C# - Operators</title>

<h1>C# - Operators</h1>

<p>An operator is a symbol that tells the compiler to perform specific mathematical or logical manipulations. C# has rich set of built-in operators and provides the following type of operators:</p>

<p>This tutorial explains the arithmetic, relational, logical, bitwise, assignment, and other operators one by one.</p>

<h2>Arithmetic Operators</h2>

<p>Following table shows all the arithmetic operators supported by C#. Assume variable <b>A</b> holds 10 and variable <b>B</b> holds 20 then:</p>

<p><a href="/csharp/csharp_arithmetic_operators.htm" title="Arithmetic Operators in C#">Show Examples</a></p>

<h2>Relational Operators</h2>

<p>Following table shows all the relational operators supported by C#. Assume variable <b>A</b> holds 10 and variable <b>B</b> holds 20, then:</p>

<p><a href="/csharp/csharp_relational_operators.htm" title="Relational Operators in C#">Show Examples</a></p>

<h2>Logical Operators</h2>

<p>Following table shows all the logical operators supported by C#. Assume variable <b>A</b> holds Boolean value true and variable <b>B</b> holds Boolean value false, then:</p>

<p><a href="/csharp/csharp_logical_operators.htm" title="Logical Operators in C#">Show Examples</a></p>

<h2>Bitwise Operators</h2>

<p>Bitwise operator works on bits and perform bit by bit operation. The truth tables for &amp;, |, and ^ are as follows:</p>

<p>Assume if A = 60; and B = 13; then in the binary format they are as follows:</p>

<p>A = 0011 1100</p>

<p>B = 0000 1101</p>

<p>-----------------</p>

<p>A&amp;B = 0000 1100</p>

<p>A|B = 0011 1101</p>

<p>A^B = 0011 0001</p>

<p>~A&nbsp; = 1100 0011</p>

<p>The Bitwise operators supported by C# are listed in the following table. Assume variable A holds 60 and variable B holds 13, then:</p>

<p><a href="/csharp/csharp_bitwise_operators.htm" title="Bitwise Operators in C#">Show Examples</a></p>

<h2>Assignment Operators</h2>

<p>There are following assignment operators supported by C#:</p>

<p><a href="/csharp/csharp_assignment_operators.htm" title="Assignment Operators in C#">Show Examples</a></p>

<h2>Miscellaneous Operators</h2>

<p>There are few other important operators including <b>sizeof, typeof</b> and <b>? :</b>  supported by C#.</p>

<p><a href="/csharp/csharp_misc_operators.htm" title="misc operators in C#">Show Examples</a></p>

<p>StringReader r = obj as StringReader;</p>

<h2>Operator Precedence in C#</h2>

<p>Operator precedence determines the grouping of terms in an expression. This affects evaluation of an expression. Certain operators have higher precedence than others; for example, the multiplication operator has higher precedence than the addition operator.</p>

<p>For example x = 7 + 3 * 2; here, x is assigned 13, not 20 because operator * has higher precedence than +, so the first evaluation takes place for 3*2 and then 7 is added into it.</p>

<p>Here, operators with the highest precedence appear at the top of the table, those with the lowest appear at the bottom. Within an expression, higher precedence operators are evaluated first.</p>

<p><a href="/csharp/csharp_operators_precedence.htm" title="Operators Precedence in C#">Show Examples</a></p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>C# - Decision Making</title>

<h1>C# - Decision Making</h1>

<p>Decision making structures requires the programmer to specify one or more conditions to be evaluated or tested by the program, along with a statement or statements to be executed if the condition is determined to be true, and optionally, other statements to be executed if the condition is determined to be false.</p>

<p>Following is the general form of a typical decision making structure found in most of the programming languages:</p>

<p>C# provides following types of decision making statements. Click the following links to check their detail.</p>

<p><a href="/csharp/if_statement_in_csharp.htm" title="if statement in C#">if statement</a></p>

<p><a href="/csharp/if_else_statement_in_csharp.htm" title="if...else statement in C#">if...else statement</a></p>

<p><a href="/csharp/nested_if_statements_in_csharp.htm" title="nested if statements in C#">nested if statements</a></p>

<p><a href="/csharp/switch_statement_in_csharp.htm" title="switch statement in C#">switch statement</a></p>

<p><a href="/csharp/nested_switch_statements_in_csharp.htm" title="nested switch statements in C#">nested switch statements</a></p>

<h2>The ? : Operator:</h2>

<p>We have covered <b>conditional operator ? :</b> in previous chapter which can be used to replace <b>if...else</b> statements. It has the following general form:</p>

<p>Where Exp1, Exp2, and Exp3 are expressions. Notice the use and placement of the colon.</p>

<p>The value of a ? expression is determined as follows: Exp1 is evaluated. If it is true, then Exp2 is evaluated and becomes the value of the entire ? expression. If Exp1 is false, then Exp3 is evaluated and its value becomes the value of the expression.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
Exp1 ? Exp2 : Exp3;
</pre>

<title>C# - Loops</title>

<h1>C# - Loops</h1>

<p>There may be a situation, when you need to execute a block of code several number of times. In general, the statements are executed sequentially: The first statement in a function is executed first, followed by the second, and so on.</p>

<p>Programming languages provide various control structures that allow for more complicated execution paths.</p>

<p>A loop statement allows us to execute a statement or a group of statements multiple times and following is the general from of a loop statement in most of the programming languages:</p>

<p>C# provides following types of loop to handle looping requirements. Click the following links to check their detail.</p>

<p><a href="/csharp/csharp_while_loop.htm" title="while loop in C#">while loop</a></p>

<p><a href="/csharp/csharp_for_loop.htm" title="for loop in C#">for loop</a></p>

<p><a href="/csharp/csharp_do_while_loop.htm" title="do...while loop in C#">do...while loop</a></p>

<p><a href="/csharp/csharp_nested_loops.htm" title="nested loops in C#">nested loops</a></p>

<h2>Loop Control Statements</h2>

<p>Loop control statements change execution from its normal sequence. When execution leaves a scope, all automatic objects that were created in that scope are destroyed.</p>

<p>C# provides the following control statements. Click the following links to check their details.</p>

<p><a href="/csharp/csharp_break_statement.htm" title="break statement in C#">break statement</a></p>

<p><a href="/csharp/csharp_continue_statement.htm" title="continue statement in C#">continue statement</a></p>

<h2>Infinite Loop</h2>

<p>A loop becomes infinite loop if a condition never becomes false. The <b>for</b> loop is traditionally used for this purpose. Since none of the three expressions that form the for loop are required, you can make an endless loop by leaving the conditional expression empty.</p>

<h3>Example</h3>

<p>When the conditional expression is absent, it is assumed to be true. You may have an initialization and increment expression, but programmers more commonly use the for(;;) construct to signify an infinite loop.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
using System;
namespace Loops
{
   class Program
   {
      static void Main(string[] args)
      {
         for (; ; )
         {
            Console.WriteLine("Hey! I am Trapped");
         }
      }
   }
} 
</pre>

<title>C# - Encapsulation</title>

<h1>C# - Encapsulation</h1>

<p><b>Encapsulation</b> is defined 'as the process of enclosing one or more items within a physical or logical package'. Encapsulation, in object oriented programming methodology, prevents access to implementation details. </p>

<p>Abstraction and encapsulation are related features in object oriented programming. Abstraction allows making relevant information visible and encapsulation enables a programmer to <i>implement the desired level of abstraction</i>.</p>

<p>Encapsulation is implemented by using <b>access specifiers</b>. An <b>access specifier</b> defines the scope and visibility of a class member. C# supports the following access specifiers:</p>

<h2>Public Access Specifier</h2>

<p>Public access specifier allows a class to expose its member variables and member functions to other functions and objects. Any public member can be accessed from outside the class.</p>

<p>The following example illustrates this:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>In the preceding example, the member variables length and width are declared <b>public</b>, so they can be accessed from the function Main() using an instance of the Rectangle class, named <b>r</b>.</p>

<p>The member function <i>Display()</i> and <i>GetArea()</i> can also access these variables directly without using any instance of the class.</p>

<p>The member functions <i>Display()</i> is also declared <b>public</b>, so it can also be accessed from <i>Main()</i> using an instance of the Rectangle class, named <b>r</b>. </p>

<h2>Private Access Specifier</h2>

<p>Private access specifier allows a class to hide its member variables and member functions from other functions and objects. Only functions of the same class can access its private members. Even an instance of a class cannot access its private members. </p>

<p>The following example illustrates this:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>In the preceding example, the member variables length and width are declared <b>private</b>, so they cannot be accessed from the function Main(). The member functions <i>AcceptDetails()</i> and <i>Display()</i> can access these variables. Since the member functions <i>AcceptDetails()</i> and <i>Display()</i> are declared <b>public</b>, they can be accessed from <i>Main()</i> using an instance of the Rectangle class, named <b>r</b>.</p>

<h2>Protected Access Specifier</h2>

<p>Protected access specifier allows a child class to access the member variables and member functions of its base class. This way it helps in implementing inheritance. We will discuss this in more details in the inheritance chapter.</p>

<h2>Internal Access Specifier</h2>

<p>Internal access specifier allows a class to expose its member variables and member functions to other functions and objects in the current assembly. In other words, any member with internal access specifier can be accessed from any class or method defined within the application in which the member is defined.</p>

<p>The following program illustrates this:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>In the preceding example, notice that the member function <i>GetArea()</i> is not declared with any access specifier. Then what would be the default access specifier of a class member if we don't mention any? It is <b>private</b>.</p>

<h2>Protected Internal Access Specifier</h2>

<p>The protected internal access specifier allows a class to hide its member variables and member functions from other class objects and functions, except a child class within the same application. This is also used while implementing inheritance.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate tryit">
using System;
namespace RectangleApplication
{
   class Rectangle
   {
      //member variables
      public double length;
      public double width;
      
      public double GetArea()
      {
         return length * width;
      }
      public void Display()
      {
         Console.WriteLine("Length: {0}", length);
         Console.WriteLine("Width: {0}", width);
         Console.WriteLine("Area: {0}", GetArea());
      }
   }//end class Rectangle
   
   class ExecuteRectangle
   {
      static void Main(string[] args)
      {
         Rectangle r = new Rectangle();
         r.length = 4.5;
         r.width = 3.5;
         r.Display();
         Console.ReadLine();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Length: 4.5
Width: 3.5
Area: 15.75
</pre>
<p>In the preceding example, the member variables length and width are declared <b>public</b>, so they can be accessed from the function Main() using an instance of the Rectangle class, named <b>r</b>.</p>
<p>The member function <i>Display()</i> and <i>GetArea()</i> can also access these variables directly without using any instance of the class.</p>
<p>The member functions <i>Display()</i> is also declared <b>public</b>, so it can also be accessed from <i>Main()</i> using an instance of the Rectangle class, named <b>r</b>. </p>
<h2>Private Access Specifier</h2>
<p>Private access specifier allows a class to hide its member variables and member functions from other functions and objects. Only functions of the same class can access its private members. Even an instance of a class cannot access its private members. </p>
<p>The following example illustrates this:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace RectangleApplication 
{
   class Rectangle
   {
      //member variables
      private double length;
      private double width;
      
      public void Acceptdetails()
      {
         Console.WriteLine("Enter Length: ");
         length = Convert.ToDouble(Console.ReadLine());
         Console.WriteLine("Enter Width: ");
         width = Convert.ToDouble(Console.ReadLine());
      }
      public double GetArea()
      {
         return length * width;
      }
      public void Display()
      {
         Console.WriteLine("Length: {0}", length);
         Console.WriteLine("Width: {0}", width);
         Console.WriteLine("Area: {0}", GetArea());
      }
   }//end class Rectangle
   
   class ExecuteRectangle
   {
      static void Main(string[] args)
      {
         Rectangle r = new Rectangle();
         r.Acceptdetails();
         r.Display();
         Console.ReadLine();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Enter Length:
4.4
Enter Width:
3.3
Length: 4.4
Width: 3.3
Area: 14.52
</pre>
<p>In the preceding example, the member variables length and width are declared <b>private</b>, so they cannot be accessed from the function Main(). The member functions <i>AcceptDetails()</i> and <i>Display()</i> can access these variables. Since the member functions <i>AcceptDetails()</i> and <i>Display()</i> are declared <b>public</b>, they can be accessed from <i>Main()</i> using an instance of the Rectangle class, named <b>r</b>.</p>
<h2>Protected Access Specifier</h2>
<p>Protected access specifier allows a child class to access the member variables and member functions of its base class. This way it helps in implementing inheritance. We will discuss this in more details in the inheritance chapter.</p>
<h2>Internal Access Specifier</h2>
<p>Internal access specifier allows a class to expose its member variables and member functions to other functions and objects in the current assembly. In other words, any member with internal access specifier can be accessed from any class or method defined within the application in which the member is defined.</p>
<p>The following program illustrates this:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace RectangleApplication
{
   class Rectangle
   {
      //member variables
      internal double length;
      internal double width;
      
      double GetArea()
      {
         return length * width;
      }
      public void Display()
      {
         Console.WriteLine("Length: {0}", length);
         Console.WriteLine("Width: {0}", width);
         Console.WriteLine("Area: {0}", GetArea());
      }
   }//end class Rectangle
   
   class ExecuteRectangle
   {
      static void Main(string[] args)
      {
         Rectangle r = new Rectangle();
         r.length = 4.5;
         r.width = 3.5;
         r.Display();
         Console.ReadLine();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Length: 4.5
Width: 3.5
Area: 15.75
</pre>

<title>C# - Methods</title>

<h1>C# - Methods</h1>

<p>A method is a group of statements that together perform a task. Every C# program has at least one class with a method named Main.</p>

<p>To use a method, you need to:</p>

<h2>Defining Methods in C#</h2>

<p>When you define a method, you basically declare the elements of its structure. The syntax for defining a method in C# is as follows:</p>

<p>Following are the various elements of a method:</p>

<p><b>Access Specifier</b>: This determines the visibility of a variable or a method from another class.</p>

<p><b>Return type</b>: A method may return a value. The return type is the data type of the value the method returns. If the method is not returning any values, then the return type is <b>void</b>.</p>

<p><b>Method name</b>: Method name is a unique identifier and it is case sensitive. It cannot be same as any other identifier declared in the class.</p>

<p><b>Parameter list</b>: Enclosed between parentheses, the parameters are used to pass and receive data from a method. The parameter list refers to the type, order, and number of the parameters of a method. Parameters are optional; that is, a method may contain no parameters.</p>

<p><b>Method body</b>: This contains the set of instructions needed to complete the required activity.</p>

<h2>Example</h2>

<p>Following code snippet shows a function <i>FindMax</i> that takes two integer values and returns the larger of the two. It has public access specifier, so it can be accessed from outside the class using an instance of the class.</p>

<h2>Calling Methods in C#</h2>

<p>You can call a method using the name of the method. The following example illustrates this:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>You can also call public method from other classes by using the instance of the class. For example, the method <i>FindMax</i> belongs to the <i>NumberManipulator</i> class, you can call it from another class <i>Test</i>.</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Recursive Method Call</h2>

<p>A method can call itself. This is known as <b>recursion</b>. Following is an example that calculates factorial for a given number using a recursive function:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Passing Parameters to a Method</h2>

<p>When method with parameters is called, you need to pass the parameters to the method. There are three ways that parameters can be passed to a method:</p>

<p><a href="/csharp/csharp_value_parameters.htm" title="Value parameters in C#">Value parameters</a></p>

<p><a href="/csharp/csharp_reference_parameters.htm" title="Reference parameters in C#">Reference parameters</a></p>

<p><a href="/csharp/csharp_output_parameters.htm" title="Output parameters in C#">Output parameters</a></p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
&lt;Access Specifier&gt; &lt;Return Type&gt; &lt;Method Name&gt;(Parameter List)
{
   Method Body
}
</pre>
<p>Following are the various elements of a method:</p>
<ul class="list">
<li><p><b>Access Specifier</b>: This determines the visibility of a variable or a method from another class.</p></li>
<li><p><b>Return type</b>: A method may return a value. The return type is the data type of the value the method returns. If the method is not returning any values, then the return type is <b>void</b>.</p></li>
<li><p><b>Method name</b>: Method name is a unique identifier and it is case sensitive. It cannot be same as any other identifier declared in the class.</p></li>
<li><p><b>Parameter list</b>: Enclosed between parentheses, the parameters are used to pass and receive data from a method. The parameter list refers to the type, order, and number of the parameters of a method. Parameters are optional; that is, a method may contain no parameters.</p></li>
<li><p><b>Method body</b>: This contains the set of instructions needed to complete the required activity.</p></li>
</ul>
<h2>Example</h2>
<p>Following code snippet shows a function <i>FindMax</i> that takes two integer values and returns the larger of the two. It has public access specifier, so it can be accessed from outside the class using an instance of the class.</p>
<pre class="prettyprint notranslate">
class NumberManipulator
{
   public int FindMax(int num1, int num2)
   {
      /* local variable declaration */
      int result;

      if (num1 &gt; num2)
         result = num1;
      else
         result = num2;

      return result;
   }
   ...
}
</pre>
<h2>Calling Methods in C#</h2>
<p>You can call a method using the name of the method. The following example illustrates this:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace CalculatorApplication
{
   class NumberManipulator
   {
      public int FindMax(int num1, int num2)
      {
         /* local variable declaration */
         int result;
         
         if (num1 &gt; num2)
            result = num1;
         else
            result = num2;
         return result;
      }
      static void Main(string[] args)
      {
         /* local variable definition */
         int a = 100;
         int b = 200;
         int ret;
         NumberManipulator n = new NumberManipulator();

         //calling the FindMax method
         ret = n.FindMax(a, b);
         Console.WriteLine("Max value is : {0}", ret );
         Console.ReadLine();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Max value is : 200
</pre>
<p>You can also call public method from other classes by using the instance of the class. For example, the method <i>FindMax</i> belongs to the <i>NumberManipulator</i> class, you can call it from another class <i>Test</i>.</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace CalculatorApplication
{
   class NumberManipulator
   {
      public int FindMax(int num1, int num2)
      {
         /* local variable declaration */
         int result;
         
         if(num1 &gt; num2)
            result = num1;
         else
            result = num2;
         
         return result;
      }
   }
   
   class Test
   {
      static void Main(string[] args)
      {
         /* local variable definition */
         int a = 100;
         int b = 200;
         int ret;
         NumberManipulator n = new NumberManipulator();
         
         //calling the FindMax method
         ret = n.FindMax(a, b);
         Console.WriteLine("Max value is : {0}", ret );
         Console.ReadLine();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Max value is : 200
</pre>
<h2>Recursive Method Call</h2>
<p>A method can call itself. This is known as <b>recursion</b>. Following is an example that calculates factorial for a given number using a recursive function:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace CalculatorApplication
{
   class NumberManipulator
   {
      public int factorial(int num)
      {
         /* local variable declaration */
         int result;
         if (num == 1)
         {
            return 1;
         }
         else
         {
            result = factorial(num - 1) * num;
            return result;
         }
      }
      
      static void Main(string[] args)
      {
         NumberManipulator n = new NumberManipulator();
         //calling the factorial method
         Console.WriteLine("Factorial of 6 is : {0}", n.factorial(6));
         Console.WriteLine("Factorial of 7 is : {0}", n.factorial(7));
         Console.WriteLine("Factorial of 8 is : {0}", n.factorial(8));
         Console.ReadLine();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Factorial of 6 is: 720
Factorial of 7 is: 5040
Factorial of 8 is: 40320
</pre>

<title>C# - Nullables</title>

<h1>C# - Nullables</h1>

<p>C# provides a special data types, the <b>nullable</b> types, to which you can assign normal range of values as well as null values.</p>

<p>For example, you can store any value from -2,147,483,648 to 2,147,483,647 or null in a Nullable&lt;Int32&gt; variable. Similarly, you can assign true, false, or null in a Nullable&lt;bool&gt; variable. Syntax for declaring a <b>nullable</b> type is as follows:</p>

<p>The following example demonstrates use of nullable data types:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>The Null Coalescing Operator (??)</h2>

<p>The null coalescing operator is used with the nullable value types and reference types. It is used for converting an operand to the type of another nullable (or not) value type operand, where an implicit conversion is possible.</p>

<p>If the value of the first operand is null, then the operator returns the value of the second operand, otherwise it returns the value of the first operand. The following example explains this:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
&lt; data_type&gt; ? &lt;variable_name&gt; = null;
</pre>
<p>The following example demonstrates use of nullable data types:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace CalculatorApplication
{
   class NullablesAtShow
   {
      static void Main(string[] args)
      {
         int? num1 = null;
         int? num2 = 45;
         double? num3 = new double?();
         double? num4 = 3.14157;
         
         bool? boolval = new bool?();

         // display the values
         
         Console.WriteLine("Nullables at Show: {0}, {1}, {2}, {3}", num1, num2, num3, num4);
         Console.WriteLine("A Nullable boolean value: {0}", boolval);
         Console.ReadLine();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Nullables at Show: , 45,  , 3.14157
A Nullable boolean value:
</pre>
<h2>The Null Coalescing Operator (??)</h2>
<p>The null coalescing operator is used with the nullable value types and reference types. It is used for converting an operand to the type of another nullable (or not) value type operand, where an implicit conversion is possible.</p> 
<p>If the value of the first operand is null, then the operator returns the value of the second operand, otherwise it returns the value of the first operand. The following example explains this:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace CalculatorApplication
{
   class NullablesAtShow
   {
      static void Main(string[] args)
      {
         double? num1 = null;
         double? num2 = 3.14157;
         double num3;
         num3 = num1 ?? 5.34;      
         Console.WriteLine(" Value of num3: {0}", num3);
         num3 = num2 ?? 5.34;
         Console.WriteLine(" Value of num3: {0}", num3);
         Console.ReadLine();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Value of num3: 5.34
Value of num3: 3.14157
</pre>

<title>C# - Arrays</title>

<h1>C# - Arrays</h1>

<p>An array stores a fixed-size sequential collection of elements of the same type. An array is used to store a collection of data, but it is often more useful to think of an array as a collection of variables of the same type stored at contiguous memory locations.</p>

<p>Instead of declaring individual variables, such as number0, number1, ..., and number99, you declare one array variable such as numbers and use numbers[0], numbers[1], and ..., numbers[99] to represent individual variables. A specific element in an array is accessed by an index.</p>

<p>All arrays consist of contiguous memory locations. The lowest address corresponds to the first element and the highest address to the last element.</p>

<h2>Declaring Arrays</h2>

<p>To declare an array in C#, you can use the following syntax:</p>

<p>where,</p>

<p>d<i>atatype</i> is used to specify the type of elements in the array.</p>

<p><i>[ ]</i> specifies the rank of the array. The rank specifies the size of the array. </p>

<p><i>arrayName</i> specifies the name of the array.</p>

<p>For example,</p>

<h2>Initializing an Array</h2>

<p>Declaring an array does not initialize the array in the memory. When the array variable is initialized, you can assign values to the array.</p>

<p>Array is a reference type, so you need to use the <b>new</b> keyword to create an instance of the array. For example,</p>

<h2>Assigning Values to an Array</h2>

<p>You can assign values to individual array elements, by using the index number, like:</p>

<p>You can assign values to the array at the time of declaration, as shown:</p>

<p>You can also create and initialize an array, as shown:</p>

<p>You may also omit the size of the array, as shown:</p>

<p>You can copy an array variable into another target array variable. In such case, both the target and source point to the same memory location:</p>

<p>When you create an array, C# compiler implicitly initializes each array element to a default value depending on the array type. For example, for an int array all elements are initialized to 0.</p>

<h2>Accessing Array Elements</h2>

<p>An element is accessed by indexing the array name. This is done by placing the index of the element within square brackets after the name of the array. For example,</p>

<p>The following example, demonstrates the above-mentioned concepts declaration, assignment, and accessing arrays:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Using the <i>foreach</i> Loop</h2>

<p>In the previous example, we used a for loop for accessing each array element. You can also use a <b>foreach</b> statement to iterate through an array.</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>C# Arrays</h2>

<p>There are following few important concepts related to array which should be clear to a C# programmer:</p>

<p><a href="/csharp/csharp_multi_dimensional_arrays.htm" title="Multi-dimensional arrays in C#">Multi-dimensional arrays</a></p>

<p><a href="/csharp/csharp_jagged_arrays.htm" title="Jagged arrays in C#">Jagged arrays</a></p>

<p><a href="/csharp/csharp_passing_arrays_to_functions.htm" title="Passing arrays to functions as arguments in C#">Passing arrays to functions</a></p>

<p><a href="/csharp/csharp_param_arrays.htm" title="Param arrays in C#">Param arrays</a></p>

<p><a href="/csharp/csharp_array_class.htm" title="Array class in C">The Array Class</a></td></p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
datatype[] arrayName;
</pre>
<p>where,</p>
<ul class="list">
<li><p>d<i>atatype</i> is used to specify the type of elements in the array.</p></li>
<li><p><i>[ ]</i> specifies the rank of the array. The rank specifies the size of the array. </p></li>
<li><p><i>arrayName</i> specifies the name of the array.</p></li>
</ul>
<p>For example,</p>
<pre class="prettyprint notranslate">
double[] balance;
</pre>
<h2>Initializing an Array</h2>
<p>Declaring an array does not initialize the array in the memory. When the array variable is initialized, you can assign values to the array.</p>
<p>Array is a reference type, so you need to use the <b>new</b> keyword to create an instance of the array. For example,</p>
<pre class="prettyprint notranslate">
double[] balance = new double[10];
</pre>
<h2>Assigning Values to an Array</h2>
<p>You can assign values to individual array elements, by using the index number, like:</p>
<pre class="prettyprint notranslate">
double[] balance = new double[10];
balance[0] = 4500.0;
</pre>
<p>You can assign values to the array at the time of declaration, as shown:</p>
<pre class="prettyprint notranslate">
double[] balance = { 2340.0, 4523.69, 3421.0};
</pre>
<p>You can also create and initialize an array, as shown:</p>
<pre class="prettyprint notranslate">
int [] marks = new int[5]  { 99,  98, 92, 97, 95};
</pre>
<p>You may also omit the size of the array, as shown:</p>
<pre class="prettyprint notranslate">
int [] marks = new int[]  { 99,  98, 92, 97, 95};
</pre>
<p>You can copy an array variable into another target array variable. In such case, both the target and source point to the same memory location:</p>
<pre class="prettyprint notranslate">
int [] marks = new int[]  { 99,  98, 92, 97, 95};
int[] score = marks;
</pre>
<p>When you create an array, C# compiler implicitly initializes each array element to a default value depending on the array type. For example, for an int array all elements are initialized to 0.</p>
<h2>Accessing Array Elements</h2>
<p>An element is accessed by indexing the array name. This is done by placing the index of the element within square brackets after the name of the array. For example,</p>
<pre class="prettyprint notranslate">
double salary = balance[9];
</pre>
<p>The following example, demonstrates the above-mentioned concepts declaration, assignment, and accessing arrays:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace ArrayApplication
{
   class MyArray
   {
      static void Main(string[] args)
      {
         int []  n = new int[10]; /* n is an array of 10 integers */
         int i,j;

         /* initialize elements of array n */
         for ( i = 0; i &lt; 10; i++ )
         {
            n[ i ] = i + 100;
         }
         
         /* output each array element's value */
         for (j = 0; j &lt; 10; j++ )
         {
            Console.WriteLine("Element[{0}] = {1}", j, n[j]);
         }
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Element[0] = 100
Element[1] = 101
Element[2] = 102
Element[3] = 103
Element[4] = 104
Element[5] = 105
Element[6] = 106
Element[7] = 107
Element[8] = 108
Element[9] = 109
</pre>
<h2>Using the <i>foreach</i> Loop</h2>
<p>In the previous example, we used a for loop for accessing each array element. You can also use a <b>foreach</b> statement to iterate through an array.</p> 
<pre class="prettyprint notranslate tryit">
using System;
namespace ArrayApplication
{
   class MyArray
   {
      static void Main(string[] args)
      {
         int []  n = new int[10]; /* n is an array of 10 integers */
         
         /* initialize elements of array n */
         for ( int i = 0; i &lt; 10; i++ )
         {
            n[i] = i + 100;
         }
         
         /* output each array element's value */
         foreach (int j in n )
         {
            int i = j-100;
            Console.WriteLine("Element[{0}] = {1}", i, j);
            
         }
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Element[0] = 100
Element[1] = 101
Element[2] = 102
Element[3] = 103
Element[4] = 104
Element[5] = 105
Element[6] = 106
Element[7] = 107
Element[8] = 108
Element[9] = 109
</pre>

<title>C# - Strings</title>

<h1>C# - Strings</h1>

<p>In C#, you can use strings as array of characters, However, more common practice is to use the <b>string</b> keyword to declare a string variable. The string keyword is an alias for the <b>System.String</b> class.</p>

<h2>Creating a String Object</h2>

<p>You can create string object using one of the following methods:</p>

<p>By assigning a string literal to a String variable</p>

<p>By using a String class constructor</p>

<p>By using the string concatenation operator (+)</p>

<p>By retrieving a property or calling a method that returns a string</p>

<p>By calling a formatting method to convert a value or an object to its string representation</p>

<p>The following example demonstrates this:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Properties of the String Class</h2>

<p>The String class has the following two properties:</p>

<p>Gets the <i>Char</i> object at a specified position in the current <i>String</i> object.</p>

<p>Gets the number of characters in the current String object.</p>

<h2>Methods of the String Class</h2>

<p>The String class has numerous methods that help you in working with the string objects. The following table provides some of the most commonly used methods:</p>

<p>Compares two specified string objects and returns an integer that indicates their relative position in the sort order.</p>

<p>Compares two specified string objects and returns an integer that indicates their relative position in the sort order. However, it ignores case if the Boolean parameter is true.</p>

<p>Concatenates two string objects.</p>

<p>Concatenates three string objects.</p>

<p>Concatenates four string objects.</p>

<p>Returns a value indicating whether the specified String object occurs within this string.</p>

<p>Creates a new String object with the same value as the specified string.</p>

<p>Copies a specified number of characters from a specified position of the String object to a specified position in an array of Unicode characters.</p>

<p>Determines whether the end of the string object matches the specified string.</p>

<p>Determines whether the current String object and the specified String object have the same value.</p>

<p>Determines whether two specified String objects have the same value.</p>

<p>Replaces one or more format items in a specified string with the string representation of a specified object.</p>

<p>Returns the zero-based index of the first occurrence of the specified Unicode character in the current string.</p>

<p>Returns the zero-based index of the first occurrence of the specified string in this instance.</p>

<p>Returns the zero-based index of the first occurrence of the specified Unicode character in this string, starting search at the specified character position.</p>

<p>Returns the zero-based index of the first occurrence of the specified string in this instance, starting search at the specified character position.</p>

<p>Returns the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters.</p>

<p>Returns the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters, starting search at the specified character position.</p>

<p>Returns a new string in which a specified string is inserted at a specified index position in the current string object.</p>

<p>Indicates whether the specified string is null or an Empty string.</p>

<p>Concatenates all the elements of a string array, using the specified separator between each element.</p>

<p>Concatenates the specified elements of a string array, using the specified separator between each element.</p>

<p>Returns the zero-based index position of the last occurrence of the specified Unicode character within the current string object.</p>

<p>Returns the zero-based index position of the last occurrence of a specified string within the current string object.</p>

<p>Removes all the characters in the current instance, beginning at a specified position and continuing through the last position, and returns the string.</p>

<p>Removes the specified number of characters in the current string beginning at a specified position and returns the string.</p>

<p>Replaces all occurrences of a specified Unicode character in the current string object with the specified Unicode character and returns the new string.</p>

<p>Replaces all occurrences of a specified string in the current string object with the specified string and returns the new string.</p>

<p>Returns a string array that contains the substrings in the current string object, delimited by elements of a specified Unicode character array.</p>

<p>Returns a string array that contains the substrings in the current string object, delimited by elements of a specified Unicode character array. The int parameter specifies the maximum number of substrings to return.</p>

<p>Returns a Unicode character array with all the characters in the current string object.</p>

<p>Returns a Unicode character array with all the characters in the current string object, starting from the specified index and up to the specified length.</p>

<p>Returns a copy of this string converted to lowercase.</p>

<p>Returns a copy of this string converted to uppercase.</p>

<p>Removes all leading and trailing white-space characters from the current String object.</p>

<p>You can visit MSDN library for the complete list of methods and String class constructors. </p>

<h2>Examples</h2>

<p>The following example demonstrates some of the methods mentioned above:</p>

<p><b>Comparing Strings:</b></p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p><b>String Contains String:</b></p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p><b>Getting a Substring:</b></p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p><b>Joining Strings:</b></p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate tryit">
using System;
namespace StringApplication
{
   class Program
   {
      static void Main(string[] args)
      {
         //from string literal and string concatenation
         string fname, lname;
         fname = "Rowan";
         lname = "Atkinson";
         
         string fullname = fname + lname;
         Console.WriteLine("Full Name: {0}", fullname);
         
         //by using string constructor
         char[] letters = { 'H', 'e', 'l', 'l','o' };
         string greetings = new string(letters);
         Console.WriteLine("Greetings: {0}", greetings);
         
         //methods returning string
         string[] sarray = { "Hello", "From", "Tutorials", "Point" };
         string message = String.Join(" ", sarray);
         Console.WriteLine("Message: {0}", message);
         
         //formatting method to convert a value
         DateTime waiting = new DateTime(2012, 10, 10, 17, 58, 1);
         string chat = String.Format("Message sent at {0:t} on {0:D}", waiting);
         Console.WriteLine("Message: {0}", chat);
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Full Name: Rowan Atkinson
Greetings: Hello
Message: Hello From Tutorials Point
Message: Message sent at 5:58 PM on Wednesday, October 10, 2012
</pre>
<h2>Properties of the String Class</h2>
<p>The String class has the following two properties:</p>
<table class="table table-bordered">
<tr>
<th style="width:5%;">Sr.No</th>
<th>Property</th>
</tr>
<tr>
<td>1</td>
<td><b>Chars</b>
<p>Gets the <i>Char</i> object at a specified position in the current <i>String</i> object.</p></td>
</tr>
<tr>
<td>2</td>
<td><b>Length</b>
<p>Gets the number of characters in the current String object.</p></td>
</tr>
</table>
<h2>Methods of the String Class</h2>
<p>The String class has numerous methods that help you in working with the string objects. The following table provides some of the most commonly used methods:</p>
<table class="table table-bordered">
<tr>
<th style="width:5%;">Sr.No</th>
<th>Methods</th>
</tr>
<tr>
<td>1</td>
<td><b>public static int Compare(string strA, string strB)</b>
<p>Compares two specified string objects and returns an integer that indicates their relative position in the sort order.</p></td>
</tr>
<tr>
<td>2</td>
<td><b>public static int Compare(string strA, string strB, bool ignoreCase )</b>
<p>Compares two specified string objects and returns an integer that indicates their relative position in the sort order. However, it ignores case if the Boolean parameter is true.</p>
</td>
</tr>
<tr>
<td>3</td>
<td><b>public static string Concat(string str0, string str1)</b>
<p>Concatenates two string objects.</p>
</td>
</tr>
<tr>
<td>4</td>
<td><b>public static string Concat(string str0, string str1, string str2)</b>
<p>Concatenates three string objects.</p>
</td>
</tr>
<tr>
<td>5</td>
<td><b>public static string Concat(string str0, string str1, string str2, string str3)</b>
<p>Concatenates four string objects.</p>
</td>
</tr>
<tr>
<td>6</td>
<td><b>public bool Contains(string value)</b>
<p>Returns a value indicating whether the specified String object occurs within this string.</p></td>
</tr>
<tr>
<td>7</td>
<td><b>public static string Copy(string str)</b>
<p>Creates a new String object with the same value as the specified string.</p>
</td>
</tr>
<tr>
<td>8</td>
<td><b>public void CopyTo(int sourceIndex, char[] destination, int destinationIndex, int count)</b>
<p>Copies a specified number of characters from a specified position of the String object to a specified position in an array of Unicode characters.</p></td>
</tr>
<tr>
<td>9</td>
<td>
<b>public bool EndsWith(string value)</b>
<p>Determines whether the end of the string object matches the specified string.</p>
</td>
</tr>
<tr>
<td>10</td>
<td>
<b>public bool Equals(string value)</b>
<p>Determines whether the current String object and the specified String object have the same value.</p>
</td>
</tr>
<tr>
<td>11</td>
<td>
<b>public static bool Equals(string a, string b)</b>
<p>Determines whether two specified String objects have the same value.</p>
</td>
</tr>
<tr>
<td>12</td>
<td>
<b>public static string Format(string format, Object arg0)</b>
<p>Replaces one or more format items in a specified string with the string representation of a specified object.</p>
</td>
</tr>
<tr>
<td>13</td>
<td>
<b>public int IndexOf(char value)</b>
<p>Returns the zero-based index of the first occurrence of the specified Unicode character in the current string.</p>
</td>
</tr>
<tr>
<td>14</td>
<td>
<b>public int IndexOf(string value)</b>
<p>Returns the zero-based index of the first occurrence of the specified string in this instance.</p>
</td>
</tr>
<tr>
<td>15</td>
<td>
<b>public int IndexOf(char value, int startIndex)</b>
<p>Returns the zero-based index of the first occurrence of the specified Unicode character in this string, starting search at the specified character position.</p>
</td>
</tr>
<tr>
<td>16</td>
<td>
<b>public int IndexOf(string value, int startIndex)</b>
<p>Returns the zero-based index of the first occurrence of the specified string in this instance, starting search at the specified character position.</p>
</td>
</tr>
<tr>
<td>17</td>
<td>
<b>public int IndexOfAny(char[] anyOf)</b>
<p>Returns the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters.</p>
</td>
</tr>
<tr>
<td>18</td>
<td>
<b>public int IndexOfAny(char[] anyOf, int startIndex)</b>
<p>Returns the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters, starting search at the specified character position.</p>
</td>
</tr>
<tr>
<td>19</td>
<td>
<b>public string Insert(int startIndex, string value)</b>
<p>Returns a new string in which a specified string is inserted at a specified index position in the current string object.</p>
</td>
</tr>
<tr>
<td>20</td>
<td>
<b>public static bool IsNullOrEmpty(string value)</b>
<p>Indicates whether the specified string is null or an Empty string.</p>
</td>
</tr>
<tr>
<td>21</td>
<td>
<b>public static string Join(string separator, params string[] value)</b>
<p>Concatenates all the elements of a string array, using the specified separator between each element.</p>
</td></tr>
<tr>
<td>22</td>
<td>
<b>public static string Join(string separator, string[] value, int startIndex, int count)</b>
<p>Concatenates the specified elements of a string array, using the specified separator between each element.</p>
</td>
</tr>
<tr>
<td>23</td>
<td>
<b>public int LastIndexOf(char value)</b>
<p>Returns the zero-based index position of the last occurrence of the specified Unicode character within the current string object.</p>
</td>
</tr>
<tr>
<td>24</td>
<td>
<b>public int LastIndexOf(string value)</b>
<p>Returns the zero-based index position of the last occurrence of a specified string within the current string object.</p>
</td>
</tr>
<tr>
<td>25</td>
<td>
<b>public string Remove(int startIndex)</b>
<p>Removes all the characters in the current instance, beginning at a specified position and continuing through the last position, and returns the string.</p>
</td>
</tr>
<tr>
<td>26</td>
<td>
<b>public string Remove(int startIndex, int count)</b>
<p>Removes the specified number of characters in the current string beginning at a specified position and returns the string.</p>
</td>
</tr>
<tr>
<td>27</td>
<td>
<b>public string Replace(char oldChar, char newChar)</b>
<p>Replaces all occurrences of a specified Unicode character in the current string object with the specified Unicode character and returns the new string.</p>
</td>
</tr>
<tr>
<td>28</td>
<td>
<b>public string Replace(string oldValue, string newValue)</b>
<p>Replaces all occurrences of a specified string in the current string object with the specified string and returns the new string.</p>
</td>
</tr>
<tr>
<td>29</td>
<td>
<b>public string[] Split(params char[] separator)</b>
<p>Returns a string array that contains the substrings in the current string object, delimited by elements of a specified Unicode character array.</p>
</td>
</tr>
<tr>
<td>30</td>
<td>
<b>public string[] Split(char[] separator, int count)</b>
<p>Returns a string array that contains the substrings in the current string object, delimited by elements of a specified Unicode character array. The int parameter specifies the maximum number of substrings to return.</p>
</td>
</tr>
<tr>
<td>31</td>
<td>
<b>public bool StartsWith(string value)</b>
<p>Determines whether the beginning of this string instance matches the specified string.</td>
</tr>
<tr>
<td>32</td>
<td>
<b>public char[] ToCharArray()</b>
<p>Returns a Unicode character array with all the characters in the current string object.</p>
</td>
</tr>
<tr>
<td>33</td>
<td><b>public char[] ToCharArray(int startIndex, int length)</b>
<p>Returns a Unicode character array with all the characters in the current string object, starting from the specified index and up to the specified length.</p>
</td>
</tr>
<tr>
<td>34</td>
<td>
<b>public string ToLower()</b>
<p>Returns a copy of this string converted to lowercase.</p>
</td>
</tr>
<tr>
<td>35</td>
<td>
<b>public string ToUpper()</b>
<p>Returns a copy of this string converted to uppercase.</p>
</td>
</tr>
<tr>
<td>36</td>
<td>
<b>public string Trim()</b>
<p>Removes all leading and trailing white-space characters from the current String object.</p>
</td>
</tr>
</table>
<p>You can visit MSDN library for the complete list of methods and String class constructors. </p>
<h2>Examples</h2>
<p>The following example demonstrates some of the methods mentioned above:</p>
<p><b>Comparing Strings:</b></p>
<pre class="prettyprint notranslate tryit">
using System;
namespace StringApplication
{
   class StringProg
   {
      static void Main(string[] args)
      {
         string str1 = "This is test";
         string str2 = "This is text";

         if (String.Compare(str1, str2) == 0)
         {
            Console.WriteLine(str1 + " and " + str2 +  " are equal.");
         }
         else
         {
            Console.WriteLine(str1 + " and " + str2 + " are not equal.");
         }
         Console.ReadKey() ;
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
This is test and This is text are not equal.
</pre>
<p><b>String Contains String:</b></p>
<pre class="prettyprint notranslate tryit">
using System;
namespace StringApplication
{
   class StringProg
   {
      static void Main(string[] args)
      {
         string str = "This is test";
         if (str.Contains("test"))
         {
            Console.WriteLine("The sequence 'test' was found.");
         }
         Console.ReadKey() ;
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
The sequence 'test' was found.
</pre>
<p><b>Getting a Substring:</b></p>
<pre class="prettyprint notranslate tryit">
using System;
namespace StringApplication
{
   class StringProg
   {
      static void Main(string[] args)
      {
         string str = "Last night I dreamt of San Pedro";
         Console.WriteLine(str);
         string substr = str.Substring(23);
         Console.WriteLine(substr);
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
San Pedro
</pre>
<p><b>Joining Strings:</b></p>
<pre class="prettyprint notranslate tryit">
using System;
namespace StringApplication
{
   class StringProg
   {
      static void Main(string[] args)
      {
         string[] starray = new string[]{"Down the way nights are dark",
         "And the sun shines daily on the mountain top",
         "I took a trip on a sailing ship",
         "And when I reached Jamaica",
         "I made a stop"};

         string str = String.Join("\n", starray);
         Console.WriteLine(str);
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Down the way nights are dark
And the sun shines daily on the mountain top
I took a trip on a sailing ship
And when I reached Jamaica
I made a stop
</pre>

<title>C# - Structures</title>

<h1>C# - Structures</h1>

<p>In C#, a structure is a value type data type. It helps you to make a single variable hold related data of various data types. The <b>struct</b> keyword is used for creating a structure. </p>

<p>Structures are used to represent a record. Suppose you want to keep track of your books in a library. You might want to track the following attributes about each book:</p>

<h2>Defining a Structure</h2>

<p>To define a structure, you must use the struct statement. The struct statement defines a new data type, with more than one member for your program.</p>

<p>For example, here is the way you can declare the Book structure:</p>

<p>The following program shows the use of the structure:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Features of C# Structures</h2>

<p>You have already used a simple structure named Books. Structures in C# are quite different from that in traditional C or C++. The C# structures have the following features:</p>

<p>Structures can have methods, fields, indexers, properties, operator methods, and events.</p>

<p>Structures can have defined constructors, but not destructors. However, you cannot define a default constructor for a structure. The default constructor is automatically defined and cannot be changed.</p>

<p>Unlike classes, structures cannot inherit other structures or classes.</p>

<p>Structures cannot be used as a base for other structures or classes.</p>

<p>A structure can implement one or more interfaces.</p>

<p>Structure members cannot be specified as abstract, virtual, or protected.</p>

<p>When you create a struct object using the <b>New</b> operator, it gets created and the appropriate constructor is called. Unlike classes, structs can be instantiated without using the New operator.</p>

<p>If the New operator is not used, the fields remain unassigned and the object cannot be used until all the fields are initialized.</p>

<h2>Class versus Structure</h2>

<p>Classes and Structures have the following basic differences:</p>

<p>classes are reference types and structs are value types</p>

<p>structures do not support inheritance</p>

<p>structures cannot have default constructor</p>

<p>In the light of the above discussions, let us rewrite the previous example:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
struct Books
{
   public string title;
   public string author;
   public string subject;
   public int book_id;
};  
</pre>
<p>The following program shows the use of the structure:</p>
<pre class="prettyprint notranslate tryit">
using System;
struct Books
{
   public string title;
   public string author;
   public string subject;
   public int book_id;
};  

public class testStructure
{
   public static void Main(string[] args)
   {

      Books Book1;   /* Declare Book1 of type Book */
      Books Book2;   /* Declare Book2 of type Book */

      /* book 1 specification */
      Book1.title = "C Programming";
      Book1.author = "Nuha Ali"; 
      Book1.subject = "C Programming Tutorial";
      Book1.book_id = 6495407;

      /* book 2 specification */
      Book2.title = "Telecom Billing";
      Book2.author = "Zara Ali";
      Book2.subject =  "Telecom Billing Tutorial";
      Book2.book_id = 6495700;

      /* print Book1 info */
      Console.WriteLine( "Book 1 title : {0}", Book1.title);
      Console.WriteLine("Book 1 author : {0}", Book1.author);
      Console.WriteLine("Book 1 subject : {0}", Book1.subject);
      Console.WriteLine("Book 1 book_id :{0}", Book1.book_id);

      /* print Book2 info */
      Console.WriteLine("Book 2 title : {0}", Book2.title);
      Console.WriteLine("Book 2 author : {0}", Book2.author);
      Console.WriteLine("Book 2 subject : {0}", Book2.subject);
      Console.WriteLine("Book 2 book_id : {0}", Book2.book_id);       

      Console.ReadKey();

   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Book 1 title : C Programming
Book 1 author : Nuha Ali
Book 1 subject : C Programming Tutorial
Book 1 book_id : 6495407
Book 2 title : Telecom Billing
Book 2 author : Zara Ali
Book 2 subject : Telecom Billing Tutorial
Book 2 book_id : 6495700
</pre>
<h2>Features of C# Structures</h2>
<p>You have already used a simple structure named Books. Structures in C# are quite different from that in traditional C or C++. The C# structures have the following features:</p>
<ul class="list">
<li><p>Structures can have methods, fields, indexers, properties, operator methods, and events.</p></li>
<li><p>Structures can have defined constructors, but not destructors. However, you cannot define a default constructor for a structure. The default constructor is automatically defined and cannot be changed.</p></li>
<li><p>Unlike classes, structures cannot inherit other structures or classes.</p></li>
<li><p>Structures cannot be used as a base for other structures or classes.</p></li>
<li><p>A structure can implement one or more interfaces.</p></li>
<li><p>Structure members cannot be specified as abstract, virtual, or protected.</p></li>
<li><p>When you create a struct object using the <b>New</b> operator, it gets created and the appropriate constructor is called. Unlike classes, structs can be instantiated without using the New operator.</p></li>
<li><p>If the New operator is not used, the fields remain unassigned and the object cannot be used until all the fields are initialized.</p></li>
</ul>
<h2>Class versus Structure</h2>
<p>Classes and Structures have the following basic differences:</p>
<ul class="list">
<li><p>classes are reference types and structs are value types</p></li>
<li><p>structures do not support inheritance</p></li>
<li><p>structures cannot have default constructor</p></li>
</ul>
<p>In the light of the above discussions, let us rewrite the previous example:</p>
<pre class="prettyprint notranslate tryit">
using System;
struct Books
{
   private string title;
   private string author;
   private string subject;
   private int book_id;
   public void getValues(string t, string a, string s, int id)
   {
      title = t;
      author = a;
      subject = s;
      book_id = id;
   }
   public void display()
   {
      Console.WriteLine("Title : {0}", title);
      Console.WriteLine("Author : {0}", author);
      Console.WriteLine("Subject : {0}", subject);
      Console.WriteLine("Book_id :{0}", book_id);
   }

};  

public class testStructure
{
   public static void Main(string[] args)
   {

      Books Book1 = new Books();   /* Declare Book1 of type Book */
      Books Book2 = new Books();   /* Declare Book2 of type Book */

      /* book 1 specification */
      Book1.getValues("C Programming",
      "Nuha Ali", "C Programming Tutorial",6495407);

      /* book 2 specification */
      Book2.getValues("Telecom Billing",
      "Zara Ali", "Telecom Billing Tutorial", 6495700);

      /* print Book1 info */
      Book1.display();

      /* print Book2 info */
      Book2.display(); 

      Console.ReadKey();

   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Title : C Programming
Author : Nuha Ali
Subject : C Programming Tutorial
Book_id : 6495407
Title : Telecom Billing
Author : Zara Ali
Subject : Telecom Billing Tutorial
Book_id : 6495700
</pre>

<title>C# - Enums</title>

<h1>C# - Enums</h1>

<p>An enumeration is a set of named integer constants. An enumerated type is declared using the <b>enum</b> keyword.</p>

<p>C# enumerations are value data type. In other words, enumeration contains its own values and cannot inherit or cannot pass inheritance.</p>

<h2>Declaring <i>enum</i> Variable</h2>

<p>The general syntax for declaring an enumeration is:</p>

<p>Where,</p>

<p>The <i>enum_name</i> specifies the enumeration type name.</p>

<p>The <i>enumeration list</i> is a comma-separated list of identifiers.</p>

<p>Each of the symbols in the enumeration list stands for an integer value, one greater than the symbol that precedes it. By default, the value of the first enumeration symbol is 0. For example:</p>

<h2>Example</h2>

<p>The following example demonstrates use of enum variable:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
enum &lt;enum_name&gt; 
{
   enumeration list 
};
</pre>
<p>Where,</p>
<ul class="list">
<li><p>The <i>enum_name</i> specifies the enumeration type name.</p></li>
<li><p>The <i>enumeration list</i> is a comma-separated list of identifiers.</p></li>
</ul>
<p>Each of the symbols in the enumeration list stands for an integer value, one greater than the symbol that precedes it. By default, the value of the first enumeration symbol is 0. For example:</p>
<pre class="prettyprint notranslate">
enum Days { Sun, Mon, tue, Wed, thu, Fri, Sat };
</pre>
<h2>Example</h2>
<p>The following example demonstrates use of enum variable:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace EnumApplication
{
   class EnumProgram
   {
      enum Days { Sun, Mon, tue, Wed, thu, Fri, Sat };

      static void Main(string[] args)
      {
         int WeekdayStart = (int)Days.Mon;
         int WeekdayEnd = (int)Days.Fri;
         Console.WriteLine("Monday: {0}", WeekdayStart);
         Console.WriteLine("Friday: {0}", WeekdayEnd);
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Monday: 1
Friday: 5
</pre>

<title>C# - Classes</title>

<h1>C# - Classes</h1>

<p>When you define a class, you define a blueprint for a data type. This does not actually define any data, but it does define what the class name means. That is, what an object of the class consists of and what operations can be performed on that object. Objects are instances of a class. The methods and variables that constitute a class are called members of the class.</p>

<h2>Defining a Class</h2>

<p>A class definition starts with the keyword class followed by the class name; and the class body enclosed by a pair of curly braces. Following is the general form of a class definition:</p>

<p>Note:</p>

<p>Access specifiers specify the access rules for the members as well as the class itself. If not mentioned, then the default access specifier for a class type is <b>internal</b>. Default access for the members is <b>private</b>.</p>

<p>Data type specifies the type of variable, and return type specifies the data type of the data the method returns, if any.</p>

<p>To access the class members, you use the dot (.) operator.</p>

<p>The dot operator links the name of an object with the name of a member.</p>

<p>The following example illustrates the concepts discussed so far:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Member Functions and Encapsulation</h2>

<p>A member function of a class is a function that has its definition or its prototype within the class definition similar to any other variable. It operates on any object of the class of which it is a member, and has access to all the members of a class for that object.</p>

<p>Member variables are the attributes of an object (from design perspective) and they are kept private to implement encapsulation. These variables can only be accessed using the public member functions.</p>

<p>Let us put above concepts to set and get the value of different class members in a class:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>C# Constructors</h2>

<p>A class <b>constructor</b> is a special member function of a class that is executed whenever we create new objects of that class.</p>

<p>A constructor has exactly the same name as that of class and it does not have any return type. Following example explains the concept of constructor:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>A <b>default constructor</b> does not have any parameter but if you need, a constructor can have parameters. Such constructors are called <b>parameterized constructors</b>. This technique helps you to assign initial value to an object at the time of its creation as shown in the following example:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>C# Destructors</h2>

<p>A <b>destructor</b> is a special member function of a class that is executed whenever an object of its class goes out of scope. A <b>destructor</b> has exactly the same name as that of the class with a prefixed tilde (~) and it can neither return a value nor can it take any parameters.</p>

<p>Destructor can be very useful for releasing memory resources before exiting the program. Destructors cannot be inherited or overloaded.</p>

<p>Following example explains the concept of destructor:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Static Members of a C# Class</h2>

<p>We can define class members as static using the <b>static</b> keyword. When we declare a member of a class as static, it means no matter how many objects of the class are created, there is only one copy of the static member.</p>

<p>The keyword <b>static</b> implies that only one instance of the member exists for a class. Static variables are used for defining constants because their values can be retrieved by invoking the class without creating an instance of it. Static variables can be initialized outside the member function or class definition. You can also initialize static variables inside the class definition.</p>

<p>The following example demonstrates the use of <b>static variables</b>:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>You can also declare a <b>member function</b> as <b>static</b>. Such functions can access only static variables. The static functions exist even before the object is created. The following example demonstrates the use of <b>static functions</b>:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
&lt;access specifier&gt; class  class_name
{
   // member variables
   &lt;access specifier&gt; &lt;data type&gt; variable1;
   &lt;access specifier&gt; &lt;data type&gt; variable2;
   ...
   &lt;access specifier&gt; &lt;data type&gt; variableN;
   // member methods
   &lt;access specifier&gt; &lt;return type&gt; method1(parameter_list)
   {
      // method body
   }
   &lt;access specifier&gt; &lt;return type&gt; method2(parameter_list)
   {
      // method body
   }
   ...
   &lt;access specifier&gt; &lt;return type&gt; methodN(parameter_list)
   {
      // method body
   }
}
</pre>
<p>Note:</p>
<ul class="list">
<li><p>Access specifiers specify the access rules for the members as well as the class itself. If not mentioned, then the default access specifier for a class type is <b>internal</b>. Default access for the members is <b>private</b>.</p></li>
<li><p>Data type specifies the type of variable, and return type specifies the data type of the data the method returns, if any.</p></li>
<li><p>To access the class members, you use the dot (.) operator.</p></li>
<li><p>The dot operator links the name of an object with the name of a member.</p></li>
</ul>
<p>The following example illustrates the concepts discussed so far:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace BoxApplication
{
    class Box
    {
       public double length;   // Length of a box
       public double breadth;  // Breadth of a box
       public double height;   // Height of a box
    }
    class Boxtester
    {
        static void Main(string[] args)
        {
            Box Box1 = new Box();   // Declare Box1 of type Box
            Box Box2 = new Box();   // Declare Box2 of type Box
            double volume = 0.0;    // Store the volume of a box here

            // box 1 specification
            Box1.height = 5.0;
            Box1.length = 6.0;
            Box1.breadth = 7.0;

            // box 2 specification
            Box2.height = 10.0;
            Box2.length = 12.0;
            Box2.breadth = 13.0;
           
            // volume of box 1
            volume = Box1.height * Box1.length * Box1.breadth;
            Console.WriteLine("Volume of Box1 : {0}",  volume);

            // volume of box 2
            volume = Box2.height * Box2.length * Box2.breadth;
            Console.WriteLine("Volume of Box2 : {0}", volume);
            Console.ReadKey();
        }
    }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Volume of Box1 : 210
Volume of Box2 : 1560
</pre>
<h2>Member Functions and Encapsulation</h2>
<p>A member function of a class is a function that has its definition or its prototype within the class definition similar to any other variable. It operates on any object of the class of which it is a member, and has access to all the members of a class for that object.</p>
<p>Member variables are the attributes of an object (from design perspective) and they are kept private to implement encapsulation. These variables can only be accessed using the public member functions.</p>
<p>Let us put above concepts to set and get the value of different class members in a class:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace BoxApplication
{
   class Box
   {
      private double length;   // Length of a box
      private double breadth;  // Breadth of a box
      private double height;   // Height of a box
      public void setLength( double len )
      {
         length = len;
      }
      
      public void setBreadth( double bre )
      {
         breadth = bre;
      }
      
      public void setHeight( double hei )
      {
         height = hei;
      }
      public double getVolume()
      {
         return length * breadth * height;
      }
   }
   class Boxtester
   {
      static void Main(string[] args)
      {
         Box Box1 = new Box();   // Declare Box1 of type Box
         Box Box2 = new Box();
         double volume;
         
         // Declare Box2 of type Box
         // box 1 specification
         Box1.setLength(6.0);
         Box1.setBreadth(7.0);
         Box1.setHeight(5.0);
         
         // box 2 specification
         Box2.setLength(12.0);
         Box2.setBreadth(13.0);
         Box2.setHeight(10.0);
         
         // volume of box 1
         volume = Box1.getVolume();
         Console.WriteLine("Volume of Box1 : {0}" ,volume);
         
         // volume of box 2
         volume = Box2.getVolume();
         Console.WriteLine("Volume of Box2 : {0}", volume);
         
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Volume of Box1 : 210
Volume of Box2 : 1560
</pre>
<h2>C# Constructors</h2>
<p>A class <b>constructor</b> is a special member function of a class that is executed whenever we create new objects of that class.</p>
<p>A constructor has exactly the same name as that of class and it does not have any return type. Following example explains the concept of constructor:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace LineApplication
{
   class Line
   {
      private double length;   // Length of a line
      public Line()
      {
         Console.WriteLine("Object is being created");
      }

      public void setLength( double len )
      {
         length = len;
      }
      
      public double getLength()
      {
         return length;
      }

      static void Main(string[] args)
      {
         Line line = new Line();    
         
         // set line length
         line.setLength(6.0);
         Console.WriteLine("Length of line : {0}", line.getLength());
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Object is being created
Length of line : 6
</pre>
<p>A <b>default constructor</b> does not have any parameter but if you need, a constructor can have parameters. Such constructors are called <b>parameterized constructors</b>. This technique helps you to assign initial value to an object at the time of its creation as shown in the following example:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace LineApplication
{
   class Line
   {
      private double length;   // Length of a line
      public Line(double len)  //Parameterized constructor
      {
         Console.WriteLine("Object is being created, length = {0}", len);
         length = len;
      }

      public void setLength( double len )
      {
         length = len;
      }
      public double getLength()
      {
         return length;
      }

      static void Main(string[] args)
      {
         Line line = new Line(10.0);
         Console.WriteLine("Length of line : {0}", line.getLength()); 
         
         // set line length
         line.setLength(6.0);
         Console.WriteLine("Length of line : {0}", line.getLength()); 
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Object is being created, length = 10
Length of line : 10
Length of line : 6
</pre>
<h2>C# Destructors</h2>
<p>A <b>destructor</b> is a special member function of a class that is executed whenever an object of its class goes out of scope. A <b>destructor</b> has exactly the same name as that of the class with a prefixed tilde (~) and it can neither return a value nor can it take any parameters.</p>
<p>Destructor can be very useful for releasing memory resources before exiting the program. Destructors cannot be inherited or overloaded.</p>
<p>Following example explains the concept of destructor:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace LineApplication
{
   class Line
   {
      private double length;   // Length of a line
      public Line()  // constructor
      {
         Console.WriteLine("Object is being created");
      }
      ~Line() //destructor
      {
         Console.WriteLine("Object is being deleted");
      }

      public void setLength( double len )
      {
         length = len;
      }
      
      public double getLength()
      {
         return length;
      }

      static void Main(string[] args)
      {
         Line line = new Line();
         
         // set line length
         line.setLength(6.0);
         Console.WriteLine("Length of line : {0}", line.getLength());           
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Object is being created
Length of line : 6
Object is being deleted
</pre>
<h2>Static Members of a C# Class</h2>
<p>We can define class members as static using the <b>static</b> keyword. When we declare a member of a class as static, it means no matter how many objects of the class are created, there is only one copy of the static member.</p>
<p>The keyword <b>static</b> implies that only one instance of the member exists for a class. Static variables are used for defining constants because their values can be retrieved by invoking the class without creating an instance of it. Static variables can be initialized outside the member function or class definition. You can also initialize static variables inside the class definition.</p>
<p>The following example demonstrates the use of <b>static variables</b>:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace StaticVarApplication
{
   class StaticVar
   {
      public static int num;
      public void count()
      {
         num++;
      }
      public int getNum()
      {
         return num;
      }
   }
   class StaticTester
   {
      static void Main(string[] args)
      {
         StaticVar s1 = new StaticVar();
         StaticVar s2 = new StaticVar();
         s1.count();
         s1.count();
         s1.count();
         s2.count();
         s2.count();
         s2.count();
         Console.WriteLine("Variable num for s1: {0}", s1.getNum());
         Console.WriteLine("Variable num for s2: {0}", s2.getNum());
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Variable num for s1: 6
Variable num for s2: 6
</pre>
<p>You can also declare a <b>member function</b> as <b>static</b>. Such functions can access only static variables. The static functions exist even before the object is created. The following example demonstrates the use of <b>static functions</b>:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace StaticVarApplication
{
   class StaticVar
   {
      public static int num;
      public void count()
      {
         num++;
      }
      public static int getNum()
      {
         return num;
      }
   }
   class StaticTester
   {
      static void Main(string[] args)
      {
         StaticVar s = new StaticVar();
         s.count();
         s.count();
         s.count();
         Console.WriteLine("Variable num: {0}", StaticVar.getNum());
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Variable num: 3
</pre>

<title>C# - Inheritance</title>

<h1>C# - Inheritance</h1>

<p>One of the most important concepts in object-oriented programming is inheritance. Inheritance allows us to define a class in terms of another class, which makes it easier to create and maintain an application. This also provides an opportunity to reuse the code functionality and speeds up implementation time.</p>

<p>When creating a class, instead of writing completely new data members and member functions, the programmer can designate that the new class should inherit the members of an existing class. This existing class is called the <b>base</b> class, and the new class is referred to as the <b>derived</b> class.</p>

<p>The idea of inheritance implements the <b>IS-A</b> relationship. For example, mammal <b>IS A</b> animal, dog <b>IS-A</b> mammal hence dog <b>IS-A</b> animal as well, and so on.</p>

<h2>Base and Derived Classes</h2>

<p>A class can be derived from more than one class or interface, which means that it can inherit data and functions from multiple base classes or interfaces.</p>

<p>The syntax used in C# for creating derived classes is as follows:</p>

<p>Consider a base class Shape and its derived class Rectangle:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Initializing Base Class</h2>

<p>The derived class inherits the base class member variables and member methods. Therefore the super class object should be created before the subclass is created. You can give instructions for superclass initialization in the member initialization list.</p>

<p>The following program demonstrates this:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Multiple Inheritance in C#</h2>

<p><b>C# does not support multiple inheritance</b>. However, you can use interfaces to implement multiple inheritance. The following program demonstrates this:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
&lt;acess-specifier&gt; class &lt;base_class&gt;
{
   ...
}
class &lt;derived_class&gt; : &lt;base_class&gt;
{
   ...
}
</pre>
<p>Consider a base class Shape and its derived class Rectangle:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace InheritanceApplication
{
   class Shape 
   {
      public void setWidth(int w)
      {
         width = w;
      }
      public void setHeight(int h)
      {
         height = h;
      }
      protected int width;
      protected int height;
   }

   // Derived class
   class Rectangle: Shape
   {
      public int getArea()
      { 
         return (width * height); 
      }
   }
   
   class RectangleTester
   {
      static void Main(string[] args)
      {
         Rectangle Rect = new Rectangle();

         Rect.setWidth(5);
         Rect.setHeight(7);

         // Print the area of the object.
         Console.WriteLine("Total area: {0}",  Rect.getArea());
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Total area: 35
</pre>
<h2>Initializing Base Class</h2>
<p>The derived class inherits the base class member variables and member methods. Therefore the super class object should be created before the subclass is created. You can give instructions for superclass initialization in the member initialization list.</p>
<p>The following program demonstrates this:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace RectangleApplication
{
   class Rectangle
   {
      //member variables
      protected double length;
      protected double width;
      public Rectangle(double l, double w)
      {
         length = l;
         width = w;
      }
      
      public double GetArea()
      {
         return length * width;
      }
      
      public void Display()
      {
         Console.WriteLine("Length: {0}", length);
         Console.WriteLine("Width: {0}", width);
         Console.WriteLine("Area: {0}", GetArea());
      }
   }//end class Rectangle  
   
   class Tabletop : Rectangle
   {
      private double cost;
      public Tabletop(double l, double w) : base(l, w)
      { }
      public double GetCost()
      {
         double cost;
         cost = GetArea() * 70;
         return cost;
      }
      public void Display()
      {
         base.Display();
         Console.WriteLine("Cost: {0}", GetCost());
      }
   }
   class ExecuteRectangle
   {
      static void Main(string[] args)
      {
         Tabletop t = new Tabletop(4.5, 7.5);
         t.Display();
         Console.ReadLine();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Length: 4.5
Width: 7.5
Area: 33.75
Cost: 2362.5
</pre>
<h2>Multiple Inheritance in C#</h2>
<p><b>C# does not support multiple inheritance</b>. However, you can use interfaces to implement multiple inheritance. The following program demonstrates this:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace InheritanceApplication
{
   class Shape 
   {
      public void setWidth(int w)
      {
         width = w;
      }
      public void setHeight(int h)
      {
         height = h;
      }
      protected int width;
      protected int height;
   }

   // Base class PaintCost
   public interface PaintCost 
   {
      int getCost(int area);

   }
   
   // Derived class
   class Rectangle : Shape, PaintCost
   {
      public int getArea()
      {
         return (width * height);
      }
      public int getCost(int area)
      {
         return area * 70;
      }
   }
   class RectangleTester
   {
      static void Main(string[] args)
      {
         Rectangle Rect = new Rectangle();
         int area;
         Rect.setWidth(5);
         Rect.setHeight(7);
         area = Rect.getArea();
         
         // Print the area of the object.
         Console.WriteLine("Total area: {0}",  Rect.getArea());
         Console.WriteLine("Total paint cost: ${0}" , Rect.getCost(area));
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Total area: 35
Total paint cost: $2450
</pre>

<title>C# - Polymorphism</title>

<h1>C# - Polymorphism</h1>

<p>The word <b>polymorphism</b> means having many forms. In object-oriented programming paradigm, polymorphism is often expressed as 'one interface, multiple functions'.</p>

<p>Polymorphism can be static or dynamic. In <b>static polymorphism</b>, the response to a function is determined at the compile time. In <b>dynamic polymorphism</b>, it is decided at run-time.</p>

<h2>Static Polymorphism</h2>

<p>The mechanism of linking a function with an object during compile time is called early binding. It is also called static binding. C# provides two techniques to implement static polymorphism. They are:</p>

<p>We discuss operator overloading in next chapter.</p>

<h2>Function Overloading</h2>

<p>You can have multiple definitions for the same function name in the same scope. The definition of the function must differ from each other by the types and/or the number of arguments in the argument list. You cannot overload function declarations that differ only by return type.</p>

<p>The following example shows using function <b>print()</b> to print different data types:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Dynamic Polymorphism</h2>

<p>C# allows you to create abstract classes that are used to provide partial class implementation of an interface. Implementation is completed when a derived class inherits from it. <b>Abstract</b> classes contain abstract methods, which are implemented by the derived class. The derived classes have more specialized functionality.</p>

<p>Here are the rules about abstract classes:</p>

<p>You cannot create an instance of an abstract class</p>

<p>You cannot declare an abstract method outside an abstract class</p>

<p>When a class is declared <b>sealed</b>, it cannot be inherited, abstract classes cannot be declared sealed.</p>

<p>The following program demonstrates an abstract class:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>When you have a function defined in a class that you want to be implemented in an inherited class(es), you use <b>virtual</b> functions. The virtual functions could be implemented differently in different inherited class and the call to these functions will be decided at runtime.</p>

<p>Dynamic polymorphism is implemented by <b>abstract classes</b> and <b>virtual functions</b>.</p>

<p>The following program demonstrates this:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate tryit">
using System;
namespace PolymorphismApplication
{
   class Printdata
   {
      void print(int i)
      {
         Console.WriteLine("Printing int: {0}", i );
      }

      void print(double f)
      {
         Console.WriteLine("Printing float: {0}" , f);
      }

      void print(string s)
      {
         Console.WriteLine("Printing string: {0}", s);
      }
      static void Main(string[] args)
      {
         Printdata p = new Printdata();
         
         // Call print to print integer
         p.print(5);
         
         // Call print to print float
         p.print(500.263);
         
         // Call print to print string
         p.print("Hello C++");
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Printing int: 5
Printing float: 500.263
Printing string: Hello C++
</pre>
<h2>Dynamic Polymorphism</h2>
<p>C# allows you to create abstract classes that are used to provide partial class implementation of an interface. Implementation is completed when a derived class inherits from it. <b>Abstract</b> classes contain abstract methods, which are implemented by the derived class. The derived classes have more specialized functionality.</p>
<p>Here are the rules about abstract classes:</p>
<ul class="list">
<li><p>You cannot create an instance of an abstract class</p></li>
<li><p>You cannot declare an abstract method outside an abstract class</p></li>
<li><p>When a class is declared <b>sealed</b>, it cannot be inherited, abstract classes cannot be declared sealed.</p></li>
</ul>
<p>The following program demonstrates an abstract class:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace PolymorphismApplication
{
   abstract class Shape
   {
      public abstract int area();
   }
   class Rectangle:  Shape
   {
      private int length;
      private int width;
      public Rectangle( int a=0, int b=0)
      {
         length = a;
         width = b;
      }
      public override int area ()
      { 
         Console.WriteLine("Rectangle class area :");
         return (width * length); 
      }
   }

   class RectangleTester
   {
      static void Main(string[] args)
      {
         Rectangle r = new Rectangle(10, 7);
         double a = r.area();
         Console.WriteLine("Area: {0}",a);
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Rectangle class area :
Area: 70
</pre>
<p>When you have a function defined in a class that you want to be implemented in an inherited class(es), you use <b>virtual</b> functions. The virtual functions could be implemented differently in different inherited class and the call to these functions will be decided at runtime.</p>
<p>Dynamic polymorphism is implemented by <b>abstract classes</b> and <b>virtual functions</b>.</p>
<p>The following program demonstrates this:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace PolymorphismApplication
{
   class Shape 
   {
      protected int width, height;
      public Shape( int a=0, int b=0)
      {
         width = a;
         height = b;
      }
      public virtual int area()
      {
         Console.WriteLine("Parent class area :");
         return 0;
      }
   }
   class Rectangle: Shape
   {
      public Rectangle( int a=0, int b=0): base(a, b)
      {

      }
      public override int area ()
      {
         Console.WriteLine("Rectangle class area :");
         return (width * height); 
      }
   }
   class Triangle: Shape
   {
      public Triangle(int a = 0, int b = 0): base(a, b)
      {
      
      }
      public override int area()
      {
         Console.WriteLine("Triangle class area :");
         return (width * height / 2); 
      }
   }
   class Caller
   {
      public void CallArea(Shape sh)
      {
         int a;
         a = sh.area();
         Console.WriteLine("Area: {0}", a);
      }
   }  
   class Tester
   {
      
      static void Main(string[] args)
      {
         Caller c = new Caller();
         Rectangle r = new Rectangle(10, 7);
         Triangle t = new Triangle(10, 5);
         c.CallArea(r);
         c.CallArea(t);
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Rectangle class area:
Area: 70
Triangle class area:
Area: 25
</pre>

<title>C# - Operator Overloading</title>

<h1>C# - Operator Overloading</h1>

<p>You can redefine or overload most of the built-in operators available in C#. Thus a programmer can use operators with user-defined types as well. Overloaded operators are functions with special names the keyword <b>operator</b> followed by the symbol for the operator being defined. similar to any other function, an overloaded operator has a return type and a parameter list.</p>

<p>For example, go through the following function:</p>

<p>The above function implements the addition operator (+) for a user-defined class Box. It adds the attributes of two Box objects and returns the resultant Box object.</p>

<h2>Implementing the Operator Overloading</h2>

<p>The following program shows the complete implementation:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Overloadable and Non-Overloadable Operators</h2>

<p>The following table describes the overload ability of the operators in C#:</p>

<h2>Example</h2>

<p>In the light of the above discussions, let us extend the preceding example, and overload few more operators:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
public static Box operator+ (Box b, Box c)
{
   Box box = new Box();
   box.length = b.length + c.length;
   box.breadth = b.breadth + c.breadth;
   box.height = b.height + c.height;
   return box;
}
</pre>
<p>The above function implements the addition operator (+) for a user-defined class Box. It adds the attributes of two Box objects and returns the resultant Box object.</p>
<h2>Implementing the Operator Overloading</h2>
<p>The following program shows the complete implementation:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace OperatorOvlApplication
{
   class Box
   {
      private double length;   // Length of a box
      private double breadth;  // Breadth of a box
      private double height;   // Height of a box

      public double getVolume()
      {
         return length * breadth * height;
      }
      
      public void setLength( double len )
      {
         length = len;
      }

      public void setBreadth( double bre )
      {
         breadth = bre;
      }

      public void setHeight( double hei )
      {
         height = hei;
      }
      
      // Overload + operator to add two Box objects.
      public static Box operator+ (Box b, Box c)
      {
         Box box = new Box();
         box.length = b.length + c.length;
         box.breadth = b.breadth + c.breadth;
         box.height = b.height + c.height;
         return box;
      }

   }

   class Tester
   {
      static void Main(string[] args)
      {
         Box Box1 = new Box();   // Declare Box1 of type Box
         Box Box2 = new Box();   // Declare Box2 of type Box
         Box Box3 = new Box();   // Declare Box3 of type Box
         double volume = 0.0;    // Store the volume of a box here

         // box 1 specification
         Box1.setLength(6.0);
         Box1.setBreadth(7.0);
         Box1.setHeight(5.0);

         // box 2 specification
         Box2.setLength(12.0);
         Box2.setBreadth(13.0);
         Box2.setHeight(10.0);

         // volume of box 1
         volume = Box1.getVolume();
         Console.WriteLine("Volume of Box1 : {0}", volume);

         // volume of box 2
         volume = Box2.getVolume();
         Console.WriteLine("Volume of Box2 : {0}", volume);

         // Add two object as follows:
         Box3 = Box1 + Box2;

         // volume of box 3
         volume = Box3.getVolume();
         Console.WriteLine("Volume of Box3 : {0}", volume);
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Volume of Box1 : 210
Volume of Box2 : 1560
Volume of Box3 : 5400
</pre>
<h2>Overloadable and Non-Overloadable Operators</h2>
<p>The following table describes the overload ability of the operators in C#:</p>
<table class="table table-bordered">
<tr>
<th style="width:25%;">Operators</th>
<th>Description</th>
</tr>
<tr>
<td>+, -, !, ~, ++, --</td>
<td>These unary operators take one operand and can be overloaded.</td>
</tr>
<tr>
<td>+, -, *, /, %</td>
<td>These binary operators take one operand and can be overloaded.</td>
</tr>
<tr>
<td>==, !=, &lt;, &gt;, &lt;=, &gt;=</td>
<td>The comparison operators can be overloaded</td>
</tr>
<tr>
<td>&amp;&amp;, ||</td>
<td>The conditional logical operators cannot be overloaded directly.</td>
</tr>
<tr>
<td>+=, -=, *=, /=, %=</td>
<td>The assignment operators cannot be overloaded.</td>
</tr>
<tr>
<td>=, ., ?:, ->, new, is, sizeof, typeof</td>
<td>These operators cannot be overloaded.</td>
</tr>
</table>
<h2>Example</h2>
<p>In the light of the above discussions, let us extend the preceding example, and overload few more operators:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace OperatorOvlApplication
{
   class Box
   {
      private double length;    // Length of a box
      private double breadth;   // Breadth of a box
      private double height;    // Height of a box
      
      public double getVolume()
      {
         return length * breadth * height;
      }
      
      public void setLength( double len )
      {
         length = len;
      }
      
      public void setBreadth( double bre )
      {
         breadth = bre;
      }
      
      
      public void setHeight( double hei )
      {
         height = hei;
      }
      
      // Overload + operator to add two Box objects.
      public static Box operator+ (Box b, Box c)
      {
         Box box = new Box();
         box.length = b.length + c.length;
         box.breadth = b.breadth + c.breadth;
         box.height = b.height + c.height;
         return box;
      }
      
      public static bool operator == (Box lhs, Box rhs)
      {
         bool status = false;
         if (lhs.length == rhs.length && lhs.height == rhs.height &amp;&amp; lhs.breadth == rhs.breadth)
         {
            status = true;
         }
         return status;
      }
      
      public static bool operator !=(Box lhs, Box rhs)
      {
         bool status = false;
         if (lhs.length != rhs.length || lhs.height != rhs.height || lhs.breadth != rhs.breadth)
         {
            status = true;
         }
         return status;
      }
      
      public static bool operator &lt;(Box lhs, Box rhs)
      {
         bool status = false;
         if (lhs.length &lt; rhs.length &amp;&amp; lhs.height &lt; rhs.height && lhs.breadth &lt; rhs.breadth)
         {
            status = true;
         }
         return status;
      }
      
      public static bool operator &gt;(Box lhs, Box rhs)
      {
         bool status = false;
         if (lhs.length &gt; rhs.length && lhs.height &gt; rhs.height &amp;&amp; lhs.breadth &gt; rhs.breadth)
         {
            status = true;
         }
         return status;
      }
      
      public static bool operator &lt;=(Box lhs, Box rhs)
      {
         bool status = false;
         if (lhs.length &lt;= rhs.length &amp;&amp; lhs.height &lt;= rhs.height && lhs.breadth &lt;= rhs.breadth)
         {
            status = true;
         }
         return status;
      }
      
      public static bool operator &gt;=(Box lhs, Box rhs)
      {
         bool status = false;
         if (lhs.length &gt;= rhs.length &amp;&amp; lhs.height &gt;= rhs.height && lhs.breadth &gt;= rhs.breadth)
         {
            status = true;
         }
         return status;
      }
      public override string ToString()
      {
         return String.Format("({0}, {1}, {2})", length, breadth, height);
      }
   }
   
   class Tester
   {
      static void Main(string[] args)
      {
         Box Box1 = new Box();   // Declare Box1 of type Box
         Box Box2 = new Box();   // Declare Box2 of type Box
         Box Box3 = new Box();   // Declare Box3 of type Box
         Box Box4 = new Box();
         double volume = 0.0;    // Store the volume of a box here
         
         // box 1 specification
         Box1.setLength(6.0);
         Box1.setBreadth(7.0);
         Box1.setHeight(5.0);
         
         // box 2 specification
         Box2.setLength(12.0);
         Box2.setBreadth(13.0);
         Box2.setHeight(10.0);
         
         //displaying the Boxes using the overloaded ToString():
         Console.WriteLine("Box 1: {0}", Box1.ToString());
         Console.WriteLine("Box 2: {0}", Box2.ToString());
         
         // volume of box 1
         volume = Box1.getVolume();
         Console.WriteLine("Volume of Box1 : {0}", volume);
         
         // volume of box 2
         volume = Box2.getVolume();
         Console.WriteLine("Volume of Box2 : {0}", volume);
         
         // Add two object as follows:
         Box3 = Box1 + Box2;
         Console.WriteLine("Box 3: {0}", Box3.ToString());
         
         // volume of box 3
         volume = Box3.getVolume();
         Console.WriteLine("Volume of Box3 : {0}", volume);
         
         //comparing the boxes
         if (Box1 &gt; Box2)
            Console.WriteLine("Box1 is greater than Box2");
         else
            Console.WriteLine("Box1 is  greater than Box2");
         
         if (Box1 &lt; Box2)
            Console.WriteLine("Box1 is less than Box2");
         else
            Console.WriteLine("Box1 is not less than Box2");
         
         if (Box1 &gt;= Box2)
            Console.WriteLine("Box1 is greater or equal to Box2");
         else
            Console.WriteLine("Box1 is not greater or equal to Box2");
         
         if (Box1 &lt;= Box2)
            Console.WriteLine("Box1 is less or equal to Box2");
         else
            Console.WriteLine("Box1 is not less or equal to Box2");
         
         if (Box1 != Box2)
            Console.WriteLine("Box1 is not equal to Box2");
         else
            Console.WriteLine("Box1 is not greater or equal to Box2");
         Box4 = Box3;
         
         if (Box3 == Box4)
            Console.WriteLine("Box3 is equal to Box4");
         else
            Console.WriteLine("Box3 is not equal to Box4");
         
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Box 1: (6, 7, 5)
Box 2: (12, 13, 10)
Volume of Box1 : 210
Volume of Box2 : 1560
Box 3: (18, 20, 15)
Volume of Box3 : 5400
Box1 is not greater than Box2
Box1 is less than Box2
Box1 is not greater or equal to Box2
Box1 is less or equal to Box2
Box1 is not equal to Box2
Box3 is equal to Box4
</pre>

<title>C# - Interfaces</title>

<h1>C# - Interfaces</h1>

<p>An interface is defined as a syntactical contract that all the classes inheriting the interface should follow. The interface defines the <b>'what'</b> part of the syntactical contract and the deriving classes define the <b>'how'</b> part of the syntactical contract. </p>

<p>Interfaces define properties, methods, and events, which are the members of the interface. Interfaces contain only the declaration of the members. It is the responsibility of the deriving class to define the members. It often helps in providing a standard structure that the deriving classes would follow.</p>

<p>Abstract classes to some extent serve the same purpose, however, they are mostly used when only few methods are to be declared by the base class and the deriving class implements the functionalities.</p>

<h2>Declaring Interfaces</h2>

<p>Interfaces are declared using the interface keyword. It is similar to class declaration. Interface statements are public by default. Following is an example of an interface declaration:</p>

<h2>Example</h2>

<p>The following example demonstrates implementation of the above interface:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
public interface ITransactions
{
   // interface members
   void showTransaction();
   double getAmount();
}
</pre>
<h2>Example</h2>
<p>The following example demonstrates implementation of the above interface:</p>
<pre class="prettyprint notranslate tryit">
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System;

namespace InterfaceApplication
{
   public interface ITransactions
   {
      // interface members
      void showTransaction();
      double getAmount();
   }
   
   public class Transaction : ITransactions
   {
      private string tCode;
      private string date;
      private double amount;
      public Transaction()
      {
         tCode = " ";
         date = " ";
         amount = 0.0;
      }
      
      public Transaction(string c, string d, double a)
      {
         tCode = c;
         date = d;
         amount = a;
      }
      
      public double getAmount()
      {
         return amount;
      }
      
      public void showTransaction()
      {
         Console.WriteLine("Transaction: {0}", tCode);
         Console.WriteLine("Date: {0}", date);
         Console.WriteLine("Amount: {0}", getAmount());
      }
   }
   class Tester
   {
      static void Main(string[] args)
      {
         Transaction t1 = new Transaction("001", "8/10/2012", 78900.00);
         Transaction t2 = new Transaction("002", "9/10/2012", 451900.00);
         t1.showTransaction();
         t2.showTransaction();
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Transaction: 001
Date: 8/10/2012
Amount: 78900
Transaction: 002
Date: 9/10/2012
Amount: 451900
</pre>

<title>C# - Namespaces</title>

<h1>C# - Namespaces</h1>

<p>A <b>namespace</b> is designed for providing a way to keep one set of names separate from another. The class names declared in one namespace does not conflict with the same class names declared in another.</p>

<h2>Defining a Namespace</h2>

<p>A namespace definition begins with the keyword <b>namespace</b> followed by the namespace name as follows:</p>

<p>To call the namespace-enabled version of either function or variable, prepend the namespace name as follows:</p>

<p>The following program demonstrates use of namespaces:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>The <i>using</i> Keyword</h2>

<p>The <b>using</b> keyword states that the program is using the names in the given namespace. For example, we are using the <b>System</b> namespace in our programs. The class Console is defined there. We just write:</p>

<p>We could have written the fully qualified name as:</p>

<p>You can also avoid prepending of namespaces with the <b>using</b> namespace directive. This directive tells the compiler that the subsequent code is making use of names in the specified namespace. The namespace is thus implied for the following code:</p>

<p>Let us rewrite our preceding example, with using directive:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Nested Namespaces</h2>

<p>You can define one namespace inside another namespace as follows:</p>

<p>You can access members of nested namespace by using the dot (.) operator as follows:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
namespace namespace_name
{
   // code declarations
}
</pre>
<p>To call the namespace-enabled version of either function or variable, prepend the namespace name as follows:</p>
<pre class="prettyprint notranslate">
namespace_name.item_name;
</pre>
<p>The following program demonstrates use of namespaces:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace first_space
{
   class namespace_cl
   {
      public void func()
      {
         Console.WriteLine("Inside first_space");
      }
   }
}

namespace second_space
{
   class namespace_cl
   {
      public void func()
      {
         Console.WriteLine("Inside second_space");
      }
   }
}

class TestClass
{
   static void Main(string[] args)
   {
      first_space.namespace_cl fc = new first_space.namespace_cl();
      second_space.namespace_cl sc = new second_space.namespace_cl();
      fc.func();
      sc.func();
      Console.ReadKey();
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Inside first_space
Inside second_space
</pre>
<h2>The <i>using</i> Keyword</h2>
<p>The <b>using</b> keyword states that the program is using the names in the given namespace. For example, we are using the <b>System</b> namespace in our programs. The class Console is defined there. We just write:</p>
<pre class="prettyprint notranslate">
Console.WriteLine ("Hello there");
</pre>
<p>We could have written the fully qualified name as:</p>
<pre class="prettyprint notranslate">
System.Console.WriteLine("Hello there");
</pre>
<p>You can also avoid prepending of namespaces with the <b>using</b> namespace directive. This directive tells the compiler that the subsequent code is making use of names in the specified namespace. The namespace is thus implied for the following code:</p>
<p>Let us rewrite our preceding example, with using directive:</p>
<pre class="prettyprint notranslate tryit">
using System;
using first_space;
using second_space;

namespace first_space
{
   class abc
   {
      public void func()
      {
         Console.WriteLine("Inside first_space");
      }
   }
}

namespace second_space
{
   class efg
   {
      public void func()
      {
         Console.WriteLine("Inside second_space");
      }
   }
}   

class TestClass
{
   static void Main(string[] args)
   {
      abc fc = new abc();
      efg sc = new efg();
      fc.func();
      sc.func();
      Console.ReadKey();
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Inside first_space
Inside second_space
</pre>
<h2>Nested Namespaces</h2>
<p>You can define one namespace inside another namespace as follows:</p>
<pre class="prettyprint notranslate">
namespace namespace_name1
{
   // code declarations
   namespace namespace_name2
   {
      // code declarations
   }
}
</pre>
<p>You can access members of nested namespace by using the dot (.) operator as follows:</p>
<pre class="prettyprint notranslate tryit">
using System;
using first_space;
using first_space.second_space;

namespace first_space
{
   class abc
   {
      public void func()
      {
         Console.WriteLine("Inside first_space");
      }
   }
   namespace second_space
   {
      class efg
      {
         public void func()
         {
            Console.WriteLine("Inside second_space");
         }
      }
   }   
}
 
class TestClass
{
   static void Main(string[] args)
   {
      abc fc = new abc();
      efg sc = new efg();
      fc.func();
      sc.func();
      Console.ReadKey();
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Inside first_space
Inside second_space
</pre>

<title>C# - Preprocessor Directives</title>

<h1>C# - Preprocessor Directives</h1>

<p>The preprocessor directives give instruction to the compiler to preprocess the information before actual compilation starts.</p>

<p>All preprocessor directives begin with #, and only white-space characters may appear before a preprocessor directive on a line. Preprocessor directives are not statements, so they do not end with a semicolon (;).</p>

<p>C# compiler does not have a separate preprocessor; however, the directives are processed as if there was one. In C# the preprocessor directives are used to help in conditional compilation. Unlike C and C++ directives, they are not used to create macros. A preprocessor directive must be the only instruction on a line.</p>

<h2>Preprocessor Directives in C#</h2>

<p>The following table lists the preprocessor directives available in C#:</p>

<h2>The #define Preprocessor</h2>

<p>The #define preprocessor directive creates symbolic constants.</p>

<p>#define lets you define a symbol such that, by using the symbol as the expression passed to the #if directive, the expression evaluates to true. Its syntax is as follows:</p>

<p>The following program illustrates this:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Conditional Directives</h2>

<p>You can use the #if directive to create a conditional directive. Conditional directives are useful for testing a symbol or symbols to check if they evaluate to true. If they do evaluate to true, the compiler evaluates all the code between the #if and the next directive.</p>

<p>Syntax for conditional directive is:</p>

<p>Where, <i>symbol</i> is the name of the symbol you want to test. You can also use true and false or prepend the symbol with the negation operator.</p>

<p>The <i>operator symbol</i> is the operator used for evaluating the symbol. Operators could be either of the following:</p>

<p>You can also group symbols and operators with parentheses. Conditional directives are used for compiling code for a debug build or when compiling for a specific configuration. A conditional directive beginning with a <b>#if</b> directive must explicitly be terminated with a <b>#endif</b> directive.</p>

<p>The following program demonstrates use of conditional directives:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
#define symbol
</pre>
<p>The following program illustrates this:</p>
<pre class="prettyprint notranslate tryit">
#define PI 
using System;
namespace PreprocessorDAppl
{
   class Program
   {
      static void Main(string[] args)
      {
         #if (PI)
            Console.WriteLine("PI is defined");
         #else
            Console.WriteLine("PI is not defined");
         #endif
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
PI is defined
</pre>
<h2>Conditional Directives</h2>
<p>You can use the #if directive to create a conditional directive. Conditional directives are useful for testing a symbol or symbols to check if they evaluate to true. If they do evaluate to true, the compiler evaluates all the code between the #if and the next directive.</p>
<p>Syntax for conditional directive is:</p>
<pre class="prettyprint notranslate">
#if symbol [operator symbol]...
</pre>
<p>Where, <i>symbol</i> is the name of the symbol you want to test. You can also use true and false or prepend the symbol with the negation operator.</p>
<p>The <i>operator symbol</i> is the operator used for evaluating the symbol. Operators could be either of the following:</p>
<ul class="list">
<li>== (equality)</li>
<li>!= (inequality)</li>
<li>&amp;&amp; (and)</li>
<li>|| (or)</li>
</ul>
<p>You can also group symbols and operators with parentheses. Conditional directives are used for compiling code for a debug build or when compiling for a specific configuration. A conditional directive beginning with a <b>#if</b> directive must explicitly be terminated with a <b>#endif</b> directive.</p>
<p>The following program demonstrates use of conditional directives:</p>
<pre class="prettyprint notranslate tryit">
#define DEBUG
#define VC_V10
using System;
public class TestClass
{
   public static void Main()
   {
      #if (DEBUG && !VC_V10)
         Console.WriteLine("DEBUG is defined");
      #elif (!DEBUG && VC_V10)
         Console.WriteLine("VC_V10 is defined");
      #elif (DEBUG && VC_V10)
         Console.WriteLine("DEBUG and VC_V10 are defined");
      #else
         Console.WriteLine("DEBUG and VC_V10 are not defined");
      #endif
      Console.ReadKey();
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
DEBUG and VC_V10 are defined
</pre>

<title>C# - Regular Expressions</title>

<h1>C# - Regular Expressions</h1>

<p>A <b>regular expression</b> is a pattern that could be matched against an input text. The .Net framework provides a regular expression engine that allows such matching. A pattern consists of one or more character literals, operators, or constructs.</p>

<h2>Constructs for Defining Regular Expressions</h2>

<p>There are various categories of characters, operators, and constructs that lets you to define regular expressions. Click the following links to find these constructs.</p>

<p><a href="/csharp/csharp_character_escapes.htm" title="csharp character escapes regular expression">Character escapes</a></p>

<p><a href="/csharp/csharp_character_classes.htm" title="csharp character classes regular expression">Character classes</a></p>

<p><a href="/csharp/csharp_anchors.htm" title="csharp anchors regular expression">Anchors</a></p>

<p><a href="/csharp/csharp_grouping_constructs.htm" title="csharp grouping constructs regular expression">Grouping constructs</a></p>

<p><a href="/csharp/csharp_quantifiers.htm" title="csharp quantifiers regular expression">Quantifiers</a></p>

<p><a href="/csharp/csharp_backreference_constructs.htm" title="csharp backreference constructs regular expression">Backreference constructs</a></p>

<p><a href="/csharp/csharp_alternation_constructs.htm" title="csharp alternation constructs regular expression">Alternation constructs</a></p>

<p><a href="/csharp/csharp_substitutions.htm" title="csharp substitutions regular expression">Substitutions</a></p>

<p><a href="/csharp/csharp_miscellaneous_constructs.htm" title="csharp miscellaneous constructs regular expression">Miscellaneous constructs</a></p>

<h2>The Regex Class</h2>

<p>The Regex class is used for representing a regular expression. It has the following commonly used methods:</p>

<p>Indicates whether the regular expression specified in the Regex constructor finds a match in a specified input string.</p>

<p>Indicates whether the regular expression specified in the Regex constructor finds a match in the specified input string, beginning at the specified starting position in the string.</p>

<p>Indicates whether the specified regular expression finds a match in the specified input string.</p>

<p>Searches the specified input string for all occurrences of a regular expression.</p>

<p>In a specified input string, replaces all strings that match a regular expression pattern with a specified replacement string.</p>

<p>Splits an input string into an array of substrings at the positions defined by a regular expression pattern specified in the Regex constructor.</p>

<p>For the complete list of methods and properties, please read the Microsoft documentation on C#.</p>

<h2>Example 1</h2>

<p>The following example matches words that start with 'S':</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Example 2</h2>

<p>The following example matches words that start with 'm' and ends with 'e':</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Example 3</h2>

<p>This example replaces extra white space:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate tryit">
using System;
using System.Text.RegularExpressions;

namespace RegExApplication
{
   class Program
   {
      private static void showMatch(string text, string expr)
      {
         Console.WriteLine("The Expression: " + expr);
         MatchCollection mc = Regex.Matches(text, expr);
         foreach (Match m in mc)
         {
            Console.WriteLine(m);
         }
      }
      
      static void Main(string[] args)
      {
         string str = "A Thousand Splendid Suns";
         
         Console.WriteLine("Matching words that start with 'S': ");
         showMatch(str, @"\bS\S*");
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Matching words that start with 'S':
The Expression: \bS\S*
Splendid
Suns
</pre>
<h2>Example 2</h2>
<p>The following example matches words that start with 'm' and ends with 'e':</p>
<pre class="prettyprint notranslate tryit">
using System;
using System.Text.RegularExpressions;

namespace RegExApplication
{
   class Program
   {
      private static void showMatch(string text, string expr)
      {
         Console.WriteLine("The Expression: " + expr);
         MatchCollection mc = Regex.Matches(text, expr);
         foreach (Match m in mc)
         {
            Console.WriteLine(m);
         }
      }
      static void Main(string[] args)
      {
         string str = "make maze and manage to measure it";

         Console.WriteLine("Matching words start with 'm' and ends with 'e':");
         showMatch(str, @"\bm\S*e\b");
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Matching words start with 'm' and ends with 'e':
The Expression: \bm\S*e\b
make
maze
manage
measure
</pre>
<h2>Example 3</h2>
<p>This example replaces extra white space:</p>
<pre class="prettyprint notranslate">
using System;
using System.Text.RegularExpressions;

namespace RegExApplication
{
   class Program
   {
      static void Main(string[] args)
      {
         string input = "Hello   World   ";
         string pattern = "\\s+";
         string replacement = " ";
         Regex rgx = new Regex(pattern);
         string result = rgx.Replace(input, replacement);

         Console.WriteLine("Original String: {0}", input);
         Console.WriteLine("Replacement String: {0}", result);    
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Original String: Hello World   
Replacement String: Hello World   
</pre>

<title>C# - Exception Handling</title>

<h1>C# - Exception Handling</h1>

<p>An exception is a problem that arises during the execution of a program. A C# exception is a response to an exceptional circumstance that arises while a program is running, such as an attempt to divide by zero.</p>

<p>Exceptions provide a way to transfer control from one part of a program to another. C# exception handling is built upon four keywords: <b>try</b>, <b>catch</b>, <b>finally</b>, and <b>throw</b>.</p>

<p><b>try</b>: A try block identifies a block of code for which particular exceptions is activated. It is followed by one or more catch blocks.</p>

<p><b>catch</b>: A program catches an exception with an exception handler at the place in a program where you want to handle the problem. The catch keyword indicates the catching of an exception.</p>

<p><b>finally</b>: The finally block is used to execute a given set of statements, whether an exception is thrown or not thrown. For example, if you open a file, it must be closed whether an exception is raised or not.</p>

<p><b>throw</b>: A program throws an exception when a problem shows up. This is done using a throw keyword.</p>

<h2>Syntax</h2>

<p>Assuming a block raises an exception, a method catches an exception using a combination of the try and catch keywords. A try/catch block is placed around the code that might generate an exception. Code within a try/catch block is referred to as protected code, and the syntax for using try/catch looks like the following:</p>

<p>You can list down multiple catch statements to catch different type of exceptions in case your try block raises more than one exception in different situations.</p>

<h2>Exception Classes in C#</h2>

<p>C# exceptions are represented by classes. The exception classes in C# are mainly directly or indirectly derived from the <b>System.Exception</b> class. Some of the exception classes derived from the System.Exception class are the <b>System.ApplicationException</b> and <b>  System.SystemException</b> classes.</p>

<p>The <b>System.ApplicationException</b> class supports exceptions generated by application programs. Hence the exceptions defined by the programmers should derive from this class.</p>

<p>The <b>System.SystemException</b> class is the base class for all predefined system exception.</p>

<p>The following table provides some of the predefined exception classes derived from the Sytem.SystemException class:</p>

<h2>Handling Exceptions</h2>

<p>C# provides a structured solution to the exception handling in the form of try and catch blocks. Using these blocks the core program statements are separated from the error-handling statements.</p>

<p>These error handling blocks are implemented using the <b>try</b>, <b>catch</b>, and <b>finally</b> keywords. Following is an example of throwing an exception when dividing by zero condition occurs:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Creating User-Defined Exceptions</h2>

<p>You can also define your own exception. User-defined exception classes are derived from the <b>Exception</b> class. The following example demonstrates this:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Throwing Objects</h2>

<p>You can throw an object if it is either directly or indirectly derived from the <b>System.Exception</b> class. You can use a throw statement in the catch block to throw the present object as:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
try
{
   // statements causing exception
}
catch( ExceptionName e1 )
{
   // error handling code
}
catch( ExceptionName e2 )
{
   // error handling code
}
catch( ExceptionName eN )
{
   // error handling code
}
finally
{
   // statements to be executed
}
</pre>
<p>You can list down multiple catch statements to catch different type of exceptions in case your try block raises more than one exception in different situations.</p>
<h2>Exception Classes in C#</h2>
<p>C# exceptions are represented by classes. The exception classes in C# are mainly directly or indirectly derived from the <b>System.Exception</b> class. Some of the exception classes derived from the System.Exception class are the <b>System.ApplicationException</b> and <b>  System.SystemException</b> classes.</p>
<p>The <b>System.ApplicationException</b> class supports exceptions generated by application programs. Hence the exceptions defined by the programmers should derive from this class.</p>
<p>The <b>System.SystemException</b> class is the base class for all predefined system exception.</p>
<p>The following table provides some of the predefined exception classes derived from the Sytem.SystemException class:</p>
<table class="table table-bordered">
<tr>
<th style="width:40%;">Exception Class</th>
<th>Description</th>
</tr>
<tr>
<td>System.IO.IOException</td>
<td>Handles I/O errors.</td>
</tr>
<tr>
<td>System.IndexOutOfRangeException</td>
<td>Handles errors generated when a method refers to an array index out of range.</td>
</tr>
<tr>
<td>System.ArrayTypeMismatchException</td>
<td>Handles errors generated when type is mismatched with the array type.</td>
</tr>
<tr>
<td>System.NullReferenceException</td>
<td>Handles errors generated from referencing a null object.</td>
</tr>
<tr>
<td>System.DivideByZeroException</td>
<td>Handles errors generated from dividing a dividend with zero.</td>
</tr>
<tr>
<td>System.InvalidCastException</td>
<td>Handles errors generated during typecasting.</td>
</tr>
<tr>
<td>System.OutOfMemoryException</td>
<td>Handles errors generated from insufficient free memory.</td>
</tr>
<tr>
<td>System.StackOverflowException</td>
<td>Handles errors generated from stack overflow.</td>
</tr>
</table>
<h2>Handling Exceptions</h2>
<p>C# provides a structured solution to the exception handling in the form of try and catch blocks. Using these blocks the core program statements are separated from the error-handling statements.</p>
<p>These error handling blocks are implemented using the <b>try</b>, <b>catch</b>, and <b>finally</b> keywords. Following is an example of throwing an exception when dividing by zero condition occurs:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace ErrorHandlingApplication
{
   class DivNumbers
   {
      int result;
      DivNumbers()
      {
         result = 0;
      }
      public void division(int num1, int num2)
      {
         try
         {
            result = num1 / num2;
         }
         catch (DivideByZeroException e)
         {
            Console.WriteLine("Exception caught: {0}", e);
         }
         finally
         {
            Console.WriteLine("Result: {0}", result);
         }
      }
      static void Main(string[] args)
      {
         DivNumbers d = new DivNumbers();
         d.division(25, 0);
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Exception caught: System.DivideByZeroException: Attempted to divide by zero. 
at ...
Result: 0
</pre>
<h2>Creating User-Defined Exceptions</h2>
<p>You can also define your own exception. User-defined exception classes are derived from the <b>Exception</b> class. The following example demonstrates this:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace UserDefinedException
{
   class TestTemperature
   {
      static void Main(string[] args)
      {
         Temperature temp = new Temperature();
         try
         {
            temp.showTemp();
         }
         catch(TempIsZeroException e)
         {
            Console.WriteLine("TempIsZeroException: {0}", e.Message);
         }
         Console.ReadKey();
      }
   }
}

public class TempIsZeroException: Exception
{
   public TempIsZeroException(string message): base(message)
   {
   }
}

public class Temperature
{
   int temperature = 0;
   public void showTemp()
   {
      if(temperature == 0)
      {
         throw (new TempIsZeroException("Zero Temperature found"));
      }
      else
      {
         Console.WriteLine("Temperature: {0}", temperature);
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
TempIsZeroException: Zero Temperature found
</pre>
<h2>Throwing Objects</h2>
<p>You can throw an object if it is either directly or indirectly derived from the <b>System.Exception</b> class. You can use a throw statement in the catch block to throw the present object as:</p>
<pre class="prettyprint notranslate">
Catch(Exception e)
{
   ...
   Throw e
}
</pre>

<title>C# - File I/O</title>

<h1>C# - File I/O</h1>

<p>A <b>file</b> is a collection of data stored in a disk with a specific name and a directory path. When a file is opened for reading or writing, it becomes a <b>stream</b>.</p>

<p>The stream is basically the sequence of bytes passing through the communication path. There are two main streams: the <b>input stream</b> and the <b>output stream</b>. The<b> input stream</b> is used for reading data from file (read operation) and the <b>output stream</b> is used for writing into the file (write operation).</p>

<h2>C# I/O Classes</h2>

<p>The System.IO namespace has various classes that are used for performing numerous operations with files, such as creating and deleting files, reading from or writing to a file, closing a file etc.</p>

<p>The following table shows some commonly used non-abstract classes in the System.IO namespace:</p>

<h2>The FileStream Class</h2>

<p>The <b>FileStream</b> class in the System.IO namespace helps in reading from, writing to and closing files. This class derives from the abstract class Stream.</p>

<p>You need to create a <b>FileStream</b> object to create a new file or open an existing file. The syntax for creating a <b>FileStream</b> object is as follows:</p>

<p>For example, we create a FileStream object <b>F</b> for reading a file named <b>sample.txt as shown</b>:</p>

<p>The <b>FileMode</b> enumerator defines various methods for opening files. The members of the FileMode enumerator are:</p>

<p><b>Append</b>: It opens an existing file and puts cursor at the end of file, or creates the file, if the file does not exist.</p>

<p><b>Create</b>: It creates a new file.</p>

<p><b>CreateNew</b>: It specifies to the operating system, that it should create a new file.</p>

<p><b>Open</b>: It opens an existing file.</p>

<p><b>OpenOrCreate</b>: It specifies to the operating system that it should open a file if it exists, otherwise it should create a new file.</p>

<p><b>Truncate</b>: It opens an existing file and truncates its size to zero bytes.</p>

<p><b>FileAccess</b> enumerators have members: <b>Read</b>, <b>ReadWrite</b> and <b>Write</b>.</p>

<p><b>FileShare</b> enumerators have the following members:</p>

<p><b>Inheritable</b>: It allows a file handle to pass inheritance to the child processes</p>

<p><b>None</b>: It declines sharing of the current file</p>

<p><b>Read</b>: It allows opening the file for reading </p>

<p><b>ReadWrite</b>: It allows opening the file for reading and writing</p>

<p><b>Write</b>: It allows opening the file for writing</p>

<h2>Example</h2>

<p>The following program demonstrates use of the <b>FileStream </b>class:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Advanced File Operations in C#</h2>

<p>The preceding example provides simple file operations in C#. However, to utilize the immense powers of C# System.IO classes, you need to know the commonly used properties and methods of these classes.</p>

<p><a href="/csharp/csharp_text_files.htm" title="C# text files">Reading from and Writing into Text files</a></p>

<p>It involves reading from and writing into text files. The <b>StreamReader</b> and <b>StreamWriter</b> class helps to accomplish it.</p>

<p><a href="/csharp/csharp_binary_files.htm" title="C# binary files">Reading from and Writing into Binary files</a></p>

<p>It involves reading from and writing into binary files. The <b>BinaryReader</b> and <b>BinaryWriter</b> class helps to accomplish this.</p>

<p><a href="/csharp/csharp_windows_file_system.htm" title="C# Windows file system">Manipulating the Windows file system</a></p>

<p>It gives a C# programamer the ability to browse and locate Windows files and directories.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
FileStream &lt;object_name&gt; = new FileStream( &lt;file_name&gt;, &lt;FileMode Enumerator&gt;, &lt;FileAccess Enumerator&gt;, &lt;FileShare Enumerator&gt;);
</pre>
<p>For example, we create a FileStream object <b>F</b> for reading a file named <b>sample.txt as shown</b>:</p>
<pre class="prettyprint notranslate">
FileStream F = new FileStream("sample.txt", FileMode.Open, FileAccess.Read, FileShare.Read);</pre>
<table class="table table-bordered">
<tr>
<th style="width:20%;">Parameter</th>
<th>Description</th>
</tr>
<tr>
<td>FileMode</td>
<td><p>The <b>FileMode</b> enumerator defines various methods for opening files. The members of the FileMode enumerator are:</p>
<ul class="list">
<li><p><b>Append</b>: It opens an existing file and puts cursor at the end of file, or creates the file, if the file does not exist.</p></li>
<li><p><b>Create</b>: It creates a new file.</p></li>
<li><p><b>CreateNew</b>: It specifies to the operating system, that it should create a new file.</p></li>
<li><p><b>Open</b>: It opens an existing file.</p></li>
<li><p><b>OpenOrCreate</b>: It specifies to the operating system that it should open a file if it exists, otherwise it should create a new file.</p></li>
<li><p><b>Truncate</b>: It opens an existing file and truncates its size to zero bytes.</p></li>
</ul>
</td>
</tr>
<tr>
<td>FileAccess</td>
<td><p><b>FileAccess</b> enumerators have members: <b>Read</b>, <b>ReadWrite</b> and <b>Write</b>.</p>
</td>
</tr>
<tr>
<td>FileShare</td>
<td><p><b>FileShare</b> enumerators have the following members:</p>
<ul class="list">
<li><p><b>Inheritable</b>: It allows a file handle to pass inheritance to the child processes</p></li>
<li><p><b>None</b>: It declines sharing of the current file</p></li>
<li><p><b>Read</b>: It allows opening the file for reading </p></li>
<li><p><b>ReadWrite</b>: It allows opening the file for reading and writing</p></li>
<li><p><b>Write</b>: It allows opening the file for writing</p></li>
</ul>
</td>
</tr>
</table>
<h2>Example</h2>
<p>The following program demonstrates use of the <b>FileStream </b>class:</p>
<pre class="prettyprint notranslate tryit">
using System;
using System.IO;

namespace FileIOApplication
{
   class Program
   {
      static void Main(string[] args)
      {
         FileStream F = new FileStream("test.dat", FileMode.OpenOrCreate, FileAccess.ReadWrite);
         for (int i = 1; i &lt;= 20; i++)
         {
            F.WriteByte((byte)i);
         }
         
         F.Position = 0;
         for (int i = 0; i &lt;= 20; i++)
         {
            Console.Write(F.ReadByte() + " ");
         }
         F.Close();
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 -1
</pre>

<title>C# - Attributes</title>

<h1>C# - Attributes</h1>

<p>An <b>attribute</b> is a declarative tag that is used to convey information to runtime about the behaviors of various elements like classes, methods, structures, enumerators, assemblies etc. in your program. You can add declarative information to a program by using an attribute. A declarative tag is depicted by square ([ ]) brackets placed above the element it is used for.</p>

<p>Attributes are used for adding metadata, such as compiler instruction and other information such as comments, description, methods and classes to a program. The .Net Framework provides two types of attributes: <i>the pre-defined</i> attributes and <i>custom built</i> attributes.</p>

<h2>Specifying an Attribute</h2>

<p>Syntax for specifying an attribute is as follows:</p>

<p>Name of the attribute and its values are specified within the square brackets, before the element to which the attribute is applied. Positional parameters specify the essential information and the name parameters specify the optional information.</p>

<h2>Predefined Attributes</h2>

<p>The .Net Framework provides three pre-defined attributes:</p>

<h2>AttributeUsage</h2>

<p>The pre-defined attribute <b>AttributeUsage</b> describes how a custom attribute class can be used. It specifies the types of items to which the attribute can be applied.</p>

<p>Syntax for specifying this attribute is as follows:</p>

<p>Where,</p>

<p>The parameter validon specifies the language elements on which the attribute can be placed. It is a combination of the value of an enumerator <i>AttributeTargets</i>. The default value is <i> AttributeTargets.All</i>.</p>

<p>The parameter <i>allowmultiple</i> (optional) provides value for the <i>AllowMultiple</i> property of this attribute, a Boolean value. If this is true, the attribute is multiuse. The default is false (single-use).</p>

<p>The parameter inherited (optional) provides value for the <i>Inherited</i> property of this attribute, a Boolean value. If it is true, the attribute is inherited by derived classes. The default value is false (not inherited).</p>

<p>For example,</p>

<h2>Conditional</h2>

<p>This predefined attribute marks a conditional method whose execution depends on a specified preprocessing identifier.</p>

<p>It causes conditional compilation of method calls, depending on the specified value such as <b>Debug</b> or <b> Trace</b>. For example, it displays the values of the variables while debugging a code.</p>

<p>Syntax for specifying this attribute is as follows:</p>

<p>For example,</p>

<p>The following example demonstrates the attribute:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Obsolete</h2>

<p>This predefined attribute marks a program entity that should not be used. It enables you to inform the compiler to discard a particular target element. For example, when a new method is being used in a class and if you still want to retain the old method in the class, you may mark it as obsolete by displaying a message the new method should be used, instead of the old method.</p>

<p>Syntax for specifying this attribute is as follows:</p>

<p>Where,</p>

<p>The parameter <i>message</i>, is a string describing the reason why the item is obsolete and what to use instead.</p>

<p>The parameter <i>iserror</i>, is a Boolean value. If its value is true, the compiler should treat the use of the item as an error. Default value is false (compiler generates a warning).</p>

<p>The following program demonstrates this:</p>

<p>When you try to compile the program, the compiler gives an error message stating:</p>

<h2>Creating Custom Attributes</h2>

<p>The .Net Framework allows creation of custom attributes that can be used to store declarative information and can be retrieved at run-time. This information can be related to any target element depending upon the design criteria and application need.</p>

<p>Creating and using custom attributes involve four steps:</p>

<p>The Last step involves writing a simple program to read through the metadata to find various notations. Metadata is data about data or information used for describing other data. This program should use reflections for accessing attributes at runtime. This we will discuss in the next chapter.</p>

<h2>Declaring a Custom Attribute</h2>

<p>A new custom attribute should is derived from the <b>System.Attribute</b> class. For example,</p>

<p>In the preceding code, we have declared a custom attribute named <i>DeBugInfo</i>.</p>

<h2>Constructing the Custom Attribute</h2>

<p>Let us construct a custom attribute named <i>DeBugInfo</i>, which stores the information obtained by debugging any program. Let it store the following information:</p>

<p>The <i>DeBugInfo</i> class has three private properties for storing the first three information and a public property for storing the message. Hence the bug number, developer's name, and date of review are the positional parameters of the DeBugInfo class and the message is an optional or named parameter.</p>

<p>Each attribute must have at least one constructor. The positional parameters should be passed through the constructor. The following code shows the <i>DeBugInfo</i> class:</p>

<h2>Applying the Custom Attribute</h2>

<p>The attribute is applied by placing it immediately before its target:</p>

<p>In the next chapter, we retrieve attribute information using a Reflection class object.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
[attribute(positional_parameters, name_parameter = value, ...)]
element
</pre>
<p>Name of the attribute and its values are specified within the square brackets, before the element to which the attribute is applied. Positional parameters specify the essential information and the name parameters specify the optional information.</p>
<h2>Predefined Attributes</h2>
<p>The .Net Framework provides three pre-defined attributes:</p>
<ul class="list">
<li>AttributeUsage</li>
<li>Conditional</li>
<li>Obsolete</li>
</ul>
<h2>AttributeUsage</h2> 
<p>The pre-defined attribute <b>AttributeUsage</b> describes how a custom attribute class can be used. It specifies the types of items to which the attribute can be applied.</p>
<p>Syntax for specifying this attribute is as follows:</p>
<pre class="prettyprint notranslate">
[AttributeUsage(
   validon,
   AllowMultiple=allowmultiple,
   Inherited=inherited
)]
</pre>
<p>Where,</p>
<ul class="list">
<li><p>The parameter validon specifies the language elements on which the attribute can be placed. It is a combination of the value of an enumerator <i>AttributeTargets</i>. The default value is <i> AttributeTargets.All</i>.</p></li>
<li><p>The parameter <i>allowmultiple</i> (optional) provides value for the <i>AllowMultiple</i> property of this attribute, a Boolean value. If this is true, the attribute is multiuse. The default is false (single-use).</p></li>
<li><p>The parameter inherited (optional) provides value for the <i>Inherited</i> property of this attribute, a Boolean value. If it is true, the attribute is inherited by derived classes. The default value is false (not inherited).</p></li>
</ul>
<p>For example,</p>
<pre class="prettyprint notranslate">
[AttributeUsage(AttributeTargets.Class |
AttributeTargets.Constructor |
AttributeTargets.Field |
AttributeTargets.Method |
AttributeTargets.Property, 
AllowMultiple = true)]
</pre>
<h2>Conditional</h2>
<p>This predefined attribute marks a conditional method whose execution depends on a specified preprocessing identifier.</p>
<p>It causes conditional compilation of method calls, depending on the specified value such as <b>Debug</b> or <b> Trace</b>. For example, it displays the values of the variables while debugging a code.</p>
<p>Syntax for specifying this attribute is as follows:</p>
<pre class="prettyprint notranslate">
[Conditional(
   conditionalSymbol
)]
</pre>
<p>For example,</p>
<pre class="prettyprint notranslate">
[Conditional("DEBUG")]
</pre>
<p>The following example demonstrates the attribute:</p>
<pre class="prettyprint notranslate tryit">
#define DEBUG
using System;
using System.Diagnostics;

public class Myclass
{
   [Conditional("DEBUG")]
   public static void Message(string msg)
   {
      Console.WriteLine(msg);
   }
}

class Test
{
   static void function1()
   {
      Myclass.Message("In Function 1.");
      function2();
   }
   static void function2()
   {
      Myclass.Message("In Function 2.");
   }
   
   public static void Main()
   {
      Myclass.Message("In Main function.");
      function1();
      Console.ReadKey();
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
In Main function
In Function 1
In Function 2
</pre>
<h2>Obsolete</h2>
<p>This predefined attribute marks a program entity that should not be used. It enables you to inform the compiler to discard a particular target element. For example, when a new method is being used in a class and if you still want to retain the old method in the class, you may mark it as obsolete by displaying a message the new method should be used, instead of the old method.</p>
<p>Syntax for specifying this attribute is as follows:</p>
<pre class="prettyprint notranslate">
[Obsolete(
   message
)]
[Obsolete(
   message,
   iserror
)]
</pre>
<p>Where,</p>
<ul class="list">
<li><p>The parameter <i>message</i>, is a string describing the reason why the item is obsolete and what to use instead.</p></li>
<li><p>The parameter <i>iserror</i>, is a Boolean value. If its value is true, the compiler should treat the use of the item as an error. Default value is false (compiler generates a warning).</p></li>
</ul>
<p>The following program demonstrates this:</p>
<pre class="prettyprint notranslate tryit">
using System;

public class MyClass
{
   [Obsolete("Don't use OldMethod, use NewMethod instead", true)]
   static void OldMethod()
   {
      Console.WriteLine("It is the old method");
   }
   static void NewMethod()
   {
      Console.WriteLine("It is the new method"); 
   }
   public static void Main()
   {
      OldMethod();
   }
}
</pre>
<p>When you try to compile the program, the compiler gives an error message stating:</p>
<pre class="result notranslate">
 Don't use OldMethod, use NewMethod instead
</pre>
<h2>Creating Custom Attributes</h2>
<p>The .Net Framework allows creation of custom attributes that can be used to store declarative information and can be retrieved at run-time. This information can be related to any target element depending upon the design criteria and application need.</p>
<p>Creating and using custom attributes involve four steps:</p>
<ul class="list">
<li>Declaring a custom attribute</li>
<li>Constructing the custom attribute</li>
<li>Apply the custom attribute on a target program element</li>
<li>Accessing Attributes Through Reflection</li>
</ul>
<p>The Last step involves writing a simple program to read through the metadata to find various notations. Metadata is data about data or information used for describing other data. This program should use reflections for accessing attributes at runtime. This we will discuss in the next chapter.</p>
<h2>Declaring a Custom Attribute</h2>
<p>A new custom attribute should is derived from the <b>System.Attribute</b> class. For example,</p>
<pre class="prettyprint notranslate">
//a custom attribute BugFix to be assigned to a class and its members
[AttributeUsage(AttributeTargets.Class |
AttributeTargets.Constructor |
AttributeTargets.Field |
AttributeTargets.Method |
AttributeTargets.Property,
AllowMultiple = true)]

public class DeBugInfo : System.Attribute
</pre>
<p>In the preceding code, we have declared a custom attribute named <i>DeBugInfo</i>.</p>
<h2>Constructing the Custom Attribute</h2>
<p>Let us construct a custom attribute named <i>DeBugInfo</i>, which stores the information obtained by debugging any program. Let it store the following information:</p>
<ul class="list">
<li>The code number for the bug</li>
<li>Name of the developer who identified the bug</li>
<li>Date of last review of the code</li>
<li>A string message for storing the developer's remarks</li>
</ul>
<p>The <i>DeBugInfo</i> class has three private properties for storing the first three information and a public property for storing the message. Hence the bug number, developer's name, and date of review are the positional parameters of the DeBugInfo class and the message is an optional or named parameter.</p>
<p>Each attribute must have at least one constructor. The positional parameters should be passed through the constructor. The following code shows the <i>DeBugInfo</i> class:</p>
<pre class="prettyprint notranslate tryit">
//a custom attribute BugFix to be assigned to a class and its members
[AttributeUsage(AttributeTargets.Class |
AttributeTargets.Constructor |
AttributeTargets.Field |
AttributeTargets.Method |
AttributeTargets.Property,
AllowMultiple = true)]

public class DeBugInfo : System.Attribute
{
   private int bugNo;
   private string developer;
   private string lastReview;
   public string message;
   
   public DeBugInfo(int bg, string dev, string d)
   {
      this.bugNo = bg;
      this.developer = dev;
      this.lastReview = d;
   }
   
   public int BugNo
   {
      get
      {
         return bugNo;
      }
   }
   
   public string Developer
   {
      get
      {
         return developer;
      }
   }
   
   public string LastReview
   {
      get
      {
         return lastReview;
      }
   }
   
   public string Message
   {
      get
      {
         return message;
      }
      set
      {
         message = value;
      }
   }
}
</pre>
<h2>Applying the Custom Attribute</h2>
<p>The attribute is applied by placing it immediately before its target:</p>
<pre class="prettyprint notranslate">
[DeBugInfo(45, "Zara Ali", "12/8/2012", Message = "Return type mismatch")]
[DeBugInfo(49, "Nuha Ali", "10/10/2012", Message = "Unused variable")]
class Rectangle
{
   //member variables
   protected double length;
   protected double width;
   public Rectangle(double l, double w)
   {
      length = l;
      width = w;
   }
   [DeBugInfo(55, "Zara Ali", "19/10/2012", Message = "Return type mismatch")]
   
   public double GetArea()
   {
      return length * width;
   }
   [DeBugInfo(56, "Zara Ali", "19/10/2012")]
   
   public void Display()
   {
      Console.WriteLine("Length: {0}", length);
      Console.WriteLine("Width: {0}", width);
      Console.WriteLine("Area: {0}", GetArea());
   }
}
</pre>

<title>C# - Reflection</title>

<h1>C# - Reflection</h1>

<p><b>Reflection</b> objects are used for obtaining type information at runtime. The classes that give access to the metadata of a running program are in the <b>System.Reflection</b> namespace.</p>

<p>The <b>System.Reflection</b> namespace contains classes that allow you to obtain information about the application and to dynamically add types, values, and objects to the application.</p>

<h2>Applications of Reflection</h2>

<p>Reflection has the following applications:</p>

<p>It allows view attribute information at runtime.</p>

<p>It allows examining various types in an assembly and instantiate these types.</p>

<p>It allows late binding to methods and properties</p>

<p>It allows creating new types at runtime and then performs some tasks using those types. </p>

<h2>Viewing Metadata</h2>

<p>We have mentioned in the preceding chapter that using reflection you can view the attribute information.</p>

<p>The <b>MemberInfo</b> object of the <b>System.Reflection</b> class needs to be initialized for discovering the attributes associated with a class. To do this, you define an object of the target class, as:</p>

<p>The following program demonstrates this:</p>

<p>When it is compiled and run, it displays the name of the custom attributes attached to the class <i>MyClass</i>:</p>

<h2>Example</h2>

<p>In this example, we use the <i>DeBugInfo</i> attribute created in the previous chapter and use reflection to read metadata in the <i>Rectangle</i> class.</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
System.Reflection.MemberInfo info = typeof(MyClass);
</pre>
<p>The following program demonstrates this:</p>
<pre class="prettyprint notranslate tryit">
using System;

[AttributeUsage(AttributeTargets.All)]
public class HelpAttribute : System.Attribute
{
   public readonly string Url;
   
   public string Topic   // Topic is a named parameter
   {
      get
      {
         return topic;
      }
      set
      {
         topic = value;
      }
   }
   
   public HelpAttribute(string url)   // url is a positional parameter
   {
      this.Url = url;
   }
   private string topic;
}

[HelpAttribute("Information on the class MyClass")]
class MyClass
{
}
namespace AttributeAppl
{
   class Program
   {
      static void Main(string[] args)
      {
         System.Reflection.MemberInfo info = typeof(MyClass);
         object[] attributes = info.GetCustomAttributes(true);
         for (int i = 0; i &lt; attributes.Length; i++)
         {
            System.Console.WriteLine(attributes[i]);
         }
         
         Console.ReadKey();
      }
   }
}
</pre>
<p>When it is compiled and run, it displays the name of the custom attributes attached to the class <i>MyClass</i>:</p>
<pre class="result notranslate">
HelpAttribute
</pre>
<h2>Example</h2>
<p>In this example, we use the <i>DeBugInfo</i> attribute created in the previous chapter and use reflection to read metadata in the <i>Rectangle</i> class.</p> 
<pre class="prettyprint notranslate tryit">
using System;
using System.Reflection;

namespace BugFixApplication
{
   //a custom attribute BugFix to be
   //assigned to a class and its members
   [AttributeUsage(AttributeTargets.Class |
   AttributeTargets.Constructor |
   AttributeTargets.Field |
   AttributeTargets.Method |
   AttributeTargets.Property,
   AllowMultiple = true)]

   public class DeBugInfo : System.Attribute
   {
      private int bugNo;
      private string developer;
      private string lastReview;
      public string message;
      
      public DeBugInfo(int bg, string dev, string d)
      {
         this.bugNo = bg;
         this.developer = dev;
         this.lastReview = d;
      }
      
      public int BugNo
      {
         get
         {
            return bugNo;
         }
      }
      
      public string Developer
      {
         get
         {
            return developer;
         }
      }
      
      public string LastReview
      {
         get
         {
            return lastReview;
         }
      }
      
      public string Message
      {
         get
         {
            return message;
         }
         set
         {
            message = value;
         }
      }
   }
   [DeBugInfo(45, "Zara Ali", "12/8/2012", Message = "Return type mismatch")]
   [DeBugInfo(49, "Nuha Ali", "10/10/2012", Message = "Unused variable")]
   
   class Rectangle
   {
      //member variables
      protected double length;
      protected double width;
      public Rectangle(double l, double w)
      {
         length = l;
         width = w;
      }
      [DeBugInfo(55, "Zara Ali", "19/10/2012", Message = "Return type mismatch")]
      public double GetArea()
      {
         return length * width;
      }
      [DeBugInfo(56, "Zara Ali", "19/10/2012")]
      public void Display()
      {
         Console.WriteLine("Length: {0}", length);
         Console.WriteLine("Width: {0}", width);
         Console.WriteLine("Area: {0}", GetArea());
      }
   }//end class Rectangle
   
   class ExecuteRectangle
   {
      static void Main(string[] args)
      {
         Rectangle r = new Rectangle(4.5, 7.5);
         r.Display();
         Type type = typeof(Rectangle);
         
         //iterating through the attribtues of the Rectangle class
         foreach (Object attributes in type.GetCustomAttributes(false))
         {
            DeBugInfo dbi = (DeBugInfo)attributes;
            if (null != dbi)
            {
               Console.WriteLine("Bug no: {0}", dbi.BugNo);
               Console.WriteLine("Developer: {0}", dbi.Developer);
               Console.WriteLine("Last Reviewed: {0}", dbi.LastReview);
               Console.WriteLine("Remarks: {0}", dbi.Message);
            }
         }
         
         //iterating through the method attribtues
         foreach (MethodInfo m in type.GetMethods())
         {
            foreach (Attribute a in m.GetCustomAttributes(true))
            {
               DeBugInfo dbi = (DeBugInfo)a;
               if (null != dbi)
               {
                  Console.WriteLine("Bug no: {0}, for Method: {1}", dbi.BugNo, m.Name);
                  Console.WriteLine("Developer: {0}", dbi.Developer);
                  Console.WriteLine("Last Reviewed: {0}", dbi.LastReview);
                  Console.WriteLine("Remarks: {0}", dbi.Message);
               }
            }
         }
         
         Console.ReadLine();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Length: 4.5
Width: 7.5
Area: 33.75
Bug No: 49
Developer: Nuha Ali
Last Reviewed: 10/10/2012
Remarks: Unused variable
Bug No: 45
Developer: Zara Ali
Last Reviewed: 12/8/2012
Remarks: Return type mismatch
Bug No: 55, for Method: GetArea
Developer: Zara Ali
Last Reviewed: 19/10/2012
Remarks: Return type mismatch
Bug No: 56, for Method: Display
Developer: Zara Ali
Last Reviewed: 19/10/2012
Remarks: 
</pre>

<title>C# - Properties</title>

<h1>C# - Properties</h1>

<p><b>Properties</b> are named members of classes, structures, and interfaces. Member variables or methods in a class or structures are called <b>Fields</b>. Properties are an extension of fields and are accessed using the same syntax. They use <b>accessors</b> through which the values of the private fields can be read, written or manipulated.</p>

<p>Properties do not name the storage locations. Instead, they have <b>accessors</b> that read, write, or compute their values.</p>

<p>For example, let us have a class named Student, with private fields for age, name, and code. We cannot directly access these fields from outside the class scope, but we can have properties for accessing these private fields.</p>

<h2>Accessors</h2>

<p>The <b>accessor</b> of a property contains the executable statements that helps in getting (reading or computing) or setting (writing) the property. The accessor declarations can contain a get accessor, a set accessor, or both. For example:</p>

<h2>Example</h2>

<p>The following example demonstrates use of properties:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Abstract Properties</h2>

<p>An abstract class may have an abstract property, which should be implemented in the derived class. The following program illustrates this:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
// Declare a Code property of type string:
public string Code
{
   get
   {
      return code;
   }
   set
   {
      code = value;
   }
}

// Declare a Name property of type string:
public string Name
{
   get
   {
      return name;
   }
   set
   {
      name = value;
   }
}

// Declare a Age property of type int:
public int Age
{ 
   get
   {
      return age;
   }
   set
   {
      age = value;
   }
}
</pre>
<h2>Example</h2>
<p>The following example demonstrates use of properties:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace tutorialspoint
{
   class Student
   {
      private string code = "N.A";
      private string name = "not known";
      private int age = 0;
      
      // Declare a Code property of type string:
      public string Code
      {
         get
         {
            return code;
         }
         set
         {
            code = value;
         }
      }
      
      // Declare a Name property of type string:
      public string Name
      {
         get
         {
            return name;
         }
         set
         {
            name = value;
         }
      }
      
      // Declare a Age property of type int:
      public int Age
      {
         get
         {
            return age;
         }
         set
         {
            age = value;
         }
      }
      public override string ToString()
      {
         return "Code = " + Code +", Name = " + Name + ", Age = " + Age;
      }
   }
   
   class ExampleDemo
   {
      public static void Main()
      {
      
         // Create a new Student object:
         Student s = new Student();
         
         // Setting code, name and the age of the student
         s.Code = "001";
         s.Name = "Zara";
         s.Age = 9;
         Console.WriteLine("Student Info: {0}", s);
         
         //let us increase age
         s.Age += 1;
         Console.WriteLine("Student Info: {0}", s);
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Student Info: Code = 001, Name = Zara, Age = 9
Student Info: Code = 001, Name = Zara, Age = 10
</pre>
<h2>Abstract Properties</h2>
<p>An abstract class may have an abstract property, which should be implemented in the derived class. The following program illustrates this:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace tutorialspoint
{
   public abstract class Person
   {
      public abstract string Name
      {
         get;
         set;
      }
      public abstract int Age
      {
         get;
         set;
      }
   }
   
   class Student : Person
   {
   
      private string code = "N.A";
      private string name = "N.A";
      private int age = 0;
      
      // Declare a Code property of type string:
      public string Code
      {
         get
         {
            return code;
         }
         set
         {
            code = value;
         }
      }
      
      // Declare a Name property of type string:
      public override string Name
      {
         get
         {
            return name;
         }
         set
         {
            name = value;
         }
      }
      
      // Declare a Age property of type int:
      public override int Age
      {
         get
         {
            return age;
         }
         set
         {
            age = value;
         }
      }
      public override string ToString()
      {
         return "Code = " + Code +", Name = " + Name + ", Age = " + Age;
      }
   }
   
   class ExampleDemo
   {
      public static void Main()
      {
         // Create a new Student object:
         Student s = new Student();
         
         // Setting code, name and the age of the student
         s.Code = "001";
         s.Name = "Zara";
         s.Age = 9;
         Console.WriteLine("Student Info:- {0}", s);
         
         //let us increase age
         s.Age += 1;
         Console.WriteLine("Student Info:- {0}", s);
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Student Info: Code = 001, Name = Zara, Age = 9
Student Info: Code = 001, Name = Zara, Age = 10
</pre>

<title>C# - Indexers</title>

<h1>C# - Indexers</h1>

<p>An <b>indexer</b> allows an object to be indexed such as an array. When you define an indexer for a class, this class behaves similar to a <b>virtual array</b>. You can then access the instance of this class using the array access operator ([ ]).</p>

<h2>Syntax</h2>

<p>A one dimensional indexer has the following syntax:</p>

<h2>Use of Indexers</h2>

<p>Declaration of behavior of an indexer is to some extent similar to a property. similar to the properties, you use <b> get</b> and <b>set</b> accessors for defining an indexer. However, properties return or set a specific data member, whereas indexers returns or sets a particular value from the object instance. In other words, it breaks the instance data into smaller parts and indexes each part, gets or sets each part.</p>

<p>Defining a property involves providing a property name. Indexers are not defined with names, but with the <b>this</b> keyword, which refers to the object instance. The following example demonstrates the concept:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Overloaded Indexers</h2>

<p>Indexers can be overloaded. Indexers can also be declared with multiple parameters and each parameter may be a different type. It is not necessary that the indexes have to be integers. C# allows indexes to be of other types, for example, a string.</p>

<p>The following example demonstrates overloaded indexers:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
element-type this[int index]
{
   // The get accessor.
   get
   {
      // return the value specified by index
   }
   
   // The set accessor.
   set
   {
      // set the value specified by index
   }
}
</pre>
<h2>Use of Indexers</h2>
<p>Declaration of behavior of an indexer is to some extent similar to a property. similar to the properties, you use <b> get</b> and <b>set</b> accessors for defining an indexer. However, properties return or set a specific data member, whereas indexers returns or sets a particular value from the object instance. In other words, it breaks the instance data into smaller parts and indexes each part, gets or sets each part.</p>
<p>Defining a property involves providing a property name. Indexers are not defined with names, but with the <b>this</b> keyword, which refers to the object instance. The following example demonstrates the concept:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace IndexerApplication
{
   class IndexedNames
   {
      private string[] namelist = new string[size];
      static public int size = 10;
      public IndexedNames()
      {
         for (int i = 0; i &lt; size; i++)
         namelist[i] = "N. A.";
      }
      
      public string this[int index]
      {
         get
         {
            string tmp;
         
            if( index &gt;= 0 &amp;&amp; index &lt;= size-1 )
            {
               tmp = namelist[index];
            }
            else
            {
               tmp = "";
            }
            
            return ( tmp );
         }
         set
         {
            if( index &gt;= 0 &amp;&amp; index &lt;= size-1 )
            {
               namelist[index] = value;
            }
         }
      }
      
      static void Main(string[] args)
      {
         IndexedNames names = new IndexedNames();
         names[0] = "Zara";
         names[1] = "Riz";
         names[2] = "Nuha";
         names[3] = "Asif";
         names[4] = "Davinder";
         names[5] = "Sunil";
         names[6] = "Rubic";
         for ( int i = 0; i &lt; IndexedNames.size; i++ )
         {
            Console.WriteLine(names[i]);
         }
         
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Zara
Riz
Nuha
Asif
Davinder
Sunil
Rubic
N. A.
N. A.
N. A.
</pre>
<h2>Overloaded Indexers</h2>
<p>Indexers can be overloaded. Indexers can also be declared with multiple parameters and each parameter may be a different type. It is not necessary that the indexes have to be integers. C# allows indexes to be of other types, for example, a string.</p>
<p>The following example demonstrates overloaded indexers:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace IndexerApplication
{
   class IndexedNames
   {
      private string[] namelist = new string[size];
      static public int size = 10;
      public IndexedNames()
      {
         for (int i = 0; i &lt; size; i++)
         {
            namelist[i] = "N. A.";
         }
      }
      
      public string this[int index]
      {
         get
         {
            string tmp;
            
            if( index &gt;= 0 &amp;&amp; index &lt;= size-1 )
            {
               tmp = namelist[index];
            }
            else
            {
               tmp = "";
            }
            
            return ( tmp );
         }
         set
         {
            if( index &gt;= 0 &amp;&amp; index &lt;= size-1 )
            {
               namelist[index] = value;
            }
         }
      }
      public int this[string name]
      {
         get
         {
            int index = 0;
            while(index &lt; size)
            {
               if (namelist[index] == name)
               {
                return index;
               }
               index++;
            }
            return index;
         }

      }

      static void Main(string[] args)
      {
         IndexedNames names = new IndexedNames();
         names[0] = "Zara";
         names[1] = "Riz";
         names[2] = "Nuha";
         names[3] = "Asif";
         names[4] = "Davinder";
         names[5] = "Sunil";
         names[6] = "Rubic";
         
         //using the first indexer with int parameter
         for (int i = 0; i &lt; IndexedNames.size; i++)
         {
            Console.WriteLine(names[i]);
         }
         
         //using the second indexer with the string parameter
         Console.WriteLine(names["Nuha"]);
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Zara
Riz
Nuha
Asif
Davinder
Sunil
Rubic
N. A.
N. A.
N. A.
2
</pre>

<title>C# - Delegates</title>

<h1>C# - Delegates</h1>

<p>C# delegates are similar to pointers to functions, in C or C++. A <b>delegate</b> is a reference type variable that holds the reference to a method. The reference can be changed at runtime.</p>

<p>Delegates are especially used for implementing events and the call-back methods. All delegates are implicitly derived from the <b>System.Delegate</b> class.</p>

<h2>Declaring Delegates</h2>

<p>Delegate declaration determines the methods that can be referenced by the delegate. A delegate can refer to a method, which has the same signature as that of the delegate.</p>

<p>For example, consider a delegate:</p>

<p>The preceding delegate can be used to reference any method that has a single <i>string</i> parameter and returns an <i>int</i> type variable.</p>

<p>Syntax for delegate declaration is:</p>

<h2>Instantiating Delegates</h2>

<p>Once a delegate type is declared, a delegate object must be created with the <b>new </b> keyword and be associated with a particular method. When creating a delegate, the argument passed to the <b>new</b> expression is written similar to a method call, but without the arguments to the method. For example:</p>

<p>Following example demonstrates declaration, instantiation, and use of a delegate that can be used to reference methods that take an integer parameter and returns an integer value.</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Multicasting of a Delegate</h2>

<p>Delegate objects can be composed using the "+" operator. A composed delegate calls the two delegates it was composed from. Only delegates of the same type can be composed. The "-" operator can be used to remove a component delegate from a composed delegate.</p>

<p>Using this property of delegates you can create an invocation list of methods that will be called when a delegate is invoked. This is called <b>multicasting</b> of a delegate. The following program demonstrates multicasting of a delegate:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Using Delegates</h2>

<p>The following example demonstrates the use of delegate. The delegate <i>printString</i> can be used to reference method that takes a string as input and returns nothing.</p>

<p>We use this delegate to call two methods, the first prints the string to the console, and the second one prints it to a file:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
public delegate int MyDelegate (string s);
</pre>
<p>The preceding delegate can be used to reference any method that has a single <i>string</i> parameter and returns an <i>int</i> type variable.</p>
<p>Syntax for delegate declaration is:</p>
<pre class="prettyprint notranslate">
delegate &lt;return type&gt; &lt;delegate-name&gt; &lt;parameter list&gt;
</pre>
<h2>Instantiating Delegates</h2>
<p>Once a delegate type is declared, a delegate object must be created with the <b>new </b> keyword and be associated with a particular method. When creating a delegate, the argument passed to the <b>new</b> expression is written similar to a method call, but without the arguments to the method. For example:</p>
<pre class="prettyprint notranslate">
public delegate void printString(string s);
...
printString ps1 = new printString(WriteToScreen);
printString ps2 = new printString(WriteToFile);
</pre>
<p>Following example demonstrates declaration, instantiation, and use of a delegate that can be used to reference methods that take an integer parameter and returns an integer value.</p>
<pre class="prettyprint notranslate tryit">
using System;

delegate int NumberChanger(int n);
namespace DelegateAppl
{
   class TestDelegate
   {
      static int num = 10;
      public static int AddNum(int p)
      {
         num += p;
         return num;
      }

      public static int MultNum(int q)
      {
         num *= q;
         return num;
      }
      public static int getNum()
      {
         return num;
      }

      static void Main(string[] args)
      {
         //create delegate instances
         NumberChanger nc1 = new NumberChanger(AddNum);
         NumberChanger nc2 = new NumberChanger(MultNum);
         
         //calling the methods using the delegate objects
         nc1(25);
         Console.WriteLine("Value of Num: {0}", getNum());
         nc2(5);
         Console.WriteLine("Value of Num: {0}", getNum());
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Value of Num: 35
Value of Num: 175
</pre>
<h2>Multicasting of a Delegate</h2>
<p>Delegate objects can be composed using the "+" operator. A composed delegate calls the two delegates it was composed from. Only delegates of the same type can be composed. The "-" operator can be used to remove a component delegate from a composed delegate.</p>
<p>Using this property of delegates you can create an invocation list of methods that will be called when a delegate is invoked. This is called <b>multicasting</b> of a delegate. The following program demonstrates multicasting of a delegate:</p>
<pre class="prettyprint notranslate tryit">
using System;

delegate int NumberChanger(int n);
namespace DelegateAppl
{
   class TestDelegate
   {
      static int num = 10;
      public static int AddNum(int p)
      {
         num += p;
         return num;
      }

      public static int MultNum(int q)
      {
         num *= q;
         return num;
      }
      
      public static int getNum()
      {
         return num;
      }

      static void Main(string[] args)
      {
         //create delegate instances
         NumberChanger nc;
         NumberChanger nc1 = new NumberChanger(AddNum);
         NumberChanger nc2 = new NumberChanger(MultNum);
         nc = nc1;
         nc += nc2;
         
         //calling multicast
         nc(5);
         Console.WriteLine("Value of Num: {0}", getNum());
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Value of Num: 75
</pre>
<h2>Using Delegates</h2>
<p>The following example demonstrates the use of delegate. The delegate <i>printString</i> can be used to reference method that takes a string as input and returns nothing.</p>
<p>We use this delegate to call two methods, the first prints the string to the console, and the second one prints it to a file:</p>
<pre class="prettyprint notranslate tryit">
using System;
using System.IO;

namespace DelegateAppl
{
   class PrintString
   {
      static FileStream fs;
      static StreamWriter sw;
      
      // delegate declaration
      public delegate void printString(string s);

      // this method prints to the console
      public static void WriteToScreen(string str)
      {
         Console.WriteLine("The String is: {0}", str);
      }
      
      //this method prints to a file
      public static void WriteToFile(string s)
      {
         fs = new FileStream("c:\\message.txt",
         FileMode.Append, FileAccess.Write);
         sw = new StreamWriter(fs);
         sw.WriteLine(s);
         sw.Flush();
         sw.Close();
         fs.Close();
      }
      
      // this method takes the delegate as parameter and uses it to
      // call the methods as required
      public static void sendString(printString ps)
      {
         ps("Hello World");
      }
      static void Main(string[] args)
      {
         printString ps1 = new printString(WriteToScreen);
         printString ps2 = new printString(WriteToFile);
         sendString(ps1);
         sendString(ps2);
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
The String is: Hello World
</pre>

<title>C# - Events</title>

<h1>C# - Events</h1>

<p><b>Events</b> are user actions such as key press, clicks, mouse movements, etc., or some occurrence such as system generated notifications. Applications need to respond to events when they occur. For example, interrupts. Events are used for inter-process communication.</p>

<h2>Using Delegates with Events</h2>

<p>The events are declared and raised in a class and associated with the event handlers using delegates within the same class or some other class. The class containing the event is used to publish the event. This is called the <b>publisher</b> class. Some other class that accepts this event is called the <b>subscriber </b> class. Events use the <b>publisher-subscriber</b> model.</p>

<p>A <b>publisher</b> is an object that contains the definition of the event and the delegate. The event-delegate association is also defined in this object. A publisher class object invokes the event and it is notified to other objects.</p>

<p>A <b>subscriber</b> is an object that accepts the event and provides an event handler. The delegate in the publisher class invokes the method (event handler) of the subscriber class.</p>

<h2>Declaring Events</h2>

<p>To declare an event inside a class, first a delegate type for the event must be declared. For example,</p>

<p>Next, the event itself is declared, using the <b>event</b> keyword:</p>

<p>The preceding code defines a delegate named <i>BoilerLogHandler</i> and an event named <i>BoilerEventLog</i>, which invokes the delegate when it is raised.</p>

<h2>Example</h2>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
public delegate string MyDel(string str);
</pre>
<p>Next, the event itself is declared, using the <b>event</b> keyword:</p>
<pre class="prettyprint notranslate">
event MyDel MyEvent;
</pre>
<p>The preceding code defines a delegate named <i>BoilerLogHandler</i> and an event named <i>BoilerEventLog</i>, which invokes the delegate when it is raised.</p>
<h2>Example</h2>
<pre class="prettyprint notranslate tryit">
using System;

namespace SampleApp {
   public delegate string MyDel(string str);
	
   class EventProgram {
      event MyDel MyEvent;
		
      public EventProgram() {
         this.MyEvent += new MyDel(this.WelcomeUser);
      }
		
      public string WelcomeUser(string username) {
         return "Welcome " + username;
      }
		
      static void Main(string[] args) {
         EventProgram obj1 = new EventProgram();
         string result = obj1.MyEvent("Tutorials Point");
         Console.WriteLine(result);
      }

   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Welcome Tutorials Point
</pre>

<title>C# - Collections</title>

<h1>C# - Collections</h1>

<p>Collection classes are specialized classes for data storage and retrieval. These classes provide support for stacks, queues, lists, and hash tables. Most collection classes implement the same interfaces.</p>

<p>Collection classes serve various purposes, such as allocating memory dynamically to elements and accessing a list of items on the basis of an index etc. These classes create collections of objects of the Object class, which is the base class for all data types in C#.</p>

<h2>Various Collection Classes and Their Usage</h2>

<p>The following are the various commonly used classes of the <b>System.Collection</b> namespace. Click the following links to check their detail.</p>

<p><a href="/csharp/csharp_arraylist.htm" title="C# ArrayList">ArrayList</a></p>

<p>It represents ordered collection of an object that can be <b>indexed</b> individually.</p>

<p>It is basically an alternative to an array. However, unlike array you can add and remove items from a list at a specified position using an <b>index</b> and the array resizes itself automatically. It also allows dynamic memory allocation, adding, searching and sorting items in the list.</p>

<p><a href="/csharp/csharp_hashtable.htm" title="C# Hashtable">Hashtable</a></p>

<p>It uses a <b>key</b> to access the elements in the collection.</p>

<p>A hash table is used when you need to access elements by using key, and you can identify a useful key value. Each item in the hash table has a <b>key/value</b> pair. The key is used to access the items in the collection.</p>

<p><a href="/csharp/csharp_sortedlist.htm" title="C# SortedList">SortedList</a></p>

<p>It uses a <b>key</b> as well as an <b>index</b> to access the items in a list.</p>

<p>A sorted list is a combination of an array and a hash table. It contains a list of items that can be accessed using a key or an index. If you access items using an index, it is an ArrayList, and if you access items using a key , it is a Hashtable. The collection of items is always sorted by the key value.</p>

<p><a href="/csharp/csharp_stack.htm" title="C# Stack">Stack</a></p>

<p>It represents a <b>last-in, first out</b> collection of object.</p>

<p>It is used when you need a last-in, first-out access of items. When you add an item in the list, it is called <b>pushing</b> the item and when you remove it, it is called <b>popping</b> the item.</p>

<p><a href="/csharp/csharp_queue.htm" title="C# Queue">Queue</a></td></p>

<p>It represents a <b>first-in, first out</b> collection of object.</p>

<p>It is used when you need a first-in, first-out access of items. When you add an item in the list, it is called <b>enqueue</b> and when you remove an item, it is called <b>deque</b>.</p>

<p><a href="/csharp/csharp_bitarray.htm" title="C# BitArray">BitArray</a></p>

<p>It represents an array of the <b>binary representation</b> using the values 1 and 0.</p>

<p>It is used when you need to store the bits but do not know the number of bits in advance. You can access items from the BitArray collection by using an <b>integer index</b>, which starts from zero.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>C# - Generics</title>

<h1>C# - Generics</h1>

<p><b>Generics</b> allow you to delay the specification of the data type of programming elements in a class or a method, until it is actually used in the program. In other words, generics allow you to write a class or method that can work with any data type.</p>

<p>You write the specifications for the class or the method, with substitute parameters for data types. When the compiler encounters a constructor for the class or a function call for the method, it generates code to handle the specific data type. A simple example would help understanding the concept:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Features of Generics</h2>

<p>Generics is a technique that enriches your programs in the following ways:</p>

<p>It helps you to maximize code reuse, type safety, and performance.</p>

<p>You can create generic collection classes. The .NET Framework class library contains several new generic collection classes in the <i>System.Collections.Generic</i> namespace. You may use these generic collection classes instead of the collection classes in the <i>System.Collections</i> namespace.</p>

<p>You can create your own generic interfaces, classes, methods, events, and delegates.</p>

<p>You may create generic classes constrained to enable access to methods on particular data types.</p>

<p>You may get information on the types used in a generic data type at run-time by means of reflection.</p>

<h2>Generic Methods</h2>

<p>In the previous example, we have used a generic class; we can declare a generic method with a type parameter. The following program illustrates the concept:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Generic Delegates</h2>

<p>You can define a generic delegate with type parameters. For example:</p>

<p>The following example shows use of this delegate:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate tryit">
using System;
using System.Collections.Generic;

namespace GenericApplication
{
   public class MyGenericArray&lt;T&gt;
   {
      private T[] array;
      public MyGenericArray(int size)
      {
         array = new T[size + 1];
      }
      
      public T getItem(int index)
      {
         return array[index];
      }
      
      public void setItem(int index, T value)
      {
         array[index] = value;
      }
   }
   
   class Tester
   {
      static void Main(string[] args)
      {
         
         //declaring an int array
         MyGenericArray&lt;int&gt; intArray = new MyGenericArray&lt;int&gt;(5);
         
         //setting values
         for (int c = 0; c &lt; 5; c++)
         {
            intArray.setItem(c, c*5);
         }
         
         //retrieving the values
         for (int c = 0; c &lt; 5; c++)
         {
            Console.Write(intArray.getItem(c) + " ");
         }
         
         Console.WriteLine();
         
         //declaring a character array
         MyGenericArray&lt;char&gt; charArray = new MyGenericArray&lt;char&gt;(5);
         
         //setting values
         for (int c = 0; c &lt; 5; c++)
         {
            charArray.setItem(c, (char)(c+97));
         }
         
         //retrieving the values
         for (int c = 0; c&lt; 5; c++)
         {
            Console.Write(charArray.getItem(c) + " ");
         }
         Console.WriteLine();
         
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
0 5 10 15 20
a b c d e
</pre>
<h2>Features of Generics</h2> 
<p>Generics is a technique that enriches your programs in the following ways:</p>
<ul class="list">
<li><p>It helps you to maximize code reuse, type safety, and performance.</p></li>
<li><p>You can create generic collection classes. The .NET Framework class library contains several new generic collection classes in the <i>System.Collections.Generic</i> namespace. You may use these generic collection classes instead of the collection classes in the <i>System.Collections</i> namespace.</p></li>
<li><p>You can create your own generic interfaces, classes, methods, events, and delegates.</p></li>
<li><p>You may create generic classes constrained to enable access to methods on particular data types.</p></li>
<li><p>You may get information on the types used in a generic data type at run-time by means of reflection.</p></li>
</ul>
<h2>Generic Methods</h2>
<p>In the previous example, we have used a generic class; we can declare a generic method with a type parameter. The following program illustrates the concept:</p>
<pre class="prettyprint notranslate tryit">
using System;
using System.Collections.Generic;

namespace GenericMethodAppl
{
   class Program
   {
      static void Swap&lt;T&gt;(ref T lhs, ref T rhs)
      {
         T temp;
         temp = lhs;
         lhs = rhs;
         rhs = temp;
      }
      static void Main(string[] args)
      {
         int a, b;
         char c, d;
         a = 10;
         b = 20;
         c = 'I';
         d = 'V';
         
         //display values before swap:
         Console.WriteLine("Int values before calling swap:");
         Console.WriteLine("a = {0}, b = {1}", a, b);
         Console.WriteLine("Char values before calling swap:");
         Console.WriteLine("c = {0}, d = {1}", c, d);
         
         //call swap
         Swap&lt;int&gt;(ref a, ref b);
         Swap&lt;char&gt;(ref c, ref d);
         
         //display values after swap:
         Console.WriteLine("Int values after calling swap:");
         Console.WriteLine("a = {0}, b = {1}", a, b);
         Console.WriteLine("Char values after calling swap:");
         Console.WriteLine("c = {0}, d = {1}", c, d);
         
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Int values before calling swap:
a = 10, b = 20
Char values before calling swap:
c = I, d = V
Int values after calling swap:
a = 20, b = 10
Char values after calling swap:
c = V, d = I
</pre>
<h2>Generic Delegates</h2>
<p>You can define a generic delegate with type parameters. For example:</p>
<pre class="prettyprint notranslate">
delegate T NumberChanger&lt;T&gt;(T n);
</pre>
<p>The following example shows use of this delegate:</p>
<pre class="prettyprint notranslate tryit">
using System;
using System.Collections.Generic;

delegate T NumberChanger&lt;T&gt;(T n);
namespace GenericDelegateAppl
{
   class TestDelegate
   {
      static int num = 10;
      public static int AddNum(int p)
      {
         num += p;
         return num;
      }
      
      public static int MultNum(int q)
      {
         num *= q;
         return num;
      }
      public static int getNum()
      {
         return num;
      }
      
      static void Main(string[] args)
      {
         //create delegate instances
         NumberChanger&lt;int&gt; nc1 = new NumberChanger&lt;int&gt;(AddNum);
         NumberChanger&lt;int&gt; nc2 = new NumberChanger&lt;int&gt;(MultNum);
         
         //calling the methods using the delegate objects
         nc1(25);
         Console.WriteLine("Value of Num: {0}", getNum());
         nc2(5);
         Console.WriteLine("Value of Num: {0}", getNum());
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Value of Num: 35
Value of Num: 175
</pre>

<title>C# - Anonymous Methods</title>

<h1>C# - Anonymous Methods</h1>

<p>We discussed that delegates are used to reference any methods that has the same signature as that of the delegate. In other words, you can call a method that can be referenced by a delegate using that delegate object.</p>

<p><b>Anonymous methods</b> provide a technique to pass a code block as a delegate parameter. Anonymous methods are the methods without a name, just the body.</p>

<p>You need not specify the return type in an anonymous method; it is inferred from the return statement inside the method body.</p>

<h2>Writing an Anonymous Method</h2>

<p>Anonymous methods are declared with the creation of the delegate instance, with a <b>delegate</b> keyword. For example,</p>

<p>The code block <i>Console.WriteLine("Anonymous Method: {0}", x);</i> is the body of the anonymous method.</p>

<p>The delegate could be called both with anonymous methods as well as named methods in the same way, i.e., by passing the method parameters to the delegate object.</p>

<p>For example,</p>

<h2>Example</h2>

<p>The following example demonstrates the concept:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
delegate void NumberChanger(int n);
...
NumberChanger nc = delegate(int x)
{
   Console.WriteLine("Anonymous Method: {0}", x);
};
</pre>
<p>The code block <i>Console.WriteLine("Anonymous Method: {0}", x);</i> is the body of the anonymous method.</p>
<p>The delegate could be called both with anonymous methods as well as named methods in the same way, i.e., by passing the method parameters to the delegate object.</p>
<p>For example,</p>
<pre class="prettyprint notranslate">
nc(10);
</pre>
<h2>Example</h2>
<p>The following example demonstrates the concept:</p>
<pre class="prettyprint notranslate tryit">
using System;

delegate void NumberChanger(int n);
namespace DelegateAppl
{
   class TestDelegate
   {
      static int num = 10;
      public static void AddNum(int p)
      {
         num += p;
         Console.WriteLine("Named Method: {0}", num);
      }
      
      public static void MultNum(int q)
      {
         num *= q;
         Console.WriteLine("Named Method: {0}", num);
      }
      
      public static int getNum()
      {
         return num;
      }
      static void Main(string[] args)
      {
         //create delegate instances using anonymous method
         NumberChanger nc = delegate(int x)
         {
            Console.WriteLine("Anonymous Method: {0}", x);
         };
         
         //calling the delegate using the anonymous method 
         nc(10);
         
         //instantiating the delegate using the named methods 
         nc =  new NumberChanger(AddNum);
         
         //calling the delegate using the named methods 
         nc(5);
         
         //instantiating the delegate using another named methods 
         nc =  new NumberChanger(MultNum);
         
         //calling the delegate using the named methods 
         nc(2);
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Anonymous Method: 10
Named Method: 15
Named Method: 30
</pre>

<title>C# - Unsafe Codes</title>

<h1>C# - Unsafe Codes</h1>

<p>C# allows using pointer variables in a function of code block when it is marked by the <b>unsafe</b> modifier. The <b>unsafe code</b> or the unmanaged code is a code block that uses a <b>pointer</b> variable.</p>

<p><b>Note:</b> To execute the programs mentioned in this chapter at <a target="blank" href="http://www.tutorialspoint.com/compile_csharp_online.php">codingground</a>, please set compilation option in <i>Project &gt;&gt; Compile Options  &gt;&gt; Compilation Command</i> to</p> <p style="text-align:center"><code>mcs *.cs -out:main.exe -unsafe"</code></p>

<h2>Pointers</h2>

<p>A <b>pointer</b> is a variable whose value is the address of another variable i.e., the direct address of the memory location. similar to any variable or constant, you must declare a pointer before you can use it to store any variable address.</p>

<p>The general form of a pointer declaration is:</p>

<p>Following are valid pointer declarations:</p>

<p>The following example illustrates use of pointers in C#, using the unsafe modifier:</p>

<p>When the above code wass compiled and executed, it produces the following result:</p>

<p>Instead of declaring an entire method as unsafe, you can also declare a part of the code as unsafe. The example in the following section shows this.</p>

<h2>Retrieving the Data Value Using a Pointer</h2>

<p>You can retrieve the data stored at the located referenced by the pointer variable, using the <b>ToString()</b> method. The following example demonstrates this:</p>

<p>When the above code was compiled and executed, it produces the following result:</p>

<h2>Passing Pointers as Parameters to Methods</h2>

<p>You can pass a pointer variable to a method as parameter. The following example illustrates this:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Accessing Array Elements Using a Pointer</h2>

<p>In C#, an array name and a pointer to a data type same as the array data, are not the same variable type. For example, int *p and int[] p, are not same type. You can increment the pointer variable p because it is not fixed in memory but an array address is fixed in memory, and you can't increment that.</p>

<p>Therefore, if you need to access an array data using a pointer variable, as we traditionally do in C, or C++ ( please check: <a href="/cprogramming/c_pointers.htm">C Pointers</a>), you need to fix the pointer using the <b>fixed</b> keyword.</p>

<p>The following example demonstrates this:</p>

<p>When the above code was compiled and executed, it produces the following result:</p>

<h2>Compiling Unsafe Code</h2>

<p>For compiling unsafe code, you have to specify the <b>/unsafe</b> command-line switch with command-line compiler.</p>

<p>For example, to compile a program named prog1.cs containing unsafe code, from command line, give the command:</p>

<p>If you are using Visual Studio IDE then you need to enable use of unsafe code in the project properties.</p>

<p>To do this:</p>

<p>Open <b>project properties</b> by double clicking the properties node in the Solution Explorer.</p>

<p>Click on the <b>Build</b> tab.</p>

<p>Select the option "<b>Allow unsafe code</b>".</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
type *var-name;
</pre>
<p>Following are valid pointer declarations:</p>
<pre class="prettyprint notranslate">
int    *ip;    /* pointer to an integer */
double *dp;    /* pointer to a double */
float  *fp;    /* pointer to a float */
char   *ch     /* pointer to a character */
</pre>
<p>The following example illustrates use of pointers in C#, using the unsafe modifier:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace UnsafeCodeApplication
{
   class Program
   {
      static unsafe void Main(string[] args)
      {
         int var = 20;
         int* p = &var;
         Console.WriteLine("Data is: {0} ",  var);
         Console.WriteLine("Address is: {0}",  (int)p);
         Console.ReadKey();
      }
   }
}
</pre>

<p>When the above code wass compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Data is: 20
Address is: 99215364
</pre>
<p>Instead of declaring an entire method as unsafe, you can also declare a part of the code as unsafe. The example in the following section shows this.</p>
<h2>Retrieving the Data Value Using a Pointer</h2>
<p>You can retrieve the data stored at the located referenced by the pointer variable, using the <b>ToString()</b> method. The following example demonstrates this:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace UnsafeCodeApplication
{
   class Program
   {
      public static void Main()
      {
         unsafe
         {
            int var = 20;
            int* p = &var;
            Console.WriteLine("Data is: {0} " , var);
            Console.WriteLine("Data is: {0} " , p->ToString());
            Console.WriteLine("Address is: {0} " , (int)p);
         }
         
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code was compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Data is: 20
Data is: 20
Address is: 77128984
</pre>
<h2>Passing Pointers as Parameters to Methods</h2>
<p>You can pass a pointer variable to a method as parameter. The following example illustrates this:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace UnsafeCodeApplication
{
   class TestPointer
   {
      public unsafe void swap(int* p, int *q)
      {
         int temp = *p;
         *p = *q;
         *q = temp;
      }
      
      public unsafe static void Main()
      {
         TestPointer p = new TestPointer();
         int var1 = 10;
         int var2 = 20;
         int* x = &var1;
         int* y = &var2;
         
         Console.WriteLine("Before Swap: var1:{0}, var2: {1}", var1, var2);
         p.swap(x, y);

         Console.WriteLine("After Swap: var1:{0}, var2: {1}", var1, var2);
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Before Swap: var1: 10, var2: 20
After Swap: var1: 20, var2: 10
</pre>
<h2>Accessing Array Elements Using a Pointer</h2>
<p>In C#, an array name and a pointer to a data type same as the array data, are not the same variable type. For example, int *p and int[] p, are not same type. You can increment the pointer variable p because it is not fixed in memory but an array address is fixed in memory, and you can't increment that.</p>
<p>Therefore, if you need to access an array data using a pointer variable, as we traditionally do in C, or C++ ( please check: <a href="/cprogramming/c_pointers.htm">C Pointers</a>), you need to fix the pointer using the <b>fixed</b> keyword.</p>
<p>The following example demonstrates this:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace UnsafeCodeApplication
{
   class TestPointer
   {
      public unsafe static void Main()
      {
         int[]  list = {10, 100, 200};
         fixed(int *ptr = list)
         
         /* let us have array address in pointer */
         for ( int i = 0; i &lt; 3; i++)
         {
            Console.WriteLine("Address of list[{0}]={1}",i,(int)(ptr + i));
            Console.WriteLine("Value of list[{0}]={1}", i, *(ptr + i));
         }
         
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code was compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Address of list[0] = 31627168
Value of list[0] = 10
Address of list[1] = 31627172
Value of list[1] = 100
Address of list[2] = 31627176
Value of list[2] = 200
</pre>
<h2>Compiling Unsafe Code</h2>
<p>For compiling unsafe code, you have to specify the <b>/unsafe</b> command-line switch with command-line compiler.</p>
<p>For example, to compile a program named prog1.cs containing unsafe code, from command line, give the command:</p>
<pre class="prettyprint notranslate">
csc /unsafe prog1.cs
</pre>

<title>C# - Multithreading</title>

<h1>C# - Multithreading</h1>

<p>A <b>thread</b> is defined as the execution path of a program. Each thread defines a unique flow of control. If your application involves complicated and time consuming operations, then it is often helpful to set different execution paths or threads, with each thread performing a particular job.</p>

<p>Threads are <b>lightweight processes</b>. One common example of use of thread is implementation of concurrent programming by modern operating systems. Use of threads saves wastage of CPU cycle and increase efficiency of an application.</p>

<p>So far we wrote the programs where a single thread runs as a single process which is the running instance of the application. However, this way the application can perform one job at a time. To make it execute more than one task at a time, it could be divided into smaller threads.</p>

<h2>Thread Life Cycle</h2>

<p>The life cycle of a thread starts when an object of the System.Threading.Thread class is created and ends when the thread is terminated or completes execution.</p>

<p>Following are the various states in the life cycle of a thread:</p>

<p><b>The Unstarted State</b>: It is the situation when the instance of the thread is created but the Start method is not called.</p>

<p><b>The Ready State</b>: It is the situation when the thread is ready to run and waiting CPU cycle.</p>

<p><b>The Not Runnable State</b>: A thread is not executable, when:</p>

<p><b>The Dead State</b>: It is the situation when the thread completes execution or is aborted.</p>

<h2>The Main Thread</h2>

<p>In C#, the <b>System.Threading.Thread</b> class is used for working with threads. It allows creating and accessing individual threads in a multithreaded application. The first thread to be executed in a process is called the <b>main</b> thread.</p>

<p>When a C# program starts execution, the main thread is automatically created. The threads created using the <b>Thread</b> class are called the child threads of the main thread. You can access a thread using the <b>CurrentThread</b> property of the Thread class.</p>

<p>The following program demonstrates main thread execution:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Properties and Methods of the Thread Class</h2>

<p>The following table shows some most commonly used <b>properties</b> of the <b>Thread</b> class:</p>

<p>The following table shows some of the most commonly used <b>methods</b> of the <b>Thread</b> class:</p>

<p>Raises a ThreadAbortException in the thread on which it is invoked, to begin the process of terminating the thread. Calling this method usually terminates the thread.</p>

<p>Allocates an unnamed data slot on all the threads. For better performance, use fields that are marked with the ThreadStaticAttribute attribute instead.</p>

<p>Allocates a named data slot on all threads. For better performance, use fields that are marked with the ThreadStaticAttribute attribute instead.</p>

<p>Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception might jeopardize other tasks in the application domain.</p>

<p>Notifies a host that managed code is about to execute instructions that depend on the identity of the current physical operating system thread.</p>

<p>Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception are limited to the current task.</p>

<p>Notifies a host that managed code has finished executing instructions that depend on the identity of the current physical operating system thread.</p>

<p>Eliminates the association between a name and a slot, for all threads in the process. For better performance, use fields that are marked with the ThreadStaticAttribute attribute instead.</p>

<p>Retrieves the value from the specified slot on the current thread, within the current thread's current domain. For better performance, use fields that are marked with the ThreadStaticAttribute attribute instead.</p>

<p>Returns the current domain in which the current thread is running.</p>

<p>Returns a unique application domain identifier</p>

<p>Looks up a named data slot. For better performance, use fields that are marked with the ThreadStaticAttribute attribute instead.</p>

<p>Interrupts a thread that is in the WaitSleepJoin thread state.</p>

<p>Blocks the calling thread until a thread terminates, while continuing to perform standard COM and SendMessage pumping. This method has different overloaded forms.</p>

<p>Synchronizes memory access as follows: The processor executing the current thread cannot reorder instructions in such a way that memory accesses prior to the call to MemoryBarrier execute after memory accesses that follow the call to MemoryBarrier.</p>

<p>Cancels an Abort requested for the current thread.</p>

<p>Sets the data in the specified slot on the currently running thread, for that thread's current domain. For better performance, use fields marked with the ThreadStaticAttribute attribute instead.</p>

<p>Starts a thread.</p>

<p>Makes the thread pause for a period of time.</p>

<p>Causes a thread to wait the number of times defined by the iterations parameter</p>

<p><b>public static byte VolatileRead(ref byte address)</b></p>

<p><b>public static double VolatileRead(ref double address)</b></p>

<p><b>public static int VolatileRead(ref int address)</b></p>

<p><b>public static Object VolatileRead(ref Object address)</b></p>

<p>Reads the value of a field. The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache. This method has different overloaded forms. Only some are given above.</p>

<p><b>public static void VolatileWrite(ref byte address,byte value)</b></p>

<p><b>public static void VolatileWrite(ref double address, double value)</b></p>

<p><b>public static void VolatileWrite(ref int address, int value)</b></p>

<p><b>public static void VolatileWrite(ref Object address, Object value)</b></p>

<p>Writes a value to a field immediately, so that the value is visible to all processors in the computer. This method has different overloaded forms. Only some are given above. </p>

<p>Causes the calling thread to yield execution to another thread that is ready to run on the current processor. The operating system selects the thread to yield to.</p>

<h2>Creating Threads</h2>

<p>Threads are created by extending the Thread class. The extended Thread class then calls the <b>Start()</b> method to begin the child thread execution.</p>

<p>The following program demonstrates the concept:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Managing Threads</h2>

<p>The Thread class provides various methods for managing threads.</p>

<p>The following example demonstrates the use of the <b>sleep()</b> method for making a thread pause for a specific period of time.</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Destroying Threads</h2>

<p>The <b>Abort()</b> method is used for destroying threads.</p>

<p>The runtime aborts the thread by throwing a <b>ThreadAbortException</b>. This exception cannot be caught, the control is sent to the <i>finally</i> block, if any.</p>

<p>The following program illustrates this:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate tryit">
using System;
using System.Threading;

namespace MultithreadingApplication
{
   class MainThreadProgram
   {
      static void Main(string[] args)
      {
         Thread th = Thread.CurrentThread;
         th.Name = "MainThread";
         Console.WriteLine("This is {0}", th.Name);
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
This is MainThread
</pre>
<h2>Properties and Methods of the Thread Class</h2>
<p>The following table shows some most commonly used <b>properties</b> of the <b>Thread</b> class:</p>
<table class="table table-bordered">
<tr>
<th style="width:25%;">Property</th>
<th>Description</th>
</tr>
<tr>
<td>CurrentContext</td>
<td>Gets the current context in which the thread is executing.</td>
</tr>
<tr>
<td>CurrentCulture</td>
<td>Gets or sets the culture for the current thread.</td>
</tr>
<tr>
<td>CurrentPrinciple</td>
<td>Gets or sets the thread's current principal (for role-based security).</td>
</tr>
<tr>
<td>CurrentThread</td>
<td>Gets the currently running thread.</td>
</tr>
<tr>
<td>CurrentUICulture</td>
<td>Gets or sets the current culture used by the Resource Manager to look up culture-specific resources at run-time.</td>
</tr>
<tr>
<td>ExecutionContext</td>
<td>Gets an ExecutionContext object that contains information about the various contexts of the current thread.</td>
</tr>
<tr>
<td>IsAlive</td>
<td>Gets a value indicating the execution status of the current thread.</td>
</tr>
<tr>
<td>IsBackground</td>
<td>Gets or sets a value indicating whether or not a thread is a background thread.</td>
</tr>
<tr>
<td>IsThreadPoolThread</td>
<td>Gets a value indicating whether or not a thread belongs to the managed thread pool.</td>
</tr>
<tr>
<td>ManagedThreadId</td>
<td>Gets a unique identifier for the current managed thread.</td>
</tr>
<tr>
<td>Name</td>
<td>Gets or sets the name of the thread.</td>
</tr>
<tr>
<td>Priority</td>
<td>Gets or sets a value indicating the scheduling priority of a thread.</td>
</tr>
<tr>
<td>ThreadState</td>
<td>Gets a value containing the states of the current thread.</td>
</tr>
</table>
<p>The following table shows some of the most commonly used <b>methods</b> of the <b>Thread</b> class:</p>
<table class="table table-bordered">
<tr>
<th style="width:5%;">Sr.No.</th>
<th>Methods</th>
</tr>
<tr>
<td>1</td>
<td>
<b>public void Abort()</b>
<p>Raises a ThreadAbortException in the thread on which it is invoked, to begin the process of terminating the thread. Calling this method usually terminates the thread.</p>
</td>
</tr>
<tr>
<td>2</td>
<td>
<b>public static LocalDataStoreSlot AllocateDataSlot()</b>
<p>Allocates an unnamed data slot on all the threads. For better performance, use fields that are marked with the ThreadStaticAttribute attribute instead.</p>
</td>
</tr>
<tr>
<td>3</td>
<td>
<b>public static LocalDataStoreSlot AllocateNamedDataSlot(string name)</b>
<p>Allocates a named data slot on all threads. For better performance, use fields that are marked with the ThreadStaticAttribute attribute instead.</p>
</td>
</tr>
<tr>
<td>4</td>
<td>
<b>public static void BeginCriticalRegion()</b>
<p>Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception might jeopardize other tasks in the application domain.</p>
</td>
</tr>
<tr>
<td>5</td>
<td>
<b>public static void BeginThreadAffinity()</b>
<p>Notifies a host that managed code is about to execute instructions that depend on the identity of the current physical operating system thread.</p>
</td>
</tr>
<tr>
<td>6</td>
<td>
<b>public static void EndCriticalRegion()</b>
<p>Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception are limited to the current task.</p>
</td>
</tr>
<tr>
<td>7</td>
<td>
<b>public static void EndThreadAffinity()</b>
<p>Notifies a host that managed code has finished executing instructions that depend on the identity of the current physical operating system thread.</p>
</td>
</tr>
<tr>
<td>8</td>
<td>
<b>public static void FreeNamedDataSlot(string name)</b>
<p>Eliminates the association between a name and a slot, for all threads in the process. For better performance, use fields that are marked with the ThreadStaticAttribute attribute instead.</p>
</td>
</tr>
<tr>
<td>9</td>
<td>
<b>public static Object GetData(LocalDataStoreSlot slot)</b>
<p>Retrieves the value from the specified slot on the current thread, within the current thread's current domain. For better performance, use fields that are marked with the ThreadStaticAttribute attribute instead.</p>
</td>
</tr>
<tr>
<td>10</td>
<td>
<b>public static AppDomain GetDomain()</b>
<p>Returns the current domain in which the current thread is running.</p>
</td>
</tr>
<tr>
<td>11</td>
<td>
<b>public static AppDomain GetDomainID()</b>
<p>Returns a unique application domain identifier</p>
</td>
</tr>
<tr>
<td>12</td>
<td>
<b>public static LocalDataStoreSlot GetNamedDataSlot(string name)</b>
<p>Looks up a named data slot. For better performance, use fields that are marked with the ThreadStaticAttribute attribute instead.</p>
</td>
</tr>
<tr>
<td>13</td>
<td>
<b>public void Interrupt()</b>
<p>Interrupts a thread that is in the WaitSleepJoin thread state.</p>
</td>
</tr>
<tr>
<td>14</td>
<td>
<b>public void Join()</b>
<p>Blocks the calling thread until a thread terminates, while continuing to perform standard COM and SendMessage pumping. This method has different overloaded forms.</p>
</td>
</tr>
<tr>
<td>15</td>
<td>
<b>public static void MemoryBarrier()</b>
<p>Synchronizes memory access as follows: The processor executing the current thread cannot reorder instructions in such a way that memory accesses prior to the call to MemoryBarrier execute after memory accesses that follow the call to MemoryBarrier.</p>
</td>
</tr>
<tr>
<td>16</td>
<td>
<b>public static void ResetAbort()</b>
<p>Cancels an Abort requested for the current thread.</p>
</td>
</tr>
<tr>
<td>17</td>
<td>
<b>public static void SetData(LocalDataStoreSlot slot, Object data)</b>
<p>Sets the data in the specified slot on the currently running thread, for that thread's current domain. For better performance, use fields marked with the ThreadStaticAttribute attribute instead.</p>
</td>
</tr>
<tr>
<td>18</td>
<td>
<b>public void Start()</b>
<p>Starts a thread.</p>
</td>
</tr>
<tr>
<td>19</td>
<td>
<b>public static void Sleep(int millisecondsTimeout)</b>
<p>Makes the thread pause for a period of time.</p>
</td>
</tr>
<tr>
<td>20</td>
<td>
<b>public static void SpinWait(int iterations)</b>
<p>Causes a thread to wait the number of times defined by the iterations parameter</p>
</td>
</tr>
<tr>
<td>21</td>
<td>
<p><b>public static byte VolatileRead(ref byte address)</b></p>
<p><b>public static double VolatileRead(ref double address)</b></p>
<p><b>public static int VolatileRead(ref int address)</b></p>
<p><b>public static Object VolatileRead(ref Object address)</b></p>
<p>Reads the value of a field. The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache. This method has different overloaded forms. Only some are given above.</p>
</td>
</tr>
<tr>
<td>22</td>
<td>
<p><b>public static void VolatileWrite(ref byte address,byte value)</b></p>
<p><b>public static void VolatileWrite(ref double address, double value)</b></p>
<p><b>public static void VolatileWrite(ref int address, int value)</b></p>
<p><b>public static void VolatileWrite(ref Object address, Object value)</b></p>
<p>Writes a value to a field immediately, so that the value is visible to all processors in the computer. This method has different overloaded forms. Only some are given above. </p></td>
</tr>
<tr>
<td>23</td>
<td>
<b>public static bool Yield()</b>
<p>Causes the calling thread to yield execution to another thread that is ready to run on the current processor. The operating system selects the thread to yield to.</p>
</td>
</tr>
</table>
<h2>Creating Threads</h2>
<p>Threads are created by extending the Thread class. The extended Thread class then calls the <b>Start()</b> method to begin the child thread execution.</p>
<p>The following program demonstrates the concept:</p>
<pre class="prettyprint notranslate tryit">
using System;
using System.Threading;

namespace MultithreadingApplication
{
   class ThreadCreationProgram
   {
      public static void CallToChildThread()
      {
         Console.WriteLine("Child thread starts");
      }
      
      static void Main(string[] args)
      {
         ThreadStart childref = new ThreadStart(CallToChildThread);
         Console.WriteLine("In Main: Creating the Child thread");
         Thread childThread = new Thread(childref);
         childThread.Start();
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
In Main: Creating the Child thread
Child thread starts
</pre>
<h2>Managing Threads</h2>
<p>The Thread class provides various methods for managing threads.</p>
<p>The following example demonstrates the use of the <b>sleep()</b> method for making a thread pause for a specific period of time.</p>
<pre class="prettyprint notranslate tryit">
using System;
using System.Threading;

namespace MultithreadingApplication
{
   class ThreadCreationProgram
   {
      public static void CallToChildThread()
      {
         Console.WriteLine("Child thread starts");
         
         // the thread is paused for 5000 milliseconds
         int sleepfor = 5000; 
         
         Console.WriteLine("Child Thread Paused for {0} seconds", sleepfor / 1000);
         Thread.Sleep(sleepfor);
         Console.WriteLine("Child thread resumes");
      }
      
      static void Main(string[] args)
      {
         ThreadStart childref = new ThreadStart(CallToChildThread);
         Console.WriteLine("In Main: Creating the Child thread");
         Thread childThread = new Thread(childref);
         childThread.Start();
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
In Main: Creating the Child thread
Child thread starts
Child Thread Paused for 5 seconds
Child thread resumes
</pre>
<h2>Destroying Threads</h2>
<p>The <b>Abort()</b> method is used for destroying threads.</p>
<p>The runtime aborts the thread by throwing a <b>ThreadAbortException</b>. This exception cannot be caught, the control is sent to the <i>finally</i> block, if any.</p>
<p>The following program illustrates this:</p>
<pre class="prettyprint notranslate tryit">
using System;
using System.Threading;

namespace MultithreadingApplication
{
   class ThreadCreationProgram
   {
      public static void CallToChildThread()
      {
         try
         {
            Console.WriteLine("Child thread starts");
            
            // do some work, like counting to 10
            for (int counter = 0; counter &lt;= 10; counter++)
            {
               Thread.Sleep(500);
               Console.WriteLine(counter);
            }
            
            Console.WriteLine("Child Thread Completed");
         }
         
         catch (ThreadAbortException e)
         {
            Console.WriteLine("Thread Abort Exception");
         }
         finally
         {
            Console.WriteLine("Couldn't catch the Thread Exception");
         }
      }
      
      static void Main(string[] args)
      {
         ThreadStart childref = new ThreadStart(CallToChildThread);
         Console.WriteLine("In Main: Creating the Child thread");
         Thread childThread = new Thread(childref);
         childThread.Start();
         
         //stop the main thread for some time
         Thread.Sleep(2000);
         
         //now abort the child
         Console.WriteLine("In Main: Aborting the Child thread");
         
         childThread.Abort();
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
In Main: Creating the Child thread
Child thread starts
0
1
2
In Main: Aborting the Child thread
Thread Abort Exception
Couldn't catch the Thread Exception 
</pre>

<title>C# Questions and Answers - TutorialsPoing</title>

<h1>C# Questions and Answers</h1>

<p><b>C# Questions and Answers</b> has been designed with a special intention of helping students and professionals preparing for various <b>Certification Exams</b> and <b>Job Interviews</b>. This section provides a useful collection of sample Interview Questions and  Multiple Choice Questions (MCQs) and their answers with appropriate explanations.</p>

<p>This section provides a huge collection of C# Interview Questions with their answers hidden in a box to challenge you to have a go at them before discovering the correct answer.</p>

<p>This section provides a great collection of C# Multiple Choice Questions (MCQs) on a single page along with their correct answers and explanation. If you select the right option, it turns green; else red.</p>

<p>If you are preparing to appear for a Java and C# related certification exam, then this section is a must for you. This section simulates a real online test along with a given timer which challenges you to complete the test within a given time-frame. Finally you can check your overall test score and how you fared among millions of other candidates who attended this online test.</p>

<p>This section provides various mock tests that you can download at your local machine and solve offline. Every mock test is supplied with a mock test key to let you verify the final score and grade yourself.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>C# - Quick Guide</title>

<h1>C# - Quick Guide</h1>

<h1>C# - Overview</h1>

<p>C# is a modern, general-purpose, object-oriented programming language developed by Microsoft and approved by European Computer Manufacturers Association (ECMA) and International Standards Organization (ISO).</p>

<p>C# was developed by Anders Hejlsberg and his team during the development of .Net Framework.</p>

<p>C# is designed for Common Language Infrastructure (CLI), which consists of the executable code and runtime environment that allows use of various high-level languages on different computer platforms and architectures.</p>

<p>The following reasons make C# a widely used professional language:</p>

<h2>Strong Programming Features of C#</h2>

<p>Although C# constructs closely follow traditional high-level languages, C and C++ and being an object-oriented programming language. It has strong resemblance with Java, it has numerous strong programming features that make it endearing to a number of programmers worldwide.</p>

<p>Following is the list of few important features of C#:</p>

<h1>C# - Environment</h1>

<p>In this chapter, we will discuss the tools required for creating C# programming.  We have already mentioned that C# is part of .Net framework and is used for writing .Net applications. Therefore, before discussing the available tools for running a C# program, let us understand how C# relates to the .Net framework.</p>

<h2>The .Net Framework</h2>

<p>The .Net framework is a revolutionary platform that helps you to write the following types of applications:</p>

<p>The .Net framework applications are multi-platform applications. The framework has been designed in such a way that it can be used from any of the following languages: C#, C++, Visual Basic, Jscript, COBOL, etc. All these languages can access the framework as well as communicate with each other.</p>

<p>The .Net framework consists of an enormous library of codes used by the client languages such as C#. Following are some of the components of the .Net framework:</p>

<p>For the jobs each of these components perform, please see <a href="http://www.tutorialspoint.com/asp.net/asp.net_introduction.htm">ASP.Net - Introduction</a>, and for details of each component, please consult Microsoft's documentation.</p>

<h2>Integrated Development Environment (IDE) for C#</h2>

<p>Microsoft provides the following development tools for C# programming:</p>

<p>The last two are freely available from Microsoft official website. Using these tools, you can write all kinds of C# programs from simple command-line applications to more complex applications. You can also write C# source code files using a basic text editor, like Notepad, and compile the code into assemblies using the command-line compiler, which is again a part of the .NET Framework.</p>

<p>Visual C# Express and Visual Web Developer Express edition are trimmed down versions of Visual Studio and has the same appearance. They retain most features of Visual Studio. In this tutorial, we have used Visual C# 2010 Express.</p>

<p>You can download it from <a target="_blank" rel="nofollow" href="http://www.microsoft.com/visualstudio/eng/downloads">Microsoft Visual Studio</a>. It gets installed automatically on your machine.</p>

<p>Note: You need an active internet connection for installing the express edition.</p>

<h2>Writing C# Programs on Linux or Mac OS</h2>

<p>Although the.NET Framework runs on the Windows operating system, there are some alternative versions that work on other operating systems. <b>Mono</b> is an open-source version of the .NET Framework which includes a C# compiler and runs on several operating systems, including various flavors of Linux and Mac OS. Kindly check <a target="_blank" rel="nofollow" href="http://www.go-mono.com/mono-downloads/download.html">Go Mono</a>.</p>

<p>The stated purpose of Mono is not only to be able to run Microsoft .NET applications cross-platform, but also to bring better development tools for Linux developers. Mono can be run on many operating systems including Android, BSD, iOS, Linux, OS X, Windows, Solaris, and UNIX.</p>

<h1>C# - Program Structure</h1>

<p>Before we study basic building blocks of the C# programming language, let us look at a bare minimum C# program structure so that we can take it as a reference in upcoming chapters.</p>

<h2>Creating Hello World Program</h2>

<p>A C# program consists of the following parts:</p>

<p>Let us look at a simple code that prints the words "Hello World":</p>

<p>When this code is compiled and executed, it produces the following result:</p>

<p>Let us look at the various parts of the given program:</p>

<p>The first line of the program <b>using System;</b> -  the <b>using</b> keyword is used to include the <b>System </b> namespace in the program. A program generally has multiple <b>using</b> statements.</p>

<p>The next line has the <b>namespace</b> declaration. A <b>namespace</b> is a collection of classes. The <i>HelloWorldApplication</i> namespace contains the class <i>HelloWorld</i>.</p>

<p>The next line has a <b>class</b> declaration, the class <i>HelloWorld</i> contains the data and method definitions that your program uses. Classes generally contain multiple methods. Methods define the behavior of the class. However, the <i>HelloWorld</i> class has only one method <b> Main</b>.</p>

<p>The next line defines the <b>Main</b> method, which is the <b>entry point</b> for all C# programs. The <b>Main </b> method states what the class does when executed.</p>

<p>The next line /*...*/ is ignored by the compiler and it is put to add <b> comments</b> in the program.</p>

<p><i>WriteLine</i> is a method of the <i>Console</i> class defined in the <i>System</i> namespace. This statement causes the message "Hello, World!" to be displayed on the screen.</p>

<p>The last line <b>Console.ReadKey();</b> is for the VS.NET Users. This makes the program wait for a key press and it prevents the screen from running and closing quickly when the program is launched from Visual Studio .NET.</p>

<p>It is worth to note the following points:</p>

<p>C# is case sensitive.</p>

<p>All statements and expression must end with a semicolon (;).</p>

<p>The program execution starts at the Main method.</p>

<p>Unlike Java, program file name could be different from the class name.</p>

<h2>Compiling and Executing the Program</h2>

<p>If you are using Visual Studio.Net for compiling and executing C# programs, take the following steps:</p>

<p>Start Visual Studio.</p>

<p>On the menu bar, choose File -&gt; New -&gt; Project.</p>

<p>Choose Visual C# from templates, and then choose Windows.</p>

<p>Choose Console Application.</p>

<p>Specify a name for your project and click OK button.</p>

<p>This creates a new project in Solution Explorer.</p>

<p>Write code in the Code Editor. </p>

<p>Click the Run button or press F5 key to execute the project. A Command Prompt window appears that contains the line Hello World.</p>

<p>You can compile a C# program by using the command-line instead of the Visual Studio IDE:</p>

<p>Open a text editor and add the above-mentioned code.</p>

<p>Save the file as <b>helloworld.cs</b></p>

<p>Open the command prompt tool and go to the directory where you saved the file.</p>

<p>Type <b>csc helloworld.cs</b> and press enter to compile your code.</p>

<p>If there are no errors in your code, the command prompt takes you to the next line and generates <b>helloworld.exe</b> executable file.</p>

<p>Type <b>helloworld</b> to execute your program.</p>

<p>You can see the output Hello World printed on the screen.</p>

<h1>C# - Basic Syntax</h1>

<p>C# is an object-oriented programming language. In Object-Oriented Programming methodology, a program consists of various objects that interact with each other by means of actions. The actions that an object may take are called methods. Objects of the same kind are said to have the same type or, are said to be in the same class.</p>

<p>For example, let us consider a Rectangle object. It has attributes such as length and width. Depending upon the design, it may need ways for accepting the values of these attributes, calculating the area, and displaying details.</p>

<p>Let us look at implementation of a Rectangle class and discuss C# basic syntax:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>The <i>using</i> Keyword</h2>

<p>The first statement in any C# program is</p>

<p>The <b>using</b> keyword is used for including the namespaces in the program. A program can include multiple using statements.</p>

<h2>The <i>class</i> Keyword</h2>

<p>The <b>class</b> keyword is used for declaring a class.</p>

<h2>Comments in C#</h2>

<p>Comments are used for explaining code. Compilers ignore the comment entries. The multiline comments in C# programs start with /* and terminates with the characters */ as shown below:</p>

<p>Single-line comments are indicated by the '//' symbol. For example,</p>

<h2>Member Variables</h2>

<p>Variables are attributes or data members of a class, used for storing data. In the preceding program, the <i>Rectangle</i> class has two member variables named <i>length</i> and <i>width</i>.</p>

<h2>Member Functions</h2>

<p>Functions are set of statements that perform a specific task. The member functions of a class are declared within the class. Our sample class Rectangle contains three member functions: <i> AcceptDetails</i>, <i>GetArea</i> and <i>Display</i>.</p>

<h2>Instantiating a Class</h2>

<p>In the preceding program, the class <i>ExecuteRectangle</i> contains the <i>Main()</i>  method and instantiates the <i>Rectangle</i> class.</p>

<h2>Identifiers</h2>

<p>An identifier is a name used to identify a class, variable, function, or any other user-defined item. The basic rules for naming classes in C# are as follows:</p>

<p>A name must begin with a letter that could be followed by a sequence of letters, digits (0 - 9) or underscore. The first character in an identifier cannot be a digit.</p>

<p>It must not contain any embedded space or symbol such as? - + ! @ # % ^ & * ( ) [ ] { } . ; : " ' / and \. However, an underscore ( _ ) can be used.</p>

<p>It should not be a C# keyword.</p>

<h2>C# Keywords</h2>

<p>Keywords are reserved words predefined to the C# compiler. These keywords cannot be used as identifiers. However, if you want to use these keywords as identifiers, you may prefix the keyword with the @ character.</p>

<p>In C#, some identifiers have special meaning in context of code, such as get and set are called contextual keywords.</p>

<p>The following table lists the reserved keywords and contextual keywords in C#:</p>

<h1>C# - Data Types</h1>

<p>The variables in C#, are categorized into the following types:</p>

<h2>Value Type</h2>

<p>Value type variables can be assigned a value directly. They are derived from the class <b> System.ValueType</b>.</p>

<p>The value types directly contain data. Some examples are <b>int, char, and float</b>, which stores numbers, alphabets, and floating point numbers, respectively. When you declare an <b>int</b> type, the system allocates memory to store the value.</p>

<p>The following table lists the available value types in C# 2010:</p>

<p>To get the exact size of a type or a variable on a particular platform, you can use the <b>sizeof</b> method. The expression <i>sizeof(type)</i> yields the storage size of the object or type in bytes. Following is an example to get the size of <i>int</i> type on any machine:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Reference Type</h2>

<p>The reference types do not contain the actual data stored in a variable, but they contain a reference to the variables.</p>

<p>In other words, they refer to a memory location. Using multiple variables, the reference types can refer to a memory location. If the data in the memory location is changed by one of the variables, the other variable automatically reflects this change in value. Example of <b>built-in</b> reference types are: <b>object</b>, <b>dynamic,</b> and <b>string</b>.</p>

<h3>Object Type</h3>

<p>The <b>Object Type</b> is the ultimate base class for all data types in C# Common Type System (CTS). Object is an alias for System.Object class. The object types can be assigned values of any other types, value types, reference types, predefined or user-defined types. However, before assigning values, it needs type conversion.</p>

<p>When a value type is converted to object type, it is called <b>boxing</b> and on the other hand, when an object type is converted to a value type, it is called <b>unboxing</b>.</p>

<h3>Dynamic Type</h3>

<p>You can store any type of value in the dynamic data type variable. Type checking for these types of variables takes place at run-time.</p>

<p>Syntax for declaring a dynamic type is:</p>

<p>For example,</p>

<p>Dynamic types are similar to object types except that type checking for object type variables takes place at compile time, whereas that for the dynamic type variables takes place at run time.</p>

<h3>String Type</h3>

<p>The <b>String Type</b> allows you to assign any string values to a variable. The string type is an alias for the System.String class. It is derived from object type. The value for a string type can be assigned using string literals in two forms: quoted and @quoted.</p>

<p>For example,</p>

<p>A @quoted string literal looks as follows:</p>

<p>The user-defined reference types are: class, interface, or delegate. We will discuss these types in later chapter.</p>

<h2>Pointer Type</h2>

<p>Pointer type variables store the memory address of another type. Pointers in C# have the same capabilities as the pointers in C or C++.</p>

<p>Syntax for declaring a pointer type is:</p>

<p>For example,</p>

<h1>C# - Type Conversion</h1>

<p>Type conversion is converting one type of data to another type. It is also known as Type Casting. In C#, type casting has two forms:</p>

<p><b>Implicit type conversion</b> - These conversions are performed by C# in a type-safe manner. For example, are conversions from smaller to larger integral types and conversions from derived classes to base classes.</p>

<p><b>Explicit type conversion</b> - These conversions are done explicitly by users using the pre-defined functions. Explicit conversions require a cast operator.</p>

<p>The following example shows an explicit type conversion:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>C# Type Conversion Methods</h2>

<p>C# provides the following built-in type conversion methods:</p>

<p>Converts a type to a Boolean value, where possible.</p>

<p>Converts a type to a byte.</p>

<p>Converts a type to a single Unicode character, where possible.</p>

<p>Converts a type (integer or string type) to date-time structures.</p>

<p>Converts a floating point or integer type to a decimal type.</p>

<p>Converts a type to a double type.</p>

<p>Converts a type to a 16-bit integer.</p>

<p>Converts a type to a 32-bit integer.</p>

<p>Converts a type to a 64-bit integer.</p>

<p>Converts a type to a signed byte type.</p>

<p>Converts a type to a small floating point number.</p>

<p>Converts a type to a string.</p>

<p>Converts a type to a specified type.</p>

<p>Converts a type to an unsigned int type.</p>

<p>Converts a type to an unsigned long type.</p>

<p>Converts a type to an unsigned big integer.</p>

<p>The following example converts various value types to string type:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>C# - Variables</h1>

<p>A variable is nothing but a name given to a storage area that our programs can manipulate. Each variable in C# has a specific type, which determines the size and layout of the variable's memory the range of values that can be stored within that memory and the set of operations that can be applied to the variable.</p>

<p>The basic value types provided in C# can be categorized as:</p>

<p>C# also allows defining other value types of variable such as <b>enum</b> and reference types of variables such as <b> class</b>, which we will cover in subsequent chapters.</p>

<h2>Defining Variables</h2>

<p>Syntax for variable definition in C# is:</p>

<p>Here, data_type must be a valid C# data type including char, int, float, double, or any user-defined data type, and variable_list may consist of one or more identifier names separated by commas.</p>

<p>Some valid variable definitions are shown here:</p>

<p>You can initialize a variable at the time of definition as:</p>

<h2>Initializing Variables</h2>

<p>Variables are initialized (assigned a value) with an equal sign followed by a constant expression. The general form of initialization is:</p>

<p>Variables can be initialized in their declaration. The initializer consists of an equal sign followed by a constant expression as:</p>

<p>Some examples are:</p>

<p>It is a good programming practice to initialize variables properly, otherwise sometimes program may produce unexpected result.</p>

<p>The following example uses various types of variables:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Accepting Values from User</h2>

<p>The <b>Console</b> class in the <b>System</b> namespace provides a function <b>ReadLine()</b> for accepting input from the user and store it into a variable.</p>

<p>For example,</p>

<p>The function <b>Convert.ToInt32()</b> converts the data entered by the user to int data type, because <b>Console.ReadLine()</b> accepts the data in string format.</p>

<h2>Lvalue and Rvalue Expressions in C#:</h2>

<p>There are two kinds of expressions in C#:</p>

<p><b>lvalue:</b> An expression that is an lvalue may appear as either the left-hand or right-hand side of an assignment.</p>

<p><b>rvalue:</b> An expression that is an rvalue may appear on the right- but not left-hand side of an assignment.</p>

<p>Variables are lvalues and hence they may appear on the left-hand side of an assignment. Numeric literals are rvalues and hence they may not be assigned and can not appear on the left-hand side. Following is a valid C# statement:</p>

<p>But following is not a valid statement and would generate compile-time error:</p>

<h1>C# - Constants and Literals</h1>

<p>The constants refer to fixed values that the program may not alter during its execution. These fixed values are also called literals. Constants can be of any of the basic data types like an integer constant, a floating constant, a character constant, or a string literal. There are also enumeration constants as well.</p>

<p>The constants are treated just like regular variables except that their values cannot be modified after their definition.</p>

<h2>Integer Literals</h2>

<p>An integer literal can be a decimal, octal, or hexadecimal constant. A prefix specifies the base or radix: 0x or 0X for hexadecimal, 0 for octal, and no prefix id for decimal.</p>

<p>An integer literal can also have a suffix that is a combination of U and L, for unsigned and long, respectively. The suffix can be uppercase or lowercase and can be in any order.</p>

<p>Here are some examples of integer literals:</p>

<p>Following are other examples of various types of Integer literals:</p>

<h2>Floating-point Literals</h2>

<p>A floating-point literal has an integer part, a decimal point, a fractional part, and an exponent part. You can represent floating point literals either in decimal form or exponential form.</p>

<p>Here are some examples of floating-point literals:</p>

<p>While representing in decimal form, you must include the decimal point, the exponent, or both; and while representing using exponential form you must include the integer part, the fractional part, or both. The signed exponent is introduced by e or E.</p>

<h2>Character Constants</h2>

<p>Character literals are enclosed in single quotes. For example, 'x' and can be stored in a simple variable of char type. A character literal can be a plain character (such as 'x'), an escape sequence (such as '\t'), or a universal character (such as '\u02C0').</p>

<p>There are certain characters in C# when they are preceded by a backslash. They have special meaning and they are used to represent like newline (\n) or tab (\t). Here, is a list of some of such escape sequence codes:</p>

<p>Following is the example to show few escape sequence characters:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>String Literals</h2>

<p>String literals or constants are enclosed in double quotes "" or with @"". A string contains characters that are similar to character literals: plain characters, escape sequences, and universal characters.</p>

<p>You can break a long line into multiple lines using string literals and separating the parts using whitespaces.</p>

<p>Here are some examples of string literals. All the three forms are identical strings.</p>

<h2>Defining Constants</h2>

<p>Constants are defined using the <b>const</b> keyword. Syntax for defining a constant is:</p>

<p>The following program demonstrates defining and using a constant in your program:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>C# - Operators</h1>

<p>An operator is a symbol that tells the compiler to perform specific mathematical or logical manipulations. C# has rich set of built-in operators and provides the following type of operators:</p>

<p>This tutorial explains the arithmetic, relational, logical, bitwise, assignment, and other operators one by one.</p>

<h2>Arithmetic Operators</h2>

<p>Following table shows all the arithmetic operators supported by C#. Assume variable <b>A</b> holds 10 and variable <b>B</b> holds 20 then:</p>

<p><a href="/csharp/csharp_arithmetic_operators.htm" title="Arithmetic Operators in C#">Show Examples</a></p>

<h2>Relational Operators</h2>

<p>Following table shows all the relational operators supported by C#. Assume variable <b>A</b> holds 10 and variable <b>B</b> holds 20, then:</p>

<p><a href="/csharp/csharp_relational_operators.htm" title="Relational Operators in C#">Show Examples</a></p>

<h2>Logical Operators</h2>

<p>Following table shows all the logical operators supported by C#. Assume variable <b>A</b> holds Boolean value true and variable <b>B</b> holds Boolean value false, then:</p>

<p><a href="/csharp/csharp_logical_operators.htm" title="Logical Operators in C#">Show Examples</a></p>

<h2>Bitwise Operators</h2>

<p>Bitwise operator works on bits and perform bit by bit operation. The truth tables for &amp;, |, and ^ are as follows:</p>

<p>Assume if A = 60; and B = 13; then in the binary format they are as follows:</p>

<p>A = 0011 1100</p>

<p>B = 0000 1101</p>

<p>-----------------</p>

<p>A&amp;B = 0000 1100</p>

<p>A|B = 0011 1101</p>

<p>A^B = 0011 0001</p>

<p>~A&nbsp; = 1100 0011</p>

<p>The Bitwise operators supported by C# are listed in the following table. Assume variable A holds 60 and variable B holds 13, then:</p>

<p><a href="/csharp/csharp_bitwise_operators.htm" title="Bitwise Operators in C#">Show Examples</a></p>

<h2>Assignment Operators</h2>

<p>There are following assignment operators supported by C#:</p>

<p><a href="/csharp/csharp_assignment_operators.htm" title="Assignment Operators in C#">Show Examples</a></p>

<h2>Miscellaneous Operators</h2>

<p>There are few other important operators including <b>sizeof, typeof</b> and <b>? :</b>  supported by C#.</p>

<p><a href="/csharp/csharp_misc_operators.htm" title="misc operators in C#">Show Examples</a></p>

<p>StringReader r = obj as StringReader;</p>

<h2>Operator Precedence in C#</h2>

<p>Operator precedence determines the grouping of terms in an expression. This affects evaluation of an expression. Certain operators have higher precedence than others; for example, the multiplication operator has higher precedence than the addition operator.</p>

<p>For example x = 7 + 3 * 2; here, x is assigned 13, not 20 because operator * has higher precedence than +, so the first evaluation takes place for 3*2 and then 7 is added into it.</p>

<p>Here, operators with the highest precedence appear at the top of the table, those with the lowest appear at the bottom. Within an expression, higher precedence operators are evaluated first.</p>

<p><a href="/csharp/csharp_operators_precedence.htm" title="Operators Precedence in C#">Show Examples</a></p>

<h1>C# - Decision Making</h1>

<p>Decision making structures requires the programmer to specify one or more conditions to be evaluated or tested by the program, along with a statement or statements to be executed if the condition is determined to be true, and optionally, other statements to be executed if the condition is determined to be false.</p>

<p>Following is the general form of a typical decision making structure found in most of the programming languages:</p>

<p>C# provides following types of decision making statements. Click the following links to check their detail.</p>

<p><a href="/csharp/if_statement_in_csharp.htm" title="if statement in C#">if statement</a></p>

<p><a href="/csharp/if_else_statement_in_csharp.htm" title="if...else statement in C#">if...else statement</a></p>

<p><a href="/csharp/nested_if_statements_in_csharp.htm" title="nested if statements in C#">nested if statements</a></p>

<p><a href="/csharp/switch_statement_in_csharp.htm" title="switch statement in C#">switch statement</a></p>

<p><a href="/csharp/nested_switch_statements_in_csharp.htm" title="nested switch statements in C#">nested switch statements</a></p>

<h2>The ? : Operator:</h2>

<p>We have covered <b>conditional operator ? :</b> in previous chapter which can be used to replace <b>if...else</b> statements. It has the following general form:</p>

<p>Where Exp1, Exp2, and Exp3 are expressions. Notice the use and placement of the colon.</p>

<p>The value of a ? expression is determined as follows: Exp1 is evaluated. If it is true, then Exp2 is evaluated and becomes the value of the entire ? expression. If Exp1 is false, then Exp3 is evaluated and its value becomes the value of the expression.</p>

<h1>C# - Loops</h1>

<p>There may be a situation, when you need to execute a block of code several number of times. In general, the statements are executed sequentially: The first statement in a function is executed first, followed by the second, and so on.</p>

<p>Programming languages provide various control structures that allow for more complicated execution paths.</p>

<p>A loop statement allows us to execute a statement or a group of statements multiple times and following is the general form of a loop statement in most of the programming languages:</p>

<p>C# provides following types of loop to handle looping requirements. Click the following links to check their detail.</p>

<p><a href="/csharp/csharp_while_loop.htm" title="while loop in C#">while loop</a></p>

<p><a href="/csharp/csharp_for_loop.htm" title="for loop in C#">for loop</a></p>

<p><a href="/csharp/csharp_do_while_loop.htm" title="do...while loop in C#">do...while loop</a></p>

<p><a href="/csharp/csharp_nested_loops.htm" title="nested loops in C#">nested loops</a></p>

<h2>Loop Control Statements</h2>

<p>Loop control statements change execution from its normal sequence. When execution leaves a scope, all automatic objects that were created in that scope are destroyed.</p>

<p>C# provides the following control statements. Click the following links to check their details.</p>

<p><a href="/csharp/csharp_break_statement.htm" title="break statement in C#">break statement</a></p>

<p><a href="/csharp/csharp_continue_statement.htm" title="continue statement in C#">continue statement</a></p>

<h2>Infinite Loop</h2>

<p>A loop becomes infinite loop if a condition never becomes false. The <b>for</b> loop is traditionally used for this purpose. Since none of the three expressions that form the for loop are required, you can make an endless loop by leaving the conditional expression empty.</p>

<h3>Example</h3>

<p>When the conditional expression is absent, it is assumed to be true. You may have an initialization and increment expression, but programmers more commonly use the for(;;) construct to signify an infinite loop.</p>

<h1>C# - Encapsulation</h1>

<p><b>Encapsulation</b> is defined 'as the process of enclosing one or more items within a physical or logical package'. Encapsulation, in object oriented programming methodology, prevents access to implementation details. </p>

<p>Abstraction and encapsulation are related features in object oriented programming. Abstraction allows making relevant information visible and encapsulation enables a programmer to <i>implement the desired level of abstraction</i>.</p>

<p>Encapsulation is implemented by using <b>access specifiers</b>. An <b>access specifier</b> defines the scope and visibility of a class member. C# supports the following access specifiers:</p>

<h2>Public Access Specifier</h2>

<p>Public access specifier allows a class to expose its member variables and member functions to other functions and objects. Any public member can be accessed from outside the class.</p>

<p>The following example illustrates this:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>In the preceding example, the member variables length and width are declared <b>public</b>, so they can be accessed from the function Main() using an instance of the Rectangle class, named <b>r</b>.</p>

<p>The member function <i>Display()</i> and <i>GetArea()</i> can also access these variables directly without using any instance of the class.</p>

<p>The member functions <i>Display()</i> is also declared <b>public</b>, so it can also be accessed from <i>Main()</i> using an instance of the Rectangle class, named <b>r</b>. </p>

<h2>Private Access Specifier</h2>

<p>Private access specifier allows a class to hide its member variables and member functions from other functions and objects. Only functions of the same class can access its private members. Even an instance of a class cannot access its private members. </p>

<p>The following example illustrates this:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>In the preceding example, the member variables length and width are declared <b>private</b>, so they cannot be accessed from the function Main(). The member functions <i>AcceptDetails()</i> and <i>Display()</i> can access these variables. Since the member functions <i>AcceptDetails()</i> and <i>Display()</i> are declared <b>public</b>, they can be accessed from <i>Main()</i> using an instance of the Rectangle class, named <b>r</b>.</p>

<h2>Protected Access Specifier</h2>

<p>Protected access specifier allows a child class to access the member variables and member functions of its base class. This way it helps in implementing inheritance. We will discuss this in more details in the inheritance chapter.</p>

<h2>Internal Access Specifier</h2>

<p>Internal access specifier allows a class to expose its member variables and member functions to other functions and objects in the current assembly. In other words, any member with internal access specifier can be accessed from any class or method defined within the application in which the member is defined.</p>

<p>The following program illustrates this:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>In the preceding example, notice that the member function <i>GetArea()</i> is not declared with any access specifier. Then what would be the default access specifier of a class member if we don't mention any? It is <b>private</b>.</p>

<h2>Protected Internal Access Specifier</h2>

<p>The protected internal access specifier allows a class to hide its member variables and member functions from other class objects and functions, except a child class within the same application. This is also used while implementing inheritance.</p>

<h1>C# - Methods</h1>

<p>A method is a group of statements that together perform a task. Every C# program has at least one class with a method named Main.</p>

<p>To use a method, you need to:</p>

<h2>Defining Methods in C#</h2>

<p>When you define a method, you basically declare the elements of its structure. The syntax for defining a method in C# is as follows:</p>

<p>Following are the various elements of a method:</p>

<p><b>Access Specifier</b>: This determines the visibility of a variable or a method from another class.</p>

<p><b>Return type</b>: A method may return a value. The return type is the data type of the value the method returns. If the method is not returning any values, then the return type is <b>void</b>.</p>

<p><b>Method name</b>: Method name is a unique identifier and it is case sensitive. It cannot be same as any other identifier declared in the class.</p>

<p><b>Parameter list</b>: Enclosed between parentheses, the parameters are used to pass and receive data from a method. The parameter list refers to the type, order, and number of the parameters of a method. Parameters are optional; that is, a method may contain no parameters.</p>

<p><b>Method body</b>: This contains the set of instructions needed to complete the required activity.</p>

<h2>Example</h2>

<p>Following code snippet shows a function <i>FindMax</i> that takes two integer values and returns the larger of the two. It has public access specifier, so it can be accessed from outside the class using an instance of the class.</p>

<h2>Calling Methods in C#</h2>

<p>You can call a method using the name of the method. The following example illustrates this:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>You can also call public method from other classes by using the instance of the class. For example, the method <i>FindMax</i> belongs to the <i>NumberManipulator</i> class, you can call it from another class <i>Test</i>.</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Recursive Method Call</h2>

<p>A method can call itself. This is known as <b>recursion</b>. Following is an example that calculates factorial for a given number using a recursive function:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Passing Parameters to a Method</h2>

<p>When method with parameters is called, you need to pass the parameters to the method. There are three ways that parameters can be passed to a method:</p>

<p><a href="/csharp/csharp_value_parameters.htm" title="Value parameters in C#">Value parameters</a></p>

<p><a href="/csharp/csharp_reference_parameters.htm" title="Reference parameters in C#">Reference parameters</a></p>

<p><a href="/csharp/csharp_output_parameters.htm" title="Output parameters in C#">Output parameters</a></p>

<h1>C# - Nullables</h1>

<p>C# provides a special data types, the <b>nullable</b> types, to which you can assign normal range of values as well as null values.</p>

<p>For example, you can store any value from -2,147,483,648 to 2,147,483,647 or null in a Nullable&lt;Int32&gt; variable. Similarly, you can assign true, false, or null in a Nullable&lt;bool&gt; variable. Syntax for declaring a <b>nullable</b> type is as follows:</p>

<p>The following example demonstrates use of nullable data types:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>The Null Coalescing Operator (??)</h2>

<p>The null coalescing operator is used with the nullable value types and reference types. It is used for converting an operand to the type of another nullable (or not) value type operand, where an implicit conversion is possible.</p>

<p>If the value of the first operand is null, then the operator returns the value of the second operand, otherwise it returns the value of the first operand. The following example explains this:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>C# - Arrays</h1>

<p>An array stores a fixed-size sequential collection of elements of the same type. An array is used to store a collection of data, but it is often more useful to think of an array as a collection of variables of the same type stored at contiguous memory locations.</p>

<p>Instead of declaring individual variables, such as number0, number1, ..., and number99, you declare one array variable such as numbers and use numbers[0], numbers[1], and ..., numbers[99] to represent individual variables. A specific element in an array is accessed by an index.</p>

<p>All arrays consist of contiguous memory locations. The lowest address corresponds to the first element and the highest address to the last element.</p>

<h2>Declaring Arrays</h2>

<p>To declare an array in C#, you can use the following syntax:</p>

<p>where,</p>

<p>d<i>atatype</i> is used to specify the type of elements in the array.</p>

<p><i>[ ]</i> specifies the rank of the array. The rank specifies the size of the array. </p>

<p><i>arrayName</i> specifies the name of the array.</p>

<p>For example,</p>

<h2>Initializing an Array</h2>

<p>Declaring an array does not initialize the array in the memory. When the array variable is initialized, you can assign values to the array.</p>

<p>Array is a reference type, so you need to use the <b>new</b> keyword to create an instance of the array. For example,</p>

<h2>Assigning Values to an Array</h2>

<p>You can assign values to individual array elements, by using the index number, like:</p>

<p>You can assign values to the array at the time of declaration, as shown:</p>

<p>You can also create and initialize an array, as shown:</p>

<p>You may also omit the size of the array, as shown:</p>

<p>You can copy an array variable into another target array variable. In such case, both the target and source point to the same memory location:</p>

<p>When you create an array, C# compiler implicitly initializes each array element to a default value depending on the array type. For example, for an int array all elements are initialized to 0.</p>

<h2>Accessing Array Elements</h2>

<p>An element is accessed by indexing the array name. This is done by placing the index of the element within square brackets after the name of the array. For example,</p>

<p>The following example, demonstrates the above-mentioned concepts declaration, assignment, and accessing arrays:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Using the <i>foreach</i> Loop</h2>

<p>In the previous example, we used a for loop for accessing each array element. You can also use a <b>foreach</b> statement to iterate through an array.</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>C# Arrays</h2>

<p>There are following few important concepts related to array which should be clear to a C# programmer:</p>

<p><a href="/csharp/csharp_multi_dimensional_arrays.htm" title="Multi-dimensional arrays in C#">Multi-dimensional arrays</a></p>

<p><a href="/csharp/csharp_jagged_arrays.htm" title="Jagged arrays in C#">Jagged arrays</a></p>

<p><a href="/csharp/csharp_passing_arrays_to_functions.htm" title="Passing arrays to functions as arguments in C#">Passing arrays to functions</a></p>

<p><a href="/csharp/csharp_param_arrays.htm" title="Param arrays in C#">Param arrays</a></p>

<p><a href="/csharp/csharp_array_class.htm" title="Array class in C">The Array Class</a></td></p>

<h1>C# - Strings</h1>

<p>In C#, you can use strings as array of characters, However, more common practice is to use the <b>string</b> keyword to declare a string variable. The string keyword is an alias for the <b>System.String</b> class.</p>

<h2>Creating a String Object</h2>

<p>You can create string object using one of the following methods:</p>

<p>By assigning a string literal to a String variable</p>

<p>By using a String class constructor</p>

<p>By using the string concatenation operator (+)</p>

<p>By retrieving a property or calling a method that returns a string</p>

<p>By calling a formatting method to convert a value or an object to its string representation</p>

<p>The following example demonstrates this:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Properties of the String Class</h2>

<p>The String class has the following two properties:</p>

<p>Gets the <i>Char</i> object at a specified position in the current <i>String</i> object.</p>

<p>Gets the number of characters in the current String object.</p>

<h2>Methods of the String Class</h2>

<p>The String class has numerous methods that help you in working with the string objects. The following table provides some of the most commonly used methods:</p>

<p>Compares two specified string objects and returns an integer that indicates their relative position in the sort order.</p>

<p>Compares two specified string objects and returns an integer that indicates their relative position in the sort order. However, it ignores case if the Boolean parameter is true.</p>

<p>Concatenates two string objects.</p>

<p>Concatenates three string objects.</p>

<p>Concatenates four string objects.</p>

<p>Returns a value indicating whether the specified String object occurs within this string.</p>

<p>Creates a new String object with the same value as the specified string.</p>

<p>Copies a specified number of characters from a specified position of the String object to a specified position in an array of Unicode characters.</p>

<p>Determines whether the end of the string object matches the specified string.</p>

<p>Determines whether the current String object and the specified String object have the same value.</p>

<p>Determines whether two specified String objects have the same value.</p>

<p>Replaces one or more format items in a specified string with the string representation of a specified object.</p>

<p>Returns the zero-based index of the first occurrence of the specified Unicode character in the current string.</p>

<p>Returns the zero-based index of the first occurrence of the specified string in this instance.</p>

<p>Returns the zero-based index of the first occurrence of the specified Unicode character in this string, starting search at the specified character position.</p>

<p>Returns the zero-based index of the first occurrence of the specified string in this instance, starting search at the specified character position.</p>

<p>Returns the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters.</p>

<p>Returns the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters, starting search at the specified character position.</p>

<p>Returns a new string in which a specified string is inserted at a specified index position in the current string object.</p>

<p>Indicates whether the specified string is null or an Empty string.</p>

<p>Concatenates all the elements of a string array, using the specified separator between each element.</p>

<p>Concatenates the specified elements of a string array, using the specified separator between each element.</p>

<p>Returns the zero-based index position of the last occurrence of the specified Unicode character within the current string object.</p>

<p>Returns the zero-based index position of the last occurrence of a specified string within the current string object.</p>

<p>Removes all the characters in the current instance, beginning at a specified position and continuing through the last position, and returns the string.</p>

<p>Removes the specified number of characters in the current string beginning at a specified position and returns the string.</p>

<p>Replaces all occurrences of a specified Unicode character in the current string object with the specified Unicode character and returns the new string.</p>

<p>Replaces all occurrences of a specified string in the current string object with the specified string and returns the new string.</p>

<p>Returns a string array that contains the substrings in the current string object, delimited by elements of a specified Unicode character array.</p>

<p>Returns a string array that contains the substrings in the current string object, delimited by elements of a specified Unicode character array. The int parameter specifies the maximum number of substrings to return.</p>

<p>Returns a Unicode character array with all the characters in the current string object.</p>

<p>Returns a Unicode character array with all the characters in the current string object, starting from the specified index and up to the specified length.</p>

<p>Returns a copy of this string converted to lowercase.</p>

<p>Returns a copy of this string converted to uppercase.</p>

<p>Removes all leading and trailing white-space characters from the current String object.</p>

<p>You can visit MSDN library for the complete list of methods and String class constructors. </p>

<h2>Examples</h2>

<p>The following example demonstrates some of the methods mentioned above:</p>

<p><b>Comparing Strings:</b></p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p><b>String Contains String:</b></p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p><b>Getting a Substring:</b></p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p><b>Joining Strings:</b></p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>C# - Structures</h1>

<p>In C#, a structure is a value type data type. It helps you to make a single variable hold related data of various data types. The <b>struct</b> keyword is used for creating a structure. </p>

<p>Structures are used to represent a record. Suppose you want to keep track of your books in a library. You might want to track the following attributes about each book:</p>

<h2>Defining a Structure</h2>

<p>To define a structure, you must use the struct statement. The struct statement defines a new data type, with more than one member for your program.</p>

<p>For example, here is the way you can declare the Book structure:</p>

<p>The following program shows the use of the structure:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Features of C# Structures</h2>

<p>You have already used a simple structure named Books. Structures in C# are quite different from that in traditional C or C++. The C# structures have the following features:</p>

<p>Structures can have methods, fields, indexers, properties, operator methods, and events.</p>

<p>Structures can have defined constructors, but not destructors. However, you cannot define a default constructor for a structure. The default constructor is automatically defined and cannot be changed.</p>

<p>Unlike classes, structures cannot inherit other structures or classes.</p>

<p>Structures cannot be used as a base for other structures or classes.</p>

<p>A structure can implement one or more interfaces.</p>

<p>Structure members cannot be specified as abstract, virtual, or protected.</p>

<p>When you create a struct object using the <b>New</b> operator, it gets created and the appropriate constructor is called. Unlike classes, structs can be instantiated without using the New operator.</p>

<p>If the New operator is not used, the fields remain unassigned and the object cannot be used until all the fields are initialized.</p>

<h2>Class versus Structure</h2>

<p>Classes and Structures have the following basic differences:</p>

<p>classes are reference types and structs are value types</p>

<p>structures do not support inheritance</p>

<p>structures cannot have default constructor</p>

<p>In the light of the above discussions, let us rewrite the previous example:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>C# - Enums</h1>

<p>An enumeration is a set of named integer constants. An enumerated type is declared using the <b>enum</b> keyword.</p>

<p>C# enumerations are value data type. In other words, enumeration contains its own values and cannot inherit or cannot pass inheritance.</p>

<h2>Declaring <i>enum</i> Variable</h2>

<p>The general syntax for declaring an enumeration is:</p>

<p>Where,</p>

<p>The <i>enum_name</i> specifies the enumeration type name.</p>

<p>The <i>enumeration list</i> is a comma-separated list of identifiers.</p>

<p>Each of the symbols in the enumeration list stands for an integer value, one greater than the symbol that precedes it. By default, the value of the first enumeration symbol is 0. For example:</p>

<h2>Example</h2>

<p>The following example demonstrates use of enum variable:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>C# - Classes</h1>

<p>When you define a class, you define a blueprint for a data type. This does not actually define any data, but it does define what the class name means. That is, what an object of the class consists of and what operations can be performed on that object. Objects are instances of a class. The methods and variables that constitute a class are called members of the class.</p>

<h2>Defining a Class</h2>

<p>A class definition starts with the keyword class followed by the class name; and the class body enclosed by a pair of curly braces. Following is the general form of a class definition:</p>

<p>Note:</p>

<p>Access specifiers specify the access rules for the members as well as the class itself. If not mentioned, then the default access specifier for a class type is <b>internal</b>. Default access for the members is <b>private</b>.</p>

<p>Data type specifies the type of variable, and return type specifies the data type of the data the method returns, if any.</p>

<p>To access the class members, you use the dot (.) operator.</p>

<p>The dot operator links the name of an object with the name of a member.</p>

<p>The following example illustrates the concepts discussed so far:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Member Functions and Encapsulation</h2>

<p>A member function of a class is a function that has its definition or its prototype within the class definition similar to any other variable. It operates on any object of the class of which it is a member, and has access to all the members of a class for that object.</p>

<p>Member variables are the attributes of an object (from design perspective) and they are kept private to implement encapsulation. These variables can only be accessed using the public member functions.</p>

<p>Let us put above concepts to set and get the value of different class members in a class:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>C# Constructors</h2>

<p>A class <b>constructor</b> is a special member function of a class that is executed whenever we create new objects of that class.</p>

<p>A constructor has exactly the same name as that of class and it does not have any return type. Following example explains the concept of constructor:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>A <b>default constructor</b> does not have any parameter but if you need, a constructor can have parameters. Such constructors are called <b>parameterized constructors</b>. This technique helps you to assign initial value to an object at the time of its creation as shown in the following example:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>C# Destructors</h2>

<p>A <b>destructor</b> is a special member function of a class that is executed whenever an object of its class goes out of scope. A <b>destructor</b> has exactly the same name as that of the class with a prefixed tilde (~) and it can neither return a value nor can it take any parameters.</p>

<p>Destructor can be very useful for releasing memory resources before exiting the program. Destructors cannot be inherited or overloaded.</p>

<p>Following example explains the concept of destructor:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Static Members of a C# Class</h2>

<p>We can define class members as static using the <b>static</b> keyword. When we declare a member of a class as static, it means no matter how many objects of the class are created, there is only one copy of the static member.</p>

<p>The keyword <b>static</b> implies that only one instance of the member exists for a class. Static variables are used for defining constants because their values can be retrieved by invoking the class without creating an instance of it. Static variables can be initialized outside the member function or class definition. You can also initialize static variables inside the class definition.</p>

<p>The following example demonstrates the use of <b>static variables</b>:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>You can also declare a <b>member function</b> as <b>static</b>. Such functions can access only static variables. The static functions exist even before the object is created. The following example demonstrates the use of <b>static functions</b>:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>C# - Inheritance</h1>

<p>One of the most important concepts in object-oriented programming is inheritance. Inheritance allows us to define a class in terms of another class, which makes it easier to create and maintain an application. This also provides an opportunity to reuse the code functionality and speeds up implementation time.</p>

<p>When creating a class, instead of writing completely new data members and member functions, the programmer can designate that the new class should inherit the members of an existing class. This existing class is called the <b>base</b> class, and the new class is referred to as the <b>derived</b> class.</p>

<p>The idea of inheritance implements the <b>IS-A</b> relationship. For example, mammal <b>IS A</b> animal, dog <b>IS-A</b> mammal hence dog <b>IS-A</b> animal as well, and so on.</p>

<h2>Base and Derived Classes</h2>

<p>A class can be derived from more than one class or interface, which means that it can inherit data and functions from multiple base classes or interfaces.</p>

<p>The syntax used in C# for creating derived classes is as follows:</p>

<p>Consider a base class Shape and its derived class Rectangle:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Initializing Base Class</h2>

<p>The derived class inherits the base class member variables and member methods. Therefore the super class object should be created before the subclass is created. You can give instructions for superclass initialization in the member initialization list.</p>

<p>The following program demonstrates this:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Multiple Inheritance in C#</h2>

<p><b>C# does not support multiple inheritance</b>. However, you can use interfaces to implement multiple inheritance. The following program demonstrates this:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>C# - Polymorphism</h1>

<p>The word <b>polymorphism</b> means having many forms. In object-oriented programming paradigm, polymorphism is often expressed as 'one interface, multiple functions'.</p>

<p>Polymorphism can be static or dynamic. In <b>static polymorphism</b>, the response to a function is determined at the compile time. In <b>dynamic polymorphism</b>, it is decided at run-time.</p>

<h2>Static Polymorphism</h2>

<p>The mechanism of linking a function with an object during compile time is called early binding. It is also called static binding. C# provides two techniques to implement static polymorphism. They are:</p>

<p>We discuss operator overloading in next chapter.</p>

<h2>Function Overloading</h2>

<p>You can have multiple definitions for the same function name in the same scope. The definition of the function must differ from each other by the types and/or the number of arguments in the argument list. You cannot overload function declarations that differ only by return type.</p>

<p>The following example shows using function <b>print()</b> to print different data types:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Dynamic Polymorphism</h2>

<p>C# allows you to create abstract classes that are used to provide partial class implementation of an interface. Implementation is completed when a derived class inherits from it. <b>Abstract</b> classes contain abstract methods, which are implemented by the derived class. The derived classes have more specialized functionality.</p>

<p>Here are the rules about abstract classes:</p>

<p>You cannot create an instance of an abstract class</p>

<p>You cannot declare an abstract method outside an abstract class</p>

<p>When a class is declared <b>sealed</b>, it cannot be inherited, abstract classes cannot be declared sealed.</p>

<p>The following program demonstrates an abstract class:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>When you have a function defined in a class that you want to be implemented in an inherited class(es), you use <b>virtual</b> functions. The virtual functions could be implemented differently in different inherited class and the call to these functions will be decided at runtime.</p>

<p>Dynamic polymorphism is implemented by <b>abstract classes</b> and <b>virtual functions</b>.</p>

<p>The following program demonstrates this:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>C# - Operator Overloading</h1>

<p>You can redefine or overload most of the built-in operators available in C#. Thus a programmer can use operators with user-defined types as well. Overloaded operators are functions with special names the keyword <b>operator</b> followed by the symbol for the operator being defined. similar to any other function, an overloaded operator has a return type and a parameter list.</p>

<p>For example, go through the following function:</p>

<p>The above function implements the addition operator (+) for a user-defined class Box. It adds the attributes of two Box objects and returns the resultant Box object.</p>

<h2>Implementing the Operator Overloading</h2>

<p>The following program shows the complete implementation:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Overloadable and Non-Overloadable Operators</h2>

<p>The following table describes the overload ability of the operators in C#:</p>

<h2>Example</h2>

<p>In the light of the above discussions, let us extend the preceding example, and overload few more operators:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>C# - Interfaces</h1>

<p>An interface is defined as a syntactical contract that all the classes inheriting the interface should follow. The interface defines the <b>'what'</b> part of the syntactical contract and the deriving classes define the <b>'how'</b> part of the syntactical contract. </p>

<p>Interfaces define properties, methods, and events, which are the members of the interface. Interfaces contain only the declaration of the members. It is the responsibility of the deriving class to define the members. It often helps in providing a standard structure that the deriving classes would follow.</p>

<p>Abstract classes to some extent serve the same purpose, however, they are mostly used when only few methods are to be declared by the base class and the deriving class implements the functionalities.</p>

<h2>Declaring Interfaces</h2>

<p>Interfaces are declared using the interface keyword. It is similar to class declaration. Interface statements are public by default. Following is an example of an interface declaration:</p>

<h2>Example</h2>

<p>The following example demonstrates implementation of the above interface:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>C# - Namespaces</h1>

<p>A <b>namespace</b> is designed for providing a way to keep one set of names separate from another. The class names declared in one namespace does not conflict with the same class names declared in another.</p>

<h2>Defining a Namespace</h2>

<p>A namespace definition begins with the keyword <b>namespace</b> followed by the namespace name as follows:</p>

<p>To call the namespace-enabled version of either function or variable, prepend the namespace name as follows:</p>

<p>The following program demonstrates use of namespaces:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>The <i>using</i> Keyword</h2>

<p>The <b>using</b> keyword states that the program is using the names in the given namespace. For example, we are using the <b>System</b> namespace in our programs. The class Console is defined there. We just write:</p>

<p>We could have written the fully qualified name as:</p>

<p>You can also avoid prepending of namespaces with the <b>using</b> namespace directive. This directive tells the compiler that the subsequent code is making use of names in the specified namespace. The namespace is thus implied for the following code:</p>

<p>Let us rewrite our preceding example, with using directive:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Nested Namespaces</h2>

<p>You can define one namespace inside another namespace as follows:</p>

<p>You can access members of nested namespace by using the dot (.) operator as follows:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>C# - Preprocessor Directives</h1>

<p>The preprocessor directives give instruction to the compiler to preprocess the information before actual compilation starts.</p>

<p>All preprocessor directives begin with #, and only white-space characters may appear before a preprocessor directive on a line. Preprocessor directives are not statements, so they do not end with a semicolon (;).</p>

<p>C# compiler does not have a separate preprocessor; however, the directives are processed as if there was one. In C# the preprocessor directives are used to help in conditional compilation. Unlike C and C++ directives, they are not used to create macros. A preprocessor directive must be the only instruction on a line.</p>

<h2>Preprocessor Directives in C#</h2>

<p>The following table lists the preprocessor directives available in C#:</p>

<h2>The #define Preprocessor</h2>

<p>The #define preprocessor directive creates symbolic constants.</p>

<p>#define lets you define a symbol such that, by using the symbol as the expression passed to the #if directive, the expression evaluates to true. Its syntax is as follows:</p>

<p>The following program illustrates this:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Conditional Directives</h2>

<p>You can use the #if directive to create a conditional directive. Conditional directives are useful for testing a symbol or symbols to check if they evaluate to true. If they do evaluate to true, the compiler evaluates all the code between the #if and the next directive.</p>

<p>Syntax for conditional directive is:</p>

<p>Where, <i>symbol</i> is the name of the symbol you want to test. You can also use true and false or prepend the symbol with the negation operator.</p>

<p>The <i>operator symbol</i> is the operator used for evaluating the symbol. Operators could be either of the following:</p>

<p>You can also group symbols and operators with parentheses. Conditional directives are used for compiling code for a debug build or when compiling for a specific configuration. A conditional directive beginning with a <b>#if</b> directive must explicitly be terminated with a <b>#endif</b> directive.</p>

<p>The following program demonstrates use of conditional directives:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>C# - Regular Expressions</h1>

<p>A <b>regular expression</b> is a pattern that could be matched against an input text. The .Net framework provides a regular expression engine that allows such matching. A pattern consists of one or more character literals, operators, or constructs.</p>

<h2>Constructs for Defining Regular Expressions</h2>

<p>There are various categories of characters, operators, and constructs that lets you to define regular expressions. Click the following links to find these constructs.</p>

<p><a href="/csharp/csharp_character_escapes.htm" title="csharp character escapes regular expression">Character escapes</a></p>

<p><a href="/csharp/csharp_character_classes.htm" title="csharp character classes regular expression">Character classes</a></p>

<p><a href="/csharp/csharp_anchors.htm" title="csharp anchors regular expression">Anchors</a></p>

<p><a href="/csharp/csharp_grouping_constructs.htm" title="csharp grouping constructs regular expression">Grouping constructs</a></p>

<p><a href="/csharp/csharp_quantifiers.htm" title="csharp quantifiers regular expression">Quantifiers</a></p>

<p><a href="/csharp/csharp_backreference_constructs.htm" title="csharp backreference constructs regular expression">Backreference constructs</a></p>

<p><a href="/csharp/csharp_alternation_constructs.htm" title="csharp alternation constructs regular expression">Alternation constructs</a></p>

<p><a href="/csharp/csharp_substitutions.htm" title="csharp substitutions regular expression">Substitutions</a></p>

<p><a href="/csharp/csharp_miscellaneous_constructs.htm" title="csharp miscellaneous constructs regular expression">Miscellaneous constructs</a></p>

<h2>The Regex Class</h2>

<p>The Regex class is used for representing a regular expression. It has the following commonly used methods:</p>

<p>Indicates whether the regular expression specified in the Regex constructor finds a match in a specified input string.</p>

<p>Indicates whether the regular expression specified in the Regex constructor finds a match in the specified input string, beginning at the specified starting position in the string.</p>

<p>Indicates whether the specified regular expression finds a match in the specified input string.</p>

<p>Searches the specified input string for all occurrences of a regular expression.</p>

<p>In a specified input string, replaces all strings that match a regular expression pattern with a specified replacement string.</p>

<p>Splits an input string into an array of substrings at the positions defined by a regular expression pattern specified in the Regex constructor.</p>

<p>For the complete list of methods and properties, please read the Microsoft documentation on C#.</p>

<h2>Example 1</h2>

<p>The following example matches words that start with 'S':</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Example 2</h2>

<p>The following example matches words that start with 'm' and ends with 'e':</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Example 3</h2>

<p>This example replaces extra white space:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>C# - Exception Handling</h1>

<p>An exception is a problem that arises during the execution of a program. A C# exception is a response to an exceptional circumstance that arises while a program is running, such as an attempt to divide by zero.</p>

<p>Exceptions provide a way to transfer control from one part of a program to another. C# exception handling is built upon four keywords: <b>try</b>, <b>catch</b>, <b>finally</b>, and <b>throw</b>.</p>

<p><b>try</b>: A try block identifies a block of code for which particular exceptions is activated. It is followed by one or more catch blocks.</p>

<p><b>catch</b>: A program catches an exception with an exception handler at the place in a program where you want to handle the problem. The catch keyword indicates the catching of an exception.</p>

<p><b>finally</b>: The finally block is used to execute a given set of statements, whether an exception is thrown or not thrown. For example, if you open a file, it must be closed whether an exception is raised or not.</p>

<p><b>throw</b>: A program throws an exception when a problem shows up. This is done using a throw keyword.</p>

<h2>Syntax</h2>

<p>Assuming a block raises an exception, a method catches an exception using a combination of the try and catch keywords. A try/catch block is placed around the code that might generate an exception. Code within a try/catch block is referred to as protected code, and the syntax for using try/catch looks like the following:</p>

<p>You can list down multiple catch statements to catch different type of exceptions in case your try block raises more than one exception in different situations.</p>

<h2>Exception Classes in C#</h2>

<p>C# exceptions are represented by classes. The exception classes in C# are mainly directly or indirectly derived from the <b>System.Exception</b> class. Some of the exception classes derived from the System.Exception class are the <b>System.ApplicationException</b> and <b>  System.SystemException</b> classes.</p>

<p>The <b>System.ApplicationException</b> class supports exceptions generated by application programs. Hence the exceptions defined by the programmers should derive from this class.</p>

<p>The <b>System.SystemException</b> class is the base class for all predefined system exception.</p>

<p>The following table provides some of the predefined exception classes derived from the Sytem.SystemException class:</p>

<h2>Handling Exceptions</h2>

<p>C# provides a structured solution to the exception handling in the form of try and catch blocks. Using these blocks the core program statements are separated from the error-handling statements.</p>

<p>These error handling blocks are implemented using the <b>try</b>, <b>catch</b>, and <b>finally</b> keywords. Following is an example of throwing an exception when dividing by zero condition occurs:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Creating User-Defined Exceptions</h2>

<p>You can also define your own exception. User-defined exception classes are derived from the <b>ApplicationException</b> class. The following example demonstrates this:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Throwing Objects</h2>

<p>You can throw an object if it is either directly or indirectly derived from the <b>System.Exception</b> class. You can use a throw statement in the catch block to throw the present object as:</p>

<h1>C# - File I/O</h1>

<p>A <b>file</b> is a collection of data stored in a disk with a specific name and a directory path. When a file is opened for reading or writing, it becomes a <b>stream</b>.</p>

<p>The stream is basically the sequence of bytes passing through the communication path. There are two main streams: the <b>input stream</b> and the <b>output stream</b>. The<b> input stream</b> is used for reading data from file (read operation) and the <b>output stream</b> is used for writing into the file (write operation).</p>

<h2>C# I/O Classes</h2>

<p>The System.IO namespace has various classes that are used for performing numerous operations with files, such as creating and deleting files, reading from or writing to a file, closing a file etc.</p>

<p>The following table shows some commonly used non-abstract classes in the System.IO namespace:</p>

<h2>The FileStream Class</h2>

<p>The <b>FileStream</b> class in the System.IO namespace helps in reading from, writing to and closing files. This class derives from the abstract class Stream.</p>

<p>You need to create a <b>FileStream</b> object to create a new file or open an existing file. The syntax for creating a <b>FileStream</b> object is as follows:</p>

<p>For example, we create a FileStream object <b>F</b> for reading a file named <b>sample.txt as shown</b>:</p>

<p>The <b>FileMode</b> enumerator defines various methods for opening files. The members of the FileMode enumerator are:</p>

<p><b>Append</b>: It opens an existing file and puts cursor at the end of file, or creates the file, if the file does not exist.</p>

<p><b>Create</b>: It creates a new file.</p>

<p><b>CreateNew</b>: It specifies to the operating system, that it should create a new file.</p>

<p><b>Open</b>: It opens an existing file.</p>

<p><b>OpenOrCreate</b>: It specifies to the operating system that it should open a file if it exists, otherwise it should create a new file.</p>

<p><b>Truncate</b>: It opens an existing file and truncates its size to zero bytes.</p>

<p><b>FileAccess</b> enumerators have members: <b>Read</b>, <b>ReadWrite</b> and <b>Write</b>.</p>

<p><b>FileShare</b> enumerators have the following members:</p>

<p><b>Inheritable</b>: It allows a file handle to pass inheritance to the child processes</p>

<p><b>None</b>: It declines sharing of the current file</p>

<p><b>Read</b>: It allows opening the file for reading </p>

<p><b>ReadWrite</b>: It allows opening the file for reading and writing</p>

<p><b>Write</b>: It allows opening the file for writing</p>

<h2>Example</h2>

<p>The following program demonstrates use of the <b>FileStream </b>class:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Advanced File Operations in C#</h2>

<p>The preceding example provides simple file operations in C#. However, to utilize the immense powers of C# System.IO classes, you need to know the commonly used properties and methods of these classes.</p>

<p><a href="/csharp/csharp_text_files.htm" title="C# text files">Reading from and Writing into Text files</a></p>

<p>It involves reading from and writing into text files. The <b>StreamReader</b> and <b>StreamWriter</b> class helps to accomplish it.</p>

<p><a href="/csharp/csharp_binary_files.htm" title="C# binary files">Reading from and Writing into Binary files</a></p>

<p>It involves reading from and writing into binary files. The <b>BinaryReader</b> and <b>BinaryWriter</b> class helps to accomplish this.</p>

<p><a href="/csharp/csharp_windows_file_system.htm" title="C# Windows file system">Manipulating the Windows file system</a></p>

<p>It gives a C# programamer the ability to browse and locate Windows files and directories.</p>

<h1>C# - Attributes</h1>

<p>An <b>attribute</b> is a declarative tag that is used to convey information to runtime about the behaviors of various elements like classes, methods, structures, enumerators, assemblies etc. in your program. You can add declarative information to a program by using an attribute. A declarative tag is depicted by square ([ ]) brackets placed above the element it is used for.</p>

<p>Attributes are used for adding metadata, such as compiler instruction and other information such as comments, description, methods and classes to a program. The .Net Framework provides two types of attributes: <i>the pre-defined</i> attributes and <i>custom built</i> attributes.</p>

<h2>Specifying an Attribute</h2>

<p>Syntax for specifying an attribute is as follows:</p>

<p>Name of the attribute and its values are specified within the square brackets, before the element to which the attribute is applied. Positional parameters specify the essential information and the name parameters specify the optional information.</p>

<h2>Predefined Attributes</h2>

<p>The .Net Framework provides three pre-defined attributes:</p>

<h2>AttributeUsage</h2>

<p>The pre-defined attribute <b>AttributeUsage</b> describes how a custom attribute class can be used. It specifies the types of items to which the attribute can be applied.</p>

<p>Syntax for specifying this attribute is as follows:</p>

<p>Where,</p>

<p>The parameter validon specifies the language elements on which the attribute can be placed. It is a combination of the value of an enumerator <i>AttributeTargets</i>. The default value is <i> AttributeTargets.All</i>.</p>

<p>The parameter <i>allowmultiple</i> (optional) provides value for the <i>AllowMultiple</i> property of this attribute, a Boolean value. If this is true, the attribute is multiuse. The default is false (single-use).</p>

<p>The parameter inherited (optional) provides value for the <i>Inherited</i> property of this attribute, a Boolean value. If it is true, the attribute is inherited by derived classes. The default value is false (not inherited).</p>

<p>For example,</p>

<h2>Conditional</h2>

<p>This predefined attribute marks a conditional method whose execution depends on a specified preprocessing identifier.</p>

<p>It causes conditional compilation of method calls, depending on the specified value such as <b>Debug</b> or <b> Trace</b>. For example, it displays the values of the variables while debugging a code.</p>

<p>Syntax for specifying this attribute is as follows:</p>

<p>For example,</p>

<p>The following example demonstrates the attribute:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Obsolete</h2>

<p>This predefined attribute marks a program entity that should not be used. It enables you to inform the compiler to discard a particular target element. For example, when a new method is being used in a class and if you still want to retain the old method in the class, you may mark it as obsolete by displaying a message the new method should be used, instead of the old method.</p>

<p>Syntax for specifying this attribute is as follows:</p>

<p>Where,</p>

<p>The parameter <i>message</i>, is a string describing the reason why the item is obsolete and what to use instead.</p>

<p>The parameter <i>iserror</i>, is a Boolean value. If its value is true, the compiler should treat the use of the item as an error. Default value is false (compiler generates a warning).</p>

<p>The following program demonstrates this:</p>

<p>When you try to compile the program, the compiler gives an error message stating:</p>

<h2>Creating Custom Attributes</h2>

<p>The .Net Framework allows creation of custom attributes that can be used to store declarative information and can be retrieved at run-time. This information can be related to any target element depending upon the design criteria and application need.</p>

<p>Creating and using custom attributes involve four steps:</p>

<p>The Last step involves writing a simple program to read through the metadata to find various notations. Metadata is data about data or information used for describing other data. This program should use reflections for accessing attributes at runtime. This we will discuss in the next chapter.</p>

<h2>Declaring a Custom Attribute</h2>

<p>A new custom attribute should is derived from the <b>System.Attribute</b> class. For example,</p>

<p>In the preceding code, we have declared a custom attribute named <i>DeBugInfo</i>.</p>

<h2>Constructing the Custom Attribute</h2>

<p>Let us construct a custom attribute named <i>DeBugInfo</i>, which stores the information obtained by debugging any program. Let it store the following information:</p>

<p>The <i>DeBugInfo</i> class has three private properties for storing the first three information and a public property for storing the message. Hence the bug number, developer's name, and date of review are the positional parameters of the DeBugInfo class and the message is an optional or named parameter.</p>

<p>Each attribute must have at least one constructor. The positional parameters should be passed through the constructor. The following code shows the <i>DeBugInfo</i> class:</p>

<h2>Applying the Custom Attribute</h2>

<p>The attribute is applied by placing it immediately before its target:</p>

<p>In the next chapter, we retrieve attribute information using a Reflection class object.</p>

<h1>C# - Reflection</h1>

<p><b>Reflection</b> objects are used for obtaining type information at runtime. The classes that give access to the metadata of a running program are in the <b>System.Reflection</b> namespace.</p>

<p>The <b>System.Reflection</b> namespace contains classes that allow you to obtain information about the application and to dynamically add types, values, and objects to the application.</p>

<h2>Applications of Reflection</h2>

<p>Reflection has the following applications:</p>

<p>It allows view attribute information at runtime.</p>

<p>It allows examining various types in an assembly and instantiate these types.</p>

<p>It allows late binding to methods and properties</p>

<p>It allows creating new types at runtime and then performs some tasks using those types. </p>

<h2>Viewing Metadata</h2>

<p>We have mentioned in the preceding chapter that using reflection you can view the attribute information.</p>

<p>The <b>MemberInfo</b> object of the <b>System.Reflection</b> class needs to be initialized for discovering the attributes associated with a class. To do this, you define an object of the target class, as:</p>

<p>The following program demonstrates this:</p>

<p>When it is compiled and run, it displays the name of the custom attributes attached to the class <i>MyClass</i>:</p>

<h2>Example</h2>

<p>In this example, we use the <i>DeBugInfo</i> attribute created in the previous chapter and use reflection to read metadata in the <i>Rectangle</i> class.</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>C# - Properties</h1>

<p><b>Properties</b> are named members of classes, structures, and interfaces. Member variables or methods in a class or structures are called <b>Fields</b>. Properties are an extension of fields and are accessed using the same syntax. They use <b>accessors</b> through which the values of the private fields can be read, written or manipulated.</p>

<p>Properties do not name the storage locations. Instead, they have <b>accessors</b> that read, write, or compute their values.</p>

<p>For example, let us have a class named Student, with private fields for age, name, and code. We cannot directly access these fields from outside the class scope, but we can have properties for accessing these private fields.</p>

<h2>Accessors</h2>

<p>The <b>accessor</b> of a property contains the executable statements that helps in getting (reading or computing) or setting (writing) the property. The accessor declarations can contain a get accessor, a set accessor, or both. For example:</p>

<h2>Example</h2>

<p>The following example demonstrates use of properties:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Abstract Properties</h2>

<p>An abstract class may have an abstract property, which should be implemented in the derived class. The following program illustrates this:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>C# - Indexers</h1>

<p>An <b>indexer</b> allows an object to be indexed such as an array. When you define an indexer for a class, this class behaves similar to a <b>virtual array</b>. You can then access the instance of this class using the array access operator ([ ]).</p>

<h2>Syntax</h2>

<p>A one dimensional indexer has the following syntax:</p>

<h2>Use of Indexers</h2>

<p>Declaration of behavior of an indexer is to some extent similar to a property. similar to the properties, you use <b> get</b> and <b>set</b> accessors for defining an indexer. However, properties return or set a specific data member, whereas indexers returns or sets a particular value from the object instance. In other words, it breaks the instance data into smaller parts and indexes each part, gets or sets each part.</p>

<p>Defining a property involves providing a property name. Indexers are not defined with names, but with the <b>this</b> keyword, which refers to the object instance. The following example demonstrates the concept:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Overloaded Indexers</h2>

<p>Indexers can be overloaded. Indexers can also be declared with multiple parameters and each parameter may be a different type. It is not necessary that the indexes have to be integers. C# allows indexes to be of other types, for example, a string.</p>

<p>The following example demonstrates overloaded indexers:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>C# - Delegates</h1>

<p>C# delegates are similar to pointers to functions, in C or C++. A <b>delegate</b> is a reference type variable that holds the reference to a method. The reference can be changed at runtime.</p>

<p>Delegates are especially used for implementing events and the call-back methods. All delegates are implicitly derived from the <b>System.Delegate</b> class.</p>

<h2>Declaring Delegates</h2>

<p>Delegate declaration determines the methods that can be referenced by the delegate. A delegate can refer to a method, which has the same signature as that of the delegate.</p>

<p>For example, consider a delegate:</p>

<p>The preceding delegate can be used to reference any method that has a single <i>string</i> parameter and returns an <i>int</i> type variable.</p>

<p>Syntax for delegate declaration is:</p>

<h2>Instantiating Delegates</h2>

<p>Once a delegate type is declared, a delegate object must be created with the <b>new </b> keyword and be associated with a particular method. When creating a delegate, the argument passed to the <b>new</b> expression is written similar to a method call, but without the arguments to the method. For example:</p>

<p>Following example demonstrates declaration, instantiation, and use of a delegate that can be used to reference methods that take an integer parameter and returns an integer value.</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Multicasting of a Delegate</h2>

<p>Delegate objects can be composed using the "+" operator. A composed delegate calls the two delegates it was composed from. Only delegates of the same type can be composed. The "-" operator can be used to remove a component delegate from a composed delegate.</p>

<p>Using this property of delegates you can create an invocation list of methods that will be called when a delegate is invoked. This is called <b>multicasting</b> of a delegate. The following program demonstrates multicasting of a delegate:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Using Delegates</h2>

<p>The following example demonstrates the use of delegate. The delegate <i>printString</i> can be used to reference method that takes a string as input and returns nothing.</p>

<p>We use this delegate to call two methods, the first prints the string to the console, and the second one prints it to a file:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>C# - Events</h1>

<p><b>Events</b> are user actions such as key press, clicks, mouse movements, etc., or some occurrence such as system generated notifications. Applications need to respond to events when they occur. For example, interrupts. Events are used for inter-process communication.</p>

<h2>Using Delegates with Events</h2>

<p>The events are declared and raised in a class and associated with the event handlers using delegates within the same class or some other class. The class containing the event is used to publish the event. This is called the <b>publisher</b> class. Some other class that accepts this event is called the <b>subscriber </b> class. Events use the <b>publisher-subscriber</b> model.</p>

<p>A <b>publisher</b> is an object that contains the definition of the event and the delegate. The event-delegate association is also defined in this object. A publisher class object invokes the event and it is notified to other objects.</p>

<p>A <b>subscriber</b> is an object that accepts the event and provides an event handler. The delegate in the publisher class invokes the method (event handler) of the subscriber class.</p>

<h2>Declaring Events</h2>

<p>To declare an event inside a class, first a delegate type for the event must be declared. For example,</p>

<p>Next, the event itself is declared, using the <b>event</b> keyword:</p>

<p>The preceding code defines a delegate named <i>BoilerLogHandler</i> and an event named <i>BoilerEventLog</i>, which invokes the delegate when it is raised.</p>

<h2>Example</h2>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>C# - Collections</h1>

<p>Collection classes are specialized classes for data storage and retrieval. These classes provide support for stacks, queues, lists, and hash tables. Most collection classes implement the same interfaces.</p>

<p>Collection classes serve various purposes, such as allocating memory dynamically to elements and accessing a list of items on the basis of an index etc. These classes create collections of objects of the Object class, which is the base class for all data types in C#.</p>

<h2>Various Collection Classes and Their Usage</h2>

<p>The following are the various commonly used classes of the <b>System.Collection</b> namespace. Click the following links to check their detail.</p>

<p><a href="/csharp/csharp_arraylist.htm" title="C# ArrayList">ArrayList</a></p>

<p>It represents ordered collection of an object that can be <b>indexed</b> individually.</p>

<p>It is basically an alternative to an array. However, unlike array you can add and remove items from a list at a specified position using an <b>index</b> and the array resizes itself automatically. It also allows dynamic memory allocation, adding, searching and sorting items in the list.</p>

<p><a href="/csharp/csharp_hashtable.htm" title="C# Hashtable">Hashtable</a></p>

<p>It uses a <b>key</b> to access the elements in the collection.</p>

<p>A hash table is used when you need to access elements by using key, and you can identify a useful key value. Each item in the hash table has a <b>key/value</b> pair. The key is used to access the items in the collection.</p>

<p><a href="/csharp/csharp_sortedlist.htm" title="C# SortedList">SortedList</a></p>

<p>It uses a <b>key</b> as well as an <b>index</b> to access the items in a list.</p>

<p>A sorted list is a combination of an array and a hash table. It contains a list of items that can be accessed using a key or an index. If you access items using an index, it is an ArrayList, and if you access items using a key , it is a Hashtable. The collection of items is always sorted by the key value.</p>

<p><a href="/csharp/csharp_stack.htm" title="C# Stack">Stack</a></p>

<p>It represents a <b>last-in, first out</b> collection of object.</p>

<p>It is used when you need a last-in, first-out access of items. When you add an item in the list, it is called <b>pushing</b> the item and when you remove it, it is called <b>popping</b> the item.</p>

<p><a href="/csharp/csharp_queue.htm" title="C# Queue">Queue</a></td></p>

<p>It represents a <b>first-in, first out</b> collection of object.</p>

<p>It is used when you need a first-in, first-out access of items. When you add an item in the list, it is called <b>enqueue</b> and when you remove an item, it is called <b>deque</b>.</p>

<p><a href="/csharp/csharp_bitarray.htm" title="C# BitArray">BitArray</a></p>

<p>It represents an array of the <b>binary representation</b> using the values 1 and 0.</p>

<p>It is used when you need to store the bits but do not know the number of bits in advance. You can access items from the BitArray collection by using an <b>integer index</b>, which starts from zero.</p>

<h1>C# - Generics</h1>

<p><b>Generics</b> allow you to delay the specification of the data type of programming elements in a class or a method, until it is actually used in the program. In other words, generics allow you to write a class or method that can work with any data type.</p>

<p>You write the specifications for the class or the method, with substitute parameters for data types. When the compiler encounters a constructor for the class or a function call for the method, it generates code to handle the specific data type. A simple example would help understanding the concept:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Features of Generics</h2>

<p>Generics is a technique that enriches your programs in the following ways:</p>

<p>It helps you to maximize code reuse, type safety, and performance.</p>

<p>You can create generic collection classes. The .NET Framework class library contains several new generic collection classes in the <i>System.Collections.Generic</i> namespace. You may use these generic collection classes instead of the collection classes in the <i>System.Collections</i> namespace.</p>

<p>You can create your own generic interfaces, classes, methods, events, and delegates.</p>

<p>You may create generic classes constrained to enable access to methods on particular data types.</p>

<p>You may get information on the types used in a generic data type at run-time by means of reflection.</p>

<h2>Generic Methods</h2>

<p>In the previous example, we have used a generic class; we can declare a generic method with a type parameter. The following program illustrates the concept:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Generic Delegates</h2>

<p>You can define a generic delegate with type parameters. For example:</p>

<p>The following example shows use of this delegate:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>C# - Anonymous Methods</h1>

<p>We discussed that delegates are used to reference any methods that has the same signature as that of the delegate. In other words, you can call a method that can be referenced by a delegate using that delegate object.</p>

<p><b>Anonymous methods</b> provide a technique to pass a code block as a delegate parameter. Anonymous methods are the methods without a name, just the body.</p>

<p>You need not specify the return type in an anonymous method; it is inferred from the return statement inside the method body.</p>

<h2>Writing an Anonymous Method</h2>

<p>Anonymous methods are declared with the creation of the delegate instance, with a <b>delegate</b> keyword. For example,</p>

<p>The code block <i>Console.WriteLine("Anonymous Method: {0}", x);</i> is the body of the anonymous method.</p>

<p>The delegate could be called both with anonymous methods as well as named methods in the same way, i.e., by passing the method parameters to the delegate object.</p>

<p>For example,</p>

<h2>Example</h2>

<p>The following example demonstrates the concept:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>C# - Unsafe Codes</h1>

<p>C# allows using pointer variables in a function of code block when it is marked by the <b>unsafe</b> modifier. The <b>unsafe code</b> or the unmanaged code is a code block that uses a <b>pointer</b> variable.</p>

<p><b>Note:</b> To execute the programs mentioned in this chapter at <a target="blank" href="http://www.tutorialspoint.com/compile_csharp_online.php">codingground</a>, please set compilation option in <i>Project &gt;&gt; Compile Options  &gt;&gt; Compilation Command</i> to</p> <p style="text-align:center"><code>mcs *.cs -out:main.exe -unsafe"</code></p>

<h2>Pointers</h2>

<p>A <b>pointer</b> is a variable whose value is the address of another variable i.e., the direct address of the memory location. similar to any variable or constant, you must declare a pointer before you can use it to store any variable address.</p>

<p>The general form of a pointer declaration is:</p>

<p>Following are valid pointer declarations:</p>

<p>The following example illustrates use of pointers in C#, using the unsafe modifier:</p>

<p>When the above code wass compiled and executed, it produces the following result:</p>

<p>Instead of declaring an entire method as unsafe, you can also declare a part of the code as unsafe. The example in the following section shows this.</p>

<h2>Retrieving the Data Value Using a Pointer</h2>

<p>You can retrieve the data stored at the located referenced by the pointer variable, using the <b>ToString()</b> method. The following example demonstrates this:</p>

<p>When the above code was compiled and executed, it produces the following result:</p>

<h2>Passing Pointers as Parameters to Methods</h2>

<p>You can pass a pointer variable to a method as parameter. The following example illustrates this:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Accessing Array Elements Using a Pointer</h2>

<p>In C#, an array name and a pointer to a data type same as the array data, are not the same variable type. For example, int *p and int[] p, are not same type. You can increment the pointer variable p because it is not fixed in memory but an array address is fixed in memory, and you can't increment that.</p>

<p>Therefore, if you need to access an array data using a pointer variable, as we traditionally do in C, or C++ ( please check: <a href="http://www.tutorialspoint.com/cprogramming/c_pointers.htm">C Pointers</a>), you need to fix the pointer using the <b>fixed</b> keyword.</p>

<p>The following example demonstrates this:</p>

<p>When the above code was compiled and executed, it produces the following result:</p>

<h2>Compiling Unsafe Code</h2>

<p>For compiling unsafe code, you have to specify the <b>/unsafe</b> command-line switch with command-line compiler.</p>

<p>For example, to compile a program named prog1.cs containing unsafe code, from command line, give the command:</p>

<p>If you are using Visual Studio IDE then you need to enable use of unsafe code in the project properties.</p>

<p>To do this:</p>

<p>Open <b>project properties</b> by double clicking the properties node in the Solution Explorer.</p>

<p>Click on the <b>Build</b> tab.</p>

<p>Select the option "<b>Allow unsafe code</b>".</p>

<h1>C# - Multithreading</h1>

<p>A <b>thread</b> is defined as the execution path of a program. Each thread defines a unique flow of control. If your application involves complicated and time consuming operations, then it is often helpful to set different execution paths or threads, with each thread performing a particular job.</p>

<p>Threads are <b>lightweight processes</b>. One common example of use of thread is implementation of concurrent programming by modern operating systems. Use of threads saves wastage of CPU cycle and increase efficiency of an application.</p>

<p>So far we wrote the programs where a single thread runs as a single process which is the running instance of the application. However, this way the application can perform one job at a time. To make it execute more than one task at a time, it could be divided into smaller threads.</p>

<h2>Thread Life Cycle</h2>

<p>The life cycle of a thread starts when an object of the System.Threading.Thread class is created and ends when the thread is terminated or completes execution.</p>

<p>Following are the various states in the life cycle of a thread:</p>

<p><b>The Unstarted State</b>: It is the situation when the instance of the thread is created but the Start method is not called.</p>

<p><b>The Ready State</b>: It is the situation when the thread is ready to run and waiting CPU cycle.</p>

<p><b>The Not Runnable State</b>: A thread is not executable, when:</p>

<p><b>The Dead State</b>: It is the situation when the thread completes execution or is aborted.</p>

<h2>The Main Thread</h2>

<p>In C#, the <b>System.Threading.Thread</b> class is used for working with threads. It allows creating and accessing individual threads in a multithreaded application. The first thread to be executed in a process is called the <b>main</b> thread.</p>

<p>When a C# program starts execution, the main thread is automatically created. The threads created using the <b>Thread</b> class are called the child threads of the main thread. You can access a thread using the <b>CurrentThread</b> property of the Thread class.</p>

<p>The following program demonstrates main thread execution:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Properties and Methods of the Thread Class</h2>

<p>The following table shows some most commonly used <b>properties</b> of the <b>Thread</b> class:</p>

<p>The following table shows some of the most commonly used <b>methods</b> of the <b>Thread</b> class:</p>

<p>Raises a ThreadAbortException in the thread on which it is invoked, to begin the process of terminating the thread. Calling this method usually terminates the thread.</p>

<p>Allocates an unnamed data slot on all the threads. For better performance, use fields that are marked with the ThreadStaticAttribute attribute instead.</p>

<p>Allocates a named data slot on all threads. For better performance, use fields that are marked with the ThreadStaticAttribute attribute instead.</p>

<p>Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception might jeopardize other tasks in the application domain.</p>

<p>Notifies a host that managed code is about to execute instructions that depend on the identity of the current physical operating system thread.</p>

<p>Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception are limited to the current task.</p>

<p>Notifies a host that managed code has finished executing instructions that depend on the identity of the current physical operating system thread.</p>

<p>Eliminates the association between a name and a slot, for all threads in the process. For better performance, use fields that are marked with the ThreadStaticAttribute attribute instead.</p>

<p>Retrieves the value from the specified slot on the current thread, within the current thread's current domain. For better performance, use fields that are marked with the ThreadStaticAttribute attribute instead.</p>

<p>Returns the current domain in which the current thread is running.</p>

<p>Returns a unique application domain identifier</p>

<p>Looks up a named data slot. For better performance, use fields that are marked with the ThreadStaticAttribute attribute instead.</p>

<p>Interrupts a thread that is in the WaitSleepJoin thread state.</p>

<p>Blocks the calling thread until a thread terminates, while continuing to perform standard COM and SendMessage pumping. This method has different overloaded forms.</p>

<p>Synchronizes memory access as follows: The processor executing the current thread cannot reorder instructions in such a way that memory accesses prior to the call to MemoryBarrier execute after memory accesses that follow the call to MemoryBarrier.</p>

<p>Cancels an Abort requested for the current thread.</p>

<p>Sets the data in the specified slot on the currently running thread, for that thread's current domain. For better performance, use fields marked with the ThreadStaticAttribute attribute instead.</p>

<p>Starts a thread.</p>

<p>Makes the thread pause for a period of time.</p>

<p>Causes a thread to wait the number of times defined by the iterations parameter</p>

<p><b>public static byte VolatileRead(ref byte address)</b></p>

<p><b>public static double VolatileRead(ref double address)</b></p>

<p><b>public static int VolatileRead(ref int address)</b></p>

<p><b>public static Object VolatileRead(ref Object address)</b></p>

<p>Reads the value of a field. The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache. This method has different overloaded forms. Only some are given above.</p>

<p><b>public static void VolatileWrite(ref byte address,byte value)</b></p>

<p><b>public static void VolatileWrite(ref double address, double value)</b></p>

<p><b>public static void VolatileWrite(ref int address, int value)</b></p>

<p><b>public static void VolatileWrite(ref Object address, Object value)</b></p>

<p>Writes a value to a field immediately, so that the value is visible to all processors in the computer. This method has different overloaded forms. Only some are given above. </p>

<p>Causes the calling thread to yield execution to another thread that is ready to run on the current processor. The operating system selects the thread to yield to.</p>

<h2>Creating Threads</h2>

<p>Threads are created by extending the Thread class. The extended Thread class then calls the <b>Start()</b> method to begin the child thread execution.</p>

<p>The following program demonstrates the concept:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Managing Threads</h2>

<p>The Thread class provides various methods for managing threads.</p>

<p>The following example demonstrates the use of the <b>sleep()</b> method for making a thread pause for a specific period of time.</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Destroying Threads</h2>

<p>The <b>Abort()</b> method is used for destroying threads.</p>

<p>The runtime aborts the thread by throwing a <b>ThreadAbortException</b>. This exception cannot be caught, the control is sent to the <i>finally</i> block, if any.</p>

<p>The following program illustrates this:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate tryit">
using System;
namespace HelloWorldApplication
{
   class HelloWorld
   {
      static void Main(string[] args)
      {
         /* my first program in C# */
         Console.WriteLine("Hello World");
         Console.ReadKey();
      }
   }
}
</pre>
<p>When this code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Hello World
</pre>
<p>Let us look at the various parts of the given program:</p>
<ul class="list">
<li><p>The first line of the program <b>using System;</b> -  the <b>using</b> keyword is used to include the <b>System </b> namespace in the program. A program generally has multiple <b>using</b> statements.</p></li>
<li><p>The next line has the <b>namespace</b> declaration. A <b>namespace</b> is a collection of classes. The <i>HelloWorldApplication</i> namespace contains the class <i>HelloWorld</i>.</p></li>
<li><p>The next line has a <b>class</b> declaration, the class <i>HelloWorld</i> contains the data and method definitions that your program uses. Classes generally contain multiple methods. Methods define the behavior of the class. However, the <i>HelloWorld</i> class has only one method <b> Main</b>.</p></li>
<li><p>The next line defines the <b>Main</b> method, which is the <b>entry point</b> for all C# programs. The <b>Main </b> method states what the class does when executed.</p></li>
<li><p>The next line /*...*/ is ignored by the compiler and it is put to add <b> comments</b> in the program.</p></li>
<li><p>The Main method specifies its behavior with the statement <b>Console.WriteLine("Hello World");</b>
<p><i>WriteLine</i> is a method of the <i>Console</i> class defined in the <i>System</i> namespace. This statement causes the message "Hello, World!" to be displayed on the screen.</p>
</p></li>
<li><p>The last line <b>Console.ReadKey();</b> is for the VS.NET Users. This makes the program wait for a key press and it prevents the screen from running and closing quickly when the program is launched from Visual Studio .NET.</p></li>
</ul>
<p>It is worth to note the following points:</p>
<ul class="list">
<li><p>C# is case sensitive.</p></li>
<li><p>All statements and expression must end with a semicolon (;).</p></li>
<li><p>The program execution starts at the Main method.</p></li>
<li><p>Unlike Java, program file name could be different from the class name.</p></li>
</ul>
<h2>Compiling and Executing the Program</h2>
<p>If you are using Visual Studio.Net for compiling and executing C# programs, take the following steps:</p>
<ul class="list">
<li><p>Start Visual Studio.</p></li>
<li><p>On the menu bar, choose File -&gt; New -&gt; Project.</p></li>
<li><p>Choose Visual C# from templates, and then choose Windows.</p></li>
<li><p>Choose Console Application.</p></li>
<li><p>Specify a name for your project and click OK button.</p></li>
<li><p>This creates a new project in Solution Explorer.</p></li>
<li><p>Write code in the Code Editor. </p></li>
<li><p>Click the Run button or press F5 key to execute the project. A Command Prompt window appears that contains the line Hello World.</p></li>
</ul>
<p>You can compile a C# program by using the command-line instead of the Visual Studio IDE:</p>
<ul class="list">
<li><p>Open a text editor and add the above-mentioned code.</p></li>
<li><p>Save the file as <b>helloworld.cs</b></p></li>
<li><p>Open the command prompt tool and go to the directory where you saved the file.</p></li>
<li><p>Type <b>csc helloworld.cs</b> and press enter to compile your code.</p></li>
<li><p>If there are no errors in your code, the command prompt takes you to the next line and generates <b>helloworld.exe</b> executable file.</p></li>
<li><p>Type <b>helloworld</b> to execute your program.</p></li>
<li><p>You can see the output Hello World printed on the screen.</p></li>
</ul>
<h1>C# - Basic Syntax</h1>
<p>C# is an object-oriented programming language. In Object-Oriented Programming methodology, a program consists of various objects that interact with each other by means of actions. The actions that an object may take are called methods. Objects of the same kind are said to have the same type or, are said to be in the same class.</p>
<p>For example, let us consider a Rectangle object. It has attributes such as length and width. Depending upon the design, it may need ways for accepting the values of these attributes, calculating the area, and displaying details.</p>
<p>Let us look at implementation of a Rectangle class and discuss C# basic syntax:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace RectangleApplication
{
   class Rectangle 
   {
      // member variables
      double length;
      double width;
      public void Acceptdetails()
      {
         length = 4.5;    
         width = 3.5;
      }
      
      public double GetArea()
      {
         return length * width; 
      }
      
      public void Display()
      {
         Console.WriteLine("Length: {0}", length);
         Console.WriteLine("Width: {0}", width);
         Console.WriteLine("Area: {0}", GetArea());
      }
   }
   
   class ExecuteRectangle 
   {
      static void Main(string[] args) 
      {
         Rectangle r = new Rectangle();
         r.Acceptdetails();
         r.Display();
         Console.ReadLine(); 
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Length: 4.5
Width: 3.5
Area: 15.75
</pre>
<h2>The <i>using</i> Keyword</h2>
<p>The first statement in any C# program is</p>
<pre class="prettyprint notranslate">
using System;
</pre>
<p>The <b>using</b> keyword is used for including the namespaces in the program. A program can include multiple using statements.</p>
<h2>The <i>class</i> Keyword</h2>
<p>The <b>class</b> keyword is used for declaring a class.</p> 
<h2>Comments in C#</h2>
<p>Comments are used for explaining code. Compilers ignore the comment entries. The multiline comments in C# programs start with /* and terminates with the characters */ as shown below:</p>
<pre class="prettyprint notranslate">
/* This program demonstrates
The basic syntax of C# programming 
Language */
</pre>
<p>Single-line comments are indicated by the '//' symbol. For example,</p>
<pre class="prettyprint notranslate">
}//end class Rectangle    
</pre>
<h2>Member Variables</h2>
<p>Variables are attributes or data members of a class, used for storing data. In the preceding program, the <i>Rectangle</i> class has two member variables named <i>length</i> and <i>width</i>.</p> 
<h2>Member Functions</h2>
<p>Functions are set of statements that perform a specific task. The member functions of a class are declared within the class. Our sample class Rectangle contains three member functions: <i> AcceptDetails</i>, <i>GetArea</i> and <i>Display</i>.</p> 
<h2>Instantiating a Class</h2>
<p>In the preceding program, the class <i>ExecuteRectangle</i> contains the <i>Main()</i>  method and instantiates the <i>Rectangle</i> class.</p>
<h2>Identifiers</h2>
<p>An identifier is a name used to identify a class, variable, function, or any other user-defined item. The basic rules for naming classes in C# are as follows:</p>
<ul class="list">
<li><p>A name must begin with a letter that could be followed by a sequence of letters, digits (0 - 9) or underscore. The first character in an identifier cannot be a digit.</p></li>
<li><p>It must not contain any embedded space or symbol such as? - + ! @ # % ^ & * ( ) [ ] { } . ; : " ' / and \. However, an underscore ( _ ) can be used.</p></li>
<li><p>It should not be a C# keyword.</p></li>
</ul>
<h2>C# Keywords</h2>
<p>Keywords are reserved words predefined to the C# compiler. These keywords cannot be used as identifiers. However, if you want to use these keywords as identifiers, you may prefix the keyword with the @ character.</p> 
<p>In C#, some identifiers have special meaning in context of code, such as get and set are called contextual keywords.</p>
<p>The following table lists the reserved keywords and contextual keywords in C#:</p>
<table class="table table-bordered">
<tr>
<th colspan="7">Reserved Keywords</th>
</tr>
<tr>
<td>abstract</td>
<td>as</td>
<td>base</td>
<td>bool</td>
<td>break</td>
<td>byte</td>
<td>case</td>
</tr>
<tr>
<td>catch</td>
<td>char</td>
<td>checked</td>
<td>class</td>
<td>const</td>
<td>continue</td>
<td>decimal</td>
</tr>
<tr>
<td>default</td>
<td>delegate</td>
<td>do</td>
<td>double</td>
<td>else</td>
<td>enum</td>
<td>event</td>
</tr>
<tr>
<td>explicit</td>
<td>extern</td>
<td>false</td>
<td>finally</td>
<td>fixed</td>
<td>float</td>
<td>for</td>
</tr>
<tr>
<td>foreach</td>
<td>goto</td>
<td>if</td>
<td>implicit</td>
<td>in</td>
<td>in (generic modifier)</td>
<td>int</td>
</tr>
<tr>
<td>interface</td>
<td>internal</td>
<td>is</td>
<td>lock</td>
<td>long</td>
<td>namespace</td>
<td>new</td>
</tr>
<tr>
<td>null</td>
<td>object</td>
<td>operator</td>
<td>out</td>
<td>out (generic modifier)</td>
<td>override</td>
<td>params</td>
</tr>
<tr>
<td>private</td>
<td>protected</td>
<td>public</td>
<td>readonly</td>
<td>ref</td>
<td>return</td>
<td>sbyte</td>
</tr>
<tr>
<td>sealed</td>
<td>short</td>
<td>sizeof</td>
<td>stackalloc</td>
<td>static</td>
<td>string</td>
<td>struct</td>
</tr>
<tr>
<td>switch</td>
<td>this</td>
<td>throw</td>
<td>true</td>
<td>try</td>
<td>typeof</td>
<td>uint</td>
</tr>
<tr>
<td>ulong</td>
<td>unchecked</td>
<td>unsafe</td>
<td>ushort</td>
<td>using</td>
<td>virtual</td>
<td>void</td>
</tr>
<tr>
<td>volatile</td>
<td>while</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<th colspan = "7">Contextual Keywords</th>
</tr>
<tr>
<td>add</td>
<td>alias</td>
<td>ascending</td>
<td>descending</td>
<td>dynamic</td>
<td>from</td>
<td>get</td>
</tr>
<tr>
<td>global</td>
<td>group</td>
<td>into</td>
<td>join</td>
<td>let</td>
<td>orderby</td>
<td>partial (type)</td>
</tr>
<tr>
<td>partial<br> (method)</td>
<td>remove</td>
<td>select</td>
<td>set</td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
<h1>C# - Data Types</h1>
<p>The variables in C#, are categorized into the following types:</p>
<ul class="list">
<li>Value types</li>
<li>Reference types</li>
<li>Pointer types</li>
</ul>
<h2>Value Type</h2>
<p>Value type variables can be assigned a value directly. They are derived from the class <b> System.ValueType</b>.</p>
<p>The value types directly contain data. Some examples are <b>int, char, and float</b>, which stores numbers, alphabets, and floating point numbers, respectively. When you declare an <b>int</b> type, the system allocates memory to store the value.</p>
<p>The following table lists the available value types in C# 2010:</p>
<table class="table table-bordered">
<tr>
<th style="width:10%;">Type</th>
<th style="width:35%;">Represents</th>
<th style="width:45%;">Range</th>
<th style="width:10%;">Default Value</th>
</tr>
<tr>
<td>bool</td>
<td>Boolean value</td>
<td>True or False</td>
<td>False</td>
</tr>
<tr>
<td>byte</td>
<td>8-bit unsigned integer</td>
<td>0 to 255</td>
<td>0</td>
</tr>
<tr>
<td>char</td>
<td>16-bit Unicode character</td>
<td>U +0000 to U +ffff</td>
<td>'\0'</td>
</tr>
<tr>
<td>decimal</td>
<td>128-bit precise decimal values with 28-29 significant digits</td>
<td>(-7.9 x 10<sup>28</sup> to 7.9 x 10<sup>28</sup>) 
/ 10<sup>0 to 28</sup>
</td>
<td>0.0M</td>
</tr>
<tr>
<td>double</td>
<td>64-bit double-precision floating point type</td>
<td>(+/-)5.0 x 10<sup>-324</sup> to (+/-)1.7 x 10<sup>308</sup></td>
<td>0.0D</td>
</tr>
<tr>
<td>float</td>
<td>32-bit single-precision floating point type</td>
<td>-3.4 x 10<sup>38</sup> to + 3.4 x 10<sup>38</sup></td>
<td>0.0F</td>
</tr>
<tr>
<td>int</td>
<td>32-bit signed integer type</td>
<td>-2,147,483,648 to 2,147,483,647</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>64-bit signed integer type</td>
<td>-923,372,036,854,775,808 to 
9,223,372,036,854,775,807
</td>
<td>0L</td>
</tr>
<tr>
<td>sbyte</td>
<td>8-bit signed integer type</td>
<td>-128 to 127</td>
<td>0</td>
</tr>
<tr>
<td>short</td>
<td>16-bit signed integer type</td>
<td>-32,768 to 32,767</td>
<td>0</td>
</tr>
<tr>
<td>uint</td>
<td>32-bit unsigned integer type</td>
<td>0 to 4,294,967,295</td>
<td>0</td>
</tr>
<tr>
<td>ulong</td>
<td>64-bit unsigned integer type</td>
<td>0 to 18,446,744,073,709,551,615</td>
<td>0</td>
</tr>
<tr>
<td>ushort</td>
<td>16-bit unsigned integer type</td>
<td>0 to 65,535</td>
<td>0</td>
</tr>
</table>
<p>To get the exact size of a type or a variable on a particular platform, you can use the <b>sizeof</b> method. The expression <i>sizeof(type)</i> yields the storage size of the object or type in bytes. Following is an example to get the size of <i>int</i> type on any machine:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace DataTypeApplication
{
   class Program 
   {
      static void Main(string[] args)
      {
         Console.WriteLine("Size of int: {0}", sizeof(int));
         Console.ReadLine();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Size of int: 4
</pre>
<h2>Reference Type</h2>
<p>The reference types do not contain the actual data stored in a variable, but they contain a reference to the variables.</p>
<p>In other words, they refer to a memory location. Using multiple variables, the reference types can refer to a memory location. If the data in the memory location is changed by one of the variables, the other variable automatically reflects this change in value. Example of <b>built-in</b> reference types are: <b>object</b>, <b>dynamic,</b> and <b>string</b>.</p>
<h3>Object Type</h3>
<p>The <b>Object Type</b> is the ultimate base class for all data types in C# Common Type System (CTS). Object is an alias for System.Object class. The object types can be assigned values of any other types, value types, reference types, predefined or user-defined types. However, before assigning values, it needs type conversion.</p>
<p>When a value type is converted to object type, it is called <b>boxing</b> and on the other hand, when an object type is converted to a value type, it is called <b>unboxing</b>.</p>
<pre class="prettyprint notranslate">
object obj;
obj = 100; // this is boxing
</pre>
<h3>Dynamic Type</h3>
<p>You can store any type of value in the dynamic data type variable. Type checking for these types of variables takes place at run-time.</p>
<p>Syntax for declaring a dynamic type is:</p>
<pre class="prettyprint notranslate">
dynamic &lt;variable_name&gt; = value;
</pre>
<p>For example,</p>
<pre class="prettyprint notranslate">
dynamic d = 20;
</pre>
<p>Dynamic types are similar to object types except that type checking for object type variables takes place at compile time, whereas that for the dynamic type variables takes place at run time.</p>
<h3>String Type</h3>
<p>The <b>String Type</b> allows you to assign any string values to a variable. The string type is an alias for the System.String class. It is derived from object type. The value for a string type can be assigned using string literals in two forms: quoted and @quoted.</p> 
<p>For example,</p>
<pre class="prettyprint notranslate">
String str = "Tutorials Point";
</pre>
<p>A @quoted string literal looks as follows:</p>
<pre class="prettyprint notranslate">
@"Tutorials Point";
</pre>
<p>The user-defined reference types are: class, interface, or delegate. We will discuss these types in later chapter.</p>
<h2>Pointer Type</h2>
<p>Pointer type variables store the memory address of another type. Pointers in C# have the same capabilities as the pointers in C or C++.</p>
<p>Syntax for declaring a pointer type is:</p>
<pre class="prettyprint notranslate">
type* identifier;
</pre>
<p>For example,</p>
<pre class="prettyprint notranslate">
char* cptr;
int* iptr;
</pre>
<p>We will discuss pointer types in the chapter 'Unsafe Codes'. 
<h1>C# - Type Conversion</h1>
<p>Type conversion is converting one type of data to another type. It is also known as Type Casting. In C#, type casting has two forms:</p>
<ul class="list">
<li><p><b>Implicit type conversion</b> - These conversions are performed by C# in a type-safe manner. For example, are conversions from smaller to larger integral types and conversions from derived classes to base classes.</p></li>
<li><p><b>Explicit type conversion</b> - These conversions are done explicitly by users using the pre-defined functions. Explicit conversions require a cast operator.</p></li>
</ul>
<p>The following example shows an explicit type conversion:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace TypeConversionApplication 
{
   class ExplicitConversion 
   {
      static void Main(string[] args) 
      {
         double d = 5673.74; 
         int i;
         
         // cast double to int.
         i = (int)d;
         Console.WriteLine(i);
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
5673
</pre>
<h2>C# Type Conversion Methods</h2>
<p>C# provides the following built-in type conversion methods:</p>
<table class="table table-bordered">
<tr>
<th style="width:5%;">Sr.No</th>
<th>Methods &amp; Description</th>
</tr>
<tr>
<td>1</td>
<td><b>ToBoolean</b>
<p>Converts a type to a Boolean value, where possible.</p>
</td>
</tr>
<tr>
<td>2</td>
<td><b>ToByte</b>
<p>Converts a type to a byte.</p>
</td>
</tr>
<tr>
<td>3</td>
<td><b>ToChar</b>
<p>Converts a type to a single Unicode character, where possible.</p>
</td>
</tr>
<tr>
<td>4</td>
<td><b>ToDateTime</b>
<p>Converts a type (integer or string type) to date-time structures.</p>
</td>
</tr>
<tr>
<td>5</td>
<td><b>ToDecimal</b>
<p>Converts a floating point or integer type to a decimal type.</p>
</td>
</tr>
<tr>
<td>6</td>
<td><b>ToDouble</b>
<p>Converts a type to a double type.</p>
</td>
</tr>
<tr>
<td>7</td>
<td><b>ToInt16</b>
<p>Converts a type to a 16-bit integer.</p>
</td>
</tr>
<tr>
<td>8</td>
<td><b>ToInt32</b>
<p>Converts a type to a 32-bit integer.</p>
</td>
</tr>
<tr>
<td>9</td>
<td><b>ToInt64</b>
<p>Converts a type to a 64-bit integer.</p>
</td>
</tr>
<tr>
<td>10</td>
<td><b>ToSbyte</b>
<p>Converts a type to a signed byte type.</p>
</td>
</tr>
<tr>
<td>11</td>
<td><b>ToSingle</b>
<p>Converts a type to a small floating point number.</p>
</td>
</tr>
<tr>
<td>12</td>
<td><b>ToString</b>
<p>Converts a type to a string.</p>
</td>
</tr>
<tr>
<td>13</td>
<td><b>ToType</b>
<p>Converts a type to a specified type.</p>
</td>
</tr>
<tr>
<td>14</td>
<td><b>ToUInt16</b>
<p>Converts a type to an unsigned int type.</p>
</td>
</tr>
<tr>
<td>15</td>
<td><b>ToUInt32</b>
<p>Converts a type to an unsigned long type.</p>
</td>
</tr>
<tr>
<td>16</td>
<td><b>ToUInt64</b>
<p>Converts a type to an unsigned big integer.</p>
</td>
</tr>
</table>
<p>The following example converts various value types to string type:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace TypeConversionApplication 
{
   class StringConversion
   {
      static void Main(string[] args)
      {
         int i = 75;
         float f = 53.005f;
         double d = 2345.7652;
         bool b = true;

         Console.WriteLine(i.ToString());
         Console.WriteLine(f.ToString());
         Console.WriteLine(d.ToString());
         Console.WriteLine(b.ToString());
         Console.ReadKey();
            
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
75
53.005
2345.7652
True
</pre>
<h1>C# - Variables</h1>
<p>A variable is nothing but a name given to a storage area that our programs can manipulate. Each variable in C# has a specific type, which determines the size and layout of the variable's memory the range of values that can be stored within that memory and the set of operations that can be applied to the variable.</p>
<p>The basic value types provided in C# can be categorized as:</p>
<table class="table table-bordered">
<tr>
<th style="width:25%;">Type</th>
<th>Example</th>
</tr>
<tr>
<td>Integral types</td>
<td>sbyte, byte, short, ushort, int, uint, long, ulong, and char</td>
</tr>
<tr>
<td>Floating point types</td>
<td>float and double</td>
</tr>
<tr>
<td>Decimal types</td>
<td>decimal</td>
</tr>
<tr>
<td>Boolean types</td>
<td>true or false values, as assigned</td>
</tr>
<tr>
<td>Nullable types</td>
<td>Nullable data types</td>
</tr>
</table>
<p>C# also allows defining other value types of variable such as <b>enum</b> and reference types of variables such as <b> class</b>, which we will cover in subsequent chapters.</p>
<h2>Defining Variables</h2>
<p>Syntax for variable definition in C# is:</p>
<pre class="prettyprint notranslate">
&lt;data_type&gt; &lt;variable_list&gt;;
</pre>
<p>Here, data_type must be a valid C# data type including char, int, float, double, or any user-defined data type, and variable_list may consist of one or more identifier names separated by commas.</p>
<p>Some valid variable definitions are shown here:</p>
<pre class="prettyprint notranslate">
int i, j, k;
char c, ch;
float f, salary;
double d;
</pre>
<p>You can initialize a variable at the time of definition as:</p>
<pre class="prettyprint notranslate">
int i = 100;
</pre>
<h2>Initializing Variables</h2>
<p>Variables are initialized (assigned a value) with an equal sign followed by a constant expression. The general form of initialization is:</p>
<pre class="prettyprint notranslate">
variable_name = value;
</pre>
<p>Variables can be initialized in their declaration. The initializer consists of an equal sign followed by a constant expression as:</p>
<pre class="prettyprint notranslate">
&lt;data_type&gt; &lt;variable_name&gt; = value;
</pre>
<p>Some examples are:</p>
<pre class="prettyprint notranslate">
int d = 3, f = 5;    /* initializing d and f. */
byte z = 22;         /* initializes z. */
double pi = 3.14159; /* declares an approximation of pi. */
char x = 'x';        /* the variable x has the value 'x'. */
</pre>
<p>It is a good programming practice to initialize variables properly, otherwise sometimes program may produce unexpected result.</p>
<p>The following example uses various types of variables:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace VariableDefinition 
{
   class Program 
   {
      static void Main(string[] args) 
      {
         short a;
         int b ;
         double c;

         /* actual initialization */
         a = 10;
         b = 20;
         c = a + b;
         Console.WriteLine("a = {0}, b = {1}, c = {2}", a, b, c);
         Console.ReadLine();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
a = 10, b = 20, c = 30
</pre>
<h2>Accepting Values from User</h2>
<p>The <b>Console</b> class in the <b>System</b> namespace provides a function <b>ReadLine()</b> for accepting input from the user and store it into a variable.</p> 
<p>For example,</p>
<pre class="prettyprint notranslate">
int num;
num = Convert.ToInt32(Console.ReadLine());
</pre>
<p>The function <b>Convert.ToInt32()</b> converts the data entered by the user to int data type, because <b>Console.ReadLine()</b> accepts the data in string format.</p>
<h2>Lvalue and Rvalue Expressions in C#:</h2>
<p>There are two kinds of expressions in C#:</p>
<ul class="list">
<li><p><b>lvalue:</b> An expression that is an lvalue may appear as either the left-hand or right-hand side of an assignment.</p></li>
<li><p><b>rvalue:</b> An expression that is an rvalue may appear on the right- but not left-hand side of an assignment.</p></li>
</ul>
<p>Variables are lvalues and hence they may appear on the left-hand side of an assignment. Numeric literals are rvalues and hence they may not be assigned and can not appear on the left-hand side. Following is a valid C# statement:</p>
<pre class="prettyprint notranslate">
int g = 20;
</pre>
<p>But following is not a valid statement and would generate compile-time error:</p>
<pre class="prettyprint notranslate">
10 = 20;
</pre>
<h1>C# - Constants and Literals</h1>
<p>The constants refer to fixed values that the program may not alter during its execution. These fixed values are also called literals. Constants can be of any of the basic data types like an integer constant, a floating constant, a character constant, or a string literal. There are also enumeration constants as well.</p>
<p>The constants are treated just like regular variables except that their values cannot be modified after their definition.</p>
<h2>Integer Literals</h2>
<p>An integer literal can be a decimal, octal, or hexadecimal constant. A prefix specifies the base or radix: 0x or 0X for hexadecimal, 0 for octal, and no prefix id for decimal.</p>
<p>An integer literal can also have a suffix that is a combination of U and L, for unsigned and long, respectively. The suffix can be uppercase or lowercase and can be in any order.</p>
<p>Here are some examples of integer literals:</p>
<pre class="prettyprint notranslate">
212         /* Legal */
215u        /* Legal */
0xFeeL      /* Legal */
078         /* Illegal: 8 is not an octal digit */
032UU       /* Illegal: cannot repeat a suffix */
</pre>
<p>Following are other examples of various types of Integer literals:</p>
<pre class="prettyprint notranslate">
85         /* decimal */
0213       /* octal */
0x4b       /* hexadecimal */
30         /* int */
30u        /* unsigned int */
30l        /* long */
30ul       /* unsigned long */
</pre>
<h2>Floating-point Literals</h2>
<p>A floating-point literal has an integer part, a decimal point, a fractional part, and an exponent part. You can represent floating point literals either in decimal form or exponential form.</p>
<p>Here are some examples of floating-point literals:</p>
<pre class="prettyprint notranslate">
3.14159       /* Legal */
314159E-5F    /* Legal */
510E          /* Illegal: incomplete exponent */
210f          /* Illegal: no decimal or exponent */
.e55          /* Illegal: missing integer or fraction */
</pre>
<p>While representing in decimal form, you must include the decimal point, the exponent, or both; and while representing using exponential form you must include the integer part, the fractional part, or both. The signed exponent is introduced by e or E.</p>
<h2>Character Constants</h2>
<p>Character literals are enclosed in single quotes. For example, 'x' and can be stored in a simple variable of char type. A character literal can be a plain character (such as 'x'), an escape sequence (such as '\t'), or a universal character (such as '\u02C0').</p>
<p>There are certain characters in C# when they are preceded by a backslash. They have special meaning and they are used to represent like newline (\n) or tab (\t). Here, is a list of some of such escape sequence codes:</p>
<table class="table table-bordered">
<tr>
<th style="width:25%">Escape sequence</th>
<th>Meaning</th>
</tr>
<tr>
<td>\\</td>
<td>\ character</td>
</tr>
<tr>
<td>\'</td>
<td> ' character</td>
</tr>
<tr>
<td>\"</td>
<td>" character</td>
</tr>
<tr>
<td>\?</td>
<td>? character</td>
</tr>
<tr>
<td>\a</td>
<td>Alert or bell</td>
</tr>
<tr>
<td>\b</td>
<td>Backspace</td>
</tr>
<tr>
<td>\f</td>
<td>Form feed</td></tr>
<tr>
<td>\n</td>
<td>Newline</td>
</tr>
<tr>
<td>\r</td>
<td>Carriage return</td>
</tr>
<tr>
<td>\t</td>
<td>Horizontal tab</td>
</tr>
<tr>
<td>\v</td>
<td>Vertical tab</td>
</tr>
<tr>
<td>\ooo</td>
<td>Octal number of one to three digits</td>
</tr>
<tr>
<td>\xhh . . .</td>
<td>Hexadecimal number of one or more digits</td>
</tr>
</table>
<p>Following is the example to show few escape sequence characters:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace EscapeChar 
{
   class Program
   {
      static void Main(string[] args)
      {
         Console.WriteLine("Hello\tWorld\n\n");
         Console.ReadLine();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Hello   World
</pre>
<h2>String Literals</h2>
<p>String literals or constants are enclosed in double quotes "" or with @"". A string contains characters that are similar to character literals: plain characters, escape sequences, and universal characters.</p>
<p>You can break a long line into multiple lines using string literals and separating the parts using whitespaces.</p>
<p>Here are some examples of string literals. All the three forms are identical strings.</p>
<pre class="prettyprint notranslate">
"hello, dear"
"hello, \
dear"
"hello, " "d" "ear"
@"hello dear"
</pre>
<h2>Defining Constants</h2>
<p>Constants are defined using the <b>const</b> keyword. Syntax for defining a constant is:</p>
<pre class="prettyprint notranslate">
const &lt;data_type&gt; &lt;constant_name&gt; = value;
</pre>
<p>The following program demonstrates defining and using a constant in your program:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace DeclaringConstants
{
    class Program
    {
        static void Main(string[] args)
        {
            const double pi = 3.14159;   
            
            // constant declaration 
            double r;
            Console.WriteLine("Enter Radius: ");
            r = Convert.ToDouble(Console.ReadLine());
            double areaCircle = pi * r * r;
            Console.WriteLine("Radius: {0}, Area: {1}", r, areaCircle);
            Console.ReadLine();
        }
    }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Enter Radius: 
3
Radius: 3, Area: 28.27431
</pre>
<h1>C# - Operators</h1>
<p>An operator is a symbol that tells the compiler to perform specific mathematical or logical manipulations. C# has rich set of built-in operators and provides the following type of operators:</p>
<ul class="list">
<li>Arithmetic Operators</li>
<li>Relational Operators</li>
<li>Logical Operators</li>
<li>Bitwise Operators</li>
<li>Assignment Operators</li>
<li>Misc Operators</li>
</ul>
<p>This tutorial explains the arithmetic, relational, logical, bitwise, assignment, and other operators one by one.</p>
<h2>Arithmetic Operators</h2>
<p>Following table shows all the arithmetic operators supported by C#. Assume variable <b>A</b> holds 10 and variable <b>B</b> holds 20 then:</p>
<p><a href="/csharp/csharp_arithmetic_operators.htm" title="Arithmetic Operators in C#">Show Examples</a></p>
<table class="table table-bordered">
<tr>
<th style="width:10%">Operator</th>
<th style="width:55%;">Description</th>
<th>Example</th>
</tr>
<tr>
<td>+</td>
<td>Adds two operands</td>
<td>A + B = 30</td>
</tr>
<tr>
<td>-</td>
<td>Subtracts second operand from the first</td>
<td>A - B = -10</td>
</tr>
<tr>
<td>*</td>
<td>Multiplies both operands</td>
<td>A * B = 200</td>
</tr>
<tr>
<td>/</td>
<td>Divides numerator by de-numerator</td>
<td>B / A = 2</td>
</tr>
<tr>
<td>%</td>
<td>Modulus Operator and remainder of after an integer division</td>
<td>B % A = 0</td>
</tr>
<tr>
<td>++</td>
<td>Increment operator increases integer value by one</td>
<td>A++ = 11</td>
</tr>
<tr>
<td>--</td>
<td>Decrement operator decreases integer value by one</td>
<td>A-- = 9</td>
</tr>
</table>
<h2>Relational Operators</h2>
<p>Following table shows all the relational operators supported by C#. Assume variable <b>A</b> holds 10 and variable <b>B</b> holds 20, then:</p>
<p><a href="/csharp/csharp_relational_operators.htm" title="Relational Operators in C#">Show Examples</a></p>
<table class="table table-bordered">
<tr>
<th style="width:10%">Operator</th>
<th style="width:55%;">Description</th>
<th>Example</th>
</tr>
<tr>
<td>==</td>
<td>Checks if the values of two operands are equal or not, if yes then condition becomes true.</td>
<td>(A == B) is not true.</td>
</tr>
<tr>
<td>!=</td>
<td>Checks if the values of two operands are equal or not, if values are not equal then condition becomes true.</td>
<td>(A != B) is true.</td>
</tr>
<tr>
<td>&gt;</td>
<td>Checks if the value of left  operand is greater than the value of right operand, if yes then condition becomes true.</td>
<td>(A &gt; B) is not true. </td>
</tr>
<tr>
<td>&lt;</td>
<td>Checks if the value of left operand is less than the value of right operand, if yes then condition becomes true.</td>
<td>(A &lt; B) is true.</td>
</tr>
<tr>
<td>&gt;=</td>
<td>Checks if the value of left operand is greater than or equal to the value of right operand, if yes then condition becomes true.</td>
<td>(A &gt;= B) is not true.</td>
</tr>
<tr>
<td>&lt;=</td>
<td>Checks if the value of left operand is less than or equal to the value of right operand, if yes then condition becomes true.</td>
<td>(A &lt;= B) is true.</td>
</tr>
</table>
<h2>Logical Operators</h2>
<p>Following table shows all the logical operators supported by C#. Assume variable <b>A</b> holds Boolean value true and variable <b>B</b> holds Boolean value false, then:</p>
<p><a href="/csharp/csharp_logical_operators.htm" title="Logical Operators in C#">Show Examples</a></p>
<table class="table table-bordered">
<tr>
<th style="width:10%">Operator</th>
<th style="width:55%;">Description</th>
<th>Example</th>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>Called Logical AND operator. If both the operands are non zero then condition becomes true.</td>
<td>(A &amp;&amp; B) is false.</td>
</tr>
<tr>
<td>||</td>
<td>Called Logical OR Operator. If any of the two operands is non zero then condition becomes true.</td>
<td>(A || B) is true.</td>
</tr>
<tr>
<td>!</td>
<td>Called Logical NOT Operator. Use to reverses the logical state of its operand. If a condition is true then Logical NOT operator will make false.</td>
<td>!(A &amp;&amp; B) is true.</td>
</tr>
</table>
<h2>Bitwise Operators</h2>
<p>Bitwise operator works on bits and perform bit by bit operation. The truth tables for &amp;, |, and ^ are as follows:</p>
<table class="table table-bordered">
<tr>
<th style="width:20%">p</th>
<th style="width:20%">q</th>
<th style="width:20%">p &amp; q</th>
<th style="width:20%">p | q</th>
<th style="width:20%">p ^ q</th>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
</table>
<p>Assume if A = 60; and B = 13; then in the binary format they are as follows:</p>
<p>A = 0011 1100</p>
<p>B = 0000 1101</p>
<p>-----------------</p>
<p>A&amp;B = 0000 1100</p>
<p>A|B = 0011 1101</p>
<p>A^B = 0011 0001</p>
<p>~A&nbsp; = 1100 0011</p>
<p>The Bitwise operators supported by C# are listed in the following table. Assume variable A holds 60 and variable B holds 13, then:</p>
<p><a href="/csharp/csharp_bitwise_operators.htm" title="Bitwise Operators in C#">Show Examples</a></p>
<table class="table table-bordered">
<tr>
<th style="width:10%">Operator</th>
<th style="width:55%;">Description</th>
<th>Example</th>
</tr>
<tr>
<td>&amp;</td>
<td>Binary AND Operator copies a bit to the result if it exists in both operands.</td>
<td>(A &amp; B) = 12, which is 0000 1100</td>
</tr>
<tr>
<td>|</td>
<td>Binary OR Operator copies a bit if it exists in either operand.</td>
<td>(A | B) = 61, which is 0011 1101</td>
</tr>
<tr>
<td>^</td>
<td>Binary XOR Operator copies the bit if it is set in one operand but not both.</td>
<td>(A ^ B) = 49, which is 0011 0001</td>
</tr>
<tr>
<td>~</td>
<td>Binary Ones Complement Operator is unary and has the effect of 'flipping' bits.</td>
<td>(~A ) = 61, which is 1100 0011 in 2's complement due to a signed binary number.</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>Binary Left Shift Operator. The left operands value is moved left by the number of bits specified by the right operand.</td>
<td>A &lt;&lt; 2 = 240, which is 1111 0000</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>Binary Right Shift Operator. The left operands value is moved right by the number of bits specified by the right operand.</td>
<td>A &gt;&gt; 2 = 15, which is 0000 1111</td>
</tr>
</table>
<h2>Assignment Operators</h2>
<p>There are following assignment operators supported by C#:</p>
<p><a href="/csharp/csharp_assignment_operators.htm" title="Assignment Operators in C#">Show Examples</a></p>
<table class="table table-bordered">
<tr>
<th style="width:10%">Operator</th>
<th style="width:55%;">Description</th>
<th>Example</th>
</tr>
<tr>
<td>=</td>
<td>Simple assignment operator, Assigns values from right side operands to left side operand</td>
<td>C = A + B assigns value of A + B into C</td>
</tr>
<tr>
<td>+=</td>
<td>Add AND assignment operator, It adds right operand to the left operand and assign the result to left operand</td>
<td>C += A is equivalent to C = C + A</td>
</tr>
<tr>
<td>-=</td>
<td>Subtract AND assignment operator, It subtracts right operand from the left operand and assign the result to left operand</td>
<td>C -= A is equivalent to C = C - A</td>
</tr>
<tr>
<td>*=</td>
<td>Multiply AND assignment operator, It multiplies right operand with the left operand and assign the result to left operand</td>
<td>C *= A is equivalent to C = C * A</td>
</tr>
<tr>
<td>/=</td>
<td>Divide AND assignment operator, It divides left operand with the right operand and assign the result to left operand</td>
<td> C /= A is equivalent to C = C / A</td>
</tr>
<tr>
<td>%=</td>
<td>Modulus AND assignment operator, It takes modulus using two operands and assign the result to left operand</td>
<td>C %= A is equivalent to C = C % A</td>
</tr>
<tr>
<td>&lt;&lt;=</td>
<td>Left shift AND assignment operator</td>
<td>C &lt;&lt;= 2 is same as  C = C &lt;&lt; 2</td>
</tr>
<tr>
<td>&gt;&gt;=</td>
<td>Right shift AND assignment operator</td>
<td>C &gt;&gt;= 2 is same as  C = C &gt;&gt; 2</td>
</tr>
<tr>
<td>&amp;=</td>
<td>Bitwise AND assignment operator</td>
<td>C &amp;= 2 is same as  C = C &amp; 2</td>
</tr>
<tr>
<td>^=</td>
<td>bitwise exclusive OR and assignment operator</td>
<td>C ^= 2 is same as  C = C ^ 2</td>
</tr>
<tr>
<td>|=</td>
<td>bitwise inclusive OR and assignment operator</td>
<td>C |= 2 is same as  C = C | 2</td>
</tr>
</table>
<h2>Miscellaneous Operators</h2>
<p>There are few other important operators including <b>sizeof, typeof</b> and <b>? :</b>  supported by C#.</p>
<p><a href="/csharp/csharp_misc_operators.htm" title="misc operators in C#">Show Examples</a></p>
<table class="table table-bordered">
<tr>
<th style="width:10%">Operator</th>
<th style="width:55%;">Description</th>
<th>Example</th>
</tr>
<tr>
<td>sizeof()</td>
<td>Returns the size of a data type.</td>
<td>sizeof(int), returns 4.</td>
</tr>
<tr>
<td>typeof()</td>
<td>Returns the type of a class.</td>
<td>typeof(StreamReader);</td>
</tr>
<tr>
<td>&amp;</td>
<td>Returns the address of an variable.</td>
<td>&amp;a; returns actual address of the variable.</td>
</tr>
<tr>
<td>*</td>
<td>Pointer to a variable.</td>
<td>*a; creates pointer named 'a' to a variable.</td>
</tr>
<tr>
<td>? :</td>
<td>Conditional Expression</td>
<td>If Condition is true ? Then value X : Otherwise value Y</td>
</tr>
<tr>
<td>is</td>
<td>Determines whether an object is of a certain type.</td>
<td>If( Ford is Car)  // checks if Ford is an object of the Car class.</td>
</tr>
<tr>
<td>as</td>
<td>Cast without raising an exception if the cast fails.</td>
<td>Object obj = new StringReader("Hello");
<p>StringReader r = obj as StringReader;</p>
</td>
</tr>
</table>
<h2>Operator Precedence in C#</h2>
<p>Operator precedence determines the grouping of terms in an expression. This affects evaluation of an expression. Certain operators have higher precedence than others; for example, the multiplication operator has higher precedence than the addition operator.</p>
<p>For example x = 7 + 3 * 2; here, x is assigned 13, not 20 because operator * has higher precedence than +, so the first evaluation takes place for 3*2 and then 7 is added into it.</p>
<p>Here, operators with the highest precedence appear at the top of the table, those with the lowest appear at the bottom. Within an expression, higher precedence operators are evaluated first.</p>
<p><a href="/csharp/csharp_operators_precedence.htm" title="Operators Precedence in C#">Show Examples</a></p>
<table class="table table-bordered">
<tr> 
<th>Category</th> 
<th>Operator</th>
<th>Associativity</th> 
</tr> 
<tr> 
<td>Postfix</td>
<td>() [] -&gt; .  ++  - - </td> 
<td>Left to right</td> 
</tr>
<tr> 
<td>Unary</td> 
<td>+  -  !  ~  ++  - -  (type)*  &amp;  sizeof</td> 
<td>Right to left</td>
</tr> 
<tr> 
<td>Multiplicative </td> 
<td>* / %</td>
<td>Left to right</td> 
</tr> 
<tr> 
<td>Additive </td>
<td>+ -</td> 
<td>Left to right</td> 
</tr>
<tr> 
<td>Shift </td> 
<td>&lt;&lt; &gt;&gt;</td> 
<td>Left to right</td> 
</tr> 
<tr> 
<td>Relational </td>
<td>&lt; &lt;=  &gt; &gt;=</td> 
<td>Left to right</td> 
</tr>
<tr> 
<td>Equality </td> 
<td>==  !=</td> 
<td>Left to right</td> 
</tr> 
<tr> 
<td>Bitwise AND</td>
<td>&amp;</td> 
<td>Left to right</td> 
</tr> 
<tr> 
<td>Bitwise XOR</td> 
<td>^</td> 
<td>Left to right</td>
</tr> 
<tr> 
<td>Bitwise OR</td> 
<td>|</td> 
<td>Left to right</td>
</tr> 
<tr> 
<td>Logical AND</td>
<td>&amp;&amp;</td> 
<td>Left to right</td>
</tr>
<tr>
<td>Logical OR</td> 
<td>||</td> 
<td>Left to right</td>
</tr> 
<tr> 
<td>Conditional</td>
<td>?:</td> 
<td>Right to left</td> 
</tr>
<tr>
<td>Assignment</td> 
<td>=  +=  -=  *=  /=  %=&gt;&gt;=  &lt;&lt;=  &amp;=  ^=   |=</td>
<td>Right to left</td>
</tr>
<tr>
<td>Comma</td> 
<td>,</td> 
<td>Left to right</td>
</tr> 
</table>
<h1>C# - Decision Making</h1>
<p>Decision making structures requires the programmer to specify one or more conditions to be evaluated or tested by the program, along with a statement or statements to be executed if the condition is determined to be true, and optionally, other statements to be executed if the condition is determined to be false.</p>
<p>Following is the general form of a typical decision making structure found in most of the programming languages:</p>
<img src="/csharp/images/decision_making.jpg" alt="Decision making statements in C#" />
<p>C# provides following types of decision making statements. Click the following links to check their detail.</p>
<table class="table table-bordered">
<tr>
<th style="width:35%">Statement</th>
<th>Description</th>
</tr>
<tr>
<td><p><a href="/csharp/if_statement_in_csharp.htm" title="if statement in C#">if statement</a></p></td>
<td>An <b>if statement</b> consists of a boolean expression followed by one or more statements.</td>
</tr>
<tr>
<td><p><a href="/csharp/if_else_statement_in_csharp.htm" title="if...else statement in C#">if...else statement</a></p></td>
<td>An <b>if statement</b> can be followed by an optional <b>else statement</b>, which executes when the boolean expression is false.</td>
</tr>
<tr>
<td><p><a href="/csharp/nested_if_statements_in_csharp.htm" title="nested if statements in C#">nested if statements</a></p></td>
<td>You can use one <b>if</b> or <b>else if</b> statement inside another <b>if</b> or <b>else if</b> statement(s).</td>
</tr>
<tr>
<td><p><a href="/csharp/switch_statement_in_csharp.htm" title="switch statement in C#">switch statement</a></p></td>
<td>A <b>switch</b> statement allows a variable to be tested for equality against a list of values.</td>
</tr>
<tr>
<td><p><a href="/csharp/nested_switch_statements_in_csharp.htm" title="nested switch statements in C#">nested switch statements</a></p></td>
<td>You can use one <b>switch</b> statement inside another <b>switch </b> statement(s).</td>
</tr>
</table>
<h2>The ? : Operator:</h2>
<p>We have covered <b>conditional operator ? :</b> in previous chapter which can be used to replace <b>if...else</b> statements. It has the following general form:</p>
<pre class="prettyprint notranslate">
Exp1 ? Exp2 : Exp3;
</pre>
<p>Where Exp1, Exp2, and Exp3 are expressions. Notice the use and placement of the colon.</p>
<p>The value of a ? expression is determined as follows: Exp1 is evaluated. If it is true, then Exp2 is evaluated and becomes the value of the entire ? expression. If Exp1 is false, then Exp3 is evaluated and its value becomes the value of the expression.</p>
<h1>C# - Loops</h1>
<p>There may be a situation, when you need to execute a block of code several number of times. In general, the statements are executed sequentially: The first statement in a function is executed first, followed by the second, and so on.</p>
<p>Programming languages provide various control structures that allow for more complicated execution paths.</p>
<p>A loop statement allows us to execute a statement or a group of statements multiple times and following is the general form of a loop statement in most of the programming languages:</p>
<img src="/csharp/images/loop_architecture.jpg" alt="Loop Architecture" />
<p>C# provides following types of loop to handle looping requirements. Click the following links to check their detail.</p>
<table class="table table-bordered">
<tr>
<th style="width:30%">Loop Type</th>
<th>Description</th>
</tr>
<tr>
<td><p><a href="/csharp/csharp_while_loop.htm" title="while loop in C#">while loop</a></p>
</td>
<td>It repeats a statement or a group of statements while a given condition is true. It tests the condition before executing the loop body.</td>
</tr>
<tr>
<td>
<p><a href="/csharp/csharp_for_loop.htm" title="for loop in C#">for loop</a></p>
</td>
<td>It executes a sequence of statements multiple times and abbreviates the code that manages the loop variable.</td>
</tr>
<tr>
<td>
<p><a href="/csharp/csharp_do_while_loop.htm" title="do...while loop in C#">do...while loop</a></p>
</td>
<td>It is similar to a while statement, except that it tests the condition at the end of the loop body</td>
</tr>
<tr>
<td><p><a href="/csharp/csharp_nested_loops.htm" title="nested loops in C#">nested loops</a></p>
</td>
<td>You can use one or more loop inside any another while, for or do..while loop.</td>
</tr>
</table>
<h2>Loop Control Statements</h2>
<p>Loop control statements change execution from its normal sequence. When execution leaves a scope, all automatic objects that were created in that scope are destroyed.</p>
<p>C# provides the following control statements. Click the following links to check their details.</p>
<table class="table table-bordered">
<tr>
<th style="width:30%">Control Statement</th>
<th>Description</th>
</tr>
<tr>
<td>
<p><a href="/csharp/csharp_break_statement.htm" title="break statement in C#">break statement</a></p></td>
<td>Terminates the <b>loop</b> or <b>switch</b> statement and transfers execution to the statement immediately following the loop or switch.</td></tr>
<tr>
<td>
<p><a href="/csharp/csharp_continue_statement.htm" title="continue statement in C#">continue statement</a></p></td>
<td>Causes the loop to skip the remainder of its body and immediately retest its condition prior to reiterating.</td>
</tr>
</table>
<h2>Infinite Loop</h2>
<p>A loop becomes infinite loop if a condition never becomes false. The <b>for</b> loop is traditionally used for this purpose. Since none of the three expressions that form the for loop are required, you can make an endless loop by leaving the conditional expression empty.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
using System;
namespace Loops
{
   class Program
   {
      static void Main(string[] args)
      {
         for (; ; )
         {
            Console.WriteLine("Hey! I am Trapped");
         }
      }
   }
} 
</pre>
<p>When the conditional expression is absent, it is assumed to be true. You may have an initialization and increment expression, but programmers more commonly use the for(;;) construct to signify an infinite loop.</p>
<h1>C# - Encapsulation</h1>
<p><b>Encapsulation</b> is defined 'as the process of enclosing one or more items within a physical or logical package'. Encapsulation, in object oriented programming methodology, prevents access to implementation details. </p>
<p>Abstraction and encapsulation are related features in object oriented programming. Abstraction allows making relevant information visible and encapsulation enables a programmer to <i>implement the desired level of abstraction</i>.</p>
<p>Encapsulation is implemented by using <b>access specifiers</b>. An <b>access specifier</b> defines the scope and visibility of a class member. C# supports the following access specifiers:</p>
<ul class="list">
<li>Public</li>
<li>Private</li>
<li>Protected</li>
<li>Internal</li>
<li>Protected internal</li>
</ul>
<h2>Public Access Specifier</h2>
<p>Public access specifier allows a class to expose its member variables and member functions to other functions and objects. Any public member can be accessed from outside the class.</p> 
<p>The following example illustrates this:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace RectangleApplication
{
   class Rectangle
   {
      //member variables
      public double length;
      public double width;
      
      public double GetArea()
      {
         return length * width;
      }
      public void Display()
      {
         Console.WriteLine("Length: {0}", length);
         Console.WriteLine("Width: {0}", width);
         Console.WriteLine("Area: {0}", GetArea());
      }
   }//end class Rectangle
   
   class ExecuteRectangle
   {
      static void Main(string[] args)
      {
         Rectangle r = new Rectangle();
         r.length = 4.5;
         r.width = 3.5;
         r.Display();
         Console.ReadLine();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Length: 4.5
Width: 3.5
Area: 15.75
</pre>
<p>In the preceding example, the member variables length and width are declared <b>public</b>, so they can be accessed from the function Main() using an instance of the Rectangle class, named <b>r</b>.</p>
<p>The member function <i>Display()</i> and <i>GetArea()</i> can also access these variables directly without using any instance of the class.</p>
<p>The member functions <i>Display()</i> is also declared <b>public</b>, so it can also be accessed from <i>Main()</i> using an instance of the Rectangle class, named <b>r</b>. </p>
<h2>Private Access Specifier</h2>
<p>Private access specifier allows a class to hide its member variables and member functions from other functions and objects. Only functions of the same class can access its private members. Even an instance of a class cannot access its private members. </p>
<p>The following example illustrates this:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace RectangleApplication 
{
   class Rectangle
   {
      //member variables
      private double length;
      private double width;
      
      public void Acceptdetails()
      {
         Console.WriteLine("Enter Length: ");
         length = Convert.ToDouble(Console.ReadLine());
         Console.WriteLine("Enter Width: ");
         width = Convert.ToDouble(Console.ReadLine());
      }
      public double GetArea()
      {
         return length * width;
      }
      public void Display()
      {
         Console.WriteLine("Length: {0}", length);
         Console.WriteLine("Width: {0}", width);
         Console.WriteLine("Area: {0}", GetArea());
      }
   }//end class Rectangle
   
   class ExecuteRectangle
   {
      static void Main(string[] args)
      {
         Rectangle r = new Rectangle();
         r.Acceptdetails();
         r.Display();
         Console.ReadLine();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Enter Length:
4.4
Enter Width:
3.3
Length: 4.4
Width: 3.3
Area: 14.52
</pre>
<p>In the preceding example, the member variables length and width are declared <b>private</b>, so they cannot be accessed from the function Main(). The member functions <i>AcceptDetails()</i> and <i>Display()</i> can access these variables. Since the member functions <i>AcceptDetails()</i> and <i>Display()</i> are declared <b>public</b>, they can be accessed from <i>Main()</i> using an instance of the Rectangle class, named <b>r</b>.</p>
<h2>Protected Access Specifier</h2>
<p>Protected access specifier allows a child class to access the member variables and member functions of its base class. This way it helps in implementing inheritance. We will discuss this in more details in the inheritance chapter.</p>
<h2>Internal Access Specifier</h2>
<p>Internal access specifier allows a class to expose its member variables and member functions to other functions and objects in the current assembly. In other words, any member with internal access specifier can be accessed from any class or method defined within the application in which the member is defined.</p>
<p>The following program illustrates this:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace RectangleApplication
{
   class Rectangle
   {
      //member variables
      internal double length;
      internal double width;
      
      double GetArea()
      {
         return length * width;
      }
      public void Display()
      {
         Console.WriteLine("Length: {0}", length);
         Console.WriteLine("Width: {0}", width);
         Console.WriteLine("Area: {0}", GetArea());
      }
   }//end class Rectangle
   
   class ExecuteRectangle
   {
      static void Main(string[] args)
      {
         Rectangle r = new Rectangle();
         r.length = 4.5;
         r.width = 3.5;
         r.Display();
         Console.ReadLine();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Length: 4.5
Width: 3.5
Area: 15.75
</pre>
<p>In the preceding example, notice that the member function <i>GetArea()</i> is not declared with any access specifier. Then what would be the default access specifier of a class member if we don't mention any? It is <b>private</b>.</p>
<h2>Protected Internal Access Specifier</h2>
<p>The protected internal access specifier allows a class to hide its member variables and member functions from other class objects and functions, except a child class within the same application. This is also used while implementing inheritance.</p>
<h1>C# - Methods</h1>
<p>A method is a group of statements that together perform a task. Every C# program has at least one class with a method named Main.</p>
<p>To use a method, you need to:</p>
<ul class="list">
<li>Define the method</li>
<li>Call the method</li>
</ul>
<h2>Defining Methods in C#</h2>
<p>When you define a method, you basically declare the elements of its structure. The syntax for defining a method in C# is as follows:</p>
<pre class="prettyprint notranslate">
&lt;Access Specifier&gt; &lt;Return Type&gt; &lt;Method Name&gt;(Parameter List)
{
   Method Body
}
</pre>
<p>Following are the various elements of a method:</p>
<ul class="list">
<li><p><b>Access Specifier</b>: This determines the visibility of a variable or a method from another class.</p></li>
<li><p><b>Return type</b>: A method may return a value. The return type is the data type of the value the method returns. If the method is not returning any values, then the return type is <b>void</b>.</p></li>
<li><p><b>Method name</b>: Method name is a unique identifier and it is case sensitive. It cannot be same as any other identifier declared in the class.</p></li>
<li><p><b>Parameter list</b>: Enclosed between parentheses, the parameters are used to pass and receive data from a method. The parameter list refers to the type, order, and number of the parameters of a method. Parameters are optional; that is, a method may contain no parameters.</p></li>
<li><p><b>Method body</b>: This contains the set of instructions needed to complete the required activity.</p></li>
</ul>
<h2>Example</h2>
<p>Following code snippet shows a function <i>FindMax</i> that takes two integer values and returns the larger of the two. It has public access specifier, so it can be accessed from outside the class using an instance of the class.</p>
<pre class="prettyprint notranslate">
class NumberManipulator
{
   public int FindMax(int num1, int num2)
   {
      /* local variable declaration */
      int result;

      if (num1 &gt; num2)
         result = num1;
      else
         result = num2;

      return result;
   }
   ...
}
</pre>
<h2>Calling Methods in C#</h2>
<p>You can call a method using the name of the method. The following example illustrates this:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace CalculatorApplication
{
   class NumberManipulator
   {
      public int FindMax(int num1, int num2)
      {
         /* local variable declaration */
         int result;
         
         if (num1 &gt; num2)
            result = num1;
         else
            result = num2;
         return result;
      }
      static void Main(string[] args)
      {
         /* local variable definition */
         int a = 100;
         int b = 200;
         int ret;
         NumberManipulator n = new NumberManipulator();

         //calling the FindMax method
         ret = n.FindMax(a, b);
         Console.WriteLine("Max value is : {0}", ret );
         Console.ReadLine();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Max value is : 200
</pre>
<p>You can also call public method from other classes by using the instance of the class. For example, the method <i>FindMax</i> belongs to the <i>NumberManipulator</i> class, you can call it from another class <i>Test</i>.</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace CalculatorApplication
{
   class NumberManipulator
   {
      public int FindMax(int num1, int num2)
      {
         /* local variable declaration */
         int result;
         
         if(num1 &gt; num2)
            result = num1;
         else
            result = num2;
         
         return result;
      }
   }
   
   class Test
   {
      static void Main(string[] args)
      {
         /* local variable definition */
         int a = 100;
         int b = 200;
         int ret;
         NumberManipulator n = new NumberManipulator();
         
         //calling the FindMax method
         ret = n.FindMax(a, b);
         Console.WriteLine("Max value is : {0}", ret );
         Console.ReadLine();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Max value is : 200
</pre>
<h2>Recursive Method Call</h2>
<p>A method can call itself. This is known as <b>recursion</b>. Following is an example that calculates factorial for a given number using a recursive function:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace CalculatorApplication
{
   class NumberManipulator
   {
      public int factorial(int num)
      {
         /* local variable declaration */
         int result;
         if (num == 1)
         {
            return 1;
         }
         else
         {
            result = factorial(num - 1) * num;
            return result;
         }
      }
      
      static void Main(string[] args)
      {
         NumberManipulator n = new NumberManipulator();
         //calling the factorial method
         Console.WriteLine("Factorial of 6 is : {0}", n.factorial(6));
         Console.WriteLine("Factorial of 7 is : {0}", n.factorial(7));
         Console.WriteLine("Factorial of 8 is : {0}", n.factorial(8));
         Console.ReadLine();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Factorial of 6 is: 720
Factorial of 7 is: 5040
Factorial of 8 is: 40320
</pre>
<h2>Passing Parameters to a Method</h2>
<p>When method with parameters is called, you need to pass the parameters to the method. There are three ways that parameters can be passed to a method:</p>
<table class="table table-bordered">
<tr>
<th style = "width:30%">Mechanism</th>
<th>Description</th>
</tr>
<tr>
<td>
<p><a href="/csharp/csharp_value_parameters.htm" title="Value parameters in C#">Value parameters</a></p>
</td>
<td>This method copies the actual value of an argument into the formal parameter of the function. In this case, changes made to the parameter inside the function have no effect on the argument.</td>
</tr>
<tr>
<td>
<p><a href="/csharp/csharp_reference_parameters.htm" title="Reference parameters in C#">Reference parameters</a></p>
</td>
<td>This method copies the reference to the memory location of an argument into the formal parameter. This means that changes made to the parameter affect the argument.</td> </tr>
<tr>
<td> 
<p><a href="/csharp/csharp_output_parameters.htm" title="Output parameters in C#">Output parameters</a></p>
</td>
<td>This method helps in returning more than one value.</td> 
</tr>
</table>
<h1>C# - Nullables</h1>
<p>C# provides a special data types, the <b>nullable</b> types, to which you can assign normal range of values as well as null values.</p>
<p>For example, you can store any value from -2,147,483,648 to 2,147,483,647 or null in a Nullable&lt;Int32&gt; variable. Similarly, you can assign true, false, or null in a Nullable&lt;bool&gt; variable. Syntax for declaring a <b>nullable</b> type is as follows:</p>
<pre class="prettyprint notranslate">
&lt; data_type&gt; ? &lt;variable_name&gt; = null;
</pre>
<p>The following example demonstrates use of nullable data types:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace CalculatorApplication
{
   class NullablesAtShow
   {
      static void Main(string[] args)
      {
         int? num1 = null;
         int? num2 = 45;
         double? num3 = new double?();
         double? num4 = 3.14157;
         
         bool? boolval = new bool?();

         // display the values
         
         Console.WriteLine("Nullables at Show: {0}, {1}, {2}, {3}", num1, num2, num3, num4);
         Console.WriteLine("A Nullable boolean value: {0}", boolval);
         Console.ReadLine();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Nullables at Show: , 45,  , 3.14157
A Nullable boolean value:
</pre>
<h2>The Null Coalescing Operator (??)</h2>
<p>The null coalescing operator is used with the nullable value types and reference types. It is used for converting an operand to the type of another nullable (or not) value type operand, where an implicit conversion is possible.</p> 
<p>If the value of the first operand is null, then the operator returns the value of the second operand, otherwise it returns the value of the first operand. The following example explains this:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace CalculatorApplication
{
   class NullablesAtShow
   {
      static void Main(string[] args)
      {
         double? num1 = null;
         double? num2 = 3.14157;
         double num3;
         num3 = num1 ?? 5.34;      
         Console.WriteLine(" Value of num3: {0}", num3);
         num3 = num2 ?? 5.34;
         Console.WriteLine(" Value of num3: {0}", num3);
         Console.ReadLine();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Value of num3: 5.34
Value of num3: 3.14157
</pre>
<h1>C# - Arrays</h1>
<p>An array stores a fixed-size sequential collection of elements of the same type. An array is used to store a collection of data, but it is often more useful to think of an array as a collection of variables of the same type stored at contiguous memory locations.</p>
<p>Instead of declaring individual variables, such as number0, number1, ..., and number99, you declare one array variable such as numbers and use numbers[0], numbers[1], and ..., numbers[99] to represent individual variables. A specific element in an array is accessed by an index.</p>
<p>All arrays consist of contiguous memory locations. The lowest address corresponds to the first element and the highest address to the last element.</p>
<img src="/csharp/images/arrays.jpg" alt="Arrays in C#" />
<h2>Declaring Arrays</h2>
<p>To declare an array in C#, you can use the following syntax:</p>
<pre class="prettyprint notranslate">
datatype[] arrayName;
</pre>
<p>where,</p>
<ul class="list">
<li><p>d<i>atatype</i> is used to specify the type of elements in the array.</p></li>
<li><p><i>[ ]</i> specifies the rank of the array. The rank specifies the size of the array. </p></li>
<li><p><i>arrayName</i> specifies the name of the array.</p></li>
</ul>
<p>For example,</p>
<pre class="prettyprint notranslate">
double[] balance;
</pre>
<h2>Initializing an Array</h2>
<p>Declaring an array does not initialize the array in the memory. When the array variable is initialized, you can assign values to the array.</p>
<p>Array is a reference type, so you need to use the <b>new</b> keyword to create an instance of the array. For example,</p>
<pre class="prettyprint notranslate">
double[] balance = new double[10];
</pre>
<h2>Assigning Values to an Array</h2>
<p>You can assign values to individual array elements, by using the index number, like:</p>
<pre class="prettyprint notranslate">
double[] balance = new double[10];
balance[0] = 4500.0;
</pre>
<p>You can assign values to the array at the time of declaration, as shown:</p>
<pre class="prettyprint notranslate">
double[] balance = { 2340.0, 4523.69, 3421.0};
</pre>
<p>You can also create and initialize an array, as shown:</p>
<pre class="prettyprint notranslate">
int [] marks = new int[5]  { 99,  98, 92, 97, 95};
</pre>
<p>You may also omit the size of the array, as shown:</p>
<pre class="prettyprint notranslate">
int [] marks = new int[]  { 99,  98, 92, 97, 95};
</pre>
<p>You can copy an array variable into another target array variable. In such case, both the target and source point to the same memory location:</p>
<pre class="prettyprint notranslate">
int [] marks = new int[]  { 99,  98, 92, 97, 95};
int[] score = marks;
</pre>
<p>When you create an array, C# compiler implicitly initializes each array element to a default value depending on the array type. For example, for an int array all elements are initialized to 0.</p>
<h2>Accessing Array Elements</h2>
<p>An element is accessed by indexing the array name. This is done by placing the index of the element within square brackets after the name of the array. For example,</p>
<pre class="prettyprint notranslate">
double salary = balance[9];
</pre>
<p>The following example, demonstrates the above-mentioned concepts declaration, assignment, and accessing arrays:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace ArrayApplication
{
   class MyArray
   {
      static void Main(string[] args)
      {
         int []  n = new int[10]; /* n is an array of 10 integers */
         int i,j;

         /* initialize elements of array n */
         for ( i = 0; i &lt; 10; i++ )
         {
            n[ i ] = i + 100;
         }
         
         /* output each array element's value */
         for (j = 0; j &lt; 10; j++ )
         {
            Console.WriteLine("Element[{0}] = {1}", j, n[j]);
         }
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Element[0] = 100
Element[1] = 101
Element[2] = 102
Element[3] = 103
Element[4] = 104
Element[5] = 105
Element[6] = 106
Element[7] = 107
Element[8] = 108
Element[9] = 109
</pre>
<h2>Using the <i>foreach</i> Loop</h2>
<p>In the previous example, we used a for loop for accessing each array element. You can also use a <b>foreach</b> statement to iterate through an array.</p> 
<pre class="prettyprint notranslate tryit">
using System;
namespace ArrayApplication
{
   class MyArray
   {
      static void Main(string[] args)
      {
         int []  n = new int[10]; /* n is an array of 10 integers */
         
         /* initialize elements of array n */
         for ( int i = 0; i &lt; 10; i++ )
         {
            n[i] = i + 100;
         }
         
         /* output each array element's value */
         foreach (int j in n )
         {
            int i = j-100;
            Console.WriteLine("Element[{0}] = {1}", i, j);
            
         }
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Element[0] = 100
Element[1] = 101
Element[2] = 102
Element[3] = 103
Element[4] = 104
Element[5] = 105
Element[6] = 106
Element[7] = 107
Element[8] = 108
Element[9] = 109
</pre>
<h2>C# Arrays</h2>
<p>There are following few important concepts related to array which should be clear to a C# programmer:</p>
<table class="table table-bordered">
<tr>
<th style="width:30%">Concept</th>
<th>Description</th>
</tr>
<tr>
<td> 
<p><a href="/csharp/csharp_multi_dimensional_arrays.htm" title="Multi-dimensional arrays in C#">Multi-dimensional arrays</a></p>
</td>
<td>C# supports multidimensional arrays. The simplest form of the multidimensional array is the two-dimensional array.</td>
</tr>
<tr>
<td> 
<p><a href="/csharp/csharp_jagged_arrays.htm" title="Jagged arrays in C#">Jagged arrays</a></p>
</td>
<td>C# supports multidimensional arrays, which are arrays of arrays.</td> 
</tr>
<tr>
<td> 
<p><a href="/csharp/csharp_passing_arrays_to_functions.htm" title="Passing arrays to functions as arguments in C#">Passing arrays to functions</a></p>
</td>
<td>You can pass to the function a pointer to an array by specifying the array's name without an index.</td> 
</tr>
<tr>
<td> 
<p><a href="/csharp/csharp_param_arrays.htm" title="Param arrays in C#">Param arrays</a></p>
</td>
<td>This is used for passing unknown number of parameters to a function.</td> 
</tr>
<tr>
<td> 
<p><a href="/csharp/csharp_array_class.htm" title="Array class in C">The Array Class</a></td></p>
<td>Defined in System namespace, it is the base class to all arrays, and provides various properties and methods for working with arrays.</td> 
</tr>
</table>
<h1>C# - Strings</h1>
<p>In C#, you can use strings as array of characters, However, more common practice is to use the <b>string</b> keyword to declare a string variable. The string keyword is an alias for the <b>System.String</b> class.</p>
<h2>Creating a String Object</h2>
<p>You can create string object using one of the following methods:</p>
<ul class="list">
<li><p>By assigning a string literal to a String variable</p></li>
<li><p>By using a String class constructor</p></li>
<li><p>By using the string concatenation operator (+)</p></li>
<li><p>By retrieving a property or calling a method that returns a string</p></li>
<li><p>By calling a formatting method to convert a value or an object to its string representation</p></li>
</ul>
<p>The following example demonstrates this:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace StringApplication
{
   class Program
   {
      static void Main(string[] args)
      {
         //from string literal and string concatenation
         string fname, lname;
         fname = "Rowan";
         lname = "Atkinson";
         
         string fullname = fname + lname;
         Console.WriteLine("Full Name: {0}", fullname);
         
         //by using string constructor
         char[] letters = { 'H', 'e', 'l', 'l','o' };
         string greetings = new string(letters);
         Console.WriteLine("Greetings: {0}", greetings);
         
         //methods returning string
         string[] sarray = { "Hello", "From", "Tutorials", "Point" };
         string message = String.Join(" ", sarray);
         Console.WriteLine("Message: {0}", message);
         
         //formatting method to convert a value
         DateTime waiting = new DateTime(2012, 10, 10, 17, 58, 1);
         string chat = String.Format("Message sent at {0:t} on {0:D}", waiting);
         Console.WriteLine("Message: {0}", chat);
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Full Name: Rowan Atkinson
Greetings: Hello
Message: Hello From Tutorials Point
Message: Message sent at 5:58 PM on Wednesday, October 10, 2012
</pre>
<h2>Properties of the String Class</h2>
<p>The String class has the following two properties:</p>
<table class="table table-bordered">
<tr>
<th style="width:5%;">Sr.No</th>
<th>Property</th>
</tr>
<tr>
<td>1</td>
<td><b>Chars</b>
<p>Gets the <i>Char</i> object at a specified position in the current <i>String</i> object.</p></td>
</tr>
<tr>
<td>2</td>
<td><b>Length</b>
<p>Gets the number of characters in the current String object.</p></td>
</tr>
</table>
<h2>Methods of the String Class</h2>
<p>The String class has numerous methods that help you in working with the string objects. The following table provides some of the most commonly used methods:</p>
<table class="table table-bordered">
<tr>
<th style="width:5%;">Sr.No</th>
<th>Methods</th>
</tr>
<tr>
<td>1</td>
<td><b>public static int Compare(string strA, string strB)</b>
<p>Compares two specified string objects and returns an integer that indicates their relative position in the sort order.</p></td>
</tr>
<tr>
<td>2</td>
<td><b>public static int Compare(string strA, string strB, bool ignoreCase )</b>
<p>Compares two specified string objects and returns an integer that indicates their relative position in the sort order. However, it ignores case if the Boolean parameter is true.</p>
</td>
</tr>
<tr>
<td>3</td>
<td><b>public static string Concat(string str0, string str1)</b>
<p>Concatenates two string objects.</p>
</td>
</tr>
<tr>
<td>4</td>
<td><b>public static string Concat(string str0, string str1, string str2)</b>
<p>Concatenates three string objects.</p>
</td>
</tr>
<tr>
<td>5</td>
<td><b>public static string Concat(string str0, string str1, string str2, string str3)</b>
<p>Concatenates four string objects.</p>
</td>
</tr>
<tr>
<td>6</td>
<td><b>public bool Contains(string value)</b>
<p>Returns a value indicating whether the specified String object occurs within this string.</p></td>
</tr>
<tr>
<td>7</td>
<td><b>public static string Copy(string str)</b>
<p>Creates a new String object with the same value as the specified string.</p>
</td>
</tr>
<tr>
<td>8</td>
<td><b>public void CopyTo(int sourceIndex, char[] destination, int destinationIndex, int count)</b>
<p>Copies a specified number of characters from a specified position of the String object to a specified position in an array of Unicode characters.</p></td>
</tr>
<tr>
<td>9</td>
<td>
<b>public bool EndsWith(string value)</b>
<p>Determines whether the end of the string object matches the specified string.</p>
</td>
</tr>
<tr>
<td>10</td>
<td>
<b>public bool Equals(string value)</b>
<p>Determines whether the current String object and the specified String object have the same value.</p>
</td>
</tr>
<tr>
<td>11</td>
<td>
<b>public static bool Equals(string a, string b)</b>
<p>Determines whether two specified String objects have the same value.</p>
</td>
</tr>
<tr>
<td>12</td>
<td>
<b>public static string Format(string format, Object arg0)</b>
<p>Replaces one or more format items in a specified string with the string representation of a specified object.</p>
</td>
</tr>
<tr>
<td>13</td>
<td>
<b>public int IndexOf(char value)</b>
<p>Returns the zero-based index of the first occurrence of the specified Unicode character in the current string.</p>
</td>
</tr>
<tr>
<td>14</td>
<td>
<b>public int IndexOf(string value)</b>
<p>Returns the zero-based index of the first occurrence of the specified string in this instance.</p>
</td>
</tr>
<tr>
<td>15</td>
<td>
<b>public int IndexOf(char value, int startIndex)</b>
<p>Returns the zero-based index of the first occurrence of the specified Unicode character in this string, starting search at the specified character position.</p>
</td>
</tr>
<tr>
<td>16</td>
<td>
<b>public int IndexOf(string value, int startIndex)</b>
<p>Returns the zero-based index of the first occurrence of the specified string in this instance, starting search at the specified character position.</p>
</td>
</tr>
<tr>
<td>17</td>
<td>
<b>public int IndexOfAny(char[] anyOf)</b>
<p>Returns the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters.</p>
</td>
</tr>
<tr>
<td>18</td>
<td>
<b>public int IndexOfAny(char[] anyOf, int startIndex)</b>
<p>Returns the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters, starting search at the specified character position.</p>
</td>
</tr>
<tr>
<td>19</td>
<td>
<b>public string Insert(int startIndex, string value)</b>
<p>Returns a new string in which a specified string is inserted at a specified index position in the current string object.</p>
</td>
</tr>
<tr>
<td>20</td>
<td>
<b>public static bool IsNullOrEmpty(string value)</b>
<p>Indicates whether the specified string is null or an Empty string.</p>
</td>
</tr>
<tr>
<td>21</td>
<td>
<b>public static string Join(string separator, params string[] value)</b>
<p>Concatenates all the elements of a string array, using the specified separator between each element.</p>
</td></tr>
<tr>
<td>22</td>
<td>
<b>public static string Join(string separator, string[] value, int startIndex, int count)</b>
<p>Concatenates the specified elements of a string array, using the specified separator between each element.</p>
</td>
</tr>
<tr>
<td>23</td>
<td>
<b>public int LastIndexOf(char value)</b>
<p>Returns the zero-based index position of the last occurrence of the specified Unicode character within the current string object.</p>
</td>
</tr>
<tr>
<td>24</td>
<td>
<b>public int LastIndexOf(string value)</b>
<p>Returns the zero-based index position of the last occurrence of a specified string within the current string object.</p>
</td>
</tr>
<tr>
<td>25</td>
<td>
<b>public string Remove(int startIndex)</b>
<p>Removes all the characters in the current instance, beginning at a specified position and continuing through the last position, and returns the string.</p>
</td>
</tr>
<tr>
<td>26</td>
<td>
<b>public string Remove(int startIndex, int count)</b>
<p>Removes the specified number of characters in the current string beginning at a specified position and returns the string.</p>
</td>
</tr>
<tr>
<td>27</td>
<td>
<b>public string Replace(char oldChar, char newChar)</b>
<p>Replaces all occurrences of a specified Unicode character in the current string object with the specified Unicode character and returns the new string.</p>
</td>
</tr>
<tr>
<td>28</td>
<td>
<b>public string Replace(string oldValue, string newValue)</b>
<p>Replaces all occurrences of a specified string in the current string object with the specified string and returns the new string.</p>
</td>
</tr>
<tr>
<td>29</td>
<td>
<b>public string[] Split(params char[] separator)</b>
<p>Returns a string array that contains the substrings in the current string object, delimited by elements of a specified Unicode character array.</p>
</td>
</tr>
<tr>
<td>30</td>
<td>
<b>public string[] Split(char[] separator, int count)</b>
<p>Returns a string array that contains the substrings in the current string object, delimited by elements of a specified Unicode character array. The int parameter specifies the maximum number of substrings to return.</p>
</td>
</tr>
<tr>
<td>31</td>
<td>
<b>public bool StartsWith(string value)</b>
<p>Determines whether the beginning of this string instance matches the specified string.</td>
</tr>
<tr>
<td>32</td>
<td>
<b>public char[] ToCharArray()</b>
<p>Returns a Unicode character array with all the characters in the current string object.</p>
</td>
</tr>
<tr>
<td>33</td>
<td><b>public char[] ToCharArray(int startIndex, int length)</b>
<p>Returns a Unicode character array with all the characters in the current string object, starting from the specified index and up to the specified length.</p>
</td>
</tr>
<tr>
<td>34</td>
<td>
<b>public string ToLower()</b>
<p>Returns a copy of this string converted to lowercase.</p>
</td>
</tr>
<tr>
<td>35</td>
<td>
<b>public string ToUpper()</b>
<p>Returns a copy of this string converted to uppercase.</p>
</td>
</tr>
<tr>
<td>36</td>
<td>
<b>public string Trim()</b>
<p>Removes all leading and trailing white-space characters from the current String object.</p>
</td>
</tr>
</table>
<p>You can visit MSDN library for the complete list of methods and String class constructors. </p>
<h2>Examples</h2>
<p>The following example demonstrates some of the methods mentioned above:</p>
<p><b>Comparing Strings:</b></p>
<pre class="prettyprint notranslate tryit">
using System;
namespace StringApplication
{
   class StringProg
   {
      static void Main(string[] args)
      {
         string str1 = "This is test";
         string str2 = "This is text";

         if (String.Compare(str1, str2) == 0)
         {
            Console.WriteLine(str1 + " and " + str2 +  " are equal.");
         }
         else
         {
            Console.WriteLine(str1 + " and " + str2 + " are not equal.");
         }
         Console.ReadKey() ;
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
This is test and This is text are not equal.
</pre>
<p><b>String Contains String:</b></p>
<pre class="prettyprint notranslate tryit">
using System;
namespace StringApplication
{
   class StringProg
   {
      static void Main(string[] args)
      {
         string str = "This is test";
         if (str.Contains("test"))
         {
            Console.WriteLine("The sequence 'test' was found.");
         }
         Console.ReadKey() ;
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
The sequence 'test' was found.
</pre>
<p><b>Getting a Substring:</b></p>
<pre class="prettyprint notranslate tryit">
using System;
namespace StringApplication
{
   class StringProg
   {
      static void Main(string[] args)
      {
         string str = "Last night I dreamt of San Pedro";
         Console.WriteLine(str);
         string substr = str.Substring(23);
         Console.WriteLine(substr);
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
San Pedro
</pre>
<p><b>Joining Strings:</b></p>
<pre class="prettyprint notranslate tryit">
using System;
namespace StringApplication
{
   class StringProg
   {
      static void Main(string[] args)
      {
         string[] starray = new string[]{"Down the way nights are dark",
         "And the sun shines daily on the mountain top",
         "I took a trip on a sailing ship",
         "And when I reached Jamaica",
         "I made a stop"};

         string str = String.Join("\n", starray);
         Console.WriteLine(str);
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Down the way nights are dark
And the sun shines daily on the mountain top
I took a trip on a sailing ship
And when I reached Jamaica
I made a stop
</pre>
<h1>C# - Structures</h1>
<p>In C#, a structure is a value type data type. It helps you to make a single variable hold related data of various data types. The <b>struct</b> keyword is used for creating a structure. </p>
<p>Structures are used to represent a record. Suppose you want to keep track of your books in a library. You might want to track the following attributes about each book:</p>
<ul class="list">
<li>Title</li>
<li>Author</li>
<li>Subject</li>
<li>Book ID</li>
</ul>
<h2>Defining a Structure</h2>
<p>To define a structure, you must use the struct statement. The struct statement defines a new data type, with more than one member for your program.</p> 
<p>For example, here is the way you can declare the Book structure:</p>
<pre class="prettyprint notranslate">
struct Books
{
   public string title;
   public string author;
   public string subject;
   public int book_id;
};  
</pre>
<p>The following program shows the use of the structure:</p>
<pre class="prettyprint notranslate tryit">
using System;
struct Books
{
   public string title;
   public string author;
   public string subject;
   public int book_id;
};  

public class testStructure
{
   public static void Main(string[] args)
   {

      Books Book1;   /* Declare Book1 of type Book */
      Books Book2;   /* Declare Book2 of type Book */

      /* book 1 specification */
      Book1.title = "C Programming";
      Book1.author = "Nuha Ali"; 
      Book1.subject = "C Programming Tutorial";
      Book1.book_id = 6495407;

      /* book 2 specification */
      Book2.title = "Telecom Billing";
      Book2.author = "Zara Ali";
      Book2.subject =  "Telecom Billing Tutorial";
      Book2.book_id = 6495700;

      /* print Book1 info */
      Console.WriteLine( "Book 1 title : {0}", Book1.title);
      Console.WriteLine("Book 1 author : {0}", Book1.author);
      Console.WriteLine("Book 1 subject : {0}", Book1.subject);
      Console.WriteLine("Book 1 book_id :{0}", Book1.book_id);

      /* print Book2 info */
      Console.WriteLine("Book 2 title : {0}", Book2.title);
      Console.WriteLine("Book 2 author : {0}", Book2.author);
      Console.WriteLine("Book 2 subject : {0}", Book2.subject);
      Console.WriteLine("Book 2 book_id : {0}", Book2.book_id);       

      Console.ReadKey();

   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Book 1 title : C Programming
Book 1 author : Nuha Ali
Book 1 subject : C Programming Tutorial
Book 1 book_id : 6495407
Book 2 title : Telecom Billing
Book 2 author : Zara Ali
Book 2 subject : Telecom Billing Tutorial
Book 2 book_id : 6495700
</pre>
<h2>Features of C# Structures</h2>
<p>You have already used a simple structure named Books. Structures in C# are quite different from that in traditional C or C++. The C# structures have the following features:</p>
<ul class="list">
<li><p>Structures can have methods, fields, indexers, properties, operator methods, and events.</p></li>
<li><p>Structures can have defined constructors, but not destructors. However, you cannot define a default constructor for a structure. The default constructor is automatically defined and cannot be changed.</p></li>
<li><p>Unlike classes, structures cannot inherit other structures or classes.</p></li>
<li><p>Structures cannot be used as a base for other structures or classes.</p></li>
<li><p>A structure can implement one or more interfaces.</p></li>
<li><p>Structure members cannot be specified as abstract, virtual, or protected.</p></li>
<li><p>When you create a struct object using the <b>New</b> operator, it gets created and the appropriate constructor is called. Unlike classes, structs can be instantiated without using the New operator.</p></li>
<li><p>If the New operator is not used, the fields remain unassigned and the object cannot be used until all the fields are initialized.</p></li>
</ul>
<h2>Class versus Structure</h2>
<p>Classes and Structures have the following basic differences:</p>
<ul class="list">
<li><p>classes are reference types and structs are value types</p></li>
<li><p>structures do not support inheritance</p></li>
<li><p>structures cannot have default constructor</p></li>
</ul>
<p>In the light of the above discussions, let us rewrite the previous example:</p>
<pre class="prettyprint notranslate tryit">
using System;
struct Books
{
   private string title;
   private string author;
   private string subject;
   private int book_id;
   public void getValues(string t, string a, string s, int id)
   {
      title = t;
      author = a;
      subject = s;
      book_id = id;
   }
   public void display()
   {
      Console.WriteLine("Title : {0}", title);
      Console.WriteLine("Author : {0}", author);
      Console.WriteLine("Subject : {0}", subject);
      Console.WriteLine("Book_id :{0}", book_id);
   }

};  

public class testStructure
{
   public static void Main(string[] args)
   {

      Books Book1 = new Books();   /* Declare Book1 of type Book */
      Books Book2 = new Books();   /* Declare Book2 of type Book */

      /* book 1 specification */
      Book1.getValues("C Programming",
      "Nuha Ali", "C Programming Tutorial",6495407);

      /* book 2 specification */
      Book2.getValues("Telecom Billing",
      "Zara Ali", "Telecom Billing Tutorial", 6495700);

      /* print Book1 info */
      Book1.display();

      /* print Book2 info */
      Book2.display(); 

      Console.ReadKey();

   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Title : C Programming
Author : Nuha Ali
Subject : C Programming Tutorial
Book_id : 6495407
Title : Telecom Billing
Author : Zara Ali
Subject : Telecom Billing Tutorial
Book_id : 6495700
</pre>
<h1>C# - Enums</h1>
<p>An enumeration is a set of named integer constants. An enumerated type is declared using the <b>enum</b> keyword.</p>
<p>C# enumerations are value data type. In other words, enumeration contains its own values and cannot inherit or cannot pass inheritance.</p>
<h2>Declaring <i>enum</i> Variable</h2>
<p>The general syntax for declaring an enumeration is:</p>
<pre class="prettyprint notranslate">
enum &lt;enum_name&gt; 
{
   enumeration list 
};
</pre>
<p>Where,</p>
<ul class="list">
<li><p>The <i>enum_name</i> specifies the enumeration type name.</p></li>
<li><p>The <i>enumeration list</i> is a comma-separated list of identifiers.</p></li>
</ul>
<p>Each of the symbols in the enumeration list stands for an integer value, one greater than the symbol that precedes it. By default, the value of the first enumeration symbol is 0. For example:</p>
<pre class="prettyprint notranslate">
enum Days { Sun, Mon, tue, Wed, thu, Fri, Sat };
</pre>
<h2>Example</h2>
<p>The following example demonstrates use of enum variable:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace EnumApplication
{
   class EnumProgram
   {
      enum Days { Sun, Mon, tue, Wed, thu, Fri, Sat };

      static void Main(string[] args)
      {
         int WeekdayStart = (int)Days.Mon;
         int WeekdayEnd = (int)Days.Fri;
         Console.WriteLine("Monday: {0}", WeekdayStart);
         Console.WriteLine("Friday: {0}", WeekdayEnd);
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Monday: 1
Friday: 5
</pre>
<h1>C# - Classes</h1>
<p>When you define a class, you define a blueprint for a data type. This does not actually define any data, but it does define what the class name means. That is, what an object of the class consists of and what operations can be performed on that object. Objects are instances of a class. The methods and variables that constitute a class are called members of the class.</p>
<h2>Defining a Class</h2>
<p>A class definition starts with the keyword class followed by the class name; and the class body enclosed by a pair of curly braces. Following is the general form of a class definition:</p>
<pre class="prettyprint notranslate">
&lt;access specifier&gt; class  class_name
{
   // member variables
   &lt;access specifier&gt; &lt;data type&gt; variable1;
   &lt;access specifier&gt; &lt;data type&gt; variable2;
   ...
   &lt;access specifier&gt; &lt;data type&gt; variableN;
   // member methods
   &lt;access specifier&gt; &lt;return type&gt; method1(parameter_list)
   {
      // method body
   }
   &lt;access specifier&gt; &lt;return type&gt; method2(parameter_list)
   {
      // method body
   }
   ...
   &lt;access specifier&gt; &lt;return type&gt; methodN(parameter_list)
   {
      // method body
   }
}
</pre>
<p>Note:</p>
<ul class="list">
<li><p>Access specifiers specify the access rules for the members as well as the class itself. If not mentioned, then the default access specifier for a class type is <b>internal</b>. Default access for the members is <b>private</b>.</p></li>
<li><p>Data type specifies the type of variable, and return type specifies the data type of the data the method returns, if any.</p></li>
<li><p>To access the class members, you use the dot (.) operator.</p></li>
<li><p>The dot operator links the name of an object with the name of a member.</p></li>
</ul>
<p>The following example illustrates the concepts discussed so far:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace BoxApplication
{
    class Box
    {
       public double length;   // Length of a box
       public double breadth;  // Breadth of a box
       public double height;   // Height of a box
    }
    class Boxtester
    {
        static void Main(string[] args)
        {
            Box Box1 = new Box();   // Declare Box1 of type Box
            Box Box2 = new Box();   // Declare Box2 of type Box
            double volume = 0.0;    // Store the volume of a box here

            // box 1 specification
            Box1.height = 5.0;
            Box1.length = 6.0;
            Box1.breadth = 7.0;

            // box 2 specification
            Box2.height = 10.0;
            Box2.length = 12.0;
            Box2.breadth = 13.0;
           
            // volume of box 1
            volume = Box1.height * Box1.length * Box1.breadth;
            Console.WriteLine("Volume of Box1 : {0}",  volume);

            // volume of box 2
            volume = Box2.height * Box2.length * Box2.breadth;
            Console.WriteLine("Volume of Box2 : {0}", volume);
            Console.ReadKey();
        }
    }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Volume of Box1 : 210
Volume of Box2 : 1560
</pre>
<h2>Member Functions and Encapsulation</h2>
<p>A member function of a class is a function that has its definition or its prototype within the class definition similar to any other variable. It operates on any object of the class of which it is a member, and has access to all the members of a class for that object.</p>
<p>Member variables are the attributes of an object (from design perspective) and they are kept private to implement encapsulation. These variables can only be accessed using the public member functions.</p>
<p>Let us put above concepts to set and get the value of different class members in a class:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace BoxApplication
{
   class Box
   {
      private double length;   // Length of a box
      private double breadth;  // Breadth of a box
      private double height;   // Height of a box
      public void setLength( double len )
      {
         length = len;
      }
      
      public void setBreadth( double bre )
      {
         breadth = bre;
      }
      
      public void setHeight( double hei )
      {
         height = hei;
      }
      public double getVolume()
      {
         return length * breadth * height;
      }
   }
   class Boxtester
   {
      static void Main(string[] args)
      {
         Box Box1 = new Box();   // Declare Box1 of type Box
         Box Box2 = new Box();
         double volume;
         
         // Declare Box2 of type Box
         // box 1 specification
         Box1.setLength(6.0);
         Box1.setBreadth(7.0);
         Box1.setHeight(5.0);
         
         // box 2 specification
         Box2.setLength(12.0);
         Box2.setBreadth(13.0);
         Box2.setHeight(10.0);
         
         // volume of box 1
         volume = Box1.getVolume();
         Console.WriteLine("Volume of Box1 : {0}" ,volume);
         
         // volume of box 2
         volume = Box2.getVolume();
         Console.WriteLine("Volume of Box2 : {0}", volume);
         
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Volume of Box1 : 210
Volume of Box2 : 1560
</pre>
<h2>C# Constructors</h2>
<p>A class <b>constructor</b> is a special member function of a class that is executed whenever we create new objects of that class.</p>
<p>A constructor has exactly the same name as that of class and it does not have any return type. Following example explains the concept of constructor:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace LineApplication
{
   class Line
   {
      private double length;   // Length of a line
      public Line()
      {
         Console.WriteLine("Object is being created");
      }

      public void setLength( double len )
      {
         length = len;
      }
      
      public double getLength()
      {
         return length;
      }

      static void Main(string[] args)
      {
         Line line = new Line();    
         
         // set line length
         line.setLength(6.0);
         Console.WriteLine("Length of line : {0}", line.getLength());
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Object is being created
Length of line : 6
</pre>
<p>A <b>default constructor</b> does not have any parameter but if you need, a constructor can have parameters. Such constructors are called <b>parameterized constructors</b>. This technique helps you to assign initial value to an object at the time of its creation as shown in the following example:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace LineApplication
{
   class Line
   {
      private double length;   // Length of a line
      public Line(double len)  //Parameterized constructor
      {
         Console.WriteLine("Object is being created, length = {0}", len);
         length = len;
      }

      public void setLength( double len )
      {
         length = len;
      }
      public double getLength()
      {
         return length;
      }

      static void Main(string[] args)
      {
         Line line = new Line(10.0);
         Console.WriteLine("Length of line : {0}", line.getLength()); 
         
         // set line length
         line.setLength(6.0);
         Console.WriteLine("Length of line : {0}", line.getLength()); 
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Object is being created, length = 10
Length of line : 10
Length of line : 6
</pre>
<h2>C# Destructors</h2>
<p>A <b>destructor</b> is a special member function of a class that is executed whenever an object of its class goes out of scope. A <b>destructor</b> has exactly the same name as that of the class with a prefixed tilde (~) and it can neither return a value nor can it take any parameters.</p>
<p>Destructor can be very useful for releasing memory resources before exiting the program. Destructors cannot be inherited or overloaded.</p>
<p>Following example explains the concept of destructor:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace LineApplication
{
   class Line
   {
      private double length;   // Length of a line
      public Line()  // constructor
      {
         Console.WriteLine("Object is being created");
      }
      ~Line() //destructor
      {
         Console.WriteLine("Object is being deleted");
      }

      public void setLength( double len )
      {
         length = len;
      }
      
      public double getLength()
      {
         return length;
      }

      static void Main(string[] args)
      {
         Line line = new Line();
         
         // set line length
         line.setLength(6.0);
         Console.WriteLine("Length of line : {0}", line.getLength());           
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Object is being created
Length of line : 6
Object is being deleted
</pre>
<h2>Static Members of a C# Class</h2>
<p>We can define class members as static using the <b>static</b> keyword. When we declare a member of a class as static, it means no matter how many objects of the class are created, there is only one copy of the static member.</p>
<p>The keyword <b>static</b> implies that only one instance of the member exists for a class. Static variables are used for defining constants because their values can be retrieved by invoking the class without creating an instance of it. Static variables can be initialized outside the member function or class definition. You can also initialize static variables inside the class definition.</p>
<p>The following example demonstrates the use of <b>static variables</b>:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace StaticVarApplication
{
   class StaticVar
   {
      public static int num;
      public void count()
      {
         num++;
      }
      public int getNum()
      {
         return num;
      }
   }
   class StaticTester
   {
      static void Main(string[] args)
      {
         StaticVar s1 = new StaticVar();
         StaticVar s2 = new StaticVar();
         s1.count();
         s1.count();
         s1.count();
         s2.count();
         s2.count();
         s2.count();
         Console.WriteLine("Variable num for s1: {0}", s1.getNum());
         Console.WriteLine("Variable num for s2: {0}", s2.getNum());
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Variable num for s1: 6
Variable num for s2: 6
</pre>
<p>You can also declare a <b>member function</b> as <b>static</b>. Such functions can access only static variables. The static functions exist even before the object is created. The following example demonstrates the use of <b>static functions</b>:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace StaticVarApplication
{
   class StaticVar
   {
      public static int num;
      public void count()
      {
         num++;
      }
      public static int getNum()
      {
         return num;
      }
   }
   class StaticTester
   {
      static void Main(string[] args)
      {
         StaticVar s = new StaticVar();
         s.count();
         s.count();
         s.count();
         Console.WriteLine("Variable num: {0}", StaticVar.getNum());
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Variable num: 3
</pre>
<h1>C# - Inheritance</h1>
<p>One of the most important concepts in object-oriented programming is inheritance. Inheritance allows us to define a class in terms of another class, which makes it easier to create and maintain an application. This also provides an opportunity to reuse the code functionality and speeds up implementation time.</p>
<p>When creating a class, instead of writing completely new data members and member functions, the programmer can designate that the new class should inherit the members of an existing class. This existing class is called the <b>base</b> class, and the new class is referred to as the <b>derived</b> class.</p>
<p>The idea of inheritance implements the <b>IS-A</b> relationship. For example, mammal <b>IS A</b> animal, dog <b>IS-A</b> mammal hence dog <b>IS-A</b> animal as well, and so on.</p>
<h2>Base and Derived Classes</h2>
<p>A class can be derived from more than one class or interface, which means that it can inherit data and functions from multiple base classes or interfaces.</p>
<p>The syntax used in C# for creating derived classes is as follows:</p>
<pre class="prettyprint notranslate">
&lt;acess-specifier&gt; class &lt;base_class&gt;
{
   ...
}
class &lt;derived_class&gt; : &lt;base_class&gt;
{
   ...
}
</pre>
<p>Consider a base class Shape and its derived class Rectangle:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace InheritanceApplication
{
   class Shape 
   {
      public void setWidth(int w)
      {
         width = w;
      }
      public void setHeight(int h)
      {
         height = h;
      }
      protected int width;
      protected int height;
   }

   // Derived class
   class Rectangle: Shape
   {
      public int getArea()
      { 
         return (width * height); 
      }
   }
   
   class RectangleTester
   {
      static void Main(string[] args)
      {
         Rectangle Rect = new Rectangle();

         Rect.setWidth(5);
         Rect.setHeight(7);

         // Print the area of the object.
         Console.WriteLine("Total area: {0}",  Rect.getArea());
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Total area: 35
</pre>
<h2>Initializing Base Class</h2>
<p>The derived class inherits the base class member variables and member methods. Therefore the super class object should be created before the subclass is created. You can give instructions for superclass initialization in the member initialization list.</p>
<p>The following program demonstrates this:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace RectangleApplication
{
   class Rectangle
   {
      //member variables
      protected double length;
      protected double width;
      public Rectangle(double l, double w)
      {
         length = l;
         width = w;
      }
      
      public double GetArea()
      {
         return length * width;
      }
      
      public void Display()
      {
         Console.WriteLine("Length: {0}", length);
         Console.WriteLine("Width: {0}", width);
         Console.WriteLine("Area: {0}", GetArea());
      }
   }//end class Rectangle  
   
   class Tabletop : Rectangle
   {
      private double cost;
      public Tabletop(double l, double w) : base(l, w)
      { }
      public double GetCost()
      {
         double cost;
         cost = GetArea() * 70;
         return cost;
      }
      public void Display()
      {
         base.Display();
         Console.WriteLine("Cost: {0}", GetCost());
      }
   }
   class ExecuteRectangle
   {
      static void Main(string[] args)
      {
         Tabletop t = new Tabletop(4.5, 7.5);
         t.Display();
         Console.ReadLine();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Length: 4.5
Width: 7.5
Area: 33.75
Cost: 2362.5
</pre>
<h2>Multiple Inheritance in C#</h2>
<p><b>C# does not support multiple inheritance</b>. However, you can use interfaces to implement multiple inheritance. The following program demonstrates this:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace InheritanceApplication
{
   class Shape 
   {
      public void setWidth(int w)
      {
         width = w;
      }
      public void setHeight(int h)
      {
         height = h;
      }
      protected int width;
      protected int height;
   }

   // Base class PaintCost
   public interface PaintCost 
   {
      int getCost(int area);

   }
   
   // Derived class
   class Rectangle : Shape, PaintCost
   {
      public int getArea()
      {
         return (width * height);
      }
      public int getCost(int area)
      {
         return area * 70;
      }
   }
   class RectangleTester
   {
      static void Main(string[] args)
      {
         Rectangle Rect = new Rectangle();
         int area;
         Rect.setWidth(5);
         Rect.setHeight(7);
         area = Rect.getArea();
         
         // Print the area of the object.
         Console.WriteLine("Total area: {0}",  Rect.getArea());
         Console.WriteLine("Total paint cost: ${0}" , Rect.getCost(area));
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Total area: 35
Total paint cost: $2450
</pre>
<h1>C# - Polymorphism</h1>
<p>The word <b>polymorphism</b> means having many forms. In object-oriented programming paradigm, polymorphism is often expressed as 'one interface, multiple functions'.</p>
<p>Polymorphism can be static or dynamic. In <b>static polymorphism</b>, the response to a function is determined at the compile time. In <b>dynamic polymorphism</b>, it is decided at run-time.</p>
<h2>Static Polymorphism</h2>
<p>The mechanism of linking a function with an object during compile time is called early binding. It is also called static binding. C# provides two techniques to implement static polymorphism. They are:</p>
<ul class="list">
<li>Function overloading</li>
<li>Operator overloading</li>
</ul>
<p>We discuss operator overloading in next chapter.</p>
<h2>Function Overloading</h2>
<p>You can have multiple definitions for the same function name in the same scope. The definition of the function must differ from each other by the types and/or the number of arguments in the argument list. You cannot overload function declarations that differ only by return type.</p>
<p>The following example shows using function <b>print()</b> to print different data types:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace PolymorphismApplication
{
   class Printdata
   {
      void print(int i)
      {
         Console.WriteLine("Printing int: {0}", i );
      }

      void print(double f)
      {
         Console.WriteLine("Printing float: {0}" , f);
      }

      void print(string s)
      {
         Console.WriteLine("Printing string: {0}", s);
      }
      static void Main(string[] args)
      {
         Printdata p = new Printdata();
         
         // Call print to print integer
         p.print(5);
         
         // Call print to print float
         p.print(500.263);
         
         // Call print to print string
         p.print("Hello C++");
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Printing int: 5
Printing float: 500.263
Printing string: Hello C++
</pre>
<h2>Dynamic Polymorphism</h2>
<p>C# allows you to create abstract classes that are used to provide partial class implementation of an interface. Implementation is completed when a derived class inherits from it. <b>Abstract</b> classes contain abstract methods, which are implemented by the derived class. The derived classes have more specialized functionality.</p>
<p>Here are the rules about abstract classes:</p>
<ul class="list">
<li><p>You cannot create an instance of an abstract class</p></li>
<li><p>You cannot declare an abstract method outside an abstract class</p></li>
<li><p>When a class is declared <b>sealed</b>, it cannot be inherited, abstract classes cannot be declared sealed.</p></li>
</ul>
<p>The following program demonstrates an abstract class:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace PolymorphismApplication
{
   abstract class Shape
   {
      public abstract int area();
   }
   class Rectangle:  Shape
   {
      private int length;
      private int width;
      public Rectangle( int a=0, int b=0)
      {
         length = a;
         width = b;
      }
      public override int area ()
      { 
         Console.WriteLine("Rectangle class area :");
         return (width * length); 
      }
   }

   class RectangleTester
   {
      static void Main(string[] args)
      {
         Rectangle r = new Rectangle(10, 7);
         double a = r.area();
         Console.WriteLine("Area: {0}",a);
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Rectangle class area :
Area: 70
</pre>
<p>When you have a function defined in a class that you want to be implemented in an inherited class(es), you use <b>virtual</b> functions. The virtual functions could be implemented differently in different inherited class and the call to these functions will be decided at runtime.</p>
<p>Dynamic polymorphism is implemented by <b>abstract classes</b> and <b>virtual functions</b>.</p>
<p>The following program demonstrates this:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace PolymorphismApplication
{
   class Shape 
   {
      protected int width, height;
      public Shape( int a=0, int b=0)
      {
         width = a;
         height = b;
      }
      public virtual int area()
      {
         Console.WriteLine("Parent class area :");
         return 0;
      }
   }
   class Rectangle: Shape
   {
      public Rectangle( int a=0, int b=0): base(a, b)
      {

      }
      public override int area ()
      {
         Console.WriteLine("Rectangle class area :");
         return (width * height); 
      }
   }
   class Triangle: Shape
   {
      public Triangle(int a = 0, int b = 0): base(a, b)
      {
      
      }
      public override int area()
      {
         Console.WriteLine("Triangle class area :");
         return (width * height / 2); 
      }
   }
   class Caller
   {
      public void CallArea(Shape sh)
      {
         int a;
         a = sh.area();
         Console.WriteLine("Area: {0}", a);
      }
   }  
   class Tester
   {
      
      static void Main(string[] args)
      {
         Caller c = new Caller();
         Rectangle r = new Rectangle(10, 7);
         Triangle t = new Triangle(10, 5);
         c.CallArea(r);
         c.CallArea(t);
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Rectangle class area:
Area: 70
Triangle class area:
Area: 25
</pre>
<h1>C# - Operator Overloading</h1>
<p>You can redefine or overload most of the built-in operators available in C#. Thus a programmer can use operators with user-defined types as well. Overloaded operators are functions with special names the keyword <b>operator</b> followed by the symbol for the operator being defined. similar to any other function, an overloaded operator has a return type and a parameter list.</p>
<p>For example, go through the following function:</p>
<pre class="prettyprint notranslate">
public static Box operator+ (Box b, Box c)
{
   Box box = new Box();
   box.length = b.length + c.length;
   box.breadth = b.breadth + c.breadth;
   box.height = b.height + c.height;
   return box;
}
</pre>
<p>The above function implements the addition operator (+) for a user-defined class Box. It adds the attributes of two Box objects and returns the resultant Box object.</p>
<h2>Implementing the Operator Overloading</h2>
<p>The following program shows the complete implementation:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace OperatorOvlApplication
{
   class Box
   {
      private double length;   // Length of a box
      private double breadth;  // Breadth of a box
      private double height;   // Height of a box

      public double getVolume()
      {
         return length * breadth * height;
      }
      
      public void setLength( double len )
      {
         length = len;
      }

      public void setBreadth( double bre )
      {
         breadth = bre;
      }

      public void setHeight( double hei )
      {
         height = hei;
      }
      
      // Overload + operator to add two Box objects.
      public static Box operator+ (Box b, Box c)
      {
         Box box = new Box();
         box.length = b.length + c.length;
         box.breadth = b.breadth + c.breadth;
         box.height = b.height + c.height;
         return box;
      }

   }

   class Tester
   {
      static void Main(string[] args)
      {
         Box Box1 = new Box();   // Declare Box1 of type Box
         Box Box2 = new Box();   // Declare Box2 of type Box
         Box Box3 = new Box();   // Declare Box3 of type Box
         double volume = 0.0;    // Store the volume of a box here

         // box 1 specification
         Box1.setLength(6.0);
         Box1.setBreadth(7.0);
         Box1.setHeight(5.0);

         // box 2 specification
         Box2.setLength(12.0);
         Box2.setBreadth(13.0);
         Box2.setHeight(10.0);

         // volume of box 1
         volume = Box1.getVolume();
         Console.WriteLine("Volume of Box1 : {0}", volume);

         // volume of box 2
         volume = Box2.getVolume();
         Console.WriteLine("Volume of Box2 : {0}", volume);

         // Add two object as follows:
         Box3 = Box1 + Box2;

         // volume of box 3
         volume = Box3.getVolume();
         Console.WriteLine("Volume of Box3 : {0}", volume);
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Volume of Box1 : 210
Volume of Box2 : 1560
Volume of Box3 : 5400
</pre>
<h2>Overloadable and Non-Overloadable Operators</h2>
<p>The following table describes the overload ability of the operators in C#:</p>
<table class="table table-bordered">
<tr>
<th style="width:25%;">Operators</th>
<th>Description</th>
</tr>
<tr>
<td>+, -, !, ~, ++, --</td>
<td>These unary operators take one operand and can be overloaded.</td>
</tr>
<tr>
<td>+, -, *, /, %</td>
<td>These binary operators take one operand and can be overloaded.</td>
</tr>
<tr>
<td>==, !=, &lt;, &gt;, &lt;=, &gt;=</td>
<td>The comparison operators can be overloaded</td>
</tr>
<tr>
<td>&amp;&amp;, ||</td>
<td>The conditional logical operators cannot be overloaded directly.</td>
</tr>
<tr>
<td>+=, -=, *=, /=, %=</td>
<td>The assignment operators cannot be overloaded.</td>
</tr>
<tr>
<td>=, ., ?:, ->, new, is, sizeof, typeof</td>
<td>These operators cannot be overloaded.</td>
</tr>
</table>
<h2>Example</h2>
<p>In the light of the above discussions, let us extend the preceding example, and overload few more operators:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace OperatorOvlApplication
{
   class Box
   {
      private double length;    // Length of a box
      private double breadth;   // Breadth of a box
      private double height;    // Height of a box
      
      public double getVolume()
      {
         return length * breadth * height;
      }
      
      public void setLength( double len )
      {
         length = len;
      }
      
      public void setBreadth( double bre )
      {
         breadth = bre;
      }
      
      
      public void setHeight( double hei )
      {
         height = hei;
      }
      
      // Overload + operator to add two Box objects.
      public static Box operator+ (Box b, Box c)
      {
         Box box = new Box();
         box.length = b.length + c.length;
         box.breadth = b.breadth + c.breadth;
         box.height = b.height + c.height;
         return box;
      }
      
      public static bool operator == (Box lhs, Box rhs)
      {
         bool status = false;
         if (lhs.length == rhs.length && lhs.height == rhs.height &amp;&amp; lhs.breadth == rhs.breadth)
         {
            status = true;
         }
         return status;
      }
      
      public static bool operator !=(Box lhs, Box rhs)
      {
         bool status = false;
         if (lhs.length != rhs.length || lhs.height != rhs.height || lhs.breadth != rhs.breadth)
         {
            status = true;
         }
         return status;
      }
      
      public static bool operator &lt;(Box lhs, Box rhs)
      {
         bool status = false;
         if (lhs.length &lt; rhs.length &amp;&amp; lhs.height &lt; rhs.height && lhs.breadth &lt; rhs.breadth)
         {
            status = true;
         }
         return status;
      }
      
      public static bool operator &gt;(Box lhs, Box rhs)
      {
         bool status = false;
         if (lhs.length &gt; rhs.length && lhs.height &gt; rhs.height &amp;&amp; lhs.breadth &gt; rhs.breadth)
         {
            status = true;
         }
         return status;
      }
      
      public static bool operator &lt;=(Box lhs, Box rhs)
      {
         bool status = false;
         if (lhs.length &lt;= rhs.length &amp;&amp; lhs.height &lt;= rhs.height && lhs.breadth &lt;= rhs.breadth)
         {
            status = true;
         }
         return status;
      }
      
      public static bool operator &gt;=(Box lhs, Box rhs)
      {
         bool status = false;
         if (lhs.length &gt;= rhs.length &amp;&amp; lhs.height &gt;= rhs.height && lhs.breadth &gt;= rhs.breadth)
         {
            status = true;
         }
         return status;
      }
      public override string ToString()
      {
         return String.Format("({0}, {1}, {2})", length, breadth, height);
      }
   }
   
   class Tester
   {
      static void Main(string[] args)
      {
         Box Box1 = new Box();   // Declare Box1 of type Box
         Box Box2 = new Box();   // Declare Box2 of type Box
         Box Box3 = new Box();   // Declare Box3 of type Box
         Box Box4 = new Box();
         double volume = 0.0;    // Store the volume of a box here
         
         // box 1 specification
         Box1.setLength(6.0);
         Box1.setBreadth(7.0);
         Box1.setHeight(5.0);
         
         // box 2 specification
         Box2.setLength(12.0);
         Box2.setBreadth(13.0);
         Box2.setHeight(10.0);
         
         //displaying the Boxes using the overloaded ToString():
         Console.WriteLine("Box 1: {0}", Box1.ToString());
         Console.WriteLine("Box 2: {0}", Box2.ToString());
         
         // volume of box 1
         volume = Box1.getVolume();
         Console.WriteLine("Volume of Box1 : {0}", volume);
         
         // volume of box 2
         volume = Box2.getVolume();
         Console.WriteLine("Volume of Box2 : {0}", volume);
         
         // Add two object as follows:
         Box3 = Box1 + Box2;
         Console.WriteLine("Box 3: {0}", Box3.ToString());
         
         // volume of box 3
         volume = Box3.getVolume();
         Console.WriteLine("Volume of Box3 : {0}", volume);
         
         //comparing the boxes
         if (Box1 &gt; Box2)
            Console.WriteLine("Box1 is greater than Box2");
         else
            Console.WriteLine("Box1 is  greater than Box2");
         
         if (Box1 &lt; Box2)
            Console.WriteLine("Box1 is less than Box2");
         else
            Console.WriteLine("Box1 is not less than Box2");
         
         if (Box1 &gt;= Box2)
            Console.WriteLine("Box1 is greater or equal to Box2");
         else
            Console.WriteLine("Box1 is not greater or equal to Box2");
         
         if (Box1 &lt;= Box2)
            Console.WriteLine("Box1 is less or equal to Box2");
         else
            Console.WriteLine("Box1 is not less or equal to Box2");
         
         if (Box1 != Box2)
            Console.WriteLine("Box1 is not equal to Box2");
         else
            Console.WriteLine("Box1 is not greater or equal to Box2");
         Box4 = Box3;
         
         if (Box3 == Box4)
            Console.WriteLine("Box3 is equal to Box4");
         else
            Console.WriteLine("Box3 is not equal to Box4");
         
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Box 1: (6, 7, 5)
Box 2: (12, 13, 10)
Volume of Box1 : 210
Volume of Box2 : 1560
Box 3: (18, 20, 15)
Volume of Box3 : 5400
Box1 is not greater than Box2
Box1 is less than Box2
Box1 is not greater or equal to Box2
Box1 is less or equal to Box2
Box1 is not equal to Box2
Box3 is equal to Box4
</pre>
<h1>C# - Interfaces</h1>
<p>An interface is defined as a syntactical contract that all the classes inheriting the interface should follow. The interface defines the <b>'what'</b> part of the syntactical contract and the deriving classes define the <b>'how'</b> part of the syntactical contract. </p>
<p>Interfaces define properties, methods, and events, which are the members of the interface. Interfaces contain only the declaration of the members. It is the responsibility of the deriving class to define the members. It often helps in providing a standard structure that the deriving classes would follow.</p>
<p>Abstract classes to some extent serve the same purpose, however, they are mostly used when only few methods are to be declared by the base class and the deriving class implements the functionalities.</p>
<h2>Declaring Interfaces</h2>
<p>Interfaces are declared using the interface keyword. It is similar to class declaration. Interface statements are public by default. Following is an example of an interface declaration:</p>
<pre class="prettyprint notranslate">
public interface ITransactions
{
   // interface members
   void showTransaction();
   double getAmount();
}
</pre>
<h2>Example</h2>
<p>The following example demonstrates implementation of the above interface:</p>
<pre class="prettyprint notranslate tryit">
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System;

namespace InterfaceApplication
{
   public interface ITransactions
   {
      // interface members
      void showTransaction();
      double getAmount();
   }
   
   public class Transaction : ITransactions
   {
      private string tCode;
      private string date;
      private double amount;
      public Transaction()
      {
         tCode = " ";
         date = " ";
         amount = 0.0;
      }
      
      public Transaction(string c, string d, double a)
      {
         tCode = c;
         date = d;
         amount = a;
      }
      
      public double getAmount()
      {
         return amount;
      }
      
      public void showTransaction()
      {
         Console.WriteLine("Transaction: {0}", tCode);
         Console.WriteLine("Date: {0}", date);
         Console.WriteLine("Amount: {0}", getAmount());
      }
   }
   class Tester
   {
      static void Main(string[] args)
      {
         Transaction t1 = new Transaction("001", "8/10/2012", 78900.00);
         Transaction t2 = new Transaction("002", "9/10/2012", 451900.00);
         t1.showTransaction();
         t2.showTransaction();
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Transaction: 001
Date: 8/10/2012
Amount: 78900
Transaction: 002
Date: 9/10/2012
Amount: 451900
</pre>
<h1>C# - Namespaces</h1>
<p>A <b>namespace</b> is designed for providing a way to keep one set of names separate from another. The class names declared in one namespace does not conflict with the same class names declared in another.</p>
<h2>Defining a Namespace</h2>
<p>A namespace definition begins with the keyword <b>namespace</b> followed by the namespace name as follows:</p>
<pre class="prettyprint notranslate">
namespace namespace_name
{
   // code declarations
}
</pre>
<p>To call the namespace-enabled version of either function or variable, prepend the namespace name as follows:</p>
<pre class="prettyprint notranslate">
namespace_name.item_name;
</pre>
<p>The following program demonstrates use of namespaces:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace first_space
{
   class namespace_cl
   {
      public void func()
      {
         Console.WriteLine("Inside first_space");
      }
   }
}

namespace second_space
{
   class namespace_cl
   {
      public void func()
      {
         Console.WriteLine("Inside second_space");
      }
   }
}

class TestClass
{
   static void Main(string[] args)
   {
      first_space.namespace_cl fc = new first_space.namespace_cl();
      second_space.namespace_cl sc = new second_space.namespace_cl();
      fc.func();
      sc.func();
      Console.ReadKey();
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Inside first_space
Inside second_space
</pre>
<h2>The <i>using</i> Keyword</h2>
<p>The <b>using</b> keyword states that the program is using the names in the given namespace. For example, we are using the <b>System</b> namespace in our programs. The class Console is defined there. We just write:</p>
<pre class="prettyprint notranslate">
Console.WriteLine ("Hello there");
</pre>
<p>We could have written the fully qualified name as:</p>
<pre class="prettyprint notranslate">
System.Console.WriteLine("Hello there");
</pre>
<p>You can also avoid prepending of namespaces with the <b>using</b> namespace directive. This directive tells the compiler that the subsequent code is making use of names in the specified namespace. The namespace is thus implied for the following code:</p>
<p>Let us rewrite our preceding example, with using directive:</p>
<pre class="prettyprint notranslate tryit">
using System;
using first_space;
using second_space;

namespace first_space
{
   class abc
   {
      public void func()
      {
         Console.WriteLine("Inside first_space");
      }
   }
}

namespace second_space
{
   class efg
   {
      public void func()
      {
         Console.WriteLine("Inside second_space");
      }
   }
}   

class TestClass
{
   static void Main(string[] args)
   {
      abc fc = new abc();
      efg sc = new efg();
      fc.func();
      sc.func();
      Console.ReadKey();
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Inside first_space
Inside second_space
</pre>
<h2>Nested Namespaces</h2>
<p>You can define one namespace inside another namespace as follows:</p>
<pre class="prettyprint notranslate">
namespace namespace_name1
{
   // code declarations
   namespace namespace_name2
   {
      // code declarations
   }
}
</pre>
<p>You can access members of nested namespace by using the dot (.) operator as follows:</p>
<pre class="prettyprint notranslate tryit">
using System;
using first_space;
using first_space.second_space;

namespace first_space
{
   class abc
   {
      public void func()
      {
         Console.WriteLine("Inside first_space");
      }
   }
   namespace second_space
   {
      class efg
      {
         public void func()
         {
            Console.WriteLine("Inside second_space");
         }
      }
   }   
}
 
class TestClass
{
   static void Main(string[] args)
   {
      abc fc = new abc();
      efg sc = new efg();
      fc.func();
      sc.func();
      Console.ReadKey();
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Inside first_space
Inside second_space
</pre>
<h1>C# - Preprocessor Directives</h1>
<p>The preprocessor directives give instruction to the compiler to preprocess the information before actual compilation starts.</p>
<p>All preprocessor directives begin with #, and only white-space characters may appear before a preprocessor directive on a line. Preprocessor directives are not statements, so they do not end with a semicolon (;).</p>
<p>C# compiler does not have a separate preprocessor; however, the directives are processed as if there was one. In C# the preprocessor directives are used to help in conditional compilation. Unlike C and C++ directives, they are not used to create macros. A preprocessor directive must be the only instruction on a line.</p>
<h2>Preprocessor Directives in C#</h2>
<p>The following table lists the preprocessor directives available in C#:</p>
<table class="table table-bordered">
<tr>
<th style="width:20%;">Preprocessor Directive</th>
<th>Description.</th>
</tr>
<tr>
<td>#define</td>
<td>It defines a sequence of characters, called symbol.</td>
</tr>
<tr>
<td>#undef</td>
<td>It allows you to undefine a symbol.</td>
</tr>
<tr>
<td>#if</td>
<td>It allows testing a symbol or symbols to see if they evaluate to true.</td>
</tr>
<tr>
<td>#else</td>
<td>It allows to create a compound conditional directive, along with #if.</td>
</tr>
<tr>
<td>#elif</td>
<td>It allows creating a compound conditional directive.</td>
</tr>
<tr>
<td>#endif</td>
<td>Specifies the end of a conditional directive.</td>
</tr>
<tr>
<td>#line</td>
<td>It lets you modify the compiler's line number and (optionally) the file name output for errors and warnings.</td>
</tr>
<tr>
<td>#error</td>
<td>It allows generating an error from a specific location in your code.</td>
</tr>
<tr>
<td>#warning</td>
<td>It allows generating a level one warning from a specific location in your code.</td>
</tr>
<tr>
<td>#region</td>
<td>It lets you specify a block of code that you can expand or collapse when using the outlining feature of the Visual Studio Code Editor.</td>
</tr>
<tr>
<td>#endregion</td>
<td>It marks the end of a #region block.</td>
</tr>
</table>
<h2>The #define Preprocessor</h2>
<p>The #define preprocessor directive creates symbolic constants.</p>
<p>#define lets you define a symbol such that, by using the symbol as the expression passed to the #if directive, the expression evaluates to true. Its syntax is as follows:</p>
<pre class="prettyprint notranslate">
#define symbol
</pre>
<p>The following program illustrates this:</p>
<pre class="prettyprint notranslate tryit">
#define PI 
using System;
namespace PreprocessorDAppl
{
   class Program
   {
      static void Main(string[] args)
      {
         #if (PI)
            Console.WriteLine("PI is defined");
         #else
            Console.WriteLine("PI is not defined");
         #endif
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
PI is defined
</pre>
<h2>Conditional Directives</h2>
<p>You can use the #if directive to create a conditional directive. Conditional directives are useful for testing a symbol or symbols to check if they evaluate to true. If they do evaluate to true, the compiler evaluates all the code between the #if and the next directive.</p>
<p>Syntax for conditional directive is:</p>
<pre class="prettyprint notranslate">
#if symbol [operator symbol]...
</pre>
<p>Where, <i>symbol</i> is the name of the symbol you want to test. You can also use true and false or prepend the symbol with the negation operator.</p>
<p>The <i>operator symbol</i> is the operator used for evaluating the symbol. Operators could be either of the following:</p>
<ul class="list">
<li>== (equality)</li>
<li>!= (inequality)</li>
<li>&amp;&amp; (and)</li>
<li>|| (or)</li>
</ul>
<p>You can also group symbols and operators with parentheses. Conditional directives are used for compiling code for a debug build or when compiling for a specific configuration. A conditional directive beginning with a <b>#if</b> directive must explicitly be terminated with a <b>#endif</b> directive.</p>
<p>The following program demonstrates use of conditional directives:</p>
<pre class="prettyprint notranslate tryit">
#define DEBUG
#define VC_V10
using System;
public class TestClass
{
   public static void Main()
   {
      #if (DEBUG && !VC_V10)
         Console.WriteLine("DEBUG is defined");
      #elif (!DEBUG && VC_V10)
         Console.WriteLine("VC_V10 is defined");
      #elif (DEBUG && VC_V10)
         Console.WriteLine("DEBUG and VC_V10 are defined");
      #else
         Console.WriteLine("DEBUG and VC_V10 are not defined");
      #endif
      Console.ReadKey();
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
DEBUG and VC_V10 are defined
</pre>
<h1>C# - Regular Expressions</h1>
<p>A <b>regular expression</b> is a pattern that could be matched against an input text. The .Net framework provides a regular expression engine that allows such matching. A pattern consists of one or more character literals, operators, or constructs.</p>
<h2>Constructs for Defining Regular Expressions</h2>
<p>There are various categories of characters, operators, and constructs that lets you to define regular expressions. Click the following links to find these constructs.</p>
<ul class="list">
<li><p><a href="/csharp/csharp_character_escapes.htm" title="csharp character escapes regular expression">Character escapes</a></p></li>
<li><p><a href="/csharp/csharp_character_classes.htm" title="csharp character classes regular expression">Character classes</a></p></li>
<li><p><a href="/csharp/csharp_anchors.htm" title="csharp anchors regular expression">Anchors</a></p></li>
<li><p><a href="/csharp/csharp_grouping_constructs.htm" title="csharp grouping constructs regular expression">Grouping constructs</a></p></li>
<li><p><a href="/csharp/csharp_quantifiers.htm" title="csharp quantifiers regular expression">Quantifiers</a></p></li>
<li><p><a href="/csharp/csharp_backreference_constructs.htm" title="csharp backreference constructs regular expression">Backreference constructs</a></p></li>
<li><p><a href="/csharp/csharp_alternation_constructs.htm" title="csharp alternation constructs regular expression">Alternation constructs</a></p></li>
<li><p><a href="/csharp/csharp_substitutions.htm" title="csharp substitutions regular expression">Substitutions</a></p></li>
<li><p><a href="/csharp/csharp_miscellaneous_constructs.htm" title="csharp miscellaneous constructs regular expression">Miscellaneous constructs</a></p></li>
</ul>
<h2>The Regex Class</h2>
<p>The Regex class is used for representing a regular expression. It has the following commonly used methods:</p>
<table class="table table-bordered">
<tr>
<th style="width:5%;">Sr.No</th>
<th>Methods</th>
</tr>
<tr>
<td>1</td>
<td>
<b>public bool IsMatch(string input)</b>
<p>Indicates whether the regular expression specified in the Regex constructor finds a match in a specified input string.</p>
</td>
</tr>
<tr>
<td>2</td>
<td><b>public bool IsMatch(string input, int startat)</b>
<p>Indicates whether the regular expression specified in the Regex constructor finds a match in the specified input string, beginning at the specified starting position in the string.</p>
</td>
</tr>
<tr>
<td>3</td>
<td><b>public static bool IsMatch(string input, string pattern)</b>
<p>Indicates whether the specified regular expression finds a match in the specified input string.</p>
</td>
</tr>
<tr>
<td>4</td>
<td>
<b>public MatchCollection Matches(string input)</b>
<p>Searches the specified input string for all occurrences of a regular expression.</p>
</td>
</tr>
<tr>
<td>5</td>
<td><b>public string Replace(string input, string replacement)</b>
<p>In a specified input string, replaces all strings that match a regular expression pattern with a specified replacement string.</p>
</td>
</tr>
<tr>
<td>6</td>
<td>
<b>public string[] Split(string input)</b>
<p>Splits an input string into an array of substrings at the positions defined by a regular expression pattern specified in the Regex constructor.</p>
</td>
</tr>
</table>
<p>For the complete list of methods and properties, please read the Microsoft documentation on C#.</p>
<h2>Example 1</h2>
<p>The following example matches words that start with 'S':</p>
<pre class="prettyprint notranslate tryit">
using System;
using System.Text.RegularExpressions;

namespace RegExApplication
{
   class Program
   {
      private static void showMatch(string text, string expr)
      {
         Console.WriteLine("The Expression: " + expr);
         MatchCollection mc = Regex.Matches(text, expr);
         foreach (Match m in mc)
         {
            Console.WriteLine(m);
         }
      }
      
      static void Main(string[] args)
      {
         string str = "A Thousand Splendid Suns";
         
         Console.WriteLine("Matching words that start with 'S': ");
         showMatch(str, @"\bS\S*");
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Matching words that start with 'S':
The Expression: \bS\S*
Splendid
Suns
</pre>
<h2>Example 2</h2>
<p>The following example matches words that start with 'm' and ends with 'e':</p>
<pre class="prettyprint notranslate tryit">
using System;
using System.Text.RegularExpressions;

namespace RegExApplication
{
   class Program
   {
      private static void showMatch(string text, string expr)
      {
         Console.WriteLine("The Expression: " + expr);
         MatchCollection mc = Regex.Matches(text, expr);
         foreach (Match m in mc)
         {
            Console.WriteLine(m);
         }
      }
      static void Main(string[] args)
      {
         string str = "make maze and manage to measure it";

         Console.WriteLine("Matching words start with 'm' and ends with 'e':");
         showMatch(str, @"\bm\S*e\b");
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Matching words start with 'm' and ends with 'e':
The Expression: \bm\S*e\b
make
maze
manage
measure
</pre>
<h2>Example 3</h2>
<p>This example replaces extra white space:</p>
<pre class="prettyprint notranslate">
using System;
using System.Text.RegularExpressions;

namespace RegExApplication
{
   class Program
   {
      static void Main(string[] args)
      {
         string input = "Hello   World   ";
         string pattern = "\\s+";
         string replacement = " ";
         Regex rgx = new Regex(pattern);
         string result = rgx.Replace(input, replacement);

         Console.WriteLine("Original String: {0}", input);
         Console.WriteLine("Replacement String: {0}", result);    
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Original String: Hello World   
Replacement String: Hello World   
</pre>
<h1>C# - Exception Handling</h1>
<p>An exception is a problem that arises during the execution of a program. A C# exception is a response to an exceptional circumstance that arises while a program is running, such as an attempt to divide by zero.</p>
<p>Exceptions provide a way to transfer control from one part of a program to another. C# exception handling is built upon four keywords: <b>try</b>, <b>catch</b>, <b>finally</b>, and <b>throw</b>.</p>
<ul class="list">
<li><p><b>try</b>: A try block identifies a block of code for which particular exceptions is activated. It is followed by one or more catch blocks.</p></li>
<li><p><b>catch</b>: A program catches an exception with an exception handler at the place in a program where you want to handle the problem. The catch keyword indicates the catching of an exception.</p></li>
<li><p><b>finally</b>: The finally block is used to execute a given set of statements, whether an exception is thrown or not thrown. For example, if you open a file, it must be closed whether an exception is raised or not.</p></li>
<li><p><b>throw</b>: A program throws an exception when a problem shows up. This is done using a throw keyword.</p></li>
</ul>
<h2>Syntax</h2>
<p>Assuming a block raises an exception, a method catches an exception using a combination of the try and catch keywords. A try/catch block is placed around the code that might generate an exception. Code within a try/catch block is referred to as protected code, and the syntax for using try/catch looks like the following:</p>
<pre class="prettyprint notranslate">
try
{
   // statements causing exception
}
catch( ExceptionName e1 )
{
   // error handling code
}
catch( ExceptionName e2 )
{
   // error handling code
}
catch( ExceptionName eN )
{
   // error handling code
}
finally
{
   // statements to be executed
}
</pre>
<p>You can list down multiple catch statements to catch different type of exceptions in case your try block raises more than one exception in different situations.</p>
<h2>Exception Classes in C#</h2>
<p>C# exceptions are represented by classes. The exception classes in C# are mainly directly or indirectly derived from the <b>System.Exception</b> class. Some of the exception classes derived from the System.Exception class are the <b>System.ApplicationException</b> and <b>  System.SystemException</b> classes.</p>
<p>The <b>System.ApplicationException</b> class supports exceptions generated by application programs. Hence the exceptions defined by the programmers should derive from this class.</p>
<p>The <b>System.SystemException</b> class is the base class for all predefined system exception.</p>
<p>The following table provides some of the predefined exception classes derived from the Sytem.SystemException class:</p>
<table class="table table-bordered">
<tr>
<th style="width:40%;">Exception Class</th>
<th>Description</th>
</tr>
<tr>
<td>System.IO.IOException</td>
<td>Handles I/O errors.</td>
</tr>
<tr>
<td>System.IndexOutOfRangeException</td>
<td>Handles errors generated when a method refers to an array index out of range.</td>
</tr>
<tr>
<td>System.ArrayTypeMismatchException</td>
<td>Handles errors generated when type is mismatched with the array type.</td>
</tr>
<tr>
<td>System.NullReferenceException</td>
<td>Handles errors generated from referencing a null object.</td>
</tr>
<tr>
<td>System.DivideByZeroException</td>
<td>Handles errors generated from dividing a dividend with zero.</td>
</tr>
<tr>
<td>System.InvalidCastException</td>
<td>Handles errors generated during typecasting.</td>
</tr>
<tr>
<td>System.OutOfMemoryException</td>
<td>Handles errors generated from insufficient free memory.</td>
</tr>
<tr>
<td>System.StackOverflowException</td>
<td>Handles errors generated from stack overflow.</td>
</tr>
</table>
<h2>Handling Exceptions</h2>
<p>C# provides a structured solution to the exception handling in the form of try and catch blocks. Using these blocks the core program statements are separated from the error-handling statements.</p>
<p>These error handling blocks are implemented using the <b>try</b>, <b>catch</b>, and <b>finally</b> keywords. Following is an example of throwing an exception when dividing by zero condition occurs:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace ErrorHandlingApplication
{
   class DivNumbers
   {
      int result;
      DivNumbers()
      {
         result = 0;
      }
      public void division(int num1, int num2)
      {
         try
         {
            result = num1 / num2;
         }
         catch (DivideByZeroException e)
         {
            Console.WriteLine("Exception caught: {0}", e);
         }
         finally
         {
            Console.WriteLine("Result: {0}", result);
         }
      }
      static void Main(string[] args)
      {
         DivNumbers d = new DivNumbers();
         d.division(25, 0);
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Exception caught: System.DivideByZeroException: Attempted to divide by zero. 
at ...
Result: 0
</pre>
<h2>Creating User-Defined Exceptions</h2>
<p>You can also define your own exception. User-defined exception classes are derived from the <b>ApplicationException</b> class. The following example demonstrates this:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace UserDefinedException
{
   class TestTemperature
   {
      static void Main(string[] args)
      {
         Temperature temp = new Temperature();
         try
         {
            temp.showTemp();
         }
         catch(TempIsZeroException e)
         {
            Console.WriteLine("TempIsZeroException: {0}", e.Message);
         }
         Console.ReadKey();
      }
   }
}

public class TempIsZeroException: ApplicationException
{
   public TempIsZeroException(string message): base(message)
   {
   }
}

public class Temperature
{
   int temperature = 0;
   public void showTemp()
   {
      if(temperature == 0)
      {
         throw (new TempIsZeroException("Zero Temperature found"));
      }
      else
      {
         Console.WriteLine("Temperature: {0}", temperature);
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
TempIsZeroException: Zero Temperature found
</pre>
<h2>Throwing Objects</h2>
<p>You can throw an object if it is either directly or indirectly derived from the <b>System.Exception</b> class. You can use a throw statement in the catch block to throw the present object as:</p>
<pre class="prettyprint notranslate">
Catch(Exception e)
{
   ...
   Throw e
}
</pre>
<h1>C# - File I/O</h1>
<p>A <b>file</b> is a collection of data stored in a disk with a specific name and a directory path. When a file is opened for reading or writing, it becomes a <b>stream</b>.</p>
<p>The stream is basically the sequence of bytes passing through the communication path. There are two main streams: the <b>input stream</b> and the <b>output stream</b>. The<b> input stream</b> is used for reading data from file (read operation) and the <b>output stream</b> is used for writing into the file (write operation).</p>
<h2>C# I/O Classes</h2>
<p>The System.IO namespace has various classes that are used for performing numerous operations with files, such as creating and deleting files, reading from or writing to a file, closing a file etc.</p>
<p>The following table shows some commonly used non-abstract classes in the System.IO namespace:</p>
<table class="table table-bordered">
<tr>
<th style="width:25%;">I/O Class</th>
<th>Description</th>
</tr>
<tr>
<td>BinaryReader</td>
<td>Reads primitive data from a binary stream.</td>
</tr>
<tr>
<td>BinaryWriter</td>
<td>Writes primitive data in binary format.</td>
</tr>
<tr>
<td>BufferedStream</td>
<td>A temporary storage for a stream of bytes.</td>
</tr>
<tr>
<td>Directory</td>
<td>Helps in manipulating a directory structure.</td>
</tr>
<tr>
<td>DirectoryInfo</td>
<td>Used for performing operations on directories.</td>
</tr>
<tr>
<td>DriveInfo</td>
<td>Provides information for the drives.</td>
</tr>
<tr>
<td>File</td>
<td>Helps in manipulating files.</td>
</tr>
<tr>
<td>FileInfo</td>
<td>Used for performing operations on files.</td>
</tr>
<tr>
<td>FileStream</td>
<td>Used to read from and write to any location in a file.</td>
</tr>
<tr>
<td>MemoryStream</td>
<td>Used for random access to streamed data stored in memory.</td>
</tr>
<tr>
<td>Path</td>
<td>Performs operations on path information.</td>
</tr>
<tr>
<td>StreamReader</td>
<td>Used for reading characters from a byte stream.</td>
</tr>
<tr>
<td>StreamWriter</td>
<td>Is used for writing characters to a stream.</td>
</tr>
<tr>
<td>StringReader</td>
<td>Is used for reading from a string buffer.</td>
</tr>
<tr>
<td>StringWriter</td>
<td>Is used for writing into a string buffer.</td>
</tr>
</table>
<h2>The FileStream Class</h2>
<p>The <b>FileStream</b> class in the System.IO namespace helps in reading from, writing to and closing files. This class derives from the abstract class Stream.</p>
<p>You need to create a <b>FileStream</b> object to create a new file or open an existing file. The syntax for creating a <b>FileStream</b> object is as follows:</p>
<pre class="prettyprint notranslate">
FileStream &lt;object_name&gt; = new FileStream( &lt;file_name&gt;, &lt;FileMode Enumerator&gt;, &lt;FileAccess Enumerator&gt;, &lt;FileShare Enumerator&gt;);
</pre>
<p>For example, we create a FileStream object <b>F</b> for reading a file named <b>sample.txt as shown</b>:</p>
<pre class="prettyprint notranslate">
FileStream F = new FileStream("sample.txt", FileMode.Open, FileAccess.Read, FileShare.Read);</pre>
<table class="table table-bordered">
<tr>
<th style="width:20%;">Parameter</th>
<th>Description</th>
</tr>
<tr>
<td>FileMode</td>
<td><p>The <b>FileMode</b> enumerator defines various methods for opening files. The members of the FileMode enumerator are:</p>
<ul class="list">
<li><p><b>Append</b>: It opens an existing file and puts cursor at the end of file, or creates the file, if the file does not exist.</p></li>
<li><p><b>Create</b>: It creates a new file.</p></li>
<li><p><b>CreateNew</b>: It specifies to the operating system, that it should create a new file.</p></li>
<li><p><b>Open</b>: It opens an existing file.</p></li>
<li><p><b>OpenOrCreate</b>: It specifies to the operating system that it should open a file if it exists, otherwise it should create a new file.</p></li>
<li><p><b>Truncate</b>: It opens an existing file and truncates its size to zero bytes.</p></li>
</ul>
</td>
</tr>
<tr>
<td>FileAccess</td>
<td><p><b>FileAccess</b> enumerators have members: <b>Read</b>, <b>ReadWrite</b> and <b>Write</b>.</p>
</td>
</tr>
<tr>
<td>FileShare</td>
<td><p><b>FileShare</b> enumerators have the following members:</p>
<ul class="list">
<li><p><b>Inheritable</b>: It allows a file handle to pass inheritance to the child processes</p></li>
<li><p><b>None</b>: It declines sharing of the current file</p></li>
<li><p><b>Read</b>: It allows opening the file for reading </p></li>
<li><p><b>ReadWrite</b>: It allows opening the file for reading and writing</p></li>
<li><p><b>Write</b>: It allows opening the file for writing</p></li>
</ul>
</td>
</tr>
</table>
<h2>Example</h2>
<p>The following program demonstrates use of the <b>FileStream </b>class:</p>
<pre class="prettyprint notranslate tryit">
using System;
using System.IO;

namespace FileIOApplication
{
   class Program
   {
      static void Main(string[] args)
      {
         FileStream F = new FileStream("test.dat", FileMode.OpenOrCreate, FileAccess.ReadWrite);
         for (int i = 1; i &lt;= 20; i++)
         {
            F.WriteByte((byte)i);
         }
         
         F.Position = 0;
         for (int i = 0; i &lt;= 20; i++)
         {
            Console.Write(F.ReadByte() + " ");
         }
         F.Close();
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 -1
</pre>
<h2>Advanced File Operations in C#</h2>
<p>The preceding example provides simple file operations in C#. However, to utilize the immense powers of C# System.IO classes, you need to know the commonly used properties and methods of these classes.</p>
<table class="table table-bordered">
<tr>
<th style="width:30%;">Topic and Description</th>
</tr>
<tr>
<td>
<p><a href="/csharp/csharp_text_files.htm" title="C# text files">Reading from and Writing into Text files</a></p>
<p>It involves reading from and writing into text files. The <b>StreamReader</b> and <b>StreamWriter</b> class helps to accomplish it.</p>
</td>
</tr>
<tr>
<td>
<p><a href="/csharp/csharp_binary_files.htm" title="C# binary files">Reading from and Writing into Binary files</a></p>
<p>It involves reading from and writing into binary files. The <b>BinaryReader</b> and <b>BinaryWriter</b> class helps to accomplish this.</p>
</td>
</tr>
<tr>
<td>
<p><a href="/csharp/csharp_windows_file_system.htm" title="C# Windows file system">Manipulating the Windows file system</a></p>
<p>It gives a C# programamer the ability to browse and locate Windows files and directories.</p>
</td>
</tr>
</table>
<h1>C# - Attributes</h1>
<p>An <b>attribute</b> is a declarative tag that is used to convey information to runtime about the behaviors of various elements like classes, methods, structures, enumerators, assemblies etc. in your program. You can add declarative information to a program by using an attribute. A declarative tag is depicted by square ([ ]) brackets placed above the element it is used for.</p>
<p>Attributes are used for adding metadata, such as compiler instruction and other information such as comments, description, methods and classes to a program. The .Net Framework provides two types of attributes: <i>the pre-defined</i> attributes and <i>custom built</i> attributes.</p>
<h2>Specifying an Attribute</h2>
<p>Syntax for specifying an attribute is as follows:</p>
<pre class="prettyprint notranslate">
[attribute(positional_parameters, name_parameter = value, ...)]
element
</pre>
<p>Name of the attribute and its values are specified within the square brackets, before the element to which the attribute is applied. Positional parameters specify the essential information and the name parameters specify the optional information.</p>
<h2>Predefined Attributes</h2>
<p>The .Net Framework provides three pre-defined attributes:</p>
<ul class="list">
<li>AttributeUsage</li>
<li>Conditional</li>
<li>Obsolete</li>
</ul>
<h2>AttributeUsage</h2> 
<p>The pre-defined attribute <b>AttributeUsage</b> describes how a custom attribute class can be used. It specifies the types of items to which the attribute can be applied.</p>
<p>Syntax for specifying this attribute is as follows:</p>
<pre class="prettyprint notranslate">
[AttributeUsage(
   validon,
   AllowMultiple=allowmultiple,
   Inherited=inherited
)]
</pre>
<p>Where,</p>
<ul class="list">
<li><p>The parameter validon specifies the language elements on which the attribute can be placed. It is a combination of the value of an enumerator <i>AttributeTargets</i>. The default value is <i> AttributeTargets.All</i>.</p></li>
<li><p>The parameter <i>allowmultiple</i> (optional) provides value for the <i>AllowMultiple</i> property of this attribute, a Boolean value. If this is true, the attribute is multiuse. The default is false (single-use).</p></li>
<li><p>The parameter inherited (optional) provides value for the <i>Inherited</i> property of this attribute, a Boolean value. If it is true, the attribute is inherited by derived classes. The default value is false (not inherited).</p></li>
</ul>
<p>For example,</p>
<pre class="prettyprint notranslate">
[AttributeUsage(AttributeTargets.Class |
AttributeTargets.Constructor |
AttributeTargets.Field |
AttributeTargets.Method |
AttributeTargets.Property, 
AllowMultiple = true)]
</pre>
<h2>Conditional</h2>
<p>This predefined attribute marks a conditional method whose execution depends on a specified preprocessing identifier.</p>
<p>It causes conditional compilation of method calls, depending on the specified value such as <b>Debug</b> or <b> Trace</b>. For example, it displays the values of the variables while debugging a code.</p>
<p>Syntax for specifying this attribute is as follows:</p>
<pre class="prettyprint notranslate">
[Conditional(
   conditionalSymbol
)]
</pre>
<p>For example,</p>
<pre class="prettyprint notranslate">
[Conditional("DEBUG")]
</pre>
<p>The following example demonstrates the attribute:</p>
<pre class="prettyprint notranslate tryit">
#define DEBUG
using System;
using System.Diagnostics;

public class Myclass
{
   [Conditional("DEBUG")]
   public static void Message(string msg)
   {
      Console.WriteLine(msg);
   }
}

class Test
{
   static void function1()
   {
      Myclass.Message("In Function 1.");
      function2();
   }
   static void function2()
   {
      Myclass.Message("In Function 2.");
   }
   
   public static void Main()
   {
      Myclass.Message("In Main function.");
      function1();
      Console.ReadKey();
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
In Main function
In Function 1
In Function 2
</pre>
<h2>Obsolete</h2>
<p>This predefined attribute marks a program entity that should not be used. It enables you to inform the compiler to discard a particular target element. For example, when a new method is being used in a class and if you still want to retain the old method in the class, you may mark it as obsolete by displaying a message the new method should be used, instead of the old method.</p>
<p>Syntax for specifying this attribute is as follows:</p>
<pre class="prettyprint notranslate">
[Obsolete(
   message
)]
[Obsolete(
   message,
   iserror
)]
</pre>
<p>Where,</p>
<ul class="list">
<li><p>The parameter <i>message</i>, is a string describing the reason why the item is obsolete and what to use instead.</p></li>
<li><p>The parameter <i>iserror</i>, is a Boolean value. If its value is true, the compiler should treat the use of the item as an error. Default value is false (compiler generates a warning).</p></li>
</ul>
<p>The following program demonstrates this:</p>
<pre class="prettyprint notranslate tryit">
using System;

public class MyClass
{
   [Obsolete("Don't use OldMethod, use NewMethod instead", true)]
   static void OldMethod()
   {
      Console.WriteLine("It is the old method");
   }
   static void NewMethod()
   {
      Console.WriteLine("It is the new method"); 
   }
   public static void Main()
   {
      OldMethod();
   }
}
</pre>
<p>When you try to compile the program, the compiler gives an error message stating:</p>
<pre class="result notranslate">
 Don't use OldMethod, use NewMethod instead
</pre>
<h2>Creating Custom Attributes</h2>
<p>The .Net Framework allows creation of custom attributes that can be used to store declarative information and can be retrieved at run-time. This information can be related to any target element depending upon the design criteria and application need.</p>
<p>Creating and using custom attributes involve four steps:</p>
<ul class="list">
<li>Declaring a custom attribute</li>
<li>Constructing the custom attribute</li>
<li>Apply the custom attribute on a target program element</li>
<li>Accessing Attributes Through Reflection</li>
</ul>
<p>The Last step involves writing a simple program to read through the metadata to find various notations. Metadata is data about data or information used for describing other data. This program should use reflections for accessing attributes at runtime. This we will discuss in the next chapter.</p>
<h2>Declaring a Custom Attribute</h2>
<p>A new custom attribute should is derived from the <b>System.Attribute</b> class. For example,</p>
<pre class="prettyprint notranslate">
//a custom attribute BugFix to be assigned to a class and its members
[AttributeUsage(AttributeTargets.Class |
AttributeTargets.Constructor |
AttributeTargets.Field |
AttributeTargets.Method |
AttributeTargets.Property,
AllowMultiple = true)]

public class DeBugInfo : System.Attribute
</pre>
<p>In the preceding code, we have declared a custom attribute named <i>DeBugInfo</i>.</p>
<h2>Constructing the Custom Attribute</h2>
<p>Let us construct a custom attribute named <i>DeBugInfo</i>, which stores the information obtained by debugging any program. Let it store the following information:</p>
<ul class="list">
<li>The code number for the bug</li>
<li>Name of the developer who identified the bug</li>
<li>Date of last review of the code</li>
<li>A string message for storing the developer's remarks</li>
</ul>
<p>The <i>DeBugInfo</i> class has three private properties for storing the first three information and a public property for storing the message. Hence the bug number, developer's name, and date of review are the positional parameters of the DeBugInfo class and the message is an optional or named parameter.</p>
<p>Each attribute must have at least one constructor. The positional parameters should be passed through the constructor. The following code shows the <i>DeBugInfo</i> class:</p>
<pre class="prettyprint notranslate tryit">
//a custom attribute BugFix to be assigned to a class and its members
[AttributeUsage(AttributeTargets.Class |
AttributeTargets.Constructor |
AttributeTargets.Field |
AttributeTargets.Method |
AttributeTargets.Property,
AllowMultiple = true)]

public class DeBugInfo : System.Attribute
{
   private int bugNo;
   private string developer;
   private string lastReview;
   public string message;
   
   public DeBugInfo(int bg, string dev, string d)
   {
      this.bugNo = bg;
      this.developer = dev;
      this.lastReview = d;
   }
   
   public int BugNo
   {
      get
      {
         return bugNo;
      }
   }
   
   public string Developer
   {
      get
      {
         return developer;
      }
   }
   
   public string LastReview
   {
      get
      {
         return lastReview;
      }
   }
   
   public string Message
   {
      get
      {
         return message;
      }
      set
      {
         message = value;
      }
   }
}
</pre>
<h2>Applying the Custom Attribute</h2>
<p>The attribute is applied by placing it immediately before its target:</p>
<pre class="prettyprint notranslate">
[DeBugInfo(45, "Zara Ali", "12/8/2012", Message = "Return type mismatch")]
[DeBugInfo(49, "Nuha Ali", "10/10/2012", Message = "Unused variable")]
class Rectangle
{
   //member variables
   protected double length;
   protected double width;
   public Rectangle(double l, double w)
   {
      length = l;
      width = w;
   }
   [DeBugInfo(55, "Zara Ali", "19/10/2012", Message = "Return type mismatch")]
   
   public double GetArea()
   {
      return length * width;
   }
   [DeBugInfo(56, "Zara Ali", "19/10/2012")]
   
   public void Display()
   {
      Console.WriteLine("Length: {0}", length);
      Console.WriteLine("Width: {0}", width);
      Console.WriteLine("Area: {0}", GetArea());
   }
}
</pre>
<p>In the next chapter, we retrieve attribute information using a Reflection class object.</p>
<h1>C# - Reflection</h1>
<p><b>Reflection</b> objects are used for obtaining type information at runtime. The classes that give access to the metadata of a running program are in the <b>System.Reflection</b> namespace.</p>
<p>The <b>System.Reflection</b> namespace contains classes that allow you to obtain information about the application and to dynamically add types, values, and objects to the application.</p>
<h2>Applications of Reflection</h2>
<p>Reflection has the following applications:</p>
<ul class="list">
<li><p>It allows view attribute information at runtime.</p></li>
<li><p>It allows examining various types in an assembly and instantiate these types.</p></li>
<li><p>It allows late binding to methods and properties</p></li>
<li><p>It allows creating new types at runtime and then performs some tasks using those types. </p></li>
</ul>
<h2>Viewing Metadata</h2>
<p>We have mentioned in the preceding chapter that using reflection you can view the attribute information.</p>
<p>The <b>MemberInfo</b> object of the <b>System.Reflection</b> class needs to be initialized for discovering the attributes associated with a class. To do this, you define an object of the target class, as:</p>
<pre class="prettyprint notranslate">
System.Reflection.MemberInfo info = typeof(MyClass);
</pre>
<p>The following program demonstrates this:</p>
<pre class="prettyprint notranslate tryit">
using System;

[AttributeUsage(AttributeTargets.All)]
public class HelpAttribute : System.Attribute
{
   public readonly string Url;
   
   public string Topic   // Topic is a named parameter
   {
      get
      {
         return topic;
      }
      set
      {
         topic = value;
      }
   }
   
   public HelpAttribute(string url)   // url is a positional parameter
   {
      this.Url = url;
   }
   private string topic;
}

[HelpAttribute("Information on the class MyClass")]
class MyClass
{
}
namespace AttributeAppl
{
   class Program
   {
      static void Main(string[] args)
      {
         System.Reflection.MemberInfo info = typeof(MyClass);
         object[] attributes = info.GetCustomAttributes(true);
         for (int i = 0; i &lt; attributes.Length; i++)
         {
            System.Console.WriteLine(attributes[i]);
         }
         
         Console.ReadKey();
      }
   }
}
</pre>
<p>When it is compiled and run, it displays the name of the custom attributes attached to the class <i>MyClass</i>:</p>
<pre class="result notranslate">
HelpAttribute
</pre>
<h2>Example</h2>
<p>In this example, we use the <i>DeBugInfo</i> attribute created in the previous chapter and use reflection to read metadata in the <i>Rectangle</i> class.</p> 
<pre class="prettyprint notranslate tryit">
using System;
using System.Reflection;

namespace BugFixApplication
{
   //a custom attribute BugFix to be
   //assigned to a class and its members
   [AttributeUsage(AttributeTargets.Class |
   AttributeTargets.Constructor |
   AttributeTargets.Field |
   AttributeTargets.Method |
   AttributeTargets.Property,
   AllowMultiple = true)]

   public class DeBugInfo : System.Attribute
   {
      private int bugNo;
      private string developer;
      private string lastReview;
      public string message;
      
      public DeBugInfo(int bg, string dev, string d)
      {
         this.bugNo = bg;
         this.developer = dev;
         this.lastReview = d;
      }
      
      public int BugNo
      {
         get
         {
            return bugNo;
         }
      }
      
      public string Developer
      {
         get
         {
            return developer;
         }
      }
      
      public string LastReview
      {
         get
         {
            return lastReview;
         }
      }
      
      public string Message
      {
         get
         {
            return message;
         }
         set
         {
            message = value;
         }
      }
   }
   [DeBugInfo(45, "Zara Ali", "12/8/2012", Message = "Return type mismatch")]
   [DeBugInfo(49, "Nuha Ali", "10/10/2012", Message = "Unused variable")]
   
   class Rectangle
   {
      //member variables
      protected double length;
      protected double width;
      public Rectangle(double l, double w)
      {
         length = l;
         width = w;
      }
      [DeBugInfo(55, "Zara Ali", "19/10/2012", Message = "Return type mismatch")]
      public double GetArea()
      {
         return length * width;
      }
      [DeBugInfo(56, "Zara Ali", "19/10/2012")]
      public void Display()
      {
         Console.WriteLine("Length: {0}", length);
         Console.WriteLine("Width: {0}", width);
         Console.WriteLine("Area: {0}", GetArea());
      }
   }//end class Rectangle
   
   class ExecuteRectangle
   {
      static void Main(string[] args)
      {
         Rectangle r = new Rectangle(4.5, 7.5);
         r.Display();
         Type type = typeof(Rectangle);
         
         //iterating through the attribtues of the Rectangle class
         foreach (Object attributes in type.GetCustomAttributes(false))
         {
            DeBugInfo dbi = (DeBugInfo)attributes;
            if (null != dbi)
            {
               Console.WriteLine("Bug no: {0}", dbi.BugNo);
               Console.WriteLine("Developer: {0}", dbi.Developer);
               Console.WriteLine("Last Reviewed: {0}", dbi.LastReview);
               Console.WriteLine("Remarks: {0}", dbi.Message);
            }
         }
         
         //iterating through the method attribtues
         foreach (MethodInfo m in type.GetMethods())
         {
            foreach (Attribute a in m.GetCustomAttributes(true))
            {
               DeBugInfo dbi = (DeBugInfo)a;
               if (null != dbi)
               {
                  Console.WriteLine("Bug no: {0}, for Method: {1}", dbi.BugNo, m.Name);
                  Console.WriteLine("Developer: {0}", dbi.Developer);
                  Console.WriteLine("Last Reviewed: {0}", dbi.LastReview);
                  Console.WriteLine("Remarks: {0}", dbi.Message);
               }
            }
         }
         
         Console.ReadLine();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Length: 4.5
Width: 7.5
Area: 33.75
Bug No: 49
Developer: Nuha Ali
Last Reviewed: 10/10/2012
Remarks: Unused variable
Bug No: 45
Developer: Zara Ali
Last Reviewed: 12/8/2012
Remarks: Return type mismatch
Bug No: 55, for Method: GetArea
Developer: Zara Ali
Last Reviewed: 19/10/2012
Remarks: Return type mismatch
Bug No: 56, for Method: Display
Developer: Zara Ali
Last Reviewed: 19/10/2012
Remarks: 
</pre>
<h1>C# - Properties</h1>
<p><b>Properties</b> are named members of classes, structures, and interfaces. Member variables or methods in a class or structures are called <b>Fields</b>. Properties are an extension of fields and are accessed using the same syntax. They use <b>accessors</b> through which the values of the private fields can be read, written or manipulated.</p>
<p>Properties do not name the storage locations. Instead, they have <b>accessors</b> that read, write, or compute their values.</p>
<p>For example, let us have a class named Student, with private fields for age, name, and code. We cannot directly access these fields from outside the class scope, but we can have properties for accessing these private fields.</p>
<h2>Accessors</h2>
<p>The <b>accessor</b> of a property contains the executable statements that helps in getting (reading or computing) or setting (writing) the property. The accessor declarations can contain a get accessor, a set accessor, or both. For example:</p>
<pre class="prettyprint notranslate">
// Declare a Code property of type string:
public string Code
{
   get
   {
      return code;
   }
   set
   {
      code = value;
   }
}

// Declare a Name property of type string:
public string Name
{
   get
   {
      return name;
   }
   set
   {
      name = value;
   }
}

// Declare a Age property of type int:
public int Age
{ 
   get
   {
      return age;
   }
   set
   {
      age = value;
   }
}
</pre>
<h2>Example</h2>
<p>The following example demonstrates use of properties:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace tutorialspoint
{
   class Student
   {
      private string code = "N.A";
      private string name = "not known";
      private int age = 0;
      
      // Declare a Code property of type string:
      public string Code
      {
         get
         {
            return code;
         }
         set
         {
            code = value;
         }
      }
      
      // Declare a Name property of type string:
      public string Name
      {
         get
         {
            return name;
         }
         set
         {
            name = value;
         }
      }
      
      // Declare a Age property of type int:
      public int Age
      {
         get
         {
            return age;
         }
         set
         {
            age = value;
         }
      }
      public override string ToString()
      {
         return "Code = " + Code +", Name = " + Name + ", Age = " + Age;
      }
   }
   
   class ExampleDemo
   {
      public static void Main()
      {
      
         // Create a new Student object:
         Student s = new Student();
         
         // Setting code, name and the age of the student
         s.Code = "001";
         s.Name = "Zara";
         s.Age = 9;
         Console.WriteLine("Student Info: {0}", s);
         
         //let us increase age
         s.Age += 1;
         Console.WriteLine("Student Info: {0}", s);
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Student Info: Code = 001, Name = Zara, Age = 9
Student Info: Code = 001, Name = Zara, Age = 10
</pre>
<h2>Abstract Properties</h2>
<p>An abstract class may have an abstract property, which should be implemented in the derived class. The following program illustrates this:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace tutorialspoint
{
   public abstract class Person
   {
      public abstract string Name
      {
         get;
         set;
      }
      public abstract int Age
      {
         get;
         set;
      }
   }
   
   class Student : Person
   {
   
      private string code = "N.A";
      private string name = "N.A";
      private int age = 0;
      
      // Declare a Code property of type string:
      public string Code
      {
         get
         {
            return code;
         }
         set
         {
            code = value;
         }
      }
      
      // Declare a Name property of type string:
      public override string Name
      {
         get
         {
            return name;
         }
         set
         {
            name = value;
         }
      }
      
      // Declare a Age property of type int:
      public override int Age
      {
         get
         {
            return age;
         }
         set
         {
            age = value;
         }
      }
      public override string ToString()
      {
         return "Code = " + Code +", Name = " + Name + ", Age = " + Age;
      }
   }
   
   class ExampleDemo
   {
      public static void Main()
      {
         // Create a new Student object:
         Student s = new Student();
         
         // Setting code, name and the age of the student
         s.Code = "001";
         s.Name = "Zara";
         s.Age = 9;
         Console.WriteLine("Student Info:- {0}", s);
         
         //let us increase age
         s.Age += 1;
         Console.WriteLine("Student Info:- {0}", s);
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Student Info: Code = 001, Name = Zara, Age = 9
Student Info: Code = 001, Name = Zara, Age = 10
</pre>
<h1>C# - Indexers</h1>
<p>An <b>indexer</b> allows an object to be indexed such as an array. When you define an indexer for a class, this class behaves similar to a <b>virtual array</b>. You can then access the instance of this class using the array access operator ([ ]).</p>
<h2>Syntax</h2>
<p>A one dimensional indexer has the following syntax:</p>
<pre class="prettyprint notranslate">
element-type this[int index]
{
   // The get accessor.
   get
   {
      // return the value specified by index
   }
   
   // The set accessor.
   set
   {
      // set the value specified by index
   }
}
</pre>
<h2>Use of Indexers</h2>
<p>Declaration of behavior of an indexer is to some extent similar to a property. similar to the properties, you use <b> get</b> and <b>set</b> accessors for defining an indexer. However, properties return or set a specific data member, whereas indexers returns or sets a particular value from the object instance. In other words, it breaks the instance data into smaller parts and indexes each part, gets or sets each part.</p>
<p>Defining a property involves providing a property name. Indexers are not defined with names, but with the <b>this</b> keyword, which refers to the object instance. The following example demonstrates the concept:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace IndexerApplication
{
   class IndexedNames
   {
      private string[] namelist = new string[size];
      static public int size = 10;
      public IndexedNames()
      {
         for (int i = 0; i &lt; size; i++)
         namelist[i] = "N. A.";
      }
      
      public string this[int index]
      {
         get
         {
            string tmp;
         
            if( index &gt;= 0 &amp;&amp; index &lt;= size-1 )
            {
               tmp = namelist[index];
            }
            else
            {
               tmp = "";
            }
            
            return ( tmp );
         }
         set
         {
            if( index &gt;= 0 &amp;&amp; index &lt;= size-1 )
            {
               namelist[index] = value;
            }
         }
      }
      
      static void Main(string[] args)
      {
         IndexedNames names = new IndexedNames();
         names[0] = "Zara";
         names[1] = "Riz";
         names[2] = "Nuha";
         names[3] = "Asif";
         names[4] = "Davinder";
         names[5] = "Sunil";
         names[6] = "Rubic";
         for ( int i = 0; i &lt; IndexedNames.size; i++ )
         {
            Console.WriteLine(names[i]);
         }
         
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Zara
Riz
Nuha
Asif
Davinder
Sunil
Rubic
N. A.
N. A.
N. A.
</pre>
<h2>Overloaded Indexers</h2>
<p>Indexers can be overloaded. Indexers can also be declared with multiple parameters and each parameter may be a different type. It is not necessary that the indexes have to be integers. C# allows indexes to be of other types, for example, a string.</p>
<p>The following example demonstrates overloaded indexers:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace IndexerApplication
{
   class IndexedNames
   {
      private string[] namelist = new string[size];
      static public int size = 10;
      public IndexedNames()
      {
         for (int i = 0; i &lt; size; i++)
         {
            namelist[i] = "N. A.";
         }
      }
      
      public string this[int index]
      {
         get
         {
            string tmp;
            
            if( index &gt;= 0 &amp;&amp; index &lt;= size-1 )
            {
               tmp = namelist[index];
            }
            else
            {
               tmp = "";
            }
            
            return ( tmp );
         }
         set
         {
            if( index &gt;= 0 &amp;&amp; index &lt;= size-1 )
            {
               namelist[index] = value;
            }
         }
      }
      public int this[string name]
      {
         get
         {
            int index = 0;
            while(index &lt; size)
            {
               if (namelist[index] == name)
               {
                return index;
               }
               index++;
            }
            return index;
         }

      }

      static void Main(string[] args)
      {
         IndexedNames names = new IndexedNames();
         names[0] = "Zara";
         names[1] = "Riz";
         names[2] = "Nuha";
         names[3] = "Asif";
         names[4] = "Davinder";
         names[5] = "Sunil";
         names[6] = "Rubic";
         
         //using the first indexer with int parameter
         for (int i = 0; i &lt; IndexedNames.size; i++)
         {
            Console.WriteLine(names[i]);
         }
         
         //using the second indexer with the string parameter
         Console.WriteLine(names["Nuha"]);
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Zara
Riz
Nuha
Asif
Davinder
Sunil
Rubic
N. A.
N. A.
N. A.
2
</pre>
<h1>C# - Delegates</h1>
<p>C# delegates are similar to pointers to functions, in C or C++. A <b>delegate</b> is a reference type variable that holds the reference to a method. The reference can be changed at runtime.</p>
<p>Delegates are especially used for implementing events and the call-back methods. All delegates are implicitly derived from the <b>System.Delegate</b> class.</p>
<h2>Declaring Delegates</h2>
<p>Delegate declaration determines the methods that can be referenced by the delegate. A delegate can refer to a method, which has the same signature as that of the delegate.</p>
<p>For example, consider a delegate:</p>
<pre class="prettyprint notranslate">
public delegate int MyDelegate (string s);
</pre>
<p>The preceding delegate can be used to reference any method that has a single <i>string</i> parameter and returns an <i>int</i> type variable.</p>
<p>Syntax for delegate declaration is:</p>
<pre class="prettyprint notranslate">
delegate &lt;return type&gt; &lt;delegate-name&gt; &lt;parameter list&gt;
</pre>
<h2>Instantiating Delegates</h2>
<p>Once a delegate type is declared, a delegate object must be created with the <b>new </b> keyword and be associated with a particular method. When creating a delegate, the argument passed to the <b>new</b> expression is written similar to a method call, but without the arguments to the method. For example:</p>
<pre class="prettyprint notranslate">
public delegate void printString(string s);
...
printString ps1 = new printString(WriteToScreen);
printString ps2 = new printString(WriteToFile);
</pre>
<p>Following example demonstrates declaration, instantiation, and use of a delegate that can be used to reference methods that take an integer parameter and returns an integer value.</p>
<pre class="prettyprint notranslate tryit">
using System;

delegate int NumberChanger(int n);
namespace DelegateAppl
{
   class TestDelegate
   {
      static int num = 10;
      public static int AddNum(int p)
      {
         num += p;
         return num;
      }

      public static int MultNum(int q)
      {
         num *= q;
         return num;
      }
      public static int getNum()
      {
         return num;
      }

      static void Main(string[] args)
      {
         //create delegate instances
         NumberChanger nc1 = new NumberChanger(AddNum);
         NumberChanger nc2 = new NumberChanger(MultNum);
         
         //calling the methods using the delegate objects
         nc1(25);
         Console.WriteLine("Value of Num: {0}", getNum());
         nc2(5);
         Console.WriteLine("Value of Num: {0}", getNum());
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Value of Num: 35
Value of Num: 175
</pre>
<h2>Multicasting of a Delegate</h2>
<p>Delegate objects can be composed using the "+" operator. A composed delegate calls the two delegates it was composed from. Only delegates of the same type can be composed. The "-" operator can be used to remove a component delegate from a composed delegate.</p>
<p>Using this property of delegates you can create an invocation list of methods that will be called when a delegate is invoked. This is called <b>multicasting</b> of a delegate. The following program demonstrates multicasting of a delegate:</p>
<pre class="prettyprint notranslate tryit">
using System;

delegate int NumberChanger(int n);
namespace DelegateAppl
{
   class TestDelegate
   {
      static int num = 10;
      public static int AddNum(int p)
      {
         num += p;
         return num;
      }

      public static int MultNum(int q)
      {
         num *= q;
         return num;
      }
      
      public static int getNum()
      {
         return num;
      }

      static void Main(string[] args)
      {
         //create delegate instances
         NumberChanger nc;
         NumberChanger nc1 = new NumberChanger(AddNum);
         NumberChanger nc2 = new NumberChanger(MultNum);
         nc = nc1;
         nc += nc2;
         
         //calling multicast
         nc(5);
         Console.WriteLine("Value of Num: {0}", getNum());
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Value of Num: 75
</pre>
<h2>Using Delegates</h2>
<p>The following example demonstrates the use of delegate. The delegate <i>printString</i> can be used to reference method that takes a string as input and returns nothing.</p>
<p>We use this delegate to call two methods, the first prints the string to the console, and the second one prints it to a file:</p>
<pre class="prettyprint notranslate tryit">
using System;
using System.IO;

namespace DelegateAppl
{
   class PrintString
   {
      static FileStream fs;
      static StreamWriter sw;
      
      // delegate declaration
      public delegate void printString(string s);

      // this method prints to the console
      public static void WriteToScreen(string str)
      {
         Console.WriteLine("The String is: {0}", str);
      }
      
      //this method prints to a file
      public static void WriteToFile(string s)
      {
         fs = new FileStream("c:\\message.txt",
         FileMode.Append, FileAccess.Write);
         sw = new StreamWriter(fs);
         sw.WriteLine(s);
         sw.Flush();
         sw.Close();
         fs.Close();
      }
      
      // this method takes the delegate as parameter and uses it to
      // call the methods as required
      public static void sendString(printString ps)
      {
         ps("Hello World");
      }
      static void Main(string[] args)
      {
         printString ps1 = new printString(WriteToScreen);
         printString ps2 = new printString(WriteToFile);
         sendString(ps1);
         sendString(ps2);
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
The String is: Hello World
</pre>
<h1>C# - Events</h1>
<p><b>Events</b> are user actions such as key press, clicks, mouse movements, etc., or some occurrence such as system generated notifications. Applications need to respond to events when they occur. For example, interrupts. Events are used for inter-process communication.</p>
<h2>Using Delegates with Events</h2>
<p>The events are declared and raised in a class and associated with the event handlers using delegates within the same class or some other class. The class containing the event is used to publish the event. This is called the <b>publisher</b> class. Some other class that accepts this event is called the <b>subscriber </b> class. Events use the <b>publisher-subscriber</b> model.</p>
<p>A <b>publisher</b> is an object that contains the definition of the event and the delegate. The event-delegate association is also defined in this object. A publisher class object invokes the event and it is notified to other objects.</p>
<p>A <b>subscriber</b> is an object that accepts the event and provides an event handler. The delegate in the publisher class invokes the method (event handler) of the subscriber class.</p>
<h2>Declaring Events</h2>
<p>To declare an event inside a class, first a delegate type for the event must be declared. For example,</p>
<pre class="prettyprint notranslate">
public delegate string MyDel(string str);
</pre>
<p>Next, the event itself is declared, using the <b>event</b> keyword:</p>
<pre class="prettyprint notranslate">
event MyDel MyEvent;
</pre>
<p>The preceding code defines a delegate named <i>BoilerLogHandler</i> and an event named <i>BoilerEventLog</i>, which invokes the delegate when it is raised.</p>
<h2>Example</h2>
<pre class="prettyprint notranslate tryit">
using System;

namespace SampleApp {
   public delegate string MyDel(string str);
	
   class EventProgram {
      event MyDel MyEvent;
		
      public EventProgram() {
         this.MyEvent += new MyDel(this.WelcomeUser);
      }
		
      public string WelcomeUser(string username) {
         return "Welcome " + username;
      }
		
      static void Main(string[] args) {
         EventProgram obj1 = new EventProgram();
         string result = obj1.MyEvent("Tutorials Point");
         Console.WriteLine(result);
      }

   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Welcome Tutorials Point
</pre>
<h1>C# - Collections</h1>
<p>Collection classes are specialized classes for data storage and retrieval. These classes provide support for stacks, queues, lists, and hash tables. Most collection classes implement the same interfaces.</p>
<p>Collection classes serve various purposes, such as allocating memory dynamically to elements and accessing a list of items on the basis of an index etc. These classes create collections of objects of the Object class, which is the base class for all data types in C#.</p>
<h2>Various Collection Classes and Their Usage</h2>
<p>The following are the various commonly used classes of the <b>System.Collection</b> namespace. Click the following links to check their detail.</p>
<table class="table table-bordered">
<tr>
<th style="width:20%;">Class</th>
<th>Description and Useage</th>
</tr>
<tr>
<td>
<p><a href="/csharp/csharp_arraylist.htm" title="C# ArrayList">ArrayList</a></p>
</td>
<td>
<p>It represents ordered collection of an object that can be <b>indexed</b> individually.</p>
<p>It is basically an alternative to an array. However, unlike array you can add and remove items from a list at a specified position using an <b>index</b> and the array resizes itself automatically. It also allows dynamic memory allocation, adding, searching and sorting items in the list.</p> 
</td>
</tr>
<tr>
<td>
<p><a href="/csharp/csharp_hashtable.htm" title="C# Hashtable">Hashtable</a></p>
</td>
<td>
<p>It uses a <b>key</b> to access the elements in the collection.</p>
<p>A hash table is used when you need to access elements by using key, and you can identify a useful key value. Each item in the hash table has a <b>key/value</b> pair. The key is used to access the items in the collection.</p>
</td>
</tr>
<tr>
<td>
<p><a href="/csharp/csharp_sortedlist.htm" title="C# SortedList">SortedList</a></p>
</td>
<td>
<p>It uses a <b>key</b> as well as an <b>index</b> to access the items in a list.</p>
<p>A sorted list is a combination of an array and a hash table. It contains a list of items that can be accessed using a key or an index. If you access items using an index, it is an ArrayList, and if you access items using a key , it is a Hashtable. The collection of items is always sorted by the key value.</p> 
</td>
</tr>
<tr>
<td>
<p><a href="/csharp/csharp_stack.htm" title="C# Stack">Stack</a></p>
</td>
<td>
<p>It represents a <b>last-in, first out</b> collection of object.</p>
<p>It is used when you need a last-in, first-out access of items. When you add an item in the list, it is called <b>pushing</b> the item and when you remove it, it is called <b>popping</b> the item.</p>
</td>
</tr>
<tr>
<td>
<p><a href="/csharp/csharp_queue.htm" title="C# Queue">Queue</a></td></p>
<td><p>It represents a <b>first-in, first out</b> collection of object.</p>
<p>It is used when you need a first-in, first-out access of items. When you add an item in the list, it is called <b>enqueue</b> and when you remove an item, it is called <b>deque</b>.</p>
</td>
</tr>
<tr>
<td>
<p><a href="/csharp/csharp_bitarray.htm" title="C# BitArray">BitArray</a></p>
</td>
<td>
<p>It represents an array of the <b>binary representation</b> using the values 1 and 0.</p>
<p>It is used when you need to store the bits but do not know the number of bits in advance. You can access items from the BitArray collection by using an <b>integer index</b>, which starts from zero.</p>
</td>
</tr>
</table>
<h1>C# - Generics</h1>
<p><b>Generics</b> allow you to delay the specification of the data type of programming elements in a class or a method, until it is actually used in the program. In other words, generics allow you to write a class or method that can work with any data type.</p>
<p>You write the specifications for the class or the method, with substitute parameters for data types. When the compiler encounters a constructor for the class or a function call for the method, it generates code to handle the specific data type. A simple example would help understanding the concept:</p>
<pre class="prettyprint notranslate tryit">
using System;
using System.Collections.Generic;

namespace GenericApplication
{
   public class MyGenericArray&lt;T&gt;
   {
      private T[] array;
      public MyGenericArray(int size)
      {
         array = new T[size + 1];
      }
      
      public T getItem(int index)
      {
         return array[index];
      }
      
      public void setItem(int index, T value)
      {
         array[index] = value;
      }
   }
   
   class Tester
   {
      static void Main(string[] args)
      {
         
         //declaring an int array
         MyGenericArray&lt;int&gt; intArray = new MyGenericArray&lt;int&gt;(5);
         
         //setting values
         for (int c = 0; c &lt; 5; c++)
         {
            intArray.setItem(c, c*5);
         }
         
         //retrieving the values
         for (int c = 0; c &lt; 5; c++)
         {
            Console.Write(intArray.getItem(c) + " ");
         }
         
         Console.WriteLine();
         
         //declaring a character array
         MyGenericArray&lt;char&gt; charArray = new MyGenericArray&lt;char&gt;(5);
         
         //setting values
         for (int c = 0; c &lt; 5; c++)
         {
            charArray.setItem(c, (char)(c+97));
         }
         
         //retrieving the values
         for (int c = 0; c&lt; 5; c++)
         {
            Console.Write(charArray.getItem(c) + " ");
         }
         Console.WriteLine();
         
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
0 5 10 15 20
a b c d e
</pre>
<h2>Features of Generics</h2> 
<p>Generics is a technique that enriches your programs in the following ways:</p>
<ul class="list">
<li><p>It helps you to maximize code reuse, type safety, and performance.</p></li>
<li><p>You can create generic collection classes. The .NET Framework class library contains several new generic collection classes in the <i>System.Collections.Generic</i> namespace. You may use these generic collection classes instead of the collection classes in the <i>System.Collections</i> namespace.</p></li>
<li><p>You can create your own generic interfaces, classes, methods, events, and delegates.</p></li>
<li><p>You may create generic classes constrained to enable access to methods on particular data types.</p></li>
<li><p>You may get information on the types used in a generic data type at run-time by means of reflection.</p></li>
</ul>
<h2>Generic Methods</h2>
<p>In the previous example, we have used a generic class; we can declare a generic method with a type parameter. The following program illustrates the concept:</p>
<pre class="prettyprint notranslate tryit">
using System;
using System.Collections.Generic;

namespace GenericMethodAppl
{
   class Program
   {
      static void Swap&lt;T&gt;(ref T lhs, ref T rhs)
      {
         T temp;
         temp = lhs;
         lhs = rhs;
         rhs = temp;
      }
      static void Main(string[] args)
      {
         int a, b;
         char c, d;
         a = 10;
         b = 20;
         c = 'I';
         d = 'V';
         
         //display values before swap:
         Console.WriteLine("Int values before calling swap:");
         Console.WriteLine("a = {0}, b = {1}", a, b);
         Console.WriteLine("Char values before calling swap:");
         Console.WriteLine("c = {0}, d = {1}", c, d);
         
         //call swap
         Swap&lt;int&gt;(ref a, ref b);
         Swap&lt;char&gt;(ref c, ref d);
         
         //display values after swap:
         Console.WriteLine("Int values after calling swap:");
         Console.WriteLine("a = {0}, b = {1}", a, b);
         Console.WriteLine("Char values after calling swap:");
         Console.WriteLine("c = {0}, d = {1}", c, d);
         
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Int values before calling swap:
a = 10, b = 20
Char values before calling swap:
c = I, d = V
Int values after calling swap:
a = 20, b = 10
Char values after calling swap:
c = V, d = I
</pre>
<h2>Generic Delegates</h2>
<p>You can define a generic delegate with type parameters. For example:</p>
<pre class="prettyprint notranslate">
delegate T NumberChanger&lt;T&gt;(T n);
</pre>
<p>The following example shows use of this delegate:</p>
<pre class="prettyprint notranslate tryit">
using System;
using System.Collections.Generic;

delegate T NumberChanger&lt;T&gt;(T n);
namespace GenericDelegateAppl
{
   class TestDelegate
   {
      static int num = 10;
      public static int AddNum(int p)
      {
         num += p;
         return num;
      }
      
      public static int MultNum(int q)
      {
         num *= q;
         return num;
      }
      public static int getNum()
      {
         return num;
      }
      
      static void Main(string[] args)
      {
         //create delegate instances
         NumberChanger&lt;int&gt; nc1 = new NumberChanger&lt;int&gt;(AddNum);
         NumberChanger&lt;int&gt; nc2 = new NumberChanger&lt;int&gt;(MultNum);
         
         //calling the methods using the delegate objects
         nc1(25);
         Console.WriteLine("Value of Num: {0}", getNum());
         nc2(5);
         Console.WriteLine("Value of Num: {0}", getNum());
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Value of Num: 35
Value of Num: 175
</pre>
<h1>C# - Anonymous Methods</h1>
<p>We discussed that delegates are used to reference any methods that has the same signature as that of the delegate. In other words, you can call a method that can be referenced by a delegate using that delegate object.</p>
<p><b>Anonymous methods</b> provide a technique to pass a code block as a delegate parameter. Anonymous methods are the methods without a name, just the body.</p>
<p>You need not specify the return type in an anonymous method; it is inferred from the return statement inside the method body.</p>
<h2>Writing an Anonymous Method</h2>
<p>Anonymous methods are declared with the creation of the delegate instance, with a <b>delegate</b> keyword. For example,</p>
<pre class="prettyprint notranslate">
delegate void NumberChanger(int n);
...
NumberChanger nc = delegate(int x)
{
   Console.WriteLine("Anonymous Method: {0}", x);
};
</pre>
<p>The code block <i>Console.WriteLine("Anonymous Method: {0}", x);</i> is the body of the anonymous method.</p>
<p>The delegate could be called both with anonymous methods as well as named methods in the same way, i.e., by passing the method parameters to the delegate object.</p>
<p>For example,</p>
<pre class="prettyprint notranslate">
nc(10);
</pre>
<h2>Example</h2>
<p>The following example demonstrates the concept:</p>
<pre class="prettyprint notranslate tryit">
using System;

delegate void NumberChanger(int n);
namespace DelegateAppl
{
   class TestDelegate
   {
      static int num = 10;
      public static void AddNum(int p)
      {
         num += p;
         Console.WriteLine("Named Method: {0}", num);
      }
      
      public static void MultNum(int q)
      {
         num *= q;
         Console.WriteLine("Named Method: {0}", num);
      }
      
      public static int getNum()
      {
         return num;
      }
      static void Main(string[] args)
      {
         //create delegate instances using anonymous method
         NumberChanger nc = delegate(int x)
         {
            Console.WriteLine("Anonymous Method: {0}", x);
         };
         
         //calling the delegate using the anonymous method 
         nc(10);
         
         //instantiating the delegate using the named methods 
         nc =  new NumberChanger(AddNum);
         
         //calling the delegate using the named methods 
         nc(5);
         
         //instantiating the delegate using another named methods 
         nc =  new NumberChanger(MultNum);
         
         //calling the delegate using the named methods 
         nc(2);
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Anonymous Method: 10
Named Method: 15
Named Method: 30
</pre>
<h1>C# - Unsafe Codes</h1>
<p>C# allows using pointer variables in a function of code block when it is marked by the <b>unsafe</b> modifier. The <b>unsafe code</b> or the unmanaged code is a code block that uses a <b>pointer</b> variable.</p>
<blockquote>
<p><b>Note:</b> To execute the programs mentioned in this chapter at <a target="blank" href="http://www.tutorialspoint.com/compile_csharp_online.php">codingground</a>, please set compilation option in <i>Project &gt;&gt; Compile Options  &gt;&gt; Compilation Command</i> to</p> <p style="text-align:center"><code>mcs *.cs -out:main.exe -unsafe"</code></p>
</blockquote>
<h2>Pointers</h2>
<p>A <b>pointer</b> is a variable whose value is the address of another variable i.e., the direct address of the memory location. similar to any variable or constant, you must declare a pointer before you can use it to store any variable address.</p>
<p>The general form of a pointer declaration is:</p>
<pre class="prettyprint notranslate">
type *var-name;
</pre>
<p>Following are valid pointer declarations:</p>
<pre class="prettyprint notranslate">
int    *ip;    /* pointer to an integer */
double *dp;    /* pointer to a double */
float  *fp;    /* pointer to a float */
char   *ch     /* pointer to a character */
</pre>
<p>The following example illustrates use of pointers in C#, using the unsafe modifier:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace UnsafeCodeApplication
{
   class Program
   {
      static unsafe void Main(string[] args)
      {
         int var = 20;
         int* p = &var;
         Console.WriteLine("Data is: {0} ",  var);
         Console.WriteLine("Address is: {0}",  (int)p);
         Console.ReadKey();
      }
   }
}
</pre>

<p>When the above code wass compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Data is: 20
Address is: 99215364
</pre>
<p>Instead of declaring an entire method as unsafe, you can also declare a part of the code as unsafe. The example in the following section shows this.</p>
<h2>Retrieving the Data Value Using a Pointer</h2>
<p>You can retrieve the data stored at the located referenced by the pointer variable, using the <b>ToString()</b> method. The following example demonstrates this:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace UnsafeCodeApplication
{
   class Program
   {
      public static void Main()
      {
         unsafe
         {
            int var = 20;
            int* p = &var;
            Console.WriteLine("Data is: {0} " , var);
            Console.WriteLine("Data is: {0} " , p->ToString());
            Console.WriteLine("Address is: {0} " , (int)p);
         }
         
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code was compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Data is: 20
Data is: 20
Address is: 77128984
</pre>
<h2>Passing Pointers as Parameters to Methods</h2>
<p>You can pass a pointer variable to a method as parameter. The following example illustrates this:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace UnsafeCodeApplication
{
   class TestPointer
   {
      public unsafe void swap(int* p, int *q)
      {
         int temp = *p;
         *p = *q;
         *q = temp;
      }
      
      public unsafe static void Main()
      {
         TestPointer p = new TestPointer();
         int var1 = 10;
         int var2 = 20;
         int* x = &var1;
         int* y = &var2;
         
         Console.WriteLine("Before Swap: var1:{0}, var2: {1}", var1, var2);
         p.swap(x, y);

         Console.WriteLine("After Swap: var1:{0}, var2: {1}", var1, var2);
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Before Swap: var1: 10, var2: 20
After Swap: var1: 20, var2: 10
</pre>
<h2>Accessing Array Elements Using a Pointer</h2>
<p>In C#, an array name and a pointer to a data type same as the array data, are not the same variable type. For example, int *p and int[] p, are not same type. You can increment the pointer variable p because it is not fixed in memory but an array address is fixed in memory, and you can't increment that.</p>
<p>Therefore, if you need to access an array data using a pointer variable, as we traditionally do in C, or C++ ( please check: <a href="http://www.tutorialspoint.com/cprogramming/c_pointers.htm">C Pointers</a>), you need to fix the pointer using the <b>fixed</b> keyword.</p>
<p>The following example demonstrates this:</p>
<pre class="prettyprint notranslate tryit">
using System;
namespace UnsafeCodeApplication
{
   class TestPointer
   {
      public unsafe static void Main()
      {
         int[]  list = {10, 100, 200};
         fixed(int *ptr = list)
         
         /* let us have array address in pointer */
         for ( int i = 0; i &lt; 3; i++)
         {
            Console.WriteLine("Address of list[{0}]={1}",i,(int)(ptr + i));
            Console.WriteLine("Value of list[{0}]={1}", i, *(ptr + i));
         }
         
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code was compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Address of list[0] = 31627168
Value of list[0] = 10
Address of list[1] = 31627172
Value of list[1] = 100
Address of list[2] = 31627176
Value of list[2] = 200
</pre>
<h2>Compiling Unsafe Code</h2>
<p>For compiling unsafe code, you have to specify the <b>/unsafe</b> command-line switch with command-line compiler.</p>
<p>For example, to compile a program named prog1.cs containing unsafe code, from command line, give the command:</p>
<pre class="prettyprint notranslate">
csc /unsafe prog1.cs
</pre>
<p>If you are using Visual Studio IDE then you need to enable use of unsafe code in the project properties.</p>
<p>To do this:</p>
<ul class="list">
<li><p>Open <b>project properties</b> by double clicking the properties node in the Solution Explorer.</p></li>
<li><p>Click on the <b>Build</b> tab.</p></li>
<li><p>Select the option "<b>Allow unsafe code</b>".</p></li>
</ul>
<h1>C# - Multithreading</h1>
<p>A <b>thread</b> is defined as the execution path of a program. Each thread defines a unique flow of control. If your application involves complicated and time consuming operations, then it is often helpful to set different execution paths or threads, with each thread performing a particular job.</p>
<p>Threads are <b>lightweight processes</b>. One common example of use of thread is implementation of concurrent programming by modern operating systems. Use of threads saves wastage of CPU cycle and increase efficiency of an application.</p>
<p>So far we wrote the programs where a single thread runs as a single process which is the running instance of the application. However, this way the application can perform one job at a time. To make it execute more than one task at a time, it could be divided into smaller threads.</p>
<h2>Thread Life Cycle</h2>
<p>The life cycle of a thread starts when an object of the System.Threading.Thread class is created and ends when the thread is terminated or completes execution.</p>
<p>Following are the various states in the life cycle of a thread:</p>
<ul class="list">
<li><p><b>The Unstarted State</b>: It is the situation when the instance of the thread is created but the Start method is not called.</p></li>
<li><p><b>The Ready State</b>: It is the situation when the thread is ready to run and waiting CPU cycle.</p></li>
<li><p><b>The Not Runnable State</b>: A thread is not executable, when:</p>
<ul class="list">
<li>Sleep method has been called</li>
<li>Wait method has been called</li>
<li>Blocked by I/O operations</li>
</ul>
</li>
<li><p><b>The Dead State</b>: It is the situation when the thread completes execution or is aborted.</p></li>
</ul>
<h2>The Main Thread</h2>
<p>In C#, the <b>System.Threading.Thread</b> class is used for working with threads. It allows creating and accessing individual threads in a multithreaded application. The first thread to be executed in a process is called the <b>main</b> thread.</p>
<p>When a C# program starts execution, the main thread is automatically created. The threads created using the <b>Thread</b> class are called the child threads of the main thread. You can access a thread using the <b>CurrentThread</b> property of the Thread class.</p>
<p>The following program demonstrates main thread execution:</p>
<pre class="prettyprint notranslate tryit">
using System;
using System.Threading;

namespace MultithreadingApplication
{
   class MainThreadProgram
   {
      static void Main(string[] args)
      {
         Thread th = Thread.CurrentThread;
         th.Name = "MainThread";
         Console.WriteLine("This is {0}", th.Name);
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
This is MainThread
</pre>
<h2>Properties and Methods of the Thread Class</h2>
<p>The following table shows some most commonly used <b>properties</b> of the <b>Thread</b> class:</p>
<table class="table table-bordered">
<tr>
<th style="width:25%;">Property</th>
<th>Description</th>
</tr>
<tr>
<td>CurrentContext</td>
<td>Gets the current context in which the thread is executing.</td>
</tr>
<tr>
<td>CurrentCulture</td>
<td>Gets or sets the culture for the current thread.</td>
</tr>
<tr>
<td>CurrentPrinciple</td>
<td>Gets or sets the thread's current principal (for role-based security).</td>
</tr>
<tr>
<td>CurrentThread</td>
<td>Gets the currently running thread.</td>
</tr>
<tr>
<td>CurrentUICulture</td>
<td>Gets or sets the current culture used by the Resource Manager to look up culture-specific resources at run-time.</td>
</tr>
<tr>
<td>ExecutionContext</td>
<td>Gets an ExecutionContext object that contains information about the various contexts of the current thread.</td>
</tr>
<tr>
<td>IsAlive</td>
<td>Gets a value indicating the execution status of the current thread.</td>
</tr>
<tr>
<td>IsBackground</td>
<td>Gets or sets a value indicating whether or not a thread is a background thread.</td>
</tr>
<tr>
<td>IsThreadPoolThread</td>
<td>Gets a value indicating whether or not a thread belongs to the managed thread pool.</td>
</tr>
<tr>
<td>ManagedThreadId</td>
<td>Gets a unique identifier for the current managed thread.</td>
</tr>
<tr>
<td>Name</td>
<td>Gets or sets the name of the thread.</td>
</tr>
<tr>
<td>Priority</td>
<td>Gets or sets a value indicating the scheduling priority of a thread.</td>
</tr>
<tr>
<td>ThreadState</td>
<td>Gets a value containing the states of the current thread.</td>
</tr>
</table>
<p>The following table shows some of the most commonly used <b>methods</b> of the <b>Thread</b> class:</p>
<table class="table table-bordered">
<tr>
<th style="width:5%;">Sr.No.</th>
<th>Methods</th>
</tr>
<tr>
<td>1</td>
<td>
<b>public void Abort()</b>
<p>Raises a ThreadAbortException in the thread on which it is invoked, to begin the process of terminating the thread. Calling this method usually terminates the thread.</p>
</td>
</tr>
<tr>
<td>2</td>
<td>
<b>public static LocalDataStoreSlot AllocateDataSlot()</b>
<p>Allocates an unnamed data slot on all the threads. For better performance, use fields that are marked with the ThreadStaticAttribute attribute instead.</p>
</td>
</tr>
<tr>
<td>3</td>
<td>
<b>public static LocalDataStoreSlot AllocateNamedDataSlot(string name)</b>
<p>Allocates a named data slot on all threads. For better performance, use fields that are marked with the ThreadStaticAttribute attribute instead.</p>
</td>
</tr>
<tr>
<td>4</td>
<td>
<b>public static void BeginCriticalRegion()</b>
<p>Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception might jeopardize other tasks in the application domain.</p>
</td>
</tr>
<tr>
<td>5</td>
<td>
<b>public static void BeginThreadAffinity()</b>
<p>Notifies a host that managed code is about to execute instructions that depend on the identity of the current physical operating system thread.</p>
</td>
</tr>
<tr>
<td>6</td>
<td>
<b>public static void EndCriticalRegion()</b>
<p>Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception are limited to the current task.</p>
</td>
</tr>
<tr>
<td>7</td>
<td>
<b>public static void EndThreadAffinity()</b>
<p>Notifies a host that managed code has finished executing instructions that depend on the identity of the current physical operating system thread.</p>
</td>
</tr>
<tr>
<td>8</td>
<td>
<b>public static void FreeNamedDataSlot(string name)</b>
<p>Eliminates the association between a name and a slot, for all threads in the process. For better performance, use fields that are marked with the ThreadStaticAttribute attribute instead.</p>
</td>
</tr>
<tr>
<td>9</td>
<td>
<b>public static Object GetData(LocalDataStoreSlot slot)</b>
<p>Retrieves the value from the specified slot on the current thread, within the current thread's current domain. For better performance, use fields that are marked with the ThreadStaticAttribute attribute instead.</p>
</td>
</tr>
<tr>
<td>10</td>
<td>
<b>public static AppDomain GetDomain()</b>
<p>Returns the current domain in which the current thread is running.</p>
</td>
</tr>
<tr>
<td>11</td>
<td>
<b>public static AppDomain GetDomainID()</b>
<p>Returns a unique application domain identifier</p>
</td>
</tr>
<tr>
<td>12</td>
<td>
<b>public static LocalDataStoreSlot GetNamedDataSlot(string name)</b>
<p>Looks up a named data slot. For better performance, use fields that are marked with the ThreadStaticAttribute attribute instead.</p>
</td>
</tr>
<tr>
<td>13</td>
<td>
<b>public void Interrupt()</b>
<p>Interrupts a thread that is in the WaitSleepJoin thread state.</p>
</td>
</tr>
<tr>
<td>14</td>
<td>
<b>public void Join()</b>
<p>Blocks the calling thread until a thread terminates, while continuing to perform standard COM and SendMessage pumping. This method has different overloaded forms.</p>
</td>
</tr>
<tr>
<td>15</td>
<td>
<b>public static void MemoryBarrier()</b>
<p>Synchronizes memory access as follows: The processor executing the current thread cannot reorder instructions in such a way that memory accesses prior to the call to MemoryBarrier execute after memory accesses that follow the call to MemoryBarrier.</p>
</td>
</tr>
<tr>
<td>16</td>
<td>
<b>public static void ResetAbort()</b>
<p>Cancels an Abort requested for the current thread.</p>
</td>
</tr>
<tr>
<td>17</td>
<td>
<b>public static void SetData(LocalDataStoreSlot slot, Object data)</b>
<p>Sets the data in the specified slot on the currently running thread, for that thread's current domain. For better performance, use fields marked with the ThreadStaticAttribute attribute instead.</p>
</td>
</tr>
<tr>
<td>18</td>
<td>
<b>public void Start()</b>
<p>Starts a thread.</p>
</td>
</tr>
<tr>
<td>19</td>
<td>
<b>public static void Sleep(int millisecondsTimeout)</b>
<p>Makes the thread pause for a period of time.</p>
</td>
</tr>
<tr>
<td>20</td>
<td>
<b>public static void SpinWait(int iterations)</b>
<p>Causes a thread to wait the number of times defined by the iterations parameter</p>
</td>
</tr>
<tr>
<td>21</td>
<td>
<p><b>public static byte VolatileRead(ref byte address)</b></p>
<p><b>public static double VolatileRead(ref double address)</b></p>
<p><b>public static int VolatileRead(ref int address)</b></p>
<p><b>public static Object VolatileRead(ref Object address)</b></p>
<p>Reads the value of a field. The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache. This method has different overloaded forms. Only some are given above.</p>
</td>
</tr>
<tr>
<td>22</td>
<td>
<p><b>public static void VolatileWrite(ref byte address,byte value)</b></p>
<p><b>public static void VolatileWrite(ref double address, double value)</b></p>
<p><b>public static void VolatileWrite(ref int address, int value)</b></p>
<p><b>public static void VolatileWrite(ref Object address, Object value)</b></p>
<p>Writes a value to a field immediately, so that the value is visible to all processors in the computer. This method has different overloaded forms. Only some are given above. </p></td>
</tr>
<tr>
<td>23</td>
<td>
<b>public static bool Yield()</b>
<p>Causes the calling thread to yield execution to another thread that is ready to run on the current processor. The operating system selects the thread to yield to.</p>
</td>
</tr>
</table>
<h2>Creating Threads</h2>
<p>Threads are created by extending the Thread class. The extended Thread class then calls the <b>Start()</b> method to begin the child thread execution.</p>
<p>The following program demonstrates the concept:</p>
<pre class="prettyprint notranslate tryit">
using System;
using System.Threading;

namespace MultithreadingApplication
{
   class ThreadCreationProgram
   {
      public static void CallToChildThread()
      {
         Console.WriteLine("Child thread starts");
      }
      
      static void Main(string[] args)
      {
         ThreadStart childref = new ThreadStart(CallToChildThread);
         Console.WriteLine("In Main: Creating the Child thread");
         Thread childThread = new Thread(childref);
         childThread.Start();
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
In Main: Creating the Child thread
Child thread starts
</pre>
<h2>Managing Threads</h2>
<p>The Thread class provides various methods for managing threads.</p>
<p>The following example demonstrates the use of the <b>sleep()</b> method for making a thread pause for a specific period of time.</p>
<pre class="prettyprint notranslate tryit">
using System;
using System.Threading;

namespace MultithreadingApplication
{
   class ThreadCreationProgram
   {
      public static void CallToChildThread()
      {
         Console.WriteLine("Child thread starts");
         
         // the thread is paused for 5000 milliseconds
         int sleepfor = 5000; 
         
         Console.WriteLine("Child Thread Paused for {0} seconds", sleepfor / 1000);
         Thread.Sleep(sleepfor);
         Console.WriteLine("Child thread resumes");
      }
      
      static void Main(string[] args)
      {
         ThreadStart childref = new ThreadStart(CallToChildThread);
         Console.WriteLine("In Main: Creating the Child thread");
         Thread childThread = new Thread(childref);
         childThread.Start();
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
In Main: Creating the Child thread
Child thread starts
Child Thread Paused for 5 seconds
Child thread resumes
</pre>
<h2>Destroying Threads</h2>
<p>The <b>Abort()</b> method is used for destroying threads.</p>
<p>The runtime aborts the thread by throwing a <b>ThreadAbortException</b>. This exception cannot be caught, the control is sent to the <i>finally</i> block, if any.</p>
<p>The following program illustrates this:</p>
<pre class="prettyprint notranslate tryit">
using System;
using System.Threading;

namespace MultithreadingApplication
{
   class ThreadCreationProgram
   {
      public static void CallToChildThread()
      {
         try
         {
            Console.WriteLine("Child thread starts");
            
            // do some work, like counting to 10
            for (int counter = 0; counter &lt;= 10; counter++)
            {
               Thread.Sleep(500);
               Console.WriteLine(counter);
            }
            
            Console.WriteLine("Child Thread Completed");
         }
         
         catch (ThreadAbortException e)
         {
            Console.WriteLine("Thread Abort Exception");
         }
         finally
         {
            Console.WriteLine("Couldn't catch the Thread Exception");
         }
      }
      
      static void Main(string[] args)
      {
         ThreadStart childref = new ThreadStart(CallToChildThread);
         Console.WriteLine("In Main: Creating the Child thread");
         Thread childThread = new Thread(childref);
         childThread.Start();
         
         //stop the main thread for some time
         Thread.Sleep(2000);
         
         //now abort the child
         Console.WriteLine("In Main: Aborting the Child thread");
         
         childThread.Abort();
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
In Main: Creating the Child thread
Child thread starts
0
1
2
In Main: Aborting the Child thread
Thread Abort Exception
Couldn't catch the Thread Exception 
</pre>

<title>C# - Useful Resources</title>

<h1>C# - Useful Resources</h1>

<p>The following resources contain additional information on C#. Please use them to get more in-depth knowledge on this topic.</p>

<h2>Useful Links on C#</h2>

<p><a target="_blank" rel="nofollow" href="http://msdn.microsoft.com/en-us/library/67ef8sbd.aspx">C# Programming Guide</a> &minus; This provides detailed information on key C# language features and features accessible to C# through the .NET Framework.</p>

<p><a target="_blank" rel="nofollow" href="http://www.microsoft.com/visualstudio/eng/downloads">Visual Studio</a> &minus; Download latest version of Visual Studio which works as C# IDE.</p>

<p><a target="_blank" rel="nofollow" href="http://www.mono-project.com/Main_Page">Go Mono</a> &minus; Mono is a software platform designed to allow developers to easily create cross platform applications.</p>

<p><a target="_blank" rel="nofollow" href="http://en.wikipedia.org/wiki/C_Sharp_(programming_language)">C Sharp (programming language)</a> &minus; Wikipedia explains C Sharp (programming language).</p>

<h2>Useful Books on C#</h2>

<p>To enlist your site on this page, please drop an email to <b>contact@tutorialspoint.com</b></p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Discuss C#</title>

<h1>Discuss C#</h1>

<p>C# is a simple, modern, general-purpose, object-oriented programming language developed by Microsoft within its .NET initiative led by Anders Hejlsberg. This tutorial will teach you basic C# programming and will also take you through various advanced concepts related to C# programming language.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

</body></html>