<!DOCTYPE html><html><body><title>F# Tutorial</title>

<h1>F# Tutorial</h1>

<p>F# helps you in the daily development of the mainstream commercial business software. This tutorial provides a brief knowledge about F# and its features, and also provides the various structures and syntaxes of its methods and functions.</p>

<h1>Audience</h1>

<p>This tutorial has been designed for beginners in F#, providing the basic to advanced concepts of the subject.</p>

<h1>Prerequisites</h1>

<p>Before starting this tutorial you should be aware of the basic understanding of Functional Programming, C# and .Net</p>

<h1>Execute F# Online</h1>

<p>For most of the examples given in this tutorial you will find Try it option, so just make use of this option to execute your F# programs at the spot and enjoy your learning.</p>

<p>Try following example using Try it option available at the top right corner of the below sample code box &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate tryit">
(* This is a comment *)
(* Sample Hello World program using F# *)
printfn "Hello World!"
</pre>

<title>F# Overview</title>

<h1>F# - Overview</h1>

<p>F# is a functional programming language. To understand F# constructs, you need to read a couple of lines about the programming paradigm named <b>Functional Programming</b>.</p>

<p>Functional programming treats computer programs as mathematical functions. In functional programming, the focus would be on constants and functions, instead of variables and states. Because functions and constants are things that don’t change.</p>

<p>In functional programming, you will write modular programs, i.e., the programs would consist of functions that will take other functions as input.</p>

<p>Programs written in functional programming language tend to be concise.</p>

<h2>About F#</h2>

<p>Following are the basic information about F# &minus;</p>

<h2>Features of F#</h2>

<p>It is .Net implementation of OCaml.</p>

<p>It compiles .Net CLI (Common Language Interface) byte code or MSIL (Microsoft Intermediate Language) that runs on CLR (Common Language Runtime).</p>

<p>It provides type inference.</p>

<p>It provides rich pattern matching constructs.</p>

<p>It has interactive scripting and debugging capabilities.</p>

<p>It allows writing higher order functions.</p>

<p>It provides well developed object model.</p>

<h2>Use of F#</h2>

<p>F# is normally used in the following areas &minus;</p>

<p>It is also used in CRUD apps, web pages, GUI games and other general purpose programs.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>F# Environment Setup</title>

<h1>F# - Environment Setup</h1>

<p>The tools required for F# programming are discussed in this chapter.</p>

<h2>Integrated Development Environment(IDE) for F#</h2>

<p>Microsoft provides Visual Studio 2013 for F# programming.</p>

<p>The free Visual Studio 2013 Community Edition is available from Microsoft’s official website. Visual Studio 2013 Community and above comes with the Visual F# Tools. Installation details available at <a href="http://www.tutorialspoint.com/asp.net/asp.net_environment_setup.htm">Asp.net Tutorial </a>.The Visual F# Tools include the command-line compiler (fsc.exe) and F# Interactive (fsi.exe).</p>

<p>To open F sharp, click on File->new project->Visual F# as shown below image</p>

<p>Using these tools, you can write all kinds of F# programs from simple command-line applications to more complex applications. You can also write F# source code files using a basic text editor, like Notepad, and compile the code into assemblies using the command-line compiler.</p>

<p>You can download it from Microsoft Visual Studio. It gets automatically installed in your machine.</p>

<h2>Writing F# Programs On Links</h2>

<p>Please visit the F# official website for the latest instructions on getting the tools as a Debian package or compiling them directly from the source &minus; <a rel="nofollow" target="_blank" href="http://fsharp.org/use/linux/">http://fsharp.org/use/linux/.</a></p>

<h3>Try it Option Online</h3>

<p>We have set up the F# Programming environment online, so that you can compile and execute all the available examples online. It gives you confidence in what you are reading and enables you to verify the programs with different options. Feel free to modify any example and execute it online.</p>

<p>Try the following example using our online compiler available at <a href="http://www.tutorialspoint.com/codingground.htm">CodingGround</a></p>

<p>For most of the examples given in this tutorial, you will find a Try it option in our website code sections at the top right corner that will take you to the online compiler. So just make use of it and enjoy your learning.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate tryit">
(* This is a comment *)
(* Sample Hello World program using F# *)
printfn "Hello World!"
</pre>

<title>F# Program Structure</title>

<h1>F# - Program Structure</h1>

<p>F# is a Functional Programming language.</p>

<p>In F#, functions work like data types. You can declare and use a function in the same way like any other variable.</p>

<p>In general, an F# application does not have any specific entry point. The compiler executes all top-level statements in the file from top to bottom.</p>

<p>However, to follow procedural programming style, many applications keep a single top level statement that calls the main loop.</p>

<p>The following code shows a simple F# program &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>Please note that &minus;</p>

<p>An F# code file might begin with a number of <b>open</b> statements that is used to import namespaces.</p>

<p>The body of the files includes other functions that implement the business logic of the application.</p>

<p>The main loop contains the top executable statements.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate tryit">
open System
(* This is a multi-line comment *)
// This is a single-line comment

let sign num =
   if num &gt; 0 then "positive"
   elif num &lt; 0 then "negative"
   else "zero"

let main() =
   Console.WriteLine("sign 5: {0}", (sign 5))

main()
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
sign 5: positive
</pre>

<title>F# Basic Syntax</title>

<h1>F# - Basic Syntax</h1>

<p>You have seen the basic structure of an F# program, so it will be easy to understand other basic building blocks of the F# programming language.</p>

<h2>Tokens in F#</h2>

<p>An F# program consists of various tokens. A token could be a keyword, an identifier, a constant, a string literal, or a symbol. We can categorize F# tokens into two types &minus;</p>

<h3>F# Keywords</h3>

<p>The following table shows the keywords and brief descriptions of the keywords. We will discuss the use of these keywords in subsequent chapters.</p>

<p>In type definitions and type extensions, indicates the end of a section of member definitions.</p>

<p>In verbose syntax, used to specify the end of a code block that starts with the begin keyword.</p>

<p>Used to declare, define, or invoke a constructor that creates or that can create an object.</p>

<p>Also used in generic parameter constraints to indicate that a type must have a certain constructor.</p>

<p>Indicates the absence of an object.</p>

<p>Also used in generic parameter constraints.</p>

<p>Used with Boolean conditions as a Boolean or operator. Equivalent to ||.</p><p>Also used in member constraints.</p>

<p>Used to declare a structure type.</p>

<p>Also used in generic parameter constraints.</p>

<p>Used for OCaml compatibility in module definitions.</p>

<p>Used in conditional expressions.</p>

<p>Also used to perform side effects after object construction.</p>

<p>Some reserved keywords came from the OCaml language &minus;</p>

<p>Some other reserved keywords are kept for future expansion of F#.</p>

<h2>Comments in F#</h2>

<p>F# provides two types of comments &minus;</p>

<h2>A Basic Program and Application Entry Point in F#</h2>

<p>Generally, you don’t have any explicit entry point for F# programs. When you compile an F# application, the last file provided to the compiler becomes the entry point and all top level statements in that file are executed from top to bottom.</p>

<p>A well-written program should have a single top-level statement that would call the main loop of the program.</p>

<p>A very minimalistic F# program that would display ‘Hello World’ on the screen &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate tryit">
(* This is a comment *)
(* Sample Hello World program using F# *)
printfn "Hello World!"
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Hello World!
</pre>

<title>F# Data Types</title>

<h1>F# - Data Types</h1>

<p>The data types in F# can be classified as follows &minus;</p>

<h2>Integral Data Type</h2>

<p>The following table provides the integral data types of F#. These are basically integer data types.</p>

<p>42y</p>

<p>-11y</p>

<p>42uy</p>

<p>200uy</p>

<p>42s</p>

<p>-11s</p>

<p>42us</p>

<p>200us</p>

<p>42</p>

<p>-11</p>

<p>42u</p>

<p>200u</p>

<p>42L</p>

<p>-11L</p>

<p>42UL</p>

<p>200UL</p>

<p>42I</p>

<p>1499999</p>

<p>9999999</p>

<p>9999999</p>

<p>9999999</p>

<p>9999I</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Floating Point Data Types</h2>

<p>The following table provides the floating point data types of F#.</p>

<p>42.0F</p>

<p>-11.0F</p>

<p>42.0</p>

<p>-11.0</p>

<p>42.0M</p>

<p>-11.0M</p>

<p>42N</p>

<p>-11N</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Text Data Types</h2>

<p>The following table provides the text data types of F#.</p>

<p>'x'</p>

<p>'\t'</p>

<p>"Hello"</p>

<p>"World"</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Other Data Types</h2>

<p>The following table provides some other data types of F#.</p>

<p>true</p>

<p>false</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate tryit">
(* single byte integer *)
let x = 268.97f
let y = 312.58f
let z = x + y

printfn "x: %f" x
printfn "y: %f" y
printfn "z: %f" z

(* unsigned 8-bit natural number *)

let p = 2uy
let q = 4uy
let r = p + q

printfn "p: %i" p
printfn "q: %i" q
printfn "r: %i" r

(* signed 16-bit integer *)

let a = 12s
let b = 24s
let c = a + b

printfn "a: %i" a
printfn "b: %i" b
printfn "c: %i" c

(* signed 32-bit integer *)

let d = 212l
let e = 504l
let f = d + e

printfn "d: %i" d
printfn "e: %i" e
printfn "f: %i" f
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
x: 1
y: 2
z: 3
p: 2
q: 4
r: 6
a: 12
b: 24
c: 36
d: 212
e: 504
f: 716
</pre>
<h2>Floating Point Data Types</h2>
<p>The following table provides the floating point data types of F#.</p>
<table class="table table-bordered">
<tr>
<th>F# Type</th>
<th style="width:20%;">Size</th>
<th style="width:28%;">Range</th>
<th>Example</th>
<th>Remarks</th>
</tr>
<tr>
<td>float32</td>
<td>4 bytes</td>
<td>±1.5e-45 to ±3.4e38</td>
<td><p>42.0F</p>
<p>-11.0F</p></td>
<td>32-bit signed floating point number (7 significant digits)</td>
</tr>
<tr>
<td>float</td>
<td>8 bytes</td>
<td>±5.0e-324 to ±1.7e308</td>
<td><p>42.0</p>
<p>-11.0</p></td>
<td>64-bit signed floating point number (15-16 significant digits)</td>
</tr>
<tr>
<td>decimal</td>
<td>16 bytes</td>
<td>±1.0e-28 to ±7.9e28</td>
<td><p>42.0M</p>
<p>-11.0M</p></td>
<td>128-bit signed floating point number (28-29 significant digits)</td>
</tr>
<tr>
<td>BigRational</td>
<td>At least 4 bytes</td>
<td>Any rational number.</td>
<td><p>42N</p>
<p>-11N</p></td>
<td>Arbitrary precision rational number. Using this type requires a reference to FSharp.PowerPack.dll.</td>
</tr>
</table>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
(* 32-bit signed floating point number *)
(* 7 significant digits *)

let d = 212.098f
let e = 504.768f
let f = d + e

printfn "d: %f" d
printfn "e: %f" e
printfn "f: %f" f

(* 64-bit signed floating point number *)
(* 15-16 significant digits *)
let x = 21290.098
let y = 50446.768
let z = x + y

printfn "x: %g" x
printfn "y: %g" y
printfn "z: %g" z
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
d: 212.098000
e: 504.768000
f: 716.866000
x: 21290.1
y: 50446.8
z: 71736.9
</pre>
<h2>Text Data Types</h2>
<p>The following table provides the text data types of F#.</p>
<table class="table table-bordered">
<tr>
<th style="width:12%;">F# Type</th>
<th>Size</th>
<th>Range</th>
<th>Example</th>
<th>Remarks</th>
</tr>
<tr>
<td>char</td>
<td>2 bytes</td>
<td>U+0000 to U+ffff</td>
<td><p>'x'</p>
<p>'\t'</p></td>
<td>Single unicode characters</td>
</tr>
<tr>
<td>string</td>
<td>20 + (2 * string's length) bytes</td>
<td>0 to about 2 billion characters</td>
<td><p>"Hello"</p>
<p>"World"</p></td>
<td>Unicode text</td>
</tr>
</table>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
let choice = 'y'
let name = "Zara Ali"
let org = "Tutorials Point"

printfn "Choice: %c" choice
printfn "Name: %s" name
printfn "Organisation: %s" org
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Choice: y
Name: Zara Ali
Organisation: Tutorials Point
</pre>
<h2>Other Data Types</h2>
<p>The following table provides some other data types of F#.</p>
<table class="table table-bordered">
<tr>
<th style="width:12%;">F# Type</th>
<th style="width:15%;">Size</th>
<th>Range</th>
<th>Example</th>
<th>Remarks</th>
</tr>
<tr>
<td>bool</td>
<td>1 byte</td>
<td>Only two possible values, true or false</td>
<td><p>true</p>
<p>false</p></td>
<td>Stores boolean values</td>
</tr>
</table>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
let trueVal = true
let falseVal = false

printfn "True Value: %b" (trueVal)
printfn "False Value: %b" (falseVal)
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
True Value: true
False Value: false
</pre>

<title>F# Variables</title>

<h1>F# - Variables</h1>

<p>A variable is a name given to a storage area that our programs can manipulate. Each variable has a specific type, which determines the size and layout of the variable's memory; the range of values that can be stored within that memory; and the set of operations that can be applied to the variable.</p>

<h2>Variable Declaration in F#</h2>

<p>The <b>let</b> keyword is used for variable declaration &minus;</p>

<p>For example,</p>

<p>It declares a variable x and assigns the value 10 to it.</p>

<p>You can also assign an expression to a variable &minus;</p>

<p>The following example illustrates the concept &minus;</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>Variables in F# are <b>immutable,</b> which means once a variable is bound to a value, it can’t be changed. They are actually compiled as static read-only properties.</p>

<p>The following example demonstrates this.</p>

<h3>Example</h3>

<p>When you compile and execute the program, it shows the following error message &minus;</p>

<h2>Variable Definition With Type Declaration</h2>

<p>A variable definition tells the compiler where and how much storage for the variable should be created. A variable definition may specify a data type and contains a list of one or more variables of that type as shown in the following example.</p>

<h3>Example</h3>

<p>When you compile and execute the program, it shows the following error message &minus;</p>

<h2>Mutable Variables</h2>

<p>At times you need to change the values stored in a variable. To specify that there could be a change in the value of a declared and assigned variable, in later part of a program, F# provides the <b>mutable</b> keyword. You can declare and assign mutable variables using this keyword, whose values you will change.</p>

<p>The <b>mutable</b> keyword allows you to declare and assign values in a mutable variable.</p>

<p>You can assign some initial value to a mutable variable using the <b>let</b> keyword. However, to assign new subsequent value to it, you need to use the <b>&larr;</b> operator.</p>

<p>For example,</p>

<p>The following example will clear the concept &minus;</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
let x = 10
</pre>
<p>It declares a variable x and assigns the value 10 to it.</p>
<p>You can also assign an expression to a variable &minus;</p>
<pre class="result notranslate">
let x = 10
let y = 20
let z = x + y
</pre>
<p>The following example illustrates the concept &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
let x = 10
let y = 20
let z = x + y

printfn "x: %i" x
printfn "y: %i" y
printfn "z: %i" z
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
x: 10
y: 20
z: 30
</pre>
<p>Variables in F# are <b>immutable,</b> which means once a variable is bound to a value, it can’t be changed. They are actually compiled as static read-only properties.</p>
<p>The following example demonstrates this.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
let x = 10
let y = 20
let z = x + y

printfn "x: %i" x
printfn "y: %i" y
printfn "z: %i" z

let x = 15
let y = 20
let z = x + y

printfn "x: %i" x
printfn "y: %i" y
printfn "z: %i" z
</pre>
<p>When you compile and execute the program, it shows the following error message &minus;</p>
<pre class="result notranslate">
Duplicate definition of value 'x'
Duplicate definition of value 'Y'
Duplicate definition of value 'Z'
</pre>
<h2>Variable Definition With Type Declaration</h2>
<p>A variable definition tells the compiler where and how much storage for the variable should be created. A variable definition may specify a data type and contains a list of one or more variables of that type as shown in the following example.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
let x:int32 = 10
let y:int32 = 20
let z:int32 = x + y

printfn "x: %d" x
printfn "y: %d" y
printfn "z: %d" z

let p:float = 15.99
let q:float = 20.78
let r:float = p + q

printfn "p: %g" p
printfn "q: %g" q
printfn "r: %g" r
</pre>
<p>When you compile and execute the program, it shows the following error message &minus;</p>
<pre class="result notranslate">
x: 10
y: 20
z: 30
p: 15.99
q: 20.78
r: 36.77
</pre>
<h2>Mutable Variables</h2>
<p>At times you need to change the values stored in a variable. To specify that there could be a change in the value of a declared and assigned variable, in later part of a program, F# provides the <b>mutable</b> keyword. You can declare and assign mutable variables using this keyword, whose values you will change.</p>
<p>The <b>mutable</b> keyword allows you to declare and assign values in a mutable variable.</p>
<p>You can assign some initial value to a mutable variable using the <b>let</b> keyword. However, to assign new subsequent value to it, you need to use the <b>&larr;</b> operator.</p>
<p>For example,</p>
<pre class="result notranslate">
let mutable x = 10
x &larr; 15
</pre>
<p>The following example will clear the concept &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
let mutable x = 10
let y = 20
let mutable z = x + y

printfn "Original Values:"
printfn "x: %i" x
printfn "y: %i" y
printfn "z: %i" z

printfn "Let us change the value of x"
printfn "Value of z will change too."

x &lt;- 15
z &lt;- x + y

printfn "New Values:"
printfn "x: %i" x
printfn "y: %i" y
printfn "z: %i" z
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Original Values:
x: 10
y: 20
z: 30
Let us change the value of x
Value of z will change too.
New Values:
x: 15
y: 20
z: 35
</pre>

<title>F# Operators</title>

<h1>F# - Operators</h1>

<p>An operator is a symbol that tells the compiler to perform specific mathematical or logical manipulations. F# is rich in built-in operators and provides the following types of operators &minus;</p>

<h2>Arithmetic Operators</h2>

<p>The following table shows all the arithmetic operators supported by F# language. Assume variable A holds 10 and variable B holds 20 then &minus;</p>

<p><a href="/fsharp/fsharp_arithmetic_operators.htm">Show Example</a></p>

<h2>Comparison Operators</h2>

<p>The following table shows all the comparison operators supported by F# language. These binary comparison operators are available for integral and floating-point types. These operators return values of type bool.</p>

<p>Assume variable A holds 10 and variable B holds 20, then &minus;</p>

<p><a href="/fsharp/fsharp_comparison_operators.htm">Show Example</a></p>

<h2>Boolean Operators</h2>

<p>The following table shows all the Boolean operators supported by F# language. Assume variable A holds <b>true</b> and variable B holds <b>false,</b> then &minus;</p>

<p><a href="/fsharp/fsharp_boolean_operators.htm">Show Example</a></p>

<h2>Bitwise Operators</h2>

<p>Bitwise operators work on bits and perform bit-by-bit operation. The truth tables for &amp;&amp;&amp; (bitwise AND), ||| (bitwise OR), and ^^^ (bitwise exclusive OR) are as follows &minus;</p>

<p><a href="/fsharp/fsharp_bitwise_operators.htm">Show Example</a></p>

<p>Assume if A = 60; and B = 13; now in binary format they will be as follows &minus;</p>

<p>A = 0011 1100</p>

<p>B = 0000 1101</p>

<p>A&amp;&amp;&amp;B = 0000 1100</p>

<p>A|||B = 0011 1101</p>

<p>A^^^B = 0011 0001</p>

<p>~~~A = 1100 0011</p>

<p>The Bitwise operators supported by F# language are listed in the following table. Assume variable A holds 60 and variable B holds 13, then &minus;</p>

<h2>Operators Precedence</h2>

<p>The following table shows the order of precedence of operators and other expression keywords in the F# language, from lowest precedence to the highest precedence.</p>

<p><a href="/fsharp/fsharp_operators_precedence.htm">Show Example</a></p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>F# Decision Making</title>

<h1>F# - Decision Making</h1>

<p>Decision making structures require that the programmer specify one or more conditions to be evaluated or tested by the program. It should be along with a statement or statements to be executed if the condition is determined to be true, and optionally, other statements to be executed if the condition is determined to be false.</p>

<p>Following is the general form of a typical decision making structure found in most of the programming languages &minus;</p>

<p>F# programming language provides the following types of decision making statements.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>F# Loops</title>

<h1>F# - Loops</h1>

<p>Programming languages provide various control structures that allow for more complicated execution paths.</p>

<p>A loop statement allows us to execute a statement or group of statements multiple times and following is the general form of a loop statement in most of the programming languages &minus;</p>

<p>F# provides the following types of loops to handle the looping requirements.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>F# Functions</title>

<h1>F# - Functions</h1>

<p>In F#, functions work like data types. You can declare and use a function in the same way like any other variable.</p>

<p>Since functions can be used like any other variables, you can &minus;</p>

<h2>Defining a Function</h2>

<p>Functions are defined by using the <b>let</b> keyword. A function definition has the following syntax &minus;</p>

<p>Where,</p>

<p><b>function-name</b> is an identifier that represents the function.</p>

<p><b>parameter-list</b> gives the list of parameters separated by spaces. You can also specify an explicit type for each parameter and if not specified compiler tends to deduce it from the function body (like variables).</p>

<p><b>function-body</b> consists of an expression, or a compound expression consisting of a number of expressions. The final expression in the function body is the return value.</p>

<p><b>return-type</b> is a colon followed by a type and is optional. If the return type is not specified, then the compiler determines it from the final expression in the function body.</p>

<h2>Parameters of a Function</h2>

<p>You list the names of parameters right after the function name. You can specify the type of a parameter. The type of the parameter should follow the name of the parameter separated by a colon.</p>

<p>If no parameter type is specified, it is inferred by the compiler.</p>

<p>For example &minus;</p>

<h3>Calling a Function</h3>

<p>A function is called by specifying the function name followed by a space and then any arguments separated by spaces.</p>

<p>For example &minus;</p>

<p>The following programs illustrate the concepts.</p>

<h3>Example 1</h3>

<p>The following program calculates the volume of a cylinder when the radius and length are given as parameters.</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h3>Example 2</h3>

<p>The following program returns the larger value of two given parameters &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h3>Example 3</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Recursive Functions</h2>

<p>Recursive functions are functions that call themselves.</p>

<p>You define a recursive using the <b>let rec</b> keyword combination.</p>

<p>Syntax for defining a recursive function is &minus;</p>

<p>For example &minus;</p>

<h3>Example 1</h3>

<p>The following program returns Fibonacci 1 to 10 &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h3>Example 2</h3>

<p>The following program returns factorial 8 &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Arrow Notations in F#</h2>

<p>F# reports about data type in functions and values, using a chained arrow notation. Let us take an example of a function that takes one <i>int</i> input, and returns a string. In arrow notation, it is written as &minus;</p>

<p>Data types are read from left to right.</p>

<p>Let us take another hypothetical function that takes two int data inputs and returns a string.</p>

<p>F# reports the data type using chained arrow notation as &minus;</p>

<p>The return type is represented by the rightmost data type in chained arrow notation.</p>

<p>Some more examples &minus;</p>

<h2>Lambda Expressions</h2>

<p>A <b>lambda expression</b> is an unnamed function.</p>

<p>Let us take an example of two functions &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>Now in the above example, if instead of defining the function <i>mul,</i> we could have used lambda expressions as &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Function Composition and Pipelining</h2>

<p>In F#, one function can be composed from other functions.</p>

<p>The following example shows the composition of a function named f, from two functions function1 and function2 &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>F# also provides a feature called <b>pipelining of functions.</b> Pipelining allows function calls to be chained together as successive operations.</p>

<p>The following example shows that &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
let [inline] function-name parameter-list [ : return-type ]
= function-body
</pre>
<p>Where,</p>
<ul class="list">
<li><p><b>function-name</b> is an identifier that represents the function.</p></li>
<li><p><b>parameter-list</b> gives the list of parameters separated by spaces. You can also specify an explicit type for each parameter and if not specified compiler tends to deduce it from the function body (like variables).</p></li>
<li><p><b>function-body</b> consists of an expression, or a compound expression consisting of a number of expressions. The final expression in the function body is the return value.</p></li>
<li><p><b>return-type</b> is a colon followed by a type and is optional. If the return type is not specified, then the compiler determines it from the final expression in the function body.</p></li>
</ul>
<h2>Parameters of a Function</h2>
<p>You list the names of parameters right after the function name. You can specify the type of a parameter. The type of the parameter should follow the name of the parameter separated by a colon.</p>
<p>If no parameter type is specified, it is inferred by the compiler.</p>
<p>For example &minus;</p>
<pre class="result notranslate">
let doubleIt (x : int) = 2 * x
</pre>
<h3>Calling a Function</h3>
<p>A function is called by specifying the function name followed by a space and then any arguments separated by spaces.</p>
<p>For example &minus;</p>
<pre class="result notranslate">
let vol = cylinderVolume 3.0 5.0
</pre>
<p>The following programs illustrate the concepts.</p>
<h3>Example 1</h3>
<p>The following program calculates the volume of a cylinder when the radius and length are given as parameters.</p>
<pre class="prettyprint notranslate tryit">
// the function calculates the volume of
// a cylinder with radius and length as parameters

let cylinderVolume radius length : float =

   // function body
   let pi = 3.14159
   length * pi * radius * radius

let vol = cylinderVolume 3.0 5.0
printfn " Volume: %g " vol
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Volume: 141.372
</pre>
<h3>Example 2</h3>
<p>The following program returns the larger value of two given parameters &minus;</p>
<pre class="prettyprint notranslate tryit">
// the function returns the larger value between two
// arguments

let max num1 num2 : int32 =
   // function body
   if(num1>num2)then
      num1
   else
      num2

let res = max 39 52
printfn " Max Value: %d " res
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Max Value: 52
</pre>
<h3>Example 3</h3>
<pre class="prettyprint notranslate tryit">
let doubleIt (x : int) = 2 * x
printfn "Double 19: %d" ( doubleIt(19))
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Double 19: 38
</pre>
<h2>Recursive Functions</h2>
<p>Recursive functions are functions that call themselves.</p>
<p>You define a recursive using the <b>let rec</b> keyword combination.</p>
<p>Syntax for defining a recursive function is &minus;</p>
<pre class="result notranslate">
//Recursive function definition
let rec function-name parameter-list = recursive-function-body
</pre>
<p>For example &minus;</p>
<pre class="result notranslate">
let rec fib n = if n &lt; 2 then 1 else fib (n - 1) &plus; fib (n - 2)
</pre>
<h3>Example 1</h3>
<p>The following program returns Fibonacci 1 to 10 &minus;</p>
<pre class="prettyprint notranslate tryit">
let rec fib n = if n &lt; 2 then 1 else fib (n - 1) &plus; fib (n - 2)
for i = 1 to 10 do
   printfn "Fibonacci %d: %d" i (fib i)
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Fibonacci 1: 1
Fibonacci 2: 2
Fibonacci 3: 3
Fibonacci 4: 5
Fibonacci 5: 8
Fibonacci 6: 13
Fibonacci 7: 21
Fibonacci 8: 34
Fibonacci 9: 55
Fibonacci 10: 89
</pre>
<h3>Example 2</h3>
<p>The following program returns factorial 8 &minus;</p>
<pre class="prettyprint notranslate tryit">
open System
let rec fact x =
   if x &lt; 1 then 1
   else x * fact (x - 1)
Console.WriteLine(fact 8)
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
40320
</pre>
<h2>Arrow Notations in F#</h2>
<p>F# reports about data type in functions and values, using a chained arrow notation. Let us take an example of a function that takes one <i>int</i> input, and returns a string. In arrow notation, it is written as &minus;</p>
<pre class="result notranslate">
int -&gt; string
</pre>
<p>Data types are read from left to right.</p>
<p>Let us take another hypothetical function that takes two int data inputs and returns a string.</p>
<pre class="result notranslate">
let mydivfunction x y = (x / y).ToString();;
</pre>
<p>F# reports the data type using chained arrow notation as &minus;</p>
<pre class="result notranslate">
val mydivfunction : x:int -&gt; y:int -&gt; string
</pre>
<p>The return type is represented by the rightmost data type in chained arrow notation.</p>
<p>Some more examples &minus;</p>
<table class="table table-bordered">
<tr>
<th>Notation</th>
<th>Meaning</th>
</tr>
<tr>
<td>float &rarr; float &rarr; float</td>
<td>The function takes two <i>float</i> inputs, returns another <i>float</i>.</td>
</tr>
<tr>
<td>int &rarr; string &rarr; float</td>
<td>The function takes an <i>int</i> and a <i>string</i> input, returns a <i>float</i>.</td>
</tr>
</table>
<h2>Lambda Expressions</h2>
<p>A <b>lambda expression</b> is an unnamed function.</p>
<p>Let us take an example of two functions &minus;</p>
<pre class="prettyprint notranslate tryit">
let applyFunction ( f: int -&gt; int -&gt; int) x y = f x y
let mul x y = x * y
let res = applyFunction mul 5 7
printfn "%d" res
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
35
</pre>
<p>Now in the above example, if instead of defining the function <i>mul,</i> we could have used lambda expressions as &minus;</p>
<pre class="prettyprint notranslate tryit">
let applyFunction ( f: int -&gt; int -&gt; int) x y = f x y
let res = applyFunction (fun x y -&gt; x * y ) 5 7
printfn "%d" res
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
35
</pre>
<h2>Function Composition and Pipelining</h2>
<p>In F#, one function can be composed from other functions.</p>
<p>The following example shows the composition of a function named f, from two functions function1 and function2 &minus;</p>
<pre class="prettyprint notranslate tryit">
let function1 x = x + 1
let function2 x = x * 5

let f = function1 &gt;&gt; function2
let res = f 10
printfn "%d" res
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
55
</pre>
<p>F# also provides a feature called <b>pipelining of functions.</b> Pipelining allows function calls to be chained together as successive operations.</p>
<p>The following example shows that &minus;</p>
<pre class="prettyprint notranslate tryit">
let function1 x = x + 1
let function2 x = x * 5

let res = 10 |> function1 |> function2
printfn "%d" res
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
55
</pre>

<title>F# Strings</title>

<h1>F# - Strings</h1>

<p>In F#, the string type represents immutable text as a sequence of Unicode characters.</p>

<h2>String Literals</h2>

<p>String literals are delimited by the quotation mark (") character.</p>

<p>Some special characters are there for special uses like newline, tab, etc. They are encoded using backslash (\) character. The backslash character and the related character make the escape sequence. The following table shows the escape sequence supported by F#.</p>

<h2>Ways of lgnoring the Escape Sequence</h2>

<p>The following two ways makes the compiler ignore the escape sequence &minus;</p>

<p>When a string literal is preceded by the @ symbol, it is called a <b>verbatim string.</b> In that way, all escape sequences in the string are ignored, except that two quotation mark characters are interpreted as one quotation mark character.</p>

<p>When a string is enclosed by triple quotes, then also all escape sequences are ignored, including double quotation mark characters.</p>

<h3>Example</h3>

<p>The following example demonstrates this technique showing how to work with XML or other structures that include embedded quotation marks &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Basic Operators on Strings</h2>

<p>The following table shows the basic operations on strings &minus;</p>

<p>The following examples demonstrate the uses of some of the above functionalities &minus;</p>

<h3>Example 1</h3>

<p>The String.collect function builds a new string whose characters are the results of applying a specified function to each of the characters of the input string and concatenating the resulting strings.</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h3>Example 2</h3>

<p>The String.concat function concatenates a given sequence of strings with a separator and returns a new string.</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h3>Example 3</h3>

<p>The String.replicate method returns a string by concatenating a specified number of instances of a string.</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate tryit">
// Using a verbatim string
let xmldata = @"&lt;book author=""Lewis, C.S"" title=""Narnia""&gt;"
printfn "%s" xmldata
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
&lt;book author="Lewis, C.S" title="Narnia"&gt;
</pre>
<h2>Basic Operators on Strings</h2>
<p>The following table shows the basic operations on strings &minus;</p>
<table class="table table-bordered">
<tr>
<th style="width:49%;">Value</th>
<th>Description</th>
</tr>
<tr>
<td>collect : (char &rarr; string) &rarr; string &rarr; string</td>
<td>Creates a new string whose characters are the results of applying a specified function to each of the characters of the input string and concatenating the resulting strings.</td>
</tr>
<tr>
<td>concat : string &rarr; seq&lt;string&gt; &rarr; string</td>
<td>Returns a new string made by concatenating the given strings with a separator.</td>
</tr>
<tr>
<td>exists : (char &rarr; bool) &rarr; string &rarr; bool</td>
<td>Tests if any character of the string satisfies the given predicate.</td>
</tr>
<tr>
<td>forall : (char &rarr; bool) &rarr; string &rarr; bool</td>
<td>Tests if all characters in the string satisfy the given predicate.</td>
</tr>
<tr>
<td>init : int &rarr; (int &rarr; string) &rarr; string</td>
<td>Creates a new string whose characters are the results of applying a specified function to each index and concatenating the resulting strings.</td>
</tr>
<tr>
<td>iter : (char &rarr; unit) &rarr; string &rarr; unit</td>
<td>Applies a specified function to each character in the string.</td>
</tr>
<tr>
<td>iteri : (int &rarr; char &rarr; unit) &rarr; string &rarr; unit</td>
<td>Applies a specified function to the index of each character in the string and the character itself.</td>
</tr>
<tr>
<td>length : string &rarr; int</td>
<td>Returns the length of the string.</td>
</tr>
<tr>
<td>map : (char &rarr; char) &rarr; string &rarr; string</td>
<td>Creates a new string whose characters are the results of applying a specified function to each of the characters of the input string.</td>
</tr>
<tr>
<td>mapi : (int &rarr; char &rarr; char) &rarr; string &rarr; string</td>
<td>Creates a new string whose characters are the results of applying a specified function to each character and index of the input string.</td>
</tr>
<tr>
<td>replicate : int &rarr; string &rarr; string</td>
<td>Returns a string by concatenating a specified number of instances of a string.</td>
</tr>
</table>
<p>The following examples demonstrate the uses of some of the above functionalities &minus;</p>
<h3>Example 1</h3>
<p>The String.collect function builds a new string whose characters are the results of applying a specified function to each of the characters of the input string and concatenating the resulting strings.</p>
<pre class="prettyprint notranslate tryit">
let collectTesting inputS =
   String.collect (fun c -&gt; sprintf "%c " c) inputS
printfn "%s" (collectTesting "Happy New Year!")
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
H a p p y N e w Y e a r !
</pre>
<h3>Example 2</h3>
<p>The String.concat function concatenates a given sequence of strings with a separator and returns a new string.</p>
<pre class="prettyprint notranslate tryit">
let strings = [ "Tutorials Point"; "Coding Ground"; "Absolute Classes" ]
let ourProducts = String.concat "\n" strings
printfn "%s" ourProducts
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Tutorials Point
Coding Ground
Absolute Classes
</pre>
<h3>Example 3</h3>
<p>The String.replicate method returns a string by concatenating a specified number of instances of a string.</p>
<pre class="prettyprint notranslate tryit">
printfn "%s" &lt;| String.replicate 10 "*! "
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
*! *! *! *! *! *! *! *! *! *!
</pre>

<title>F# Options</title>

<h1>F# - Options</h1>

<p>The <b>option</b> type in F# is used in calculations when there may or may not exist a value for a variable or function. Option types are used for representing optional values in calculations. They can have two possible values &minus; <b>Some(x)</b> or <b>None</b>.</p>

<p>For example, a function performing a division will return a value in normal situation, but will throw exceptions in case of a zero denominator. Using options here will help to indicate whether the function has succeeded or failed.</p>

<p>An option has an underlying type and can hold a value of that type, or it might not have a value.</p>

<h2>Using Options</h2>

<p>Let us take the example of division function. The following program explains this &minus;</p>

<p>Let us write a function div, and send two arguments to it 20 and 5 &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>If the second argument is zero, then the program throws an exception &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>In such cases, we can use option types to return Some (value) when the operation is successful or None if the operation fails.</p>

<p>The following example demonstrates the use of options &minus;</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Option Properties and Methods</h2>

<p>The option type supports the following properties and methods &minus;</p>

<h3>Example 1</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h3>Example 2</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h3>Example 3</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate tryit">
let div x y = x / y
let res = div 20 5
printfn "Result: %d" res
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Result: 4
</pre>
<p>If the second argument is zero, then the program throws an exception &minus;</p>
<pre class="prettyprint notranslate tryit">
let div x y = x / y
let res = div 20 0
printfn "Result: %d" res
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Unhandled Exception:
System.DivideByZeroException: Division by zero
</pre>
<p>In such cases, we can use option types to return Some (value) when the operation is successful or None if the operation fails.</p>
<p>The following example demonstrates the use of options &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
let div x y =
   match y with
   | 0 -&gt; None
   | _ -&gt; Some(x/y)

let res : int option = div 20 4
printfn "Result: %A " res
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Result: Some 5
</pre>
<h2>Option Properties and Methods</h2>
<p>The option type supports the following properties and methods &minus;</p>
<table class="table table-bordered">
<tr>
<th style="width:30%;">Property or method</th>
<th style="width:15%;">Type</th>
<th>Description</th>
</tr>
<tr>
<td>None</td>
<td>'T option</td>
<td>A static property that enables you to create an option value that has the <b>None value</b>.</td>
</tr>
<tr>
<td>IsNone</td>
<td>bool</td>
<td>Returns <b>true</b> if the option has the <b>None</b> value.</td>
</tr>
<tr>
<td>IsSome</td>
<td>bool</td>
<td>Returns <b>true</b> if the option has a value that is not <b>None</b>.</td>
</tr>
<tr>
<td>Some</td>
<td>'T option</td>
<td>A static member that creates an option that has a value that is not <b>None</b>.</td>
</tr>
<tr>
<td>Value</td>
<td>'T</td>
<td>Returns the underlying value, or throws a NullReferenceException if the value is <b>None</b>.</td>
</tr>
</table>
<h3>Example 1</h3>
<pre class="prettyprint notranslate tryit">
let checkPositive (a : int) =
   if a > 0 then
      Some(a)
   else
      None

let res : int option = checkPositive(-31)
printfn "Result: %A " res
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Result: &lt;null&gt;
</pre>
<h3>Example 2</h3>
<pre class="prettyprint notranslate tryit">
let div x y =
   match y with
   | 0 -&gt; None
   | _ -&gt; Some(x/y)

let res : int option = div 20 4
printfn "Result: %A " res
printfn "Result: %A " res.Value
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Result: Some 5
Result: 5
</pre>
<h3>Example 3</h3>
<pre class="prettyprint notranslate tryit">
let isHundred = function
   | Some(100) -&gt; true
   | Some(_) | None -&gt; false

printfn "%A" (isHundred (Some(45)))
printfn "%A" (isHundred (Some(100)))
printfn "%A" (isHundred None)
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
false
true
false
</pre>

<title>F# Tuples</title>

<h1>F# - Tuples</h1>

<p>A <b>tuple</b> is a comma-separated collection of values. These are used for creating ad hoc data structures, which group together related values.</p>

<p>For example, (“Zara Ali”, “Hyderabad”, 10) is a 3-tuple with two string values and an int value, it has the type (string * string * int).</p>

<p>Tuples could be pairs, triples, and so on, of the same or different types.</p>

<p>Some examples are provided here &minus;</p>

<h2>Example</h2>

<p>This program has a function that takes a tuple of four float values and returns the average &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Accessing Individual Tuple Members</h2>

<p>The individual members of a tuple could be assessed and printed using pattern matching.</p>

<p>The following example illustrates the concept &minus;</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>F# has two built-in functions, <b>fst</b> and <b>snd,</b> which return the first and second items in a 2-tuple.</p>

<p>The following example illustrates the concept &minus;</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
// Tuple of two integers.
( 4, 5 )

// Triple of strings.
( "one", "two", "three" )

// Tuple of unknown types.
( a, b )

// Tuple that has mixed types.
( "Absolute Classes", 1, 2.0 )

// Tuple of integer expressions.
( a * 4, b + 7)
</pre>
<h2>Example</h2>
<p>This program has a function that takes a tuple of four float values and returns the average &minus;</p>
<pre class="prettyprint notranslate tryit">
let averageFour (a, b, c, d) =
   let sum = a + b + c + d
   sum / 4.0

let avg:float = averageFour (4.0, 5.1, 8.0, 12.0)
printfn "Avg of four numbers: %f" avg
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Avg of four numbers: 7.275000
</pre>
<h2>Accessing Individual Tuple Members</h2>
<p>The individual members of a tuple could be assessed and printed using pattern matching.</p>
<p>The following example illustrates the concept &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
let display tuple1 =
   match tuple1 with
   | (a, b, c) -&gt; printfn "Detail Info: %A %A %A" a b c

display ("Zara Ali", "Hyderabad", 10 )
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Detail Info: "Zara Ali" "Hyderabad" 10
</pre>
<p>F# has two built-in functions, <b>fst</b> and <b>snd,</b> which return the first and second items in a 2-tuple.</p>
<p>The following example illustrates the concept &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
printfn "First member: %A" (fst(23, 30))
printfn "Second member: %A" (snd(23, 30))

printfn "First member: %A" (fst("Hello", "World!"))
printfn "Second member: %A" (snd("Hello", "World!"))

let nameTuple = ("Zara", "Ali")

printfn "First Name: %A" (fst nameTuple)
printfn "Second Name: %A" (snd nameTuple)
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
First member: 23
Second member: 30
First member: "Hello"
Second member: "World!"
First Name: "Zara"
Second Name: "Ali"
</pre>

<title>F# Records</title>

<h1>F# - Records</h1>

<p>A <b>record</b> is similar to a tuple, however it contains named fields. For example,</p>

<h2>Defining Record</h2>

<p>A record is defined as a type using the <b>type</b> keyword, and the fields of the record are defined as a semicolon-separated list.</p>

<p>Syntax for defining a record is &minus;</p>

<h2>Creating a Record</h2>

<p>You can create a record by specifying the record's fields. For example, let us create a <i>website</i> record named <i>homepage</i> &minus;</p>

<p>The following examples will explain the concepts &minus;</p>

<h3>Example 1</h3>

<p>This program defines a record type named website. Then it creates some records of type website and prints the records.</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h3>Example 2</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
type website =
   { title : string;
      url : string }
</pre>
<h2>Defining Record</h2>
<p>A record is defined as a type using the <b>type</b> keyword, and the fields of the record are defined as a semicolon-separated list.</p>
<p>Syntax for defining a record is &minus;</p>
<pre class="result notranslate">
type recordName =
   { [ fieldName : dataType ] + }
</pre>
<h2>Creating a Record</h2>
<p>You can create a record by specifying the record's fields. For example, let us create a <i>website</i> record named <i>homepage</i> &minus;</p>
<pre class="result notranslate">
let homepage = { Title = "TutorialsPoint"; Url = "www.tutorialspoint.com" }
</pre>
<p>The following examples will explain the concepts &minus;</p>
<h3>Example 1</h3>
<p>This program defines a record type named website. Then it creates some records of type website and prints the records.</p>
<pre class="prettyprint notranslate tryit">
(* defining a record type named website *)
type website =
   { Title : string;
      Url : string }

(* creating some records *)
let homepage = { Title = "TutorialsPoint"; Url = "www.tutorialspoint.com" }
let cpage = { Title = "Learn C"; Url = "www.tutorialspoint.com/cprogramming/index.htm" }
let fsharppage = { Title = "Learn F#"; Url = "www.tutorialspoint.com/fsharp/index.htm" }
let csharppage = { Title = "Learn C#"; Url = "www.tutorialspoint.com/csharp/index.htm" }

(*printing records *)
(printfn "Home Page: Title: %A \n \t URL: %A") homepage.Title homepage.Url
(printfn "C Page: Title: %A \n \t URL: %A") cpage.Title cpage.Url
(printfn "F# Page: Title: %A \n \t URL: %A") fsharppage.Title fsharppage.Url
(printfn "C# Page: Title: %A \n \t URL: %A") csharppage.Title csharppage.Url
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Home Page: Title: "TutorialsPoint"
       URL: "www.tutorialspoint.com"
C Page: Title: "Learn C"
      URL: "www.tutorialspoint.com/cprogramming/index.htm"
F# Page: Title: "Learn F#"
      URL: "www.tutorialspoint.com/fsharp/index.htm"
C# Page: Title: "Learn C#"
      URL: "www.tutorialspoint.com/csharp/index.htm"
</pre>
<h3>Example 2</h3>
<pre class="prettyprint notranslate tryit">
type student =
   { Name : string;
      ID : int;
      RegistrationText : string;
      IsRegistered : bool }

let getStudent name id =
   { Name = name; ID = id; RegistrationText = null; IsRegistered = false }

let registerStudent st =
   { st with
      RegistrationText = "Registered";
      IsRegistered = true }

let printStudent msg st =
   printfn "%s: %A" msg st

let main() =
   let preRegisteredStudent = getStudent "Zara" 10
   let postRegisteredStudent = registerStudent preRegisteredStudent

   printStudent "Before Registration: " preRegisteredStudent
   printStudent "After Registration: " postRegisteredStudent

main()
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Before Registration: : {Name = "Zara";
   ID = 10;
   RegistrationText = null;
   IsRegistered = false;}
After Registration: : {Name = "Zara";
   ID = 10;
   RegistrationText = "Registered";
   IsRegistered = true;}
</pre>

<title>F# Lists</title>

<h1>F# - Lists</h1>

<p>In F#, a list is an ordered, immutable series of elements of the same type. It is to some extent equivalent to a linked list data structure.</p>

<p>The F# module, <b>Microsoft.FSharp.Collections.List,</b> has the common operations on lists. However F# imports this module automatically and makes it accessible to every F# application.</p>

<h2>Creating and Initializing a List</h2>

<p>Following are the various ways of creating lists &minus;</p>

<p>Using list <b>literals</b>.</p>

<p>Using <b>cons</b> (::) operator.</p>

<p>Using the <b>List.init</b> method of List module.</p>

<p>Using some <b>syntactic constructs</b> called <b>List Comprehensions</b>.</p>

<h3>List Literals</h3>

<p>In this method, you just specify a semicolon-delimited sequence of values in square brackets. For example &minus;</p>

<h3>The cons (::) Operator</h3>

<p>With this method, you can add some values by prepending or <b>cons-ing</b> it to an existing list using the :: operator. For example &minus;</p>

<p>[] denotes an empty list.</p>

<h3>List init Method</h3>

<p>The List.init method of the List module is often used for creating lists. This method has the type &minus;</p>

<p>The first argument is the desired length of the new list, and the second argument is an initializer function, which generates items in the list.</p>

<p>For example,</p>

<p>Here, the index function generates the list.</p>

<h3>List Comprehensions</h3>

<p>List comprehensions are special syntactic constructs used for generating lists.</p>

<p>F# list comprehension syntax comes in two forms &minus; ranges and generators.</p>

<p>Ranges have the constructs &minus; [start .. end] and [start .. step .. end]</p>

<p>For example,</p>

<p>Generators have the construct &minus; [for x in collection do ... yield expr]</p>

<p>For example,</p>

<p>As the <b>yield</b> keyword pushes a single value into a list, the keyword, <b>yield!,</b> pushes a collection of values into the list.</p>

<p>The following function demonstrates the above methods &minus;</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Properties of List Data Type</h2>

<p>The following table shows various properties of list data type &minus;</p>

<p>The following example shows the use of these properties &minus;</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Basic Operators on List</h2>

<p>The following table shows the basic operations on list data type &minus;</p>

<p>The following examples demonstrate the uses of the above functionalities &minus;</p>

<h3>Example 1</h3>

<p>This program shows reversing a list recursively &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>However, you can use the <b>rev</b> function of the module for the same purpose &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h3>Example 2</h3>

<p>This program shows filtering a list using the <b>List.filter</b> method &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h3>Example 3</h3>

<p>The <b>List.map</b> method maps a list from one type to another &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h3>Example 4</h3>

<p>The <b>List.append</b> method and the @ operator appends one list to another &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h3>Example 5</h3>

<p>The <b>List.sort</b> method sorts a list. The <b>List.sum</b> method gives the sum of elements in the list and the <b>List.average</b> method gives the average of elements in the list &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>A "fold" operation applies a function to each element in a list, aggregates the result of the function in an accumulator variable, and returns the accumulator as the result of the fold operation.</p>

<h3>Example 6</h3>

<p>The <b>List.fold</b> method applies a function to each element from left to right, while <b>List.foldBack</b> applies a function to each element from right to left.</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
let list1 = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]
</pre>
<h3>The cons (::) Operator</h3>
<p>With this method, you can add some values by prepending or <b>cons-ing</b> it to an existing list using the :: operator. For example &minus;</p>
<pre class="result notranslate">
let list2 = 1::2::3::4::5::6::7::8::9::10::[];;
</pre>
<p>[] denotes an empty list.</p>
<h3>List init Method</h3>
<p>The List.init method of the List module is often used for creating lists. This method has the type &minus;</p>
<pre class="result notranslate">
val init : int -&gt; (int -&gt; 'T) -&gt; 'T list
</pre>
<p>The first argument is the desired length of the new list, and the second argument is an initializer function, which generates items in the list.</p>
<p>For example,</p>
<pre class="result notranslate">
let list5 = List.init 5 (fun index -&gt; (index, index * index, index * index * index))
</pre>
<p>Here, the index function generates the list.</p>
<h3>List Comprehensions</h3>
<p>List comprehensions are special syntactic constructs used for generating lists.</p>
<p>F# list comprehension syntax comes in two forms &minus; ranges and generators.</p>
<p>Ranges have the constructs &minus; [start .. end] and [start .. step .. end]</p>
<p>For example,</p>
<pre class="result notranslate">
let list3 = [1 .. 10]
</pre>
<p>Generators have the construct &minus; [for x in collection do ... yield expr]</p>
<p>For example,</p>
<pre class="result notranslate">
let list6 = [ for a in 1 .. 10 do yield (a * a) ]
</pre>
<p>As the <b>yield</b> keyword pushes a single value into a list, the keyword, <b>yield!,</b> pushes a collection of values into the list.</p>
<p>The following function demonstrates the above methods &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
(* using list literals *)
let list1 = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]
printfn "The list: %A" list1

(*using cons operator *)
let list2 = 1 :: 2 :: 3 :: []
printfn "The list: %A" list2

(* using range constructs*)
let list3 = [1 .. 10]
printfn "The list: %A" list3

(* using range constructs *)
let list4 = ['a' .. 'm']
printfn "The list: %A" list4

(* using init method *)
let list5 = List.init 5 (fun index -> (index, index * index, index * index * index))
printfn "The list: %A" list5

(* using yield operator *)
let list6 = [ for a in 1 .. 10 do yield (a * a) ]
printfn "The list: %A" list6

(* using yield operator *)
let list7 = [ for a in 1 .. 100 do if a % 3 = 0 && a % 5 = 0 then yield a]
printfn "The list: %A" list7

(* using yield! operator *)
let list8 = [for a in 1 .. 3 do yield! [ a .. a + 3 ] ]
printfn "The list: %A" list8
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
The list: [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]
The list: [1; 2; 3]
The list: [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]
The list: ['a'; 'b'; 'c'; 'd'; 'e'; 'f'; 'g'; 'h'; 'i'; 'j'; 'k'; 'l'; 'm']
The list: [(0, 0, 0); (1, 1, 1); (2, 4, 8); (3, 9, 27); (4, 16, 64)]
The list: [1; 4; 9; 16; 25; 36; 49; 64; 81; 100]
The list: [15; 30; 45; 60; 75; 90]
The list: [1; 2; 3; 4; 2; 3; 4; 5; 3; 4; 5; 6]
</pre>
<h2>Properties of List Data Type</h2>
<p>The following table shows various properties of list data type &minus;</p>
<table class="table table-bordered">
<tr>
<th>Property</th>
<th>Type</th>
<th>Description</th>
</tr>
<tr>
<td>Head</td>
<td>'T</td>
<td>The first element.</td>
</tr>
<tr>
<td>Empty</td>
<td>'T list</td>
<td>A static property that returns an empty list of the appropriate type.</td>
</tr>
<tr>
<td>IsEmpty</td>
<td>bool</td>
<td><b>true</b> if the list has no elements.</td>
</tr>
<tr>
<td>Item</td>
<td>'T</td>
<td>The element at the specified index (zero-based).</td>
</tr>
<tr>
<td>Length</td>
<td>int</td>
<td>The number of elements.</td>
</tr>
<tr>
<td>Tail</td>
<td>'T list</td>
<td>The list without the first element.</td>
</tr>
</table>
<p>The following example shows the use of these properties &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
let list1 = [ 2; 4; 6; 8; 10; 12; 14; 16 ]

// Use of Properties
printfn "list1.IsEmpty is %b" (list1.IsEmpty)
printfn "list1.Length is %d" (list1.Length)
printfn "list1.Head is %d" (list1.Head)
printfn "list1.Tail.Head is %d" (list1.Tail.Head)
printfn "list1.Tail.Tail.Head is %d" (list1.Tail.Tail.Head)
printfn "list1.Item(1) is %d" (list1.Item(1))
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
list1.IsEmpty is false
list1.Length is 8
list1.Head is 2
list1.Tail.Head is 4
list1.Tail.Tail.Head is 6
list1.Item(1) is 4
</pre>
<h2>Basic Operators on List</h2>
<p>The following table shows the basic operations on list data type &minus;</p>
<table class="table table-bordered">
<tr>
<th style="width:48%;">Value</th>
<th>Description</th>
</tr>
<tr>
<td>append : 'T list &rarr; 'T list &rarr; 'T list</td>
<td>Returns a new list that contains the elements of the first list followed by elements of the second.</td>
</tr>
<tr>
<td>average : 'T list &rarr; ^T</td>
<td>Returns the average of the elements in the list.</td>
</tr>
<tr>
<td>averageBy : ('T &rarr; ^U) &rarr; 'T list &rarr; ^U</td>
<td>Returns the average of the elements generated by applying the function to each element of the list.</td>
</tr>
<tr>
<td>choose : ('T &rarr; 'U option) &rarr; 'T list &rarr; 'U list</td>
<td>Applies the given function to each element of the list. Returns the list comprised of the results for each element where the function returns <b>Some</b>.</td>
</tr>
<tr>
<td>collect : ('T &rarr; 'U list) &rarr; 'T list &rarr; 'U list</td>
<td>For each element of the list, applies the given function. Concatenates all the results and return the combined list.</td>
</tr>
<tr>
<td>concat : seq&lt;'T list&gt; &rarr; 'T list</td>
<td>Returns a new list that contains the elements of each the lists in order.</td>
</tr>
<tr>
<td>empty : 'T list</td>
<td>Returns an empty list of the given type.</td>
</tr>
<tr>
<td>exists : ('T &rarr; bool) &rarr; 'T list &rarr; bool</td>
<td>Tests if any element of the list satisfies the given predicate.</td>
</tr>
<tr>
<td>exists2 : ('T1 &rarr; 'T2 &rarr; bool) &rarr; 'T1 list &rarr; 'T2 list &rarr; bool</td>
<td>Tests if any pair of corresponding elements of the lists satisfies the given predicate.</td>
</tr>
<tr>
<td>filter : ('T &rarr; bool) &rarr; 'T list &rarr; 'T list</td>
<td>Returns a new collection containing only the elements of the collection for which the given predicate returns <b>true</b>.</td>
</tr>
<tr>
<td>find : ('T &rarr; bool) &rarr; 'T list &rarr; 'T</td>
<td>Returns the first element for which the given function returns <b>true</b>.</td>
</tr>
<tr>
<td>findIndex : ('T &rarr; bool) &rarr; 'T list &rarr; int</td>
<td>Returns the index of the first element in the list that satisfies the given predicate.</td>
</tr>
<tr>
<td>fold : ('State &rarr; 'T &rarr; 'State) &rarr; 'State &rarr; 'T list &rarr; 'State</td>
<td>Applies a function to each element of the collection, threading an accumulator argument through the computation. This function takes the second argument, and applies the function to it and the first element of the list. Then, it passes this result into the function along with the second element, and so on. Finally, it returns the final result. If the input function is f and the elements are i0...iN, then this function computes f (... (f s i0) i1 ...) iN.</td>
</tr>
<tr>
<td>fold2 : ('State &rarr; 'T1 &rarr; 'T2 &rarr; 'State) &rarr; 'State &rarr; 'T1 list &rarr; 'T2 list &rarr; 'State</td>
<td>Applies a function to corresponding elements of two collections, threading an accumulator argument through the computation. The collections must have identical sizes. If the input function is f and the elements are i0...iN and j0...jN, then this function computes f (... (f s i0 j0)...) iN jN.</td>
</tr>
<tr>
<td>foldBack : ('T &rarr; 'State &rarr; 'State) &rarr; 'T list &rarr; 'State &rarr; 'State</td>
<td>Applies a function to each element of the collection, threading an accumulator argument through the computation. If the input function isf and the elements are i0...iN then computes f i0 (...(f iN s)).</td>
</tr>
<tr>
<td>foldBack2 : ('T1 &rarr; 'T2 &rarr; 'State &rarr; 'State) &rarr; 'T1 list &rarr; 'T2 list &rarr; 'State &rarr; 'State</td>
<td>Applies a function to corresponding elements of two collections, threading an accumulator argument through the computation. The collections must have identical sizes. If the input function is f and the elements are i0...iN and j0...jN, then this function computes f i0 j0 (...(f iN jN s)).</td>
</tr>
<tr>
<td>forall : ('T &rarr; bool) &rarr; 'T list &rarr; bool</td>
<td>Tests if all elements of the collection satisfy the given predicate.</td>
</tr>
<tr>
<td>forall2 : ('T1 &rarr; 'T2 &rarr; bool) &rarr; 'T1 list &rarr; 'T2 list &rarr; bool</td>
<td>Tests if all corresponding elements of the collection satisfy the given predicate pairwise.</td>
</tr>
<tr>
<td>head : 'T list &rarr; 'T</td>
<td>Returns the first element of the list.</td>
</tr>
<tr>
<td>init : int &rarr; (int &rarr; 'T) &rarr; 'T list</td>
<td>Creates a list by calling the given generator on each index.</td>
</tr>
<tr>
<td>isEmpty : 'T list &rarr; bool</td>
<td>Returns <b>true</b> if the list contains no elements, <b>false</b> otherwise.</td>
</tr>
<tr>
<td>iter : ('T &rarr; unit) &rarr; 'T list &rarr; unit</td>
<td>Applies the given function to each element of the collection.</td>
</tr>
<tr>
<td>iter2 : ('T1 &rarr; 'T2 &rarr; unit) &rarr; 'T1 list &rarr; 'T2 list &rarr; unit</td>
<td>Applies the given function to two collections simultaneously. The collections must have identical size.</td>
</tr>
<tr>
<td>iteri : (int &rarr; 'T &rarr; unit) &rarr; 'T list &rarr; unit</td>
<td>Applies the given function to each element of the collection. The integer passed to the function indicates the index of element.</td>
</tr>
<tr>
<td>iteri2 : (int &rarr; 'T1 &rarr; 'T2 &rarr; unit) &rarr; 'T1 list &rarr; 'T2 list &rarr; unit</td>
<td>Applies the given function to two collections simultaneously. The collections must have identical size. The integer passed to the function indicates the index of element.</td>
</tr>
<tr>
<td>length : 'T list &rarr; int</td>
<td>Returns the length of the list.</td>
</tr>
<tr>
<td>map : ('T &rarr; 'U) &rarr; 'T list &rarr; 'U list</td>
<td>Creates a new collection whose elements are the results of applying the given function to each of the elements of the collection.</td>
</tr>
<tr>
<td>map2 : ('T1 &rarr; 'T2 &rarr; 'U) &rarr; 'T1 list &rarr; 'T2 list &rarr; 'U list</td>
<td>Creates a new collection whose elements are the results of applying the given function to the corresponding elements of the two collections pairwise.</td>
</tr>
<tr>
<td>map3 : ('T1 &rarr; 'T2 &rarr; 'T3 &rarr; 'U) &rarr; 'T1 list &rarr; 'T2 list &rarr; 'T3 list &rarr; 'U list</td>
<td>Creates a new collection whose elements are the results of applying the given function to the corresponding elements of the three collections simultaneously.</td>
</tr>
<tr>
<td>mapi : (int &rarr; 'T &rarr; 'U) &rarr; 'T list &rarr; 'U list</td>
<td>Creates a new collection whose elements are the results of applying the given function to each of the elements of the collection. The integer index passed to the function indicates the index (from 0) of element being transformed.</td>
</tr>
<tr>
<td>mapi2 : (int &rarr; 'T1 &rarr; 'T2 &rarr; 'U) &rarr; 'T1 list &rarr; 'T2 list &rarr; 'U list</td>
<td>Like List.mapi, but mapping corresponding elements from two lists of equal length.</td>
</tr>
<tr>
<td>max : 'T list &rarr; 'T</td>
<td>Returns the greatest of all elements of the list, compared by using Operators.max.</td>
</tr>
<tr>
<td>maxBy : ('T &rarr; 'U) &rarr; 'T list &rarr; 'T</td>
<td>Returns the greatest of all elements of the list, compared by using Operators.max on the function result.</td>
</tr>
<tr>
<td>min : 'T list &rarr; 'T</td>
<td>Returns the lowest of all elements of the list, compared by using Operators.min.</td>
</tr>
<tr>
<td>minBy : ('T &rarr; 'U) &rarr; 'T list &rarr; 'T</td>
<td>Returns the lowest of all elements of the list, compared by using Operators.min on the function result</td>
</tr>
<tr>
<td>nth : 'T list &rarr; int &rarr; 'T</td>
<td>Indexes into the list. The first element has index 0.</td>
</tr>
<tr>
<td>ofArray : 'T [] &rarr; 'T list</td>
<td>Creates a list from the given array.</td>
</tr>
<tr>
<td>ofSeq : seq&lt;'T&gt; &rarr; 'T list</td>
<td>Creates a new list from the given enumerable object.</td>
</tr>
<tr>
<td>partition : ('T &rarr; bool) &rarr; 'T list * 'T list</td>
<td>Splits the collection into two collections, containing the elements for which the given predicate returns <b>true</b> and <b>false</b> respectively.</td>
</tr>
<tr>
<td>permute : (int &rarr; int) &rarr; 'T list &rarr; 'T list</td>
<td>Returns a list with all elements permuted according to the specified permutation.</td>
</tr>
<tr>
<td>pick : ('T &rarr; 'U option) &rarr; 'T list &rarr; 'U</td>
<td>Applies the given function to successive elements, returning the first result where function returns <b>Some</b> for some value.</td>
</tr>
<tr>
<td>reduce : ('T &rarr; 'T &rarr; 'T) &rarr; 'T list &rarr; 'T</td>
<td>Applies a function to each element of the collection, threading an accumulator argument through the computation. This function applies the specified function to the first two elements of the list. It then passes this result into the function along with the third element, and so on. Finally, it returns the final result. If the input function is f and the elements are i0...iN, then this function computes f (... (f i0 i1) i2 ...) iN.</td>
</tr>
<tr>
<td>reduceBack : ('T &rarr; 'T &rarr; 'T) &rarr; 'T list &rarr; 'T</td>
<td>Applies a function to each element of the collection, threading an accumulator argument through the computation. If the input function isf and the elements are i0...iN, then this function computes f i0 (...(f iN-1 iN)).</td>
</tr>
<tr>
<td>replicate : (int &rarr; 'T &rarr; 'T list)</td>
<td>Creates a list by calling the given generator on each index.</td>
</tr>
<tr>
<td>rev : 'T list &rarr; 'T list</td>
<td>Returns a new list with the elements in reverse order.</td>
</tr>
<tr>
<td>scan : ('State &rarr; 'T &rarr; 'State) &rarr; 'State &rarr; 'T list &rarr; 'State list</td>
<td>Applies a function to each element of the collection, threading an accumulator argument through the computation. This function takes the second argument, and applies the specified function to it and the first element of the list. Then, it passes this result into the function along with the second element and so on. Finally, it returns the list of intermediate results and the final result.</td>
</tr>
<tr>
<td>scanBack : ('T &rarr; 'State &rarr; 'State) &rarr; 'T list &rarr; 'State &rarr; 'State list</td>
<td>Like foldBack, but returns both the intermediate and final results</td>
</tr>
<tr>
<td>sort : 'T list &rarr; 'T list</td>
<td>Sorts the given list using Operators.compare.</td>
</tr>
<tr>
<td>sortBy : ('T &rarr; 'Key) &rarr; 'T list &rarr; 'T list</td>
<td>Sorts the given list using keys given by the given projection. Keys are compared using Operators.compare.</td>
</tr>
<tr>
<td>sortWith : ('T &rarr; 'T &rarr; int) &rarr; 'T list &rarr; 'T list</td>
<td>Sorts the given list using the given comparison function.</td>
</tr>
<tr>
<td>sum : ^T list &rarr; ^T</td>
<td>Returns the sum of the elements in the list.</td>
</tr>
<tr>
<td>sumBy : ('T &rarr; ^U) &rarr; 'T list &rarr; ^U</td>
<td>Returns the sum of the results generated by applying the function to each element of the list.</td>
</tr>
<tr>
<td>tail : 'T list &rarr; 'T list</td>
<td>Returns the input list without the first element.</td>
</tr>
<tr>
<td>toArray : 'T list &rarr; 'T []</td>
<td>Creates an array from the given list.</td>
</tr>
<tr>
<td>toSeq : 'T list &rarr; seq&lt;'T&gt;</td>
<td>Views the given list as a sequence.</td>
</tr>
<tr>
<td>tryFind : ('T &rarr; bool) &rarr; 'T list &rarr; 'T option</td>
<td>Returns the first element for which the given function returns <b>true</b>. Return <b>None</b> if no such element exists.</td>
</tr>
<tr>
<td>tryFindIndex : ('T &rarr; bool) &rarr; 'T list &rarr; int option</td>
<td>Returns the index of the first element in the list that satisfies the given predicate. Return <b>None</b> if no such element exists.</td>
</tr>
<tr>
<td>tryPick : ('T &rarr; 'U option) &rarr; 'T list &rarr; 'U option</td>
<td>Applies the given function to successive elements, returning the first result where function returns <b>Some</b> for some value. If no such element exists then return <b>None</b>.</td>
</tr>
<tr>
<td>unzip : ('T1 * 'T2) list &rarr; 'T1 list * 'T2 list</td>
<td>Splits a list of pairs into two lists.</td>
</tr>
<tr>
<td>unzip3 : ('T1 * 'T2 * 'T3) list &rarr; 'T1 list * 'T2 list * 'T3 list</td>
<td>Splits a list of triples into three lists.</td>
</tr>
<tr>
<td>zip : 'T1 list &rarr; 'T2 list &rarr; ('T1 * 'T2) list</td>
<td>Combines the two lists into a list of pairs. The two lists must have equal lengths.</td>
</tr>
<tr>
<td>zip3 : 'T1 list &rarr; 'T2 list &rarr; 'T3 list &rarr; ('T1 * 'T2 * 'T3) list</td>
<td>Combines the three lists into a list of triples. The lists must have equal lengths.</td>
</tr>
</table>
<p>The following examples demonstrate the uses of the above functionalities &minus;</p>
<h3>Example 1</h3>
<p>This program shows reversing a list recursively &minus;</p>
<pre class="prettyprint notranslate tryit">
let list1 = [ 2; 4; 6; 8; 10; 12; 14; 16 ]
printfn "The original list: %A" list1

let reverse lt =
   let rec loop acc = function
      | [] -&gt; acc
      | hd :: tl -&gt; loop (hd :: acc) tl
   loop [] lt

printfn "The reversed list: %A" (reverse list1)
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
The original list: [2; 4; 6; 8; 10; 12; 14; 16]
The reversed list: [16; 14; 12; 10; 8; 6; 4; 2]
</pre>
<p>However, you can use the <b>rev</b> function of the module for the same purpose &minus;</p>
<pre class="prettyprint notranslate tryit">
let list1 = [ 2; 4; 6; 8; 10; 12; 14; 16 ]
printfn "The original list: %A" list1
printfn "The reversed list: %A" (List.rev list1)
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
The original list: [2; 4; 6; 8; 10; 12; 14; 16]
The reversed list: [16; 14; 12; 10; 8; 6; 4; 2]
</pre>
<h3>Example 2</h3>
<p>This program shows filtering a list using the <b>List.filter</b> method &minus;</p>
<pre class="prettyprint notranslate tryit">
let list1 = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]
printfn "The list: %A" list1
let list2 = list1 |&gt; List.filter (fun x -&gt; x % 2 = 0);;
printfn "The Filtered list: %A" list2
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
The list: [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]
The Filtered list: [2; 4; 6; 8; 10]
</pre>
<h3>Example 3</h3>
<p>The <b>List.map</b> method maps a list from one type to another &minus;</p>
<pre class="prettyprint notranslate tryit">
let list1 = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]
printfn "The list: %A" list1
let list2 = list1 |&gt; List.map (fun x -&gt; (x * x).ToString());;
printfn "The Mapped list: %A" list2
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
The list: [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]
The Mapped list: ["1"; "4"; "9"; "16"; "25"; "36"; "49"; "64"; "81"; "100"]
</pre>
<h3>Example 4</h3>
<p>The <b>List.append</b> method and the @ operator appends one list to another &minus;</p>
<pre class="prettyprint notranslate tryit">
let list1 = [1; 2; 3; 4; 5 ]
let list2 = [6; 7; 8; 9; 10]
let list3 = List.append list1 list2

printfn "The first list: %A" list1
printfn "The second list: %A" list2
printfn "The appened list: %A" list3

let lt1 = ['a'; 'b';'c' ]
let lt2 = ['e'; 'f';'g' ]
let lt3 = lt1 @ lt2

printfn "The first list: %A" lt1
printfn "The second list: %A" lt2
printfn "The appened list: %A" lt3
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
The first list: [1; 2; 3; 4; 5]
The second list: [6; 7; 8; 9; 10]
The appened list: [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]
The first list: ['a'; 'b'; 'c']
The second list: ['e'; 'f'; 'g']
The appened list: ['a'; 'b'; 'c'; 'e'; 'f'; 'g']
</pre>
<h3>Example 5</h3>
<p>The <b>List.sort</b> method sorts a list. The <b>List.sum</b> method gives the sum of elements in the list and the <b>List.average</b> method gives the average of elements in the list &minus;</p>
<pre class="prettyprint notranslate tryit">
let list1 = [9.0; 0.0; 2.0; -4.5; 11.2; 8.0; -10.0]
printfn "The list: %A" list1

let list2 = List.sort list1
printfn "The sorted list: %A" list2

let s = List.sum list1
let avg = List.average list1
printfn "The sum: %f" s
printfn "The average: %f" avg
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
The list: [9.0; 0.0; 2.0; -4.5; 11.2; 8.0; -10.0]
The sorted list: [-10.0; -4.5; 0.0; 2.0; 8.0; 9.0; 11.2]
The sum: 15.700000
The average: 2.242857
</pre>
<p>A "fold" operation applies a function to each element in a list, aggregates the result of the function in an accumulator variable, and returns the accumulator as the result of the fold operation.</p>
<h3>Example 6</h3>
<p>The <b>List.fold</b> method applies a function to each element from left to right, while <b>List.foldBack</b> applies a function to each element from right to left.</p>
<pre class="prettyprint notranslate tryit">
let sumList list = List.fold (fun acc elem -&gt; acc + elem) 0 list
printfn "Sum of the elements of list %A is %d." [ 1 .. 10 ] (sumList [ 1 .. 10 ])
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Sum of the elements of list [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] is 55.
</pre>

<title>F# Sequences</title>

<h1>F# - Sequences</h1>

<p>Sequences, like lists also represent an ordered collection of values. However, the elements in a sequence or sequence expression are computed when required. They are not computed at once, and for this reason they are used to represent infinite data structures.</p>

<h2>Defining Sequences</h2>

<p>Sequences are defined using the following syntax &minus;</p>

<p>For example,</p>

<h2>Creating Sequences and Sequences Expressions</h2>

<p>Similar to lists, you can create sequences using ranges and comprehensions.</p>

<p>Sequence expressions are the expressions you can write for creating sequences. These can be done &minus;</p>

<p>The following examples demonstrate the concept &minus;</p>

<h3>Example 1</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h3>Example 2</h3>

<p>The following program prints the prime numbers from 1 to 50 &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Basic Operations on Sequence</h2>

<p>The following table shows the basic operations on sequence data type &minus;</p>

<p>The following examples demonstrate the uses of some of the above functionalities &minus;</p>

<h3>Example 1</h3>

<p>This program creates an empty sequence and fills it up later &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>Please note that &minus;</p>

<p>The Seq.empty method creates an empty sequence.</p>

<p>The Seq.singleton method creates a sequence of just one specified element.</p>

<p>The Seq.init method creates a sequence for which the elements are created by using a given function.</p>

<p>The Seq.ofArray and Seq.ofList&lt;'T&gt; methods create sequences from arrays and lists.</p>

<p>The Seq.iter method allows iterating through a sequence.</p>

<h3>Example 2</h3>

<p>The Seq.unfold method generates a sequence from a computation function that takes a state and transforms it to produce each subsequent element in the sequence.</p>

<p>The following function produces the first 20 natural numbers &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h3>Example 3</h3>

<p>The Seq.truncate method creates a sequence from another sequence, but limits the sequence to a specified number of elements.</p>

<p>The Seq.take method creates a new sequence that contains a specified number of elements from the start of a sequence.</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
seq { expr }
</pre>
<p>For example,</p>
<pre class="result notranslate">
let seq1 = seq { 1 .. 10 }
</pre>
<h2>Creating Sequences and Sequences Expressions</h2>
<p>Similar to lists, you can create sequences using ranges and comprehensions.</p>
<p>Sequence expressions are the expressions you can write for creating sequences. These can be done &minus;</p>
<ul class="list">
<li>By specifying the range.</li>
<li>By specifying the range with increment or decrement.</li>
<li>By using the <b>yield</b> keyword to produce values that become part of the sequence.</li>
<li>By using the &rarr; operator.</li>
</ul>
<p>The following examples demonstrate the concept &minus;</p>
<h3>Example 1</h3>
<pre class="prettyprint notranslate tryit">
(* Sequences *)
let seq1 = seq { 1 .. 10 }

(* ascending order and increment*)
printfn "The Sequence: %A" seq1
let seq2 = seq { 1 .. 5 .. 50 }

(* descending order and decrement*)
printfn "The Sequence: %A" seq2
let seq3 = seq {50 .. -5 .. 0}
printfn "The Sequence: %A" seq3

(* using yield *)
let seq4 = seq { for a in 1 .. 10 do yield a, a*a, a*a*a }
printfn "The Sequence: %A" seq4
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
The Sequence: seq [1; 2; 3; 4; ...]
The Sequence: seq [1; 6; 11; 16; ...]
The Sequence: seq [50; 45; 40; 35; ...]
The Sequence: seq [(1, 1, 1); (2, 4, 8); (3, 9, 27); (4, 16, 64); ...]
</pre>
<h3>Example 2</h3>
<p>The following program prints the prime numbers from 1 to 50 &minus;</p>
<pre class="prettyprint notranslate tryit">
(* Recursive isprime function. *)
let isprime n =
   let rec check i =
      i &gt; n/2 || (n % i &lt;&gt; 0 && check (i + 1))
   check 2

let primeIn50 = seq { for n in 1..50 do if isprime n then yield n }
for x in primeIn50 do
   printfn "%d" x
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
1
2
3
5
7
11
13
17
19
23
29
31
37
41
43
47
</pre>
<h2>Basic Operations on Sequence</h2>
<p>The following table shows the basic operations on sequence data type &minus;</p>
<table class="table table-bordered">
<tr>
<th style="width:48%;">Value</th>
<th>Description</th>
</tr>
<tr>
<td>append : seq&lt;'T&gt; &rarr; seq&lt;'T&gt; &rarr; seq&lt;'T&gt;</td>
<td>Wraps the two given enumerations as a single concatenated enumeration.</td>
</tr>
<tr>
<td>average : seq&lt;^T&gt; &rarr; ^T</td>
<td>Returns the average of the elements in the sequence.</td>
</tr>
<tr>
<td>averageBy : ('T &rarr; ^U) &rarr; seq&lt;'T&gt; &rarr; ^U</td>
<td>Returns the average of the results generated by applying the function to each element of the sequence.</td>
</tr>
<tr>
<td>cache : seq&lt;'T&gt; &rarr; seq&lt;'T&gt;</td>
<td>Returns a sequence that corresponds to a cached version of the input sequence.</td>
</tr>
<tr>
<td>cast : IEnumerable &rarr; seq&lt;'T&gt;</td>
<td>Wraps a loosely-typed System. Collections sequence as a typed sequence.</td>
</tr>
<tr>
<td>choose : ('T &rarr; 'U option) &rarr; seq&lt;'T&gt; &rarr; seq&lt;'U&gt;</td>
<td>Applies the given function to each element of the list. Return the list comprised of the results for each element where the function returns <b>Some</b>.</td>
</tr>
<tr>
<td>collect : ('T &rarr; 'Collection) &rarr; seq&lt;'T&gt; &rarr; seq&lt;'U&gt;</td>
<td>Applies the given function to each element of the sequence and concatenates all the results.</td>
</tr>
<tr>
<td>compareWith : ('T &rarr; 'T &rarr; int) &rarr; seq&lt;'T&gt; &rarr; seq&lt;'T&gt; &rarr; int</td>
<td>Compares two sequences using the given comparison function, element by element.</td>
</tr>
<tr>
<td>concat : seq&lt;'Collection&gt; &rarr; seq&lt;'T&gt;</td>
<td>Combines the given enumeration-of-enumerations as a single concatenated enumeration.</td>
</tr>
<tr>
<td>countBy : ('T &rarr; 'Key) &rarr; seq&lt;'T&gt; &rarr; seq&lt;'Key * int&gt;</td>
<td>Applies a key-generating function to each element of a sequence and return a sequence yielding unique keys and their number of occurrences in the original sequence.</td>
</tr>
<tr>
<td>delay : (unit &rarr; seq&lt;'T&gt;) &rarr; seq&lt;'T&gt;</td>
<td>Returns a sequence that is built from the given delayed specification of a sequence.</td>
</tr>
<tr>
<td>distinct : seq&lt;'T&gt; &rarr; seq&lt;'T&gt;</td>
<td>Returns a sequence that contains no duplicate entries according to generic hash and equality comparisons on the entries. If an element occurs multiple times in the sequence then the later occurrences are discarded.</td>
</tr>
<tr>
<td>distinctBy : ('T &rarr; 'Key) &rarr; seq&lt;'T&gt; &rarr; seq&lt;'T&gt;</td>
<td>Returns a sequence that contains no duplicate entries according to the generic hash and equality comparisons on the keys returned by the given key-generating function. If an element occurs multiple times in the sequence then the later occurrences are discarded.</td>
</tr>
<tr>
<td>empty : seq&lt;'T&gt;</td>
<td>Creates an empty sequence.</td>
</tr>
<tr>
<td>exactlyOne : seq&lt;'T&gt; &rarr; 'T</td>
<td>Returns the only element of the sequence.</td>
</tr>
<tr>
<td>exists : ('T &rarr; bool) &rarr; seq&lt;'T&gt; &rarr; bool</td>
<td>Tests if any element of the sequence satisfies the given predicate.</td>
</tr>
<tr>
<td>exists2 : ('T1 &rarr; 'T2 &rarr; bool) &rarr; seq&lt;'T1&gt; &rarr; seq&lt;'T2&gt; &rarr; bool</td>
<td>Tests if any pair of corresponding elements of the input sequences satisfies the given predicate.</td>
</tr>
<tr>
<td>filter : ('T &rarr; bool) &rarr; seq&lt;'T&gt; &rarr; seq&lt;'T&gt;</td>
<td>Returns a new collection containing only the elements of the collection for which the given predicate returns <b>true</b>.</td>
</tr>
<tr>
<td>find : ('T &rarr; bool) &rarr; seq&lt;'T&gt; &rarr; 'T</td>
<td>Returns the first element for which the given function returns <b>true</b>.</td>
</tr>
<tr>
<td>findIndex : ('T &rarr; bool) &rarr; seq&lt;'T&gt; &rarr; int</td>
<td>Returns the index of the first element for which the given function returns <b>true</b>.</td>
</tr>
<tr>
<td>fold : ('State &rarr; 'T &rarr; 'State) &rarr; 'State &rarr; seq&lt;'T&gt; &rarr; 'State</td>
<td>Applies a function to each element of the collection, threading an accumulator argument through the computation. If the input function is f and the elements are i0...iN, then this function computes f (... (f s i0)...) iN.</td>
</tr>
<tr>
<td>forall : ('T &rarr; bool) &rarr; seq&lt;'T&gt; &rarr; bool</td>
<td>Tests if all elements of the sequence satisfy the given predicate.</td>
</tr>
<tr>
<td>forall2 : ('T1 &rarr; 'T2 &rarr; bool) &rarr; seq&lt;'T1&gt; &rarr; seq&lt;'T2&gt; &rarr; bool</td>
<td>Tests the all pairs of elements drawn from the two sequences satisfy the given predicate. If one sequence is shorter than the other then the remaining elements of the longer sequence are ignored.</td>
</tr>
<tr>
<td>groupBy : ('T &rarr; 'Key) &rarr; seq&lt;'T&gt; &rarr; seq&lt;'Key * seq&lt;'T&gt;&gt;</td>
<td>Applies a key-generating function to each element of a sequence and yields a sequence of unique keys. Each unique key has also contains a sequence of all elements that match to this key.</td>
</tr>
<tr>
<td>head : seq&lt;'T&gt; &rarr; 'T</td>
<td>Returns the first element of the sequence.</td>
</tr>
<tr>
<td>init : int &rarr; (int &rarr; 'T) &rarr; seq&lt;'T&gt;</td>
<td>Generates a new sequence which, when iterated, returns successive elements by calling the given function, up to the given count. The results of calling the function are not saved, that is, the function is reapplied as necessary to regenerate the elements. The function is passed the index of the item being generated.</td>
</tr>
<tr>
<td>initInfinite : (int &rarr; 'T) &rarr; seq&lt;'T&gt;</td>
<td>Generates a new sequence which, when iterated, will return successive elements by calling the given function. The results of calling the function are not saved, that is, the function will be reapplied as necessary to regenerate the elements. The function is passed the index of the item being generated.</td>
</tr>
<tr>
<td>isEmpty : seq&lt;'T&gt; &rarr; bool</td>
<td>Tests whether a sequence has any elements.</td>
</tr>
<tr>
<td>iter : ('T &rarr; unit) &rarr; seq&lt;'T&gt; &rarr; unit</td>
<td>Applies the given function to each element of the collection.</td>
</tr>
<tr>
<td>iter2 : ('T1 &rarr; 'T2 &rarr; unit) &rarr; seq&lt;'T1&gt; &rarr; seq&lt;'T2&gt; &rarr; unit</td>
<td>Applies the given function to two collections simultaneously. If one sequence is shorter than the other then the remaining elements of the longer sequence are ignored.</td>
</tr>
<tr>
<td>iteri : (int &rarr; 'T &rarr; unit) &rarr; seq&lt;'T&gt; &rarr; unit</td>
<td>Applies the given function to each element of the collection. The integer passed to the function indicates the index of element.</td>
</tr>
<tr>
<td>last : seq&lt;'T&gt; &rarr; 'T</td>
<td>Returns the last element of the sequence.</td>
</tr>
<tr>
<td>length : seq&lt;'T&gt; &rarr; int</td>
<td>Returns the length of the sequence.</td>
</tr>
<tr>
<td>map : ('T &rarr; 'U) &rarr; seq&lt;'T&gt; &rarr; seq&lt;'U&gt;</td>
<td>Creates a new collection whose elements are the results of applying the given function to each of the elements of the collection. The given function will be applied as elements are demanded using the MoveNext method on enumerators retrieved from the object.</td>
</tr>
<tr>
<td>map2 : ('T1 &rarr; 'T2 &rarr; 'U) &rarr; seq&lt;'T1&gt; &rarr; seq&lt;'T2&gt; &rarr; seq&lt;'U&gt;</td>
<td>Creates a new collection whose elements are the results of applying the given function to the corresponding pairs of elements from the two sequences. If one input sequence is shorter than the other then the remaining elements of the longer sequence are ignored.</td>
</tr>
<tr>
<td>mapi : (int &rarr; 'T &rarr; 'U) &rarr; seq&lt;'T&gt; &rarr; seq&lt;'U&gt;</td>
<td>Creates a new collection whose elements are the results of applying the given function to each of the elements of the collection. The integer index passed to the function indicates the index (from 0) of element being transformed.</td>
</tr>
<tr>
<td>max : seq&lt;'T&gt; &rarr; 'T</td>
<td>Returns the greatest of all elements of the sequence, compared by using Operators.max.</td>
</tr>
<tr>
<td>maxBy : ('T &rarr; 'U) &rarr; seq&lt;'T&gt; &rarr; 'T</td>
<td>Returns the greatest of all elements of the sequence, compared by using Operators.max on the function result.</td>
</tr>
<tr>
<td>min : seq&lt;'T&gt; &rarr; 'T</td>
<td>Returns the lowest of all elements of the sequence, compared by using Operators.min.</td>
</tr>
<tr>
<td>minBy : ('T &rarr; 'U) &rarr; seq&lt;'T&gt; &rarr; 'T</td>
<td>Returns the lowest of all elements of the sequence, compared by using Operators.min on the function result.</td>
</tr>
<tr>
<td>nth : int &rarr; seq&lt;'T&gt; &rarr; 'T</td>
<td>Computes the <i>nth</i> element in the collection.</td>
</tr>
<tr>
<td>ofArray : 'T array &rarr; seq&lt;'T&gt;</td>
<td>Views the given array as a sequence.</td>
</tr>
<tr>
<td>ofList : 'T list &rarr; seq&lt;'T&gt;</td>
<td>Views the given list as a sequence.</td>
</tr>
<tr>
<td>pairwise : seq&lt;'T&gt; &rarr; seq&lt;'T * 'T&gt;</td>
<td>Returns a sequence of each element in the input sequence and its predecessor, with the exception of the first element which is only returned as the predecessor of the second element.</td>
</tr>
<tr>
<td>pick : ('T &rarr; 'U option) &rarr; seq&lt;'T&gt; &rarr; 'U</td>
<td>Applies the given function to successive elements, returning the first value where the function returns a <b>Some</b> value.</td>
</tr>
<tr>
<td>readonly : seq&lt;'T&gt; &rarr; seq&lt;'T&gt;</td>
<td>Creates a new sequence object that delegates to the given sequence object. This ensures the original sequence cannot be rediscovered and mutated by a type cast. For example, if given an array the returned sequence will return the elements of the array, but you cannot cast the returned sequence object to an array.</td>
</tr>
<tr>
<td>reduce : ('T &rarr; 'T &rarr; 'T) &rarr; seq&lt;'T&gt; &rarr; 'T</td>
<td>Applies a function to each element of the sequence, threading an accumulator argument through the computation. Begin by applying the function to the first two elements. Then feed this result into the function along with the third element and so on. Return the final result.</td>
</tr>
<tr>
<td>scan : ('State &rarr; 'T &rarr; 'State) &rarr; 'State &rarr; seq&lt;'T&gt; &rarr; seq&lt;'State&gt;</td>
<td>Like Seq.fold, but computes on-demand and returns the sequence of intermediary and final results.</td>
</tr>
<tr>
<td>singleton : 'T &rarr; seq&lt;'T&gt;</td>
<td>Returns a sequence that yields one item only.</td>
</tr>
<tr>
<td>skip : int &rarr; seq&lt;'T&gt; &rarr; seq&lt;'T&gt;</td>
<td>Returns a sequence that skips a specified number of elements of the underlying sequence and then yields the remaining elements of the sequence.</td>
</tr>
<tr>
<td>skipWhile : ('T &rarr; bool) &rarr; seq&lt;'T&gt; &rarr; seq&lt;'T&gt;</td>
<td>Returns a sequence that, when iterated, skips elements of the underlying sequence while the given predicate returns <b>true,</b> and then yields the remaining elements of the sequence.</td>
</tr>
<tr>
<td>sort : seq&lt;'T&gt; &rarr; seq&lt;'T&gt;</td>
<td>Yields a sequence ordered by keys.</td>
</tr>
<tr>
<td>sortBy : ('T &rarr; 'Key) &rarr; seq&lt;'T&gt; &rarr; seq&lt;'T&gt;</td>
<td>Applies a key-generating function to each element of a sequence and yield a sequence ordered by keys. The keys are compared using generic comparison as implemented by Operators.compare.</td>
</tr>
<tr>
<td>sum : seq&lt;^T&gt; &rarr; ^T</td>
<td>Returns the sum of the elements in the sequence.</td>
</tr>
<tr>
<td>sumBy</td>
<td>Returns the sum of the results generated by applying the function to each element of the sequence.</td>
</tr>
<tr>
<td>take : int &rarr; seq&lt;'T&gt; &rarr; seq&lt;'T&gt;</td>
<td>Returns the first elements of the sequence up to a specified count.</td>
</tr>
<tr>
<td>takeWhile : ('T &rarr; bool) &rarr; seq&lt;'T&gt; &rarr; seq&lt;'T&gt;</td>
<td>Returns a sequence that, when iterated, yields elements of the underlying sequence while the given predicate returns <b>true,</b> and then returns no further elements.</td>
</tr>
<tr>
<td>toArray : seq&lt;'T&gt; &rarr; 'T[]</td>
<td>Creates an array from the given collection.</td>
</tr>
<tr>
<td>toList : seq&lt;'T&gt; &rarr; 'T list</td>
<td>Creates a list from the given collection.</td>
</tr>
<tr>
<td>truncate : int &rarr; seq&lt;'T&gt; &rarr; seq&lt;'T&gt;</td>
<td>Returns a sequence that when enumerated returns no more than a specified number of elements.</td>
</tr>
<tr>
<td>tryFind : ('T &rarr; bool) &rarr; seq&lt;'T&gt; &rarr; 'T option</td>
<td>Returns the first element for which the given function returns <b>true,</b> or <b>None</b> if no such element exists.</td>
</tr>
<tr>
<td>tryFindIndex : ('T &rarr; bool) &rarr; seq&lt;'T&gt; &rarr; int option</td>
<td>Returns the index of the first element in the sequence that satisfies the given predicate, or <b>None</b> if no such element exists.</td>
</tr>
<tr>
<td>tryPick : ('T &rarr; 'U option) &rarr; seq&lt;'T&gt; &rarr; 'U option</td>
<td>Applies the given function to successive elements, returning the first value where the function returns a <b>Some</b> value.</td>
</tr>
<tr>
<td>unfold : ('State &rarr; 'T * 'State option) &rarr; 'State &rarr; seq&lt;'T&gt;</td>
<td>Returns a sequence that contains the elements generated by the given computation.</td>
</tr>
<tr>
<td>where : ('T &rarr; bool) &rarr; seq&lt;'T&gt; &rarr; seq&lt;'T&gt;</td>
<td>Returns a new collection containing only the elements of the collection for which the given predicate returns <b>true</b>. A synonym for Seq.filter.</td>
</tr>
<tr>
<td>windowed : int &rarr; seq&lt;'T&gt; &rarr; seq&lt;'T []&gt;</td>
<td>Returns a sequence that yields sliding windows of containing elements drawn from the input sequence. Each window is returned as a fresh array.</td>
</tr>
<tr>
<td>zip : seq&lt;'T1&gt; &rarr; seq&lt;'T2&gt; &rarr; seq&lt;'T1 * 'T2&gt;</td>
<td>Combines the two sequences into a list of pairs. The two sequences need not have equal lengths &minus; when one sequence is exhausted any remaining elements in the other sequence are ignored.</td>
</tr>
<tr>
<td>zip3 : seq&lt;'T1&gt; &rarr; seq&lt;'T2&gt; &rarr; seq&lt;'T3&gt; &rarr; seq&lt;'T1 * 'T2 * 'T3&gt;</td>
<td>Combines the three sequences into a list of triples. The sequences need not have equal lengths &minus; when one sequence is exhausted any remaining elements in the other sequences are ignored.</td>
</tr>
</table>
<p>The following examples demonstrate the uses of some of the above functionalities &minus;</p>
<h3>Example 1</h3>
<p>This program creates an empty sequence and fills it up later &minus;</p>
<pre class="prettyprint notranslate tryit">
(* Creating sequences *)
let emptySeq = Seq.empty
let seq1 = Seq.singleton 20

printfn"The singleton sequence:"
printfn "%A " seq1
printfn"The init sequence:"

let seq2 = Seq.init 5 (fun n -&gt; n * 3)
Seq.iter (fun i -&gt; printf "%d " i) seq2
printfn""

(* converting an array to sequence by using cast *)
printfn"The array sequence 1:"
let seq3 = [| 1 .. 10 |] :> seq&lt;int&gt;
Seq.iter (fun i -&gt; printf "%d " i) seq3
printfn""

(* converting an array to sequence by using Seq.ofArray *)
printfn"The array sequence 2:"
let seq4 = [| 2..2.. 20 |] |> Seq.ofArray
Seq.iter (fun i -&gt; printf "%d " i) seq4
printfn""
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
The singleton sequence:
seq [20]
The init sequence:
0 3 6 9 12
The array sequence 1:
1 2 3 4 5 6 7 8 9 10
The array sequence 2:
2 4 6 8 10 12 14 16 18 20
</pre>
<p>Please note that &minus;</p>
<ul class="list">
<li><p>The Seq.empty method creates an empty sequence.</p></li>
<li><p>The Seq.singleton method creates a sequence of just one specified element.</p></li>
<li><p>The Seq.init method creates a sequence for which the elements are created by using a given function.</p></li>
<li><p>The Seq.ofArray and Seq.ofList&lt;'T&gt; methods create sequences from arrays and lists.</p></li>
<li><p>The Seq.iter method allows iterating through a sequence.</p></li>
</ul>
<h3>Example 2</h3>
<p>The Seq.unfold method generates a sequence from a computation function that takes a state and transforms it to produce each subsequent element in the sequence.</p>
<p>The following function produces the first 20 natural numbers &minus;</p>
<pre class="prettyprint notranslate tryit">
let seq1 = Seq.unfold (fun state -&gt; if (state &gt; 20) then None else Some(state, state + 1)) 0
printfn "The sequence seq1 contains numbers from 0 to 20."
for x in seq1 do printf "%d " x
printfn" "
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
The sequence seq1 contains numbers from 0 to 20.
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
</pre>
<h3>Example 3</h3>
<p>The Seq.truncate method creates a sequence from another sequence, but limits the sequence to a specified number of elements.</p>
<p>The Seq.take method creates a new sequence that contains a specified number of elements from the start of a sequence.</p>
<pre class="prettyprint notranslate tryit">
let mySeq = seq { for i in 1 .. 10 -&gt; 3*i }
let truncatedSeq = Seq.truncate 5 mySeq
let takeSeq = Seq.take 5 mySeq

printfn"The original sequence"
Seq.iter (fun i -&gt; printf "%d " i) mySeq
printfn""

printfn"The truncated sequence"
Seq.iter (fun i -&gt; printf "%d " i) truncatedSeq
printfn""

printfn"The take sequence"
Seq.iter (fun i -&gt; printf "%d " i) takeSeq
printfn""
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
The original sequence
3 6 9 12 15 18 21 24 27 30
The truncated sequence
3 6 9 12 15
The take sequence
3 6 9 12 15
</pre>

<title>F# Sets</title>

<h1>F# - Sets</h1>

<p>A set in F# is a data structure that acts as a collection of items without preserving the order in which items are inserted. Sets do not allow duplicate entries to be inserted into the collection.</p>

<h2>Creating Sets</h2>

<p>Sets can be created in the following ways &minus;</p>

<p>The following program demonstrates the techniques &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Basic Operations on Sets</h2>

<p>The following table shows the basic operations on sets &minus;</p>

<p>The following example demonstrates the uses of some of the above functionalities &minus;</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate tryit">
(* creating sets *)
let set1 = Set.empty.Add(3).Add(5).Add(7). Add(9)
printfn"The new set: %A" set1

let weekdays = Set.ofList ["mon"; "tues"; "wed"; "thurs"; "fri"]
printfn "The list set: %A" weekdays

let set2 = Set.ofSeq [ 1 .. 2.. 10 ]
printfn "The sequence set: %A" set2
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
The new set: set [3; 5; 7; 9]
The list set: set ["fri"; "mon"; "thurs"; "tues"; "wed"]
The sequence set: set [1; 3; 5; 7; 9]
</pre>
<h2>Basic Operations on Sets</h2>
<p>The following table shows the basic operations on sets &minus;</p>
<table class="table table-bordered">
<tr>
<th style="width:48%;">Value</th>
<th>Description</th>
</tr>
<tr>
<td>add : 'T &rarr; Set&lt;'T&gt; &rarr; Set&lt;'T&gt;</td>
<td>Returns a new set with an element added to the set. No exception is raised if the set already contains the given element.</td>
</tr>
<tr>
<td>contains : 'T &rarr; Set&lt;'T&gt; &rarr; bool</td>
<td>Evaluates to <b>true</b> if the given element is in the given set.</td>
</tr>
<tr>
<td>count : Set&lt;'T&gt; &rarr; int</td>
<td>Returns the number of elements in the set.</td>
</tr>
<tr>
<td>difference : Set&lt;'T&gt; &rarr; Set&lt;'T&gt; &rarr; Set&lt;'T&gt;</td>
<td>Returns a new set with the elements of the second set removed from the first.</td>
</tr>
<tr>
<td>empty : Set&lt;'T&gt;</td>
<td>The empty set for the specified type.</td>
</tr>
<tr>
<td>exists : ('T &rarr; bool) &rarr; Set&lt;'T&gt; &rarr; bool</td>
<td>Tests if any element of the collection satisfies the given predicate. If the input function is predicate and the elements are i0...iN, then this function computes predicate i0 or ... or predicate iN.</td>
</tr>
<tr>
<td>filter : ('T &rarr; bool) &rarr; Set&lt;'T&gt; &rarr; Set&lt;'T&gt;</td>
<td>Returns a new collection containing only the elements of the collection for which the given predicate returns <b>true</b>.</td>
</tr>
<tr>
<td>fold : ('State &rarr; 'T &rarr; 'State) &rarr; 'State &rarr; Set&lt;'T&gt; &rarr; 'State</td>
<td>Applies the given accumulating function to all the elements of the set.</td>
</tr>
<tr>
<td>foldBack : ('T &rarr; 'State &rarr; 'State) &rarr; Set&lt;'T&gt; &rarr; 'State &rarr; 'State</td>
<td>Applies the given accumulating function to all the elements of the set.</td>
</tr>
<tr>
<td>forall : ('T &rarr; bool) &rarr; Set&lt;'T&gt; &rarr; bool</td>
<td>Tests if all elements of the collection satisfy the given predicate. If the input function is p and the elements are i0...iN, then this function computes p i0 && ... && p iN.</td>
</tr>
<tr>
<td>intersect : Set&lt;'T&gt; &rarr; Set&lt;'T&gt; &rarr; Set&lt;'T&gt;</td>
<td>Computes the intersection of the two sets.</td>
</tr>
<tr>
<td>intersectMany : seq&lt;Set&lt;'T&gt;&gt; &rarr; Set&lt;'T&gt;</td>
<td>Computes the intersection of a sequence of sets. The sequence must be non-empty.</td>
</tr>
<tr>
<td>isEmpty : Set&lt;'T&gt; &rarr; bool</td>
<td>Returns <b>true</b> if the set is empty.</td>
</tr>
<tr>
<td>isProperSubset : Set&lt;'T&gt; &rarr; Set&lt;'T&gt; &rarr; bool</td>
<td>Evaluates to <b>true</b> if all elements of the first set are in the second, and at least one element of the second is not in the first.</td>
</tr>
<tr>
<td>isProperSuperset : Set&lt;'T&gt; &rarr; Set&lt;'T&gt; &rarr; bool</td>
<td>Evaluates to <b>true</b> if all elements of the second set are in the first, and at least one element of the first is not in the second.</td>
</tr>
<tr>
<td>isSubset : Set&lt;'T&gt; &rarr; Set&lt;'T&gt; &rarr; bool</td>
<td>Evaluates to <b>true</b> if all elements of the first set are in the second.</td>
</tr>
<tr>
<td>isSuperset : Set&lt;'T&gt; &rarr; Set&lt;'T&gt; &rarr; bool</td>
<td>Evaluates to <b>true</b> if all elements of the second set are in the first.</td>
</tr>
<tr>
<td>iter : ('T &rarr; unit) &rarr; Set&lt;'T&gt; &rarr; unit</td>
<td>Applies the given function to each element of the set, in order according to the comparison function.</td>
</tr>
<tr>
<td>map : ('T &rarr; 'U) &rarr; Set&lt;'T&gt; &rarr; Set&lt;'U&gt;</td>
<td>Returns a new collection containing the results of applying the given function to each element of the input set.</td>
</tr>
<tr>
<td>maxElement : Set&lt;'T&gt; &rarr; 'T</td>
<td>Returns the highest element in the set according to the ordering being used for the set.</td>
</tr>
<tr>
<td>minElement : Set&lt;'T&gt; &rarr; 'T</td>
<td>Returns the lowest element in the set according to the ordering being used for the set.</td>
</tr>
<tr>
<td>ofArray : 'T array &rarr; Set&lt;'T&gt;</td>
<td>Creates a set that contains the same elements as the given array.</td>
</tr>
<tr>
<td>ofList : 'T list &rarr; Set&lt;'T&gt;</td>
<td>Creates a set that contains the same elements as the given list.</td>
</tr>
<tr>
<td>ofSeq : seq&lt;'T&gt; &rarr; Set&lt;'T&gt;</td>
<td>Creates a new collection from the given enumerable object.</td>
</tr>
<tr>
<td>partition : ('T &rarr; bool) &rarr; Set&lt;'T&gt; &rarr; Set&lt;'T&gt; * Set&lt;'T&gt;</td>
<td>Splits the set into two sets containing the elements for which the given predicate returns true and false respectively.</td>
</tr>
<tr>
<td>remove : 'T &rarr; Set&lt;'T&gt; &rarr; Set&lt;'T&gt;</td>
<td>Returns a new set with the given element removed. No exception is raised if the set doesn't contain the given element.</td>
</tr>
<tr>
<td>singleton : 'T &rarr; Set&lt;'T&gt;</td>
<td>The set containing the given element.</td>
</tr>
<tr>
<td>toArray : Set&lt;'T&gt; &rarr; 'T array</td>
<td>Creates an array that contains the elements of the set in order.</td>
</tr>
<tr>
<td>toList : Set&lt;'T&gt; &rarr; 'T list</td>
<td>Creates a list that contains the elements of the set in order.</td>
</tr>
<tr>
<td>toSeq : Set&lt;'T&gt; &rarr; seq&lt;'T&gt;</td>
<td>Returns an ordered view of the collection as an enumerable object.</td>
</tr>
<tr>
<td>union : Set&lt;'T&gt; &rarr; Set&lt;'T&gt; &rarr; Set&lt;'T&gt;</td>
<td>Computes the union of the two sets.</td>
</tr>
<tr>
<td>unionMany : seq&lt;Set&lt;'T&gt;&gt; &rarr; Set&lt;'T&gt;</td>
<td>Computes the union of a sequence of sets.</td>
</tr>
</table>
<p>The following example demonstrates the uses of some of the above functionalities &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
let a = Set.ofSeq [ 1 ..2.. 20 ]
let b = Set.ofSeq [ 1 ..3 .. 20 ]
let c = Set.intersect a b
let d = Set.union a b
let e = Set.difference a b

printfn "Set a: "
Set.iter (fun x -> printf "%O " x) a
printfn""

printfn "Set b: "
Set.iter (fun x -> printf "%O " x) b
printfn""

printfn "Set c = set intersect of a and b : "
Set.iter (fun x -> printf "%O " x) c
printfn""

printfn "Set d = set union of a and b : "
Set.iter (fun x -> printf "%O " x) d
printfn""

printfn "Set e = set difference of a and b : "
Set.iter (fun x -> printf "%O " x) e
printfn""
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Set a:
1 3 5 7 9 11 13 15 17 19
Set b:
1 4 7 10 13 16 19
Set c = set intersect of a and b :
1 7 13 19
Set d = set union of a and b :
1 3 4 5 7 9 10 11 13 15 16 17 19
Set e = set difference of a and b :
3 5 9 11 15 17
</pre>

<title>F# Maps</title>

<h1>F# - Maps</h1>

<p>In F#, a map is a special kind of set that associates the values with key. A map is created in a similar way as sets are created.</p>

<h2>Creating Maps</h2>

<p>Maps are created by creating an empty map using Map.empty and adding items using the Add function. The following example demonstrates this &minus;</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>You can access individual elements in the map using the key.</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Basic Operations on Maps</h2>

<h3>Add module name</h3>

<p>The following table shows the basic operations on maps &minus;</p>

<p>The following example demonstrates the uses of some of the above functionalities &minus;</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate tryit">
(* Create an empty Map *)
let students =
   Map.empty. (* Creating an empty Map *)
      Add("Zara Ali", "1501").
      Add("Rishita Gupta", "1502").
      Add("Robin Sahoo", "1503").
      Add("Gillian Megan", "1504");;
printfn "Map - students: %A" students

(* Convert a list to Map *)
let capitals =
   [ "Argentina", "Buenos Aires";
      "France ", "Paris";
      "Chili", "Santiago";
      "Malaysia", " Kuala Lumpur";
      "Switzerland", "Bern" ]
   |> Map.ofList;;
printfn "Map capitals : %A" capitals
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Map - students: map
[("Gillian Megan", "1504"); ("Rishita Gupta", "1502"); ("Robin Sahoo", "1503
");
("Zara Ali", "1501")]
Map capitals : map
[("Argentina", "Buenos Aires"); ("Chili", "Santiago"); ("France ", "Paris");
("Malaysia", " Kuala Lumpur"); ("Switzerland", "Bern")]
</pre>
<p>You can access individual elements in the map using the key.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
(* Create an empty Map *)
let students =
   Map.empty. (* Creating an empty Map *)
      Add("Zara Ali", "1501").
      Add("Rishita Gupta", "1502").
      Add("Robin Sahoo", "1503").
      Add("Gillian Megan", "1504");;
printfn "Map - students: %A" students

(*Accessing an element using key *)
printfn "%A" students.["Zara Ali"]
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Map - students: map
[("Gillian Megan", "1504"); ("Rishita Gupta", "1502"); ("Robin Sahoo", "1503
");
("Zara Ali", "1501")]
"1501"
</pre>
<h2>Basic Operations on Maps</h2>
<h3>Add module name</h3>
<p>The following table shows the basic operations on maps &minus;</p>
<table class="table table-bordered">
<tr>
<th>Member</th>
<th>Description</th>
</tr>
<tr>
<td>Add</td>
<td>Returns a new map with the binding added to the given map.</td>
</tr>
<tr>
<td>ContainsKey</td>
<td>Tests if an element is in the domain of the map.</td>
</tr>
<tr>
<td>Count</td>
<td>The number of bindings in the map.</td>
</tr>
<tr>
<td>IsEmpty</td>
<td>Returns true if there are no bindings in the map.</td>
</tr>
<tr>
<td>Item</td>
<td>Lookup an element in the map. Raises KeyNotFoundException if no binding exists in the map.</td>
</tr>
<tr>
<td>Remove</td>
<td>Removes an element from the domain of the map. No exception is raised if the element is not present.</td>
</tr>
<tr>
<td>TryFind</td>
<td>Lookup an element in the map, returning a <b>Some</b> value if the element is in the domain of the map and <b>None</b> if not.</td>
</tr>
</table>
<p>The following example demonstrates the uses of some of the above functionalities &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
(* Create an empty Map *)
let students =
   Map.empty. (* Creating an empty Map *)
      Add("Zara Ali", "1501").
      Add("Rishita Gupta", "1502").
      Add("Robin Sahoo", "1503").
      Add("Gillian Megan", "1504").
      Add("Shraddha Dubey", "1505").
      Add("Novonil Sarker", "1506").
      Add("Joan Paul", "1507");;
printfn "Map - students: %A" students
printfn "Map - number of students: %d" students.Count

(* finding the registration number of a student*)
let found = students.TryFind "Rishita Gupta"
match found with
| Some x -> printfn "Found %s." x
| None -> printfn "Did not find the specified value."
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Map - students: map
[("Gillian Megan", "1504"); ("Joan Paul", "1507"); ("Novonil Sarker", "1506"
);
("Rishita Gupta", "1502"); ("Robin Sahoo", "1503");
("Shraddha Dubey", "1505"); ("Zara Ali", "1501")]
Map - number of students: 7
Found 1502.
</pre>

<title>F# Discriminated Unions</title>

<h1>F# - Discriminated Unions</h1>

<p>Unions, or discriminated unions allows you to build up complex data structures representing well-defined set of choices. For example, you need to build an implementation of a <i>choice</i> variable, which has two values yes and no. Using the Unions tool, you can design this.</p>

<h2>Syntax</h2>

<p>Discriminated unions are defined using the following syntax &minus;</p>

<p>Our simple implementation of ,<i>choice,</i> will look like the following &minus;</p>

<p>The following example uses the type choice &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Example 1</h2>

<p>The following example shows the implementation of the voltage states that sets a bit on high or low &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Example 2</h2>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
type type-name =
   | case-identifier1 [of [ fieldname1 : ] type1 [ * [ fieldname2 : ] 
type2 ...]
   | case-identifier2 [of [fieldname3 : ]type3 [ * [ fieldname4 : ]type4 ...]
...
</pre>
<p>Our simple implementation of ,<i>choice,</i> will look like the following &minus;</p>
<pre class="result notranslate">
type choice =
   | Yes
   | No
</pre>
<p>The following example uses the type choice &minus;</p>
<pre class="prettyprint notranslate tryit">
type choice =
   | Yes
   | No

let x = Yes (* creates an instance of choice *)
let y = No (* creates another instance of choice *)
let main() =
   printfn "x: %A" x
   printfn "y: %A" y
main()
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
x: Yes
y: No
</pre>
<h2>Example 1</h2>
<p>The following example shows the implementation of the voltage states that sets a bit on high or low &minus;</p>
<pre class="prettyprint notranslate tryit">
type VoltageState =
   | High
   | Low

let toggleSwitch = function (* pattern matching input *)
   | High -> Low
   | Low -> High

let main() =
   let on = High
   let off = Low
   let change = toggleSwitch off

   printfn "Switch on state: %A" on
   printfn "Switch off state: %A" off
   printfn "Toggle off: %A" change
   printfn "Toggle the Changed state: %A" (toggleSwitch change)

main()
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Switch on state: High
Switch off state: Low
Toggle off: High
Toggle the Changed state: Low
</pre>
<h2>Example 2</h2>
<pre class="prettyprint notranslate tryit">
type Shape =
   // here we store the radius of a circle
   | Circle of float

   // here we store the side length.
   | Square of float

   // here we store the height and width.
   | Rectangle of float * float

let pi = 3.141592654

let area myShape =
   match myShape with
   | Circle radius -&gt; pi * radius * radius
   | Square s -&gt; s * s
   | Rectangle (h, w) -&gt; h * w

let radius = 12.0
let myCircle = Circle(radius)
printfn "Area of circle with radius %g: %g" radius (area myCircle)

let side = 15.0
let mySquare = Square(side)
printfn "Area of square that has side %g: %g" side (area mySquare)

let height, width = 5.0, 8.0
let myRectangle = Rectangle(height, width)
printfn "Area of rectangle with height %g and width %g is %g" height width (area myRectangle)
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Area of circle with radius 12: 452.389
Area of square that has side 15: 225
Area of rectangle with height 5 and width 8 is 40
</pre>

<title>F# Mutable Data</title>

<h1>F# - Mutable Data</h1>

<p>Variables in F# are <b>immutable,</b> which means once a variable is bound to a value, it can’t be changed. They are actually compiled as static read-only properties.</p>

<p>The following example demonstrates this.</p>

<h2>Example</h2>

<p>When you compile and execute the program, it shows the following error message &minus;</p>

<h2>Mutable Variables</h2>

<p>At times you need to change the values stored in a variable. To specify that there could be a change in the value of a declared and assigned variable in later part of a program, F# provides the <b>mutable</b> keyword. You can declare and assign mutable variables using this keyword, whose values you will change.</p>

<p>The <b>mutable</b> keyword allows you to declare and assign values in a mutable variable.</p>

<p>You can assign some initial value to a mutable variable using the <b>let</b> keyword. However, to assign new subsequent value to it, you need to use the <b>&lt;-</b> operator.</p>

<p>For example,</p>

<p>The following example will clear the concept &minus;</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Uses of Mutable Data</h2>

<p>Mutable data is often required and used in data processing, particularly with record data structure. The following example demonstrates this &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate tryit">
let x = 10
let y = 20
let z = x + y

printfn "x: %i" x
printfn "y: %i" y
printfn "z: %i" z

let x = 15
let y = 20
let z = x + y

printfn "x: %i" x
printfn "y: %i" y
printfn "z: %i" z
</pre>
<p>When you compile and execute the program, it shows the following error message &minus;</p>
<pre class="result notranslate">
Duplicate definition of value 'x'
Duplicate definition of value 'Y'
Duplicate definition of value 'Z'
</pre>
<h2>Mutable Variables</h2>
<p>At times you need to change the values stored in a variable. To specify that there could be a change in the value of a declared and assigned variable in later part of a program, F# provides the <b>mutable</b> keyword. You can declare and assign mutable variables using this keyword, whose values you will change.</p>
<p>The <b>mutable</b> keyword allows you to declare and assign values in a mutable variable.</p>
<p>You can assign some initial value to a mutable variable using the <b>let</b> keyword. However, to assign new subsequent value to it, you need to use the <b>&lt;-</b> operator.</p>
<p>For example,</p>
<pre class="result notranslate">
let mutable x = 10
x &lt;- 15
</pre>
<p>The following example will clear the concept &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
let mutable x = 10
let y = 20
let mutable z = x + y

printfn "Original Values:"
printfn "x: %i" x
printfn "y: %i" y
printfn "z: %i" z

printfn "Let us change the value of x"
printfn "Value of z will change too."

x &lt;- 15
z &lt;- x + y

printfn "New Values:"
printfn "x: %i" x
printfn "y: %i" y
printfn "z: %i" z
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Original Values:
x: 10
y: 20
z: 30
Let us change the value of x
Value of z will change too.
New Values:
x: 15
y: 20
z: 35
</pre>
<h2>Uses of Mutable Data</h2>
<p>Mutable data is often required and used in data processing, particularly with record data structure. The following example demonstrates this &minus;</p>
<pre class="prettyprint notranslate tryit">
open System

type studentData =
   { ID : int;
      mutable IsRegistered : bool;
      mutable RegisteredText : string; }

let getStudent id =
   { ID = id;
      IsRegistered = false;
      RegisteredText = null; }

let registerStudents (students : studentData list) =
   students |> List.iter(fun st -&gt;
      st.IsRegistered &lt;- true
      st.RegisteredText &lt;- sprintf "Registered %s" (DateTime.Now.ToString("hh:mm:ss"))

      Threading.Thread.Sleep(1000) (* Putting thread to sleep for 1 second to simulate processing overhead. *))

let printData (students : studentData list) =
   students |> List.iter (fun x -&gt; printfn "%A" x)

let main() =
   let students = List.init 3 getStudent

   printfn "Before Process:"
   printData students

   printfn "After process:"
   registerStudents students
   printData students

   Console.ReadKey(true) |> ignore

main()
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Before Process:
{ID = 0;
IsRegistered = false;
RegisteredText = null;}
{ID = 1;
IsRegistered = false;
RegisteredText = null;}
{ID = 2;
IsRegistered = false;
RegisteredText = null;}
After process:
{ID = 0;
IsRegistered = true;
RegisteredText = "Registered 05:39:15";}
{ID = 1;
IsRegistered = true;
RegisteredText = "Registered 05:39:16";}
{ID = 2;
IsRegistered = true;
RegisteredText = "Registered 05:39:17";}
</pre>

<title>F# Arrays</title>

<h1>F# - Arrays</h1>

<p>Arrays are fixed-size, zero-based, mutable collections of consecutive data elements that are all of the same type.</p>

<h2>Creating Arrays</h2>

<p>You can create arrays using various syntaxes and ways or by using the functions from the Array module. In this section, we will discuss creating arrays without using the module functions.</p>

<p>There are three syntactical ways of creating arrays without functions &minus;</p>

<p>You can access array elements by using a dot operator (.) and brackets ([ and ]).</p>

<p>The following example demonstrates creating arrays &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Basic Operations on Arrays</h2>

<p>The library module Microsoft.FSharp.Collections.Array supports operations on one-dimensional arrays.</p>

<p>The following table shows the basic operations on Arrays &minus;</p>

<p>In the following section, we will see the uses of some of these functionalities.</p>

<h2>Creating Arrays Using Functions</h2>

<p>The Array module provides several functions that create an array from scratch.</p>

<p>The <b>Array.empty</b> function creates a new empty array.</p>

<p>The <b>Array.create</b> function creates an array of a specified size and sets all the elements to given values.</p>

<p>The <b>Array.init</b> function creates an array, given a dimension and a function to generate the elements.</p>

<p>The <b>Array.zeroCreate</b> function creates an array in which all the elements are initialized to the zero value.</p>

<p>The <b>Array.copy</b> function creates a new array that contains elements that are copied from an existing array.</p>

<p>The <b>Array.sub</b> function generates a new array from a subrange of an array.</p>

<p>The <b>Array.append</b> function creates a new array by combining two existing arrays.</p>

<p>The <b>Array.choose</b> function selects elements of an array to include in a new array.</p>

<p>The <b>Array.collect</b> function runs a specified function on each array element of an existing array and then collects the elements generated by the function and combines them into a new array.</p>

<p>The <b>Array.concat</b> function takes a sequence of arrays and combines them into a single array.</p>

<p>The <b>Array.filter</b> function takes a Boolean condition function and generates a new array that contains only those elements from the input array for which the condition is true.</p>

<p>The <b>Array.rev</b> function generates a new array by reversing the order of an existing array.</p>

<p>The following examples demonstrate these functions &minus;</p>

<h3>Example 1</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h3>Example 2</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Searching Arrays</h2>

<p>The <b>Array.find</b> function takes a Boolean function and returns the first element for which the function returns true, else raises a KeyNotFoundException.</p>

<p>The <b>Array.findIndex</b> function works similarly except that it returns the index of the element instead of the element itself.</p>

<p>The following example demonstrates this.</p>

<p>Microsoft provides this interesting program example, which finds the first element in the range of a given number that is both a perfect square as well as a perfect cube &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate tryit">
//using semicolon separator
let array1 = [| 1; 2; 3; 4; 5; 6 |]
for i in 0 .. array1.Length - 1 do
   printf "%d " array1.[i]
printfn" "

// without semicolon separator
let array2 =
   [|
      1
      2
      3
      4
      5
   |]
for i in 0 .. array2.Length - 1 do
   printf "%d " array2.[i]
printfn" "

//using sequence
let array3 = [| for i in 1 .. 10 -> i * i |]
for i in 0 .. array3.Length - 1 do
   printf "%d " array3.[i]
printfn" "
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
1 2 3 4 5 6
1 2 3 4 5
1 4 9 16 25 36 49 64 81 100
</pre>
<h2>Basic Operations on Arrays</h2>
<p>The library module Microsoft.FSharp.Collections.Array supports operations on one-dimensional arrays.</p>
<p>The following table shows the basic operations on Arrays &minus;</p>
<table class="table table-bordered">
<tr>
<th style="width:48%;">Value</th>
<th>Description</th>
</tr>
<tr>
<td>append : 'T [] &rarr; 'T [] &rarr; 'T []</td>
<td>Creates an array that contains the elements of one array followed by the elements of another array.</td>
</tr>
<tr>
<td>average : ^T [] &rarr; ^T</td>
<td>Returns the average of the elements in an array.</td>
</tr>
<tr>
<td>averageBy : ('T &rarr; ^U) &rarr; 'T [] &rarr; ^U</td>
<td>Returns the average of the elements generated by applying a function to each element of an array.</td>
</tr>
<tr>
<td>blit : 'T [] &rarr; int &rarr; 'T [] &rarr; int &rarr; int &rarr; unit</td>
<td>Reads a range of elements from one array and writes them into another.</td>
</tr>
<tr>
<td>choose : ('T &rarr; U option) &rarr; 'T [] &rarr; 'U []</td>
<td>Applies a supplied function to each element of an array. Returns an array that contains the results x for each element for which the function returns Some(x).</td>
</tr>
<tr>
<td>collect : ('T &rarr; 'U []) &rarr; T [] &rarr; 'U []</td>
<td>Applies the supplied function to each element of an array, concatenates the results, and returns the combined array.</td>
</tr>
<tr>
<td>concat : seq&lt;'T []&gt; &rarr; 'T []</td>
<td>Creates an array that contains the elements of each of the supplied sequence of arrays.</td>
</tr>
<tr>
<td>copy : 'T &rarr; 'T []</td>
<td>Creates an array that contains the elements of the supplied array.</td>
</tr>
<tr>
<td>create : int &rarr; 'T &rarr; 'T []</td>
<td>Creates an array whose elements are all initially the supplied value.</td>
</tr>
<tr>
<td>empty : 'T []</td>
<td>Returns an empty array of the given type.</td>
</tr>
<tr>
<td>exists : ('T &rarr; bool) &rarr; 'T [] &rarr; bool</td>
<td>Tests whether any element of an array satisfies the supplied predicate.</td>
</tr>
<tr>
<td>exists2 : ('T1 &rarr; 'T2 &rarr; bool) &rarr; 'T1 [] &rarr; 'T2 [] &rarr; bool</td>
<td>Tests whether any pair of corresponding elements of two arrays satisfy the supplied condition.</td>
</tr>
<tr>
<td>fill : 'T [] &rarr; int &rarr; int &rarr; 'T &rarr; unit</td>
<td>Fills a range of elements of an array with the supplied value.</td>
</tr>
<tr>
<td>filter : ('T &rarr; bool) &rarr; 'T [] &rarr; 'T []</td>
<td>Returns a collection that contains only the elements of the supplied array for which the supplied condition returns <b>true</b>.</td>
</tr>
<tr>
<td>find : ('T &rarr; bool) &rarr; 'T [] &rarr; 'T</td>
<td>Returns the first element for which the supplied function returns <b>true</b>. Raises KeyNotFoundException if no such element exists.</td>
</tr>
<tr>
<td>findIndex : ('T &rarr; bool) &rarr; 'T [] &rarr; int</td>
<td>Returns the index of the first element in an array that satisfies the supplied condition. Raises KeyNotFoundException if none of the elements satisfy the condition.</td>
</tr>
<tr>
<td>fold : ('State &rarr; 'T &rarr; 'State) &rarr; 'State &rarr; 'T [] &rarr; 'State</td>
<td>Applies a function to each element of an array, threading an accumulator argument through the computation. If the input function is f and the array elements are i0...iN, this function computes f (...(f s i0)...) iN.</td>
</tr>
<tr>
<td>fold2 : ('State &rarr; 'T1 &rarr; 'T2 &rarr; 'State) &rarr; 'State &rarr; 'T1 [] &rarr; 'T2 [] &rarr; 'State</td>
<td>Applies a function to pairs of elements from two supplied arrays, left-to-right, threading an accumulator argument through the computation. The two input arrays must have the same lengths; otherwise, ArgumentException is raised.</td>
</tr>
<tr>
<td>foldBack : ('T &rarr; 'State &rarr; 'State) &rarr; 'T [] &rarr; 'State &rarr; 'State</td>
<td>Applies a function to each element of an array, threading an accumulator argument through the computation. If the input function is f and the array elements are i0...iN, this function computes f i0 (...(f iN s)).</td>
</tr>
<tr>
<td>foldBack2 : ('T1 &rarr; 'T2 &rarr; 'State &rarr; 'State) &rarr; 'T1 [] &rarr; 'T2 [] &rarr; 'State &rarr; 'State</td>
<td>Applies a function to pairs of elements from two supplied arrays, right-to-left, threading an accumulator argument through the computation. The two input arrays must have the same lengths; otherwise, ArgumentException is raised.</td>
</tr>
<tr>
<td>forall : ('T &rarr; bool) &rarr; 'T [] &rarr; bool</td>
<td>Tests whether all elements of an array satisfy the supplied condition.</td>
</tr>
<tr>
<td>forall2 : ('T1 &rarr; 'T2 &rarr; bool) &rarr; 'T1 [] &rarr; 'T2 [] &rarr; bool</td>
<td>Tests whether all corresponding elements of two supplied arrays satisfy a supplied condition.</td>
</tr>
<tr>
<td>get : 'T [] &rarr; int &rarr; 'T</td>
<td>Gets an element from an array.</td>
</tr>
<tr>
<td>init : int &rarr; (int &rarr; 'T) &rarr; 'T []</td>
<td>Uses a supplied function to create an array of the supplied dimension.</td>
</tr>
<tr>
<td>isEmpty : 'T [] &rarr; bool</td>
<td>Tests whether an array has any elements.</td>
</tr>
<tr>
<td>iter : ('T &rarr; unit) &rarr; 'T [] &rarr; unit</td>
<td>Applies the supplied function to each element of an array.</td>
</tr>
<tr>
<td>iter2 : ('T1 &rarr; 'T2 &rarr; unit) &rarr; 'T1 [] &rarr; 'T2 [] &rarr; unit)</td>
<td>Applies the supplied function to a pair of elements from matching indexes in two arrays. The two arrays must have the same lengths; otherwise, ArgumentException is raised.</td>
</tr>
<tr>
<td>iteri : (int &rarr; 'T &rarr; unit) &rarr; 'T [] &rarr; unit</td>
<td>Applies the supplied function to each element of an array. The integer passed to the function indicates the index of the element.</td>
</tr>
<tr>
<td>iteri2 : (int &rarr; 'T1 &rarr; 'T2 &rarr; unit) &rarr; 'T1 [] &rarr; 'T2 [] &rarr; unit</td>
<td>Applies the supplied function to a pair of elements from matching indexes in two arrays, also passing the index of the elements. The two arrays must have the same lengths; otherwise, an ArgumentException is raised.</td>
</tr>
<tr>
<td>length : 'T [] &rarr; int</td>
<td>Returns the length of an array. The Length property does the same thing.</td>
</tr>
<tr>
<td>map : ('T &rarr; 'U) &rarr; 'T [] &rarr; 'U []</td>
<td>Creates an array whose elements are the results of applying the supplied function to each of the elements of a supplied array.</td>
</tr>
<tr>
<td>map2 : ('T1 &rarr; 'T2 &rarr; 'U) &rarr; 'T1 [] &rarr; 'T2 [] &rarr; 'U []</td>
<td>Creates an array whose elements are the results of applying the supplied function to the corresponding elements of two supplied arrays. The two input arrays must have the same lengths; otherwise, ArgumentException is raised.</td>
</tr>
<tr>
<td>mapi : (int &rarr; 'T &rarr; 'U) &rarr; 'T [] &rarr; 'U []</td>
<td>Creates an array whose elements are the results of applying the supplied function to each of the elements of a supplied array. An integer index passed to the function indicates the index of the element being transformed.</td>
</tr>
<tr>
<td>mapi2 : (int &rarr; 'T1 &rarr; 'T2 &rarr; 'U) &rarr; 'T1 [] &rarr; 'T2 [] &rarr; 'U []</td>
<td>Creates an array whose elements are the results of applying the supplied function to the corresponding elements of the two collections pairwise, also passing the index of the elements. The two input arrays must have the same lengths; otherwise, ArgumentException is raised.</td>
</tr>
<tr>
<td>max : 'T [] &rarr; 'T</td>
<td>Returns the largest of all elements of an array. Operators.max is used to compare the elements.</td>
</tr>
<tr>
<td>maxBy : ('T &rarr; 'U) &rarr; 'T [] &rarr; 'T</td>
<td>Returns the largest of all elements of an array, compared via Operators.max on the function result.</td>
</tr>
<tr>
<td>min : ('T [] &rarr; 'T</td>
<td>Returns the smallest of all elements of an array. Operators.min is used to compare the elements.</td>
</tr>
<tr>
<td>minBy : ('T &rarr; 'U) &rarr; 'T [] &rarr; 'T</td>
<td>Returns the smallest of all elements of an array. Operators.min is used to compare the elements.</td>
</tr>
<tr>
<td>ofList : 'T list &rarr; 'T []</td>
<td>Creates an array from the supplied list.</td>
</tr>
<tr>
<td>ofSeq : seq&lt;'T&gt; &rarr; 'T []</td>
<td>Creates an array from the supplied enumerable object.</td>
</tr>
<tr>
<td>partition : ('T &rarr; bool) &rarr; 'T [] &rarr; 'T [] * 'T []</td>
<td>Splits an array into two arrays, one containing the elements for which the supplied condition returns <b>true,</b> and the other containing those for which it returns <b>false</b>.</td>
</tr>
<tr>
<td>permute : (int &rarr; int) &rarr; 'T [] &rarr; 'T []</td>
<td>Permutes the elements of an array according to the specified permutation.</td>
</tr>
<tr>
<td>pick : ('T &rarr; 'U option) &rarr; 'T [] &rarr; 'U</td>
<td>Applies the supplied function to successive elements of a supplied array, returning the first result where the function returns Some(x) for some x. If the function never returns Some(x), KeyNotFoundException is raised.</td>
</tr>
<tr>
<td>reduce : ('T &rarr; 'T &rarr; 'T) &rarr; 'T [] &rarr; 'T</td>
<td>Applies a function to each element of an array, threading an accumulator argument through the computation. If the input function is f and the array elements are i0...iN, this function computes f (...(f i0 i1)...) iN. If the array has size zero, ArgumentException is raised.</td>
</tr>
<tr>
<td>reduceBack : ('T &rarr; 'T &rarr; 'T) &rarr; 'T [] &rarr; 'T</td>
<td>Applies a function to each element of an array, threading an accumulator argument through the computation. If the input function is f and the elements are i0...iN, this function computes f i0 (...(f iN-1 iN)). If the array has size zero, ArgumentException is raised.</td>
</tr>
<tr>
<td>rev : 'T [] &rarr; 'T []</td>
<td>Reverses the order of the elements in a supplied array.</td>
</tr>
<tr>
<td>scan : ('State &rarr; 'T &rarr; 'State) &rarr; 'State &rarr; 'T [] &rarr; 'State [])</td>
<td>Behaves like fold, but returns the intermediate results together with the final results.</td>
</tr>
<tr>
<td>scanBack : ('T &rarr; 'State &rarr; 'State) &rarr; 'T [] &rarr; 'State &rarr; 'State []</td>
<td>Behaves like foldBack, but returns the intermediary results together with the final results.</td>
</tr>
<tr>
<td>set : 'T [] &rarr; int &rarr; 'T &rarr; unit</td>
<td>Sets an element of an array.</td>
</tr>
<tr>
<td>sort : 'T[] &rarr; 'T []</td>
<td>Sorts the elements of an array and returns a new array. Operators.compare is used to compare the elements.</td>
</tr>
<tr>
<td>sortBy : ('T &rarr; 'Key) &rarr; 'T [] &rarr; 'T []</td>
<td>Sorts the elements of an array by using the supplied function to transform the elements to the type on which the sort operation is based, and returns a new array. Operators.compare is used to compare the elements.</td>
</tr>
<tr>
<td>sortInPlace : 'T [] &rarr; unit</td>
<td>Sorts the elements of an array by changing the array in place, using the supplied comparison function. Operators.compare is used to compare the elements.</td>
</tr>
<tr>
<td>sortInPlaceBy : ('T &rarr; 'Key) &rarr; 'T [] &rarr; unit</td>
<td>Sorts the elements of an array by changing the array in place, using the supplied projection for the keys. Operators.compare is used to compare the elements.</td>
</tr>
<tr>
<td>sortInPlaceWith : ('T &rarr; 'T &rarr; int) &rarr; 'T [] &rarr; unit</td>
<td>Sorts the elements of an array by using the supplied comparison function to change the array in place.</td>
</tr>
<tr>
<td>sortWith : ('T &rarr; 'T &rarr; int) &rarr; 'T [] &rarr; 'T []</td>
<td>Sorts the elements of an array by using the supplied comparison function, and returns a new array.</td>
</tr>
<tr>
<td>sub : 'T [] &rarr; int &rarr; int &rarr; 'T []</td>
<td>Creates an array that contains the supplied subrange, which is specified by starting index and length.</td>
</tr>
<tr>
<td>sum : 'T [] &rarr; ^T</td>
<td>Returns the sum of the elements in the array.</td>
</tr>
<tr>
<td>sumBy : ('T &rarr; ^U) &rarr; 'T [] &rarr; ^U</td>
<td>Returns the sum of the results generated by applying a function to each element of an array.</td>
</tr>
<tr>
<td>toList : 'T [] &rarr; 'T list</td>
<td>Converts the supplied array to a list.</td>
</tr>
<tr>
<td>toSeq : 'T [] &rarr; seq&lt;'T&gt;</td>
<td>Views the supplied array as a sequence.</td>
</tr>
<tr>
<td>tryFind : ('T &rarr; bool) &rarr; 'T [] &rarr; 'T option</td>
<td>Returns the first element in the supplied array for which the supplied function returns <b>true</b>. Returns <b>None</b> if no such element exists.</td>
</tr>
<tr>
<td>tryFindIndex : ('T &rarr; bool) &rarr; 'T [] &rarr; int option</td>
<td>Returns the index of the first element in an array that satisfies the supplied condition.</td>
</tr>
<tr>
<td>tryPick : ('T &rarr; 'U option) &rarr; 'T [] &rarr; 'U option</td>
<td>Applies the supplied function to successive elements of the supplied array, and returns the first result where the function returns Some(x) for some x. If the function never returns Some(x), <b>None</b> is returned.</td>
</tr>
<tr>
<td>unzip : ('T1 * 'T2) [] &rarr; 'T1 [] * 'T2 []</td>
<td>Splits an array of tuple pairs into a tuple of two arrays.</td>
</tr>
<tr>
<td>unzip3 : ('T1 * 'T2 * 'T3) [] &rarr; 'T1 [] * 'T2 [] * 'T3 []</td>
<td>Splits an array of tuples of three elements into a tuple of three arrays.</td>
</tr>
<tr>
<td>zeroCreate : int &rarr; 'T []</td>
<td>Creates an array whose elements are initially set to the default value Unchecked.defaultof&lt;'T&gt;.</td>
</tr>
<tr>
<td>zip : 'T1 [] &rarr; 'T2 [] &rarr; ('T1 * 'T2) []</td>
<td>Combines two arrays into an array of tuples that have two elements. The two arrays must have equal lengths; otherwise, ArgumentException is raised.</td>
</tr>
<tr>
<td>zip3 : 'T1 [] &rarr; 'T2 [] &rarr; 'T3 [] &rarr; ('T1 * 'T2 * 113
'T3) []</td>
<td>Combines three arrays into an array of tuples that have three elements. The three arrays must have equal lengths; otherwise, ArgumentException is raised.</td>
</tr>
</table>
<p>In the following section, we will see the uses of some of these functionalities.</p>
<h2>Creating Arrays Using Functions</h2>
<p>The Array module provides several functions that create an array from scratch.</p>
<ul class="list">
<li><p>The <b>Array.empty</b> function creates a new empty array.</p></li>
<li><p>The <b>Array.create</b> function creates an array of a specified size and sets all the elements to given values.</p></li>
<li><p>The <b>Array.init</b> function creates an array, given a dimension and a function to generate the elements.</p></li>
<li><p>The <b>Array.zeroCreate</b> function creates an array in which all the elements are initialized to the zero value.</p></li>
<li><p>The <b>Array.copy</b> function creates a new array that contains elements that are copied from an existing array.</p></li>
<li><p>The <b>Array.sub</b> function generates a new array from a subrange of an array.</p></li>
<li><p>The <b>Array.append</b> function creates a new array by combining two existing arrays.</p></li>
<li><p>The <b>Array.choose</b> function selects elements of an array to include in a new array.</p></li>
<li><p>The <b>Array.collect</b> function runs a specified function on each array element of an existing array and then collects the elements generated by the function and combines them into a new array.</p></li>
<li><p>The <b>Array.concat</b> function takes a sequence of arrays and combines them into a single array.</p></li>
<li><p>The <b>Array.filter</b> function takes a Boolean condition function and generates a new array that contains only those elements from the input array for which the condition is true.</p></li>
<li><p>The <b>Array.rev</b> function generates a new array by reversing the order of an existing array.</p></li>
</ul>
<p>The following examples demonstrate these functions &minus;</p>
<h3>Example 1</h3>
<pre class="prettyprint notranslate tryit">
(* using create and set *)
let array1 = Array.create 10 ""
for i in 0 .. array1.Length - 1 do
   Array.set array1 i (i.ToString())
for i in 0 .. array1.Length - 1 do
   printf "%s " (Array.get array1 i)
printfn " "

(* empty array *)
let array2 = Array.empty
printfn "Length of empty array: %d" array2.Length

let array3 = Array.create 10 7.0
printfn "Float Array: %A" array3

(* using the init and zeroCreate *)
let array4 = Array.init 10 (fun index -&gt; index * index)
printfn "Array of squares: %A" array4

let array5 : float array = Array.zeroCreate 10
let (myZeroArray : float array) = Array.zeroCreate 10
printfn "Float Array: %A" array5
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
0 1 2 3 4 5 6 7 8 9
Length of empty array: 0
Float Array: [|7.0; 7.0; 7.0; 7.0; 7.0; 7.0; 7.0; 7.0; 7.0; 7.0|]
Array of squares: [|0; 1; 4; 9; 16; 25; 36; 49; 64; 81|]
Float Array: [|0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0|]
</pre>
<h3>Example 2</h3>
<pre class="prettyprint notranslate tryit">
(* creating subarray from element 5 *)
(* containing 15 elements thereon *)

let array1 = [| 0 .. 50 |]
let array2 = Array.sub array1 5 15
printfn "Sub Array:"
printfn "%A" array2

(* appending two arrays *)
let array3 = [| 1; 2; 3; 4|]
let array4 = [| 5 .. 9 |]
printfn "Appended Array:"
let array5 = Array.append array3 array4
printfn "%A" array5

(* using the Choose function *)
let array6 = [| 1 .. 20 |]
let array7 = Array.choose (fun elem -&gt; if elem % 3 = 0 then
                                             Some(float (elem))
                                          else
                                             None) array6
printfn "Array with Chosen elements:"
printfn "%A" array7

(*using the Collect function *)
let array8 = [| 2 .. 5 |]
let array9 = Array.collect (fun elem -&gt; [| 0 .. elem - 1 |]) array8
printfn "Array with collected elements:"
printfn "%A" array9
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Sub Array:
[|5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19|]
Appended Array:
[|1; 2; 3; 4; 5; 6; 7; 8; 9|]
Array with Chosen elements:
[|3.0; 6.0; 9.0; 12.0; 15.0; 18.0|]
Array with collected elements:
[|0; 1; 0; 1; 2; 0; 1; 2; 3; 0; 1; 2; 3; 4|]
</pre>
<h2>Searching Arrays</h2>
<p>The <b>Array.find</b> function takes a Boolean function and returns the first element for which the function returns true, else raises a KeyNotFoundException.</p>
<p>The <b>Array.findIndex</b> function works similarly except that it returns the index of the element instead of the element itself.</p>
<p>The following example demonstrates this.</p>
<p>Microsoft provides this interesting program example, which finds the first element in the range of a given number that is both a perfect square as well as a perfect cube &minus;</p>
<pre class="prettyprint notranslate tryit">
let array1 = [| 2 .. 100 |]
let delta = 1.0e-10
let isPerfectSquare (x:int) =
   let y = sqrt (float x)
   abs(y - round y) &lt; delta

let isPerfectCube (x:int) =
   let y = System.Math.Pow(float x, 1.0/3.0)
   abs(y - round y) &lt; delta

let element = Array.find (fun elem -&gt; isPerfectSquare elem && isPerfectCube elem) array1

let index = Array.findIndex (fun elem -&gt; isPerfectSquare elem && isPerfectCube elem) array1

printfn "The first element that is both a square and a cube is %d and its index is %d." element index
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
The first element that is both a square and a cube is 64 and its index is 62.
</pre>

<title>F# Mutable Lists</title>

<h1>F# - Mutable Lists</h1>

<p>The <b>List&lt;'T&gt;</b> class represents a strongly typed list of objects that can be accessed by index.</p>

<p>It is a mutable counterpart of the List class. It is similar to arrays, as it can be accessed by an index, however, unlike arrays, lists can be resized. Therefore you need not specify a size during declaration.</p>

<h2>Creating a Mutable List</h2>

<p>Lists are created using the <b>new</b> keyword and calling the list's constructor. The following example demonstrates this &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>The List(T) Class</h2>

<p>The List(T) class represents a strongly typed list of objects that can be accessed by index. It provide methods to search, sort, and manipulate lists.</p>

<p>The following tables provide the properties, constructors and the methods of the List(T) class &minus;</p>

<h3>Properties</h3>

<h3>Constructors</h3>

<h3>Method</h3>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate tryit">
(* Creating a List *)
open System.Collections.Generic

let booksList = new List&lt;string&gt;()
booksList.Add("Gone with the Wind")
booksList.Add("Atlas Shrugged")
booksList.Add("Fountainhead")
booksList.Add("Thornbirds")
booksList.Add("Rebecca")
booksList.Add("Narnia")

booksList |> Seq.iteri (fun index item -&gt; printfn "%i: %s" index booksList.[index])
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
0: Gone with the Wind
1: Atlas Shrugged
2: Fountainhead
3: Thornbirds
4: Rebecca
5: Narnia
</pre>
<h2>The List(T) Class</h2>
<p>The List(T) class represents a strongly typed list of objects that can be accessed by index. It provide methods to search, sort, and manipulate lists.</p>
<p>The following tables provide the properties, constructors and the methods of the List(T) class &minus;</p>
<h3>Properties</h3>
<table class="table table-bordered">
<tr>
<th>Property</th>
<th>Description</th>
</tr>
<tr>
<td>Capacity</td>
<td>Gets or sets the total number of elements the internal data structure can hold without resizing.</td>
</tr>
<tr>
<td>Count</td>
<td>Gets the number of elements contained in the List(T).</td>
</tr>
<tr>
<td>Item</td>
<td>Gets or sets the element at the specified index.</td>
</tr>
</table>
<h3>Constructors</h3>
<table class="table table-bordered">
<tr>
<th style="width:30%;">Constructor</th>
<th>Description</th>
</tr>
<tr>
<td>List(T)()</td>
<td>Initializes a new instance of the List(T) class that is empty and has the default initial capacity.</td>
</tr>
<tr>
<td>List(T)(IEnumerable(T))</td>
<td>Initializes a new instance of the List(T) class that contains elements copied from the specified collection and has sufficient capacity to accommodate the number of elements copied.</td>
</tr>
<tr>
<td>List(T)(Int32)</td>
<td>Initializes a new instance of the List(T) class that is empty and has the specified initial capacity.</td>
</tr>
</table>
<h3>Method</h3>
<table class="table table-bordered">
<tr>
<th style="width:45%;">Methods</th>
<th>Description</th>
</tr>
<tr>
<td>Add</td>
<td>Adds an object to the end of the List(T).</td>
</tr>
<tr>
<td>AddRange</td>
<td>Adds the elements of the specified collection to the end of the List(T).</td>
</tr>
<tr>
<td>AsReadOnly</td>
<td>Returns a read-only IList(T) wrapper for the current collection.</td>
</tr>
<tr>
<td>BinarySearch(T)</td>
<td>Searches the entire sorted List(T) for an element using the default comparer and returns the zero-based index of the element.</td>
</tr>
<tr>
<td>BinarySearch(T, IComparer(T))</td>
<td>Searches the entire sorted List(T) for an element using the specified comparer and returns the zero-based index of the element.</td>
</tr>
<tr>
<td>BinarySearch(Int32, Int32, T, IComparer(T))</td>
<td>Searches a range of elements in the sorted List(T) for an element using the specified comparer and returns the zero-based index of the element.</td>
</tr>
<tr>
<td>Clear</td>
<td>Removes all elements from the List(T).</td>
</tr>
<tr>
<td>Contains</td>
<td>Determines whether an element is in the List(T).</td>
</tr>
<tr>
<td>ConvertAll(TOutput)</td>
<td>Converts the elements in the current List(T) to another type, and returns a list containing the converted elements.</td>
</tr>
<tr>
<td>CopyTo(T[])</td>
<td>Copies the entire List(T) to a compatible one-dimensional array, starting at the beginning of the target array.</td>
</tr>
<tr>
<td>CopyTo(T[], Int32)</td>
<td>Copies the entire List(T) to a compatible one-dimensional array, starting at the specified index of the target array.</td>
</tr>
<tr>
<td>CopyTo(Int32, T[], Int32, Int32)</td>
<td>Copies a range of elements from the List(T) to a compatible one-dimensional array, starting at the specified index of the target array.</td>
</tr>
<tr>
<td>Equals(Object)</td>
<td>Determines whether the specified object is equal to the current object. (Inherited from Object.)</td>
</tr>
<tr>
<td>Exists</td>
<td>Determines whether the List(T) contains elements that match the conditions defined by the specified predicate.</td>
</tr>
<tr>
<td>Finalize</td>
<td>Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection (Inherited from Object).</td>
</tr>
<tr>
<td>Find</td>
<td>Searches for an element that matches the conditions defined by the specified predicate, and returns the first occurrence within the entire List(T).</td>
</tr>
<tr>
<td>FindAll</td>
<td>Retrieves all the elements that match the conditions defined by the specified predicate.</td>
</tr>
<tr>
<td>FindIndex(Predicate(T))</td>
<td>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the entire List(T).</td>
</tr>
<tr>
<td>FindIndex(Int32, Predicate(T))</td>
<td>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the range of elements in the List(T) that extends from the specified index to the last element.</td>
</tr>
<tr>
<td>FindIndex(Int32, Int32, Predicate(T))</td>
<td>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the range of elements in the List(T) that starts at the specified index and contains the specified number of elements.</td>
</tr>
<tr>
<td>FindLast</td>
<td>Searches for an element that matches the conditions defined by the specified predicate, and returns the last occurrence within the entire List(T).</td>
</tr>
<tr>
<td>FindLastIndex(Predicate(T))</td>
<td>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the entire List(T).</td>
</tr>
<tr>
<td>FindLastIndex(Int32, Predicate(T))</td>
<td>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the range of elements in the List(T) that extends from the first element to the specified index.</td>
</tr>
<tr>
<td>FindLastIndex(Int32, Int32, Predicate(T))</td>
<td>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the range of elements in the List(T) that contains the specified number of elements and ends at the specified index.</td>
</tr>
<tr>
<td>ForEach</td>
<td>Performs the specified action on each element of the List(T).</td>
</tr>
<tr>
<td>GetEnumerator</td>
<td>Returns an enumerator that iterates through the List(T).</td>
</tr>
<tr>
<td>GetHashCode</td>
<td>Serves as the default hash function. (Inherited from Object.)</td>
</tr>
<tr>
<td>GetRange</td>
<td>Creates a shallow copy of a range of elements in the source List(T).</td>
</tr>
<tr>
<td>GetType</td>
<td>Gets the Type of the current instance. (Inherited from Object.)</td>
</tr>
<tr>
<td>IndexOf(T)</td>
<td>Searches for the specified object and returns the zero-based index of the first occurrence within the entire List(T).</td>
</tr>
<tr>
<td>IndexOf(T, Int32)</td>
<td>Searches for the specified object and returns the zero-based index of the first occurrence within the range of elements in the List(T) that extends from the specified index to the last element.</td>
</tr>
<tr>
<td>IndexOf(T, Int32, Int32)</td>
<td>Searches for the specified object and returns the zero-based index of the first occurrence within the range of elements in the List(T) that starts at the specified index and contains the specified number of elements.</td>
</tr>
<tr>
<td>Insert</td>
<td>Inserts an element into the List(T) at the specified index.</td>
</tr>
<tr>
<td>InsertRange</td>
<td>Inserts the elements of a collection into the List(T) at the specified index.</td>
</tr>
<tr>
<td>LastIndexOf(T)</td>
<td>Searches for the specified object and returns the zero-based index of the last occurrence within the entire List(T).</td>
</tr>
<tr>
<td>LastIndexOf(T, Int32)</td>
<td>Searches for the specified object and returns the zero-based index of the last occurrence within the range of elements in the List(T) that extends from the first element to the specified index.</td>
</tr>
<tr>
<td>LastIndexOf(T, Int32, Int32)</td>
<td>Searches for the specified object and returns the zero-based index of the last occurrence within the range of elements in the List(T) that contains the specified number of elements and ends at the specified index.</td>
</tr>
<tr>
<td>MemberwiseClone</td>
<td>Creates a shallow copy of the current Object. (Inherited from Object.)</td>
</tr>
<tr>
<td>Remove</td>
<td>Removes the first occurrence of a specific object from the List(T).</td>
</tr>
<tr>
<td>RemoveAll</td>
<td>Removes all the elements that match the conditions defined by the specified predicate.</td>
</tr>
<tr>
<td>RemoveAt</td>
<td>Removes the element at the specified index of the List(T).</td>
</tr>
<tr>
<td>RemoveRange</td>
<td>Removes a range of elements from the List(T).</td>
</tr>
<tr>
<td>Reverse()</td>
<td>Reverses the order of the elements in the entire List(T).</td>
</tr>
<tr>
<td>Reverse(Int32, Int32)</td>
<td>Reverses the order of the elements in the specified range.</td>
</tr>
<tr>
<td>Sort()</td>
<td>Sorts the elements in the entire List(T) using the default comparer.</td>
</tr>
<tr>
<td>Sort(Comparison(T))</td>
<td>Sorts the elements in the entire List(T) using the specified System. Comparison(T).</td>
</tr>
<tr>
<td>Sort(IComparer(T))</td>
<td>Sorts the elements in the entire List(T) using the specified comparer.</td>
</tr>
<tr>
<td>Sort(Int32, Int32, IComparer(T))</td>
<td>Sorts the elements in a range of elements in List(T) using the specified comparer.</td>
</tr>
<tr>
<td>ToArray</td>
<td>Copies the elements of the List(T) to a new array.</td>
</tr>
<tr>
<td>ToString</td>
<td>Returns a string that represents the current object. (Inherited from Object.)</td>
</tr>
<tr>
<td>TrimExcess</td>
<td>Sets the capacity to the actual number of elements in the List(T), if that number is less than a threshold value.</td>
</tr>
<tr>
<td>TrueForAll</td>
<td>Determines whether every element in the List(T) matches the conditions defined by the specified predicate.</td>
</tr>
</table>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
(* Creating a List *)
open System.Collections.Generic

let booksList = new List&lt;string&gt;()
booksList.Add("Gone with the Wind")
booksList.Add("Atlas Shrugged")
booksList.Add("Fountainhead")
booksList.Add("Thornbirds")
booksList.Add("Rebecca")
booksList.Add("Narnia")

printfn"Total %d books" booksList.Count
booksList |> Seq.iteri (fun index item -&gt; printfn "%i: %s" index booksList.[index])
booksList.Insert(2, "Roots")

printfn("after inserting at index 2")
printfn"Total %d books" booksList.Count

booksList |> Seq.iteri (fun index item -&gt; printfn "%i: %s" index booksList.[index])
booksList.RemoveAt(3)

printfn("after removing from index 3")
printfn"Total %d books" booksList.Count

booksList |> Seq.iteri (fun index item -&gt; printfn "%i: %s" index booksList.[index])
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Total 6 books
0: Gone with the Wind
1: Atlas Shrugged
2: Fountainhead
3: Thornbirds
4: Rebecca
5: Narnia
after inserting at index 2
Total 7 books
0: Gone with the Wind
1: Atlas Shrugged
2: Roots
3: Fountainhead
4: Thornbirds
5: Rebecca
6: Narnia
after removing from index 3
Total 6 books
0: Gone with the Wind
1: Atlas Shrugged
2: Roots
3: Thornbirds
4: Rebecca
5: Narnia
</pre>

<title>F# Mutable Dictionary</title>

<h1>F# - Mutable Dictionary</h1>

<p>The <b>Dictionary&lt;'TKey, 'TValue&gt;</b> class is the mutable analog of the F# map data structure and contains many of the same functions.</p>

<p>Recapitulating from the Map chapter in F#, a map is a special kind of set that associates the values with key.</p>

<h2>Creating of a Mutable Dictionary</h2>

<p>Mutable dictionaries are created using the <b>new</b> keyword and calling the list's constructor. The following example demonstrates this &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>The Dictionary(TKey,TValue) Class</h2>

<p>The Dictionary(TKey, TValue) Class represents a collection of keys and values.</p>

<p>The following tables provide the properties, constructors and the methods of the List(T) class &minus;</p>

<h3>Properties</h3>

<h3>Constructors</h3>

<h3>Methods</h3>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate tryit">
open System.Collections.Generic
let dict = new Dictionary&lt;string, string&gt;()
dict.Add("1501", "Zara Ali")
dict.Add("1502","Rishita Gupta")
dict.Add("1503","Robin Sahoo")
dict.Add("1504","Gillian Megan")
printfn "Dictionary - students: %A" dict
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Dictionary - students: seq
[[1501, Zara Ali]; [1502, Rishita Gupta]; [1503, Robin Sahoo];
[1504, Gillian Megan]]
</pre>
<h2>The Dictionary(TKey,TValue) Class</h2>
<p>The Dictionary(TKey, TValue) Class represents a collection of keys and values.</p>
<p>The following tables provide the properties, constructors and the methods of the List(T) class &minus;</p>
<h3>Properties</h3>
<table class="table table-bordered">
<tr>
<th>Property</th>
<th>Description</th>
</tr>
<tr>
<td>Comparer</td>
<td>Gets the IEqualityComparer(T) that is used to determine equality of keys for the dictionary.</td>
</tr>
<tr>
<td>Count</td>
<td>Gets the number of key/value pairs contained in the Dictionary(TKey, TValue).</td>
</tr>
<tr>
<td>Item</td>
<td>Gets or sets the value associated with the specified key.</td>
</tr>
<tr>
<td>Keys</td>
<td>Gets a collection containing the keys in the Dictionary(TKey, TValue).</td>
</tr>
<tr>
<td>Values</td>
<td>Gets a collection containing the values in the Dictionary(TKey, TValue).</td>
</tr>
</table>
<h3>Constructors</h3>
<table class="table table-bordered">
<tr>
<th>Constructors</th>
<th>Description</th>
</tr>
<tr>
<td>Dictionary(TKey, TValue)()</td>
<td>Initializes a new instance of the <b>Dictionary(TKey, TValue)</b> class that is empty, has the default initial capacity, and uses the default equality comparer for the key type.</td>
</tr>
<tr>
<td>Dictionary(TKey, TValue)(IDictionary(TKey, TValue))</td>
<td>Initializes a new instance of the <b>Dictionary(TKey, TValue)</b> class that contains elements copied from the specified <b>IDictionary(TKey, TValue)</b> and uses the default equality comparer for the key type.</td>
</tr>
<tr>
<td>Dictionary(TKey, TValue)(IEqualityComparer(TKey))</td>
<td>Initializes a new instance of the <b>Dictionary(TKey, TValue)</b> class that is empty, has the default initial capacity, and uses the specified <b>IEqualityComparer(T).</b></td>
</tr>
<tr>
<td>Dictionary(TKey, TValue)(Int32)</td>
<td>Initializes a new instance of the <b>Dictionary(TKey, TValue)</b> class that is empty, has the specified initial capacity, and uses the default equality comparer for the key type.</td>
</tr>
<tr>
<td>Dictionary(TKey, TValue)(IDictionary(TKey, TValue), IEqualityComparer(TKey))</td>
<td>Initializes a new instance of the <b>Dictionary(TKey, TValue)</b> class that contains elements copied from the specified <b>IDictionary(TKey, TValue)</b> and uses the specified <b>IEqualityComparer(T).</b></td>
</tr>
<tr>
<td>Dictionary(TKey, TValue)(Int32, IEqualityComparer(TKey))</td>
<td>Initializes a new instance of the <b>Dictionary(TKey, TValue)</b> class that is empty, has the specified initial capacity, and uses the specified <b>IEqualityComparer(T).</b></td>
</tr>
<tr>
<td>Dictionary(TKey, TValue)(SerializationInfo, StreamingContext)</td>
<td>Initializes a new instance of the <b>ictionary(TKey, TValue)</b> class with serialized data.</td>
</tr>
</table>
<h3>Methods</h3>
<table class="table table-bordered">
<tr>
<th>Method</th>
<th>Description</th>
</tr>
<tr>
<td>Add</td>
<td>Adds the specified key and value to the dictionary.</td>
</tr>
<tr>
<td>Clear</td>
<td>Removes all keys and values from the Dictionary(TKey, TValue).</td>
</tr>
<tr>
<td>ContainsKey</td>
<td>Determines whether the Dictionary(TKey, TValue) contains the specified key.</td>
</tr>
<tr>
<td>ContainsValue</td>
<td>Determines whether the Dictionary(TKey, TValue) contains a specific value.</td>
</tr>
<tr>
<td>Equals(Object)</td>
<td>Determines whether the specified object is equal to the current object. (Inherited from Object.)</td>
</tr>
<tr>
<td>Finalize</td>
<td>Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection. (Inherited from Object.)</td>
</tr>
<tr>
<td>GetEnumerator</td>
<td>Returns an enumerator that iterates through the Dictionary(TKey, TValue).</td>
</tr>
<tr>
<td>GetHashCode</td>
<td>Serves as the default hash function. (Inherited from Object.)</td>
</tr>
<tr>
<td>GetObjectData</td>
<td>Implements the System.Runtime.Serialization.ISerializable interface and returns the data needed to serialize the Dictionary(TKey, TValue)instance.</td>
</tr>
<tr>
<td>GetType</td>
<td>Gets the Type of the current instance. (Inherited from Object.)</td>
</tr>
<tr>
<td>MemberwiseClone</td>
<td>Creates a shallow copy of the current Object. (Inherited from Object.)</td>
</tr>
<tr>
<td>OnDeserialization</td>
<td>Implements the System.Runtime.Serialization.ISerializable interface and raises the deserialization event when the deserialization is complete.</td>
</tr>
<tr>
<td>Remove</td>
<td>Removes the value with the specified key from the Dictionary(TKey, TValue).</td>
</tr>
<tr>
<td>ToString</td>
<td>Returns a string that represents the current object. (Inherited from Object.)</td>
</tr>
<tr>
<td>TryGetValue</td>
<td>Gets the value associated with the specified key.</td>
</tr>
</table>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
open System.Collections.Generic
let dict = new Dictionary&lt;string, string&gt;()

dict.Add("1501", "Zara Ali")
dict.Add("1502","Rishita Gupta")
dict.Add("1503","Robin Sahoo")
dict.Add("1504","Gillian Megan")

printfn "Dictionary - students: %A" dict
printfn "Total Number of Students: %d" dict.Count
printfn "The keys: %A" dict.Keys
printf"The Values: %A" dict.Values
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Dictionary - students: seq
[[1501, Zara Ali]; [1502, Rishita Gupta]; [1503, Robin Sahoo];
[1504, Gillian Megan]]
Total Number of Students: 4
The keys: seq ["1501"; "1502"; "1503"; "1504"]
The Values: seq ["Zara Ali"; "Rishita Gupta"; "Robin Sahoo"; "Gillian Megan"]
</pre>

<title>F# Basic I/O</title>

<h1>F# - Basic I/O</h1>

<p>Basic Input Output includes &minus;</p>

<h2>Core.Printf Module</h2>

<p>We have used the <i>printf</i> and the <i>printfn</i> functions for writing into the console. In this section, we will look into the details of the <b>Printf</b> module of F#.</p>

<p>Apart from the above functions, the <i>Core.Printf</i> module of F# has various other methods for printing and formatting using % markers as placeholders. The following table shows the methods with brief description &minus;</p>

<h2>Format Specifications</h2>

<p>Format specifications are used for formatting the input or output, according to the programmers’ need.</p>

<p>These are strings with % markers indicating format placeholders.</p>

<p>The syntax of a Format placeholders is &minus;</p>

<p>The <b>type</b> is interpreted as &minus;</p>

<p>A general format specifier, requires two arguments. The first argument is a function which accepts two arguments: first, a context parameter of the appropriate type for the given formatting function (for example, a TextWriter), and second, a value to print and which either outputs or returns appropriate text.</p>

<p>The second argument is the particular value to print.</p>

<p>The <b>width</b> is an optional parameter. It is an integer that indicates the minimal width of the result. For example, %5d prints an integer with at least spaces of 5 characters.</p>

<p>Valid <b>flags</b> are described in the following table &minus;</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>The Console Class</h2>

<p>This class is a part of the .NET framework. It represents the standard input, output, and error streams for console applications.</p>

<p>It provides various methods for reading from and writing into the console. The following table shows the methods &minus;</p>

<p>The following example demonstrates reading from console and writing into it &minus;</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>The System.IO Namespace</h2>

<p>The System.IO namespace contains a variety of useful classes for performing basic I/O.</p>

<p>It contains types or classes that allow reading and writing to files and data streams and types that provide basic file and directory support.</p>

<p>Classes useful for working with the file system &minus;</p>

<p>Classes useful for working with the streams (sequence of bytes) &minus;</p>

<p>The following table shows all the classes provided in the namespace along with a brief description &minus;</p>

<h3>Example</h3>

<p>The following example creates a file called test.txt, writes a message there, reads the text from the file and prints it on the console.</p>

<p><b>Note</b> &minus;  The amount of code needed to do this is surprisingly less!</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
%[flags][width][.precision][type]
</pre>
<p>The <b>type</b> is interpreted as &minus;</p>
<table class="table table-bordered">
<tr>
<th style="width:28%;">Type</th>
<th>Description</th>
</tr>
<tr>
<td>%b</td>
<td>Formats a <b>bool,</b> formatted as <b>true</b> or <b>false</b>.</td>
</tr>
<tr>
<td>%c</td>
<td>Formats a character.</td>
</tr>
<tr>
<td>%s</td>
<td>Formats a <b>string,</b> formatted as its contents, without interpreting any escape characters.</td>
</tr>
<tr>
<td>%d, %i</td>
<td>Formats any basic integer type formatted as a decimal integer, signed if the basic integer type is signed.</td>
</tr>
<tr>
<td>%u</td>
<td>Formats any basic integer type formatted as an unsigned decimal integer.</td>
</tr>
<tr>
<td>%x</td>
<td>Formats any basic integer type formatted as an unsigned hexadecimal integer, using lowercase letters a through f.</td>
</tr>
<tr>
<td>%X</td>
<td>Formats any basic integer type formatted as an unsigned hexadecimal integer, using uppercase letters A through F.</td>
</tr>
<tr>
<td>%o</td>
<td>Formats any basic integer type formatted as an unsigned octal integer.</td>
</tr>
<tr>
<td>%e, %E, %f, %F, %g, %G</td>
<td>Formats any basic floating point type <b>(float, float32)</b> formatted using a C-style floating point format specifications.</td>
</tr>
<tr>
<td>%e, %E</td>
<td>Formats a signed value having the form [-]d.dddde[sign]ddd where d is a single decimal digit, dddd is one or more decimal digits, ddd is exactly three decimal digits, and sign is + or -.</td>
</tr>
<tr>
<td>%f</td>
<td>Formats a signed value having the form [-]dddd.dddd, where dddd is one or more decimal digits. The number of digits before the decimal point depends on the magnitude of the number, and the number of digits after the decimal point depends on the requested precision.</td>
</tr>
<tr>
<td>%g, %G</td>
<td>Formats a signed value printed in f or e format, whichever is more compact for the given value and precision.</td>
</tr>
<tr>
<td>%M</td>
<td>Formats a Decimal value.</td>
</tr>
<tr>
<td>%O</td>
<td>Formats any value, printed by boxing the object and using its <b>ToString</b> method.</td>
</tr>
<tr>
<td>%A, %+A</td>
<td>Formats any value, printed with the default layout settings. Use %+A to print the structure of discriminated unions with internal and private representations.</td>
</tr>
<tr>
<td>%a</td>
<td><p>A general format specifier, requires two arguments. The first argument is a function which accepts two arguments: first, a context parameter of the appropriate type for the given formatting function (for example, a TextWriter), and second, a value to print and which either outputs or returns appropriate text.</p>
<p>The second argument is the particular value to print.</p></td>
</tr>
<tr>
<td>%t</td>
<td>A general format specifier, requires one argument: a function which accepts a context parameter of the appropriate type for the given formatting function (aTextWriter) and which either outputs or returns appropriate text. Basic integer types are <b>byte, sbyte, int16, uint16, int32, uint32, int64, uint64, nativeint,</b> and <b>unativeint.</b> Basic floating point types are <b>float</b> and <b>float32.</b></td>
</tr>
</table>
<p>The <b>width</b> is an optional parameter. It is an integer that indicates the minimal width of the result. For example, %5d prints an integer with at least spaces of 5 characters.</p>
<p>Valid <b>flags</b> are described in the following table &minus;</p>
<table class="table table-bordered">
<tr>
<th>Value</th>
<th>Description</th>
</tr>
<tr>
<td>0</td>
<td>Specifies to add zeros instead of spaces to make up the required width.</td>
</tr>
<tr>
<td>-</td>
<td>Specifies to left-justify the result within the width specified.</td>
</tr>
<tr>
<td>+</td>
<td>Specifies to add a + character if the number is positive (to match a - sign for negative numbers).</td>
</tr>
<tr>
<td>' ' (space)</td>
<td>Specifies to add an extra space if the number is positive (to match a - sign for negative numbers).</td>
</tr>
<tr>
<td>#</td>
<td>Invalid.</td>
</tr>
</table>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
printf "Hello "
printf "World"
printfn ""
printfn "Hello "
printfn "World"
printf "Hi, I'm %s and I'm a %s" "Rohit" "Medical Student"

printfn "d: %f" 212.098f
printfn "e: %f" 504.768f

printfn "x: %g" 212.098f
printfn "y: %g" 504.768f

printfn "x: %e" 212.098f
printfn "y: %e" 504.768f
printfn "True: %b" true
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Hello World
Hello
World
Hi, I'm Rohit and I'm a Medical Studentd: 212.098000
e: 504.768000
x: 212.098
y: 504.768
x: 2.120980e+002
y: 5.047680e+002
True: true
</pre>
<h2>The Console Class</h2>
<p>This class is a part of the .NET framework. It represents the standard input, output, and error streams for console applications.</p>
<p>It provides various methods for reading from and writing into the console. The following table shows the methods &minus;</p>
<table class="table table-bordered">
<tr>
<th>Method</th>
<th>Description</th>
</tr>
<tr>
<td>Beep()</td>
<td>Plays the sound of a beep through the console speaker.</td>
</tr>
<tr>
<td>Beep(Int32, Int32)</td>
<td>Plays the sound of a beep of a specified frequency and duration through the console speaker.</td>
</tr>
<tr>
<td>Clear</td>
<td>Clears the console buffer and corresponding console window of display information.</td>
</tr>
<tr>
<td>MoveBufferArea(Int32, Int32, Int32, Int32, Int32, Int32)</td>
<td>Copies a specified source area of the screen buffer to a specified destination area.</td>
</tr>
<tr>
<td>MoveBufferArea(Int32, Int32, Int32, Int32, Int32, Int32, Char, ConsoleColor, ConsoleColor)</td>
<td>Copies a specified source area of the screen buffer to a specified destination area.</td>
</tr>
<tr>
<td>OpenStandardError()</td>
<td>Acquires the standard error stream.</td>
</tr>
<tr>
<td>OpenStandardError(Int32)</td>
<td>Acquires the standard error stream, which is set to a specified buffer size.</td>
</tr>
<tr>
<td>OpenStandardInput()</td>
<td>Acquires the standard input stream.</td>
</tr>
<tr>
<td>OpenStandardInput(Int32)</td>
<td>Acquires the standard input stream, which is set to a specified buffer size.</td>
</tr>
<tr>
<td>OpenStandardOutput()</td>
<td>Acquires the standard output stream.</td>
</tr>
<tr>
<td>OpenStandardOutput(Int32)</td>
<td>Acquires the standard output stream, which is set to a specified buffer size.</td>
</tr>
<tr>
<td>Read</td>
<td>Reads the next character from the standard input stream.</td>
</tr>
<tr>
<td>ReadKey()</td>
<td>Obtains the next character or function key pressed by the user. The pressed key is displayed in the console window.</td>
</tr>
<tr>
<td>ReadKey(Boolean)</td>
<td>Obtains the next character or function key pressed by the user. The pressed key is optionally displayed in the console window.</td>
</tr>
<tr>
<td>ReadLine</td>
<td>Reads the next line of characters from the standard input stream.</td>
</tr>
<tr>
<td>ResetColor</td>
<td>Sets the foreground and background console colors to their defaults.</td>
</tr>
<tr>
<td>SetBufferSize</td>
<td>Sets the height and width of the screen buffer area to the specified values.</td>
</tr>
<tr>
<td>SetCursorPosition</td>
<td>Sets the position of the cursor.</td>
</tr>
<tr>
<td>SetError</td>
<td>Sets the Error property to the specified <a rel="nofollow" target="_blank" href="http://msdn.microsoft.com/en-us/library/system.io.textwriter.aspx">TextWriter</a> object.</td>
</tr>
<tr>
<td>SetIn</td>
<td>Sets the In property to the specified <a rel="nofollow" target="_blank" href="http://msdn.microsoft.com/en-us/library/system.io.textreader.aspx">TextReader</a> object.</td>
</tr>
<tr>
<td>SetOut</td>
<td>Sets the Out property to the specified <a rel="nofollow" target="_blank" href="http://msdn.microsoft.com/en-us/library/system.io.textwriter.aspx">TextWriter</a> object.</td>
</tr>
<tr>
<td>SetWindowPosition</td>
<td>Sets the position of the console window relative to the screen buffer.</td>
</tr>
<tr>
<td>SetWindowSize</td>
<td>Sets the height and width of the console window to the specified values.</td>
</tr>
<tr>
<td>Write(Boolean)</td>
<td>Writes the text representation of the specified Boolean value to the standard output stream.</td>
</tr>
<tr>
<td>Write(Char)</td>
<td>Writes the specified Unicode character value to the standard output stream.</td>
</tr>
<tr>
<td>Write(Char[])</td>
<td>Writes the specified array of Unicode characters to the standard output stream.</td>
</tr>
<tr>
<td>Write(Decimal)</td>
<td>Writes the text representation of the specified Decimal value to the standard output stream.</td>
</tr>
<tr>
<td>Write(Double)</td>
<td>Writes the text representation of the specified double-precision floating-point value to the standard output stream.</td>
</tr>
<tr>
<td>Write(Int32)</td>
<td>Writes the text representation of the specified 32-bit signed integer value to the standard output stream.</td>
</tr>
<tr>
<td>Write(Int64)</td>
<td>Writes the text representation of the specified 64-bit signed integer value to the standard output stream.</td>
</tr>
<tr>
<td>Write(Object)</td>
<td>Writes the text representation of the specified object to the standard output stream.</td>
</tr>
<tr>
<td>Write(Single)</td>
<td>Writes the text representation of the specified single-precision floating-point value to the standard output stream.</td>
</tr>
<tr>
<td>Write(String)</td>
<td>Writes the specified string value to the standard output stream.</td>
</tr>
<tr>
<td>Write(UInt32)</td>
<td>Writes the text representation of the specified 32-bit unsigned integer value to the standard output stream.</td>
</tr>
<tr>
<td>Write(UInt64)</td>
<td>Writes the text representation of the specified 64-bit unsigned integer value to the standard output stream.</td>
</tr>
<tr>
<td>Write(String, Object)</td>
<td>Writes the text representation of the specified object to the standard output stream using the specified format information.</td>
</tr>
<tr>
<td>Write(String, Object[])</td>
<td>Writes the text representation of the specified array of objects to the standard output stream using the specified format information.</td>
</tr>
<tr>
<td>Write(Char[], Int32, Int32)</td>
<td>Writes the specified subarray of Unicode characters to the standard output stream.</td>
</tr>
<tr>
<td>Write(String, Object, Object)</td>
<td>Writes the text representation of the specified objects to the standard output stream using the specified format information.</td>
</tr>
<tr>
<td>Write(String, Object, Object, Object)</td>
<td>Writes the text representation of the specified objects to the standard output stream using the specified format information.</td>
</tr>
<tr>
<td>Write(String, Object, Object, Object, Object)</td>
<td>Writes the text representation of the specified objects and variable-length parameter list to the standard output stream using the specified format information.</td>
</tr>
<tr>
<td>WriteLine()</td>
<td>Writes the current line terminator to the standard output stream.</td>
</tr>
<tr>
<td>WriteLine(Boolean)</td>
<td>Writes the text representation of the specified Boolean value, followed by the current line terminator, to the standard output stream.</td>
</tr>
<tr>
<td>WriteLine(Char)</td>
<td>Writes the specified Unicode character, followed by the current line terminator, value to the standard output stream.</td>
</tr>
<tr>
<td>WriteLine(Char[])</td>
<td>Writes the specified array of Unicode characters, followed by the current line terminator, to the standard output stream.</td>
</tr>
<tr>
<td>WriteLine(Decimal)</td>
<td>Writes the text representation of the specified Decimal value, followed by the current line terminator, to the standard output stream.</td>
</tr>
<tr>
<td>WriteLine(Double)</td>
<td>Writes the text representation of the specified double-precision floating-point value, followed by the current line terminator, to the standard output stream.</td>
</tr>
<tr>
<td>WriteLine(Int32)</td>
<td>Writes the text representation of the specified 32-bit signed integer value, followed by the current line terminator, to the standard output stream.</td>
</tr>
<tr>
<td>WriteLine(Int64)</td>
<td>Writes the text representation of the specified 64-bit signed integer value, followed by the current line terminator, to the standard output stream.</td>
</tr>
<tr>
<td>WriteLine(Object)</td>
<td>Writes the text representation of the specified object, followed by the current line terminator, to the standard output stream.</td>
</tr>
<tr>
<td>WriteLine(Single)</td>
<td>Writes the text representation of the specified single-precision floating-point value, followed by the current line terminator, to the standard output stream.</td>
</tr>
<tr>
<td>WriteLine(String)</td>
<td>Writes the specified string value, followed by the current line terminator, to the standard output stream.</td>
</tr>
<tr>
<td>WriteLine(UInt32)</td>
<td>Writes the text representation of the specified 32-bit unsigned integer value, followed by the current line terminator, to the standard output stream.</td>
</tr>
<tr>
<td>WriteLine(UInt64)</td>
<td>Writes the text representation of the specified 64-bit unsigned integer value, followed by the current line terminator, to the standard output stream.</td>
</tr>
<tr>
<td>WriteLine(String, Object)</td>
<td>Writes the text representation of the specified object, followed by the current line terminator, to the standard output stream using the specified format information.</td>
</tr>
<tr>
<td>WriteLine(String, Object[])</td>
<td>Writes the text representation of the specified array of objects, followed by the current line terminator, to the standard output stream using the specified format information.</td>
</tr>
<tr>
<td>WriteLine(Char[], Int32, Int32)</td>
<td>Writes the specified subarray of Unicode characters, followed by the current line terminator, to the standard output stream.</td>
</tr>
<tr>
<td>WriteLine(String, Object, Object)</td>
<td>Writes the text representation of the specified objects, followed by the current line terminator, to the standard output stream using the specified format information.</td>
</tr>
<tr>
<td>WriteLine(String, Object, Object, Object)</td>
<td>Writes the text representation of the specified objects, followed by the current line terminator, to the standard output stream using the specified format information.</td>
</tr>
<tr>
<td>WriteLine(String, Object, Object, Object, Object)</td>
<td>Writes the text representation of the specified objects and variable-length parameter list, followed by the current line terminator, to the standard output stream using the specified format information.</td>
</tr>
</table>
<p>The following example demonstrates reading from console and writing into it &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
open System
let main() =
   Console.Write("What's your name? ")
   let name = Console.ReadLine()
   Console.Write("Hello, {0}\n", name)
   Console.WriteLine(System.String.Format("Big Greetings from {0} and {1}", "TutorialsPoint", "Absoulte Classes"))
   Console.WriteLine(System.String.Format("|{0:yyyy-MMM-dd}|", System.DateTime.Now))
main()
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
What's your name? Kabir
Hello, Kabir
Big Greetings from TutorialsPoint and Absoulte Classes
|2015-Jan-05|
</pre>
<h2>The System.IO Namespace</h2>
<p>The System.IO namespace contains a variety of useful classes for performing basic I/O.</p>
<p>It contains types or classes that allow reading and writing to files and data streams and types that provide basic file and directory support.</p>
<p>Classes useful for working with the file system &minus;</p>
<ul class="list">
<li>The System.IO.File class is used for creating, appending, and deleting files.</li>
<li>System.IO.Directory class is used for creating, moving, and deleting directories.</li>
<li>System.IO.Path class performs operations on strings, which represent file paths.</li>
<li>System.IO.FileSystemWatcher class allows users to listen to a directory for changes.</li>
</ul>
<p>Classes useful for working with the streams (sequence of bytes) &minus;</p>
<ul class="list">
<li>System.IO.StreamReader class is used to read characters from a stream.</li>
<li>System.IO.StreamWriter class is used to write characters to a stream.</li>
<li>System.IO.MemoryStream class creates an in-memory stream of bytes.</li>
</ul>
<p>The following table shows all the classes provided in the namespace along with a brief description &minus;</p>
<table class="table table-bordered">
<tr>
<th>Class</td>
<th>Description</th>
</tr>
<tr>
<td>BinaryReader</td>
<td>Reads primitive data types as binary values in a specific encoding.</td>
</tr>
<tr>
<td>BinaryWriter</td>
<td>Writes primitive types in binary to a stream and supports writing strings in a specific encoding.</td>
</tr>
<tr>
<td>BufferedStream</td>
<td>Adds a buffering layer to read and write operations on another stream.</td>
</tr>
<tr>
<td>Directory</td>
<td>Exposes static methods for creating, moving, and enumerating through directories and subdirectories.</td>
</tr>
<tr>
<td>DirectoryInfo</td>
<td>Exposes instance methods for creating, moving, and enumerating through directories and subdirectories.</td>
</tr>
<tr>
<td>DirectoryNotFoundException</td>
<td>The exception that is thrown when part of a file or directory cannot be found.</td>
</tr>
<tr>
<td>DriveInfo</td>
<td>Provides access to information on a drive.</td>
</tr>
<tr>
<td>DriveNotFoundException</td>
<td>The exception that is thrown when trying to access a drive or share that is not available.</td>
</tr>
<tr>
<td>EndOfStreamException</td>
<td>The exception that is thrown when reading is attempted past the end of a stream.</td>
</tr>
<tr>
<td>ErrorEventArgs</td>
<td>Provides data for the FileSystemWatcher.Error event.</td>
</tr>
<tr>
<td>File</td>
<td>Provides static methods for the creation, copying, deletion, moving, and opening of a single file, and aids in the creation of FileStream objects.</td>
</tr>
<tr>
<td>FileFormatException</td>
<td>The exception that is thrown when an input file or a data stream that is supposed to conform to a certain file format specification is malformed.</td>
</tr>
<tr>
<td>FileInfo</td>
<td>Provides properties and instance methods for the creation, copying, deletion, moving, and opening of files, and aids in the creation of FileStream objects.</td>
</tr>
<tr>
<td>FileLoadException</td>
<td>The exception that is thrown when a managed assembly is found but cannot be loaded.</td>
</tr>
<tr>
<td>FileNotFoundException</td>
<td>The exception that is thrown when an attempt to access a file that does not exist on disk fails.</td>
</tr>
<tr>
<td>FileStream</td>
<td>Exposes a Stream around a file, supporting both synchronous and asynchronous read and write operations.</td>
</tr>
<tr>
<td>FileSystemEventArgs</td>
<td>Provides data for the directory events &minus; Changed, Created, Deleted.</td>
</tr>
<tr>
<td>FileSystemInfo</td>
<td>Provides the base class for both FileInfo and DirectoryInfo objects.</td>
</tr>
<tr>
<td>FileSystemWatcher</td>
<td>Listens to the file system change notifications and raises events when a directory, or file in a directory, changes.</td>
</tr>
<tr>
<td>InternalBufferOverflowException</td>
<td>The exception thrown when the internal buffer overflows.</td>
</tr>
<tr>
<td>InvalidDataException</td>
<td>The exception that is thrown when a data stream is in an invalid format.</td>
</tr>
<tr>
<td>IODescriptionAttribute</td>
<td>Sets the description visual designers can display when referencing an event, extender, or property.</td>
</tr>
<tr>
<td>IOException</td>
<td>The exception that is thrown when an I/O error occurs.</td>
</tr>
<tr>
<td>MemoryStream</td>
<td>Creates a stream whose backing store is memory.</td>
</tr>
<tr>
<td>Path</td>
<td>Performs operations on String instances that contain file or directory path information. These operations are performed in a cross-platform manner.</td>
</tr>
<tr>
<td>PathTooLongException</td>
<td>The exception that is thrown when a path or file name is longer than the system-defined maximum length.</td>
</tr>
<tr>
<td>PipeException</td>
<td>Thrown when an error occurs within a named pipe.</td>
</tr>
<tr>
<td>RenamedEventArgs</td>
<td>Provides data for the Renamed event.</td>
</tr>
<tr>
<td>Stream</td>
<td>Provides a generic view of a sequence of bytes. This is an abstract class.</td>
</tr>
<tr>
<td>StreamReader</td>
<td>Implements a TextReader that reads characters from a byte stream in a particular encoding.</td>
</tr>
<tr>
<td>StreamWriter</td>
<td>Implements a TextWriter for writing characters to a stream in a particular encoding. To browse the .NET Framework source code for this type, see the Reference Source.</td>
</tr>
<tr>
<td>StringReader</td>
<td>Implements a TextReader that reads from a string.</td>
</tr>
<tr>
<td>StringWriter</td>
<td>Implements a TextWriter for writing information to a string. The information is stored in an underlying StringBuilder.</td>
</tr>
<tr>
<td>TextReader</td>
<td>Represents a reader that can read a sequential series of characters.</td>
</tr>
<tr>
<td>TextWriter</td>
<td>Represents a writer that can write a sequential series of characters. This class is abstract.</td>
</tr>
<tr>
<td>UnmanagedMemoryAccessor</td>
<td>Provides random access to unmanaged blocks of memory from managed code.</td>
</tr>
<tr>
<td>UnmanagedMemoryStream</td>
<td>Provides access to unmanaged blocks of memory from managed code.</td>
</tr>
<tr>
<td>WindowsRuntimeStorageExtensions</td>
<td>Contains extension methods for the IStorageFile and IStorageFolder interfaces in the Windows Runtime when developing Windows Store apps.</td>
</tr>
<tr>
<td>WindowsRuntimeStreamExtensions</td>
<td>Contains extension methods for converting between streams in the Windows Runtime and managed streams in the .NET for Windows Store apps.</td>
</tr>
</table>
<h3>Example</h3>
<p>The following example creates a file called test.txt, writes a message there, reads the text from the file and prints it on the console.</p>
<p><b>Note</b> &minus;  The amount of code needed to do this is surprisingly less!</p>
<pre class="prettyprint notranslate tryit">
open System.IO // Name spaces can be opened just as modules
File.WriteAllText("test.txt", "Hello There\n Welcome to:\n Tutorials Point")
let msg = File.ReadAllText("test.txt")
printfn "%s" msg
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Hello There
Welcome to:
Tutorials Point
</pre>

<title>F# Generics</title>

<h1>F# - Generics</h1>

<p>Generics allow you to delay the specification of the data type of programming elements in a class or a method, until it is actually used in the program. In other words, generics allow you to write a class or method that can work with any data type.</p>

<p>You write the specifications for the class or the method, with substitute parameters for data types. When the compiler encounters a constructor for the class or a function call for the method, it generates code to handle the specific data type.</p>

<p>In F#, function values, methods, properties, and aggregate types such as classes, records, and discriminated unions can be generic.</p>

<p>Generic constructs contain at least one type parameter. Generic functions and types enable you to write code that works with a variety of types without repeating the code for each type.</p>

<h2>Syntax</h2>

<p>Syntax for writing a generic construct is as follows &minus;</p>

<h2>Examples</h2>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>You can also make a function generic by using the single quotation mark syntax &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>Please note that when you use generic functions or methods, you might not have to specify the type arguments. However, in case of an ambiguity, you can provide type arguments in angle brackets as we did in the first example.</p>

<p>If you have more than one type, then you separate multiple type arguments with commas.</p>

<h2>Generic Class</h2>

<p>Like generic functions, you can also write generic classes. The following example demonstrates this &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
// Explicitly generic function.
let function-name&lt;type-parameters&gt; parameter-list =
   function-body

// Explicitly generic method.
[ static ] member object-identifer.method-name&lt;type-parameters&gt; parameter-list [ return-type ] =
   method-body

// Explicitly generic class, record, interface, structure,
// or discriminated union.
type type-name&lt;type-parameters&gt; type-definition
</pre>
<h2>Examples</h2>
<pre class="prettyprint notranslate tryit">
(* Generic Function *)
let printFunc<'T> x y =
   printfn "%A, %A" x y

printFunc&lt;float&gt; 10.0 20.0
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
10.0, 20.0
</pre>
<p>You can also make a function generic by using the single quotation mark syntax &minus;</p>
<pre class="prettyprint notranslate tryit">
(* Generic Function *)
let printFunction (x: 'a) (y: 'a) =
   printfn "%A %A" x y

printFunction 10.0 20.0
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
10.0 20.0
</pre>
<p>Please note that when you use generic functions or methods, you might not have to specify the type arguments. However, in case of an ambiguity, you can provide type arguments in angle brackets as we did in the first example.</p>
<p>If you have more than one type, then you separate multiple type arguments with commas.</p>
<h2>Generic Class</h2>
<p>Like generic functions, you can also write generic classes. The following example demonstrates this &minus;</p>
<pre class="prettyprint notranslate tryit">
type genericClass<'a> (x: 'a) =
   do printfn "%A" x

let gr = new genericClass&lt;string&gt;("zara")
let gs = genericClass( seq { for i in 1 .. 10 -> (i, i*i) } )
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
"zara"
seq [(1, 1); (2, 4); (3, 9); (4, 16); ...]
</pre>

<title>F# Delegates</title>

<h1>F# - Delegates</h1>

<p>A delegate is a reference type variable that holds the reference to a method. The reference can be changed at runtime. F# delegates are similar to pointers to functions, in C or C++.</p>

<h2>Declaring Delegates</h2>

<p>Delegate declaration determines the methods that can be referenced by the delegate. A delegate can refer to a method, which have the same signature as that of the delegate.</p>

<p>Syntax for delegate declaration is &minus;</p>

<p>For example, consider the delegates &minus;</p>

<p>Both the delegates can be used to reference any method that has two <i>int</i> parameters and returns an <i>int</i> type variable.</p>

<p>In the syntax &minus;</p>

<p>Please note &minus;</p>

<p>The argument types are automatically curried.</p>

<p>Delegates can be attached to function values, and static or instance methods.</p>

<p>F# function values can be passed directly as arguments to delegate constructors.</p>

<p>For a static method the delegate is called by using the name of the class and the method. For an instance method, the name of the object instance and method is used.</p>

<p>The Invoke method on the delegate type calls the encapsulated function.</p>

<p>Also, delegates can be passed as function values by referencing the Invoke method name without the parentheses.</p>

<p>The following example demonstrates the concept &minus;</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
type delegate-typename = delegate of type1 -&gt; type2
</pre>
<p>For example, consider the delegates &minus;</p>
<pre class="result notranslate">
// Delegate1 works with tuple arguments.
type Delegate1 = delegate of (int * int) -&gt; int
// Delegate2 works with curried arguments.
type Delegate2 = delegate of int * int -&gt; int
</pre>
<p>Both the delegates can be used to reference any method that has two <i>int</i> parameters and returns an <i>int</i> type variable.</p>
<p>In the syntax &minus;</p>
<ul class="list">
<li><p><b><i>type1</i></b> represents the argument type(s).<p></li>
<li><p><b><i>type2</i></b> represents the return type.<p></li>
</ul>
<p>Please note &minus;</p>
<ul class="list">
<li><p>The argument types are automatically curried.</p></li>
<li><p>Delegates can be attached to function values, and static or instance methods.</p></li>
<li><p>F# function values can be passed directly as arguments to delegate constructors.</p></li>
<li><p>For a static method the delegate is called by using the name of the class and the method. For an instance method, the name of the object instance and method is used.</p></li>
<li><p>The Invoke method on the delegate type calls the encapsulated function.</p></li>
<li><p>Also, delegates can be passed as function values by referencing the Invoke method name without the parentheses.</p></li>
</ul>
<p>The following example demonstrates the concept &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
type Myclass() =
   static member add(a : int, b : int) =
      a + b
   static member sub (a : int) (b : int) =
      a - b
   member x.Add(a : int, b : int) =
      a + b
   member x.Sub(a : int) (b : int) =
      a - b

// Delegate1 works with tuple arguments.
type Delegate1 = delegate of (int * int) -&gt; int
// Delegate2 works with curried arguments.
type Delegate2 = delegate of int * int -&gt; int

let InvokeDelegate1 (dlg : Delegate1) (a : int) (b: int) =
   dlg.Invoke(a, b)
let InvokeDelegate2 (dlg : Delegate2) (a : int) (b: int) =
   dlg.Invoke(a, b)

// For static methods, use the class name, the dot operator, and the
// name of the static method.
let del1 : Delegate1 = new Delegate1( Myclass.add )
let del2 : Delegate2 = new Delegate2( Myclass.sub )

let mc = Myclass()
// For instance methods, use the instance value name, the dot operator, and the instance method name.

let del3 : Delegate1 = new Delegate1( mc.Add )
let del4 : Delegate2 = new Delegate2( mc.Sub )

for (a, b) in [ (400, 200); (100, 45) ] do
   printfn "%d + %d = %d" a b (InvokeDelegate1 del1 a b)
   printfn "%d - %d = %d" a b (InvokeDelegate2 del2 a b)
   printfn "%d + %d = %d" a b (InvokeDelegate1 del3 a b)
   printfn "%d - %d = %d" a b (InvokeDelegate2 del4 a b)
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
400 + 200 = 600
400 - 200 = 200
400 + 200 = 600
400 - 200 = 200
100 + 45 = 145
100 - 45 = 55
100 + 45 = 145
100 - 45 = 55
</pre>

<title>F# Enumerations</title>

<h1>F# - Enumerations</h1>

<p>An enumeration is a set of named integer constants.</p>

<p>In F#, <b>enumerations,</b> also known as <b>enums,</b> are integral types where labels are assigned to a subset of the values. You can use them in place of literals to make code more readable and maintainable.</p>

<h2>Declaring Enumerations</h2>

<p>The general syntax for declaring an enumeration is &minus;</p>

<p>The following example demonstrates the use of enumerations &minus;</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
type enum-name =
   | value1 = integer-literal1
   | value2 = integer-literal2
...
</pre>
<p>The following example demonstrates the use of enumerations &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
// Declaration of an enumeration.
type Days =
   | Sun = 0
   | Mon = 1
   | Tues = 2
   | Wed = 3
   | Thurs = 4
   | Fri = 5
   | Sat = 6

// Use of an enumeration.
let weekend1 : Days = Days.Sat
let weekend2 : Days = Days.Sun
let weekDay1 : Days = Days.Mon

printfn "Monday: %A" weekDay1
printfn "Saturday: %A" weekend1
printfn "Sunday: %A" weekend2
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Monday: Mon
Saturday: Sat
Sunday: Sun
</pre>

<title>F# Pattern Matching</title>

<h1>F# - Pattern Matching</h1>

<p>Pattern matching allows you to “compare data with a logical structure or structures, decompose data into constituent parts, or extract information from data in various ways”.</p>

<p>In other terms, it provides a more flexible and powerful way of testing data against a series of conditions and performing some computations based on the condition met.</p>

<p>Conceptually, it is like a series of if… then statements.</p>

<h2>Syntax</h2>

<p>In high level terms, pattern matching follows this syntax in F# &minus;</p>

<p>Where,</p>

<h2>Example 1</h2>

<p>The following example, calculates the Fibonacci numbers using pattern matching syntax &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>You can also chain together multiple conditions, which return the same value. For example &minus;</p>

<h2>Example 2</h2>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Pattern Matching Functions</h2>

<p>F# allows you to write pattern matching functions using the <b>function</b> keyword &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Adding Filters or Guards to Patterns</h2>

<p>You can add filters, or guards, to patterns using the <b>when</b> keyword.</p>

<h3>Example 1</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h3>Example 2</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Pattern Matching with Tuples</h2>

<p>The following example demonstrates the pattern matching with tuples &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Pattern Matching with Records</h2>

<p>The following example demonstrates pattern matching with records &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
match expr with
| pat1 - result1
| pat2 -&gt; result2
| pat3 when expr2 -&gt; result3
| _ -&gt; defaultResult
</pre>
<p>Where,</p>
<ul class="list">
<li>Each | symbol defines a condition.</li>
<li>The -&gt; symbol means "if the condition is true, return this value...".</li>
<li>The _ symbol provides the default pattern, meaning that it matches all other things like a wildcard.</li>
</ul>
<h2>Example 1</h2>
<p>The following example, calculates the Fibonacci numbers using pattern matching syntax &minus;</p>
<pre class="prettyprint notranslate tryit">
let rec fib n =
   match n with
   | 0 -&gt; 0
   | 1 -&gt; 1
   | _ -&gt; fib (n - 1) + fib (n - 2)
for i = 1 to 10 do
   printfn "Fibonacci %d: %d" i (fib i)
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Fibonacci 1: 1
Fibonacci 2: 1
Fibonacci 3: 2
Fibonacci 4: 3
Fibonacci 5: 5
Fibonacci 6: 8
Fibonacci 7: 13
Fibonacci 8: 21
Fibonacci 9: 34
Fibonacci 10: 55
</pre>
<p>You can also chain together multiple conditions, which return the same value. For example &minus;</p>
<h2>Example 2</h2>
<pre class="prettyprint notranslate tryit">
let printSeason month =
   match month with
   | "December" | "January" | "February" -&gt; printfn "Winter"
   | "March" | "April" -&gt; printfn "Spring"
   | "May" | "June" -&gt; printfn "Summer"
   | "July" | "August" -&gt; printfn "Rainy"
   | "September" | "October" | "November" -&gt; printfn "Autumn"
   | _ -&gt; printfn "Season depends on month!"

printSeason "February"
printSeason "April"
printSeason "November"
printSeason "July"
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Winter
Spring
Autumn
Rainy
</pre>
<h2>Pattern Matching Functions</h2>
<p>F# allows you to write pattern matching functions using the <b>function</b> keyword &minus;</p>
<pre class="prettyprint notranslate tryit">
let getRate = function
   | "potato" -&gt; 10.00
   | "brinjal" -&gt; 20.50
   | "cauliflower" -&gt; 21.00
   | "cabbage" -&gt; 8.75
   | "carrot" -&gt; 15.00
   | _ -&gt; nan (* nan is a special value meaning "not a number" *)

printfn "%g"(getRate "potato")
printfn "%g"(getRate "brinjal")
printfn "%g"(getRate "cauliflower")
printfn "%g"(getRate "cabbage")
printfn "%g"(getRate "carrot")
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
10
20.5
21
8.75
15
</pre>
<h2>Adding Filters or Guards to Patterns</h2>
<p>You can add filters, or guards, to patterns using the <b>when</b> keyword.</p>
<h3>Example 1</h3>
<pre class="prettyprint notranslate tryit">
let sign = function
   | 0 -&gt; 0
   | x when x &lt; 0 -&gt; -1
   | x when x &gt; 0 -&gt; 1

printfn "%d" (sign -20)
printfn "%d" (sign 20)
printfn "%d" (sign 0)
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
-1
1
0
</pre>
<h3>Example 2</h3>
<pre class="prettyprint notranslate tryit">
let compareInt x =
   match x with
   | (var1, var2) when var1 > var2 -> printfn "%d is greater than %d" var1 var2
   | (var1, var2) when var1 &lt; var2 -&gt; printfn "%d is less than %d" var1 var2
   | (var1, var2) -> printfn "%d equals %d" var1 var2

compareInt (11,25)
compareInt (72, 10)
compareInt (0, 0)
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
11 is less than 25
72 is greater than 10
0 equals 0
</pre>
<h2>Pattern Matching with Tuples</h2>
<p>The following example demonstrates the pattern matching with tuples &minus;</p>
<pre class="prettyprint notranslate tryit">
let greeting (name, subject) =
   match (name, subject) with
   | ("Zara", _) -&gt; "Hello, Zara"
   | (name, "English") -&gt; "Hello, " + name + " from the department of English"
   | (name, _) when subject.StartsWith("Comp") -&gt; "Hello, " + name + " from the department of Computer Sc."
   | (_, "Accounts and Finance") -&gt; "Welcome to the department of Accounts and Finance!"
   | _ -&gt; "You are not registered into the system"

printfn "%s" (greeting ("Zara", "English"))
printfn "%s" (greeting ("Raman", "Computer Science"))
printfn "%s" (greeting ("Ravi", "Mathematics"))
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Hello, Zara
Hello, Raman from the department of Computer Sc.
You are not registered into the system
</pre>
<h2>Pattern Matching with Records</h2>
<p>The following example demonstrates pattern matching with records &minus;</p>
<pre class="prettyprint notranslate tryit">
type Point = { x: float; y: float }
let evaluatePoint (point: Point) =
   match point with
   | { x = 0.0; y = 0.0 } -&gt; printfn "Point is at the origin."
   | { x = xVal; y = 0.0 } -&gt; printfn "Point is on the x-axis. Value is %f." xVal
   | { x = 0.0; y = yVal } -&gt; printfn "Point is on the y-axis. Value is %f." yVal
   | { x = xVal; y = yVal } -&gt; printfn "Point is at (%f, %f)." xVal yVal

evaluatePoint { x = 0.0; y = 0.0 }
evaluatePoint { x = 10.0; y = 0.0 }
evaluatePoint { x = 0.0; y = 10.0 }
evaluatePoint { x = 10.0; y = 10.0 }
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Point is at the origin.
Point is on the x-axis. Value is 10.000000.
Point is on the y-axis. Value is 10.000000.
Point is at (10.000000, 10.000000).
</pre>

<title>F# Exception Handling</title>

<h1>F# - Exception Handling</h1>

<p>An exception is a problem that arises during the execution of a program. An F# exception is a response to an exceptional circumstance that arises while a program is running, such as an attempt to divide by zero.</p>

<p>Exceptions provide a way to transfer control from one part of a program to another. F# exception handling provides the following constructs &minus;</p>

<p>Let us start with the basic syntax of Exception Handling.</p>

<h2>Syntax</h2>

<p>Basic syntax for F# exception handling block is &minus;</p>

<p>Where,</p>

<p><b>exception-type</b> is the name of a new F# exception type.</p>

<p><b>argument-type</b> represents the type of an argument that can be supplied when you raise an exception of this type.</p>

<p>Multiple arguments can be specified by using a tuple type for argument-type.</p>

<p>The <b>try...with</b> expression is used for exception handling in the F# language.</p>

<p>Syntax for the try … with expression is &minus;</p>

<p>The <b>try...finally</b> expression allows you to execute clean-up code even if a block of code throws an exception.</p>

<p>Syntax for the try … finally expression is &minus;</p>

<p>The <b>raise</b> function is used to indicate that an error or exceptional condition has occurred. It also captures the information about the error in an exception object.</p>

<p>Syntax for the raise function is &minus;</p>

<p>The <b>failwith</b> function generates an F# exception.</p>

<p>Syntax for the failwith function is &minus;</p>

<p>The <b>invalidArg</b> function generates an argument exception.</p>

<h2>Example of Exception Handling</h2>

<h3>Example 1</h3>

<p>The following program shows the basic exception handling with a simple try… with block &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h3>Example 2</h3>

<p>F# provides an <b>exception</b> type for declaring exceptions. You can use an exception type directly in the filters in a <b>try...with</b> expression.</p>

<p>The following example demonstrates this &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h3>Example 3</h3>

<p>The following example demonstrates nested exception handling &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h3>Example 4</h3>

<p>The following function demonstrates the <b>failwith</b> function &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h3>Example 5</h3>

<p>The <b>invalidArg</b> function generates an argument exception. The following program demonstrates this &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>Some other information about the file and variable causing error in the system will also be displayed, depending upon the system.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
exception exception-type of argument-type
</pre>
<p>Where,</p>
<ul class="list">
<li><p><b>exception-type</b> is the name of a new F# exception type.</p></li>
<li><p><b>argument-type</b> represents the type of an argument that can be supplied when you raise an exception of this type.</p></li>
<li><p>Multiple arguments can be specified by using a tuple type for argument-type.</p></li>
</ul>
<p>The <b>try...with</b> expression is used for exception handling in the F# language.</p>
<p>Syntax for the try … with expression is &minus;</p>
<pre class="result notranslate">
try
   expression1
with
   | pattern1 -&gt; expression2
   | pattern2 -&gt; expression3
...
</pre>
<p>The <b>try...finally</b> expression allows you to execute clean-up code even if a block of code throws an exception.</p>
<p>Syntax for the try … finally expression is &minus;</p>
<pre class="result notranslate">
try
   expression1
finally
   expression2
</pre>
<p>The <b>raise</b> function is used to indicate that an error or exceptional condition has occurred. It also captures the information about the error in an exception object.</p>
<p>Syntax for the raise function is &minus;</p>
<pre class="result notranslate">
raise (expression)
</pre>
<p>The <b>failwith</b> function generates an F# exception.</p>
<p>Syntax for the failwith function is &minus;</p>
<pre class="result notranslate">
failwith error-message-string
</pre>
<p>The <b>invalidArg</b> function generates an argument exception.</p>
<pre class="result notranslate">
invalidArg parameter-name error-message-string
</pre>
<h2>Example of Exception Handling</h2>
<h3>Example 1</h3>
<p>The following program shows the basic exception handling with a simple try… with block &minus;</p>
<pre class="prettyprint notranslate tryit">
let divisionprog x y =
   try
      Some (x / y)
   with
      | :? System.DivideByZeroException -&gt; printfn "Division by zero!"; None

let result1 = divisionprog 100 0
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Division by zero!
</pre>
<h3>Example 2</h3>
<p>F# provides an <b>exception</b> type for declaring exceptions. You can use an exception type directly in the filters in a <b>try...with</b> expression.</p>
<p>The following example demonstrates this &minus;</p>
<pre class="prettyprint notranslate tryit">
exception Error1 of string
// Using a tuple type as the argument type.
exception Error2 of string * int

let myfunction x y =
   try
      if x = y then raise (Error1("Equal Number Error"))
      else raise (Error2("Error Not detected", 100))
   with
      | Error1(str) -&gt; printfn "Error1 %s" str
      | Error2(str, i) -&gt; printfn "Error2 %s %d" str i
myfunction 20 10
myfunction 5 5
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Error2 Error Not detected 100
Error1 Equal Number Error
</pre>
<h3>Example 3</h3>
<p>The following example demonstrates nested exception handling &minus;</p>
<pre class="prettyprint notranslate tryit">
exception InnerError of string
exception OuterError of string

let func1 x y =
   try
      try
         if x = y then raise (InnerError("inner error"))
         else raise (OuterError("outer error"))
      with
         | InnerError(str) -&gt; printfn "Error:%s" str
   finally
      printfn "From the finally block."

let func2 x y =
   try
      func1 x y
   with
      | OuterError(str) -&gt; printfn "Error: %s" str

func2 100 150
func2 100 100
func2 100 120
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
From the finally block.
Error: outer error
Error:inner error
From the finally block.
From the finally block.
Error: outer error
</pre>
<h3>Example 4</h3>
<p>The following function demonstrates the <b>failwith</b> function &minus;</p>
<pre class="prettyprint notranslate tryit">
let divisionFunc x y =
   if (y = 0) then failwith "Divisor cannot be zero."
   else
      x / y

let trydivisionFunc x y =
   try
      divisionFunc x y
   with
      | Failure(msg) -&gt; printfn "%s" msg; 0

let result1 = trydivisionFunc 100 0
let result2 = trydivisionFunc 100 4
printfn "%A" result1
printfn "%A" result2
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Divisor cannot be zero.
0
25
</pre>
<h3>Example 5</h3>
<p>The <b>invalidArg</b> function generates an argument exception. The following program demonstrates this &minus;</p>
<pre class="prettyprint notranslate tryit">
let days = [| "Sunday"; "Monday"; "Tuesday"; "Wednesday"; "Thursday"; "Friday"; "Saturday" |]
let findDay day =
   if (day &gt; 7 || day &lt; 1)
      then invalidArg "day" (sprintf "You have entered %d." day)
   days.[day - 1]

printfn "%s" (findDay 1)
printfn "%s" (findDay 5)
printfn "%s" (findDay 9)
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Sunday
Thursday
Unhandled Exception:
System.ArgumentException: You have entered 9.
…
</pre>

<title>F# Classes</title>

<h1>F# - Classes</h1>

<p>Classes are types that represent objects that can have properties, methods, and events. ‘They are used to model actions, processes, and any conceptual entities in applications’.</p>

<h2>Syntax</h2>

<p>Syntax for defining a class type is as follows &minus;</p>

<p>Where,</p>

<p>The <b>type-name</b> is any valid identifier. Default access modifier for this is <b>public</b>.</p>

<p>The <b>type-params</b> describes optional generic type parameters.</p>

<p>The <b>parameter-list</b> describes constructor parameters. Default access modifier for primary constructor is <b>public</b>.</p>

<p>The <b>identifier</b> used with the optional <b>as</b> keyword gives a name to the instance variable, or <b>self-identifier,</b> which can be used in the type definition to refer to the instance of the type.</p>

<p>The <b>inherit</b> keyword allows you to specify the base class for a class.</p>

<p>The <b>let</b> bindings allow you to declare fields or function values local to the class.</p>

<p>The <b>do-bindings</b> section includes code to be executed upon object construction.</p>

<p>The <b>member-list</b> consists of additional constructors, instance and static method declarations, interface declarations, abstract bindings, and property and event declarations.</p>

<p>The keywords <b>class</b> and <b>end</b> that mark the start and end of the definition are optional.</p>

<h2>Constructor of a Class</h2>

<p>The constructor is code that creates an instance of the class type.</p>

<p>In F#, constructors work little differently than other .Net languages. In the class definition, the arguments of the primary constructor are described as parameter-list.</p>

<p>The body of the constructor consists of the <b>let</b> and <b>do</b> bindings.</p>

<p>You can add additional constructors by using the new keyword to add a member &minus;</p>

<p>The following example illustrates the concept &minus;</p>

<h3>Example</h3>

<p>The following program creates a line class along with a constructor that calculates the length of the line while an object of the class is created &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Let Bindings</h2>

<p>The let bindings in a class definition allow you to define private fields and private functions for F# classes.</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>Please note the use of self-identifier <i>gr</i> for the <i>Greetings</i> class.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
// Class definition:
type [access-modifier] type-name [type-params] [access-modifier] ( parameter-list ) [ as identifier ] =
   [ class ]
      [ inherit base-type-name(base-constructor-args) ]
      [ let-bindings ]
      [ do-bindings ]
      member-list
      ...
   [ end ]

// Mutually recursive class definitions:
type [access-modifier] type-name1 ...
and [access-modifier] type-name2 ...
...
</pre>
<p>Where,</p>
<ul class="list">
<li><p>The <b>type-name</b> is any valid identifier. Default access modifier for this is <b>public</b>.</p></li>
<li><p>The <b>type-params</b> describes optional generic type parameters.</p></li>
<li><p>The <b>parameter-list</b> describes constructor parameters. Default access modifier for primary constructor is <b>public</b>.</p></li>
<li><p>The <b>identifier</b> used with the optional <b>as</b> keyword gives a name to the instance variable, or <b>self-identifier,</b> which can be used in the type definition to refer to the instance of the type.</p></li>
<li><p>The <b>inherit</b> keyword allows you to specify the base class for a class.</p></li>
<li><p>The <b>let</b> bindings allow you to declare fields or function values local to the class.</p></li>
<li><p>The <b>do-bindings</b> section includes code to be executed upon object construction.</p></li>
<li><p>The <b>member-list</b> consists of additional constructors, instance and static method declarations, interface declarations, abstract bindings, and property and event declarations.</p></li>
<li><p>The keywords <b>class</b> and <b>end</b> that mark the start and end of the definition are optional.</p></li>
</ul>
<h2>Constructor of a Class</h2>
<p>The constructor is code that creates an instance of the class type.</p>
<p>In F#, constructors work little differently than other .Net languages. In the class definition, the arguments of the primary constructor are described as parameter-list.</p>
<p>The body of the constructor consists of the <b>let</b> and <b>do</b> bindings.</p>
<p>You can add additional constructors by using the new keyword to add a member &minus;</p>
<pre class="result notranslate">
new (argument-list) = constructor-body
</pre>
<p>The following example illustrates the concept &minus;</p>
<h3>Example</h3>
<p>The following program creates a line class along with a constructor that calculates the length of the line while an object of the class is created &minus;</p>
<pre class="prettyprint notranslate tryit">
type Line = class
   val X1 : float
   val Y1 : float
   val X2 : float
   val Y2 : float

   new (x1, y1, x2, y2) as this =
      { X1 = x1; Y1 = y1; X2 = x2; Y2 = y2;}
      then
         printfn " Creating Line: {(%g, %g), (%g, %g)}\nLength: %g"
            this.X1 this.Y1 this.X2 this.Y2 this.Length

   member x.Length =
      let sqr x = x * x
      sqrt(sqr(x.X1 - x.X2) + sqr(x.Y1 - x.Y2) )
end
let aLine = new Line(1.0, 1.0, 4.0, 5.0)
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Creating Line: {(1, 1), (4, 5)}
Length: 5
</pre>
<h2>Let Bindings</h2>
<p>The let bindings in a class definition allow you to define private fields and private functions for F# classes.</p>
<pre class="prettyprint notranslate tryit">
type Greetings(name) as gr =
   let data = name
   do
      gr.PrintMessage()
   member this.PrintMessage() =
      printf "Hello %s\n" data
let gtr = new Greetings("Zara")
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Hello Zara
</pre>

<title>F# Structures</title>

<h1>F# - Structures</h1>

<p>A structure in F# is a value type data type. It helps you to make a single variable, hold related data of various data types. The <b>struct</b> keyword is used for creating a structure.</p>

<h2>Syntax</h2>

<p>Syntax for defining a structure is as follows &minus;</p>

<p>There are two syntaxes. The first syntax is mostly used, because, if you use the <b>struct</b> and <b>end</b> keywords, you can omit the <b>StructAttribute</b> attribute.</p>

<p>The structure definition elements provide &minus;</p>

<p>Unlike classes, structures cannot be inherited and cannot contain let or do bindings. Since, structures do not have let bindings; you must declare fields in structures by using the <b>val</b> keyword.</p>

<p>When you define a field and its type using <b>val</b> keyword, you cannot initialize the field value, instead they are initialized to zero or null. So for a structure having an implicit constructor, the <b>val</b> declarations be annotated with the <b>DefaultValue</b> attribute.</p>

<h2>Example</h2>

<p>The following program creates a line structure along with a constructor. The program calculates the length of a line using the structure &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
[ attributes ]
type [accessibility-modifier] type-name =
   struct
      type-definition-elements
   end
// or
[ attributes ]
[&lt;StructAttribute&gt;]
type [accessibility-modifier] type-name =
   type-definition-elements
</pre>
<p>There are two syntaxes. The first syntax is mostly used, because, if you use the <b>struct</b> and <b>end</b> keywords, you can omit the <b>StructAttribute</b> attribute.</p>
<p>The structure definition elements provide &minus;</p>
<ul class="list">
<li>Member declarations and definitions.</li>
<li>Constructors and mutable and immutable fields.</li>
<li>Members and interface implementations.</li>
</ul>
<p>Unlike classes, structures cannot be inherited and cannot contain let or do bindings. Since, structures do not have let bindings; you must declare fields in structures by using the <b>val</b> keyword.</p>
<p>When you define a field and its type using <b>val</b> keyword, you cannot initialize the field value, instead they are initialized to zero or null. So for a structure having an implicit constructor, the <b>val</b> declarations be annotated with the <b>DefaultValue</b> attribute.</p>
<h2>Example</h2>
<p>The following program creates a line structure along with a constructor. The program calculates the length of a line using the structure &minus;</p>
<pre class="prettyprint notranslate tryit">
type Line = struct
   val X1 : float
   val Y1 : float
   val X2 : float
   val Y2 : float

   new (x1, y1, x2, y2) =
      {X1 = x1; Y1 = y1; X2 = x2; Y2 = y2;}
end
let calcLength(a : Line)=
   let sqr a = a * a
   sqrt(sqr(a.X1 - a.X2) + sqr(a.Y1 - a.Y2) )

let aLine = new Line(1.0, 1.0, 4.0, 5.0)
let length = calcLength aLine
printfn "Length of the Line: %g " length
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Length of the Line: 5
</pre>

<title>F# Operator Overloading</title>

<h1>F# - Operator Overloading</h1>

<p>You can redefine or overload most of the built-in operators available in F#. Thus a programmer can use operators with user-defined types as well.</p>

<p>Operators are functions with special names, enclosed in brackets. They must be defined as static class members. Like any other function, an overloaded operator has a return type and a parameter list.</p>

<p>The following example, shows a &plus; operator on complex numbers &minus;</p>

<p>The above function implements the addition operator (&plus;) for a user-defined class Complex. It adds the attributes of two objects and returns the resultant Complex object.</p>

<h2>Implementation of Operator Overloading</h2>

<p>The following program shows the complete implementation &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
//overloading &plus; operator
static member (&plus;) (a : Complex, b: Complex) =
Complex(a.x &plus; b.x, a.y &plus; b.y)
</pre>
<p>The above function implements the addition operator (&plus;) for a user-defined class Complex. It adds the attributes of two objects and returns the resultant Complex object.</p>
<h2>Implementation of Operator Overloading</h2>
<p>The following program shows the complete implementation &minus;</p>
<pre class="prettyprint notranslate tryit">
//implementing a complex class with +, and - operators
//overloaded
type Complex(x: float, y : float) =
   member this.x = x
   member this.y = y
   //overloading + operator
   static member (+) (a : Complex, b: Complex) =
      Complex(a.x + b.x, a.y + b.y)

   //overloading - operator
   static member (-) (a : Complex, b: Complex) =
      Complex(a.x - b.x, a.y - b.y)

   // overriding the ToString method
   override this.ToString() =
      this.x.ToString() + " " + this.y.ToString()

//Creating two complex numbers
let c1 = Complex(7.0, 5.0)
let c2 = Complex(4.2, 3.1)

// addition and subtraction using the
//overloaded operators
let c3 = c1 + c2
let c4 = c1 - c2

//printing the complex numbers
printfn "%s" (c1.ToString())
printfn "%s" (c2.ToString())
printfn "%s" (c3.ToString())
printfn "%s" (c4.ToString())
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
7 5
4.2 3.1
11.2 8.1
2.8 1.9
</pre>

<title>F# Inheritance</title>

<h1>F# - Inheritance</h1>

<p>One of the most important concepts in object-oriented programming is that of inheritance. Inheritance allows us to define a class in terms of another class, which makes it easier to create and maintain an application. This also provides an opportunity to reuse the code functionality and fast implementation time.</p>

<p>When creating a class, instead of writing completely new data members and member functions, the programmer can designate that the new class should inherit the members of an existing class. This existing class is called the base class, and the new class is referred to as the derived class.</p>

<p>The idea of inheritance implements the IS-A relationship. For example, mammal IS A animal, dog IS-A mammal hence dog IS-A animal as well and so on.</p>

<h2>Base Class and Sub Class</h2>

<p>A subclass is derived from a base class, which is already defined. A subclass inherits the members of the base class, as well as has its own members.</p>

<p>A subclass is defined using the <b>inherit</b> keyword as shown below &minus;</p>

<p>In F#, a class can have at most one direct base class. If you do not specify a base class by using the <b>inherit</b> keyword, the class implicitly inherits from Object.</p>

<p>Please note &minus;</p>

<p>The methods and members of the base class are available to users of the derived class like the direct members of the derived class.</p>

<p>Let bindings and constructor parameters are private to a class and, therefore, cannot be accessed from derived classes.</p>

<p>The keyword <b>base</b> refers to the base class instance. It is used like the self-identifier.</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Overriding Methods</h2>

<p>You can override a default behavior of a base class method and implement it differently in the subclass or the derived class.</p>

<p>Methods in F# are not overridable by default.</p>

<p>To override methods in a derived class, you have to declare your method as overridable using the <b>abstract</b> and <b>default</b> keywords as follows &minus;</p>

<p>Now, the <i>Greet</i> method of the Person class can be overridden in derived classes. The following example demonstrates this &minus;</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Abstract Class</h2>

<p>At times you need to provide an incomplete implementation of an object, which should not be implemented in reality. Later, some other programmer should create subclasses of the abstract class to a complete implementation.</p>

<p>For example, the Person class will not be needed in a School Management System. However, the Student or the Teacher class will be needed. In such cases, you can declare the Person class as an abstract class.</p>

<p>The <b>AbstractClass</b> attribute tells the compiler that the class has some abstract members.</p>

<p>You cannot create an instance of an abstract class because the class is not fully implemented.</p>

<p>The following example demonstrates this &minus;</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
type MyDerived(...) =
   inherit MyBase(...)
</pre>
<p>In F#, a class can have at most one direct base class. If you do not specify a base class by using the <b>inherit</b> keyword, the class implicitly inherits from Object.</p>
<p>Please note &minus;</p>
<ul class="list">
<li><p>The methods and members of the base class are available to users of the derived class like the direct members of the derived class.</p></li>
<li><p>Let bindings and constructor parameters are private to a class and, therefore, cannot be accessed from derived classes.</p></li>
<li><p>The keyword <b>base</b> refers to the base class instance. It is used like the self-identifier.</p></li>
</ul>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
type Person(name) =
   member x.Name = name
   member x.Greet() = printfn "Hi, I'm %s" x.Name

type Student(name, studentID : int) =
   inherit Person(name)
   let mutable _GPA = 0.0
   member x.StudentID = studentID
   member x.GPA
      with get() = _GPA
      and set value = _GPA &lt;- value

type Teacher(name, expertise : string) =
   inherit Person(name)

   let mutable _salary = 0.0
   member x.Salary
      with get() = _salary
      and set value = _salary &lt;- value
   member x.Expertise = expertise

//using the subclasses
let p = new Person("Mohan")
let st = new Student("Zara", 1234)
let tr = new Teacher("Mariam", "Java")

p.Greet()
st.Greet()
tr.Greet()
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Hi, I'm Mohan
Hi, I'm Zara
Hi, I'm Mariam
</pre>
<h2>Overriding Methods</h2>
<p>You can override a default behavior of a base class method and implement it differently in the subclass or the derived class.</p>
<p>Methods in F# are not overridable by default.</p>
<p>To override methods in a derived class, you have to declare your method as overridable using the <b>abstract</b> and <b>default</b> keywords as follows &minus;</p>
<pre class="result notranslate">
type Person(name) =
   member x.Name = name
   abstract Greet : unit -&gt; unit
   default x.Greet() = printfn "Hi, I'm %s" x.Name
</pre>
<p>Now, the <i>Greet</i> method of the Person class can be overridden in derived classes. The following example demonstrates this &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
type Person(name) =
   member x.Name = name
   abstract Greet : unit -&gt; unit
   default x.Greet() = printfn "Hi, I'm %s" x.Name

type Student(name, studentID : int) =
   inherit Person(name)

   let mutable _GPA = 0.0

   member x.StudentID = studentID
   member x.GPA
      with get() = _GPA
      and set value = _GPA &lt;- value
   override x.Greet() = printfn "Student %s" x.Name

type Teacher(name, expertise : string) =
   inherit Person(name)
   let mutable _salary = 0.0
   member x.Salary
      with get() = _salary
      and set value = _salary &lt;- value

   member x.Expertise = expertise
   override x.Greet() = printfn "Teacher %s." x.Name

//using the subclasses
let p = new Person("Mohan")
let st = new Student("Zara", 1234)
let tr = new Teacher("Mariam", "Java")

//default Greet
p.Greet()

//Overriden Greet
st.Greet()
tr.Greet()
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Hi, I'm Mohan
Student Zara
Teacher Mariam.
</pre>
<h2>Abstract Class</h2>
<p>At times you need to provide an incomplete implementation of an object, which should not be implemented in reality. Later, some other programmer should create subclasses of the abstract class to a complete implementation.</p>
<p>For example, the Person class will not be needed in a School Management System. However, the Student or the Teacher class will be needed. In such cases, you can declare the Person class as an abstract class.</p>
<p>The <b>AbstractClass</b> attribute tells the compiler that the class has some abstract members.</p>
<p>You cannot create an instance of an abstract class because the class is not fully implemented.</p>
<p>The following example demonstrates this &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
[&lt;AbstractClass&gt;]
type Person(name) =
   member x.Name = name
   abstract Greet : unit -&gt; unit

type Student(name, studentID : int) =
   inherit Person(name)
   let mutable _GPA = 0.0
   member x.StudentID = studentID
   member x.GPA
      with get() = _GPA
      and set value = _GPA &lt;- value
   override x.Greet() = printfn "Student %s" x.Name

type Teacher(name, expertise : string) =
   inherit Person(name)
   let mutable _salary = 0.0
   member x.Salary
      with get() = _salary
      and set value = _salary &lt;- value
   member x.Expertise = expertise
   override x.Greet() = printfn "Teacher %s." x.Name

let st = new Student("Zara", 1234)
let tr = new Teacher("Mariam", "Java")

//Overriden Greet
st.Greet()
tr.Greet()
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Student Zara
Teacher Mariam.
</pre>

<title>F# Interfaces</title>

<h1>F# - Interfaces</h1>

<p>Interfaces provide an abstract way of writing up the implementation details of a class. It is a template that declares the methods the class must implement and expose publicly.</p>

<h2>Syntax</h2>

<p>An interface specifies the sets of related members that other classes implement. It has the following syntax &minus;</p>

<p>Please note &minus;</p>

<p>In an interface declaration the members are not implemented.</p>

<p>The members are abstract, declared by the <b>abstract</b> keyword. However you may provide a default implementation using the <b>default</b> keyword.</p>

<p>You can implement interfaces either by using object expressions or by using class types.</p>

<p>In class or object implementation, you need to provide method bodies for abstract methods of the interface.</p>

<p>The keywords <b>interface</b> and <b>end,</b> which mark the start and end of the definition, are optional.</p>

<p>For example,</p>

<h2>Calling Interface Methods</h2>

<p>Interface methods are called through the interface, not through the instance of the class or type implementing interface. To call an interface method, you up cast to the interface type by using the <b>:&gt;</b> operator (upcast operator).</p>

<p>For example,</p>

<p>The following example illustrates the concept &minus;</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Interface Inheritance</h2>

<p>Interfaces can inherit from one or more base interfaces.</p>

<p>The following example shows the concept &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
// Interface declaration:
[ attributes ]
type interface-name =
   [ interface ]
      [ inherit base-interface-name ...]
      abstract member1 : [ argument-types1 -> ] return-type1
      abstract member2 : [ argument-types2 -> ] return-type2
      ...
   [ end ]
	
// Implementing, inside a class type definition:
interface interface-name with
   member self-identifier.member1 argument-list = method-body1
   member self-identifier.member2 argument-list = method-body2
// Implementing, by using an object expression:
[ attributes ]
let class-name (argument-list) =
   { new interface-name with
      member self-identifier.member1 argument-list = method-body1
      member self-identifier.member2 argument-list = method-body2
      [ base-interface-definitions ]
   }
member-list
</pre>
<p>Please note &minus;</p>
<ul class="list">
<li><p>In an interface declaration the members are not implemented.</p></li>
<li><p>The members are abstract, declared by the <b>abstract</b> keyword. However you may provide a default implementation using the <b>default</b> keyword.</p></li>
<li><p>You can implement interfaces either by using object expressions or by using class types.</p></li>
<li><p>In class or object implementation, you need to provide method bodies for abstract methods of the interface.</p></li>
<li><p>The keywords <b>interface</b> and <b>end,</b> which mark the start and end of the definition, are optional.</p></li>
</ul>
<p>For example,</p>
<pre class="result notranslate">
type IPerson =
   abstract Name : string
   abstract Enter : unit -&gt; unit
   abstract Leave : unit -&gt; unit
</pre>
<h2>Calling Interface Methods</h2>
<p>Interface methods are called through the interface, not through the instance of the class or type implementing interface. To call an interface method, you up cast to the interface type by using the <b>:&gt;</b> operator (upcast operator).</p>
<p>For example,</p>
<pre class="result notranslate">
(s :&gt; IPerson).Enter()
(s :&gt; IPerson).Leave()
</pre>
<p>The following example illustrates the concept &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
type IPerson =
   abstract Name : string
   abstract Enter : unit -&gt; unit
   abstract Leave : unit -&gt; unit

type Student(name : string, id : int) =
   member this.ID = id
   interface IPerson with
      member this.Name = name
      member this.Enter() = printfn "Student entering premises!"
      member this.Leave() = printfn "Student leaving premises!"

type StuffMember(name : string, id : int, salary : float) =
   let mutable _salary = salary

   member this.Salary
      with get() = _salary
      and set(value) = _salary &lt;- value

   interface IPerson with
      member this.Name = name
      member this.Enter() = printfn "Stuff member entering premises!"
      member this.Leave() = printfn "Stuff member leaving premises!"

let s = new Student("Zara", 1234)
let st = new StuffMember("Rohit", 34, 50000.0)

(s :&gt; IPerson).Enter()
(s :&gt; IPerson).Leave()
(st :&gt; IPerson).Enter()
(st :&gt; IPerson).Leave()
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Student entering premises!
Student leaving premises!
Stuff member entering premises!
Stuff member leaving premises!
</pre>
<h2>Interface Inheritance</h2>
<p>Interfaces can inherit from one or more base interfaces.</p>
<p>The following example shows the concept &minus;</p>
<pre class="prettyprint notranslate tryit">
type Interface1 =
   abstract member doubleIt: int -&gt; int

type Interface2 =
   abstract member tripleIt: int -&gt; int

type Interface3 =
   inherit Interface1
   inherit Interface2
   abstract member printIt: int -&gt; string

type multiplierClass() =
   interface Interface3 with
      member this.doubleIt(a) = 2 * a
      member this.tripleIt(a) = 3 * a
      member this.printIt(a) = a.ToString()

let ml = multiplierClass()
printfn "%d" ((ml:&gt;Interface3).doubleIt(5))
printfn "%d" ((ml:&gt;Interface3).tripleIt(5))
printfn "%s" ((ml:&gt;Interface3).printIt(5))
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
10
15
5
</pre>

<title>F# Events</title>

<h1>F# - Events</h1>

<p>Events allow classes to send and receive messages between one another.</p>

<p>In GUI, events are user actions like key press, clicks, mouse movements, etc., or some occurrence like system generated notifications. Applications need to respond to events when they occur. For example, interrupts. Events are used for inter-process communication.</p>

<p>Objects communicate with one another through synchronous message passing.</p>

<p>Events are attached to other functions; objects register <b>callback</b> functions to an event, and these callbacks are executed when (and if) the event is triggered by some object.</p>

<h2>The Event Class and Event Module</h2>

<p>The Control.Event&lt;'T&gt; Class helps in creating an observable object or event.</p>

<p>It has the following instance members to work with the events &minus;</p>

<p>The Control.Event Module provides functions for managing event streams &minus;</p>

<h2>Creating Events</h2>

<p>Events are created and used through the <b>Event</b> class. The Event constructor is used for creating an event.</p>

<h3>Example</h3>

<p>After this you need to expose the nameChanged field as a public member, so that the listeners can hook onto the event for which, you use the <b>Publish</b> property of the event &minus;</p>

<p>Next, you add callbacks to event handlers. Each event handler has the type IEvent&lt;'T&gt;, which provides several methods &minus;</p>

<p>The following section provides a complete example.</p>

<h3>Example</h3>

<p>The following example demonstrates the concept and techniques discussed above &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
type Worker(name : string, shift : string) =
   let mutable _name = name;
   let mutable _shift = shift;
   let nameChanged = new Event&lt;unit&gt;() (* creates event *)
   let shiftChanged = new Event&lt;unit&gt;() (* creates event *)

   member this.Name
      with get() = _name
      and set(value) = _name &lt;- value

   member this.Shift
      with get() = _shift
      and set(value) = _shift &lt;- value
</pre>
<p>After this you need to expose the nameChanged field as a public member, so that the listeners can hook onto the event for which, you use the <b>Publish</b> property of the event &minus;</p>
<pre class="prettyprint notranslate">
type Worker(name : string, shift : string) =
   let mutable _name = name;
   let mutable _shift = shift;

   let nameChanged = new Event&lt;unit&gt;() (* creates event *)
   let shiftChanged = new Event&lt;unit&gt;() (* creates event *)

   member this.NameChanged = nameChanged.Publish (* exposed event handler *)
   member this.ShiftChanged = shiftChanged.Publish (* exposed event handler *)

   member this.Name
      with get() = _name
      and set(value) = _name &lt;- value
      nameChanged.Trigger() (* invokes event handler *)

   member this.Shift
      with get() = _shift
      and set(value) = _shift &lt;- value
   shiftChanged.Trigger() (* invokes event handler *)
</pre>
<p>Next, you add callbacks to event handlers. Each event handler has the type IEvent&lt;'T&gt;, which provides several methods &minus;</p>
<table class="table table-bordered">
<tr>
<th style="width:40%;">Method</td>
<th>Description</td>
</tr>
<tr>
<td>val Add : event:('T &rarr; unit) &rarr; unit</td>
<td>Connects a listener function to the event. The listener will be invoked when the event is fired.</td>
</tr>
<tr>
<td>val AddHandler : 'del &rarr; unit</td>
<td>Connects a handler delegate object to the event. A handler can be later removed using RemoveHandler. The listener will be invoked when the event is fired.</td>
</tr>
<tr>
<td>val RemoveHandler : 'del &rarr; unit</td>
<td>Removes a listener delegate from an event listener store.</td>
</tr>
</table>
<p>The following section provides a complete example.</p>
<h3>Example</h3>
<p>The following example demonstrates the concept and techniques discussed above &minus;</p>
<pre class="prettyprint notranslate tryit">
type Worker(name : string, shift : string) =
   let mutable _name = name;
   let mutable _shift = shift;

   let nameChanged = new Event&lt;unit&gt;() (* creates event *)
   let shiftChanged = new Event&lt;unit&gt;() (* creates event *)

   member this.NameChanged = nameChanged.Publish (* exposed event handler *)
   member this.ShiftChanged = shiftChanged.Publish (* exposed event handler *)

   member this.Name
      with get() = _name
      and set(value) = 
         _name &lt;- value
         nameChanged.Trigger() (* invokes event handler *)

   member this.Shift
      with get() = _shift
      and set(value) = 
         _shift &lt;- value
         shiftChanged.Trigger() (* invokes event handler *)

let wk = new Worker("Wilson", "Evening")
wk.NameChanged.Add(fun () -&gt; printfn "Worker changed name! New name: %s" wk.Name)
wk.Name &lt;- "William"
wk.NameChanged.Add(fun () -&gt; printfn "-- Another handler attached to NameChanged!")
wk.Name &lt;- "Bill"

wk.ShiftChanged.Add(fun () -&gt; printfn "Worker changed shift! New shift: %s" wk.Shift)
wk.Shift &lt;- "Morning"
wk.ShiftChanged.Add(fun () -&gt; printfn "-- Another handler attached to ShiftChanged!")
wk.Shift &lt;- "Night"
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Worker changed name! New name: William
Worker changed name! New name: Bill
-- Another handler attached to NameChanged!
Worker changed shift! New shift: Morning
Worker changed shift! New shift: Night
-- Another handler attached to ShiftChanged!
</pre>

<title>F# Modules</title>

<h1>F# - Modules</h1>

<p>As per MSDN library, an F# module is a grouping of F# code constructs, such as types, values, function values, and code in do bindings. It is implemented as a common language runtime (CLR) class that has only static members.</p>

<p>Depending upon the situation whether the whole file is included in the module, there are two types of module declarations &minus;</p>

<p>In a top-level module declaration the whole file is included in the module. In this case, the first declaration in the file is the module declaration. You do not have to indent declarations in a top-level module.</p>

<p>In a local module declaration, only the declarations that are indented under that module declaration are part of the module.</p>

<h2>Syntax</h2>

<p>Syntax for module declaration is as follows &minus;</p>

<p>Please note that the accessibility-modifier can be one of the following &minus; public, private, internal. The default is <b>public</b>.</p>

<p>The following examples will demonstrate the concepts &minus;</p>

<h2>Example 1</h2>

<p>The module file Arithmetic.fs &minus;</p>

<p>The program file main.fs &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Example 2</h2>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
// Top-level module declaration.
module [accessibility-modifier] [qualified-namespace.]module-name
   declarations
// Local module declaration.
module [accessibility-modifier] module-name =
   declarations
</pre>
<p>Please note that the accessibility-modifier can be one of the following &minus; public, private, internal. The default is <b>public</b>.</p>
<p>The following examples will demonstrate the concepts &minus;</p>
<h2>Example 1</h2>
<p>The module file Arithmetic.fs &minus;</p>
<pre class="prettyprint notranslate">
module Arithmetic
let add x y =
   x + y

let sub x y =
   x - y
	
let mult x y =
   x * y
	
let div x y =
   x / y
</pre>
<p>The program file main.fs &minus;</p>
<pre class="prettyprint notranslate">
// Fully qualify the function name.
open Arithmetic
let addRes = Arithmetic.add 25 9
let subRes = Arithmetic.sub 25 9
let multRes = Arithmetic.mult 25 9
let divRes = Arithmetic.div 25 9

printfn "%d" addRes
printfn "%d" subRes
printfn "%d" multRes
printfn "%d" divRes
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
34
16
225
2
110
90
1000
10
</pre>
<h2>Example 2</h2>
<pre class="prettyprint notranslate tryit">
// Module1
module module1 =
   // Indent all program elements within modules that are declared with an equal sign.
   let value1 = 100
   let module1Function x =
      x + value1

// Module2
module module2 =
   let value2 = 200

   // Use a qualified name to access the function.
   // from module1.
   let module2Function x =
      x + (module1.module1Function value2)

let result = module1.module1Function 25
printfn "%d" result

let result2 = module2.module2Function 25
printfn "%d" result2
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
125
325
</pre>

<title>F# Namespaces</title>

<h1>F# - Namespaces</h1>

<p>A <b>namespace</b> is designed for providing a way to keep one set of names separate from another. The class names declared in one namespace will not conflict with the same class names declared in another.</p>

<p>As per the MSDN library, a <b>namespace</b> lets you organize code into areas of related functionality by enabling you to attach a name to a grouping of program elements.</p>

<h2>Declaring a Namespace</h2>

<p>To organize your code in a namespace, you must declare the namespace as the first declaration in the file. The contents of the entire file then become part of the namespace.</p>

<p>The following example illustrates the concept &minus;</p>

<h2>Example</h2>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
namespace [parent-namespaces.]identifier
</pre>
<p>The following example illustrates the concept &minus;</p>
<h2>Example</h2>
<pre class="prettyprint notranslate tryit">
namespace testing

module testmodule1 =
   let testFunction x y =
      printfn "Values from Module1: %A %A" x y
module testmodule2 =
   let testFunction x y =
      printfn "Values from Module2: %A %A" x y

module usermodule =
   do
      testmodule1.testFunction ( "one", "two", "three" ) 150
      testmodule2.testFunction (seq { for i in 1 .. 10 do yield i * i }) 200
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Values from Module1: ("one", "two", "three") 150
Values from Module2: seq [1; 4; 9; 16; ...] 200
</pre>

<title>F# Quick Guide</title>

<h1>F# - Quick Guide</h1>

<h1>F# - Overview</h1>

<p>F# is a functional programming language. To understand F# constructs, you need to read a couple of lines about the programming paradigm named <b>Functional Programming</b>.</p>

<p>Functional programming treats computer programs as mathematical functions. In functional programming, the focus would be on constants and functions, instead of variables and states. Because functions and constants are things that don’t change.</p>

<p>In functional programming, you will write modular programs, i.e., the programs would consist of functions that will take other functions as input.</p>

<p>Programs written in functional programming language tend to be concise.</p>

<h2>About F#</h2>

<p>Following are the basic information about F# &minus;</p>

<h2>Features of F#</h2>

<p>It is .Net implementation of OCaml.</p>

<p>It compiles .Net CLI (Common Language Interface) byte code or MSIL (Microsoft Intermediate Language) that runs on CLR (Common Language Runtime).</p>

<p>It provides type inference.</p>

<p>It provides rich pattern matching constructs.</p>

<p>It has interactive scripting and debugging capabilities.</p>

<p>It allows writing higher order functions.</p>

<p>It provides well developed object model.</p>

<h2>Use of F#</h2>

<p>F# is normally used in the following areas &minus;</p>

<p>It is also used in CRUD apps, web pages, GUI games and other general purpose programs.</p>

<h1>F# - Environment Setup</h1>

<p>The tools required for F# programming are discussed in this chapter.</p>

<h2>Integrated Development Environment(IDE) for F#</h2>

<p>Microsoft provides Visual Studio 2013 for F# programming.</p>

<p>The free Visual Studio 2013 Community Edition is available from Microsoft’s official website. Visual Studio 2013 Community and above comes with the Visual F# Tools. The Visual F# Tools include the command-line compiler (fsc.exe) and F# Interactive (fsi.exe).</p>

<p>Using these tools, you can write all kinds of F# programs from simple command-line applications to more complex applications. You can also write F# source code files using a basic text editor, like Notepad, and compile the code into assemblies using the command-line compiler.</p>

<p>You can download it from Microsoft Visual Studio. It gets automatically installed in your machine.</p>

<h2>Writing F# Programs On Links</h2>

<p>Please visit the F# official website for the latest instructions on getting the tools as a Debian package or compiling them directly from the source &minus; <a rel="nofollow" target="_blank" href="http://fsharp.org/use/linux/">http://fsharp.org/use/linux/.</a></p>

<h3>Try it Option Online</h3>

<p>We have set up the F# Programming environment online. You can easily compile and execute all the available examples online along with doing your theory work. It gives you confidence in what you are reading and to check the result with different options. Feel free to modify any example and execute it online.</p>

<p>Try the following example using the Try it option or use the url &minus; <a href="http://www.compileonline.com/">http://www.compileonline.com/.</a></p>

<p>For most of the examples given in this tutorial, you will find a Try it option in our website code sections at the top right corner that will take you to the online compiler. So just make use of it and enjoy your learning.</p>

<h1>F# - Program Structure</h1>

<p>F# is a Functional Programming language.</p>

<p>In F#, functions work like data types. You can declare and use a function in the same way like any other variable.</p>

<p>In general, an F# application does not have any specific entry point. The compiler executes all top-level statements in the file from top to bottom.</p>

<p>However, to follow procedural programming style, many applications keep a single top level statement that calls the main loop.</p>

<p>The following code shows a simple F# program &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>Please note that &minus;</p>

<p>An F# code file might begin with a number of <b>open</b> statements that is used to import namespaces.</p>

<p>The body of the files includes other functions that implement the business logic of the application.</p>

<p>The main loop contains the top executable statements.</p>

<h1>F# - Basic Syntax</h1>

<p>You have seen the basic structure of an F# program, so it will be easy to understand other basic building blocks of the F# programming language.</p>

<h2>Tokens in F#</h2>

<p>An F# program consists of various tokens. A token could be a keyword, an identifier, a constant, a string literal, or a symbol. We can categorize F# tokens into two types &minus;</p>

<h3>F# Keywords</h3>

<p>The following table shows the keywords and brief descriptions of the keywords. We will discuss the use of these keywords in subsequent chapters.</p>

<p>In type definitions and type extensions, indicates the end of a section of member definitions.</p>

<p>In verbose syntax, used to specify the end of a code block that starts with the begin keyword.</p>

<p>Used to declare, define, or invoke a constructor that creates or that can create an object.</p>

<p>Also used in generic parameter constraints to indicate that a type must have a certain constructor.</p>

<p>Indicates the absence of an object.</p>

<p>Also used in generic parameter constraints.</p>

<p>Used with Boolean conditions as a Boolean or operator. Equivalent to ||.</p><p>Also used in member constraints.</p>

<p>Used to declare a structure type.</p>

<p>Also used in generic parameter constraints.</p>

<p>Used for OCaml compatibility in module definitions.</p>

<p>Used in conditional expressions.</p>

<p>Also used to perform side effects after object construction.</p>

<p>Some reserved keywords came from the OCaml language &minus;</p>

<p>Some other reserved keywords are kept for future expansion of F#.</p>

<h2>Comments in F#</h2>

<p>F# provides two types of comments &minus;</p>

<h2>A Basic Program and Application Entry Point in F#</h2>

<p>Generally, you don’t have any explicit entry point for F# programs. When you compile an F# application, the last file provided to the compiler becomes the entry point and all top level statements in that file are executed from top to bottom.</p>

<p>A well-written program should have a single top-level statement that would call the main loop of the program.</p>

<p>A very minimalistic F# program that would display ‘Hello World’ on the screen &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h1>F# - Data Types</h1>

<p>The data types in F# can be classified as follows &minus;</p>

<h2>Integral Data Type</h2>

<p>The following table provides the integral data types of F#. These are basically integer data types.</p>

<p>42y</p>

<p>-11y</p>

<p>42uy</p>

<p>200uy</p>

<p>42s</p>

<p>-11s</p>

<p>42us</p>

<p>200us</p>

<p>42</p>

<p>-11</p>

<p>42u</p>

<p>200u</p>

<p>42L</p>

<p>-11L</p>

<p>42UL</p>

<p>200UL</p>

<p>42I</p>

<p>1499999</p>

<p>9999999</p>

<p>9999999</p>

<p>9999999</p>

<p>9999I</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Floating Point Data Types</h2>

<p>The following table provides the floating point data types of F#.</p>

<p>42.0F</p>

<p>-11.0F</p>

<p>42.0</p>

<p>-11.0</p>

<p>42.0M</p>

<p>-11.0M</p>

<p>42N</p>

<p>-11N</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Text Data Types</h2>

<p>The following table provides the text data types of F#.</p>

<p>'x'</p>

<p>'\t'</p>

<p>"Hello"</p>

<p>"World"</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Other Data Types</h2>

<p>The following table provides some other data types of F#.</p>

<p>true</p>

<p>false</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h1>F# - Variables</h1>

<p>A variable is a name given to a storage area that our programs can manipulate. Each variable has a specific type, which determines the size and layout of the variable's memory; the range of values that can be stored within that memory; and the set of operations that can be applied to the variable.</p>

<h2>Variable Declaration in F#</h2>

<p>The <b>let</b> keyword is used for variable declaration &minus;</p>

<p>For example,</p>

<p>It declares a variable x and assigns the value 10 to it.</p>

<p>You can also assign an expression to a variable &minus;</p>

<p>The following example illustrates the concept &minus;</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>Variables in F# are <b>immutable,</b> which means once a variable is bound to a value, it can’t be changed. They are actually compiled as static read-only properties.</p>

<p>The following example demonstrates this.</p>

<h3>Example</h3>

<p>When you compile and execute the program, it shows the following error message &minus;</p>

<h2>Variable Definition With Type Declaration</h2>

<p>A variable definition tells the compiler where and how much storage for the variable should be created. A variable definition may specify a data type and contains a list of one or more variables of that type as shown in the following example.</p>

<h3>Example</h3>

<p>When you compile and execute the program, it shows the following error message &minus;</p>

<h2>Mutable Variables</h2>

<p>At times you need to change the values stored in a variable. To specify that there could be a change in the value of a declared and assigned variable, in later part of a program, F# provides the <b>mutable</b> keyword. You can declare and assign mutable variables using this keyword, whose values you will change.</p>

<p>The <b>mutable</b> keyword allows you to declare and assign values in a mutable variable.</p>

<p>You can assign some initial value to a mutable variable using the <b>let</b> keyword. However, to assign new subsequent value to it, you need to use the <b>&larr;</b> operator.</p>

<p>For example,</p>

<p>The following example will clear the concept &minus;</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h1>F# - Operators</h1>

<p>An operator is a symbol that tells the compiler to perform specific mathematical or logical manipulations. F# is rich in built-in operators and provides the following types of operators &minus;</p>

<h2>Arithmetic Operators</h2>

<p>The following table shows all the arithmetic operators supported by F# language. Assume variable A holds 10 and variable B holds 20 then &minus;</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Comparison Operators</h2>

<p>The following table shows all the comparison operators supported by F# language. These binary comparison operators are available for integral and floating-point types. These operators return values of type bool.</p>

<p>Assume variable A holds 10 and variable B holds 20, then &minus;</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Boolean Operators</h2>

<p>The following table shows all the Boolean operators supported by F# language. Assume variable A holds <b>true</b> and variable B holds <b>false,</b> then &minus;</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Bitwise Operators</h2>

<p>Bitwise operators work on bits and perform bit-by-bit operation. The truth tables for &amp;&amp;&amp; (bitwise AND), ||| (bitwise OR), and ^^^ (bitwise exclusive OR) are as follows &minus;</p>

<p>Assume if A = 60; and B = 13; now in binary format they will be as follows &minus;</p>

<p>A = 0011 1100</p>

<p>B = 0000 1101</p>

<p>A&amp;&amp;&amp;B = 0000 1100</p>

<p>A|||B = 0011 1101</p>

<p>A^^^B = 0011 0001</p>

<p>~~~A = 1100 0011</p>

<p>The Bitwise operators supported by F# language are listed in the following table. Assume variable A holds 60 and variable B holds 13, then &minus;</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Operators Precedence</h2>

<p>The following table shows the order of precedence of operators and other expression keywords in the F# language, from lowest precedence to the highest precedence.</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h1>F# - Decision Making</h1>

<p>Decision making structures require that the programmer specify one or more conditions to be evaluated or tested by the program. It should be along with a statement or statements to be executed if the condition is determined to be true, and optionally, other statements to be executed if the condition is determined to be false.</p>

<p>Following is the general form of a typical decision making structure found in most of the programming languages &minus;</p>

<p>F# programming language provides the following types of decision making statements.</p>

<h2>F#-if/then Statement</h2>

<p>An if/then statement consists of a Boolean expression followed by one or more statements.</p>

<h3>Syntax</h3>

<p>The if/then construct in F# has the following syntax &minus;</p>

<h3>Flow diagram</h3>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>F#-if/then/else Statement</h2>

<p>An <b>if/then</b> statement can be followed by an optional <b>else</b> statement, which executes when the Boolean expression is false.</p>

<h3>Syntax</h3>

<p>The syntax of an if/then/else statement in F# programming language is &minus;</p>

<h3>Flow Diagram</h3>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>F#-if/then/elif/else Statement</h2>

<p>An <b>if/then/elif/else</b> construct has multiple else branches.</p>

<h3>Syntax</h3>

<p>The syntax of an if/then/elif/else statement in F# programming language is &minus;</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>F#-Nested if Statements</h2>

<p>It is always legal in F# programming to nest if/then or if/then/else statements, which means you can use one <b>if</b> or <b>else if</b> statement inside another <b>if</b> or <b>else if </b>statement(s).</p>

<h3>Syntax</h3>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h1>F# - Loops</h1>

<p>Programming languages provide various control structures that allow for more complicated execution paths.</p>

<p>A loop statement allows us to execute a statement or group of statements multiple times and following is the general form of a loop statement in most of the programming languages &minus;</p>

<p>F# provides the following types of loops to handle the looping requirements.</p>

<h2>F#-for...to and for...downto Expressions</h2>

<p>A <b>for loop</b> is a repetition control structure that allows you to efficiently write a loop that needs to execute a specific number of times.</p>

<h3>Syntax</h3>

<p>The syntax of a <b>for…to</b> loop in F# programming language is &minus;</p>

<p>The syntax of a for…downto loop in F# programming language is &minus;</p>

<h3>Example 1</h3>

<p>The following program prints out the numbers 1 - 20 &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h3>Example 2</h3>

<p>The following program counts in reverse and prints out the numbers 20 - 1 &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>F#-for...in Expressions</h2>

<p>This looping construct is used to iterate over the matches of a pattern in an enumerable collection such as a range expression, sequence, list, array, or other construct that supports enumeration.</p>

<h3>Syntax</h3>

<h3>Example</h3>

<p>The following program illustrates the concept &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>F#-While…do Expressions</h2>

<p>The <b>while...do</b> expression is used to perform iterative execution while a specified test condition is true.</p>

<h3>Syntax</h3>

<p>The test-expression is evaluated first; if it is true, the body-expression is executed and the test expression is evaluated again. The body-expression must have type unit, i.e., it should not return any value. If the test expression is false, the iteration ends.</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>F#-Nested Loops</h2>

<p>F# programming language allows to use one loop inside another loop.</p>

<h3>Syntax</h3>

<p>The syntax for a nested for loop statement could be as follows &minus;</p>

<p>The syntax for a nested while loop statement could be as follows &minus;</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h1>F# - Functions</h1>

<p>In F#, functions work like data types. You can declare and use a function in the same way like any other variable.</p>

<p>Since functions can be used like any other variables, you can &minus;</p>

<h2>Defining a Function</h2>

<p>Functions are defined by using the <b>let</b> keyword. A function definition has the following syntax &minus;</p>

<p>Where,</p>

<p><b>function-name</b> is an identifier that represents the function.</p>

<p><b>parameter-list</b> gives the list of parameters separated by spaces. You can also specify an explicit type for each parameter and if not specified compiler tends to deduce it from the function body (like variables).</p>

<p><b>function-body</b> consists of an expression, or a compound expression consisting of a number of expressions. The final expression in the function body is the return value.</p>

<p><b>return-type</b> is a colon followed by a type and is optional. If the return type is not specified, then the compiler determines it from the final expression in the function body.</p>

<h2>Parameters of a Function</h2>

<p>You list the names of parameters right after the function name. You can specify the type of a parameter. The type of the parameter should follow the name of the parameter separated by a colon.</p>

<p>If no parameter type is specified, it is inferred by the compiler.</p>

<p>For example &minus;</p>

<h3>Calling a Function</h3>

<p>A function is called by specifying the function name followed by a space and then any arguments separated by spaces.</p>

<p>For example &minus;</p>

<p>The following programs illustrate the concepts.</p>

<h3>Example 1</h3>

<p>The following program calculates the volume of a cylinder when the radius and length are given as parameters.</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h3>Example 2</h3>

<p>The following program returns the larger value of two given parameters &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h3>Example 3</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Recursive Functions</h2>

<p>Recursive functions are functions that call themselves.</p>

<p>You define a recursive using the <b>let rec</b> keyword combination.</p>

<p>Syntax for defining a recursive function is &minus;</p>

<p>For example &minus;</p>

<h3>Example 1</h3>

<p>The following program returns Fibonacci 1 to 10 &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h3>Example 2</h3>

<p>The following program returns factorial 8 &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Arrow Notations in F#</h2>

<p>F# reports about data type in functions and values, using a chained arrow notation. Let us take an example of a function that takes one <i>int</i> input, and returns a string. In arrow notation, it is written as &minus;</p>

<p>Data types are read from left to right.</p>

<p>Let us take another hypothetical function that takes two int data inputs and returns a string.</p>

<p>F# reports the data type using chained arrow notation as &minus;</p>

<p>The return type is represented by the rightmost data type in chained arrow notation.</p>

<p>Some more examples &minus;</p>

<h2>Lambda Expressions</h2>

<p>A <b>lambda expression</b> is an unnamed function.</p>

<p>Let us take an example of two functions &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>Now in the above example, if instead of defining the function <i>mul,</i> we could have used lambda expressions as &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Function Composition and Pipelining</h2>

<p>In F#, one function can be composed from other functions.</p>

<p>The following example shows the composition of a function named f, from two functions function1 and function2 &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>F# also provides a feature called <b>pipelining of functions.</b> Pipelining allows function calls to be chained together as successive operations.</p>

<p>The following example shows that &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h1>F# - Strings</h1>

<p>In F#, the string type represents immutable text as a sequence of Unicode characters.</p>

<h2>String Literals</h2>

<p>String literals are delimited by the quotation mark (") character.</p>

<p>Some special characters are there for special uses like newline, tab, etc. They are encoded using backslash (\) character. The backslash character and the related character make the escape sequence. The following table shows the escape sequence supported by F#.</p>

<h2>Ways of lgnoring the Escape Sequence</h2>

<p>The following two ways makes the compiler ignore the escape sequence &minus;</p>

<p>When a string literal is preceded by the @ symbol, it is called a <b>verbatim string.</b> In that way, all escape sequences in the string are ignored, except that two quotation mark characters are interpreted as one quotation mark character.</p>

<p>When a string is enclosed by triple quotes, then also all escape sequences are ignored, including double quotation mark characters.</p>

<h3>Example</h3>

<p>The following example demonstrates this technique showing how to work with XML or other structures that include embedded quotation marks &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Basic Operators on Strings</h2>

<p>The following table shows the basic operations on strings &minus;</p>

<p>The following examples demonstrate the uses of some of the above functionalities &minus;</p>

<h3>Example 1</h3>

<p>The String.collect function builds a new string whose characters are the results of applying a specified function to each of the characters of the input string and concatenating the resulting strings.</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h3>Example 2</h3>

<p>The String.concat function concatenates a given sequence of strings with a separator and returns a new string.</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h3>Example 3</h3>

<p>The String.replicate method returns a string by concatenating a specified number of instances of a string.</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h1>F# - Options</h1>

<p>The <b>option</b> type in F# is used in calculations when there may or may not exist a value for a variable or function. Option types are used for representing optional values in calculations. They can have two possible values &minus; <b>Some(x)</b> or <b>None</b>.</p>

<p>For example, a function performing a division will return a value in normal situation, but will throw exceptions in case of a zero denominator. Using options here will help to indicate whether the function has succeeded or failed.</p>

<p>An option has an underlying type and can hold a value of that type, or it might not have a value.</p>

<h2>Using Options</h2>

<p>Let us take the example of division function. The following program explains this &minus;</p>

<p>Let us write a function div, and send two arguments to it 20 and 5 &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>If the second argument is zero, then the program throws an exception &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>In such cases, we can use option types to return Some (value) when the operation is successful or None if the operation fails.</p>

<p>The following example demonstrates the use of options &minus;</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Option Properties and Methods</h2>

<p>The option type supports the following properties and methods &minus;</p>

<h3>Example 1</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h3>Example 2</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h3>Example 3</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h1>F# - Tuples</h1>

<p>A <b>tuple</b> is a comma-separated collection of values. These are used for creating ad hoc data structures, which group together related values.</p>

<p>For example, (“Zara Ali”, “Hyderabad”, 10) is a 3-tuple with two string values and an int value, it has the type (string * string * int).</p>

<p>Tuples could be pairs, triples, and so on, of the same or different types.</p>

<p>Some examples are provided here &minus;</p>

<h2>Example</h2>

<p>This program has a function that takes a tuple of four float values and returns the average &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Accessing Individual Tuple Members</h2>

<p>The individual members of a tuple could be assessed and printed using pattern matching.</p>

<p>The following example illustrates the concept &minus;</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>F# has two built-in functions, <b>fst</b> and <b>snd,</b> which return the first and second items in a 2-tuple.</p>

<p>The following example illustrates the concept &minus;</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h1>F# - Records</h1>

<p>A <b>record</b> is similar to a tuple, however it contains named fields. For example,</p>

<h2>Defining Record</h2>

<p>A record is defined as a type using the <b>type</b> keyword, and the fields of the record are defined as a semicolon-separated list.</p>

<p>Syntax for defining a record is &minus;</p>

<h2>Creating a Record</h2>

<p>You can create a record by specifying the record's fields. For example, let us create a <i>website</i> record named <i>homepage</i> &minus;</p>

<p>The following examples will explain the concepts &minus;</p>

<h3>Example 1</h3>

<p>This program defines a record type named website. Then it creates some records of type website and prints the records.</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h3>Example 2</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h1>F# - Lists</h1>

<p>In F#, a list is an ordered, immutable series of elements of the same type. It is to some extent equivalent to a linked list data structure.</p>

<p>The F# module, <b>Microsoft.FSharp.Collections.List,</b> has the common operations on lists. However F# imports this module automatically and makes it accessible to every F# application.</p>

<h2>Creating and Initializing a List</h2>

<p>Following are the various ways of creating lists &minus;</p>

<p>Using list <b>literals</b>.</p>

<p>Using <b>cons</b> (::) operator.</p>

<p>Using the <b>List.init</b> method of List module.</p>

<p>Using some <b>syntactic constructs</b> called <b>List Comprehensions</b>.</p>

<h3>List Literals</h3>

<p>In this method, you just specify a semicolon-delimited sequence of values in square brackets. For example:</p>

<h3>The cons (::) Operator</h3>

<p>With this method, you can add some values by prepending or <b>cons-ing</b> it to an existing list using the :: operator. For example &minus;</p>

<p>[] denotes an empty list.</p>

<h3>List init Method</h3>

<p>The List.init method of the List module is often used for creating lists. This method has the type &minus;</p>

<p>The first argument is the desired length of the new list, and the second argument is an initializer function, which generates items in the list.</p>

<p>For example,</p>

<p>Here, the index function generates the list.</p>

<h3>List Comprehensions</h3>

<p>List comprehensions are special syntactic constructs used for generating lists.</p>

<p>F# list comprehension syntax comes in two forms &minus; ranges and generators.</p>

<p>Ranges have the constructs &minus; [start .. end] and [start .. step .. end]</p>

<p>For example,</p>

<p>Generators have the construct &minus; [for x in collection do ... yield expr]</p>

<p>For example,</p>

<p>As the <b>yield</b> keyword pushes a single value into a list, the keyword, <b>yield!,</b> pushes a collection of values into the list.</p>

<p>The following function demonstrates the above methods &minus;</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Properties of List Data Type</h2>

<p>The following table shows various properties of list data type &minus;</p>

<p>The following example shows the use of these properties &minus;</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Basic Operators on List</h2>

<p>The following table shows the basic operations on list data type &minus;</p>

<p>The following examples demonstrate the uses of the above functionalities &minus;</p>

<h3>Example 1</h3>

<p>This program shows reversing a list recursively &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>However, you can use the <b>rev</b> function of the module for the same purpose &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h3>Example 2</h3>

<p>This program shows filtering a list using the <b>List.filter</b> method &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h3>Example 3</h3>

<p>The <b>List.map</b> method maps a list from one type to another &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h3>Example 4</h3>

<p>The <b>List.append</b> method and the @ operator appends one list to another &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h3>Example 5</h3>

<p>The <b>List.sort</b> method sorts a list. The <b>List.sum</b> method gives the sum of elements in the list and the <b>List.average</b> method gives the average of elements in the list &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>A "fold" operation applies a function to each element in a list, aggregates the result of the function in an accumulator variable, and returns the accumulator as the result of the fold operation.</p>

<h3>Example 6</h3>

<p>The <b>List.fold</b> method applies a function to each element from left to right, while <b>List.foldBack</b> applies a function to each element from right to left.</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h1>F# - Sequences</h1>

<p>Sequences, like lists also represent an ordered collection of values. However, the elements in a sequence or sequence expression are computed when required. They are not computed at once, and for this reason they are used to represent infinite data structures.</p>

<h2>Defining Sequences</h2>

<p>Sequences are defined using the following syntax &minus;</p>

<p>For example,</p>

<h2>Creating Sequences and Sequences Expressions</h2>

<p>Similar to lists, you can create sequences using ranges and comprehensions.</p>

<p>Sequence expressions are the expressions you can write for creating sequences. These can be done &minus;</p>

<p>The following examples demonstrate the concept &minus;</p>

<h3>Example 1</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h3>Example 2</h3>

<p>The following program prints the prime numbers from 1 to 50 &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Basic Operations on Sequence</h2>

<p>The following table shows the basic operations on sequence data type &minus;</p>

<p>The following examples demonstrate the uses of some of the above functionalities &minus;</p>

<h3>Example 1</h3>

<p>This program creates an empty sequence and fills it up later &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>Please note that &minus;</p>

<p>The Seq.empty method creates an empty sequence.</p>

<p>The Seq.singleton method creates a sequence of just one specified element.</p>

<p>The Seq.init method creates a sequence for which the elements are created by using a given function.</p>

<p>The Seq.ofArray and Seq.ofList&lt;'T&gt; methods create sequences from arrays and lists.</p>

<p>The Seq.iter method allows iterating through a sequence.</p>

<h3>Example 2</h3>

<p>The Seq.unfold method generates a sequence from a computation function that takes a state and transforms it to produce each subsequent element in the sequence.</p>

<p>The following function produces the first 20 natural numbers &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h3>Example 3</h3>

<p>The Seq.truncate method creates a sequence from another sequence, but limits the sequence to a specified number of elements.</p>

<p>The Seq.take method creates a new sequence that contains a specified number of elements from the start of a sequence.</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h1>F# - Sets</h1>

<p>A set in F# is a data structure that acts as a collection of items without preserving the order in which items are inserted. Sets do not allow duplicate entries to be inserted into the collection.</p>

<h2>Creating Sets</h2>

<p>Sets can be created in the following ways &minus;</p>

<p>The following program demonstrates the techniques &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Basic Operations on Sets</h2>

<p>The following table shows the basic operations on sets &minus;</p>

<p>The following example demonstrates the uses of some of the above functionalities &minus;</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h1>F# - Maps</h1>

<p>In F#, a map is a special kind of set that associates the values with key. A map is created in a similar way as sets are created.</p>

<h2>Creating Maps</h2>

<p>Maps are created by creating an empty map using Map.empty and adding items using the Add function. The following example demonstrates this &minus;</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>You can access individual elements in the map using the key.</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Basic Operations on Maps</h2>

<h3>Add module name</h3>

<p>The following table shows the basic operations on maps &minus;</p>

<p>The following example demonstrates the uses of some of the above functionalities &minus;</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h1>F# - Discriminated Unions</h1>

<p>Unions, or discriminated unions allows you to build up complex data structures representing well-defined set of choices. For example, you need to build an implementation of a <i>choice</i> variable, which has two values yes and no. Using the Unions tool, you can design this.</p>

<h2>Syntax</h2>

<p>Discriminated unions are defined using the following syntax &minus;</p>

<p>Our simple implementation of ,<i>choice,</i> will look like the following &minus;</p>

<p>The following example uses the type choice &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Example 1</h2>

<p>The following example shows the implementation of the voltage states that sets a bit on high or low &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Example 2</h2>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h1>F# - Mutable Data</h1>

<p>Variables in F# are <b>immutable,</b> which means once a variable is bound to a value, it can’t be changed. They are actually compiled as static read-only properties.</p>

<p>The following example demonstrates this.</p>

<h2>Example</h2>

<p>When you compile and execute the program, it shows the following error message &minus;</p>

<h2>Mutable Variables</h2>

<p>At times you need to change the values stored in a variable. To specify that there could be a change in the value of a declared and assigned variable in later part of a program, F# provides the <b>mutable</b> keyword. You can declare and assign mutable variables using this keyword, whose values you will change.</p>

<p>The <b>mutable</b> keyword allows you to declare and assign values in a mutable variable.</p>

<p>You can assign some initial value to a mutable variable using the <b>let</b> keyword. However, to assign new subsequent value to it, you need to use the <b>&lt;-</b> operator.</p>

<p>For example,</p>

<p>The following example will clear the concept &minus;</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Uses of Mutable Data</h2>

<p>Mutable data is often required and used in data processing, particularly with record data structure. The following example demonstrates this &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h1>F# - Arrays</h1>

<p>Arrays are fixed-size, zero-based, mutable collections of consecutive data elements that are all of the same type.</p>

<h2>Creating Arrays</h2>

<p>You can create arrays using various syntaxes and ways or by using the functions from the Array module. In this section, we will discuss creating arrays without using the module functions.</p>

<p>There are three syntactical ways of creating arrays without functions &minus;</p>

<p>You can access array elements by using a dot operator (.) and brackets ([ and ]).</p>

<p>The following example demonstrates creating arrays &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Basic Operations on Arrays</h2>

<p>The library module Microsoft.FSharp.Collections.Array supports operations on one-dimensional arrays.</p>

<p>The following table shows the basic operations on Arrays &minus;</p>

<p>In the following section, we will see the uses of some of these functionalities.</p>

<h2>Creating Arrays Using Functions</h2>

<p>The Array module provides several functions that create an array from scratch.</p>

<p>The <b>Array.empty</b> function creates a new empty array.</p>

<p>The <b>Array.create</b> function creates an array of a specified size and sets all the elements to given values.</p>

<p>The <b>Array.init</b> function creates an array, given a dimension and a function to generate the elements.</p>

<p>The <b>Array.zeroCreate</b> function creates an array in which all the elements are initialized to the zero value.</p>

<p>The <b>Array.copy</b> function creates a new array that contains elements that are copied from an existing array.</p>

<p>The <b>Array.sub</b> function generates a new array from a subrange of an array.</p>

<p>The <b>Array.append</b> function creates a new array by combining two existing arrays.</p>

<p>The <b>Array.choose</b> function selects elements of an array to include in a new array.</p>

<p>The <b>Array.collect</b> function runs a specified function on each array element of an existing array and then collects the elements generated by the function and combines them into a new array.</p>

<p>The <b>Array.concat</b> function takes a sequence of arrays and combines them into a single array.</p>

<p>The <b>Array.filter</b> function takes a Boolean condition function and generates a new array that contains only those elements from the input array for which the condition is true.</p>

<p>The <b>Array.rev</b> function generates a new array by reversing the order of an existing array.</p>

<p>The following examples demonstrate these functions &minus;</p>

<h3>Example 1</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h3>Example 2</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Searching Arrays</h2>

<p>The <b>Array.find</b> function takes a Boolean function and returns the first element for which the function returns true, else raises a KeyNotFoundException.</p>

<p>The <b>Array.findIndex</b> function works similarly except that it returns the index of the element instead of the element itself.</p>

<p>The following example demonstrates this.</p>

<p>Microsoft provides this interesting program example, which finds the first element in the range of a given number that is both a perfect square as well as a perfect cube &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h1>F# - Mutable Lists</h1>

<p>The <b>List&lt;'T&gt;</b> class represents a strongly typed list of objects that can be accessed by index.</p>

<p>It is a mutable counterpart of the List class. It is similar to arrays, as it can be accessed by an index, however, unlike arrays, lists can be resized. Therefore you need not specify a size during declaration.</p>

<h2>Creating a Mutable List</h2>

<p>Lists are created using the <b>new</b> keyword and calling the list's constructor. The following example demonstrates this &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>The List(T) Class</h2>

<p>The List(T) class represents a strongly typed list of objects that can be accessed by index. It provide methods to search, sort, and manipulate lists.</p>

<p>The following tables provide the properties, constructors and the methods of the List(T) class &minus;</p>

<h3>Properties</h3>

<h3>Constructors</h3>

<h3>Method</h3>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h1>F# - Mutable Dictionary</h1>

<p>The <b>Dictionary&lt;'TKey, 'TValue&gt;</b> class is the mutable analog of the F# map data structure and contains many of the same functions.</p>

<p>Recapitulating from the Map chapter in F#, a map is a special kind of set that associates the values with key.</p>

<h2>Creating of a Mutable Dictionary</h2>

<p>Mutable dictionaries are created using the <b>new</b> keyword and calling the list's constructor. The following example demonstrates this &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>The Dictionary(TKey,TValue) Class</h2>

<p>The Dictionary(TKey, TValue) Class represents a collection of keys and values.</p>

<p>The following tables provide the properties, constructors and the methods of the List(T) class &minus;</p>

<h3>Properties</h3>

<h3>Constructors</h3>

<h3>Methods</h3>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h1>F# - Basic IO</h1>

<p>Basic Input Output includes &minus;</p>

<h2>Core.Printf Module</h2>

<p>We have used the <i>printf</i> and the <i>printfn</i> functions for writing into the console. In this section, we will look into the details of the <b>Printf</b> module of F#.</p>

<p>Apart from the above functions, the <i>Core.Printf</i> module of F# has various other methods for printing and formatting using % markers as placeholders. The following table shows the methods with brief description &minus;</p>

<h2>Format Specifications</h2>

<p>Format specifications are used for formatting the input or output, according to the programmers’ need.</p>

<p>These are strings with % markers indicating format placeholders.</p>

<p>The syntax of a Format placeholders is &minus;</p>

<p>The <b>type</b> is interpreted as &minus;</p>

<p>A general format specifier, requires two arguments. The first argument is a function which accepts two arguments: first, a context parameter of the appropriate type for the given formatting function (for example, a TextWriter), and second, a value to print and which either outputs or returns appropriate text.</p>

<p>The second argument is the particular value to print.</p>

<p>The <b>width</b> is an optional parameter. It is an integer that indicates the minimal width of the result. For example, %5d prints an integer with at least spaces of 5 characters.</p>

<p>Valid <b>flags</b> are described in the following table &minus;</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>The Console Class</h2>

<p>This class is a part of the .NET framework. It represents the standard input, output, and error streams for console applications.</p>

<p>It provides various methods for reading from and writing into the console. The following table shows the methods &minus;</p>

<p>The following example demonstrates reading from console and writing into it &minus;</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>The System.IO Namespace</h2>

<p>The System.IO namespace contains a variety of useful classes for performing basic I/O.</p>

<p>It contains types or classes that allow reading and writing to files and data streams and types that provide basic file and directory support.</p>

<p>Classes useful for working with the file system &minus;</p>

<p>Classes useful for working with the streams (sequence of bytes) &minus;</p>

<p>The following table shows all the classes provided in the namespace along with a brief description &minus;</p>

<h3>Example</h3>

<p>The following example creates a file called test.txt, writes a message there, reads the text from the file and prints it on the console.</p>

<p><b>Note</b> &minus;  The amount of code needed to do this is surprisingly less!</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h1>F# - Generics</h1>

<p>Generics allow you to delay the specification of the data type of programming elements in a class or a method, until it is actually used in the program. In other words, generics allow you to write a class or method that can work with any data type.</p>

<p>You write the specifications for the class or the method, with substitute parameters for data types. When the compiler encounters a constructor for the class or a function call for the method, it generates code to handle the specific data type.</p>

<p>In F#, function values, methods, properties, and aggregate types such as classes, records, and discriminated unions can be generic.</p>

<p>Generic constructs contain at least one type parameter. Generic functions and types enable you to write code that works with a variety of types without repeating the code for each type.</p>

<h2>Syntax</h2>

<p>Syntax for writing a generic construct is as follows &minus;</p>

<h2>Examples</h2>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>You can also make a function generic by using the single quotation mark syntax &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>Please note that when you use generic functions or methods, you might not have to specify the type arguments. However, in case of an ambiguity, you can provide type arguments in angle brackets as we did in the first example.</p>

<p>If you have more than one type, then you separate multiple type arguments with commas.</p>

<h2>Generic Class</h2>

<p>Like generic functions, you can also write generic classes. The following example demonstrates this &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h1>F# - Delegates</h1>

<p>A delegate is a reference type variable that holds the reference to a method. The reference can be changed at runtime. F# delegates are similar to pointers to functions, in C or C++.</p>

<h2>Declaring Delegates</h2>

<p>Delegate declaration determines the methods that can be referenced by the delegate. A delegate can refer to a method, which have the same signature as that of the delegate.</p>

<p>Syntax for delegate declaration is &minus;</p>

<p>For example, consider the delegates &minus;</p>

<p>Both the delegates can be used to reference any method that has two <i>int</i> parameters and returns an <i>int</i> type variable.</p>

<p>In the syntax &minus;</p>

<p>Please note &minus;</p>

<p>The argument types are automatically curried.</p>

<p>Delegates can be attached to function values, and static or instance methods.</p>

<p>F# function values can be passed directly as arguments to delegate constructors.</p>

<p>For a static method the delegate is called by using the name of the class and the method. For an instance method, the name of the object instance and method is used.</p>

<p>The Invoke method on the delegate type calls the encapsulated function.</p>

<p>Also, delegates can be passed as function values by referencing the Invoke method name without the parentheses.</p>

<p>The following example demonstrates the concept &minus;</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h1>F# - Enumerations</h1>

<p>An enumeration is a set of named integer constants.</p>

<p>In F#, <b>enumerations,</b> also known as <b>enums,</b> are integral types where labels are assigned to a subset of the values. You can use them in place of literals to make code more readable and maintainable.</p>

<h2>Declaring Enumerations</h2>

<p>The general syntax for declaring an enumeration is &minus;</p>

<p>The following example demonstrates the use of enumerations &minus;</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h1>F# - Pattern Matching</h1>

<p>Pattern matching allows you to “compare data with a logical structure or structures, decompose data into constituent parts, or extract information from data in various ways”.</p>

<p>In other terms, it provides a more flexible and powerful way of testing data against a series of conditions and performing some computations based on the condition met.</p>

<p>Conceptually, it is like a series of if… then statements.</p>

<h2>Syntax</h2>

<p>In high level terms, pattern matching follows this syntax in F# &minus;</p>

<p>Where,</p>

<h2>Example 1</h2>

<p>The following example, calculates the Fibonacci numbers using pattern matching syntax &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>You can also chain together multiple conditions, which return the same value. For example &minus;</p>

<h2>Example 2</h2>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Pattern Matching Functions</h2>

<p>F# allows you to write pattern matching functions using the <b>function</b> keyword &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Adding Filters or Guards to Patterns</h2>

<p>You can add filters, or guards, to patterns using the <b>when</b> keyword.</p>

<h3>Example 1</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h3>Example 2</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Pattern Matching with Tuples</h2>

<p>The following example demonstrates the pattern matching with tuples &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Pattern Matching with Records</h2>

<p>The following example demonstrates pattern matching with records &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h1>F# - Exception Handling</h1>

<p>An exception is a problem that arises during the execution of a program. An F# exception is a response to an exceptional circumstance that arises while a program is running, such as an attempt to divide by zero.</p>

<p>Exceptions provide a way to transfer control from one part of a program to another. F# exception handling provides the following constructs &minus;</p>

<p>Let us start with the basic syntax of Exception Handling.</p>

<h2>Syntax</h2>

<p>Basic syntax for F# exception handling block is &minus;</p>

<p>Where,</p>

<p><b>exception-type</b> is the name of a new F# exception type.</p>

<p><b>argument-type</b> represents the type of an argument that can be supplied when you raise an exception of this type.</p>

<p>Multiple arguments can be specified by using a tuple type for argument-type.</p>

<p>The <b>try...with</b> expression is used for exception handling in the F# language.</p>

<p>Syntax for the try … with expression is &minus;</p>

<p>The <b>try...finally</b> expression allows you to execute clean-up code even if a block of code throws an exception.</p>

<p>Syntax for the try … finally expression is &minus;</p>

<p>The <b>raise</b> function is used to indicate that an error or exceptional condition has occurred. It also captures the information about the error in an exception object.</p>

<p>Syntax for the raise function is &minus;</p>

<p>The <b>failwith</b> function generates an F# exception.</p>

<p>Syntax for the failwith function is &minus;</p>

<p>The <b>invalidArg</b> function generates an argument exception.</p>

<h2>Example of Exception Handling</h2>

<h3>Example 1</h3>

<p>The following program shows the basic exception handling with a simple try… with block &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h3>Example 2</h3>

<p>F# provides an <b>exception</b> type for declaring exceptions. You can use an exception type directly in the filters in a <b>try...with</b> expression.</p>

<p>The following example demonstrates this &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h3>Example 3</h3>

<p>The following example demonstrates nested exception handling &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h3>Example 4</h3>

<p>The following function demonstrates the <b>failwith</b> function &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h3>Example 5</h3>

<p>The <b>invalidArg</b> function generates an argument exception. The following program demonstrates this &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>Some other information about the file and variable causing error in the system will also be displayed, depending upon the system.</p>

<h1>F# - Classes</h1>

<p>Classes are types that represent objects that can have properties, methods, and events. ‘They are used to model actions, processes, and any conceptual entities in applications.’</p>

<h2>Syntax</h2>

<p>Syntax for defining a class type is as follows &minus;</p>

<p>Where,</p>

<p>The <b>type-name</b> is any valid identifier. Default access modifier for this is <b>public</b>.</p>

<p>The <b>type-params</b> describes optional generic type parameters.</p>

<p>The <b>parameter-list</b> describes constructor parameters. Default access modifier for primary constructor is <b>public</b>.</p>

<p>The <b>identifier</b> used with the optional <b>as</b> keyword gives a name to the instance variable, or <b>self-identifier,</b> which can be used in the type definition to refer to the instance of the type.</p>

<p>The <b>inherit</b> keyword allows you to specify the base class for a class.</p>

<p>The <b>let</b> bindings allow you to declare fields or function values local to the class.</p>

<p>The <b>do-bindings</b> section includes code to be executed upon object construction.</p>

<p>The <b>member-list</b> consists of additional constructors, instance and static method declarations, interface declarations, abstract bindings, and property and event declarations.</p>

<p>The keywords <b>class</b> and <b>end</b> that mark the start and end of the definition are optional.</p>

<h2>Constructor of a Class</h2>

<p>The constructor is code that creates an instance of the class type.</p>

<p>In F#, constructors work little differently than other .Net languages. In the class definition, the arguments of the primary constructor are described as parameter-list.</p>

<p>The body of the constructor consists of the <b>let</b> and <b>do</b> bindings.</p>

<p>You can add additional constructors by using the new keyword to add a member &minus;</p>

<p>The following example illustrates the concept &minus;</p>

<h3>Example</h3>

<p>The following program creates a line class along with a constructor that calculates the length of the line while an object of the class is created &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Let Bindings</h2>

<p>The let bindings in a class definition allow you to define private fields and private functions for F# classes.</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>Please note the use of self-identifier <i>gr</i> for the <i>Greetings</i> class.</p>

<h1>F# - Structures</h1>

<p>A structure in F# is a value type data type. It helps you to make a single variable, hold related data of various data types. The <b>struct</b> keyword is used for creating a structure.</p>

<h2>Syntax</h2>

<p>Syntax for defining a structure is as follows &minus;</p>

<p>There are two syntaxes. The first syntax is mostly used, because, if you use the <b>struct</b> and <b>end</b> keywords, you can omit the <b>StructAttribute</b> attribute.</p>

<p>The structure definition elements provide &minus;</p>

<p>Unlike classes, structures cannot be inherited and cannot contain let or do bindings. Since, structures do not have let bindings; you must declare fields in structures by using the <b>val</b> keyword.</p>

<p>When you define a field and its type using <b>val</b> keyword, you cannot initialize the field value, instead they are initialized to zero or null. So for a structure having an implicit constructor, the <b>val</b> declarations be annotated with the <b>DefaultValue</b> attribute.</p>

<h2>Example</h2>

<p>The following program creates a line structure along with a constructor. The program calculates the length of a line using the structure &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h1>F# - Operator Overloading</h1>

<p>You can redefine or overload most of the built-in operators available in F#. Thus a programmer can use operators with user-defined types as well.</p>

<p>Operators are functions with special names, enclosed in brackets. They must be defined as static class members. Like any other function, an overloaded operator has a return type and a parameter list.</p>

<p>The following example, shows a &plus; operator on complex numbers &minus;</p>

<p>The above function implements the addition operator (&plus;) for a user-defined class Complex. It adds the attributes of two objects and returns the resultant Complex object.</p>

<h2>Implementation of Operator Overloading</h2>

<p>The following program shows the complete implementation &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h1>F# - Inheritance</h1>

<p>One of the most important concepts in object-oriented programming is that of inheritance. Inheritance allows us to define a class in terms of another class, which makes it easier to create and maintain an application. This also provides an opportunity to reuse the code functionality and fast implementation time.</p>

<p>When creating a class, instead of writing completely new data members and member functions, the programmer can designate that the new class should inherit the members of an existing class. This existing class is called the base class, and the new class is referred to as the derived class.</p>

<p>The idea of inheritance implements the IS-A relationship. For example, mammal IS A animal, dog IS-A mammal hence dog IS-A animal as well and so on.</p>

<h2>Base Class and Sub Class</h2>

<p>A subclass is derived from a base class, which is already defined. A subclass inherits the members of the base class, as well as has its own members.</p>

<p>A subclass is defined using the <b>inherit</b> keyword as shown below &minus;</p>

<p>In F#, a class can have at most one direct base class. If you do not specify a base class by using the <b>inherit</b> keyword, the class implicitly inherits from Object.</p>

<p>Please note &minus;</p>

<p>The methods and members of the base class are available to users of the derived class like the direct members of the derived class.</p>

<p>Let bindings and constructor parameters are private to a class and, therefore, cannot be accessed from derived classes.</p>

<p>The keyword <b>base</b> refers to the base class instance. It is used like the self-identifier.</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Overriding Methods</h2>

<p>You can override a default behavior of a base class method and implement it differently in the subclass or the derived class.</p>

<p>Methods in F# are not overridable by default.</p>

<p>To override methods in a derived class, you have to declare your method as overridable using the <b>abstract</b> and <b>default</b> keywords as follows &minus;</p>

<p>Now, the <i>Greet</i> method of the Person class can be overridden in derived classes. The following example demonstrates this &minus;</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Abstract Class</h2>

<p>At times you need to provide an incomplete implementation of an object, which should not be implemented in reality. Later, some other programmer should create subclasses of the abstract class to a complete implementation.</p>

<p>For example, the Person class will not be needed in a School Management System. However, the Student or the Teacher class will be needed. In such cases, you can declare the Person class as an abstract class.</p>

<p>The <b>AbstractClass</b> attribute tells the compiler that the class has some abstract members.</p>

<p>You cannot create an instance of an abstract class because the class is not fully implemented.</p>

<p>The following example demonstrates this &minus;</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h1>F# - Interfaces</h1>

<p>Interfaces provide an abstract way of writing up the implementation details of a class. It is a template that declares the methods the class must implement and expose publicly.</p>

<h2>Syntax</h2>

<p>An interface specifies the sets of related members that other classes implement. It has the following syntax &minus;</p>

<p>Please note &minus;</p>

<p>In an interface declaration the members are not implemented.</p>

<p>The members are abstract, declared by the <b>abstract</b> keyword. However you may provide a default implementation using the <b>default</b> keyword.</p>

<p>You can implement interfaces either by using object expressions or by using class types.</p>

<p>In class or object implementation, you need to provide method bodies for abstract methods of the interface.</p>

<p>The keywords <b>interface</b> and <b>end,</b> which mark the start and end of the definition, are optional.</p>

<p>For example,</p>

<h2>Calling Interface Methods</h2>

<p>Interface methods are called through the interface, not through the instance of the class or type implementing interface. To call an interface method, you up cast to the interface type by using the <b>:&gt;</b> operator (upcast operator).</p>

<p>For example,</p>

<p>The following example illustrates the concept &minus;</p>

<h3>Example</h3>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Interface Inheritance</h2>

<p>Interfaces can inherit from one or more base interfaces.</p>

<p>The following example shows the concept &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h1>F# - Events</h1>

<p>Events allow classes to send and receive messages between one another.</p>

<p>In GUI, events are user actions like key press, clicks, mouse movements, etc., or some occurrence like system generated notifications. Applications need to respond to events when they occur. For example, interrupts. Events are used for inter-process communication.</p>

<p>Objects communicate with one another through synchronous message passing.</p>

<p>Events are attached to other functions; objects register <b>callback</b> functions to an event, and these callbacks are executed when (and if) the event is triggered by some object.</p>

<h2>The Event Class and Event Module</h2>

<p>The Control.Event&lt;'T&gt; Class helps in creating an observable object or event.</p>

<p>It has the following instance members to work with the events &minus;</p>

<p>The Control.Event Module provides functions for managing event streams &minus;</p>

<h2>Creating Events</h2>

<p>Events are created and used through the <b>Event</b> class. The Event constructor is used for creating an event.</p>

<h3>Example</h3>

<p>After this you need to expose the nameChanged field as a public member, so that the listeners can hook onto the event for which, you use the <b>Publish</b> property of the event &minus;</p>

<p>Next, you add callbacks to event handlers. Each event handler has the type IEvent&lt;'T&gt;, which provides several methods &minus;</p>

<p>The following section provides a complete example.</p>

<h3>Example</h3>

<p>The following example demonstrates the concept and techniques discussed above &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h1>F# - Modules</h1>

<p>As per MSDN library, an F# module is a grouping of F# code constructs, such as types, values, function values, and code in do bindings. It is implemented as a common language runtime (CLR) class that has only static members.</p>

<p>Depending upon the situation whether the whole file is included in the module, there are two types of module declarations &minus;</p>

<p>In a top-level module declaration the whole file is included in the module. In this case, the first declaration in the file is the module declaration. You do not have to indent declarations in a top-level module.</p>

<p>In a local module declaration, only the declarations that are indented under that module declaration are part of the module.</p>

<h2>Syntax</h2>

<p>Syntax for module declaration is as follows &minus;</p>

<p>Please note that the accessibility-modifier can be one of the following &minus; public, private, internal. The default is <b>public</b>.</p>

<p>The following examples will demonstrate the concepts &minus;</p>

<h2>Example 1</h2>

<p>The module file Arithmetic.fs &minus;</p>

<p>The program file main.fs &minus;</p>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h2>Example 2</h2>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<h1>F# - Namespaces</h1>

<p>A <b>namespace</b> is designed for providing a way to keep one set of names separate from another. The class names declared in one namespace will not conflict with the same class names declared in another.</p>

<p>As per the MSDN library, a <b>namespace</b> lets you organize code into areas of related functionality by enabling you to attach a name to a grouping of program elements.</p>

<h2>Declaring a Namespace</h2>

<p>To organize your code in a namespace, you must declare the namespace as the first declaration in the file. The contents of the entire file then become part of the namespace.</p>

<p>The following example illustrates the concept &minus;</p>

<h2>Example</h2>

<p>When you compile and execute the program, it yields the following output &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
(* This is a comment *)
(* Sample Hello World program using F# *)
printfn "Hello World!"
</pre>
<p>For most of the examples given in this tutorial, you will find a Try it option in our website code sections at the top right corner that will take you to the online compiler. So just make use of it and enjoy your learning.</p>
</blockquote>
<h1>F# - Program Structure</h1>
<p>F# is a Functional Programming language.</p>
<p>In F#, functions work like data types. You can declare and use a function in the same way like any other variable.</p>
<p>In general, an F# application does not have any specific entry point. The compiler executes all top-level statements in the file from top to bottom.</p>
<p>However, to follow procedural programming style, many applications keep a single top level statement that calls the main loop.</p>
<p>The following code shows a simple F# program &minus;</p>
<pre class="prettyprint notranslate tryit">
open System
(* This is a multi-line comment *)
// This is a single-line comment

let sign num =
   if num &gt; 0 then "positive"
   elif num &lt; 0 then "negative"
   else "zero"

let main() =
   Console.WriteLine("sign 5: {0}", (sign 5))

main()
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
sign 5: positive
</pre>
<p>Please note that &minus;</p>
<ul class="list">
<li><p>An F# code file might begin with a number of <b>open</b> statements that is used to import namespaces.</p></li>
<li><p>The body of the files includes other functions that implement the business logic of the application.</p></li>
<li><p>The main loop contains the top executable statements.</p></li>
</ul>
<h1>F# - Basic Syntax</h1>
<p>You have seen the basic structure of an F# program, so it will be easy to understand other basic building blocks of the F# programming language.</p>
<h2>Tokens in F#</h2>
<p>An F# program consists of various tokens. A token could be a keyword, an identifier, a constant, a string literal, or a symbol. We can categorize F# tokens into two types &minus;</p>
<ul class="list">
<li>Keywords</li>
<li>Symbol and Operators</li>
</ul>
<h3>F# Keywords</h3>
<p>The following table shows the keywords and brief descriptions of the keywords. We will discuss the use of these keywords in subsequent chapters.</p>
<table class="table table-bordered">
<tr>
<th>Keyword</th>
<th>Description</th>
</tr>
<tr>
<td><b>abstract</b></td>
<td>Indicates a method that either has no implementation in the type in which it is declared or that is virtual and has a default implementation.</td>
</tr>
<tr>
<td><b>and</b></td>
<td>Used in mutually recursive bindings, in property declarations, and with multiple constraints on generic parameters.</td>
</tr>
<tr>
<td><b>as</b></td>
<td>Used to give the current class object an object name. Also used to give a name to a whole pattern within a pattern match.</td>
</tr>
<tr>
<td><b>assert</b></td>
<td>Used to verify code during debugging.</td>
</tr>
<tr>
<td><b>base</b></td>
<td>Used as the name of the base class object.</td>
</tr>
<tr>
<td><b>begin</b></td>
<td>In verbose syntax, indicates the start of a code block.</td>
</tr>
<tr>
<td><b>class</b></td>
<td>In verbose syntax, indicates the start of a class definition.</td>
</tr>
<tr>
<td><b>default</b></td>
<td>Indicates an implementation of an abstract method; used together with an abstract method declaration to create a virtual method.</td>
</tr>
<tr>
<td><b>delegate</b></td>
<td>Used to declare a delegate.</td>
</tr>
<tr>
<td><b>do</b></td>
<td>Used in looping constructs or to execute imperative code.</td>
</tr>
<tr>
<td><b>done</b></td>
<td>In verbose syntax, indicates the end of a block of code in a looping expression.</td>
</tr>
<tr>
<td><b>downcast</b></td>
<td>Used to convert to a type that is lower in the inheritance chain.</td>
</tr>
<tr>
<td><b>downto</b></td>
<td>In a <b>for</b> expression, used when counting in reverse.</td>
</tr>
<tr>
<td><b>elif</b></td>
<td>Used in conditional branching. A short form of else if.</td>
</tr>
<tr>
<td><b>else</b></td>
<td>Used in conditional branching.</td>
</tr>
<tr>
<td><b>end</b></td>
<td><p>In type definitions and type extensions, indicates the end of a section of member definitions.</p>
<p>In verbose syntax, used to specify the end of a code block that starts with the begin keyword.</p>
</td>
</tr>
<tr>
<td><b>exception</b></td>
<td>Used to declare an exception type.</td>
</tr>
<tr>
<td><b>extern</b></td>
<td>Indicates that a declared program element is defined in another binary or assembly.</td>
</tr>
<tr>
<td><b>false</b></td>
<td>Used as a Boolean literal.</td>
</tr>
<tr>
<td><b>finally</b></td>
<td>Used together with try to introduce a block of code that executes regardless of whether an exception occurs.</td>
</tr>
<tr>
<td><b>for</b></td>
<td>Used in looping constructs.</td>
</tr>
<tr>
<td><b>fun</b></td>
<td>Used in lambda expressions, also known as anonymous functions.</td>
</tr>
<tr>
<td><b>function</b></td>
<td>Used as a shorter alternative to the fun keyword and a match expression in a lambda expression that has pattern matching on a single argument.</td>
</tr>
<tr>
<td><b>global</b></td>
<td>Used to reference the top-level .NET namespace.</td>
</tr>
<tr>
<td><b>if</b></td>
<td>Used in conditional branching constructs.</td>
</tr>
<tr>
<td><b>in</b></td>
<td>Used for sequence expressions and, in verbose syntax, to separate expressions from bindings.</td>
</tr>
<tr>
<td><b>inherit</b></td>
<td>Used to specify a base class or base interface.</td>
</tr>
<tr>
<td><b>inline</b></td>
<td>Used to indicate a function that should be integrated directly into the caller's code.</td>
</tr>
<tr>
<td><b>interface</b></td>
<td>Used to declare and implement interfaces.</td>
</tr>
<tr>
<td><b>internal</b></td>
<td>Used to specify that a member is visible inside an assembly but not outside it.</td>
</tr>
<tr>
<td><b>lazy</b></td>
<td>Used to specify a computation that is to be performed only when a result is needed.</td>
</tr>
<tr>
<td><b>let</b></td>
<td>Used to associate, or bind, a name to a value or function.</td>
</tr>
<tr>
<td><b>let!</b></td>
<td>Used in asynchronous workflows to bind a name to the result of an asynchronous computation, or, in other computation expressions, used to bind a name to a result, which is of the computation type.</td>
</tr>
<tr>
<td><b>match</b></td>
<td>Used to branch by comparing a value to a pattern.</td>
</tr>
<tr>
<td><b>member</b></td>
<td>Used to declare a property or method in an object type.</td>
</tr>
<tr>
<td><b>module</b></td>
<td>Used to associate a name with a group of related types, values, and functions, to logically separate it from other code.</td>
</tr>
<tr>
<td><b>mutable</b></td>
<td>Used to declare a variable, that is, a value that can be changed.</td>
</tr>
<tr>
<td><b>namespace</b></td>
<td>Used to associate a name with a group of related types and modules, to logically separate it from other code.</td>
</tr>
<tr>
<td><b>new</b></td>
<td><p>Used to declare, define, or invoke a constructor that creates or that can create an object.</p>
<p>Also used in generic parameter constraints to indicate that a type must have a certain constructor.</p></td>
</tr>
<tr>
<td><b>not</b></td>
<td>Not actually a keyword. However, not struct in combination is used as a generic parameter constraint.</td>
</tr>
<tr>
<td><b>null</b></td>
<td><p>Indicates the absence of an object.</p>
<p>Also used in generic parameter constraints.</p></td>
</tr>
<tr>
<td><b>of</b></td>
<td>Used in discriminated unions to indicate the type of categories of values, and in delegate and exception declarations.</td>
</tr>
<tr>
<td><b>open</b></td>
<td>Used to make the contents of a namespace or module available without qualification.</td>
</tr>
<tr>
<td><b>or</b></td>
<td><p>Used with Boolean conditions as a Boolean or operator. Equivalent to ||.</p><p>Also used in member constraints.</p></td>
</tr>
<tr>
<td><b>override</b></td>
<td>Used to implement a version of an abstract or virtual method that differs from the base version.</td>
</tr>
<tr>
<td><b>private</b></td>
<td>Restricts access to a member to code in the same type or module.</td>
</tr>
<tr>
<td><b>public</b></td>
<td>Allows access to a member from outside the type.</td>
</tr>
<tr>
<td><b>rec</b></td>
<td>Used to indicate that a function is recursive.</td>
</tr>
<tr>
<td><b>return</b></td>
<td>Used to indicate a value to provide as the result of a computation expression.</td>
</tr>
<tr>
<td><b>return!</b></td>
<td>Used to indicate a computation expression that, when evaluated, provides the result of the containing computation expression.</td>
</tr>
<tr>
<td><b>select</b></td>
<td>Used in query expressions to specify what fields or columns to extract. Note that this is a contextual keyword, which means that it is not actually a reserved word and it only acts like a keyword in appropriate context.</td>
</tr>
<tr>
<td><b>static</b></td>
<td>Used to indicate a method or property that can be called without an instance of a type, or a value member that is shared among all instances of a type.</td>
</tr>
<tr>
<td><b>struct</b></td>
<td><p>Used to declare a structure type.</p>
<p>Also used in generic parameter constraints.</p>
<p>Used for OCaml compatibility in module definitions.</p></td>
</tr>
<tr>
<td><b>then</b></td>
<td><p>Used in conditional expressions.</p>
<p>Also used to perform side effects after object construction.</p></td>
</tr>
<tr>
<td><b>to</b></td>
<td>Used in for loops to indicate a range.</td>
</tr>
<tr>
<td><b>true</b></td>
<td>Used as a Boolean literal.</td>
</tr>
<tr>
<td><b>try</b></td>
<td>Used to introduce a block of code that might generate an exception. Used together with <i>with</i> or finally.</td>
</tr>
<tr>
<td><b>type</b></td>
<td>Used to declare a class, record, structure, discriminated union, enumeration type, unit of measure, or type abbreviation.</td>
</tr>
<tr>
<td><b>upcast</b></td>
<td>Used to convert to a type that is higher in the inheritance chain.</td>
</tr>
<tr>
<td><b>use</b></td>
<td>Used instead of let for values that require Dispose to be called to free resources.</td>
</tr>
<tr>
<td><b>use!</b></td>
<td>Used instead of let! in asynchronous workflows and other computation expressions for values that require Dispose to be called to free resources.</td>
</tr>
<tr>
<td><b>val</b></td>
<td>Used in a signature to indicate a value, or in a type to declare a member, in limited situations.</td>
</tr>
<tr>
<td><b>void</b></td>
<td>Indicates the .NET void type. Used when interoperating with other .NET languages.</td>
</tr>
<tr>
<td><b>when</b></td>
<td>Used for Boolean conditions <i>(when guards)</i> on pattern matches and to introduce a constraint clause for a generic type parameter.</td>
</tr>
<tr>
<td><b>while</b></td>
<td>Introduces a looping construct.</td>
</tr>
<tr>
<td><b>with</b></td>
<td>Used together with the match keyword in pattern matching expressions. Also used in object expressions, record copying expressions, and type extensions to introduce member definitions, and to introduce exception handlers.</td>
</tr>
<tr>
<td><b>yield</b></td>
<td>Used in a sequence expression to produce a value for a sequence.</td>
</tr>
<tr>
<td><b>yield!</b></td>
<td>Used in a computation expression to append the result of a given computation expression to a collection of results for the containing computation expression.</td>
</tr>
</table>
<p>Some reserved keywords came from the OCaml language &minus;</p>
<table class="table table-bordered">
<tr>
<td>asr</td>
<td>land</td>
<td>lor</td>
<td>lsl</td>
<td>lsr</td>
<td>lxor</td>
<td>mod</td>
<td>sig</td>
</tr>
</table>
<p>Some other reserved keywords are kept for future expansion of F#.</p>
<table class="table table-bordered">
<tr>
<td>atomic</td>
<td>break</td>
<td>checked</td>
<td>component</td>
<td>const</td>
<td>constraint</td>
<td>constructor</td>
</tr>
<tr>
<td>continue</td>
<td>eager</td>
<td>event</td>
<td>external</td>
<td>fixed</td>
<td>functor</td>
<td>include</td>
</tr>
<tr>
<td>method</td>
<td>mixin</td>
<td>object</td>
<td>parallel</td>
<td>process</td>
<td>protected</td>
<td>pure</td>
</tr>
<tr>
<td>sealed</td>
<td>tailcall</td>
<td>trait</td>
<td>virtual</td>
<td>volatile</td>
<td></td>
<td></td>
</tr>
</table>
<h2>Comments in F#</h2>
<p>F# provides two types of comments &minus;</p>
<ul class="list">
<li>One line comment starts with // symbol.</li>
<li>Multi line comment starts with (* and ends with *).</li>
</ul>
<h2>A Basic Program and Application Entry Point in F#</h2>
<p>Generally, you don’t have any explicit entry point for F# programs. When you compile an F# application, the last file provided to the compiler becomes the entry point and all top level statements in that file are executed from top to bottom.</p>
<p>A well-written program should have a single top-level statement that would call the main loop of the program.</p>
<p>A very minimalistic F# program that would display ‘Hello World’ on the screen &minus;</p>
<pre class="prettyprint notranslate tryit">
(* This is a comment *)
(* Sample Hello World program using F# *)
printfn "Hello World!"
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Hello World!
</pre>
<h1>F# - Data Types</h1>
<p>The data types in F# can be classified as follows &minus;</p>
<ul class="list">
<li>Integral types</li>
<li>Floating point types</li>
<li>Text types</li>
<li>Other types</li>
</ul>
<h2>Integral Data Type</h2>
<p>The following table provides the integral data types of F#. These are basically integer data types.</p>
<table class="table table-bordered">
<tr>
<th>F# Type</th>
<th style="width:20%;">Size</th>
<th>Range</th>
<th>Example</th>
<th>Remarks</th>
</tr>
<tr>
<td>sbyte</td>
<td>1 byte</td>
<td>-128 to 127</td>
<td><p>42y</p>
<p>-11y</p></td>
<td>8-bit signed integer</td>
</tr>
<tr>
<td>byte</td>
<td>1 byte</td>
<td>0 to 255</td>
<td><p>42uy</p>
<p>200uy</p></td>
<td>8-bit unsigned integer</td>
</tr>
<tr>
<td>int16</td>
<td>2 bytes</td>
<td>-32768 to 32767</td>
<td><p>42s</p>
<p>-11s</p></td>
<td>16-bit signed integer</td>
</tr>
<tr>
<td>uint16</td>
<td>2 bytes</td>
<td>0 to 65,535</td>
<td><p>42us</p>
<p>200us</p></td>
<td>16-bit unsigned integer</td>
</tr>
<tr>
<td>int/int32</td>
<td>4 bytes</td>
<td>-2,147,483,648 to 2,147,483,647</td>
<td><p>42</p>
<p>-11</p></td>
<td>32-bit signed integer</td>
</tr>
<tr>
<td>uint32</td>
<td>4 bytes</td>
<td>0 to 4,294,967,295</td>
<td><p>42u</p>
<p>200u</p></td>
<td>32-bit unsigned integer</td>
</tr>
<tr>
<td>int64</td>
<td>8 bytes</td>
<td>-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807</td>
<td><p>42L</p>
<p>-11L</p></td>
<td>64-bit signed integer</td>
</tr>
<tr>
<td>uint64</td>
<td>8 bytes</td>
<td>0 to 18,446,744,073,709,551,615</td>
<td><p>42UL</p>
<p>200UL</p></td>
<td>64-bit unsigned integer</td>
</tr>
<tr>
<td>bigint</td>
<td>At least 4 bytes</td>
<td>any integer</td>
<td><p>42I</p>
<p>1499999</p>
<p>9999999</p>
<p>9999999</p>
<p>9999999</p>
<p>9999I</p>
</td>
<td>arbitrary precision integer</td>
</tr>
</table>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
(* single byte integer *)
let x = 268.97f
let y = 312.58f
let z = x + y

printfn "x: %f" x
printfn "y: %f" y
printfn "z: %f" z

(* unsigned 8-bit natural number *)

let p = 2uy
let q = 4uy
let r = p + q

printfn "p: %i" p
printfn "q: %i" q
printfn "r: %i" r

(* signed 16-bit integer *)

let a = 12s
let b = 24s
let c = a + b

printfn "a: %i" a
printfn "b: %i" b
printfn "c: %i" c

(* signed 32-bit integer *)

let d = 212l
let e = 504l
let f = d + e

printfn "d: %i" d
printfn "e: %i" e
printfn "f: %i" f
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
x: 1
y: 2
z: 3
p: 2
q: 4
r: 6
a: 12
b: 24
c: 36
d: 212
e: 504
f: 716
</pre>
<h2>Floating Point Data Types</h2>
<p>The following table provides the floating point data types of F#.</p>
<table class="table table-bordered">
<tr>
<th>F# Type</th>
<th style="width:20%;">Size</th>
<th style="width:28%;">Range</th>
<th>Example</th>
<th>Remarks</th>
</tr>
<tr>
<td>float32</td>
<td>4 bytes</td>
<td>±1.5e-45 to ±3.4e38</td>
<td><p>42.0F</p>
<p>-11.0F</p></td>
<td>32-bit signed floating point number (7 significant digits)</td>
</tr>
<tr>
<td>float</td>
<td>8 bytes</td>
<td>±5.0e-324 to ±1.7e308</td>
<td><p>42.0</p>
<p>-11.0</p></td>
<td>64-bit signed floating point number (15-16 significant digits)</td>
</tr>
<tr>
<td>decimal</td>
<td>16 bytes</td>
<td>±1.0e-28 to ±7.9e28</td>
<td><p>42.0M</p>
<p>-11.0M</p></td>
<td>128-bit signed floating point number (28-29 significant digits)</td>
</tr>
<tr>
<td>BigRational</td>
<td>At least 4 bytes</td>
<td>Any rational number.</td>
<td><p>42N</p>
<p>-11N</p></td>
<td>Arbitrary precision rational number. Using this type requires a reference to FSharp.PowerPack.dll.</td>
</tr>
</table>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
(* 32-bit signed floating point number *)
(* 7 significant digits *)

let d = 212.098f
let e = 504.768f
let f = d + e

printfn "d: %f" d
printfn "e: %f" e
printfn "f: %f" f

(* 64-bit signed floating point number *)
(* 15-16 significant digits *)
let x = 21290.098
let y = 50446.768
let z = x + y

printfn "x: %g" x
printfn "y: %g" y
printfn "z: %g" z
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
d: 212.098000
e: 504.768000
f: 716.866000
x: 21290.1
y: 50446.8
z: 71736.9
</pre>
<h2>Text Data Types</h2>
<p>The following table provides the text data types of F#.</p>
<table class="table table-bordered">
<tr>
<th style="width:12%;">F# Type</th>
<th>Size</th>
<th>Range</th>
<th>Example</th>
<th>Remarks</th>
</tr>
<tr>
<td>char</td>
<td>2 bytes</td>
<td>U+0000 to U+ffff</td>
<td><p>'x'</p>
<p>'\t'</p></td>
<td>Single unicode characters</td>
</tr>
<tr>
<td>string</td>
<td>20 + (2 * string's length) bytes</td>
<td>0 to about 2 billion characters</td>
<td><p>"Hello"</p>
<p>"World"</p></td>
<td>Unicode text</td>
</tr>
</table>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
let choice = 'y'
let name = "Zara Ali"
let org = "Tutorials Point"

printfn "Choice: %c" choice
printfn "Name: %s" name
printfn "Organisation: %s" org
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Choice: y
Name: Zara Ali
Organisation: Tutorials Point
</pre>
<h2>Other Data Types</h2>
<p>The following table provides some other data types of F#.</p>
<table class="table table-bordered">
<tr>
<th style="width:12%;">F# Type</th>
<th style="width:15%;">Size</th>
<th>Range</th>
<th>Example</th>
<th>Remarks</th>
</tr>
<tr>
<td>bool</td>
<td>1 byte</td>
<td>Only two possible values, true or false</td>
<td><p>true</p>
<p>false</p></td>
<td>Stores boolean values</td>
</tr>
</table>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
let trueVal = true
let falseVal = false

printfn "True Value: %b" (trueVal)
printfn "False Value: %b" (falseVal)
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
True Value: true
False Value: false
</pre>
<h1>F# - Variables</h1>
<p>A variable is a name given to a storage area that our programs can manipulate. Each variable has a specific type, which determines the size and layout of the variable's memory; the range of values that can be stored within that memory; and the set of operations that can be applied to the variable.</p>
<h2>Variable Declaration in F#</h2>
<p>The <b>let</b> keyword is used for variable declaration &minus;</p>
<p>For example,</p>
<pre class="result notranslate">
let x = 10
</pre>
<p>It declares a variable x and assigns the value 10 to it.</p>
<p>You can also assign an expression to a variable &minus;</p>
<pre class="result notranslate">
let x = 10
let y = 20
let z = x + y
</pre>
<p>The following example illustrates the concept &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
let x = 10
let y = 20
let z = x + y

printfn "x: %i" x
printfn "y: %i" y
printfn "z: %i" z
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
x: 10
y: 20
z: 30
</pre>
<p>Variables in F# are <b>immutable,</b> which means once a variable is bound to a value, it can’t be changed. They are actually compiled as static read-only properties.</p>
<p>The following example demonstrates this.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
let x = 10
let y = 20
let z = x + y

printfn "x: %i" x
printfn "y: %i" y
printfn "z: %i" z

let x = 15
let y = 20
let z = x + y

printfn "x: %i" x
printfn "y: %i" y
printfn "z: %i" z
</pre>
<p>When you compile and execute the program, it shows the following error message &minus;</p>
<pre class="result notranslate">
Duplicate definition of value 'x'
Duplicate definition of value 'Y'
Duplicate definition of value 'Z'
</pre>
<h2>Variable Definition With Type Declaration</h2>
<p>A variable definition tells the compiler where and how much storage for the variable should be created. A variable definition may specify a data type and contains a list of one or more variables of that type as shown in the following example.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
let x:int32 = 10
let y:int32 = 20
let z:int32 = x + y

printfn "x: %d" x
printfn "y: %d" y
printfn "z: %d" z

let p:float = 15.99
let q:float = 20.78
let r:float = p + q

printfn "p: %g" p
printfn "q: %g" q
printfn "r: %g" r
</pre>
<p>When you compile and execute the program, it shows the following error message &minus;</p>
<pre class="result notranslate">
x: 10
y: 20
z: 30
p: 15.99
q: 20.78
r: 36.77
</pre>
<h2>Mutable Variables</h2>
<p>At times you need to change the values stored in a variable. To specify that there could be a change in the value of a declared and assigned variable, in later part of a program, F# provides the <b>mutable</b> keyword. You can declare and assign mutable variables using this keyword, whose values you will change.</p>
<p>The <b>mutable</b> keyword allows you to declare and assign values in a mutable variable.</p>
<p>You can assign some initial value to a mutable variable using the <b>let</b> keyword. However, to assign new subsequent value to it, you need to use the <b>&larr;</b> operator.</p>
<p>For example,</p>
<pre class="result notranslate">
let mutable x = 10
x &larr; 15
</pre>
<p>The following example will clear the concept &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
let mutable x = 10
let y = 20
let mutable z = x + y

printfn "Original Values:"
printfn "x: %i" x
printfn "y: %i" y
printfn "z: %i" z

printfn "Let us change the value of x"
printfn "Value of z will change too."

x &lt;- 15
z &lt;- x + y

printfn "New Values:"
printfn "x: %i" x
printfn "y: %i" y
printfn "z: %i" z
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Original Values:
x: 10
y: 20
z: 30
Let us change the value of x
Value of z will change too.
New Values:
x: 15
y: 20
z: 35
</pre>
<h1>F# - Operators</h1>
<p>An operator is a symbol that tells the compiler to perform specific mathematical or logical manipulations. F# is rich in built-in operators and provides the following types of operators &minus;</p>
<ul class="list">
<li>Arithmetic Operators</li>
<li>Comparison Operators</li>
<li>Boolean Operators</li>
<li>Bitwise Operators</li>
</ul>
<h2>Arithmetic Operators</h2>
<p>The following table shows all the arithmetic operators supported by F# language. Assume variable A holds 10 and variable B holds 20 then &minus;</p>
<table class="table table-bordered">
<tr>
<th>Operator</th>
<th>Description</th>
<th style="width:24%;">Example</th>
</tr>
<tr>
<td>+</td>
<td>Adds two operands</td>
<td>A + B will give 30</td>
</tr>
<tr>
<td>-</td>
<td>Subtracts second operand from the first</td>
<td>A - B will give -10</td>
</tr>
<tr>
<td>*</td>
<td>Multiplies both operands</td>
<td>A * B will give 200</td>
</tr>
<tr>
<td>/</td>
<td>Divides numerator by de-numerator</td>
<td>B / A will give 2</td>
</tr>
<tr>
<td>%</td>
<td>Modulus Operator and remainder of after an integer division</td>
<td>B % A will give 0</td>
</tr>
<tr>
<td>**</td>
<td>Exponentiation Operator, raises an operand to the power of another</td>
<td>B**A will give 20<sup>10</sup></td>
</tr>
</table>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
let a : int32 = 21
let b : int32 = 10

let mutable c = a + b
printfn "Line 1 - Value of c is %d" c

c &lt;- a - b;
printfn "Line 2 - Value of c is %d" c

c &lt;- a * b;
printfn "Line 3 - Value of c is %d" c

c &lt;- a / b;
printfn "Line 4 - Value of c is %d" c

c &lt;- a % b;
printfn "Line 5 - Value of c is %d" c
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Line 1 - Value of c is 31
Line 2 - Value of c is 11
Line 3 - Value of c is 210
Line 4 - Value of c is 2
Line 5 - Value of c is 1
</pre>
<h2>Comparison Operators</h2>
<p>The following table shows all the comparison operators supported by F# language. These binary comparison operators are available for integral and floating-point types. These operators return values of type bool.</p>
<p>Assume variable A holds 10 and variable B holds 20, then &minus;</p>
<table class="table table-bordered">
<tr>
<th>Operator</th>
<th>Description</th>
<th style="width:24%;">Example</th>
</tr>
<tr>
<td>=</td>
<td>Checks if the values of two operands are equal or not, if yes then condition becomes true.</td>
<td>(A == B) is not true.</td>
</tr>
<tr>
<td>&lt;&gt;</td>
<td>Checks if the values of two operands are equal or not, if values are not equal then condition becomes true.</td>
<td>(A &lt;&gt; B) is true.</td>
</tr>
<tr>
<td>&gt;</td>
<td>Checks if the value of left operand is greater than the value of right operand, if yes then condition becomes true.</td>
<td>(A &gt; B) is not true.</td>
</tr>
<tr>
<td>&lt;</td>
<td>Checks if the value of left operand is less than the value of right operand, if yes then condition becomes true.</td>
<td>(A &lt; B) is true.</td>
</tr>
<tr>
<td>&gt;=</td>
<td>Checks if the value of left operand is greater than or equal to the value of right operand, if yes then condition becomes true.</td>
<td>(A &gt;= B) is not true.</td>
</tr>
<tr>
<td>&lt;=</td>
<td>Checks if the value of left operand is less than or equal to the value of right operand, if yes then condition becomes true.</td>
<td>(A &lt;= B) is true.</td>
</tr>
</table>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
let mutable a : int32 = 21
let mutable b : int32 = 10

if (a = b) then
   printfn "Line 1 - a is equal to b"
else
   printfn "Line 1 - a is not equal to b"

if (a &lt; b) then
   printfn "Line 2 - a is less than b"
else
   printfn "Line 2 - a is not less than b"

if (a &gt; b) then
   printfn "Line 3 - a is greater than b"
else
   printfn "Line 3 - a is not greater than b"

(* Lets change value of a and b *)
a &lt;- 5
b &lt;- 20

if (a &lt;= b) then
   printfn "Line 4 - a is either less than or equal to b"
else
   printfn "Line4 - a is a is greater than b"
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Line 1 - a is not equal to b
Line 2 - a is not less than b
Line 3 - a is greater than b
Line 4 - a is either less than or equal to b
</pre>
<h2>Boolean Operators</h2>
<p>The following table shows all the Boolean operators supported by F# language. Assume variable A holds <b>true</b> and variable B holds <b>false,</b> then &minus;</p>
<table class="table table-bordered">
<tr>
<th>Operator</th>
<th>Description</th>
<th style="width:25%;">Example</th>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>Called Boolean AND operator. If both the operands are non-zero, then condition becomes true.</td>
<td>(A &amp;&amp; B) is false.</td>
</tr>
<tr>
<td>||</td>
<td>Called Boolean OR Operator. If any of the two operands is non-zero, then condition becomes true.</td>
<td>(A || B) is true.</td>
</tr>
<tr>
<td>not</td>
<td>Called Boolean NOT Operator. Use to reverses the logical state of its operand. If a condition is true then Logical NOT operator will make false.</td>
<td>not (A &amp;&amp; B) is true.</td>
</tr>
</table>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
let mutable a : bool = true;
let mutable b : bool = true;

if ( a &amp;&amp; b ) then
   printfn "Line 1 - Condition is true"
else
   printfn "Line 1 - Condition is not true"

if ( a || b ) then
   printfn "Line 2 - Condition is true"
else
   printfn "Line 2 - Condition is not true"

(* lets change the value of a *)

a &lt;- false
if ( a &amp;&amp; b ) then
   printfn "Line 3 - Condition is true"
else
   printfn "Line 3 - Condition is not true"

if ( a || b ) then
   printfn "Line 4 - Condition is true"
else
   printfn "Line 4 - Condition is not true"
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Line 1 - Condition is true
Line 2 - Condition is true
Line 3 - Condition is not true
Line 4 - Condition is true
</pre>
<h2>Bitwise Operators</h2>
<p>Bitwise operators work on bits and perform bit-by-bit operation. The truth tables for &amp;&amp;&amp; (bitwise AND), ||| (bitwise OR), and ^^^ (bitwise exclusive OR) are as follows &minus;</p>
<table class="table table-bordered">
<tr>
<td>p</td>
<td>q</td>
<td>p &amp;&amp;&amp; q</td>
<td>p ||| q</td>
<td>p ^^^ q</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
</table>
<p>Assume if A = 60; and B = 13; now in binary format they will be as follows &minus;</p>
<p>A = 0011 1100</p>
<p>B = 0000 1101</p>
-----------------
<p>A&amp;&amp;&amp;B = 0000 1100</p>
<p>A|||B = 0011 1101</p>
<p>A^^^B = 0011 0001</p>
<p>~~~A = 1100 0011</p>
<p>The Bitwise operators supported by F# language are listed in the following table. Assume variable A holds 60 and variable B holds 13, then &minus;</p>
<table class="table table-bordered">
<tr>
<th>Operator</th>
<th>Description</th>
<th>Example</th>
</tr>
<tr>
<td>&amp;&amp;&amp;</td>
<td>Binary AND Operator copies a bit to the result if it exists in both operands.</td>
<td>(A &amp;&amp;&amp; B) will give 12, which is 0000 1100</td>
</tr>
<tr>
<td>|||</td>
<td>Binary OR Operator copies a bit if it exists in either operand.</td>
<td>(A ||| B) will give 61, which is 0011 1101</td>
</tr>
<tr>
<td>^^^</td>
<td>Binary XOR Operator copies the bit if it is set in one operand but not both.</td>
<td>(A ^^^ B) will give 49, which is 0011 0001</td>
</tr>
<tr>
<td>~~~</td>
<td>Binary Ones Complement Operator is unary and has the effect of 'flipping' bits.</td>
<td>(~~~A) will give -61, which is 1100 0011 in 2's complement form.</td>
</tr>
<tr>
<td>&lt;&lt;&lt;</td>
<td>Binary Left Shift Operator. The left operands value is moved left by the number of bits specified by the right operand.</td>
<td>A &lt;&lt;&lt; 2 will give 240 which is 1111 0000</td>
</tr>
<tr>
<td>&gt;&gt;&gt;</td>
<td>Binary Right Shift Operator. The left operands value is moved right by the number of bits specified by the right operand.</td>
<td>A &gt;&gt;&gt; 2 will give 15 which is 0000 1111</td>
</tr>
</table>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
let a : int32 = 60 // 60 = 0011 1100
let b : int32 = 13 // 13 = 0000 1101
let mutable c : int32 = 0

c &lt;- a &&& b // 12 = 0000 1100
printfn "Line 1 - Value of c is %d" c

c &lt;- a ||| b // 61 = 0011 1101
printfn "Line 2 - Value of c is %d" c

c &lt;- a ^^^ b // 49 = 0011 0001
printfn "Line 3 - Value of c is %d" c

c = ~~~a // -61 = 1100 0011
printfn "Line 4 - Value of c is %d" c

c &lt;- a &lt;&lt;&lt; 2 // 240 = 1111 0000
printfn "Line 5 - Value of c is %d" c

c &lt;- a &gt;&gt;&gt; 2 // 15 = 0000 1111
printfn "Line 6 - Value of c is %d" c
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Line 1 - Value of c is 12
Line 2 - Value of c is 61
Line 3 - Value of c is 49
Line 4 - Value of c is 49
Line 5 - Value of c is 240
Line 6 - Value of c is 15
</pre>
<h2>Operators Precedence</h2>
<p>The following table shows the order of precedence of operators and other expression keywords in the F# language, from lowest precedence to the highest precedence.</p>
<table class="table table-bordered">
<tr>
<th>Operator</th>
<th>Associativity</th>
</tr>
<tr>
<td>as</td>
<td>Right</td>
</tr>
<tr>
<td>when</td>
<td>Right</td>
</tr>
<tr>
<td>| (pipe)</td>
<td>Left</td>
</tr>
<tr>
<td>;</td>
<td>Right</td>
</tr>
<tr>
<td>let</td>
<td>Non associative</td>
</tr>
<tr>
<td>function, fun, match, try</td>
<td>Non associative</td>
</tr>
<tr>
<td>if</td>
<td>Non associative</td>
</tr>
<tr>
<td>&rarr;</td>
<td>Right</td>
</tr>
<tr>
<td>:=</td>
<td>Right</td>
</tr>
<tr>
<td>,</td>
<td>Non associative</td>
</tr>
<tr>
<td>or, ||</td>
<td>Left</td>
</tr>
<tr>
<td>&amp;, &amp;&amp;</td>
<td>Left</td>
</tr>
<tr>
<td>&lt; op, &gt;op, =, |op, &amp;op </td>
<td>Left</td>
</tr>
<tr>
<td>&amp;&amp;&amp; , |||, ^^^, ~~~, &lt;&lt;&lt;, &gt;&gt;&gt;</td>
<td>Left</td>
</tr>
<tr>
<td>^ op</td>
<td>Right</td>
</tr>
<tr>
<td>::</td>
<td>Right</td>
</tr>
<tr>
<td>:?&gt;, :?</td>
<td>Non associative</td>
</tr>
<tr>
<td>- op, +op, (binary)</td>
<td>Left</td>
</tr>
<tr>
<td>* op, /op, %op</td>
<td>Left</td>
</tr>
<tr>
<td>** op</td>
<td>Right</td>
</tr>
<tr>
<td>f x (function application)</td>
<td>Left</td>
</tr>
<tr>
<td>| (pattern match)</td>
<td>Right</td>
</tr>
<tr>
<td>prefix operators (&plus;op, -op, %, %%, &amp;, &amp;&amp;, !op, ~op)</td>
<td>Left</td>
</tr>
<tr>
<td>.</td>
<td>Left</td>
</tr>
<tr>
<td>f(x)</td>
<td>Left</td>
</tr>
<tr>
<td>f&lt;types&gt;</td>
<td>Left</td>
</tr>
</table>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
let a : int32 = 20
let b : int32 = 10
let c : int32 = 15
let d : int32 = 5

let mutable e : int32 = 0
e &lt;- (a + b) * c / d // ( 30 * 15 ) / 5
printfn "Value of (a + b) * c / d is : %d" e

e &lt;- ((a + b) * c) / d // (30 * 15 ) / 5
printfn "Value of ((a + b) * c) / d is : %d" e

e &lt;- (a + b) * (c / d) // (30) * (15/5)
printfn "Value of (a + b) * (c / d) is : %d" e

e &lt;- a + (b * c) / d // 20 + (150/5)
printfn "Value of a + (b * c) / d is : %d" e
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Value of (a + b) * c / d is : 90 
Value of ((a + b) * c) / d is : 90
Value of (a + b) * (c / d) is : 90 
Value of a + (b * c) / d is : 50
</pre>
<h1>F# - Decision Making</h1>
<p>Decision making structures require that the programmer specify one or more conditions to be evaluated or tested by the program. It should be along with a statement or statements to be executed if the condition is determined to be true, and optionally, other statements to be executed if the condition is determined to be false.</p>
<p>Following is the general form of a typical decision making structure found in most of the programming languages &minus;</p>
<img src="/fsharp/images/decision_making.jpg" alt="Decision Making" />
<p>F# programming language provides the following types of decision making statements.</p>
<table class="table table-bordered">
<tr>
<th style="width:32%;">Statement</th>
<th>Description</th>
</tr>
<tr>
<td>if /then statement</td>
<td>An <b>if/then statement</b> consists of a Boolean expression followed by one or more statements.</td>
</tr>
<tr>
<td>if/then/ else statement</td>
<td>An <b>if/then statement</b> can be followed by an optional <b>else statement,</b> which executes when the Boolean expression is false.</td>
</tr>
<tr>
<td>if/then/elif/else statement</td>
<td>An <b>if/then/elif/else</b> statement allows you to have multiple else branches.</td>
</tr>
<tr>
<td>nested if statements</td>
<td>You can use one <b>if</b> or <b>else if</b> statement inside another <b>if</b> or <b>else if</b> statement(s).</td>
</tr>
</table>
<h2>F#-if/then Statement</h2>
<p>An if/then statement consists of a Boolean expression followed by one or more statements.</p>
<h3>Syntax</h3>
<p>The if/then construct in F# has the following syntax &minus;</p>
<pre class="result notranslate">
(* simple if *)
if expr then
   expr
</pre>
<h3>Flow diagram</h3>
<img src="/fsharp/images/if_then_statement.jpg" alt="If then Statement" />
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
let a : int32 = 10

(* check the boolean condition using if statement *)
if (a &lt; 20) then
   printfn "a is less than 20\n"
   printfn "Value of a is: %d" a
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
a is less than 20

Value of a is: 10
</pre>
<h2>F#-if/then/else Statement</h2>
<p>An <b>if/then</b> statement can be followed by an optional <b>else</b> statement, which executes when the Boolean expression is false.</p>
<h3>Syntax</h3>
<p>The syntax of an if/then/else statement in F# programming language is &minus;</p>
<pre class="result notranslate">
if expr then
   expr
else
   expr
</pre>
<h3>Flow Diagram</h3>
<img src="/fsharp/images/else_statement.jpg" alt="Else Statement" />
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
let a : int32 = 100

(* check the boolean condition using if statement *)

if (a &lt; 20) then
   printfn "a is less than 20\n"
else
   printfn "a is not less than 20\n"
   printfn "Value of a is: %d" a
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
a is not less than 20

Value of a is: 100
</pre>
<h2>F#-if/then/elif/else Statement</h2>
<p>An <b>if/then/elif/else</b> construct has multiple else branches.</p>
<h3>Syntax</h3>
<p>The syntax of an if/then/elif/else statement in F# programming language is &minus;</p>
<pre class="result notranslate">
if expr then
   expr
elif expr then
   expr
elif expr then
   expr
...
else
   expr
</pre>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
let a : int32 = 100

(* check the boolean condition using if statement *)

if (a = 10) then
   printfn "Value of a is 10\n"
elif (a = 20) then
   printfn " Value of a is 20\n"
elif (a = 30) then
   printfn " Value of a is 30\n"
else
   printfn " None of the values are matching\n"
   printfn "Value of a is: %d" a
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
None of the values are matching

Value of a is: 100
</pre>
<h2>F#-Nested if Statements</h2>
<p>It is always legal in F# programming to nest if/then or if/then/else statements, which means you can use one <b>if</b> or <b>else if</b> statement inside another <b>if</b> or <b>else if </b>statement(s).</p>
<h3>Syntax</h3>
<pre class="result notranslate">
if expr then
   expr
   if expr then
      expr
   else
      expr
else
   expr
</pre>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
let a : int32 = 100
let b : int32 = 200

(* check the boolean condition using if statement *)

if (a = 100) then
(* if condition is true then check the following *)

   if (b = 200) then
      printfn "Value of a is 100 and b is 200\n"
printfn "Exact value of a is: %d" a
printfn "Exact value of b is: %d" b
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Value of a is 100 and b is 200

Exact value of a is: 100
Exact value of b is: 200
</pre>
<h1>F# - Loops</h1>
<p>Programming languages provide various control structures that allow for more complicated execution paths.</p>
<p>A loop statement allows us to execute a statement or group of statements multiple times and following is the general form of a loop statement in most of the programming languages &minus;</p>
<img src="/fsharp/images/loop_statement.jpg" alt="Loop Statement" />
<p>F# provides the following types of loops to handle the looping requirements.</p>
<table class="table table-bordered">
<tr>
<th style="width:45%;">Loop Type</th>
<th>Description</th>
</tr>
<tr>
<td>for… to and for… downto expressions</td>
<td>The for...to expression is used to iterate in a loop over a range of values of a loop variable. The for… downto expression reduces the value of loop variable.</td>
</tr>
<tr>
<td>for … in expression</td>
<td>This form of for loop is used to iterate over collections of items i.e., loops over collections and sequences</td>
</tr>
<tr>
<td>While…do loop</td>
<td>Repeats a statement or group of statements while a given condition is true. It tests the condition before executing the loop body.</td>
</tr>
<tr>
<td>nested loops</td>
<td>You can use one or more loop inside any other for or while loop.</td>
</tr>
</table>
<h2>F#-for...to and for...downto Expressions</h2>
<p>A <b>for loop</b> is a repetition control structure that allows you to efficiently write a loop that needs to execute a specific number of times.</p>
<h3>Syntax</h3>
<p>The syntax of a <b>for…to</b> loop in F# programming language is &minus;</p>
<pre class="result notranslate">
for var = start-expr to end-expr do
   ... // loop body
</pre>
<p>The syntax of a for…downto loop in F# programming language is &minus;</p>
<pre class="result notranslate">
for var = start-expr downto end-expr do
   ... // loop body
</pre>
<h3>Example 1</h3>
<p>The following program prints out the numbers 1 - 20 &minus;</p>
<pre class="prettyprint notranslate tryit">
let main() =
   for i = 1 to 20 do
      printfn "i: %i" i
main()
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
i: 1
i: 2
i: 3
i: 4
i: 5
i: 6
i: 7
i: 8
i: 9
i: 10
i: 11
i: 12
i: 13
i: 14
i: 15
i: 16
i: 17
i: 18
i: 19
i: 20
</pre>
<h3>Example 2</h3>
<p>The following program counts in reverse and prints out the numbers 20 - 1 &minus;</p>
<pre class="prettyprint notranslate tryit">
let main() =
   for i = 20 downto 1 do
      printfn "i: %i" i
main()
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
i: 20
i: 19
i: 18
i: 17
i: 16
i: 15
i: 14
i: 13
i: 12
i: 11
i: 10
i: 9
i: 8
i: 7
i: 6
i: 5
i: 4
i: 3
i: 2
i: 1
</pre>
<h2>F#-for...in Expressions</h2>
<p>This looping construct is used to iterate over the matches of a pattern in an enumerable collection such as a range expression, sequence, list, array, or other construct that supports enumeration.</p>
<h3>Syntax</h3>
<pre class="result notranslate">
for pattern in enumerable-expression do
   body-expression
</pre>
<h3>Example</h3>
<p>The following program illustrates the concept &minus;</p>
<pre class="prettyprint notranslate tryit">
// Looping over a list.
let list1 = [ 10; 25; 34; 45; 78 ]
for i in list1 do
   printfn "%d" i

// Looping over a sequence.
let seq1 = seq { for i in 1 .. 10 -> (i, i*i) }
for (a, asqr) in seq1 do
   printfn "%d squared is %d" a asqr
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
10
25
34
45
78
1 squared is 1
2 squared is 4
3 squared is 9
4 squared is 16
5 squared is 25
6 squared is 36
7 squared is 49
8 squared is 64
9 squared is 81
10 squared is 100
</pre>
<h2>F#-While…do Expressions</h2>
<p>The <b>while...do</b> expression is used to perform iterative execution while a specified test condition is true.</p>
<h3>Syntax</h3>
<pre class="result notranslate">
while test-expression do
   body-expression
</pre>
<p>The test-expression is evaluated first; if it is true, the body-expression is executed and the test expression is evaluated again. The body-expression must have type unit, i.e., it should not return any value. If the test expression is false, the iteration ends.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
let mutable a = 10
while (a &lt; 20) do
   printfn "value of a: %d" a
   a &lt;- a + 1
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
value of a: 10
value of a: 11
value of a: 12
value of a: 13
value of a: 14
value of a: 15
value of a: 16
value of a: 17
value of a: 18
value of a: 19
</pre>
<h2>F#-Nested Loops</h2>
<p>F# programming language allows to use one loop inside another loop.</p>
<h3>Syntax</h3>
<p>The syntax for a nested for loop statement could be as follows &minus;</p>
<pre class="result notranslate">
for var1 = start-expr1 to end-expr1 do
   for var2 = start-expr2 to end-expr2 do
      ... // loop body
</pre>
<p>The syntax for a nested while loop statement could be as follows &minus;</p>
<pre class="result notranslate">
while test-expression1 do
   while test-expression2 do
      body-expression
</pre>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
let main() =
   for i = 1 to 5 do
      printf "\n"
      for j = 1 to 3 do
         printf "*"
main()
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
***
***
***
***
***
</pre>
<h1>F# - Functions</h1>
<p>In F#, functions work like data types. You can declare and use a function in the same way like any other variable.</p>
<p>Since functions can be used like any other variables, you can &minus;</p>
<ul class="list">
<li>Create a function, with a name and associate that name with a type.</li>
<li>Assign it a value.</li>
<li>Perform some calculation on that value.</li>
<li>Pass it as a parameter to another function or sub-routine.</li>
<li>Return a function as the result of another function.</li>
</ul>
<h2>Defining a Function</h2>
<p>Functions are defined by using the <b>let</b> keyword. A function definition has the following syntax &minus;</p>
<pre class="result notranslate">
let [inline] function-name parameter-list [ : return-type ]
= function-body
</pre>
<p>Where,</p>
<ul class="list">
<li><p><b>function-name</b> is an identifier that represents the function.</p></li>
<li><p><b>parameter-list</b> gives the list of parameters separated by spaces. You can also specify an explicit type for each parameter and if not specified compiler tends to deduce it from the function body (like variables).</p></li>
<li><p><b>function-body</b> consists of an expression, or a compound expression consisting of a number of expressions. The final expression in the function body is the return value.</p></li>
<li><p><b>return-type</b> is a colon followed by a type and is optional. If the return type is not specified, then the compiler determines it from the final expression in the function body.</p></li>
</ul>
<h2>Parameters of a Function</h2>
<p>You list the names of parameters right after the function name. You can specify the type of a parameter. The type of the parameter should follow the name of the parameter separated by a colon.</p>
<p>If no parameter type is specified, it is inferred by the compiler.</p>
<p>For example &minus;</p>
<pre class="result notranslate">
let doubleIt (x : int) = 2 * x
</pre>
<h3>Calling a Function</h3>
<p>A function is called by specifying the function name followed by a space and then any arguments separated by spaces.</p>
<p>For example &minus;</p>
<pre class="result notranslate">
let vol = cylinderVolume 3.0 5.0
</pre>
<p>The following programs illustrate the concepts.</p>
<h3>Example 1</h3>
<p>The following program calculates the volume of a cylinder when the radius and length are given as parameters.</p>
<pre class="prettyprint notranslate tryit">
// the function calculates the volume of
// a cylinder with radius and length as parameters

let cylinderVolume radius length : float =

   // function body
   let pi = 3.14159
   length * pi * radius * radius

let vol = cylinderVolume 3.0 5.0
printfn " Volume: %g " vol
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Volume: 141.372
</pre>
<h3>Example 2</h3>
<p>The following program returns the larger value of two given parameters &minus;</p>
<pre class="prettyprint notranslate tryit">
// the function returns the larger value between two
// arguments

let max num1 num2 : int32 =
   // function body
   if(num1>num2)then
      num1
   else
      num2

let res = max 39 52
printfn " Max Value: %d " res
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Max Value: 52
</pre>
<h3>Example 3</h3>
<pre class="prettyprint notranslate tryit">
let doubleIt (x : int) = 2 * x
printfn "Double 19: %d" ( doubleIt(19))
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Double 19: 38
</pre>
<h2>Recursive Functions</h2>
<p>Recursive functions are functions that call themselves.</p>
<p>You define a recursive using the <b>let rec</b> keyword combination.</p>
<p>Syntax for defining a recursive function is &minus;</p>
<pre class="result notranslate">
//Recursive function definition
let rec function-name parameter-list = recursive-function-body
</pre>
<p>For example &minus;</p>
<pre class="result notranslate">
let rec fib n = if n &lt; 2 then 1 else fib (n - 1) &plus; fib (n - 2)
</pre>
<h3>Example 1</h3>
<p>The following program returns Fibonacci 1 to 10 &minus;</p>
<pre class="prettyprint notranslate tryit">
let rec fib n = if n &lt; 2 then 1 else fib (n - 1) &plus; fib (n - 2)
for i = 1 to 10 do
   printfn "Fibonacci %d: %d" i (fib i)
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Fibonacci 1: 1
Fibonacci 2: 2
Fibonacci 3: 3
Fibonacci 4: 5
Fibonacci 5: 8
Fibonacci 6: 13
Fibonacci 7: 21
Fibonacci 8: 34
Fibonacci 9: 55
Fibonacci 10: 89
</pre>
<h3>Example 2</h3>
<p>The following program returns factorial 8 &minus;</p>
<pre class="prettyprint notranslate tryit">
open System
let rec fact x =
   if x &lt; 1 then 1
   else x * fact (x - 1)
Console.WriteLine(fact 8)
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
40320
</pre>
<h2>Arrow Notations in F#</h2>
<p>F# reports about data type in functions and values, using a chained arrow notation. Let us take an example of a function that takes one <i>int</i> input, and returns a string. In arrow notation, it is written as &minus;</p>
<pre class="result notranslate">
int -&gt; string
</pre>
<p>Data types are read from left to right.</p>
<p>Let us take another hypothetical function that takes two int data inputs and returns a string.</p>
<pre class="result notranslate">
let mydivfunction x y = (x / y).ToString();;
</pre>
<p>F# reports the data type using chained arrow notation as &minus;</p>
<pre class="result notranslate">
val mydivfunction : x:int -&gt; y:int -&gt; string
</pre>
<p>The return type is represented by the rightmost data type in chained arrow notation.</p>
<p>Some more examples &minus;</p>
<table class="table table-bordered">
<tr>
<th>Notation</th>
<th>Meaning</th>
</tr>
<tr>
<td>float &rarr; float &rarr; float</td>
<td>The function takes two <i>float</i> inputs, returns another <i>float</i>.</td>
</tr>
<tr>
<td>int &rarr; string &rarr; float</td>
<td>The function takes an <i>int</i> and a <i>string</i> input, returns a <i>float</i>.</td>
</tr>
</table>
<h2>Lambda Expressions</h2>
<p>A <b>lambda expression</b> is an unnamed function.</p>
<p>Let us take an example of two functions &minus;</p>
<pre class="prettyprint notranslate tryit">
let applyFunction ( f: int -&gt; int -&gt; int) x y = f x y
let mul x y = x * y
let res = applyFunction mul 5 7
printfn "%d" res
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
35
</pre>
<p>Now in the above example, if instead of defining the function <i>mul,</i> we could have used lambda expressions as &minus;</p>
<pre class="prettyprint notranslate tryit">
let applyFunction ( f: int -&gt; int -&gt; int) x y = f x y
let res = applyFunction (fun x y -&gt; x * y ) 5 7
printfn "%d" res
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
35
</pre>
<h2>Function Composition and Pipelining</h2>
<p>In F#, one function can be composed from other functions.</p>
<p>The following example shows the composition of a function named f, from two functions function1 and function2 &minus;</p>
<pre class="prettyprint notranslate tryit">
let function1 x = x + 1
let function2 x = x * 5

let f = function1 &gt;&gt; function2
let res = f 10
printfn "%d" res
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
55
</pre>
<p>F# also provides a feature called <b>pipelining of functions.</b> Pipelining allows function calls to be chained together as successive operations.</p>
<p>The following example shows that &minus;</p>
<pre class="prettyprint notranslate tryit">
let function1 x = x + 1
let function2 x = x * 5

let res = 10 |> function1 |> function2
printfn "%d" res
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
55
</pre>
<h1>F# - Strings</h1>
<p>In F#, the string type represents immutable text as a sequence of Unicode characters.</p>
<h2>String Literals</h2>
<p>String literals are delimited by the quotation mark (") character.</p>
<p>Some special characters are there for special uses like newline, tab, etc. They are encoded using backslash (\) character. The backslash character and the related character make the escape sequence. The following table shows the escape sequence supported by F#.</p>
<table class="table table-bordered">
<tr>
<th>Character</th>
<th>Escape sequence</th>
</tr>
<tr>
<td>Backspace</td>
<td>\b</td>
</tr>
<tr>
<td>Newline</td>
<td>\n</td>
</tr>
<tr>
<td>Carriage return</td>
<td>\r</td>
</tr>
<tr>
<td>Tab</td>
<td>\t</td>
</tr>
<tr>
<td>Backslash</td>
<td>\\</td>
</tr>
<tr>
<td>Quotation mark</td>
<td>\"</td>
</tr>
<tr>
<td>Apostrophe</td>
<td>\'</td>
</tr>
<tr>
<td>Unicode character</td>
<td>\uXXXX or \UXXXXXXXX (where X indicates a hexadecimal digit)</td>
</tr>
</table>
<h2>Ways of lgnoring the Escape Sequence</h2>
<p>The following two ways makes the compiler ignore the escape sequence &minus;</p>
<ul class="list">
<li>Using the @ symbol.</li>
<li>Enclosing the string in triple quotes.</li>
</ul>
<p>When a string literal is preceded by the @ symbol, it is called a <b>verbatim string.</b> In that way, all escape sequences in the string are ignored, except that two quotation mark characters are interpreted as one quotation mark character.</p>
<p>When a string is enclosed by triple quotes, then also all escape sequences are ignored, including double quotation mark characters.</p>
<h3>Example</h3>
<p>The following example demonstrates this technique showing how to work with XML or other structures that include embedded quotation marks &minus;</p>
<pre class="prettyprint notranslate tryit">
// Using a verbatim string
let xmldata = @"&lt;book author=""Lewis, C.S"" title=""Narnia""&gt;"
printfn "%s" xmldata
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
&lt;book author="Lewis, C.S" title="Narnia"&gt;
</pre>
<h2>Basic Operators on Strings</h2>
<p>The following table shows the basic operations on strings &minus;</p>
<table class="table table-bordered">
<tr>
<th style="width:49%;">Value</th>
<th>Description</th>
</tr>
<tr>
<td>collect : (char &rarr; string) &rarr; string &rarr; string</td>
<td>Creates a new string whose characters are the results of applying a specified function to each of the characters of the input string and concatenating the resulting strings.</td>
</tr>
<tr>
<td>concat : string &rarr; seq&lt;string&gt; &rarr; string</td>
<td>Returns a new string made by concatenating the given strings with a separator.</td>
</tr>
<tr>
<td>exists : (char &rarr; bool) &rarr; string &rarr; bool</td>
<td>Tests if any character of the string satisfies the given predicate.</td>
</tr>
<tr>
<td>forall : (char &rarr; bool) &rarr; string &rarr; bool</td>
<td>Tests if all characters in the string satisfy the given predicate.</td>
</tr>
<tr>
<td>init : int &rarr; (int &rarr; string) &rarr; string</td>
<td>Creates a new string whose characters are the results of applying a specified function to each index and concatenating the resulting strings.</td>
</tr>
<tr>
<td>iter : (char &rarr; unit) &rarr; string &rarr; unit</td>
<td>Applies a specified function to each character in the string.</td>
</tr>
<tr>
<td>iteri : (int &rarr; char &rarr; unit) &rarr; string &rarr; unit</td>
<td>Applies a specified function to the index of each character in the string and the character itself.</td>
</tr>
<tr>
<td>length : string &rarr; int</td>
<td>Returns the length of the string.</td>
</tr>
<tr>
<td>map : (char &rarr; char) &rarr; string &rarr; string</td>
<td>Creates a new string whose characters are the results of applying a specified function to each of the characters of the input string.</td>
</tr>
<tr>
<td>mapi : (int &rarr; char &rarr; char) &rarr; string &rarr; string</td>
<td>Creates a new string whose characters are the results of applying a specified function to each character and index of the input string.</td>
</tr>
<tr>
<td>replicate : int &rarr; string &rarr; string</td>
<td>Returns a string by concatenating a specified number of instances of a string.</td>
</tr>
</table>
<p>The following examples demonstrate the uses of some of the above functionalities &minus;</p>
<h3>Example 1</h3>
<p>The String.collect function builds a new string whose characters are the results of applying a specified function to each of the characters of the input string and concatenating the resulting strings.</p>
<pre class="prettyprint notranslate tryit">
let collectTesting inputS =
   String.collect (fun c -&gt; sprintf "%c " c) inputS
printfn "%s" (collectTesting "Happy New Year!")
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
H a p p y N e w Y e a r !
</pre>
<h3>Example 2</h3>
<p>The String.concat function concatenates a given sequence of strings with a separator and returns a new string.</p>
<pre class="prettyprint notranslate tryit">
let strings = [ "Tutorials Point"; "Coding Ground"; "Absolute Classes" ]
let ourProducts = String.concat "\n" strings
printfn "%s" ourProducts
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Tutorials Point
Coding Ground
Absolute Classes
</pre>
<h3>Example 3</h3>
<p>The String.replicate method returns a string by concatenating a specified number of instances of a string.</p>
<pre class="prettyprint notranslate tryit">
printfn "%s" &lt;| String.replicate 10 "*! "
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
*! *! *! *! *! *! *! *! *! *!
</pre>
<h1>F# - Options</h1>
<p>The <b>option</b> type in F# is used in calculations when there may or may not exist a value for a variable or function. Option types are used for representing optional values in calculations. They can have two possible values &minus; <b>Some(x)</b> or <b>None</b>.</p>
<p>For example, a function performing a division will return a value in normal situation, but will throw exceptions in case of a zero denominator. Using options here will help to indicate whether the function has succeeded or failed.</p>
<p>An option has an underlying type and can hold a value of that type, or it might not have a value.</p>
<h2>Using Options</h2>
<p>Let us take the example of division function. The following program explains this &minus;</p>
<p>Let us write a function div, and send two arguments to it 20 and 5 &minus;</p>
<pre class="prettyprint notranslate tryit">
let div x y = x / y
let res = div 20 5
printfn "Result: %d" res
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Result: 4
</pre>
<p>If the second argument is zero, then the program throws an exception &minus;</p>
<pre class="prettyprint notranslate tryit">
let div x y = x / y
let res = div 20 0
printfn "Result: %d" res
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Unhandled Exception:
System.DivideByZeroException: Division by zero
</pre>
<p>In such cases, we can use option types to return Some (value) when the operation is successful or None if the operation fails.</p>
<p>The following example demonstrates the use of options &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
let div x y =
   match y with
   | 0 -&gt; None
   | _ -&gt; Some(x/y)

let res : int option = div 20 4
printfn "Result: %A " res
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Result: Some 5
</pre>
<h2>Option Properties and Methods</h2>
<p>The option type supports the following properties and methods &minus;</p>
<table class="table table-bordered">
<tr>
<th style="width:30%;">Property or method</th>
<th style="width:15%;">Type</th>
<th>Description</th>
</tr>
<tr>
<td>None</td>
<td>'T option</td>
<td>A static property that enables you to create an option value that has the <b>None value</b>.</td>
</tr>
<tr>
<td>IsNone</td>
<td>bool</td>
<td>Returns <b>true</b> if the option has the <b>None</b> value.</td>
</tr>
<tr>
<td>IsSome</td>
<td>bool</td>
<td>Returns <b>true</b> if the option has a value that is not <b>None</b>.</td>
</tr>
<tr>
<td>Some</td>
<td>'T option</td>
<td>A static member that creates an option that has a value that is not <b>None</b>.</td>
</tr>
<tr>
<td>Value</td>
<td>'T</td>
<td>Returns the underlying value, or throws a NullReferenceException if the value is <b>None</b>.</td>
</tr>
</table>
<h3>Example 1</h3>
<pre class="prettyprint notranslate tryit">
let checkPositive (a : int) =
   if a > 0 then
      Some(a)
   else
      None

let res : int option = checkPositive(-31)
printfn "Result: %A " res
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Result: &lt;null&gt;
</pre>
<h3>Example 2</h3>
<pre class="prettyprint notranslate tryit">
let div x y =
   match y with
   | 0 -&gt; None
   | _ -&gt; Some(x/y)

let res : int option = div 20 4
printfn "Result: %A " res
printfn "Result: %A " res.Value
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Result: Some 5
Result: 5
</pre>
<h3>Example 3</h3>
<pre class="prettyprint notranslate tryit">
let isHundred = function
   | Some(100) -&gt; true
   | Some(_) | None -&gt; false

printfn "%A" (isHundred (Some(45)))
printfn "%A" (isHundred (Some(100)))
printfn "%A" (isHundred None)
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
false
true
false
</pre>
<h1>F# - Tuples</h1>
<p>A <b>tuple</b> is a comma-separated collection of values. These are used for creating ad hoc data structures, which group together related values.</p>
<p>For example, (“Zara Ali”, “Hyderabad”, 10) is a 3-tuple with two string values and an int value, it has the type (string * string * int).</p>
<p>Tuples could be pairs, triples, and so on, of the same or different types.</p>
<p>Some examples are provided here &minus;</p>
<pre class="result notranslate">
// Tuple of two integers.
( 4, 5 )

// Triple of strings.
( "one", "two", "three" )

// Tuple of unknown types.
( a, b )

// Tuple that has mixed types.
( "Absolute Classes", 1, 2.0 )

// Tuple of integer expressions.
( a * 4, b + 7)
</pre>
<h2>Example</h2>
<p>This program has a function that takes a tuple of four float values and returns the average &minus;</p>
<pre class="prettyprint notranslate tryit">
let averageFour (a, b, c, d) =
   let sum = a + b + c + d
   sum / 4.0

let avg:float = averageFour (4.0, 5.1, 8.0, 12.0)
printfn "Avg of four numbers: %f" avg
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Avg of four numbers: 7.275000
</pre>
<h2>Accessing Individual Tuple Members</h2>
<p>The individual members of a tuple could be assessed and printed using pattern matching.</p>
<p>The following example illustrates the concept &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
let display tuple1 =
   match tuple1 with
   | (a, b, c) -&gt; printfn "Detail Info: %A %A %A" a b c

display ("Zara Ali", "Hyderabad", 10 )
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Detail Info: "Zara Ali" "Hyderabad" 10
</pre>
<p>F# has two built-in functions, <b>fst</b> and <b>snd,</b> which return the first and second items in a 2-tuple.</p>
<p>The following example illustrates the concept &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
printfn "First member: %A" (fst(23, 30))
printfn "Second member: %A" (snd(23, 30))

printfn "First member: %A" (fst("Hello", "World!"))
printfn "Second member: %A" (snd("Hello", "World!"))

let nameTuple = ("Zara", "Ali")

printfn "First Name: %A" (fst nameTuple)
printfn "Second Name: %A" (snd nameTuple)
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
First member: 23
Second member: 30
First member: "Hello"
Second member: "World!"
First Name: "Zara"
Second Name: "Ali"
</pre>
<h1>F# - Records</h1>
<p>A <b>record</b> is similar to a tuple, however it contains named fields. For example,</p>
<pre class="result notranslate">
type website =
   { title : string;
      url : string }
</pre>
<h2>Defining Record</h2>
<p>A record is defined as a type using the <b>type</b> keyword, and the fields of the record are defined as a semicolon-separated list.</p>
<p>Syntax for defining a record is &minus;</p>
<pre class="result notranslate">
type recordName =
   { [ fieldName : dataType ] + }
</pre>
<h2>Creating a Record</h2>
<p>You can create a record by specifying the record's fields. For example, let us create a <i>website</i> record named <i>homepage</i> &minus;</p>
<pre class="result notranslate">
let homepage = { Title = "TutorialsPoint"; Url = "www.tutorialspoint.com" }
</pre>
<p>The following examples will explain the concepts &minus;</p>
<h3>Example 1</h3>
<p>This program defines a record type named website. Then it creates some records of type website and prints the records.</p>
<pre class="prettyprint notranslate tryit">
(* defining a record type named website *)
type website =
   { Title : string;
      Url : string }

(* creating some records *)
let homepage = { Title = "TutorialsPoint"; Url = "www.tutorialspoint.com" }
let cpage = { Title = "Learn C"; Url = "www.tutorialspoint.com/cprogramming/index.htm" }
let fsharppage = { Title = "Learn F#"; Url = "www.tutorialspoint.com/fsharp/index.htm" }
let csharppage = { Title = "Learn C#"; Url = "www.tutorialspoint.com/csharp/index.htm" }

(*printing records *)
(printfn "Home Page: Title: %A \n \t URL: %A") homepage.Title homepage.Url
(printfn "C Page: Title: %A \n \t URL: %A") cpage.Title cpage.Url
(printfn "F# Page: Title: %A \n \t URL: %A") fsharppage.Title fsharppage.Url
(printfn "C# Page: Title: %A \n \t URL: %A") csharppage.Title csharppage.Url
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Home Page: Title: "TutorialsPoint"
       URL: "www.tutorialspoint.com"
C Page: Title: "Learn C"
      URL: "www.tutorialspoint.com/cprogramming/index.htm"
F# Page: Title: "Learn F#"
      URL: "www.tutorialspoint.com/fsharp/index.htm"
C# Page: Title: "Learn C#"
      URL: "www.tutorialspoint.com/csharp/index.htm"
</pre>
<h3>Example 2</h3>
<pre class="prettyprint notranslate tryit">
type student =
   { Name : string;
      ID : int;
      RegistrationText : string;
      IsRegistered : bool }

let getStudent name id =
   { Name = name; ID = id; RegistrationText = null; IsRegistered = false }

let registerStudent st =
   { st with
      RegistrationText = "Registered";
      IsRegistered = true }

let printStudent msg st =
   printfn "%s: %A" msg st

let main() =
   let preRegisteredStudent = getStudent "Zara" 10
   let postRegisteredStudent = registerStudent preRegisteredStudent

   printStudent "Before Registration: " preRegisteredStudent
   printStudent "After Registration: " postRegisteredStudent

main()
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Before Registration: : {Name = "Zara";
   ID = 10;
   RegistrationText = null;
   IsRegistered = false;}
After Registration: : {Name = "Zara";
   ID = 10;
   RegistrationText = "Registered";
   IsRegistered = true;}
</pre>
<h1>F# - Lists</h1>
<p>In F#, a list is an ordered, immutable series of elements of the same type. It is to some extent equivalent to a linked list data structure.</p>
<p>The F# module, <b>Microsoft.FSharp.Collections.List,</b> has the common operations on lists. However F# imports this module automatically and makes it accessible to every F# application.</p>
<h2>Creating and Initializing a List</h2>
<p>Following are the various ways of creating lists &minus;</p>
<ul class="list">
<li><p>Using list <b>literals</b>.</p></li>
<li><p>Using <b>cons</b> (::) operator.</p></li>
<li><p>Using the <b>List.init</b> method of List module.</p></li>
<li><p>Using some <b>syntactic constructs</b> called <b>List Comprehensions</b>.</p></li>
</ul>
<h3>List Literals</h3>
<p>In this method, you just specify a semicolon-delimited sequence of values in square brackets. For example:</p>
<pre class="result notranslate">
let list1 = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]
</pre>
<h3>The cons (::) Operator</h3>
<p>With this method, you can add some values by prepending or <b>cons-ing</b> it to an existing list using the :: operator. For example &minus;</p>
<pre class="result notranslate">
let list2 = 1::2::3::4::5::6::7::8::9::10::[];;
</pre>
<p>[] denotes an empty list.</p>
<h3>List init Method</h3>
<p>The List.init method of the List module is often used for creating lists. This method has the type &minus;</p>
<pre class="result notranslate">
val init : int -&gt; (int -&gt; 'T) -&gt; 'T list
</pre>
<p>The first argument is the desired length of the new list, and the second argument is an initializer function, which generates items in the list.</p>
<p>For example,</p>
<pre class="result notranslate">
let list5 = List.init 5 (fun index -&gt; (index, index * index, index * index * index))
</pre>
<p>Here, the index function generates the list.</p>
<h3>List Comprehensions</h3>
<p>List comprehensions are special syntactic constructs used for generating lists.</p>
<p>F# list comprehension syntax comes in two forms &minus; ranges and generators.</p>
<p>Ranges have the constructs &minus; [start .. end] and [start .. step .. end]</p>
<p>For example,</p>
<pre class="result notranslate">
let list3 = [1 .. 10]
</pre>
<p>Generators have the construct &minus; [for x in collection do ... yield expr]</p>
<p>For example,</p>
<pre class="result notranslate">
let list6 = [ for a in 1 .. 10 do yield (a * a) ]
</pre>
<p>As the <b>yield</b> keyword pushes a single value into a list, the keyword, <b>yield!,</b> pushes a collection of values into the list.</p>
<p>The following function demonstrates the above methods &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
(* using list literals *)
let list1 = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]
printfn "The list: %A" list1

(*using cons operator *)
let list2 = 1 :: 2 :: 3 :: []
printfn "The list: %A" list2

(* using range constructs*)
let list3 = [1 .. 10]
printfn "The list: %A" list3

(* using range constructs *)
let list4 = ['a' .. 'm']
printfn "The list: %A" list4

(* using init method *)
let list5 = List.init 5 (fun index -> (index, index * index, index * index * index))
printfn "The list: %A" list5

(* using yield operator *)
let list6 = [ for a in 1 .. 10 do yield (a * a) ]
printfn "The list: %A" list6

(* using yield operator *)
let list7 = [ for a in 1 .. 100 do if a % 3 = 0 && a % 5 = 0 then yield a]
printfn "The list: %A" list7

(* using yield! operator *)
let list8 = [for a in 1 .. 3 do yield! [ a .. a + 3 ] ]
printfn "The list: %A" list8
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
The list: [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]
The list: [1; 2; 3]
The list: [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]
The list: ['a'; 'b'; 'c'; 'd'; 'e'; 'f'; 'g'; 'h'; 'i'; 'j'; 'k'; 'l'; 'm']
The list: [(0, 0, 0); (1, 1, 1); (2, 4, 8); (3, 9, 27); (4, 16, 64)]
The list: [1; 4; 9; 16; 25; 36; 49; 64; 81; 100]
The list: [15; 30; 45; 60; 75; 90]
The list: [1; 2; 3; 4; 2; 3; 4; 5; 3; 4; 5; 6]
</pre>
<h2>Properties of List Data Type</h2>
<p>The following table shows various properties of list data type &minus;</p>
<table class="table table-bordered">
<tr>
<th>Property</th>
<th>Type</th>
<th>Description</th>
</tr>
<tr>
<td>Head</td>
<td>'T</td>
<td>The first element.</td>
</tr>
<tr>
<td>Empty</td>
<td>'T list</td>
<td>A static property that returns an empty list of the appropriate type.</td>
</tr>
<tr>
<td>IsEmpty</td>
<td>bool</td>
<td><b>true</b> if the list has no elements.</td>
</tr>
<tr>
<td>Item</td>
<td>'T</td>
<td>The element at the specified index (zero-based).</td>
</tr>
<tr>
<td>Length</td>
<td>int</td>
<td>The number of elements.</td>
</tr>
<tr>
<td>Tail</td>
<td>'T list</td>
<td>The list without the first element.</td>
</tr>
</table>
<p>The following example shows the use of these properties &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
let list1 = [ 2; 4; 6; 8; 10; 12; 14; 16 ]

// Use of Properties
printfn "list1.IsEmpty is %b" (list1.IsEmpty)
printfn "list1.Length is %d" (list1.Length)
printfn "list1.Head is %d" (list1.Head)
printfn "list1.Tail.Head is %d" (list1.Tail.Head)
printfn "list1.Tail.Tail.Head is %d" (list1.Tail.Tail.Head)
printfn "list1.Item(1) is %d" (list1.Item(1))
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
list1.IsEmpty is false
list1.Length is 8
list1.Head is 2
list1.Tail.Head is 4
list1.Tail.Tail.Head is 6
list1.Item(1) is 4
</pre>
<h2>Basic Operators on List</h2>
<p>The following table shows the basic operations on list data type &minus;</p>
<table class="table table-bordered">
<tr>
<th style="width:48%;">Value</th>
<th>Description</th>
</tr>
<tr>
<td>append : 'T list &rarr; 'T list &rarr; 'T list</td>
<td>Returns a new list that contains the elements of the first list followed by elements of the second.</td>
</tr>
<tr>
<td>average : 'T list &rarr; ^T</td>
<td>Returns the average of the elements in the list.</td>
</tr>
<tr>
<td>averageBy : ('T &rarr; ^U) &rarr; 'T list &rarr; ^U</td>
<td>Returns the average of the elements generated by applying the function to each element of the list.</td>
</tr>
<tr>
<td>choose : ('T &rarr; 'U option) &rarr; 'T list &rarr; 'U list</td>
<td>Applies the given function to each element of the list. Returns the list comprised of the results for each element where the function returns <b>Some</b>.</td>
</tr>
<tr>
<td>collect : ('T &rarr; 'U list) &rarr; 'T list &rarr; 'U list</td>
<td>For each element of the list, applies the given function. Concatenates all the results and return the combined list.</td>
</tr>
<tr>
<td>concat : seq&lt;'T list&gt; &rarr; 'T list</td>
<td>Returns a new list that contains the elements of each the lists in order.</td>
</tr>
<tr>
<td>empty : 'T list</td>
<td>Returns an empty list of the given type.</td>
</tr>
<tr>
<td>exists : ('T &rarr; bool) &rarr; 'T list &rarr; bool</td>
<td>Tests if any element of the list satisfies the given predicate.</td>
</tr>
<tr>
<td>exists2 : ('T1 &rarr; 'T2 &rarr; bool) &rarr; 'T1 list &rarr; 'T2 list &rarr; bool</td>
<td>Tests if any pair of corresponding elements of the lists satisfies the given predicate.</td>
</tr>
<tr>
<td>filter : ('T &rarr; bool) &rarr; 'T list &rarr; 'T list</td>
<td>Returns a new collection containing only the elements of the collection for which the given predicate returns <b>true</b>.</td>
</tr>
<tr>
<td>find : ('T &rarr; bool) &rarr; 'T list &rarr; 'T</td>
<td>Returns the first element for which the given function returns <b>true</b>.</td>
</tr>
<tr>
<td>findIndex : ('T &rarr; bool) &rarr; 'T list &rarr; int</td>
<td>Returns the index of the first element in the list that satisfies the given predicate.</td>
</tr>
<tr>
<td>fold : ('State &rarr; 'T &rarr; 'State) &rarr; 'State &rarr; 'T list &rarr; 'State</td>
<td>Applies a function to each element of the collection, threading an accumulator argument through the computation. This function takes the second argument, and applies the function to it and the first element of the list. Then, it passes this result into the function along with the second element, and so on. Finally, it returns the final result. If the input function is f and the elements are i0...iN, then this function computes f (... (f s i0) i1 ...) iN.</td>
</tr>
<tr>
<td>fold2 : ('State &rarr; 'T1 &rarr; 'T2 &rarr; 'State) &rarr; 'State &rarr; 'T1 list &rarr; 'T2 list &rarr; 'State</td>
<td>Applies a function to corresponding elements of two collections, threading an accumulator argument through the computation. The collections must have identical sizes. If the input function is f and the elements are i0...iN and j0...jN, then this function computes f (... (f s i0 j0)...) iN jN.</td>
</tr>
<tr>
<td>foldBack : ('T &rarr; 'State &rarr; 'State) &rarr; 'T list &rarr; 'State &rarr; 'State</td>
<td>Applies a function to each element of the collection, threading an accumulator argument through the computation. If the input function isf and the elements are i0...iN then computes f i0 (...(f iN s)).</td>
</tr>
<tr>
<td>foldBack2 : ('T1 &rarr; 'T2 &rarr; 'State &rarr; 'State) &rarr; 'T1 list &rarr; 'T2 list &rarr; 'State &rarr; 'State</td>
<td>Applies a function to corresponding elements of two collections, threading an accumulator argument through the computation. The collections must have identical sizes. If the input function is f and the elements are i0...iN and j0...jN, then this function computes f i0 j0 (...(f iN jN s)).</td>
</tr>
<tr>
<td>forall : ('T &rarr; bool) &rarr; 'T list &rarr; bool</td>
<td>Tests if all elements of the collection satisfy the given predicate.</td>
</tr>
<tr>
<td>forall2 : ('T1 &rarr; 'T2 &rarr; bool) &rarr; 'T1 list &rarr; 'T2 list &rarr; bool</td>
<td>Tests if all corresponding elements of the collection satisfy the given predicate pairwise.</td>
</tr>
<tr>
<td>head : 'T list &rarr; 'T</td>
<td>Returns the first element of the list.</td>
</tr>
<tr>
<td>init : int &rarr; (int &rarr; 'T) &rarr; 'T list</td>
<td>Creates a list by calling the given generator on each index.</td>
</tr>
<tr>
<td>isEmpty : 'T list &rarr; bool</td>
<td>Returns <b>true</b> if the list contains no elements, <b>false</b> otherwise.</td>
</tr>
<tr>
<td>iter : ('T &rarr; unit) &rarr; 'T list &rarr; unit</td>
<td>Applies the given function to each element of the collection.</td>
</tr>
<tr>
<td>iter2 : ('T1 &rarr; 'T2 &rarr; unit) &rarr; 'T1 list &rarr; 'T2 list &rarr; unit</td>
<td>Applies the given function to two collections simultaneously. The collections must have identical size.</td>
</tr>
<tr>
<td>iteri : (int &rarr; 'T &rarr; unit) &rarr; 'T list &rarr; unit</td>
<td>Applies the given function to each element of the collection. The integer passed to the function indicates the index of element.</td>
</tr>
<tr>
<td>iteri2 : (int &rarr; 'T1 &rarr; 'T2 &rarr; unit) &rarr; 'T1 list &rarr; 'T2 list &rarr; unit</td>
<td>Applies the given function to two collections simultaneously. The collections must have identical size. The integer passed to the function indicates the index of element.</td>
</tr>
<tr>
<td>length : 'T list &rarr; int</td>
<td>Returns the length of the list.</td>
</tr>
<tr>
<td>map : ('T &rarr; 'U) &rarr; 'T list &rarr; 'U list</td>
<td>Creates a new collection whose elements are the results of applying the given function to each of the elements of the collection.</td>
</tr>
<tr>
<td>map2 : ('T1 &rarr; 'T2 &rarr; 'U) &rarr; 'T1 list &rarr; 'T2 list &rarr; 'U list</td>
<td>Creates a new collection whose elements are the results of applying the given function to the corresponding elements of the two collections pairwise.</td>
</tr>
<tr>
<td>map3 : ('T1 &rarr; 'T2 &rarr; 'T3 &rarr; 'U) &rarr; 'T1 list &rarr; 'T2 list &rarr; 'T3 list &rarr; 'U list</td>
<td>Creates a new collection whose elements are the results of applying the given function to the corresponding elements of the three collections simultaneously.</td>
</tr>
<tr>
<td>mapi : (int &rarr; 'T &rarr; 'U) &rarr; 'T list &rarr; 'U list</td>
<td>Creates a new collection whose elements are the results of applying the given function to each of the elements of the collection. The integer index passed to the function indicates the index (from 0) of element being transformed.</td>
</tr>
<tr>
<td>mapi2 : (int &rarr; 'T1 &rarr; 'T2 &rarr; 'U) &rarr; 'T1 list &rarr; 'T2 list &rarr; 'U list</td>
<td>Like List.mapi, but mapping corresponding elements from two lists of equal length.</td>
</tr>
<tr>
<td>max : 'T list &rarr; 'T</td>
<td>Returns the greatest of all elements of the list, compared by using Operators.max.</td>
</tr>
<tr>
<td>maxBy : ('T &rarr; 'U) &rarr; 'T list &rarr; 'T</td>
<td>Returns the greatest of all elements of the list, compared by using Operators.max on the function result.</td>
</tr>
<tr>
<td>min : 'T list &rarr; 'T</td>
<td>Returns the lowest of all elements of the list, compared by using Operators.min.</td>
</tr>
<tr>
<td>minBy : ('T &rarr; 'U) &rarr; 'T list &rarr; 'T</td>
<td>Returns the lowest of all elements of the list, compared by using Operators.min on the function result</td>
</tr>
<tr>
<td>nth : 'T list &rarr; int &rarr; 'T</td>
<td>Indexes into the list. The first element has index 0.</td>
</tr>
<tr>
<td>ofArray : 'T [] &rarr; 'T list</td>
<td>Creates a list from the given array.</td>
</tr>
<tr>
<td>ofSeq : seq&lt;'T&gt; &rarr; 'T list</td>
<td>Creates a new list from the given enumerable object.</td>
</tr>
<tr>
<td>partition : ('T &rarr; bool) &rarr; 'T list * 'T list</td>
<td>Splits the collection into two collections, containing the elements for which the given predicate returns <b>true</b> and <b>false</b> respectively.</td>
</tr>
<tr>
<td>permute : (int &rarr; int) &rarr; 'T list &rarr; 'T list</td>
<td>Returns a list with all elements permuted according to the specified permutation.</td>
</tr>
<tr>
<td>pick : ('T &rarr; 'U option) &rarr; 'T list &rarr; 'U</td>
<td>Applies the given function to successive elements, returning the first result where function returns <b>Some</b> for some value.</td>
</tr>
<tr>
<td>reduce : ('T &rarr; 'T &rarr; 'T) &rarr; 'T list &rarr; 'T</td>
<td>Applies a function to each element of the collection, threading an accumulator argument through the computation. This function applies the specified function to the first two elements of the list. It then passes this result into the function along with the third element, and so on. Finally, it returns the final result. If the input function is f and the elements are i0...iN, then this function computes f (... (f i0 i1) i2 ...) iN.</td>
</tr>
<tr>
<td>reduceBack : ('T &rarr; 'T &rarr; 'T) &rarr; 'T list &rarr; 'T</td>
<td>Applies a function to each element of the collection, threading an accumulator argument through the computation. If the input function isf and the elements are i0...iN, then this function computes f i0 (...(f iN-1 iN)).</td>
</tr>
<tr>
<td>replicate : (int &rarr; 'T &rarr; 'T list)</td>
<td>Creates a list by calling the given generator on each index.</td>
</tr>
<tr>
<td>rev : 'T list &rarr; 'T list</td>
<td>Returns a new list with the elements in reverse order.</td>
</tr>
<tr>
<td>scan : ('State &rarr; 'T &rarr; 'State) &rarr; 'State &rarr; 'T list &rarr; 'State list</td>
<td>Applies a function to each element of the collection, threading an accumulator argument through the computation. This function takes the second argument, and applies the specified function to it and the first element of the list. Then, it passes this result into the function along with the second element and so on. Finally, it returns the list of intermediate results and the final result.</td>
</tr>
<tr>
<td>scanBack : ('T &rarr; 'State &rarr; 'State) &rarr; 'T list &rarr; 'State &rarr; 'State list</td>
<td>Like foldBack, but returns both the intermediate and final results</td>
</tr>
<tr>
<td>sort : 'T list &rarr; 'T list</td>
<td>Sorts the given list using Operators.compare.</td>
</tr>
<tr>
<td>sortBy : ('T &rarr; 'Key) &rarr; 'T list &rarr; 'T list</td>
<td>Sorts the given list using keys given by the given projection. Keys are compared using Operators.compare.</td>
</tr>
<tr>
<td>sortWith : ('T &rarr; 'T &rarr; int) &rarr; 'T list &rarr; 'T list</td>
<td>Sorts the given list using the given comparison function.</td>
</tr>
<tr>
<td>sum : ^T list &rarr; ^T</td>
<td>Returns the sum of the elements in the list.</td>
</tr>
<tr>
<td>sumBy : ('T &rarr; ^U) &rarr; 'T list &rarr; ^U</td>
<td>Returns the sum of the results generated by applying the function to each element of the list.</td>
</tr>
<tr>
<td>tail : 'T list &rarr; 'T list</td>
<td>Returns the input list without the first element.</td>
</tr>
<tr>
<td>toArray : 'T list &rarr; 'T []</td>
<td>Creates an array from the given list.</td>
</tr>
<tr>
<td>toSeq : 'T list &rarr; seq&lt;'T&gt;</td>
<td>Views the given list as a sequence.</td>
</tr>
<tr>
<td>tryFind : ('T &rarr; bool) &rarr; 'T list &rarr; 'T option</td>
<td>Returns the first element for which the given function returns <b>true</b>. Return <b>None</b> if no such element exists.</td>
</tr>
<tr>
<td>tryFindIndex : ('T &rarr; bool) &rarr; 'T list &rarr; int option</td>
<td>Returns the index of the first element in the list that satisfies the given predicate. Return <b>None</b> if no such element exists.</td>
</tr>
<tr>
<td>tryPick : ('T &rarr; 'U option) &rarr; 'T list &rarr; 'U option</td>
<td>Applies the given function to successive elements, returning the first result where function returns <b>Some</b> for some value. If no such element exists then return <b>None</b>.</td>
</tr>
<tr>
<td>unzip : ('T1 * 'T2) list &rarr; 'T1 list * 'T2 list</td>
<td>Splits a list of pairs into two lists.</td>
</tr>
<tr>
<td>unzip3 : ('T1 * 'T2 * 'T3) list &rarr; 'T1 list * 'T2 list * 'T3 list</td>
<td>Splits a list of triples into three lists.</td>
</tr>
<tr>
<td>zip : 'T1 list &rarr; 'T2 list &rarr; ('T1 * 'T2) list</td>
<td>Combines the two lists into a list of pairs. The two lists must have equal lengths.</td>
</tr>
<tr>
<td>zip3 : 'T1 list &rarr; 'T2 list &rarr; 'T3 list &rarr; ('T1 * 'T2 * 'T3) list</td>
<td>Combines the three lists into a list of triples. The lists must have equal lengths.</td>
</tr>
</table>
<p>The following examples demonstrate the uses of the above functionalities &minus;</p>
<h3>Example 1</h3>
<p>This program shows reversing a list recursively &minus;</p>
<pre class="prettyprint notranslate tryit">
let list1 = [ 2; 4; 6; 8; 10; 12; 14; 16 ]
printfn "The original list: %A" list1

let reverse lt =
   let rec loop acc = function
      | [] -&gt; acc
      | hd :: tl -&gt; loop (hd :: acc) tl
   loop [] lt
	
printfn "The reversed list: %A" (reverse list1)
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
The original list: [2; 4; 6; 8; 10; 12; 14; 16]
The reversed list: [16; 14; 12; 10; 8; 6; 4; 2]
</pre>
<p>However, you can use the <b>rev</b> function of the module for the same purpose &minus;</p>
<pre class="prettyprint notranslate tryit">
let list1 = [ 2; 4; 6; 8; 10; 12; 14; 16 ]
printfn "The original list: %A" list1
printfn "The reversed list: %A" (List.rev list1)
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
The original list: [2; 4; 6; 8; 10; 12; 14; 16]
The reversed list: [16; 14; 12; 10; 8; 6; 4; 2]
</pre>
<h3>Example 2</h3>
<p>This program shows filtering a list using the <b>List.filter</b> method &minus;</p>
<pre class="prettyprint notranslate tryit">
let list1 = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]
printfn "The list: %A" list1
let list2 = list1 |&gt; List.filter (fun x -&gt; x % 2 = 0);;
printfn "The Filtered list: %A" list2
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
The list: [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]
The Filtered list: [2; 4; 6; 8; 10]
</pre>
<h3>Example 3</h3>
<p>The <b>List.map</b> method maps a list from one type to another &minus;</p>
<pre class="prettyprint notranslate tryit">
let list1 = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]
printfn "The list: %A" list1
let list2 = list1 |&gt; List.map (fun x -&gt; (x * x).ToString());;
printfn "The Mapped list: %A" list2
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
The list: [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]
The Mapped list: ["1"; "4"; "9"; "16"; "25"; "36"; "49"; "64"; "81"; "100"]
</pre>
<h3>Example 4</h3>
<p>The <b>List.append</b> method and the @ operator appends one list to another &minus;</p>
<pre class="prettyprint notranslate tryit">
let list1 = [1; 2; 3; 4; 5 ]
let list2 = [6; 7; 8; 9; 10]
let list3 = List.append list1 list2

printfn "The first list: %A" list1
printfn "The second list: %A" list2
printfn "The appened list: %A" list3

let lt1 = ['a'; 'b';'c' ]
let lt2 = ['e'; 'f';'g' ]
let lt3 = lt1 @ lt2

printfn "The first list: %A" lt1
printfn "The second list: %A" lt2
printfn "The appened list: %A" lt3
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
The first list: [1; 2; 3; 4; 5]
The second list: [6; 7; 8; 9; 10]
The appened list: [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]
The first list: ['a'; 'b'; 'c']
The second list: ['e'; 'f'; 'g']
The appened list: ['a'; 'b'; 'c'; 'e'; 'f'; 'g']
</pre>
<h3>Example 5</h3>
<p>The <b>List.sort</b> method sorts a list. The <b>List.sum</b> method gives the sum of elements in the list and the <b>List.average</b> method gives the average of elements in the list &minus;</p>
<pre class="prettyprint notranslate tryit">
let list1 = [9.0; 0.0; 2.0; -4.5; 11.2; 8.0; -10.0]
printfn "The list: %A" list1

let list2 = List.sort list1
printfn "The sorted list: %A" list2

let s = List.sum list1
let avg = List.average list1
printfn "The sum: %f" s
printfn "The average: %f" avg
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
The list: [9.0; 0.0; 2.0; -4.5; 11.2; 8.0; -10.0]
The sorted list: [-10.0; -4.5; 0.0; 2.0; 8.0; 9.0; 11.2]
The sum: 15.700000
The average: 2.242857
</pre>
<p>A "fold" operation applies a function to each element in a list, aggregates the result of the function in an accumulator variable, and returns the accumulator as the result of the fold operation.</p>
<h3>Example 6</h3>
<p>The <b>List.fold</b> method applies a function to each element from left to right, while <b>List.foldBack</b> applies a function to each element from right to left.</p>
<pre class="prettyprint notranslate tryit">
let sumList list = List.fold (fun acc elem -&gt; acc + elem) 0 list
printfn "Sum of the elements of list %A is %d." [ 1 .. 10 ] (sumList [ 1 .. 10 ])
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Sum of the elements of list [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] is 55.
</pre>
<h1>F# - Sequences</h1>
<p>Sequences, like lists also represent an ordered collection of values. However, the elements in a sequence or sequence expression are computed when required. They are not computed at once, and for this reason they are used to represent infinite data structures.</p>
<h2>Defining Sequences</h2>
<p>Sequences are defined using the following syntax &minus;</p>
<pre class="result notranslate">
seq { expr }
</pre>
<p>For example,</p>
<pre class="result notranslate">
let seq1 = seq { 1 .. 10 }
</pre>
<h2>Creating Sequences and Sequences Expressions</h2>
<p>Similar to lists, you can create sequences using ranges and comprehensions.</p>
<p>Sequence expressions are the expressions you can write for creating sequences. These can be done &minus;</p>
<ul class="list">
<li>By specifying the range.</li>
<li>By specifying the range with increment or decrement.</li>
<li>By using the <b>yield</b> keyword to produce values that become part of the sequence.</li>
<li>By using the &rarr; operator.</li>
</ul>
<p>The following examples demonstrate the concept &minus;</p>
<h3>Example 1</h3>
<pre class="prettyprint notranslate tryit">
(* Sequences *)
let seq1 = seq { 1 .. 10 }

(* ascending order and increment*)
printfn "The Sequence: %A" seq1
let seq2 = seq { 1 .. 5 .. 50 }

(* descending order and decrement*)
printfn "The Sequence: %A" seq2
let seq3 = seq {50 .. -5 .. 0}
printfn "The Sequence: %A" seq3

(* using yield *)
let seq4 = seq { for a in 1 .. 10 do yield a, a*a, a*a*a }
printfn "The Sequence: %A" seq4
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
The Sequence: seq [1; 2; 3; 4; ...]
The Sequence: seq [1; 6; 11; 16; ...]
The Sequence: seq [50; 45; 40; 35; ...]
The Sequence: seq [(1, 1, 1); (2, 4, 8); (3, 9, 27); (4, 16, 64); ...]
</pre>
<h3>Example 2</h3>
<p>The following program prints the prime numbers from 1 to 50 &minus;</p>
<pre class="prettyprint notranslate tryit">
(* Recursive isprime function. *)
let isprime n =
   let rec check i =
      i &gt; n/2 || (n % i &lt;&gt; 0 && check (i + 1))
   check 2

let primeIn50 = seq { for n in 1..50 do if isprime n then yield n }
for x in primeIn50 do
   printfn "%d" x
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
1
2
3
5
7
11
13
17
19
23
29
31
37
41
43
47
</pre>
<h2>Basic Operations on Sequence</h2>
<p>The following table shows the basic operations on sequence data type &minus;</p>
<table class="table table-bordered">
<tr>
<th style="width:48%;">Value</th>
<th>Description</th>
</tr>
<tr>
<td>append : seq&lt;'T&gt; &rarr; seq&lt;'T&gt; &rarr; seq&lt;'T&gt;</td>
<td>Wraps the two given enumerations as a single concatenated enumeration.</td>
</tr>
<tr>
<td>average : seq&lt;^T&gt; &rarr; ^T</td>
<td>Returns the average of the elements in the sequence.</td>
</tr>
<tr>
<td>averageBy : ('T &rarr; ^U) &rarr; seq&lt;'T&gt; &rarr; ^U</td>
<td>Returns the average of the results generated by applying the function to each element of the sequence.</td>
</tr>
<tr>
<td>cache : seq&lt;'T&gt; &rarr; seq&lt;'T&gt;</td>
<td>Returns a sequence that corresponds to a cached version of the input sequence.</td>
</tr>
<tr>
<td>cast : IEnumerable &rarr; seq&lt;'T&gt;</td>
<td>Wraps a loosely-typed System. Collections sequence as a typed sequence.</td>
</tr>
<tr>
<td>choose : ('T &rarr; 'U option) &rarr; seq&lt;'T&gt; &rarr; seq&lt;'U&gt;</td>
<td>Applies the given function to each element of the list. Return the list comprised of the results for each element where the function returns <b>Some</b>.</td>
</tr>
<tr>
<td>collect : ('T &rarr; 'Collection) &rarr; seq&lt;'T&gt; &rarr; seq&lt;'U&gt;</td>
<td>Applies the given function to each element of the sequence and concatenates all the results.</td>
</tr>
<tr>
<td>compareWith : ('T &rarr; 'T &rarr; int) &rarr; seq&lt;'T&gt; &rarr; seq&lt;'T&gt; &rarr; int</td>
<td>Compares two sequences using the given comparison function, element by element.</td>
</tr>
<tr>
<td>concat : seq&lt;'Collection&gt; &rarr; seq&lt;'T&gt;</td>
<td>Combines the given enumeration-of-enumerations as a single concatenated enumeration.</td>
</tr>
<tr>
<td>countBy : ('T &rarr; 'Key) &rarr; seq&lt;'T&gt; &rarr; seq&lt;'Key * int&gt;</td>
<td>Applies a key-generating function to each element of a sequence and return a sequence yielding unique keys and their number of occurrences in the original sequence.</td>
</tr>
<tr>
<td>delay : (unit &rarr; seq&lt;'T&gt;) &rarr; seq&lt;'T&gt;</td>
<td>Returns a sequence that is built from the given delayed specification of a sequence.</td>
</tr>
<tr>
<td>distinct : seq&lt;'T&gt; &rarr; seq&lt;'T&gt;</td>
<td>Returns a sequence that contains no duplicate entries according to generic hash and equality comparisons on the entries. If an element occurs multiple times in the sequence then the later occurrences are discarded.</td>
</tr>
<tr>
<td>distinctBy : ('T &rarr; 'Key) &rarr; seq&lt;'T&gt; &rarr; seq&lt;'T&gt;</td>
<td>Returns a sequence that contains no duplicate entries according to the generic hash and equality comparisons on the keys returned by the given key-generating function. If an element occurs multiple times in the sequence then the later occurrences are discarded.</td>
</tr>
<tr>
<td>empty : seq&lt;'T&gt;</td>
<td>Creates an empty sequence.</td>
</tr>
<tr>
<td>exactlyOne : seq&lt;'T&gt; &rarr; 'T</td>
<td>Returns the only element of the sequence.</td>
</tr>
<tr>
<td>exists : ('T &rarr; bool) &rarr; seq&lt;'T&gt; &rarr; bool</td>
<td>Tests if any element of the sequence satisfies the given predicate.</td>
</tr>
<tr>
<td>exists2 : ('T1 &rarr; 'T2 &rarr; bool) &rarr; seq&lt;'T1&gt; &rarr; seq&lt;'T2&gt; &rarr; bool</td>
<td>Tests if any pair of corresponding elements of the input sequences satisfies the given predicate.</td>
</tr>
<tr>
<td>filter : ('T &rarr; bool) &rarr; seq&lt;'T&gt; &rarr; seq&lt;'T&gt;</td>
<td>Returns a new collection containing only the elements of the collection for which the given predicate returns <b>true</b>.</td>
</tr>
<tr>
<td>find : ('T &rarr; bool) &rarr; seq&lt;'T&gt; &rarr; 'T</td>
<td>Returns the first element for which the given function returns <b>true</b>.</td>
</tr>
<tr>
<td>findIndex : ('T &rarr; bool) &rarr; seq&lt;'T&gt; &rarr; int</td>
<td>Returns the index of the first element for which the given function returns <b>true</b>.</td>
</tr>
<tr>
<td>fold : ('State &rarr; 'T &rarr; 'State) &rarr; 'State &rarr; seq&lt;'T&gt; &rarr; 'State</td>
<td>Applies a function to each element of the collection, threading an accumulator argument through the computation. If the input function is f and the elements are i0...iN, then this function computes f (... (f s i0)...) iN.</td>
</tr>
<tr>
<td>forall : ('T &rarr; bool) &rarr; seq&lt;'T&gt; &rarr; bool</td>
<td>Tests if all elements of the sequence satisfy the given predicate.</td>
</tr>
<tr>
<td>forall2 : ('T1 &rarr; 'T2 &rarr; bool) &rarr; seq&lt;'T1&gt; &rarr; seq&lt;'T2&gt; &rarr; bool</td>
<td>Tests the all pairs of elements drawn from the two sequences satisfy the given predicate. If one sequence is shorter than the other then the remaining elements of the longer sequence are ignored.</td>
</tr>
<tr>
<td>groupBy : ('T &rarr; 'Key) &rarr; seq&lt;'T&gt; &rarr; seq&lt;'Key * seq&lt;'T&gt;&gt;</td>
<td>Applies a key-generating function to each element of a sequence and yields a sequence of unique keys. Each unique key has also contains a sequence of all elements that match to this key.</td>
</tr>
<tr>
<td>head : seq&lt;'T&gt; &rarr; 'T</td>
<td>Returns the first element of the sequence.</td>
</tr>
<tr>
<td>init : int &rarr; (int &rarr; 'T) &rarr; seq&lt;'T&gt;</td>
<td>Generates a new sequence which, when iterated, returns successive elements by calling the given function, up to the given count. The results of calling the function are not saved, that is, the function is reapplied as necessary to regenerate the elements. The function is passed the index of the item being generated.</td>
</tr>
<tr>
<td>initInfinite : (int &rarr; 'T) &rarr; seq&lt;'T&gt;</td>
<td>Generates a new sequence which, when iterated, will return successive elements by calling the given function. The results of calling the function are not saved, that is, the function will be reapplied as necessary to regenerate the elements. The function is passed the index of the item being generated.</td>
</tr>
<tr>
<td>isEmpty : seq&lt;'T&gt; &rarr; bool</td>
<td>Tests whether a sequence has any elements.</td>
</tr>
<tr>
<td>iter : ('T &rarr; unit) &rarr; seq&lt;'T&gt; &rarr; unit</td>
<td>Applies the given function to each element of the collection.</td>
</tr>
<tr>
<td>iter2 : ('T1 &rarr; 'T2 &rarr; unit) &rarr; seq&lt;'T1&gt; &rarr; seq&lt;'T2&gt; &rarr; unit</td>
<td>Applies the given function to two collections simultaneously. If one sequence is shorter than the other then the remaining elements of the longer sequence are ignored.</td>
</tr>
<tr>
<td>iteri : (int &rarr; 'T &rarr; unit) &rarr; seq&lt;'T&gt; &rarr; unit</td>
<td>Applies the given function to each element of the collection. The integer passed to the function indicates the index of element.</td>
</tr>
<tr>
<td>last : seq&lt;'T&gt; &rarr; 'T</td>
<td>Returns the last element of the sequence.</td>
</tr>
<tr>
<td>length : seq&lt;'T&gt; &rarr; int</td>
<td>Returns the length of the sequence.</td>
</tr>
<tr>
<td>map : ('T &rarr; 'U) &rarr; seq&lt;'T&gt; &rarr; seq&lt;'U&gt;</td>
<td>Creates a new collection whose elements are the results of applying the given function to each of the elements of the collection. The given function will be applied as elements are demanded using the MoveNext method on enumerators retrieved from the object.</td>
</tr>
<tr>
<td>map2 : ('T1 &rarr; 'T2 &rarr; 'U) &rarr; seq&lt;'T1&gt; &rarr; seq&lt;'T2&gt; &rarr; seq&lt;'U&gt;</td>
<td>Creates a new collection whose elements are the results of applying the given function to the corresponding pairs of elements from the two sequences. If one input sequence is shorter than the other then the remaining elements of the longer sequence are ignored.</td>
</tr>
<tr>
<td>mapi : (int &rarr; 'T &rarr; 'U) &rarr; seq&lt;'T&gt; &rarr; seq&lt;'U&gt;</td>
<td>Creates a new collection whose elements are the results of applying the given function to each of the elements of the collection. The integer index passed to the function indicates the index (from 0) of element being transformed.</td>
</tr>
<tr>
<td>max : seq&lt;'T&gt; &rarr; 'T</td>
<td>Returns the greatest of all elements of the sequence, compared by using Operators.max.</td>
</tr>
<tr>
<td>maxBy : ('T &rarr; 'U) &rarr; seq&lt;'T&gt; &rarr; 'T</td>
<td>Returns the greatest of all elements of the sequence, compared by using Operators.max on the function result.</td>
</tr>
<tr>
<td>min : seq&lt;'T&gt; &rarr; 'T</td>
<td>Returns the lowest of all elements of the sequence, compared by using Operators.min.</td>
</tr>
<tr>
<td>minBy : ('T &rarr; 'U) &rarr; seq&lt;'T&gt; &rarr; 'T</td>
<td>Returns the lowest of all elements of the sequence, compared by using Operators.min on the function result.</td>
</tr>
<tr>
<td>nth : int &rarr; seq&lt;'T&gt; &rarr; 'T</td>
<td>Computes the <i>nth</i> element in the collection.</td>
</tr>
<tr>
<td>ofArray : 'T array &rarr; seq&lt;'T&gt;</td>
<td>Views the given array as a sequence.</td>
</tr>
<tr>
<td>ofList : 'T list &rarr; seq&lt;'T&gt;</td>
<td>Views the given list as a sequence.</td>
</tr>
<tr>
<td>pairwise : seq&lt;'T&gt; &rarr; seq&lt;'T * 'T&gt;</td>
<td>Returns a sequence of each element in the input sequence and its predecessor, with the exception of the first element which is only returned as the predecessor of the second element.</td>
</tr>
<tr>
<td>pick : ('T &rarr; 'U option) &rarr; seq&lt;'T&gt; &rarr; 'U</td>
<td>Applies the given function to successive elements, returning the first value where the function returns a <b>Some</b> value.</td>
</tr>
<tr>
<td>readonly : seq&lt;'T&gt; &rarr; seq&lt;'T&gt;</td>
<td>Creates a new sequence object that delegates to the given sequence object. This ensures the original sequence cannot be rediscovered and mutated by a type cast. For example, if given an array the returned sequence will return the elements of the array, but you cannot cast the returned sequence object to an array.</td>
</tr>
<tr>
<td>reduce : ('T &rarr; 'T &rarr; 'T) &rarr; seq&lt;'T&gt; &rarr; 'T</td>
<td>Applies a function to each element of the sequence, threading an accumulator argument through the computation. Begin by applying the function to the first two elements. Then feed this result into the function along with the third element and so on. Return the final result.</td>
</tr>
<tr>
<td>scan : ('State &rarr; 'T &rarr; 'State) &rarr; 'State &rarr; seq&lt;'T&gt; &rarr; seq&lt;'State&gt;</td>
<td>Like Seq.fold, but computes on-demand and returns the sequence of intermediary and final results.</td>
</tr>
<tr>
<td>singleton : 'T &rarr; seq&lt;'T&gt;</td>
<td>Returns a sequence that yields one item only.</td>
</tr>
<tr>
<td>skip : int &rarr; seq&lt;'T&gt; &rarr; seq&lt;'T&gt;</td>
<td>Returns a sequence that skips a specified number of elements of the underlying sequence and then yields the remaining elements of the sequence.</td>
</tr>
<tr>
<td>skipWhile : ('T &rarr; bool) &rarr; seq&lt;'T&gt; &rarr; seq&lt;'T&gt;</td>
<td>Returns a sequence that, when iterated, skips elements of the underlying sequence while the given predicate returns <b>true,</b> and then yields the remaining elements of the sequence.</td>
</tr>
<tr>
<td>sort : seq&lt;'T&gt; &rarr; seq&lt;'T&gt;</td>
<td>Yields a sequence ordered by keys.</td>
</tr>
<tr>
<td>sortBy : ('T &rarr; 'Key) &rarr; seq&lt;'T&gt; &rarr; seq&lt;'T&gt;</td>
<td>Applies a key-generating function to each element of a sequence and yield a sequence ordered by keys. The keys are compared using generic comparison as implemented by Operators.compare.</td>
</tr>
<tr>
<td>sum : seq&lt;^T&gt; &rarr; ^T</td>
<td>Returns the sum of the elements in the sequence.</td>
</tr>
<tr>
<td>sumBy</td>
<td>Returns the sum of the results generated by applying the function to each element of the sequence.</td>
</tr>
<tr>
<td>take : int &rarr; seq&lt;'T&gt; &rarr; seq&lt;'T&gt;</td>
<td>Returns the first elements of the sequence up to a specified count.</td>
</tr>
<tr>
<td>takeWhile : ('T &rarr; bool) &rarr; seq&lt;'T&gt; &rarr; seq&lt;'T&gt;</td>
<td>Returns a sequence that, when iterated, yields elements of the underlying sequence while the given predicate returns <b>true,</b> and then returns no further elements.</td>
</tr>
<tr>
<td>toArray : seq&lt;'T&gt; &rarr; 'T[]</td>
<td>Creates an array from the given collection.</td>
</tr>
<tr>
<td>toList : seq&lt;'T&gt; &rarr; 'T list</td>
<td>Creates a list from the given collection.</td>
</tr>
<tr>
<td>truncate : int &rarr; seq&lt;'T&gt; &rarr; seq&lt;'T&gt;</td>
<td>Returns a sequence that when enumerated returns no more than a specified number of elements.</td>
</tr>
<tr>
<td>tryFind : ('T &rarr; bool) &rarr; seq&lt;'T&gt; &rarr; 'T option</td>
<td>Returns the first element for which the given function returns <b>true,</b> or <b>None</b> if no such element exists.</td>
</tr>
<tr>
<td>tryFindIndex : ('T &rarr; bool) &rarr; seq&lt;'T&gt; &rarr; int option</td>
<td>Returns the index of the first element in the sequence that satisfies the given predicate, or <b>None</b> if no such element exists.</td>
</tr>
<tr>
<td>tryPick : ('T &rarr; 'U option) &rarr; seq&lt;'T&gt; &rarr; 'U option</td>
<td>Applies the given function to successive elements, returning the first value where the function returns a <b>Some</b> value.</td>
</tr>
<tr>
<td>unfold : ('State &rarr; 'T * 'State option) &rarr; 'State &rarr; seq&lt;'T&gt;</td>
<td>Returns a sequence that contains the elements generated by the given computation.</td>
</tr>
<tr>
<td>where : ('T &rarr; bool) &rarr; seq&lt;'T&gt; &rarr; seq&lt;'T&gt;</td>
<td>Returns a new collection containing only the elements of the collection for which the given predicate returns <b>true</b>. A synonym for Seq.filter.</td>
</tr>
<tr>
<td>windowed : int &rarr; seq&lt;'T&gt; &rarr; seq&lt;'T []&gt;</td>
<td>Returns a sequence that yields sliding windows of containing elements drawn from the input sequence. Each window is returned as a fresh array.</td>
</tr>
<tr>
<td>zip : seq&lt;'T1&gt; &rarr; seq&lt;'T2&gt; &rarr; seq&lt;'T1 * 'T2&gt;</td>
<td>Combines the two sequences into a list of pairs. The two sequences need not have equal lengths &minus; when one sequence is exhausted any remaining elements in the other sequence are ignored.</td>
</tr>
<tr>
<td>zip3 : seq&lt;'T1&gt; &rarr; seq&lt;'T2&gt; &rarr; seq&lt;'T3&gt; &rarr; seq&lt;'T1 * 'T2 * 'T3&gt;</td>
<td>Combines the three sequences into a list of triples. The sequences need not have equal lengths &minus; when one sequence is exhausted any remaining elements in the other sequences are ignored.</td>
</tr>
</table>
<p>The following examples demonstrate the uses of some of the above functionalities &minus;</p>
<h3>Example 1</h3>
<p>This program creates an empty sequence and fills it up later &minus;</p>
<pre class="prettyprint notranslate tryit">
(* Creating sequences *)
let emptySeq = Seq.empty
let seq1 = Seq.singleton 20

printfn"The singleton sequence:"
printfn "%A " seq1
printfn"The init sequence:"

let seq2 = Seq.init 5 (fun n -&gt; n * 3)
Seq.iter (fun i -&gt; printf "%d " i) seq2
printfn""

(* converting an array to sequence by using cast *)
printfn"The array sequence 1:"
let seq3 = [| 1 .. 10 |] :> seq&lt;int&gt;
Seq.iter (fun i -&gt; printf "%d " i) seq3
printfn""

(* converting an array to sequence by using Seq.ofArray *)
printfn"The array sequence 2:"
let seq4 = [| 2..2.. 20 |] |> Seq.ofArray
Seq.iter (fun i -&gt; printf "%d " i) seq4
printfn""
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
The singleton sequence:
seq [20]
The init sequence:
0 3 6 9 12
The array sequence 1:
1 2 3 4 5 6 7 8 9 10
The array sequence 2:
2 4 6 8 10 12 14 16 18 20
</pre>
<p>Please note that &minus;</p>
<ul class="list">
<li><p>The Seq.empty method creates an empty sequence.</p></li>
<li><p>The Seq.singleton method creates a sequence of just one specified element.</p></li>
<li><p>The Seq.init method creates a sequence for which the elements are created by using a given function.</p></li>
<li><p>The Seq.ofArray and Seq.ofList&lt;'T&gt; methods create sequences from arrays and lists.</p></li>
<li><p>The Seq.iter method allows iterating through a sequence.</p></li>
</ul>
<h3>Example 2</h3>
<p>The Seq.unfold method generates a sequence from a computation function that takes a state and transforms it to produce each subsequent element in the sequence.</p>
<p>The following function produces the first 20 natural numbers &minus;</p>
<pre class="prettyprint notranslate tryit">
let seq1 = Seq.unfold (fun state -&gt; if (state &gt; 20) then None else Some(state, state + 1)) 0
printfn "The sequence seq1 contains numbers from 0 to 20."
for x in seq1 do printf "%d " x
printfn" "
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
The sequence seq1 contains numbers from 0 to 20.
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
</pre>
<h3>Example 3</h3>
<p>The Seq.truncate method creates a sequence from another sequence, but limits the sequence to a specified number of elements.</p>
<p>The Seq.take method creates a new sequence that contains a specified number of elements from the start of a sequence.</p>
<pre class="prettyprint notranslate tryit">
let mySeq = seq { for i in 1 .. 10 -&gt; 3*i }
let truncatedSeq = Seq.truncate 5 mySeq
let takeSeq = Seq.take 5 mySeq

printfn"The original sequence"
Seq.iter (fun i -&gt; printf "%d " i) mySeq
printfn""

printfn"The truncated sequence"
Seq.iter (fun i -&gt; printf "%d " i) truncatedSeq
printfn""

printfn"The take sequence"
Seq.iter (fun i -&gt; printf "%d " i) takeSeq
printfn""
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
The original sequence
3 6 9 12 15 18 21 24 27 30
The truncated sequence
3 6 9 12 15
The take sequence
3 6 9 12 15
</pre>
<h1>F# - Sets</h1>
<p>A set in F# is a data structure that acts as a collection of items without preserving the order in which items are inserted. Sets do not allow duplicate entries to be inserted into the collection.</p>
<h2>Creating Sets</h2>
<p>Sets can be created in the following ways &minus;</p>
<ul class="list">
<li>By creating an empty set using Set.empty and adding items using the add function.</li>
<li>Converting sequences and lists to sets.</li>
</ul>
<p>The following program demonstrates the techniques &minus;</p>
<pre class="prettyprint notranslate tryit">
(* creating sets *)
let set1 = Set.empty.Add(3).Add(5).Add(7). Add(9)
printfn"The new set: %A" set1

let weekdays = Set.ofList ["mon"; "tues"; "wed"; "thurs"; "fri"]
printfn "The list set: %A" weekdays

let set2 = Set.ofSeq [ 1 .. 2.. 10 ]
printfn "The sequence set: %A" set2
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
The new set: set [3; 5; 7; 9]
The list set: set ["fri"; "mon"; "thurs"; "tues"; "wed"]
The sequence set: set [1; 3; 5; 7; 9]
</pre>
<h2>Basic Operations on Sets</h2>
<p>The following table shows the basic operations on sets &minus;</p>
<table class="table table-bordered">
<tr>
<th style="width:48%;">Value</th>
<th>Description</th>
</tr>
<tr>
<td>add : 'T &rarr; Set&lt;'T&gt; &rarr; Set&lt;'T&gt;</td>
<td>Returns a new set with an element added to the set. No exception is raised if the set already contains the given element.</td>
</tr>
<tr>
<td>contains : 'T &rarr; Set&lt;'T&gt; &rarr; bool</td>
<td>Evaluates to <b>true</b> if the given element is in the given set.</td>
</tr>
<tr>
<td>count : Set&lt;'T&gt; &rarr; int</td>
<td>Returns the number of elements in the set.</td>
</tr>
<tr>
<td>difference : Set&lt;'T&gt; &rarr; Set&lt;'T&gt; &rarr; Set&lt;'T&gt;</td>
<td>Returns a new set with the elements of the second set removed from the first.</td>
</tr>
<tr>
<td>empty : Set&lt;'T&gt;</td>
<td>The empty set for the specified type.</td>
</tr>
<tr>
<td>exists : ('T &rarr; bool) &rarr; Set&lt;'T&gt; &rarr; bool</td>
<td>Tests if any element of the collection satisfies the given predicate. If the input function is predicate and the elements are i0...iN, then this function computes predicate i0 or ... or predicate iN.</td>
</tr>
<tr>
<td>filter : ('T &rarr; bool) &rarr; Set&lt;'T&gt; &rarr; Set&lt;'T&gt;</td>
<td>Returns a new collection containing only the elements of the collection for which the given predicate returns <b>true</b>.</td>
</tr>
<tr>
<td>fold : ('State &rarr; 'T &rarr; 'State) &rarr; 'State &rarr; Set&lt;'T&gt; &rarr; 'State</td>
<td>Applies the given accumulating function to all the elements of the set.</td>
</tr>
<tr>
<td>foldBack : ('T &rarr; 'State &rarr; 'State) &rarr; Set&lt;'T&gt; &rarr; 'State &rarr; 'State</td>
<td>Applies the given accumulating function to all the elements of the set.</td>
</tr>
<tr>
<td>forall : ('T &rarr; bool) &rarr; Set&lt;'T&gt; &rarr; bool</td>
<td>Tests if all elements of the collection satisfy the given predicate. If the input function is p and the elements are i0...iN, then this function computes p i0 && ... && p iN.</td>
</tr>
<tr>
<td>intersect : Set&lt;'T&gt; &rarr; Set&lt;'T&gt; &rarr; Set&lt;'T&gt;</td>
<td>Computes the intersection of the two sets.</td>
</tr>
<tr>
<td>intersectMany : seq&lt;Set&lt;'T&gt;&gt; &rarr; Set&lt;'T&gt;</td>
<td>Computes the intersection of a sequence of sets. The sequence must be non-empty.</td>
</tr>
<tr>
<td>isEmpty : Set&lt;'T&gt; &rarr; bool</td>
<td>Returns <b>true</b> if the set is empty.</td>
</tr>
<tr>
<td>isProperSubset : Set&lt;'T&gt; &rarr; Set&lt;'T&gt; &rarr; bool</td>
<td>Evaluates to <b>true</b> if all elements of the first set are in the second, and at least one element of the second is not in the first.</td>
</tr>
<tr>
<td>isProperSuperset : Set&lt;'T&gt; &rarr; Set&lt;'T&gt; &rarr; bool</td>
<td>Evaluates to <b>true</b> if all elements of the second set are in the first, and at least one element of the first is not in the second.</td>
</tr>
<tr>
<td>isSubset : Set&lt;'T&gt; &rarr; Set&lt;'T&gt; &rarr; bool</td>
<td>Evaluates to <b>true</b> if all elements of the first set are in the second.</td>
</tr>
<tr>
<td>isSuperset : Set&lt;'T&gt; &rarr; Set&lt;'T&gt; &rarr; bool</td>
<td>Evaluates to <b>true</b> if all elements of the second set are in the first.</td>
</tr>
<tr>
<td>iter : ('T &rarr; unit) &rarr; Set&lt;'T&gt; &rarr; unit</td>
<td>Applies the given function to each element of the set, in order according to the comparison function.</td>
</tr>
<tr>
<td>map : ('T &rarr; 'U) &rarr; Set&lt;'T&gt; &rarr; Set&lt;'U&gt;</td>
<td>Returns a new collection containing the results of applying the given function to each element of the input set.</td>
</tr>
<tr>
<td>maxElement : Set&lt;'T&gt; &rarr; 'T</td>
<td>Returns the highest element in the set according to the ordering being used for the set.</td>
</tr>
<tr>
<td>minElement : Set&lt;'T&gt; &rarr; 'T</td>
<td>Returns the lowest element in the set according to the ordering being used for the set.</td>
</tr>
<tr>
<td>ofArray : 'T array &rarr; Set&lt;'T&gt;</td>
<td>Creates a set that contains the same elements as the given array.</td>
</tr>
<tr>
<td>ofList : 'T list &rarr; Set&lt;'T&gt;</td>
<td>Creates a set that contains the same elements as the given list.</td>
</tr>
<tr>
<td>ofSeq : seq&lt;'T&gt; &rarr; Set&lt;'T&gt;</td>
<td>Creates a new collection from the given enumerable object.</td>
</tr>
<tr>
<td>partition : ('T &rarr; bool) &rarr; Set&lt;'T&gt; &rarr; Set&lt;'T&gt; * Set&lt;'T&gt;</td>
<td>Splits the set into two sets containing the elements for which the given predicate returns true and false respectively.</td>
</tr>
<tr>
<td>remove : 'T &rarr; Set&lt;'T&gt; &rarr; Set&lt;'T&gt;</td>
<td>Returns a new set with the given element removed. No exception is raised if the set doesn't contain the given element.</td>
</tr>
<tr>
<td>singleton : 'T &rarr; Set&lt;'T&gt;</td>
<td>The set containing the given element.</td>
</tr>
<tr>
<td>toArray : Set&lt;'T&gt; &rarr; 'T array</td>
<td>Creates an array that contains the elements of the set in order.</td>
</tr>
<tr>
<td>toList : Set&lt;'T&gt; &rarr; 'T list</td>
<td>Creates a list that contains the elements of the set in order.</td>
</tr>
<tr>
<td>toSeq : Set&lt;'T&gt; &rarr; seq&lt;'T&gt;</td>
<td>Returns an ordered view of the collection as an enumerable object.</td>
</tr>
<tr>
<td>union : Set&lt;'T&gt; &rarr; Set&lt;'T&gt; &rarr; Set&lt;'T&gt;</td>
<td>Computes the union of the two sets.</td>
</tr>
<tr>
<td>unionMany : seq&lt;Set&lt;'T&gt;&gt; &rarr; Set&lt;'T&gt;</td>
<td>Computes the union of a sequence of sets.</td>
</tr>
</table>
<p>The following example demonstrates the uses of some of the above functionalities &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
let a = Set.ofSeq [ 1 ..2.. 20 ]
let b = Set.ofSeq [ 1 ..3 .. 20 ]
let c = Set.intersect a b
let d = Set.union a b
let e = Set.difference a b

printfn "Set a: "
Set.iter (fun x -> printf "%O " x) a
printfn""

printfn "Set b: "
Set.iter (fun x -> printf "%O " x) b
printfn""

printfn "Set c = set intersect of a and b : "
Set.iter (fun x -> printf "%O " x) c
printfn""

printfn "Set d = set union of a and b : "
Set.iter (fun x -> printf "%O " x) d
printfn""

printfn "Set e = set difference of a and b : "
Set.iter (fun x -> printf "%O " x) e
printfn""
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Set a:
1 3 5 7 9 11 13 15 17 19
Set b:
1 4 7 10 13 16 19
Set c = set intersect of a and b :
1 7 13 19
Set d = set union of a and b :
1 3 4 5 7 9 10 11 13 15 16 17 19
Set e = set difference of a and b :
3 5 9 11 15 17
</pre>
<h1>F# - Maps</h1>
<p>In F#, a map is a special kind of set that associates the values with key. A map is created in a similar way as sets are created.</p>
<h2>Creating Maps</h2>
<p>Maps are created by creating an empty map using Map.empty and adding items using the Add function. The following example demonstrates this &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
(* Create an empty Map *)
let students =
   Map.empty. (* Creating an empty Map *)
      Add("Zara Ali", "1501").
      Add("Rishita Gupta", "1502").
      Add("Robin Sahoo", "1503").
      Add("Gillian Megan", "1504");;
printfn "Map - students: %A" students

(* Convert a list to Map *)
let capitals =
   [ "Argentina", "Buenos Aires";
      "France ", "Paris";
      "Chili", "Santiago";
      "Malaysia", " Kuala Lumpur";
      "Switzerland", "Bern" ]
   |> Map.ofList;;
printfn "Map capitals : %A" capitals
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Map - students: map
[("Gillian Megan", "1504"); ("Rishita Gupta", "1502"); ("Robin Sahoo", "1503
");
("Zara Ali", "1501")]
Map capitals : map
[("Argentina", "Buenos Aires"); ("Chili", "Santiago"); ("France ", "Paris");
("Malaysia", " Kuala Lumpur"); ("Switzerland", "Bern")]
</pre>
<p>You can access individual elements in the map using the key.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
(* Create an empty Map *)
let students =
   Map.empty. (* Creating an empty Map *)
      Add("Zara Ali", "1501").
      Add("Rishita Gupta", "1502").
      Add("Robin Sahoo", "1503").
      Add("Gillian Megan", "1504");;
printfn "Map - students: %A" students

(*Accessing an element using key *)
printfn "%A" students.["Zara Ali"]
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Map - students: map
[("Gillian Megan", "1504"); ("Rishita Gupta", "1502"); ("Robin Sahoo", "1503
");
("Zara Ali", "1501")]
"1501"
</pre>
<h2>Basic Operations on Maps</h2>
<h3>Add module name</h3>
<p>The following table shows the basic operations on maps &minus;</p>
<table class="table table-bordered">
<tr>
<th>Member</th>
<th>Description</th>
</tr>
<tr>
<td>Add</td>
<td>Returns a new map with the binding added to the given map.</td>
</tr>
<tr>
<td>ContainsKey</td>
<td>Tests if an element is in the domain of the map.</td>
</tr>
<tr>
<td>Count</td>
<td>The number of bindings in the map.</td>
</tr>
<tr>
<td>IsEmpty</td>
<td>Returns true if there are no bindings in the map.</td>
</tr>
<tr>
<td>Item</td>
<td>Lookup an element in the map. Raises KeyNotFoundException if no binding exists in the map.</td>
</tr>
<tr>
<td>Remove</td>
<td>Removes an element from the domain of the map. No exception is raised if the element is not present.</td>
</tr>
<tr>
<td>TryFind</td>
<td>Lookup an element in the map, returning a <b>Some</b> value if the element is in the domain of the map and <b>None</b> if not.</td>
</tr>
</table>
<p>The following example demonstrates the uses of some of the above functionalities &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
(* Create an empty Map *)
let students =
   Map.empty. (* Creating an empty Map *)
      Add("Zara Ali", "1501").
      Add("Rishita Gupta", "1502").
      Add("Robin Sahoo", "1503").
      Add("Gillian Megan", "1504").
      Add("Shraddha Dubey", "1505").
      Add("Novonil Sarker", "1506").
      Add("Joan Paul", "1507");;
printfn "Map - students: %A" students
printfn "Map - number of students: %d" students.Count

(* finding the registration number of a student*)
let found = students.TryFind "Rishita Gupta"
match found with
| Some x -> printfn "Found %s." x
| None -> printfn "Did not find the specified value."
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Map - students: map
[("Gillian Megan", "1504"); ("Joan Paul", "1507"); ("Novonil Sarker", "1506"
);
("Rishita Gupta", "1502"); ("Robin Sahoo", "1503");
("Shraddha Dubey", "1505"); ("Zara Ali", "1501")]
Map - number of students: 7
Found 1502.
</pre>
<h1>F# - Discriminated Unions</h1>
<p>Unions, or discriminated unions allows you to build up complex data structures representing well-defined set of choices. For example, you need to build an implementation of a <i>choice</i> variable, which has two values yes and no. Using the Unions tool, you can design this.</p>
<h2>Syntax</h2>
<p>Discriminated unions are defined using the following syntax &minus;</p>
<pre class="result notranslate">
type type-name =
   | case-identifier1 [of [ fieldname1 : ] type1 [ * [ fieldname2 : ] 
type2 ...]
   | case-identifier2 [of [fieldname3 : ]type3 [ * [ fieldname4 : ]type4 ...]
...
</pre>
<p>Our simple implementation of ,<i>choice,</i> will look like the following &minus;</p>
<pre class="result notranslate">
type choice =
   | Yes
   | No
</pre>
<p>The following example uses the type choice &minus;</p>
<pre class="prettyprint notranslate tryit">
type choice =
   | Yes
   | No

let x = Yes (* creates an instance of choice *)
let y = No (* creates another instance of choice *)
let main() =
   printfn "x: %A" x
   printfn "y: %A" y
main()
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
x: Yes
y: No
</pre>
<h2>Example 1</h2>
<p>The following example shows the implementation of the voltage states that sets a bit on high or low &minus;</p>
<pre class="prettyprint notranslate tryit">
type VoltageState =
   | High
   | Low

let toggleSwitch = function (* pattern matching input *)
   | High -> Low
   | Low -> High

let main() =
   let on = High
   let off = Low
   let change = toggleSwitch off

   printfn "Switch on state: %A" on
   printfn "Switch off state: %A" off
   printfn "Toggle off: %A" change
   printfn "Toggle the Changed state: %A" (toggleSwitch change)

main()
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Switch on state: High
Switch off state: Low
Toggle off: High
Toggle the Changed state: Low
</pre>
<h2>Example 2</h2>
<pre class="prettyprint notranslate tryit">
type Shape =
   // here we store the radius of a circle
   | Circle of float

   // here we store the side length.
   | Square of float

   // here we store the height and width.
   | Rectangle of float * float

let pi = 3.141592654

let area myShape =
   match myShape with
   | Circle radius -&gt; pi * radius * radius
   | Square s -&gt; s * s
   | Rectangle (h, w) -&gt; h * w

let radius = 12.0
let myCircle = Circle(radius)
printfn "Area of circle with radius %g: %g" radius (area myCircle)

let side = 15.0
let mySquare = Square(side)
printfn "Area of square that has side %g: %g" side (area mySquare)

let height, width = 5.0, 8.0
let myRectangle = Rectangle(height, width)
printfn "Area of rectangle with height %g and width %g is %g" height width (area myRectangle)
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Area of circle with radius 12: 452.389
Area of square that has side 15: 225
Area of rectangle with height 5 and width 8 is 40
</pre>
<h1>F# - Mutable Data</h1>
<p>Variables in F# are <b>immutable,</b> which means once a variable is bound to a value, it can’t be changed. They are actually compiled as static read-only properties.</p>
<p>The following example demonstrates this.</p>
<h2>Example</h2>
<pre class="prettyprint notranslate tryit">
let x = 10
let y = 20
let z = x + y

printfn "x: %i" x
printfn "y: %i" y
printfn "z: %i" z

let x = 15
let y = 20
let z = x + y

printfn "x: %i" x
printfn "y: %i" y
printfn "z: %i" z
</pre>
<p>When you compile and execute the program, it shows the following error message &minus;</p>
<pre class="result notranslate">
Duplicate definition of value 'x'
Duplicate definition of value 'Y'
Duplicate definition of value 'Z'
</pre>
<h2>Mutable Variables</h2>
<p>At times you need to change the values stored in a variable. To specify that there could be a change in the value of a declared and assigned variable in later part of a program, F# provides the <b>mutable</b> keyword. You can declare and assign mutable variables using this keyword, whose values you will change.</p>
<p>The <b>mutable</b> keyword allows you to declare and assign values in a mutable variable.</p>
<p>You can assign some initial value to a mutable variable using the <b>let</b> keyword. However, to assign new subsequent value to it, you need to use the <b>&lt;-</b> operator.</p>
<p>For example,</p>
<pre class="result notranslate">
let mutable x = 10
x &lt;- 15
</pre>
<p>The following example will clear the concept &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
let mutable x = 10
let y = 20
let mutable z = x + y

printfn "Original Values:"
printfn "x: %i" x
printfn "y: %i" y
printfn "z: %i" z

printfn "Let us change the value of x"
printfn "Value of z will change too."

x &lt;- 15
z &lt;- x + y

printfn "New Values:"
printfn "x: %i" x
printfn "y: %i" y
printfn "z: %i" z
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Original Values:
x: 10
y: 20
z: 30
Let us change the value of x
Value of z will change too.
New Values:
x: 15
y: 20
z: 35
</pre>
<h2>Uses of Mutable Data</h2>
<p>Mutable data is often required and used in data processing, particularly with record data structure. The following example demonstrates this &minus;</p>
<pre class="prettyprint notranslate tryit">
open System

type studentData =
   { ID : int;
      mutable IsRegistered : bool;
      mutable RegisteredText : string; }

let getStudent id =
   { ID = id;
      IsRegistered = false;
      RegisteredText = null; }

let registerStudents (students : studentData list) =
   students |> List.iter(fun st -&gt;
      st.IsRegistered &lt;- true
      st.RegisteredText &lt;- sprintf "Registered %s" (DateTime.Now.ToString("hh:mm:ss"))

      Threading.Thread.Sleep(1000) (* Putting thread to sleep for 1 second to simulate processing overhead. *))

let printData (students : studentData list) =
   students |> List.iter (fun x -&gt; printfn "%A" x)

let main() =
   let students = List.init 3 getStudent

   printfn "Before Process:"
   printData students

   printfn "After process:"
   registerStudents students
   printData students

   Console.ReadKey(true) |> ignore

main()
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Before Process:
{ID = 0;
IsRegistered = false;
RegisteredText = null;}
{ID = 1;
IsRegistered = false;
RegisteredText = null;}
{ID = 2;
IsRegistered = false;
RegisteredText = null;}
After process:
{ID = 0;
IsRegistered = true;
RegisteredText = "Registered 05:39:15";}
{ID = 1;
IsRegistered = true;
RegisteredText = "Registered 05:39:16";}
{ID = 2;
IsRegistered = true;
RegisteredText = "Registered 05:39:17";}
</pre>
<h1>F# - Arrays</h1>
<p>Arrays are fixed-size, zero-based, mutable collections of consecutive data elements that are all of the same type.</p>
<h2>Creating Arrays</h2>
<p>You can create arrays using various syntaxes and ways or by using the functions from the Array module. In this section, we will discuss creating arrays without using the module functions.</p>
<p>There are three syntactical ways of creating arrays without functions &minus;</p>
<ul class="list">
<li>By listing consecutive values between [| and |] and separated by semicolons.</li>
<li>By putting each element on a separate line, in which case the semicolon separator is optional.</li>
<li>By using sequence expressions.</li>
</ul>
<p>You can access array elements by using a dot operator (.) and brackets ([ and ]).</p>
<p>The following example demonstrates creating arrays &minus;</p>
<pre class="prettyprint notranslate tryit">
//using semicolon separator
let array1 = [| 1; 2; 3; 4; 5; 6 |]
for i in 0 .. array1.Length - 1 do
   printf "%d " array1.[i]
printfn" "

// without semicolon separator
let array2 =
   [|
      1
      2
      3
      4
      5
   |]
for i in 0 .. array2.Length - 1 do
   printf "%d " array2.[i]
printfn" "

//using sequence
let array3 = [| for i in 1 .. 10 -> i * i |]
for i in 0 .. array3.Length - 1 do
   printf "%d " array3.[i]
printfn" "
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
1 2 3 4 5 6
1 2 3 4 5
1 4 9 16 25 36 49 64 81 100
</pre>
<h2>Basic Operations on Arrays</h2>
<p>The library module Microsoft.FSharp.Collections.Array supports operations on one-dimensional arrays.</p>
<p>The following table shows the basic operations on Arrays &minus;</p>
<table class="table table-bordered">
<tr>
<th style="width:48%;">Value</th>
<th>Description</th>
</tr>
<tr>
<td>append : 'T [] &rarr; 'T [] &rarr; 'T []</td>
<td>Creates an array that contains the elements of one array followed by the elements of another array.</td>
</tr>
<tr>
<td>average : ^T [] &rarr; ^T</td>
<td>Returns the average of the elements in an array.</td>
</tr>
<tr>
<td>averageBy : ('T &rarr; ^U) &rarr; 'T [] &rarr; ^U</td>
<td>Returns the average of the elements generated by applying a function to each element of an array.</td>
</tr>
<tr>
<td>blit : 'T [] &rarr; int &rarr; 'T [] &rarr; int &rarr; int &rarr; unit</td>
<td>Reads a range of elements from one array and writes them into another.</td>
</tr>
<tr>
<td>choose : ('T &rarr; U option) &rarr; 'T [] &rarr; 'U []</td>
<td>Applies a supplied function to each element of an array. Returns an array that contains the results x for each element for which the function returns Some(x).</td>
</tr>
<tr>
<td>collect : ('T &rarr; 'U []) &rarr; T [] &rarr; 'U []</td>
<td>Applies the supplied function to each element of an array, concatenates the results, and returns the combined array.</td>
</tr>
<tr>
<td>concat : seq&lt;'T []&gt; &rarr; 'T []</td>
<td>Creates an array that contains the elements of each of the supplied sequence of arrays.</td>
</tr>
<tr>
<td>copy : 'T &rarr; 'T []</td>
<td>Creates an array that contains the elements of the supplied array.</td>
</tr>
<tr>
<td>create : int &rarr; 'T &rarr; 'T []</td>
<td>Creates an array whose elements are all initially the supplied value.</td>
</tr>
<tr>
<td>empty : 'T []</td>
<td>Returns an empty array of the given type.</td>
</tr>
<tr>
<td>exists : ('T &rarr; bool) &rarr; 'T [] &rarr; bool</td>
<td>Tests whether any element of an array satisfies the supplied predicate.</td>
</tr>
<tr>
<td>exists2 : ('T1 &rarr; 'T2 &rarr; bool) &rarr; 'T1 [] &rarr; 'T2 [] &rarr; bool</td>
<td>Tests whether any pair of corresponding elements of two arrays satisfy the supplied condition.</td>
</tr>
<tr>
<td>fill : 'T [] &rarr; int &rarr; int &rarr; 'T &rarr; unit</td>
<td>Fills a range of elements of an array with the supplied value.</td>
</tr>
<tr>
<td>filter : ('T &rarr; bool) &rarr; 'T [] &rarr; 'T []</td>
<td>Returns a collection that contains only the elements of the supplied array for which the supplied condition returns <b>true</b>.</td>
</tr>
<tr>
<td>find : ('T &rarr; bool) &rarr; 'T [] &rarr; 'T</td>
<td>Returns the first element for which the supplied function returns <b>true</b>. Raises KeyNotFoundException if no such element exists.</td>
</tr>
<tr>
<td>findIndex : ('T &rarr; bool) &rarr; 'T [] &rarr; int</td>
<td>Returns the index of the first element in an array that satisfies the supplied condition. Raises KeyNotFoundException if none of the elements satisfy the condition.</td>
</tr>
<tr>
<td>fold : ('State &rarr; 'T &rarr; 'State) &rarr; 'State &rarr; 'T [] &rarr; 'State</td>
<td>Applies a function to each element of an array, threading an accumulator argument through the computation. If the input function is f and the array elements are i0...iN, this function computes f (...(f s i0)...) iN.</td>
</tr>
<tr>
<td>fold2 : ('State &rarr; 'T1 &rarr; 'T2 &rarr; 'State) &rarr; 'State &rarr; 'T1 [] &rarr; 'T2 [] &rarr; 'State</td>
<td>Applies a function to pairs of elements from two supplied arrays, left-to-right, threading an accumulator argument through the computation. The two input arrays must have the same lengths; otherwise, ArgumentException is raised.</td>
</tr>
<tr>
<td>foldBack : ('T &rarr; 'State &rarr; 'State) &rarr; 'T [] &rarr; 'State &rarr; 'State</td>
<td>Applies a function to each element of an array, threading an accumulator argument through the computation. If the input function is f and the array elements are i0...iN, this function computes f i0 (...(f iN s)).</td>
</tr>
<tr>
<td>foldBack2 : ('T1 &rarr; 'T2 &rarr; 'State &rarr; 'State) &rarr; 'T1 [] &rarr; 'T2 [] &rarr; 'State &rarr; 'State</td>
<td>Applies a function to pairs of elements from two supplied arrays, right-to-left, threading an accumulator argument through the computation. The two input arrays must have the same lengths; otherwise, ArgumentException is raised.</td>
</tr>
<tr>
<td>forall : ('T &rarr; bool) &rarr; 'T [] &rarr; bool</td>
<td>Tests whether all elements of an array satisfy the supplied condition.</td>
</tr>
<tr>
<td>forall2 : ('T1 &rarr; 'T2 &rarr; bool) &rarr; 'T1 [] &rarr; 'T2 [] &rarr; bool</td>
<td>Tests whether all corresponding elements of two supplied arrays satisfy a supplied condition.</td>
</tr>
<tr>
<td>get : 'T [] &rarr; int &rarr; 'T</td>
<td>Gets an element from an array.</td>
</tr>
<tr>
<td>init : int &rarr; (int &rarr; 'T) &rarr; 'T []</td>
<td>Uses a supplied function to create an array of the supplied dimension.</td>
</tr>
<tr>
<td>isEmpty : 'T [] &rarr; bool</td>
<td>Tests whether an array has any elements.</td>
</tr>
<tr>
<td>iter : ('T &rarr; unit) &rarr; 'T [] &rarr; unit</td>
<td>Applies the supplied function to each element of an array.</td>
</tr>
<tr>
<td>iter2 : ('T1 &rarr; 'T2 &rarr; unit) &rarr; 'T1 [] &rarr; 'T2 [] &rarr; unit)</td>
<td>Applies the supplied function to a pair of elements from matching indexes in two arrays. The two arrays must have the same lengths; otherwise, ArgumentException is raised.</td>
</tr>
<tr>
<td>iteri : (int &rarr; 'T &rarr; unit) &rarr; 'T [] &rarr; unit</td>
<td>Applies the supplied function to each element of an array. The integer passed to the function indicates the index of the element.</td>
</tr>
<tr>
<td>iteri2 : (int &rarr; 'T1 &rarr; 'T2 &rarr; unit) &rarr; 'T1 [] &rarr; 'T2 [] &rarr; unit</td>
<td>Applies the supplied function to a pair of elements from matching indexes in two arrays, also passing the index of the elements. The two arrays must have the same lengths; otherwise, an ArgumentException is raised.</td>
</tr>
<tr>
<td>length : 'T [] &rarr; int</td>
<td>Returns the length of an array. The Length property does the same thing.</td>
</tr>
<tr>
<td>map : ('T &rarr; 'U) &rarr; 'T [] &rarr; 'U []</td>
<td>Creates an array whose elements are the results of applying the supplied function to each of the elements of a supplied array.</td>
</tr>
<tr>
<td>map2 : ('T1 &rarr; 'T2 &rarr; 'U) &rarr; 'T1 [] &rarr; 'T2 [] &rarr; 'U []</td>
<td>Creates an array whose elements are the results of applying the supplied function to the corresponding elements of two supplied arrays. The two input arrays must have the same lengths; otherwise, ArgumentException is raised.</td>
</tr>
<tr>
<td>mapi : (int &rarr; 'T &rarr; 'U) &rarr; 'T [] &rarr; 'U []</td>
<td>Creates an array whose elements are the results of applying the supplied function to each of the elements of a supplied array. An integer index passed to the function indicates the index of the element being transformed.</td>
</tr>
<tr>
<td>mapi2 : (int &rarr; 'T1 &rarr; 'T2 &rarr; 'U) &rarr; 'T1 [] &rarr; 'T2 [] &rarr; 'U []</td>
<td>Creates an array whose elements are the results of applying the supplied function to the corresponding elements of the two collections pairwise, also passing the index of the elements. The two input arrays must have the same lengths; otherwise, ArgumentException is raised.</td>
</tr>
<tr>
<td>max : 'T [] &rarr; 'T</td>
<td>Returns the largest of all elements of an array. Operators.max is used to compare the elements.</td>
</tr>
<tr>
<td>maxBy : ('T &rarr; 'U) &rarr; 'T [] &rarr; 'T</td>
<td>Returns the largest of all elements of an array, compared via Operators.max on the function result.</td>
</tr>
<tr>
<td>min : ('T [] &rarr; 'T</td>
<td>Returns the smallest of all elements of an array. Operators.min is used to compare the elements.</td>
</tr>
<tr>
<td>minBy : ('T &rarr; 'U) &rarr; 'T [] &rarr; 'T</td>
<td>Returns the smallest of all elements of an array. Operators.min is used to compare the elements.</td>
</tr>
<tr>
<td>ofList : 'T list &rarr; 'T []</td>
<td>Creates an array from the supplied list.</td>
</tr>
<tr>
<td>ofSeq : seq&lt;'T&gt; &rarr; 'T []</td>
<td>Creates an array from the supplied enumerable object.</td>
</tr>
<tr>
<td>partition : ('T &rarr; bool) &rarr; 'T [] &rarr; 'T [] * 'T []</td>
<td>Splits an array into two arrays, one containing the elements for which the supplied condition returns <b>true,</b> and the other containing those for which it returns <b>false</b>.</td>
</tr>
<tr>
<td>permute : (int &rarr; int) &rarr; 'T [] &rarr; 'T []</td>
<td>Permutes the elements of an array according to the specified permutation.</td>
</tr>
<tr>
<td>pick : ('T &rarr; 'U option) &rarr; 'T [] &rarr; 'U</td>
<td>Applies the supplied function to successive elements of a supplied array, returning the first result where the function returns Some(x) for some x. If the function never returns Some(x), KeyNotFoundException is raised.</td>
</tr>
<tr>
<td>reduce : ('T &rarr; 'T &rarr; 'T) &rarr; 'T [] &rarr; 'T</td>
<td>Applies a function to each element of an array, threading an accumulator argument through the computation. If the input function is f and the array elements are i0...iN, this function computes f (...(f i0 i1)...) iN. If the array has size zero, ArgumentException is raised.</td>
</tr>
<tr>
<td>reduceBack : ('T &rarr; 'T &rarr; 'T) &rarr; 'T [] &rarr; 'T</td>
<td>Applies a function to each element of an array, threading an accumulator argument through the computation. If the input function is f and the elements are i0...iN, this function computes f i0 (...(f iN-1 iN)). If the array has size zero, ArgumentException is raised.</td>
</tr>
<tr>
<td>rev : 'T [] &rarr; 'T []</td>
<td>Reverses the order of the elements in a supplied array.</td>
</tr>
<tr>
<td>scan : ('State &rarr; 'T &rarr; 'State) &rarr; 'State &rarr; 'T [] &rarr; 'State [])</td>
<td>Behaves like fold, but returns the intermediate results together with the final results.</td>
</tr>
<tr>
<td>scanBack : ('T &rarr; 'State &rarr; 'State) &rarr; 'T [] &rarr; 'State &rarr; 'State []</td>
<td>Behaves like foldBack, but returns the intermediary results together with the final results.</td>
</tr>
<tr>
<td>set : 'T [] &rarr; int &rarr; 'T &rarr; unit</td>
<td>Sets an element of an array.</td>
</tr>
<tr>
<td>sort : 'T[] &rarr; 'T []</td>
<td>Sorts the elements of an array and returns a new array. Operators.compare is used to compare the elements.</td>
</tr>
<tr>
<td>sortBy : ('T &rarr; 'Key) &rarr; 'T [] &rarr; 'T []</td>
<td>Sorts the elements of an array by using the supplied function to transform the elements to the type on which the sort operation is based, and returns a new array. Operators.compare is used to compare the elements.</td>
</tr>
<tr>
<td>sortInPlace : 'T [] &rarr; unit</td>
<td>Sorts the elements of an array by changing the array in place, using the supplied comparison function. Operators.compare is used to compare the elements.</td>
</tr>
<tr>
<td>sortInPlaceBy : ('T &rarr; 'Key) &rarr; 'T [] &rarr; unit</td>
<td>Sorts the elements of an array by changing the array in place, using the supplied projection for the keys. Operators.compare is used to compare the elements.</td>
</tr>
<tr>
<td>sortInPlaceWith : ('T &rarr; 'T &rarr; int) &rarr; 'T [] &rarr; unit</td>
<td>Sorts the elements of an array by using the supplied comparison function to change the array in place.</td>
</tr>
<tr>
<td>sortWith : ('T &rarr; 'T &rarr; int) &rarr; 'T [] &rarr; 'T []</td>
<td>Sorts the elements of an array by using the supplied comparison function, and returns a new array.</td>
</tr>
<tr>
<td>sub : 'T [] &rarr; int &rarr; int &rarr; 'T []</td>
<td>Creates an array that contains the supplied subrange, which is specified by starting index and length.</td>
</tr>
<tr>
<td>sum : 'T [] &rarr; ^T</td>
<td>Returns the sum of the elements in the array.</td>
</tr>
<tr>
<td>sumBy : ('T &rarr; ^U) &rarr; 'T [] &rarr; ^U</td>
<td>Returns the sum of the results generated by applying a function to each element of an array.</td>
</tr>
<tr>
<td>toList : 'T [] &rarr; 'T list</td>
<td>Converts the supplied array to a list.</td>
</tr>
<tr>
<td>toSeq : 'T [] &rarr; seq&lt;'T&gt;</td>
<td>Views the supplied array as a sequence.</td>
</tr>
<tr>
<td>tryFind : ('T &rarr; bool) &rarr; 'T [] &rarr; 'T option</td>
<td>Returns the first element in the supplied array for which the supplied function returns <b>true</b>. Returns <b>None</b> if no such element exists.</td>
</tr>
<tr>
<td>tryFindIndex : ('T &rarr; bool) &rarr; 'T [] &rarr; int option</td>
<td>Returns the index of the first element in an array that satisfies the supplied condition.</td>
</tr>
<tr>
<td>tryPick : ('T &rarr; 'U option) &rarr; 'T [] &rarr; 'U option</td>
<td>Applies the supplied function to successive elements of the supplied array, and returns the first result where the function returns Some(x) for some x. If the function never returns Some(x), <b>None</b> is returned.</td>
</tr>
<tr>
<td>unzip : ('T1 * 'T2) [] &rarr; 'T1 [] * 'T2 []</td>
<td>Splits an array of tuple pairs into a tuple of two arrays.</td>
</tr>
<tr>
<td>unzip3 : ('T1 * 'T2 * 'T3) [] &rarr; 'T1 [] * 'T2 [] * 'T3 []</td>
<td>Splits an array of tuples of three elements into a tuple of three arrays.</td>
</tr>
<tr>
<td>zeroCreate : int &rarr; 'T []</td>
<td>Creates an array whose elements are initially set to the default value Unchecked.defaultof&lt;'T&gt;.</td>
</tr>
<tr>
<td>zip : 'T1 [] &rarr; 'T2 [] &rarr; ('T1 * 'T2) []</td>
<td>Combines two arrays into an array of tuples that have two elements. The two arrays must have equal lengths; otherwise, ArgumentException is raised.</td>
</tr>
<tr>
<td>zip3 : 'T1 [] &rarr; 'T2 [] &rarr; 'T3 [] &rarr; ('T1 * 'T2 * 113
'T3) []</td>
<td>Combines three arrays into an array of tuples that have three elements. The three arrays must have equal lengths; otherwise, ArgumentException is raised.</td>
</tr>
</table>
<p>In the following section, we will see the uses of some of these functionalities.</p>
<h2>Creating Arrays Using Functions</h2>
<p>The Array module provides several functions that create an array from scratch.</p>
<ul class="list">
<li><p>The <b>Array.empty</b> function creates a new empty array.</p></li>
<li><p>The <b>Array.create</b> function creates an array of a specified size and sets all the elements to given values.</p></li>
<li><p>The <b>Array.init</b> function creates an array, given a dimension and a function to generate the elements.</p></li>
<li><p>The <b>Array.zeroCreate</b> function creates an array in which all the elements are initialized to the zero value.</p></li>
<li><p>The <b>Array.copy</b> function creates a new array that contains elements that are copied from an existing array.</p></li>
<li><p>The <b>Array.sub</b> function generates a new array from a subrange of an array.</p></li>
<li><p>The <b>Array.append</b> function creates a new array by combining two existing arrays.</p></li>
<li><p>The <b>Array.choose</b> function selects elements of an array to include in a new array.</p></li>
<li><p>The <b>Array.collect</b> function runs a specified function on each array element of an existing array and then collects the elements generated by the function and combines them into a new array.</p></li>
<li><p>The <b>Array.concat</b> function takes a sequence of arrays and combines them into a single array.</p></li>
<li><p>The <b>Array.filter</b> function takes a Boolean condition function and generates a new array that contains only those elements from the input array for which the condition is true.</p></li>
<li><p>The <b>Array.rev</b> function generates a new array by reversing the order of an existing array.</p></li>
</ul>
<p>The following examples demonstrate these functions &minus;</p>
<h3>Example 1</h3>
<pre class="prettyprint notranslate tryit">
(* using create and set *)
let array1 = Array.create 10 ""
for i in 0 .. array1.Length - 1 do
   Array.set array1 i (i.ToString())
for i in 0 .. array1.Length - 1 do
   printf "%s " (Array.get array1 i)
printfn " "

(* empty array *)
let array2 = Array.empty
printfn "Length of empty array: %d" array2.Length

let array3 = Array.create 10 7.0
printfn "Float Array: %A" array3

(* using the init and zeroCreate *)
let array4 = Array.init 10 (fun index -&gt; index * index)
printfn "Array of squares: %A" array4

let array5 : float array = Array.zeroCreate 10
let (myZeroArray : float array) = Array.zeroCreate 10
printfn "Float Array: %A" array5
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
0 1 2 3 4 5 6 7 8 9
Length of empty array: 0
Float Array: [|7.0; 7.0; 7.0; 7.0; 7.0; 7.0; 7.0; 7.0; 7.0; 7.0|]
Array of squares: [|0; 1; 4; 9; 16; 25; 36; 49; 64; 81|]
Float Array: [|0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0|]
</pre>
<h3>Example 2</h3>
<pre class="prettyprint notranslate tryit">
(* creating subarray from element 5 *)
(* containing 15 elements thereon *)

let array1 = [| 0 .. 50 |]
let array2 = Array.sub array1 5 15
printfn "Sub Array:"
printfn "%A" array2

(* appending two arrays *)
let array3 = [| 1; 2; 3; 4|]
let array4 = [| 5 .. 9 |]
printfn "Appended Array:"
let array5 = Array.append array3 array4
printfn "%A" array5

(* using the Choose function *)
let array6 = [| 1 .. 20 |]
let array7 = Array.choose (fun elem -&gt; if elem % 3 = 0 then
                                             Some(float (elem))
                                          else
                                             None) array6
printfn "Array with Chosen elements:"
printfn "%A" array7

(*using the Collect function *)
let array8 = [| 2 .. 5 |]
let array9 = Array.collect (fun elem -&gt; [| 0 .. elem - 1 |]) array8
printfn "Array with collected elements:"
printfn "%A" array9
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Sub Array:
[|5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19|]
Appended Array:
[|1; 2; 3; 4; 5; 6; 7; 8; 9|]
Array with Chosen elements:
[|3.0; 6.0; 9.0; 12.0; 15.0; 18.0|]
Array with collected elements:
[|0; 1; 0; 1; 2; 0; 1; 2; 3; 0; 1; 2; 3; 4|]
</pre>
<h2>Searching Arrays</h2>
<p>The <b>Array.find</b> function takes a Boolean function and returns the first element for which the function returns true, else raises a KeyNotFoundException.</p>
<p>The <b>Array.findIndex</b> function works similarly except that it returns the index of the element instead of the element itself.</p>
<p>The following example demonstrates this.</p>
<p>Microsoft provides this interesting program example, which finds the first element in the range of a given number that is both a perfect square as well as a perfect cube &minus;</p>
<pre class="prettyprint notranslate tryit">
let array1 = [| 2 .. 100 |]
let delta = 1.0e-10
let isPerfectSquare (x:int) =
   let y = sqrt (float x)
   abs(y - round y) &lt; delta

let isPerfectCube (x:int) =
   let y = System.Math.Pow(float x, 1.0/3.0)
   abs(y - round y) &lt; delta

let element = Array.find (fun elem -&gt; isPerfectSquare elem && isPerfectCube elem) array1

let index = Array.findIndex (fun elem -&gt; isPerfectSquare elem && isPerfectCube elem) array1

printfn "The first element that is both a square and a cube is %d and its index is %d." element index
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
The first element that is both a square and a cube is 64 and its index is 62.
</pre>
<h1>F# - Mutable Lists</h1>
<p>The <b>List&lt;'T&gt;</b> class represents a strongly typed list of objects that can be accessed by index.</p>
<p>It is a mutable counterpart of the List class. It is similar to arrays, as it can be accessed by an index, however, unlike arrays, lists can be resized. Therefore you need not specify a size during declaration.</p>
<h2>Creating a Mutable List</h2>
<p>Lists are created using the <b>new</b> keyword and calling the list's constructor. The following example demonstrates this &minus;</p>
<pre class="prettyprint notranslate tryit">
(* Creating a List *)
open System.Collections.Generic

let booksList = new List&lt;string&gt;()
booksList.Add("Gone with the Wind")
booksList.Add("Atlas Shrugged")
booksList.Add("Fountainhead")
booksList.Add("Thornbirds")
booksList.Add("Rebecca")
booksList.Add("Narnia")

booksList |> Seq.iteri (fun index item -&gt; printfn "%i: %s" index booksList.[index])
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
0: Gone with the Wind
1: Atlas Shrugged
2: Fountainhead
3: Thornbirds
4: Rebecca
5: Narnia
</pre>
<h2>The List(T) Class</h2>
<p>The List(T) class represents a strongly typed list of objects that can be accessed by index. It provide methods to search, sort, and manipulate lists.</p>
<p>The following tables provide the properties, constructors and the methods of the List(T) class &minus;</p>
<h3>Properties</h3>
<table class="table table-bordered">
<tr>
<th>Property</th>
<th>Description</th>
</tr>
<tr>
<td>Capacity</td>
<td>Gets or sets the total number of elements the internal data structure can hold without resizing.</td>
</tr>
<tr>
<td>Count</td>
<td>Gets the number of elements contained in the List(T).</td>
</tr>
<tr>
<td>Item</td>
<td>Gets or sets the element at the specified index.</td>
</tr>
</table>
<h3>Constructors</h3>
<table class="table table-bordered">
<tr>
<th style="width:30%;">Constructor</th>
<th>Description</th>
</tr>
<tr>
<td>List(T)()</td>
<td>Initializes a new instance of the List(T) class that is empty and has the default initial capacity.</td>
</tr>
<tr>
<td>List(T)(IEnumerable(T))</td>
<td>Initializes a new instance of the List(T) class that contains elements copied from the specified collection and has sufficient capacity to accommodate the number of elements copied.</td>
</tr>
<tr>
<td>List(T)(Int32)</td>
<td>Initializes a new instance of the List(T) class that is empty and has the specified initial capacity.</td>
</tr>
</table>
<h3>Method</h3>
<table class="table table-bordered">
<tr>
<th style="width:45%;">Methods</th>
<th>Description</th>
</tr>
<tr>
<td>Add</td>
<td>Adds an object to the end of the List(T).</td>
</tr>
<tr>
<td>AddRange</td>
<td>Adds the elements of the specified collection to the end of the List(T).</td>
</tr>
<tr>
<td>AsReadOnly</td>
<td>Returns a read-only IList(T) wrapper for the current collection.</td>
</tr>
<tr>
<td>BinarySearch(T)</td>
<td>Searches the entire sorted List(T) for an element using the default comparer and returns the zero-based index of the element.</td>
</tr>
<tr>
<td>BinarySearch(T, IComparer(T))</td>
<td>Searches the entire sorted List(T) for an element using the specified comparer and returns the zero-based index of the element.</td>
</tr>
<tr>
<td>BinarySearch(Int32, Int32, T, IComparer(T))</td>
<td>Searches a range of elements in the sorted List(T) for an element using the specified comparer and returns the zero-based index of the element.</td>
</tr>
<tr>
<td>Clear</td>
<td>Removes all elements from the List(T).</td>
</tr>
<tr>
<td>Contains</td>
<td>Determines whether an element is in the List(T).</td>
</tr>
<tr>
<td>ConvertAll(TOutput)</td>
<td>Converts the elements in the current List(T) to another type, and returns a list containing the converted elements.</td>
</tr>
<tr>
<td>CopyTo(T[])</td>
<td>Copies the entire List(T) to a compatible one-dimensional array, starting at the beginning of the target array.</td>
</tr>
<tr>
<td>CopyTo(T[], Int32)</td>
<td>Copies the entire List(T) to a compatible one-dimensional array, starting at the specified index of the target array.</td>
</tr>
<tr>
<td>CopyTo(Int32, T[], Int32, Int32)</td>
<td>Copies a range of elements from the List(T) to a compatible one-dimensional array, starting at the specified index of the target array.</td>
</tr>
<tr>
<td>Equals(Object)</td>
<td>Determines whether the specified object is equal to the current object. (Inherited from Object.)</td>
</tr>
<tr>
<td>Exists</td>
<td>Determines whether the List(T) contains elements that match the conditions defined by the specified predicate.</td>
</tr>
<tr>
<td>Finalize</td>
<td>Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection (Inherited from Object).</td>
</tr>
<tr>
<td>Find</td>
<td>Searches for an element that matches the conditions defined by the specified predicate, and returns the first occurrence within the entire List(T).</td>
</tr>
<tr>
<td>FindAll</td>
<td>Retrieves all the elements that match the conditions defined by the specified predicate.</td>
</tr>
<tr>
<td>FindIndex(Predicate(T))</td>
<td>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the entire List(T).</td>
</tr>
<tr>
<td>FindIndex(Int32, Predicate(T))</td>
<td>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the range of elements in the List(T) that extends from the specified index to the last element.</td>
</tr>
<tr>
<td>FindIndex(Int32, Int32, Predicate(T))</td>
<td>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the range of elements in the List(T) that starts at the specified index and contains the specified number of elements.</td>
</tr>
<tr>
<td>FindLast</td>
<td>Searches for an element that matches the conditions defined by the specified predicate, and returns the last occurrence within the entire List(T).</td>
</tr>
<tr>
<td>FindLastIndex(Predicate(T))</td>
<td>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the entire List(T).</td>
</tr>
<tr>
<td>FindLastIndex(Int32, Predicate(T))</td>
<td>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the range of elements in the List(T) that extends from the first element to the specified index.</td>
</tr>
<tr>
<td>FindLastIndex(Int32, Int32, Predicate(T))</td>
<td>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the range of elements in the List(T) that contains the specified number of elements and ends at the specified index.</td>
</tr>
<tr>
<td>ForEach</td>
<td>Performs the specified action on each element of the List(T).</td>
</tr>
<tr>
<td>GetEnumerator</td>
<td>Returns an enumerator that iterates through the List(T).</td>
</tr>
<tr>
<td>GetHashCode</td>
<td>Serves as the default hash function. (Inherited from Object.)</td>
</tr>
<tr>
<td>GetRange</td>
<td>Creates a shallow copy of a range of elements in the source List(T).</td>
</tr>
<tr>
<td>GetType</td>
<td>Gets the Type of the current instance. (Inherited from Object.)</td>
</tr>
<tr>
<td>IndexOf(T)</td>
<td>Searches for the specified object and returns the zero-based index of the first occurrence within the entire List(T).</td>
</tr>
<tr>
<td>IndexOf(T, Int32)</td>
<td>Searches for the specified object and returns the zero-based index of the first occurrence within the range of elements in the List(T) that extends from the specified index to the last element.</td>
</tr>
<tr>
<td>IndexOf(T, Int32, Int32)</td>
<td>Searches for the specified object and returns the zero-based index of the first occurrence within the range of elements in the List(T) that starts at the specified index and contains the specified number of elements.</td>
</tr>
<tr>
<td>Insert</td>
<td>Inserts an element into the List(T) at the specified index.</td>
</tr>
<tr>
<td>InsertRange</td>
<td>Inserts the elements of a collection into the List(T) at the specified index.</td>
</tr>
<tr>
<td>LastIndexOf(T)</td>
<td>Searches for the specified object and returns the zero-based index of the last occurrence within the entire List(T).</td>
</tr>
<tr>
<td>LastIndexOf(T, Int32)</td>
<td>Searches for the specified object and returns the zero-based index of the last occurrence within the range of elements in the List(T) that extends from the first element to the specified index.</td>
</tr>
<tr>
<td>LastIndexOf(T, Int32, Int32)</td>
<td>Searches for the specified object and returns the zero-based index of the last occurrence within the range of elements in the List(T) that contains the specified number of elements and ends at the specified index.</td>
</tr>
<tr>
<td>MemberwiseClone</td>
<td>Creates a shallow copy of the current Object. (Inherited from Object.)</td>
</tr>
<tr>
<td>Remove</td>
<td>Removes the first occurrence of a specific object from the List(T).</td>
</tr>
<tr>
<td>RemoveAll</td>
<td>Removes all the elements that match the conditions defined by the specified predicate.</td>
</tr>
<tr>
<td>RemoveAt</td>
<td>Removes the element at the specified index of the List(T).</td>
</tr>
<tr>
<td>RemoveRange</td>
<td>Removes a range of elements from the List(T).</td>
</tr>
<tr>
<td>Reverse()</td>
<td>Reverses the order of the elements in the entire List(T).</td>
</tr>
<tr>
<td>Reverse(Int32, Int32)</td>
<td>Reverses the order of the elements in the specified range.</td>
</tr>
<tr>
<td>Sort()</td>
<td>Sorts the elements in the entire List(T) using the default comparer.</td>
</tr>
<tr>
<td>Sort(Comparison(T))</td>
<td>Sorts the elements in the entire List(T) using the specified System. Comparison(T).</td>
</tr>
<tr>
<td>Sort(IComparer(T))</td>
<td>Sorts the elements in the entire List(T) using the specified comparer.</td>
</tr>
<tr>
<td>Sort(Int32, Int32, IComparer(T))</td>
<td>Sorts the elements in a range of elements in List(T) using the specified comparer.</td>
</tr>
<tr>
<td>ToArray</td>
<td>Copies the elements of the List(T) to a new array.</td>
</tr>
<tr>
<td>ToString</td>
<td>Returns a string that represents the current object. (Inherited from Object.)</td>
</tr>
<tr>
<td>TrimExcess</td>
<td>Sets the capacity to the actual number of elements in the List(T), if that number is less than a threshold value.</td>
</tr>
<tr>
<td>TrueForAll</td>
<td>Determines whether every element in the List(T) matches the conditions defined by the specified predicate.</td>
</tr>
</table>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
(* Creating a List *)
open System.Collections.Generic

let booksList = new List&lt;string&gt;()
booksList.Add("Gone with the Wind")
booksList.Add("Atlas Shrugged")
booksList.Add("Fountainhead")
booksList.Add("Thornbirds")
booksList.Add("Rebecca")
booksList.Add("Narnia")

printfn"Total %d books" booksList.Count
booksList |> Seq.iteri (fun index item -&gt; printfn "%i: %s" index booksList.[index])
booksList.Insert(2, "Roots")

printfn("after inserting at index 2")
printfn"Total %d books" booksList.Count

booksList |> Seq.iteri (fun index item -&gt; printfn "%i: %s" index booksList.[index])
booksList.RemoveAt(3)

printfn("after removing from index 3")
printfn"Total %d books" booksList.Count

booksList |> Seq.iteri (fun index item -&gt; printfn "%i: %s" index booksList.[index])
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Total 6 books
0: Gone with the Wind
1: Atlas Shrugged
2: Fountainhead
3: Thornbirds
4: Rebecca
5: Narnia
after inserting at index 2
Total 7 books
0: Gone with the Wind
1: Atlas Shrugged
2: Roots
3: Fountainhead
4: Thornbirds
5: Rebecca
6: Narnia
after removing from index 3
Total 6 books
0: Gone with the Wind
1: Atlas Shrugged
2: Roots
3: Thornbirds
4: Rebecca
5: Narnia
</pre>
<h1>F# - Mutable Dictionary</h1>
<p>The <b>Dictionary&lt;'TKey, 'TValue&gt;</b> class is the mutable analog of the F# map data structure and contains many of the same functions.</p>
<p>Recapitulating from the Map chapter in F#, a map is a special kind of set that associates the values with key.</p>
<h2>Creating of a Mutable Dictionary</h2>
<p>Mutable dictionaries are created using the <b>new</b> keyword and calling the list's constructor. The following example demonstrates this &minus;</p>
<pre class="prettyprint notranslate tryit">
open System.Collections.Generic
let dict = new Dictionary&lt;string, string&gt;()
dict.Add("1501", "Zara Ali")
dict.Add("1502","Rishita Gupta")
dict.Add("1503","Robin Sahoo")
dict.Add("1504","Gillian Megan")
printfn "Dictionary - students: %A" dict
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Dictionary - students: seq
[[1501, Zara Ali]; [1502, Rishita Gupta]; [1503, Robin Sahoo];
[1504, Gillian Megan]]
</pre>
<h2>The Dictionary(TKey,TValue) Class</h2>
<p>The Dictionary(TKey, TValue) Class represents a collection of keys and values.</p>
<p>The following tables provide the properties, constructors and the methods of the List(T) class &minus;</p>
<h3>Properties</h3>
<table class="table table-bordered">
<tr>
<th>Property</th>
<th>Description</th>
</tr>
<tr>
<td>Comparer</td>
<td>Gets the IEqualityComparer(T) that is used to determine equality of keys for the dictionary.</td>
</tr>
<tr>
<td>Count</td>
<td>Gets the number of key/value pairs contained in the Dictionary(TKey, TValue).</td>
</tr>
<tr>
<td>Item</td>
<td>Gets or sets the value associated with the specified key.</td>
</tr>
<tr>
<td>Keys</td>
<td>Gets a collection containing the keys in the Dictionary(TKey, TValue).</td>
</tr>
<tr>
<td>Values</td>
<td>Gets a collection containing the values in the Dictionary(TKey, TValue).</td>
</tr>
</table>
<h3>Constructors</h3>
<table class="table table-bordered">
<tr>
<th>Constructors</th>
<th>Description</th>
</tr>
<tr>
<td>Dictionary(TKey, TValue)()</td>
<td>Initializes a new instance of the <b>Dictionary(TKey, TValue)</b> class that is empty, has the default initial capacity, and uses the default equality comparer for the key type.</td>
</tr>
<tr>
<td>Dictionary(TKey, TValue)(IDictionary(TKey, TValue))</td>
<td>Initializes a new instance of the <b>Dictionary(TKey, TValue)</b> class that contains elements copied from the specified <b>IDictionary(TKey, TValue)</b> and uses the default equality comparer for the key type.</td>
</tr>
<tr>
<td>Dictionary(TKey, TValue)(IEqualityComparer(TKey))</td>
<td>Initializes a new instance of the <b>Dictionary(TKey, TValue)</b> class that is empty, has the default initial capacity, and uses the specified <b>IEqualityComparer(T).</b></td>
</tr>
<tr>
<td>Dictionary(TKey, TValue)(Int32)</td>
<td>Initializes a new instance of the <b>Dictionary(TKey, TValue)</b> class that is empty, has the specified initial capacity, and uses the default equality comparer for the key type.</td>
</tr>
<tr>
<td>Dictionary(TKey, TValue)(IDictionary(TKey, TValue), IEqualityComparer(TKey))</td>
<td>Initializes a new instance of the <b>Dictionary(TKey, TValue)</b> class that contains elements copied from the specified <b>IDictionary(TKey, TValue)</b> and uses the specified <b>IEqualityComparer(T).</b></td>
</tr>
<tr>
<td>Dictionary(TKey, TValue)(Int32, IEqualityComparer(TKey))</td>
<td>Initializes a new instance of the <b>Dictionary(TKey, TValue)</b> class that is empty, has the specified initial capacity, and uses the specified <b>IEqualityComparer(T).</b></td>
</tr>
<tr>
<td>Dictionary(TKey, TValue)(SerializationInfo, StreamingContext)</td>
<td>Initializes a new instance of the <b>ictionary(TKey, TValue)</b> class with serialized data.</td>
</tr>
</table>
<h3>Methods</h3>
<table class="table table-bordered">
<tr>
<th>Method</th>
<th>Description</th>
</tr>
<tr>
<td>Add</td>
<td>Adds the specified key and value to the dictionary.</td>
</tr>
<tr>
<td>Clear</td>
<td>Removes all keys and values from the Dictionary(TKey, TValue).</td>
</tr>
<tr>
<td>ContainsKey</td>
<td>Determines whether the Dictionary(TKey, TValue) contains the specified key.</td>
</tr>
<tr>
<td>ContainsValue</td>
<td>Determines whether the Dictionary(TKey, TValue) contains a specific value.</td>
</tr>
<tr>
<td>Equals(Object)</td>
<td>Determines whether the specified object is equal to the current object. (Inherited from Object.)</td>
</tr>
<tr>
<td>Finalize</td>
<td>Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection. (Inherited from Object.)</td>
</tr>
<tr>
<td>GetEnumerator</td>
<td>Returns an enumerator that iterates through the Dictionary(TKey, TValue).</td>
</tr>
<tr>
<td>GetHashCode</td>
<td>Serves as the default hash function. (Inherited from Object.)</td>
</tr>
<tr>
<td>GetObjectData</td>
<td>Implements the System.Runtime.Serialization.ISerializable interface and returns the data needed to serialize the Dictionary(TKey, TValue)instance.</td>
</tr>
<tr>
<td>GetType</td>
<td>Gets the Type of the current instance. (Inherited from Object.)</td>
</tr>
<tr>
<td>MemberwiseClone</td>
<td>Creates a shallow copy of the current Object. (Inherited from Object.)</td>
</tr>
<tr>
<td>OnDeserialization</td>
<td>Implements the System.Runtime.Serialization.ISerializable interface and raises the deserialization event when the deserialization is complete.</td>
</tr>
<tr>
<td>Remove</td>
<td>Removes the value with the specified key from the Dictionary(TKey, TValue).</td>
</tr>
<tr>
<td>ToString</td>
<td>Returns a string that represents the current object. (Inherited from Object.)</td>
</tr>
<tr>
<td>TryGetValue</td>
<td>Gets the value associated with the specified key.</td>
</tr>
</table>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
open System.Collections.Generic
let dict = new Dictionary&lt;string, string&gt;()

dict.Add("1501", "Zara Ali")
dict.Add("1502","Rishita Gupta")
dict.Add("1503","Robin Sahoo")
dict.Add("1504","Gillian Megan")

printfn "Dictionary - students: %A" dict
printfn "Total Number of Students: %d" dict.Count
printfn "The keys: %A" dict.Keys
printf"The Values: %A" dict.Values
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Dictionary - students: seq
[[1501, Zara Ali]; [1502, Rishita Gupta]; [1503, Robin Sahoo];
[1504, Gillian Megan]]
Total Number of Students: 4
The keys: seq ["1501"; "1502"; "1503"; "1504"]
The Values: seq ["Zara Ali"; "Rishita Gupta"; "Robin Sahoo"; "Gillian Megan"]
</pre>
<h1>F# - Basic IO</h1>
<p>Basic Input Output includes &minus;</p>
<ul class="list">
<li>Reading from and writing into console.</li>
<li>Reading from and writing into file.</li>
</ul>
<h2>Core.Printf Module</h2>
<p>We have used the <i>printf</i> and the <i>printfn</i> functions for writing into the console. In this section, we will look into the details of the <b>Printf</b> module of F#.</p>
<p>Apart from the above functions, the <i>Core.Printf</i> module of F# has various other methods for printing and formatting using % markers as placeholders. The following table shows the methods with brief description &minus;</p>
<table class="table table-bordered">
<tr>
<th style="width:50%;">Value</th>
<th>Description</th>
</tr>
<tr>
<td>bprintf : StringBuilder &rarr; BuilderFormat&lt;'T&gt; &rarr; 'T</td>
<td>Prints to a StringBuilder.</td>
</tr>
<tr>
<td>eprintf : TextWriterFormat&lt;'T&gt; &rarr; 'T</td>
<td>Prints formatted output to stderr.</td>
</tr>
<tr>
<td>eprintfn : TextWriterFormat&lt;'T&gt; &rarr; 'T</td>
<td>Prints formatted output to stderr, adding a newline.</td>
</tr>
<tr>
<td>failwithf : StringFormat&lt;'T,'Result&gt; &rarr; 'T</td>
<td>Prints to a string buffer and raises an exception with the given result.</td>
</tr>
<tr>
<td>fprintf : TextWriter &rarr; TextWriterFormat&lt;'T&gt; &rarr; 'T</td>
<td>Prints to a text writer.</td>
</tr>
<tr>
<td>fprintfn : TextWriter &rarr; TextWriterFormat&lt;'T&gt; &rarr; 'T</td>
<td>Prints to a text writer, adding a newline.</td>
</tr>
<tr>
<td>kbprintf : (unit &rarr; 'Result) &rarr; StringBuilder &rarr; BuilderFormat&lt;'T,'Result&gt; &rarr; 'T</td>
<td>Like bprintf, but calls the specified function to generate the result.</td>
</tr>
<tr>
<td>kfprintf : (unit &rarr; 'Result) &rarr; TextWriter &rarr; TextWriterFormat&lt;'T,'Result&gt; &rarr; 'T</td>
<td>Like fprintf, but calls the specified function to generate the result.</td>
</tr>
<tr>
<td>kprintf : (string &rarr; 'Result) &rarr; StringFormat&lt;'T,'Result&gt; &rarr; 'T</td>
<td>Like printf, but calls the specified function to generate the result. For example, these let the printing force a flush after all output has been entered onto the channel, but not before.</td>
</tr>
<tr>
<td>ksprintf : (string &rarr; 'Result) &rarr; StringFormat&lt;'T,'Result&gt; &rarr; 'T</td>
<td>Like sprintf, but calls the specified function to generate the result.</td>
</tr>
<tr>
<td>printf : TextWriterFormat&lt;'T&gt; &rarr; 'T</td>
<td>Prints formatted output to stdout.</td>
</tr>
<tr>
<td>printfn : TextWriterFormat&lt;'T&gt; &rarr; 'T</td>
<td>Prints formatted output to stdout, adding a newline.</td>
</tr>
<tr>
<td>sprintf : StringFormat&lt;'T&gt; &rarr; 'T</td>
<td>Prints to a string by using an internal string buffer and returns the result as a string.</td>
</tr>
</table>
<h2>Format Specifications</h2>
<p>Format specifications are used for formatting the input or output, according to the programmers’ need.</p>
<p>These are strings with % markers indicating format placeholders.</p>
<p>The syntax of a Format placeholders is &minus;</p>
<pre class="result notranslate">
%[flags][width][.precision][type]
</pre>
<p>The <b>type</b> is interpreted as &minus;</p>
<table class="table table-bordered">
<tr>
<th style="width:28%;">Type</th>
<th>Description</th>
</tr>
<tr>
<td>%b</td>
<td>Formats a <b>bool,</b> formatted as <b>true</b> or <b>false</b>.</td>
</tr>
<tr>
<td>%c</td>
<td>Formats a character.</td>
</tr>
<tr>
<td>%s</td>
<td>Formats a <b>string,</b> formatted as its contents, without interpreting any escape characters.</td>
</tr>
<tr>
<td>%d, %i</td>
<td>Formats any basic integer type formatted as a decimal integer, signed if the basic integer type is signed.</td>
</tr>
<tr>
<td>%u</td>
<td>Formats any basic integer type formatted as an unsigned decimal integer.</td>
</tr>
<tr>
<td>%x</td>
<td>Formats any basic integer type formatted as an unsigned hexadecimal integer, using lowercase letters a through f.</td>
</tr>
<tr>
<td>%X</td>
<td>Formats any basic integer type formatted as an unsigned hexadecimal integer, using uppercase letters A through F.</td>
</tr>
<tr>
<td>%o</td>
<td>Formats any basic integer type formatted as an unsigned octal integer.</td>
</tr>
<tr>
<td>%e, %E, %f, %F, %g, %G</td>
<td>Formats any basic floating point type <b>(float, float32)</b> formatted using a C-style floating point format specifications.</td>
</tr>
<tr>
<td>%e, %E</td>
<td>Formats a signed value having the form [-]d.dddde[sign]ddd where d is a single decimal digit, dddd is one or more decimal digits, ddd is exactly three decimal digits, and sign is + or -.</td>
</tr>
<tr>
<td>%f</td>
<td>Formats a signed value having the form [-]dddd.dddd, where dddd is one or more decimal digits. The number of digits before the decimal point depends on the magnitude of the number, and the number of digits after the decimal point depends on the requested precision.</td>
</tr>
<tr>
<td>%g, %G</td>
<td>Formats a signed value printed in f or e format, whichever is more compact for the given value and precision.</td>
</tr>
<tr>
<td>%M</td>
<td>Formats a Decimal value.</td>
</tr>
<tr>
<td>%O</td>
<td>Formats any value, printed by boxing the object and using its <b>ToString</b> method.</td>
</tr>
<tr>
<td>%A, %+A</td>
<td>Formats any value, printed with the default layout settings. Use %+A to print the structure of discriminated unions with internal and private representations.</td>
</tr>
<tr>
<td>%a</td>
<td><p>A general format specifier, requires two arguments. The first argument is a function which accepts two arguments: first, a context parameter of the appropriate type for the given formatting function (for example, a TextWriter), and second, a value to print and which either outputs or returns appropriate text.</p>
<p>The second argument is the particular value to print.</p></td>
</tr>
<tr>
<td>%t</td>
<td>A general format specifier, requires one argument: a function which accepts a context parameter of the appropriate type for the given formatting function (aTextWriter) and which either outputs or returns appropriate text. Basic integer types are <b>byte, sbyte, int16, uint16, int32, uint32, int64, uint64, nativeint,</b> and <b>unativeint.</b> Basic floating point types are <b>float</b> and <b>float32.</b></td>
</tr>
</table>
<p>The <b>width</b> is an optional parameter. It is an integer that indicates the minimal width of the result. For example, %5d prints an integer with at least spaces of 5 characters.</p>
<p>Valid <b>flags</b> are described in the following table &minus;</p>
<table class="table table-bordered">
<tr>
<th>Value</th>
<th>Description</th>
</tr>
<tr>
<td>0</td>
<td>Specifies to add zeros instead of spaces to make up the required width.</td>
</tr>
<tr>
<td>-</td>
<td>Specifies to left-justify the result within the width specified.</td>
</tr>
<tr>
<td>+</td>
<td>Specifies to add a + character if the number is positive (to match a - sign for negative numbers).</td>
</tr>
<tr>
<td>' ' (space)</td>
<td>Specifies to add an extra space if the number is positive (to match a - sign for negative numbers).</td>
</tr>
<tr>
<td>#</td>
<td>Invalid.</td>
</tr>
</table>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
printf "Hello "
printf "World"
printfn ""
printfn "Hello "
printfn "World"
printf "Hi, I'm %s and I'm a %s" "Rohit" "Medical Student"

printfn "d: %f" 212.098f
printfn "e: %f" 504.768f

printfn "x: %g" 212.098f
printfn "y: %g" 504.768f

printfn "x: %e" 212.098f
printfn "y: %e" 504.768f
printfn "True: %b" true
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Hello World
Hello
World
Hi, I'm Rohit and I'm a Medical Studentd: 212.098000
e: 504.768000
x: 212.098
y: 504.768
x: 2.120980e+002
y: 5.047680e+002
True: true
</pre>
<h2>The Console Class</h2>
<p>This class is a part of the .NET framework. It represents the standard input, output, and error streams for console applications.</p>
<p>It provides various methods for reading from and writing into the console. The following table shows the methods &minus;</p>
<table class="table table-bordered">
<tr>
<th>Method</th>
<th>Description</th>
</tr>
<tr>
<td>Beep()</td>
<td>Plays the sound of a beep through the console speaker.</td>
</tr>
<tr>
<td>Beep(Int32, Int32)</td>
<td>Plays the sound of a beep of a specified frequency and duration through the console speaker.</td>
</tr>
<tr>
<td>Clear</td>
<td>Clears the console buffer and corresponding console window of display information.</td>
</tr>
<tr>
<td>MoveBufferArea(Int32, Int32, Int32, Int32, Int32, Int32)</td>
<td>Copies a specified source area of the screen buffer to a specified destination area.</td>
</tr>
<tr>
<td>MoveBufferArea(Int32, Int32, Int32, Int32, Int32, Int32, Char, ConsoleColor, ConsoleColor)</td>
<td>Copies a specified source area of the screen buffer to a specified destination area.</td>
</tr>
<tr>
<td>OpenStandardError()</td>
<td>Acquires the standard error stream.</td>
</tr>
<tr>
<td>OpenStandardError(Int32)</td>
<td>Acquires the standard error stream, which is set to a specified buffer size.</td>
</tr>
<tr>
<td>OpenStandardInput()</td>
<td>Acquires the standard input stream.</td>
</tr>
<tr>
<td>OpenStandardInput(Int32)</td>
<td>Acquires the standard input stream, which is set to a specified buffer size.</td>
</tr>
<tr>
<td>OpenStandardOutput()</td>
<td>Acquires the standard output stream.</td>
</tr>
<tr>
<td>OpenStandardOutput(Int32)</td>
<td>Acquires the standard output stream, which is set to a specified buffer size.</td>
</tr>
<tr>
<td>Read</td>
<td>Reads the next character from the standard input stream.</td>
</tr>
<tr>
<td>ReadKey()</td>
<td>Obtains the next character or function key pressed by the user. The pressed key is displayed in the console window.</td>
</tr>
<tr>
<td>ReadKey(Boolean)</td>
<td>Obtains the next character or function key pressed by the user. The pressed key is optionally displayed in the console window.</td>
</tr>
<tr>
<td>ReadLine</td>
<td>Reads the next line of characters from the standard input stream.</td>
</tr>
<tr>
<td>ResetColor</td>
<td>Sets the foreground and background console colors to their defaults.</td>
</tr>
<tr>
<td>SetBufferSize</td>
<td>Sets the height and width of the screen buffer area to the specified values.</td>
</tr>
<tr>
<td>SetCursorPosition</td>
<td>Sets the position of the cursor.</td>
</tr>
<tr>
<td>SetError</td>
<td>Sets the Error property to the specified <a rel="nofollow" target="_blank" href="http://msdn.microsoft.com/en-us/library/system.io.textwriter.aspx">TextWriter</a> object.</td>
</tr>
<tr>
<td>SetIn</td>
<td>Sets the In property to the specified <a rel="nofollow" target="_blank" href="http://msdn.microsoft.com/en-us/library/system.io.textreader.aspx">TextReader</a> object.</td>
</tr>
<tr>
<td>SetOut</td>
<td>Sets the Out property to the specified <a rel="nofollow" target="_blank" href="http://msdn.microsoft.com/en-us/library/system.io.textwriter.aspx">TextWriter</a> object.</td>
</tr>
<tr>
<td>SetWindowPosition</td>
<td>Sets the position of the console window relative to the screen buffer.</td>
</tr>
<tr>
<td>SetWindowSize</td>
<td>Sets the height and width of the console window to the specified values.</td>
</tr>
<tr>
<td>Write(Boolean)</td>
<td>Writes the text representation of the specified Boolean value to the standard output stream.</td>
</tr>
<tr>
<td>Write(Char)</td>
<td>Writes the specified Unicode character value to the standard output stream.</td>
</tr>
<tr>
<td>Write(Char[])</td>
<td>Writes the specified array of Unicode characters to the standard output stream.</td>
</tr>
<tr>
<td>Write(Decimal)</td>
<td>Writes the text representation of the specified Decimal value to the standard output stream.</td>
</tr>
<tr>
<td>Write(Double)</td>
<td>Writes the text representation of the specified double-precision floating-point value to the standard output stream.</td>
</tr>
<tr>
<td>Write(Int32)</td>
<td>Writes the text representation of the specified 32-bit signed integer value to the standard output stream.</td>
</tr>
<tr>
<td>Write(Int64)</td>
<td>Writes the text representation of the specified 64-bit signed integer value to the standard output stream.</td>
</tr>
<tr>
<td>Write(Object)</td>
<td>Writes the text representation of the specified object to the standard output stream.</td>
</tr>
<tr>
<td>Write(Single)</td>
<td>Writes the text representation of the specified single-precision floating-point value to the standard output stream.</td>
</tr>
<tr>
<td>Write(String)</td>
<td>Writes the specified string value to the standard output stream.</td>
</tr>
<tr>
<td>Write(UInt32)</td>
<td>Writes the text representation of the specified 32-bit unsigned integer value to the standard output stream.</td>
</tr>
<tr>
<td>Write(UInt64)</td>
<td>Writes the text representation of the specified 64-bit unsigned integer value to the standard output stream.</td>
</tr>
<tr>
<td>Write(String, Object)</td>
<td>Writes the text representation of the specified object to the standard output stream using the specified format information.</td>
</tr>
<tr>
<td>Write(String, Object[])</td>
<td>Writes the text representation of the specified array of objects to the standard output stream using the specified format information.</td>
</tr>
<tr>
<td>Write(Char[], Int32, Int32)</td>
<td>Writes the specified subarray of Unicode characters to the standard output stream.</td>
</tr>
<tr>
<td>Write(String, Object, Object)</td>
<td>Writes the text representation of the specified objects to the standard output stream using the specified format information.</td>
</tr>
<tr>
<td>Write(String, Object, Object, Object)</td>
<td>Writes the text representation of the specified objects to the standard output stream using the specified format information.</td>
</tr>
<tr>
<td>Write(String, Object, Object, Object, Object)</td>
<td>Writes the text representation of the specified objects and variable-length parameter list to the standard output stream using the specified format information.</td>
</tr>
<tr>
<td>WriteLine()</td>
<td>Writes the current line terminator to the standard output stream.</td>
</tr>
<tr>
<td>WriteLine(Boolean)</td>
<td>Writes the text representation of the specified Boolean value, followed by the current line terminator, to the standard output stream.</td>
</tr>
<tr>
<td>WriteLine(Char)</td>
<td>Writes the specified Unicode character, followed by the current line terminator, value to the standard output stream.</td>
</tr>
<tr>
<td>WriteLine(Char[])</td>
<td>Writes the specified array of Unicode characters, followed by the current line terminator, to the standard output stream.</td>
</tr>
<tr>
<td>WriteLine(Decimal)</td>
<td>Writes the text representation of the specified Decimal value, followed by the current line terminator, to the standard output stream.</td>
</tr>
<tr>
<td>WriteLine(Double)</td>
<td>Writes the text representation of the specified double-precision floating-point value, followed by the current line terminator, to the standard output stream.</td>
</tr>
<tr>
<td>WriteLine(Int32)</td>
<td>Writes the text representation of the specified 32-bit signed integer value, followed by the current line terminator, to the standard output stream.</td>
</tr>
<tr>
<td>WriteLine(Int64)</td>
<td>Writes the text representation of the specified 64-bit signed integer value, followed by the current line terminator, to the standard output stream.</td>
</tr>
<tr>
<td>WriteLine(Object)</td>
<td>Writes the text representation of the specified object, followed by the current line terminator, to the standard output stream.</td>
</tr>
<tr>
<td>WriteLine(Single)</td>
<td>Writes the text representation of the specified single-precision floating-point value, followed by the current line terminator, to the standard output stream.</td>
</tr>
<tr>
<td>WriteLine(String)</td>
<td>Writes the specified string value, followed by the current line terminator, to the standard output stream.</td>
</tr>
<tr>
<td>WriteLine(UInt32)</td>
<td>Writes the text representation of the specified 32-bit unsigned integer value, followed by the current line terminator, to the standard output stream.</td>
</tr>
<tr>
<td>WriteLine(UInt64)</td>
<td>Writes the text representation of the specified 64-bit unsigned integer value, followed by the current line terminator, to the standard output stream.</td>
</tr>
<tr>
<td>WriteLine(String, Object)</td>
<td>Writes the text representation of the specified object, followed by the current line terminator, to the standard output stream using the specified format information.</td>
</tr>
<tr>
<td>WriteLine(String, Object[])</td>
<td>Writes the text representation of the specified array of objects, followed by the current line terminator, to the standard output stream using the specified format information.</td>
</tr>
<tr>
<td>WriteLine(Char[], Int32, Int32)</td>
<td>Writes the specified subarray of Unicode characters, followed by the current line terminator, to the standard output stream.</td>
</tr>
<tr>
<td>WriteLine(String, Object, Object)</td>
<td>Writes the text representation of the specified objects, followed by the current line terminator, to the standard output stream using the specified format information.</td>
</tr>
<tr>
<td>WriteLine(String, Object, Object, Object)</td>
<td>Writes the text representation of the specified objects, followed by the current line terminator, to the standard output stream using the specified format information.</td>
</tr>
<tr>
<td>WriteLine(String, Object, Object, Object, Object)</td>
<td>Writes the text representation of the specified objects and variable-length parameter list, followed by the current line terminator, to the standard output stream using the specified format information.</td>
</tr>
</table>
<p>The following example demonstrates reading from console and writing into it &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
open System
let main() =
   Console.Write("What's your name? ")
   let name = Console.ReadLine()
   Console.Write("Hello, {0}\n", name)
   Console.WriteLine(System.String.Format("Big Greetings from {0} and {1}", "TutorialsPoint", "Absoulte Classes"))
   Console.WriteLine(System.String.Format("|{0:yyyy-MMM-dd}|", System.DateTime.Now))
main()
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
What's your name? Kabir
Hello, Kabir
Big Greetings from TutorialsPoint and Absoulte Classes
|2015-Jan-05|
</pre>
<h2>The System.IO Namespace</h2>
<p>The System.IO namespace contains a variety of useful classes for performing basic I/O.</p>
<p>It contains types or classes that allow reading and writing to files and data streams and types that provide basic file and directory support.</p>
<p>Classes useful for working with the file system &minus;</p>
<ul class="list">
<li>The System.IO.File class is used for creating, appending, and deleting files.</li>
<li>System.IO.Directory class is used for creating, moving, and deleting directories.</li>
<li>System.IO.Path class performs operations on strings, which represent file paths.</li>
<li>System.IO.FileSystemWatcher class allows users to listen to a directory for changes.</li>
</ul>
<p>Classes useful for working with the streams (sequence of bytes) &minus;</p>
<ul class="list">
<li>System.IO.StreamReader class is used to read characters from a stream.</li>
<li>System.IO.StreamWriter class is used to write characters to a stream.</li>
<li>System.IO.MemoryStream class creates an in-memory stream of bytes.</li>
</ul>
<p>The following table shows all the classes provided in the namespace along with a brief description &minus;</p>
<table class="table table-bordered">
<tr>
<th>Class</td>
<th>Description</th>
</tr>
<tr>
<td>BinaryReader</td>
<td>Reads primitive data types as binary values in a specific encoding.</td>
</tr>
<tr>
<td>BinaryWriter</td>
<td>Writes primitive types in binary to a stream and supports writing strings in a specific encoding.</td>
</tr>
<tr>
<td>BufferedStream</td>
<td>Adds a buffering layer to read and write operations on another stream.</td>
</tr>
<tr>
<td>Directory</td>
<td>Exposes static methods for creating, moving, and enumerating through directories and subdirectories.</td>
</tr>
<tr>
<td>DirectoryInfo</td>
<td>Exposes instance methods for creating, moving, and enumerating through directories and subdirectories.</td>
</tr>
<tr>
<td>DirectoryNotFoundException</td>
<td>The exception that is thrown when part of a file or directory cannot be found.</td>
</tr>
<tr>
<td>DriveInfo</td>
<td>Provides access to information on a drive.</td>
</tr>
<tr>
<td>DriveNotFoundException</td>
<td>The exception that is thrown when trying to access a drive or share that is not available.</td>
</tr>
<tr>
<td>EndOfStreamException</td>
<td>The exception that is thrown when reading is attempted past the end of a stream.</td>
</tr>
<tr>
<td>ErrorEventArgs</td>
<td>Provides data for the FileSystemWatcher.Error event.</td>
</tr>
<tr>
<td>File</td>
<td>Provides static methods for the creation, copying, deletion, moving, and opening of a single file, and aids in the creation of FileStream objects.</td>
</tr>
<tr>
<td>FileFormatException</td>
<td>The exception that is thrown when an input file or a data stream that is supposed to conform to a certain file format specification is malformed.</td>
</tr>
<tr>
<td>FileInfo</td>
<td>Provides properties and instance methods for the creation, copying, deletion, moving, and opening of files, and aids in the creation of FileStream objects.</td>
</tr>
<tr>
<td>FileLoadException</td>
<td>The exception that is thrown when a managed assembly is found but cannot be loaded.</td>
</tr>
<tr>
<td>FileNotFoundException</td>
<td>The exception that is thrown when an attempt to access a file that does not exist on disk fails.</td>
</tr>
<tr>
<td>FileStream</td>
<td>Exposes a Stream around a file, supporting both synchronous and asynchronous read and write operations.</td>
</tr>
<tr>
<td>FileSystemEventArgs</td>
<td>Provides data for the directory events &minus; Changed, Created, Deleted.</td>
</tr>
<tr>
<td>FileSystemInfo</td>
<td>Provides the base class for both FileInfo and DirectoryInfo objects.</td>
</tr>
<tr>
<td>FileSystemWatcher</td>
<td>Listens to the file system change notifications and raises events when a directory, or file in a directory, changes.</td>
</tr>
<tr>
<td>InternalBufferOverflowException</td>
<td>The exception thrown when the internal buffer overflows.</td>
</tr>
<tr>
<td>InvalidDataException</td>
<td>The exception that is thrown when a data stream is in an invalid format.</td>
</tr>
<tr>
<td>IODescriptionAttribute</td>
<td>Sets the description visual designers can display when referencing an event, extender, or property.</td>
</tr>
<tr>
<td>IOException</td>
<td>The exception that is thrown when an I/O error occurs.</td>
</tr>
<tr>
<td>MemoryStream</td>
<td>Creates a stream whose backing store is memory.</td>
</tr>
<tr>
<td>Path</td>
<td>Performs operations on String instances that contain file or directory path information. These operations are performed in a cross-platform manner.</td>
</tr>
<tr>
<td>PathTooLongException</td>
<td>The exception that is thrown when a path or file name is longer than the system-defined maximum length.</td>
</tr>
<tr>
<td>PipeException</td>
<td>Thrown when an error occurs within a named pipe.</td>
</tr>
<tr>
<td>RenamedEventArgs</td>
<td>Provides data for the Renamed event.</td>
</tr>
<tr>
<td>Stream</td>
<td>Provides a generic view of a sequence of bytes. This is an abstract class.</td>
</tr>
<tr>
<td>StreamReader</td>
<td>Implements a TextReader that reads characters from a byte stream in a particular encoding.</td>
</tr>
<tr>
<td>StreamWriter</td>
<td>Implements a TextWriter for writing characters to a stream in a particular encoding. To browse the .NET Framework source code for this type, see the Reference Source.</td>
</tr>
<tr>
<td>StringReader</td>
<td>Implements a TextReader that reads from a string.</td>
</tr>
<tr>
<td>StringWriter</td>
<td>Implements a TextWriter for writing information to a string. The information is stored in an underlying StringBuilder.</td>
</tr>
<tr>
<td>TextReader</td>
<td>Represents a reader that can read a sequential series of characters.</td>
</tr>
<tr>
<td>TextWriter</td>
<td>Represents a writer that can write a sequential series of characters. This class is abstract.</td>
</tr>
<tr>
<td>UnmanagedMemoryAccessor</td>
<td>Provides random access to unmanaged blocks of memory from managed code.</td>
</tr>
<tr>
<td>UnmanagedMemoryStream</td>
<td>Provides access to unmanaged blocks of memory from managed code.</td>
</tr>
<tr>
<td>WindowsRuntimeStorageExtensions</td>
<td>Contains extension methods for the IStorageFile and IStorageFolder interfaces in the Windows Runtime when developing Windows Store apps.</td>
</tr>
<tr>
<td>WindowsRuntimeStreamExtensions</td>
<td>Contains extension methods for converting between streams in the Windows Runtime and managed streams in the .NET for Windows Store apps.</td>
</tr>
</table>
<h3>Example</h3>
<p>The following example creates a file called test.txt, writes a message there, reads the text from the file and prints it on the console.</p>
<p><b>Note</b> &minus;  The amount of code needed to do this is surprisingly less!</p>
<pre class="prettyprint notranslate tryit">
open System.IO // Name spaces can be opened just as modules
File.WriteAllText("test.txt", "Hello There\n Welcome to:\n Tutorials Point")
let msg = File.ReadAllText("test.txt")
printfn "%s" msg
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Hello There
Welcome to:
Tutorials Point
</pre>
<h1>F# - Generics</h1>
<p>Generics allow you to delay the specification of the data type of programming elements in a class or a method, until it is actually used in the program. In other words, generics allow you to write a class or method that can work with any data type.</p>
<p>You write the specifications for the class or the method, with substitute parameters for data types. When the compiler encounters a constructor for the class or a function call for the method, it generates code to handle the specific data type.</p>
<p>In F#, function values, methods, properties, and aggregate types such as classes, records, and discriminated unions can be generic.</p>
<p>Generic constructs contain at least one type parameter. Generic functions and types enable you to write code that works with a variety of types without repeating the code for each type.</p>
<h2>Syntax</h2>
<p>Syntax for writing a generic construct is as follows &minus;</p>
<pre class="result notranslate">
// Explicitly generic function.
let function-name&lt;type-parameters&gt; parameter-list =
   function-body

// Explicitly generic method.
[ static ] member object-identifer.method-name&lt;type-parameters&gt; parameter-list [ return-type ] =
   method-body

// Explicitly generic class, record, interface, structure,
// or discriminated union.
type type-name&lt;type-parameters&gt; type-definition
</pre>
<h2>Examples</h2>
<pre class="prettyprint notranslate tryit">
(* Generic Function *)
let printFunc<'T> x y =
   printfn "%A, %A" x y

printFunc&lt;float&gt; 10.0 20.0
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
10.0, 20.0
</pre>
<p>You can also make a function generic by using the single quotation mark syntax &minus;</p>
<pre class="prettyprint notranslate tryit">
(* Generic Function *)
let printFunction (x: 'a) (y: 'a) =
   printfn "%A %A" x y

printFunction 10.0 20.0
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
10.0 20.0
</pre>
<p>Please note that when you use generic functions or methods, you might not have to specify the type arguments. However, in case of an ambiguity, you can provide type arguments in angle brackets as we did in the first example.</p>
<p>If you have more than one type, then you separate multiple type arguments with commas.</p>
<h2>Generic Class</h2>
<p>Like generic functions, you can also write generic classes. The following example demonstrates this &minus;</p>
<pre class="prettyprint notranslate tryit">
type genericClass<'a> (x: 'a) =
   do printfn "%A" x

let gr = new genericClass&lt;string&gt;("zara")
let gs = genericClass( seq { for i in 1 .. 10 -> (i, i*i) } )
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
"zara"
seq [(1, 1); (2, 4); (3, 9); (4, 16); ...]
</pre>
<h1>F# - Delegates</h1>
<p>A delegate is a reference type variable that holds the reference to a method. The reference can be changed at runtime. F# delegates are similar to pointers to functions, in C or C++.</p>
<h2>Declaring Delegates</h2>
<p>Delegate declaration determines the methods that can be referenced by the delegate. A delegate can refer to a method, which have the same signature as that of the delegate.</p>
<p>Syntax for delegate declaration is &minus;</p>
<pre class="result notranslate">
type delegate-typename = delegate of type1 -&gt; type2
</pre>
<p>For example, consider the delegates &minus;</p>
<pre class="result notranslate">
// Delegate1 works with tuple arguments.
type Delegate1 = delegate of (int * int) -&gt; int
// Delegate2 works with curried arguments.
type Delegate2 = delegate of int * int -&gt; int
</pre>
<p>Both the delegates can be used to reference any method that has two <i>int</i> parameters and returns an <i>int</i> type variable.</p>
<p>In the syntax &minus;</p>
<ul class="list">
<li><p><b><i>type1</i></b> represents the argument type(s).<p></li>
<li><p><b><i>type2</i></b> represents the return type.<p></li>
</ul>
<p>Please note &minus;</p>
<ul class="list">
<li><p>The argument types are automatically curried.</p></li>
<li><p>Delegates can be attached to function values, and static or instance methods.</p></li>
<li><p>F# function values can be passed directly as arguments to delegate constructors.</p></li>
<li><p>For a static method the delegate is called by using the name of the class and the method. For an instance method, the name of the object instance and method is used.</p></li>
<li><p>The Invoke method on the delegate type calls the encapsulated function.</p></li>
<li><p>Also, delegates can be passed as function values by referencing the Invoke method name without the parentheses.</p></li>
</ul>
<p>The following example demonstrates the concept &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
type Myclass() =
   static member add(a : int, b : int) =
      a + b
   static member sub (a : int) (b : int) =
      a - b
   member x.Add(a : int, b : int) =
      a + b
   member x.Sub(a : int) (b : int) =
      a - b

// Delegate1 works with tuple arguments.
type Delegate1 = delegate of (int * int) -&gt; int
// Delegate2 works with curried arguments.
type Delegate2 = delegate of int * int -&gt; int

let InvokeDelegate1 (dlg : Delegate1) (a : int) (b: int) =
   dlg.Invoke(a, b)
let InvokeDelegate2 (dlg : Delegate2) (a : int) (b: int) =
   dlg.Invoke(a, b)

// For static methods, use the class name, the dot operator, and the
// name of the static method.
let del1 : Delegate1 = new Delegate1( Myclass.add )
let del2 : Delegate2 = new Delegate2( Myclass.sub )

let mc = Myclass()
// For instance methods, use the instance value name, the dot operator, and the instance method name.

let del3 : Delegate1 = new Delegate1( mc.Add )
let del4 : Delegate2 = new Delegate2( mc.Sub )

for (a, b) in [ (400, 200); (100, 45) ] do
   printfn "%d + %d = %d" a b (InvokeDelegate1 del1 a b)
   printfn "%d - %d = %d" a b (InvokeDelegate2 del2 a b)
   printfn "%d + %d = %d" a b (InvokeDelegate1 del3 a b)
   printfn "%d - %d = %d" a b (InvokeDelegate2 del4 a b)
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
400 + 200 = 600
400 - 200 = 200
400 + 200 = 600
400 - 200 = 200
100 + 45 = 145
100 - 45 = 55
100 + 45 = 145
100 - 45 = 55
</pre>
<h1>F# - Enumerations</h1>
<p>An enumeration is a set of named integer constants.</p>
<p>In F#, <b>enumerations,</b> also known as <b>enums,</b> are integral types where labels are assigned to a subset of the values. You can use them in place of literals to make code more readable and maintainable.</p>
<h2>Declaring Enumerations</h2>
<p>The general syntax for declaring an enumeration is &minus;</p>
<pre class="result notranslate">
type enum-name =
   | value1 = integer-literal1
   | value2 = integer-literal2
...
</pre>
<p>The following example demonstrates the use of enumerations &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
// Declaration of an enumeration.
type Days =
   | Sun = 0
   | Mon = 1
   | Tues = 2
   | Wed = 3
   | Thurs = 4
   | Fri = 5
   | Sat = 6

// Use of an enumeration.
let weekend1 : Days = Days.Sat
let weekend2 : Days = Days.Sun
let weekDay1 : Days = Days.Mon

printfn "Monday: %A" weekDay1
printfn "Saturday: %A" weekend1
printfn "Sunday: %A" weekend2
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Monday: Mon
Saturday: Sat
Sunday: Sun
</pre>
<h1>F# - Pattern Matching</h1>
<p>Pattern matching allows you to “compare data with a logical structure or structures, decompose data into constituent parts, or extract information from data in various ways”.</p>
<p>In other terms, it provides a more flexible and powerful way of testing data against a series of conditions and performing some computations based on the condition met.</p>
<p>Conceptually, it is like a series of if… then statements.</p>
<h2>Syntax</h2>
<p>In high level terms, pattern matching follows this syntax in F# &minus;</p>
<pre class="result notranslate">
match expr with
| pat1 - result1
| pat2 -&gt; result2
| pat3 when expr2 -&gt; result3
| _ -&gt; defaultResult
</pre>
<p>Where,</p>
<ul class="list">
<li>Each | symbol defines a condition.</li>
<li>The -&gt; symbol means "if the condition is true, return this value...".</li>
<li>The _ symbol provides the default pattern, meaning that it matches all other things like a wildcard.</li>
</ul>
<h2>Example 1</h2>
<p>The following example, calculates the Fibonacci numbers using pattern matching syntax &minus;</p>
<pre class="prettyprint notranslate tryit">
let rec fib n =
   match n with
   | 0 -&gt; 0
   | 1 -&gt; 1
   | _ -&gt; fib (n - 1) + fib (n - 2)
for i = 1 to 10 do
   printfn "Fibonacci %d: %d" i (fib i)
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Fibonacci 1: 1
Fibonacci 2: 1
Fibonacci 3: 2
Fibonacci 4: 3
Fibonacci 5: 5
Fibonacci 6: 8
Fibonacci 7: 13
Fibonacci 8: 21
Fibonacci 9: 34
Fibonacci 10: 55
</pre>
<p>You can also chain together multiple conditions, which return the same value. For example &minus;</p>
<h2>Example 2</h2>
<pre class="prettyprint notranslate tryit">
let printSeason month =
   match month with
   | "December" | "January" | "February" -&gt; printfn "Winter"
   | "March" | "April" -&gt; printfn "Spring"
   | "May" | "June" -&gt; printfn "Summer"
   | "July" | "August" -&gt; printfn "Rainy"
   | "September" | "October" | "November" -&gt; printfn "Autumn"
   | _ -&gt; printfn "Season depends on month!"

printSeason "February"
printSeason "April"
printSeason "November"
printSeason "July"
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Winter
Spring
Autumn
Rainy
</pre>
<h2>Pattern Matching Functions</h2>
<p>F# allows you to write pattern matching functions using the <b>function</b> keyword &minus;</p>
<pre class="prettyprint notranslate tryit">
let getRate = function
   | "potato" -&gt; 10.00
   | "brinjal" -&gt; 20.50
   | "cauliflower" -&gt; 21.00
   | "cabbage" -&gt; 8.75
   | "carrot" -&gt; 15.00
   | _ -&gt; nan (* nan is a special value meaning "not a number" *)

printfn "%g"(getRate "potato")
printfn "%g"(getRate "brinjal")
printfn "%g"(getRate "cauliflower")
printfn "%g"(getRate "cabbage")
printfn "%g"(getRate "carrot")
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
10
20.5
21
8.75
15
</pre>
<h2>Adding Filters or Guards to Patterns</h2>
<p>You can add filters, or guards, to patterns using the <b>when</b> keyword.</p>
<h3>Example 1</h3>
<pre class="prettyprint notranslate tryit">
let sign = function
   | 0 -&gt; 0
   | x when x &lt; 0 -&gt; -1
   | x when x &gt; 0 -&gt; 1

printfn "%d" (sign -20)
printfn "%d" (sign 20)
printfn "%d" (sign 0)
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
-1
1
0
</pre>
<h3>Example 2</h3>
<pre class="prettyprint notranslate tryit">
let compareInt x =
   match x with
   | (var1, var2) when var1 > var2 -> printfn "%d is greater than %d" var1 var2
   | (var1, var2) when var1 &lt; var2 -&gt; printfn "%d is less than %d" var1 var2
   | (var1, var2) -> printfn "%d equals %d" var1 var2

compareInt (11,25)
compareInt (72, 10)
compareInt (0, 0)
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
11 is less than 25
72 is greater than 10
0 equals 0
</pre>
<h2>Pattern Matching with Tuples</h2>
<p>The following example demonstrates the pattern matching with tuples &minus;</p>
<pre class="prettyprint notranslate tryit">
let greeting (name, subject) =
   match (name, subject) with
   | ("Zara", _) -&gt; "Hello, Zara"
   | (name, "English") -&gt; "Hello, " + name + " from the department of English"
   | (name, _) when subject.StartsWith("Comp") -&gt; "Hello, " + name + " from the department of Computer Sc."
   | (_, "Accounts and Finance") -&gt; "Welcome to the department of Accounts and Finance!"
   | _ -&gt; "You are not registered into the system"

printfn "%s" (greeting ("Zara", "English"))
printfn "%s" (greeting ("Raman", "Computer Science"))
printfn "%s" (greeting ("Ravi", "Mathematics"))
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Hello, Zara
Hello, Raman from the department of Computer Sc.
You are not registered into the system
</pre>
<h2>Pattern Matching with Records</h2>
<p>The following example demonstrates pattern matching with records &minus;</p>
<pre class="prettyprint notranslate tryit">
type Point = { x: float; y: float }
let evaluatePoint (point: Point) =
   match point with
   | { x = 0.0; y = 0.0 } -&gt; printfn "Point is at the origin."
   | { x = xVal; y = 0.0 } -&gt; printfn "Point is on the x-axis. Value is %f." xVal
   | { x = 0.0; y = yVal } -&gt; printfn "Point is on the y-axis. Value is %f." yVal
   | { x = xVal; y = yVal } -&gt; printfn "Point is at (%f, %f)." xVal yVal

evaluatePoint { x = 0.0; y = 0.0 }
evaluatePoint { x = 10.0; y = 0.0 }
evaluatePoint { x = 0.0; y = 10.0 }
evaluatePoint { x = 10.0; y = 10.0 }
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Point is at the origin.
Point is on the x-axis. Value is 10.000000.
Point is on the y-axis. Value is 10.000000.
Point is at (10.000000, 10.000000).
</pre>
<h1>F# - Exception Handling</h1>
<p>An exception is a problem that arises during the execution of a program. An F# exception is a response to an exceptional circumstance that arises while a program is running, such as an attempt to divide by zero.</p>
<p>Exceptions provide a way to transfer control from one part of a program to another. F# exception handling provides the following constructs &minus;</p>
<table class="table table-bordered">
<tr>
<th style="width:35%;">Construct</th>
<th>Description</th>
</tr>
<tr>
<td>raise expr</td>
<td>Raises the given exception.</td>
</tr>
<tr>
<td>failwith expr</td>
<td>Raises the <b>System.Exception</b> exception.</td>
</tr>
<tr>
<td>try expr with rules</td>
<td>Catches expressions matching the pattern rules.</td>
</tr>
<tr>
<td>try expr finally expr</td>
<td>Execution the <b>finally</b> expression both when the computation is successful and when an exception is raised.</td>
</tr>
<tr>
<td>| :? ArgumentException</td>
<td>A rule matching the given .NET exception type.</td>
</tr>
<tr>
<td>| :? ArgumentException as e</td>
<td>A rule matching the given .NET exception type, binding the name <b>e</b> to the exception object value.</td>
</tr>
<tr>
<td>| Failure(msg) &rarr; expr</td>
<td>A rule matching the given data-carrying F# exception.</td>
</tr>
<tr>
<td>| exn &rarr; expr</td>
<td>A rule matching any exception, binding the name <b>exn</b> to the exception object value.</td>
</tr>
<tr>
<td>| exn when expr &rarr; expr</td>
<td>A rule matching the exception under the given condition, binding the name <b>exn</b> to the exception object value.</td>
</tr>
</table>
<p>Let us start with the basic syntax of Exception Handling.</p>
<h2>Syntax</h2>
<p>Basic syntax for F# exception handling block is &minus;</p>
<pre class="result notranslate">
exception exception-type of argument-type
</pre>
<p>Where,</p>
<ul class="list">
<li><p><b>exception-type</b> is the name of a new F# exception type.</p></li>
<li><p><b>argument-type</b> represents the type of an argument that can be supplied when you raise an exception of this type.</p></li>
<li><p>Multiple arguments can be specified by using a tuple type for argument-type.</p></li>
</ul>
<p>The <b>try...with</b> expression is used for exception handling in the F# language.</p>
<p>Syntax for the try … with expression is &minus;</p>
<pre class="result notranslate">
try
   expression1
with
   | pattern1 -&gt; expression2
   | pattern2 -&gt; expression3
...
</pre>
<p>The <b>try...finally</b> expression allows you to execute clean-up code even if a block of code throws an exception.</p>
<p>Syntax for the try … finally expression is &minus;</p>
<pre class="result notranslate">
try
   expression1
finally
   expression2
</pre>
<p>The <b>raise</b> function is used to indicate that an error or exceptional condition has occurred. It also captures the information about the error in an exception object.</p>
<p>Syntax for the raise function is &minus;</p>
<pre class="result notranslate">
raise (expression)
</pre>
<p>The <b>failwith</b> function generates an F# exception.</p>
<p>Syntax for the failwith function is &minus;</p>
<pre class="result notranslate">
failwith error-message-string
</pre>
<p>The <b>invalidArg</b> function generates an argument exception.</p>
<pre class="result notranslate">
invalidArg parameter-name error-message-string
</pre>
<h2>Example of Exception Handling</h2>
<h3>Example 1</h3>
<p>The following program shows the basic exception handling with a simple try… with block &minus;</p>
<pre class="prettyprint notranslate tryit">
let divisionprog x y =
   try
      Some (x / y)
   with
      | :? System.DivideByZeroException -&gt; printfn "Division by zero!"; None

let result1 = divisionprog 100 0
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Division by zero!
</pre>
<h3>Example 2</h3>
<p>F# provides an <b>exception</b> type for declaring exceptions. You can use an exception type directly in the filters in a <b>try...with</b> expression.</p>
<p>The following example demonstrates this &minus;</p>
<pre class="prettyprint notranslate tryit">
exception Error1 of string
// Using a tuple type as the argument type.
exception Error2 of string * int

let myfunction x y =
   try
      if x = y then raise (Error1("Equal Number Error"))
      else raise (Error2("Error Not detected", 100))
   with
      | Error1(str) -&gt; printfn "Error1 %s" str
      | Error2(str, i) -&gt; printfn "Error2 %s %d" str i
myfunction 20 10
myfunction 5 5
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Error2 Error Not detected 100
Error1 Equal Number Error
</pre>
<h3>Example 3</h3>
<p>The following example demonstrates nested exception handling &minus;</p>
<pre class="prettyprint notranslate tryit">
exception InnerError of string
exception OuterError of string

let func1 x y =
   try
      try
         if x = y then raise (InnerError("inner error"))
         else raise (OuterError("outer error"))
      with
         | InnerError(str) -&gt; printfn "Error:%s" str
   finally
      printfn "From the finally block."

let func2 x y =
   try
      func1 x y
   with
      | OuterError(str) -&gt; printfn "Error: %s" str

func2 100 150
func2 100 100
func2 100 120
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
From the finally block.
Error: outer error
Error:inner error
From the finally block.
From the finally block.
Error: outer error
</pre>
<h3>Example 4</h3>
<p>The following function demonstrates the <b>failwith</b> function &minus;</p>
<pre class="prettyprint notranslate tryit">
let divisionFunc x y =
   if (y = 0) then failwith "Divisor cannot be zero."
   else
      x / y

let trydivisionFunc x y =
   try
      divisionFunc x y
   with
      | Failure(msg) -&gt; printfn "%s" msg; 0

let result1 = trydivisionFunc 100 0
let result2 = trydivisionFunc 100 4
printfn "%A" result1
printfn "%A" result2
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Divisor cannot be zero.
0
25
</pre>
<h3>Example 5</h3>
<p>The <b>invalidArg</b> function generates an argument exception. The following program demonstrates this &minus;</p>
<pre class="prettyprint notranslate tryit">
let days = [| "Sunday"; "Monday"; "Tuesday"; "Wednesday"; "Thursday"; "Friday"; "Saturday" |]
let findDay day =
   if (day &gt; 7 || day &lt; 1)
      then invalidArg "day" (sprintf "You have entered %d." day)
   days.[day - 1]

printfn "%s" (findDay 1)
printfn "%s" (findDay 5)
printfn "%s" (findDay 9)
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Sunday
Thursday
Unhandled Exception:
System.ArgumentException: You have entered 9.
…
</pre>
<p>Some other information about the file and variable causing error in the system will also be displayed, depending upon the system.</p>
<h1>F# - Classes</h1>
<p>Classes are types that represent objects that can have properties, methods, and events. ‘They are used to model actions, processes, and any conceptual entities in applications.’</p>
<h2>Syntax</h2>
<p>Syntax for defining a class type is as follows &minus;</p>
<pre class="result notranslate">
// Class definition:
type [access-modifier] type-name [type-params] [access-modifier] ( parameter-list ) [ as identifier ] =
   [ class ]
      [ inherit base-type-name(base-constructor-args) ]
      [ let-bindings ]
      [ do-bindings ]
      member-list
      ...
   [ end ]

// Mutually recursive class definitions:
type [access-modifier] type-name1 ...
and [access-modifier] type-name2 ...
...
</pre>
<p>Where,</p>
<ul class="list">
<li><p>The <b>type-name</b> is any valid identifier. Default access modifier for this is <b>public</b>.</p></li>
<li><p>The <b>type-params</b> describes optional generic type parameters.</p></li>
<li><p>The <b>parameter-list</b> describes constructor parameters. Default access modifier for primary constructor is <b>public</b>.</p></li>
<li><p>The <b>identifier</b> used with the optional <b>as</b> keyword gives a name to the instance variable, or <b>self-identifier,</b> which can be used in the type definition to refer to the instance of the type.</p></li>
<li><p>The <b>inherit</b> keyword allows you to specify the base class for a class.</p></li>
<li><p>The <b>let</b> bindings allow you to declare fields or function values local to the class.</p></li>
<li><p>The <b>do-bindings</b> section includes code to be executed upon object construction.</p></li>
<li><p>The <b>member-list</b> consists of additional constructors, instance and static method declarations, interface declarations, abstract bindings, and property and event declarations.</p></li>
<li><p>The keywords <b>class</b> and <b>end</b> that mark the start and end of the definition are optional.</p></li>
</ul>
<h2>Constructor of a Class</h2>
<p>The constructor is code that creates an instance of the class type.</p>
<p>In F#, constructors work little differently than other .Net languages. In the class definition, the arguments of the primary constructor are described as parameter-list.</p>
<p>The body of the constructor consists of the <b>let</b> and <b>do</b> bindings.</p>
<p>You can add additional constructors by using the new keyword to add a member &minus;</p>
<pre class="result notranslate">
new (argument-list) = constructor-body
</pre>
<p>The following example illustrates the concept &minus;</p>
<h3>Example</h3>
<p>The following program creates a line class along with a constructor that calculates the length of the line while an object of the class is created &minus;</p>
<pre class="prettyprint notranslate tryit">
type Line = class
   val X1 : float
   val Y1 : float
   val X2 : float
   val Y2 : float

   new (x1, y1, x2, y2) as this =
      { X1 = x1; Y1 = y1; X2 = x2; Y2 = y2;}
      then
         printfn " Creating Line: {(%g, %g), (%g, %g)}\nLength: %g"
            this.X1 this.Y1 this.X2 this.Y2 this.Length

   member x.Length =
      let sqr x = x * x
      sqrt(sqr(x.X1 - x.X2) + sqr(x.Y1 - x.Y2) )
end
let aLine = new Line(1.0, 1.0, 4.0, 5.0)
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Creating Line: {(1, 1), (4, 5)}
Length: 5
</pre>
<h2>Let Bindings</h2>
<p>The let bindings in a class definition allow you to define private fields and private functions for F# classes.</p>
<pre class="prettyprint notranslate tryit">
type Greetings(name) as gr =
   let data = name
   do
      gr.PrintMessage()
   member this.PrintMessage() =
      printf "Hello %s\n" data
let gtr = new Greetings("Zara")
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Hello Zara
</pre>
<p>Please note the use of self-identifier <i>gr</i> for the <i>Greetings</i> class.</p>
<h1>F# - Structures</h1>
<p>A structure in F# is a value type data type. It helps you to make a single variable, hold related data of various data types. The <b>struct</b> keyword is used for creating a structure.</p>
<h2>Syntax</h2>
<p>Syntax for defining a structure is as follows &minus;</p>
<pre class="result notranslate">
[ attributes ]
type [accessibility-modifier] type-name =
   struct
      type-definition-elements
   end
// or
[ attributes ]
[&lt;StructAttribute&gt;]
type [accessibility-modifier] type-name =
   type-definition-elements
</pre>
<p>There are two syntaxes. The first syntax is mostly used, because, if you use the <b>struct</b> and <b>end</b> keywords, you can omit the <b>StructAttribute</b> attribute.</p>
<p>The structure definition elements provide &minus;</p>
<ul class="list">
<li>Member declarations and definitions.</li>
<li>Constructors and mutable and immutable fields.</li>
<li>Members and interface implementations.</li>
</ul>
<p>Unlike classes, structures cannot be inherited and cannot contain let or do bindings. Since, structures do not have let bindings; you must declare fields in structures by using the <b>val</b> keyword.</p>
<p>When you define a field and its type using <b>val</b> keyword, you cannot initialize the field value, instead they are initialized to zero or null. So for a structure having an implicit constructor, the <b>val</b> declarations be annotated with the <b>DefaultValue</b> attribute.</p>
<h2>Example</h2>
<p>The following program creates a line structure along with a constructor. The program calculates the length of a line using the structure &minus;</p>
<pre class="prettyprint notranslate tryit">
type Line = struct
   val X1 : float
   val Y1 : float
   val X2 : float
   val Y2 : float

   new (x1, y1, x2, y2) =
      {X1 = x1; Y1 = y1; X2 = x2; Y2 = y2;}
end
let calcLength(a : Line)=
   let sqr a = a * a
   sqrt(sqr(a.X1 - a.X2) + sqr(a.Y1 - a.Y2) )

let aLine = new Line(1.0, 1.0, 4.0, 5.0)
let length = calcLength aLine
printfn "Length of the Line: %g " length
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Length of the Line: 5
</pre>
<h1>F# - Operator Overloading</h1>
<p>You can redefine or overload most of the built-in operators available in F#. Thus a programmer can use operators with user-defined types as well.</p>
<p>Operators are functions with special names, enclosed in brackets. They must be defined as static class members. Like any other function, an overloaded operator has a return type and a parameter list.</p>
<p>The following example, shows a &plus; operator on complex numbers &minus;</p>
<pre class="result notranslate">
//overloading &plus; operator
static member (&plus;) (a : Complex, b: Complex) =
Complex(a.x &plus; b.x, a.y &plus; b.y)
</pre>
<p>The above function implements the addition operator (&plus;) for a user-defined class Complex. It adds the attributes of two objects and returns the resultant Complex object.</p>
<h2>Implementation of Operator Overloading</h2>
<p>The following program shows the complete implementation &minus;</p>
<pre class="prettyprint notranslate tryit">
//implementing a complex class with +, and - operators
//overloaded
type Complex(x: float, y : float) =
   member this.x = x
   member this.y = y
   //overloading + operator
   static member (+) (a : Complex, b: Complex) =
      Complex(a.x + b.x, a.y + b.y)

   //overloading - operator
   static member (-) (a : Complex, b: Complex) =
      Complex(a.x - b.x, a.y - b.y)

   // overriding the ToString method
   override this.ToString() =
      this.x.ToString() + " " + this.y.ToString()

//Creating two complex numbers
let c1 = Complex(7.0, 5.0)
let c2 = Complex(4.2, 3.1)

// addition and subtraction using the
//overloaded operators
let c3 = c1 + c2
let c4 = c1 - c2

//printing the complex numbers
printfn "%s" (c1.ToString())
printfn "%s" (c2.ToString())
printfn "%s" (c3.ToString())
printfn "%s" (c4.ToString())
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
7 5
4.2 3.1
11.2 8.1
2.8 1.9
</pre>
<h1>F# - Inheritance</h1>
<p>One of the most important concepts in object-oriented programming is that of inheritance. Inheritance allows us to define a class in terms of another class, which makes it easier to create and maintain an application. This also provides an opportunity to reuse the code functionality and fast implementation time.</p>
<p>When creating a class, instead of writing completely new data members and member functions, the programmer can designate that the new class should inherit the members of an existing class. This existing class is called the base class, and the new class is referred to as the derived class.</p>
<p>The idea of inheritance implements the IS-A relationship. For example, mammal IS A animal, dog IS-A mammal hence dog IS-A animal as well and so on.</p>
<h2>Base Class and Sub Class</h2>
<p>A subclass is derived from a base class, which is already defined. A subclass inherits the members of the base class, as well as has its own members.</p>
<p>A subclass is defined using the <b>inherit</b> keyword as shown below &minus;</p>
<pre class="result notranslate">
type MyDerived(...) =
   inherit MyBase(...)
</pre>
<p>In F#, a class can have at most one direct base class. If you do not specify a base class by using the <b>inherit</b> keyword, the class implicitly inherits from Object.</p>
<p>Please note &minus;</p>
<ul class="list">
<li><p>The methods and members of the base class are available to users of the derived class like the direct members of the derived class.</p></li>
<li><p>Let bindings and constructor parameters are private to a class and, therefore, cannot be accessed from derived classes.</p></li>
<li><p>The keyword <b>base</b> refers to the base class instance. It is used like the self-identifier.</p></li>
</ul>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
type Person(name) =
   member x.Name = name
   member x.Greet() = printfn "Hi, I'm %s" x.Name

type Student(name, studentID : int) =
   inherit Person(name)
   let mutable _GPA = 0.0
   member x.StudentID = studentID
   member x.GPA
      with get() = _GPA
      and set value = _GPA &lt;- value

type Teacher(name, expertise : string) =
   inherit Person(name)

   let mutable _salary = 0.0
   member x.Salary
      with get() = _salary
      and set value = _salary &lt;- value
   member x.Expertise = expertise

//using the subclasses
let p = new Person("Mohan")
let st = new Student("Zara", 1234)
let tr = new Teacher("Mariam", "Java")

p.Greet()
st.Greet()
tr.Greet()
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Hi, I'm Mohan
Hi, I'm Zara
Hi, I'm Mariam
</pre>
<h2>Overriding Methods</h2>
<p>You can override a default behavior of a base class method and implement it differently in the subclass or the derived class.</p>
<p>Methods in F# are not overridable by default.</p>
<p>To override methods in a derived class, you have to declare your method as overridable using the <b>abstract</b> and <b>default</b> keywords as follows &minus;</p>
<pre class="result notranslate">
type Person(name) =
   member x.Name = name
   abstract Greet : unit -&gt; unit
   default x.Greet() = printfn "Hi, I'm %s" x.Name
</pre>
<p>Now, the <i>Greet</i> method of the Person class can be overridden in derived classes. The following example demonstrates this &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
type Person(name) =
   member x.Name = name
   abstract Greet : unit -&gt; unit
   default x.Greet() = printfn "Hi, I'm %s" x.Name

type Student(name, studentID : int) =
   inherit Person(name)

   let mutable _GPA = 0.0

   member x.StudentID = studentID
   member x.GPA
      with get() = _GPA
      and set value = _GPA &lt;- value
   override x.Greet() = printfn "Student %s" x.Name

type Teacher(name, expertise : string) =
   inherit Person(name)
   let mutable _salary = 0.0
   member x.Salary
      with get() = _salary
      and set value = _salary &lt;- value

   member x.Expertise = expertise
   override x.Greet() = printfn "Teacher %s." x.Name

//using the subclasses
let p = new Person("Mohan")
let st = new Student("Zara", 1234)
let tr = new Teacher("Mariam", "Java")

//default Greet
p.Greet()

//Overriden Greet
st.Greet()
tr.Greet()
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Hi, I'm Mohan
Student Zara
Teacher Mariam.
</pre>
<h2>Abstract Class</h2>
<p>At times you need to provide an incomplete implementation of an object, which should not be implemented in reality. Later, some other programmer should create subclasses of the abstract class to a complete implementation.</p>
<p>For example, the Person class will not be needed in a School Management System. However, the Student or the Teacher class will be needed. In such cases, you can declare the Person class as an abstract class.</p>
<p>The <b>AbstractClass</b> attribute tells the compiler that the class has some abstract members.</p>
<p>You cannot create an instance of an abstract class because the class is not fully implemented.</p>
<p>The following example demonstrates this &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
[&lt;AbstractClass&gt;]
type Person(name) =
   member x.Name = name
   abstract Greet : unit -&gt; unit

type Student(name, studentID : int) =
   inherit Person(name)
   let mutable _GPA = 0.0
   member x.StudentID = studentID
   member x.GPA
      with get() = _GPA
      and set value = _GPA &lt;- value
   override x.Greet() = printfn "Student %s" x.Name

type Teacher(name, expertise : string) =
   inherit Person(name)
   let mutable _salary = 0.0
   member x.Salary
      with get() = _salary
      and set value = _salary &lt;- value
   member x.Expertise = expertise
   override x.Greet() = printfn "Teacher %s." x.Name

let st = new Student("Zara", 1234)
let tr = new Teacher("Mariam", "Java")

//Overriden Greet
st.Greet()
tr.Greet()
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Student Zara
Teacher Mariam.
</pre>
<h1>F# - Interfaces</h1>
<p>Interfaces provide an abstract way of writing up the implementation details of a class. It is a template that declares the methods the class must implement and expose publicly.</p>
<h2>Syntax</h2>
<p>An interface specifies the sets of related members that other classes implement. It has the following syntax &minus;</p>
<pre class="result notranslate">
// Interface declaration:
[ attributes ]
type interface-name =
   [ interface ]
      [ inherit base-interface-name ...]
      abstract member1 : [ argument-types1 -> ] return-type1
      abstract member2 : [ argument-types2 -> ] return-type2
      ...
   [ end ]
	
// Implementing, inside a class type definition:
interface interface-name with
   member self-identifier.member1 argument-list = method-body1
   member self-identifier.member2 argument-list = method-body2
// Implementing, by using an object expression:
[ attributes ]
let class-name (argument-list) =
   { new interface-name with
      member self-identifier.member1 argument-list = method-body1
      member self-identifier.member2 argument-list = method-body2
      [ base-interface-definitions ]
   }
member-list
</pre>
<p>Please note &minus;</p>
<ul class="list">
<li><p>In an interface declaration the members are not implemented.</p></li>
<li><p>The members are abstract, declared by the <b>abstract</b> keyword. However you may provide a default implementation using the <b>default</b> keyword.</p></li>
<li><p>You can implement interfaces either by using object expressions or by using class types.</p></li>
<li><p>In class or object implementation, you need to provide method bodies for abstract methods of the interface.</p></li>
<li><p>The keywords <b>interface</b> and <b>end,</b> which mark the start and end of the definition, are optional.</p></li>
</ul>
<p>For example,</p>
<pre class="result notranslate">
type IPerson =
   abstract Name : string
   abstract Enter : unit -&gt; unit
   abstract Leave : unit -&gt; unit
</pre>
<h2>Calling Interface Methods</h2>
<p>Interface methods are called through the interface, not through the instance of the class or type implementing interface. To call an interface method, you up cast to the interface type by using the <b>:&gt;</b> operator (upcast operator).</p>
<p>For example,</p>
<pre class="result notranslate">
(s :&gt; IPerson).Enter()
(s :&gt; IPerson).Leave()
</pre>
<p>The following example illustrates the concept &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
type IPerson =
   abstract Name : string
   abstract Enter : unit -&gt; unit
   abstract Leave : unit -&gt; unit

type Student(name : string, id : int) =
   member this.ID = id
   interface IPerson with
      member this.Name = name
      member this.Enter() = printfn "Student entering premises!"
      member this.Leave() = printfn "Student leaving premises!"

type StuffMember(name : string, id : int, salary : float) =
   let mutable _salary = salary

   member this.Salary
      with get() = _salary
      and set(value) = _salary &lt;- value

   interface IPerson with
      member this.Name = name
      member this.Enter() = printfn "Stuff member entering premises!"
      member this.Leave() = printfn "Stuff member leaving premises!"

let s = new Student("Zara", 1234)
let st = new StuffMember("Rohit", 34, 50000.0)

(s :&gt; IPerson).Enter()
(s :&gt; IPerson).Leave()
(st :&gt; IPerson).Enter()
(st :&gt; IPerson).Leave()
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Student entering premises!
Student leaving premises!
Stuff member entering premises!
Stuff member leaving premises!
</pre>
<h2>Interface Inheritance</h2>
<p>Interfaces can inherit from one or more base interfaces.</p>
<p>The following example shows the concept &minus;</p>
<pre class="prettyprint notranslate tryit">
type Interface1 =
   abstract member doubleIt: int -&gt; int

type Interface2 =
   abstract member tripleIt: int -&gt; int

type Interface3 =
   inherit Interface1
   inherit Interface2
   abstract member printIt: int -&gt; string

type multiplierClass() =
   interface Interface3 with
      member this.doubleIt(a) = 2 * a
      member this.tripleIt(a) = 3 * a
      member this.printIt(a) = a.ToString()

let ml = multiplierClass()
printfn "%d" ((ml:&gt;Interface3).doubleIt(5))
printfn "%d" ((ml:&gt;Interface3).tripleIt(5))
printfn "%s" ((ml:&gt;Interface3).printIt(5))
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
10
15
5
</pre>
<h1>F# - Events</h1>
<p>Events allow classes to send and receive messages between one another.</p>
<p>In GUI, events are user actions like key press, clicks, mouse movements, etc., or some occurrence like system generated notifications. Applications need to respond to events when they occur. For example, interrupts. Events are used for inter-process communication.</p>
<p>Objects communicate with one another through synchronous message passing.</p>
<p>Events are attached to other functions; objects register <b>callback</b> functions to an event, and these callbacks are executed when (and if) the event is triggered by some object.</p>
<h2>The Event Class and Event Module</h2>
<p>The Control.Event&lt;'T&gt; Class helps in creating an observable object or event.</p>
<p>It has the following instance members to work with the events &minus;</p>
<table class="table table-bordered">
<tr>
<th>Member</th>
<th>Description</th>
</tr>
<tr>
<td>Publish</td>
<td>Publishes an observation as a first class value.</td>
</tr>
<tr>
<td>Trigger</td>
<td>Triggers an observation using the given parameters.</td>
</tr>
</table>
<p>The Control.Event Module provides functions for managing event streams &minus;</p>
<table class="table table-bordered">
<tr>
<th style="width:48%;">Value</th>
<th>Description</th>
</tr>
<tr>
<td>add : ('T &rarr; unit) &rarr; Event&lt;'Del,'T&gt; &rarr; unit</td>
<td>Runs the given function each time the given event is triggered.</td>
</tr>
<tr>
<td>choose : ('T &rarr; 'U option) &rarr; IEvent&lt;'Del,'T&gt; &rarr; IEvent&lt;'U&gt;</td>
<td>Returns a new event which fires on a selection of messages from the original event. The selection function takes an original message to an optional new message.</td>
</tr>
<tr>
<td>filter : ('T &rarr; bool) &rarr; IEvent&lt;'Del,'T&gt; &rarr; IEvent&lt;'T&gt;</td>
<td>Returns a new event that listens to the original event and triggers the resulting event only when the argument to the event passes the given function.</td>
</tr>
<tr>
<td>map : ('T &rarr; 'U) &rarr; IEvent&lt;'Del, 'T&gt; &rarr; IEvent&lt;'U&gt;</td>
<td>Returns a new event that passes values transformed by the given function.</td>
</tr>
<tr>
<td>merge : IEvent&lt;'Del1,'T&gt; &rarr; IEvent&lt;'Del2,'T&gt; &rarr; IEvent&lt;'T&gt;</td>
<td>Fires the output event when either of the input events fire.</td>
</tr>
<tr>
<td>pairwise : IEvent&lt;'Del,'T&gt; &rarr; IEvent&lt;'T * 'T&gt;</td>
<td>Returns a new event that triggers on the second and subsequent triggering of the input event. The <b>Nth</b> triggering of the input event passes the arguments from the <b>N-1th</b> and <b>Nth</b> triggering as a pair. The argument passed to the <b>N-1th</b> triggering is held in hidden internal state until the <b>Nth</b> triggering occurs.</td>
</tr>
<tr>
<td>partition : ('T &rarr; bool) &rarr; IEvent&lt;'Del,'T&gt; &rarr; IEvent&lt;'T&gt; * IEvent&lt;'T&gt;</td>
<td>Returns a new event that listens to the original event and triggers the first resulting event if the application of the predicate to the event arguments returned true, and the second event if it returned false.</td>
</tr>
<tr>
<td>scan : ('U &rarr; 'T &rarr; 'U) &rarr; 'U &rarr; IEvent&lt;'Del,'T&gt; &rarr; IEvent&lt;'U&gt;</td>
<td>Returns a new event consisting of the results of applying the given accumulating function to successive values triggered on the input event. An item of internal state records the current value of the state parameter. The internal state is not locked during the execution of the accumulation function, so care should be taken that the input IEvent not triggered by multiple threads simultaneously.</td>
</tr>
<tr>
<td>split : ('T &rarr; Choice&lt;'U1,'U2&gt;) &rarr; IEvent&lt;'Del,'T&gt; &rarr; IEvent&lt;'U1&gt; * IEvent&lt;'U2&gt;</td>
<td>Returns a new event that listens to the original event and triggers the first resulting event if the application of the function to the event arguments returned a Choice1Of2, and the second event if it returns a Choice2Of2.</td>
</tr>
</table>
<h2>Creating Events</h2>
<p>Events are created and used through the <b>Event</b> class. The Event constructor is used for creating an event.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
type Worker(name : string, shift : string) =
   let mutable _name = name;
   let mutable _shift = shift;
   let nameChanged = new Event&lt;unit&gt;() (* creates event *)
   let shiftChanged = new Event&lt;unit&gt;() (* creates event *)

   member this.Name
      with get() = _name
      and set(value) = _name &lt;- value

   member this.Shift
      with get() = _shift
      and set(value) = _shift &lt;- value
</pre>
<p>After this you need to expose the nameChanged field as a public member, so that the listeners can hook onto the event for which, you use the <b>Publish</b> property of the event &minus;</p>
<pre class="prettyprint notranslate">
type Worker(name : string, shift : string) =
   let mutable _name = name;
   let mutable _shift = shift;

   let nameChanged = new Event&lt;unit&gt;() (* creates event *)
   let shiftChanged = new Event&lt;unit&gt;() (* creates event *)

   member this.NameChanged = nameChanged.Publish (* exposed event handler *)
   member this.ShiftChanged = shiftChanged.Publish (* exposed event handler *)

   member this.Name
      with get() = _name
      and set(value) = _name &lt;- value
      nameChanged.Trigger() (* invokes event handler *)

   member this.Shift
      with get() = _shift
      and set(value) = _shift &lt;- value
   shiftChanged.Trigger() (* invokes event handler *)
</pre>
<p>Next, you add callbacks to event handlers. Each event handler has the type IEvent&lt;'T&gt;, which provides several methods &minus;</p>
<table class="table table-bordered">
<tr>
<th style="width:40%;">Method</td>
<th>Description</td>
</tr>
<tr>
<td>val Add : event:('T &rarr; unit) &rarr; unit</td>
<td>Connects a listener function to the event. The listener will be invoked when the event is fired.</td>
</tr>
<tr>
<td>val AddHandler : 'del &rarr; unit</td>
<td>Connects a handler delegate object to the event. A handler can be later removed using RemoveHandler. The listener will be invoked when the event is fired.</td>
</tr>
<tr>
<td>val RemoveHandler : 'del &rarr; unit</td>
<td>Removes a listener delegate from an event listener store.</td>
</tr>
</table>
<p>The following section provides a complete example.</p>
<h3>Example</h3>
<p>The following example demonstrates the concept and techniques discussed above &minus;</p>
<pre class="prettyprint notranslate tryit">
type Worker(name : string, shift : string) =
   let mutable _name = name;
   let mutable _shift = shift;

   let nameChanged = new Event&lt;unit&gt;() (* creates event *)
   let shiftChanged = new Event&lt;unit&gt;() (* creates event *)

   member this.NameChanged = nameChanged.Publish (* exposed event handler *)
   member this.ShiftChanged = shiftChanged.Publish (* exposed event handler *)

   member this.Name
      with get() = _name
      and set(value) = 
         _name &lt;- value
         nameChanged.Trigger() (* invokes event handler *)

   member this.Shift
      with get() = _shift
      and set(value) = 
         _shift &lt;- value
         shiftChanged.Trigger() (* invokes event handler *)

let wk = new Worker("Wilson", "Evening")
wk.NameChanged.Add(fun () -&gt; printfn "Worker changed name! New name: %s" wk.Name)
wk.Name &lt;- "William"
wk.NameChanged.Add(fun () -&gt; printfn "-- Another handler attached to NameChanged!")
wk.Name &lt;- "Bill"

wk.ShiftChanged.Add(fun () -&gt; printfn "Worker changed shift! New shift: %s" wk.Shift)
wk.Shift &lt;- "Morning"
wk.ShiftChanged.Add(fun () -&gt; printfn "-- Another handler attached to ShiftChanged!")
wk.Shift &lt;- "Night"
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Worker changed name! New name: William
Worker changed name! New name: Bill
-- Another handler attached to NameChanged!
Worker changed shift! New shift: Morning
Worker changed shift! New shift: Night
-- Another handler attached to ShiftChanged!
</pre>
<h1>F# - Modules</h1>
<p>As per MSDN library, an F# module is a grouping of F# code constructs, such as types, values, function values, and code in do bindings. It is implemented as a common language runtime (CLR) class that has only static members.</p>
<p>Depending upon the situation whether the whole file is included in the module, there are two types of module declarations &minus;</p>
<ul class="list">
<li>Top-level module declaration</li>
<li>Local module declaration</li>
</ul>
<p>In a top-level module declaration the whole file is included in the module. In this case, the first declaration in the file is the module declaration. You do not have to indent declarations in a top-level module.</p>
<p>In a local module declaration, only the declarations that are indented under that module declaration are part of the module.</p>
<h2>Syntax</h2>
<p>Syntax for module declaration is as follows &minus;</p>
<pre class="result notranslate">
// Top-level module declaration.
module [accessibility-modifier] [qualified-namespace.]module-name
   declarations
// Local module declaration.
module [accessibility-modifier] module-name =
   declarations
</pre>
<p>Please note that the accessibility-modifier can be one of the following &minus; public, private, internal. The default is <b>public</b>.</p>
<p>The following examples will demonstrate the concepts &minus;</p>
<h2>Example 1</h2>
<p>The module file Arithmetic.fs &minus;</p>
<pre class="prettyprint notranslate">
module Arithmetic
let add x y =
   x + y

let sub x y =
   x - y
	
let mult x y =
   x * y
	
let div x y =
   x / y
</pre>
<p>The program file main.fs &minus;</p>
<pre class="prettyprint notranslate tryit">
// Fully qualify the function name.
let addRes = Arithmetic.add 25 9
let subRes = Arithmetic.sub 25 9
let multRes = Arithmetic.mult 25 9
let divRes = Arithmetic.div 25 9

printfn "%d" addRes
printfn "%d" subRes
printfn "%d" multRes
printfn "%d" divRes

// Opening the module.
open Arithmetic

let addRes2 = Arithmetic.add 100 10
let subRes2 = Arithmetic.sub 100 10
let multRes2 = Arithmetic.mult 100 10
let divRes2 = Arithmetic.div 100 10

printfn "%d" addRes2
printfn "%d" subRes2
printfn "%d" multRes2
printfn "%d" divRes2
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
34
16
225
2
110
90
1000
10
</pre>
<h2>Example 2</h2>
<pre class="prettyprint notranslate tryit">
// Module1
module module1 =
   // Indent all program elements within modules that are declared with an equal sign.
   let value1 = 100
   let module1Function x =
      x + value1

// Module2
module module2 =
   let value2 = 200

   // Use a qualified name to access the function.
   // from module1.
   let module2Function x =
      x + (module1.module1Function value2)

let result = module1.module1Function 25
printfn "%d" result

let result2 = module2.module2Function 25
printfn "%d" result2
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
125
325
</pre>
<h1>F# - Namespaces</h1>
<p>A <b>namespace</b> is designed for providing a way to keep one set of names separate from another. The class names declared in one namespace will not conflict with the same class names declared in another.</p>
<p>As per the MSDN library, a <b>namespace</b> lets you organize code into areas of related functionality by enabling you to attach a name to a grouping of program elements.</p>
<h2>Declaring a Namespace</h2>
<p>To organize your code in a namespace, you must declare the namespace as the first declaration in the file. The contents of the entire file then become part of the namespace.</p>
<pre class="result notranslate">
namespace [parent-namespaces.]identifier
</pre>
<p>The following example illustrates the concept &minus;</p>
<h2>Example</h2>
<pre class="prettyprint notranslate tryit">
namespace testing

module testmodule1 =
   let testFunction x y =
      printfn "Values from Module1: %A %A" x y
module testmodule2 =
   let testFunction x y =
      printfn "Values from Module2: %A %A" x y

module usermodule =
   do
      testmodule1.testFunction ( "one", "two", "three" ) 150
      testmodule2.testFunction (seq { for i in 1 .. 10 do yield i * i }) 200
</pre>
<p>When you compile and execute the program, it yields the following output &minus;</p>
<pre class="result notranslate">
Values from Module1: ("one", "two", "three") 150
Values from Module2: seq [1; 4; 9; 16; ...] 200
</pre>

<title>F# Useful Resources</title>

<h1>F# - Useful Resources</h1>

<p>The following resources contain additional information on F#. Please use them to get more in-depth knowledge on this topic.</p>

<h2>Useful Links on F#</h2>

<p><a target="_blank" rel="nofollow" href="http://fsharp.org/">F#</a> - Official site of F#.</p>

<p><a target="_blank" rel="nofollow" href="http://en.wikipedia.org/wiki/F_Sharp_(programming_language)">F# Wikipedia</a> - Wikipedia reference for F#.</p>

<h2>Useful Books on F#</h2>

<p>To enlist your site on this page, please drop an email to <b>contact@tutorialspoint.com</b></p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Discuss F#</title>

<h1>Discuss F#</h1>

<p>F# helps you in the daily development of the mainstream commercial business software. This tutorial provides a brief knowledge about F# and its features, and also provides the various structures and syntaxes of its methods and functions.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

</body></html>