<!DOCTYPE html><html><body><title>Embedded Systems Tutorial</title>

<h1>Embedded Systems Tutorial</h1>

<p>We can broadly define an embedded system as a microcontroller-based, software-driven, reliable, real-time control system, designed to perform a specific task. It can be thought of as a computer hardware system having software embedded in it. An embedded system can be either an independent system or a part of a large system. In this tutorial, we will explain all the steps necessary to design an embedded system and use it.</p>

<h1>Audience</h1>

<p>This tutorial has been designed to help the students of electronics learn the basic-to-advanced concepts of Embedded System and 8051 Microcontroller.</p>

<h1>Prerequisites</h1>

<p>Before proceeding with this tutorial, you should have a good understanding of the concepts of basic electronics such as circuits, logic gates, etc.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Embedded Systems Overview</title>

<h1>Embedded Systems - Overview</h1>

<h2>System</h2>

<p>A system is an arrangement in which all its unit assemble work together according to a set of rules. It can also be defined as a way of working, organizing or doing one or many tasks according to a fixed plan. For example, a watch is a time displaying system. Its components follow a set of rules to show time. If one of its parts fails, the watch will stop working. So we can say, in a system, all its subcomponents depend on each other.</p>

<h2>Embedded System</h2>

<p>As its name suggests, Embedded means something that is attached to another thing. An embedded system can be thought of as a computer hardware system having software embedded in it. An embedded system can be an independent system or it can be a part of a large system. An embedded system is a microcontroller or microprocessor based system which is designed to perform a specific task. For example, a fire alarm is an embedded system; it will sense only smoke.</p>

<p>An embedded system has three components &minus;</p>

<p>It has hardware.</p>

<p>It has application software.</p>

<p>It has Real Time Operating system (RTOS) that supervises the application software and provide mechanism to let the processor run a process as per scheduling by following a plan to control the latencies. RTOS defines the way the system works. It sets the rules during the execution of application program. A small scale embedded system may not have RTOS.</p>

<p>So we can define an embedded system as a Microcontroller based, software driven, reliable, real-time control system.</p>

<h2>Characteristics of an Embedded System</h2>

<p><b>Single-functioned</b> &minus; An embedded system usually performs a specialized operation and does the same repeatedly. For example: A pager always functions as a pager.</p>

<p><b>Tightly constrained</b> &minus; All computing systems have constraints on design metrics, but those on an embedded system can be especially tight. Design metrics is a measure of an implementation's features such as its cost, size, power, and performance. It must be of a size to fit on a single chip, must perform fast enough to process data in real time and consume minimum power to extend battery life.</p>

<p><b>Reactive and Real time</b> &minus; Many embedded systems must continually react to changes in the system's environment and must compute certain results in real time without any delay. Consider an example of a car cruise controller; it continually monitors and reacts to speed and brake sensors. It must compute acceleration or de-accelerations repeatedly within a limited time; a delayed computation can result in failure to control of the car.</p>

<p><b>Microprocessors based</b> &minus; It must be microprocessor or microcontroller based.</p>

<p><b>Memory</b> &minus; It must have a memory, as its software usually embeds in ROM. It does not need any secondary memories in the computer.</p>

<p><b>Connected</b> &minus; It must have connected peripherals to connect input and output devices.</p>

<p><b>HW-SW systems</b> &minus; Software is used for more features and flexibility. Hardware is used for performance and security.</p>

<h3>Advantages</h3>

<h3>Disadvantages</h3>

<h2>Basic Structure of an Embedded System</h2>

<p>The following illustration shows the basic structure of an embedded system &minus;</p>

<p><b>Sensor</b> &minus; It measures the physical quantity and converts it to an electrical signal which can be read by an observer or by any electronic instrument like an A2D converter. A sensor stores the measured quantity to the memory.</p>

<p><b>A-D Converter</b> &minus; An analog-to-digital converter converts the analog signal sent by the sensor into a digital signal.</p>

<p><b>Processor &amp; ASICs</b> &minus; Processors process the data to measure the output and store it to the memory.</p>

<p><b>D-A Converter</b> &minus; A digital-to-analog converter converts the digital data fed by the processor to analog data</p>

<p><b>Actuator</b> &minus; An actuator compares the output given by the D-A Converter to the actual (expected) output stored in it and stores the approved output. </p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Embedded Systems Processors</title>

<h1>Embedded Systems - Processors</h1>

<p>Processor is the heart of an embedded system. It is the basic unit that takes inputs and produces an output after processing the data. For an embedded system designer, it is necessary to have the knowledge of both microprocessors and microcontrollers.</p>

<h2>Processors in a System</h2>

<p>A processor has two essential units &minus;</p>

<p>The CU includes a fetch unit for fetching instructions from the memory. The EU has circuits that implement the instructions pertaining to data transfer operation and data conversion from one form to another.</p>

<p>The EU includes the Arithmetic and Logical Unit (ALU) and also the circuits that execute instructions for a program control task such as interrupt, or jump to another set of instructions.</p>

<p>A processor runs the cycles of fetch and executes the instructions in the same sequence as they are fetched from memory.</p>

<h2>Types of Processors</h2>

<p>Processors can be of the following categories &minus;</p>

<p>General Purpose Processor (GPP)</p>

<p>Application Specific System Processor (ASSP)</p>

<p>Application Specific Instruction Processors (ASIPs)</p>

<p>GPP core(s) or ASIP core(s) on either an Application Specific Integrated Circuit (ASIC) or a Very Large Scale Integration (VLSI) circuit.</p>

<h2>Microprocessor</h2>

<p>A microprocessor is a single VLSI chip having a CPU. In addition, it may also have other units such as coaches, floating point processing arithmetic unit, and pipelining units that help in faster processing of instructions.</p>

<p>Earlier generation microprocessors’ fetch-and-execute cycle was guided by a clock frequency of order of ~1 MHz. Processors now operate at a clock frequency of 2GHz</p>

<h2>Microcontroller</h2>

<p>A microcontroller is a single-chip VLSI unit (also called <b>microcomputer</b>) which, although having limited computational capabilities, possesses enhanced input/output capability and a number of on-chip functional units.</p>

<p>Microcontrollers are particularly used in embedded systems for real-time control applications with on-chip program memory and devices.</p>

<h2>Microprocessor vs Microcontroller</h2>

<p>Let us now take a look at the most notable differences between a microprocessor and a microcontroller.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Embedded Systems Architecture Types</title>

<h1>Embedded Systems - Architecture Types</h1>

<p>The 8051 microcontrollers work with 8-bit data bus. So they can support external data memory up to 64K and external program memory of 64k at best. Collectively, 8051 microcontrollers can address 128k of external memory.</p>

<p>When data and code lie in different memory blocks, then the architecture is referred as <b>Harvard architecture</b>. In case data and code lie in the same memory block, then the architecture is referred as <b>Von Neumann architecture</b>.</p>

<h2>Von Neumann Architecture</h2>

<p>The Von Neumann architecture was first proposed by a computer scientist John von Neumann. In this architecture, one data path or bus exists for both instruction and data. As a result, the CPU does one operation at a time. It either fetches an instruction from memory, or performs read/write operation on data. So an instruction fetch and a data operation cannot occur simultaneously, sharing a common bus.</p>

<p>Von-Neumann architecture supports simple hardware. It allows the use of a single, sequential memory. Today's processing speeds vastly outpace memory access times, and we employ a very fast but small amount of memory (cache) local to the processor.</p>

<h2>Harvard Architecture</h2>

<p>The Harvard architecture offers separate storage and signal buses for instructions and data. This architecture has data storage entirely contained within the CPU, and there is no access to the instruction storage as data. Computers have separate memory areas for program instructions and data using internal data buses, allowing simultaneous access to both instructions and data.</p>

<p>Programs needed to be loaded by an operator; the processor could not boot itself. In a Harvard architecture, there is no need to make the two memories share properties.</p>

<h2>Von-Neumann Architecture vs Harvard Architecture</h2>

<p>The following points distinguish the Von Neumann Architecture from the Harvard Architecture.</p>

<h2>CISC and RISC</h2>

<p>CISC is a Complex Instruction Set Computer. It is a computer that can address a large number of instructions.</p>

<p>In the early 1980s, computer designers recommended that computers should use fewer instructions with simple constructs so that they can be executed much faster within the CPU without having to use memory. Such computers are classified as Reduced Instruction Set Computer or RISC.</p>

<h3>CISC vs RISC</h3>

<p>The following points differentiate a CISC from a RISC &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Embedded Systems Tools and Peripherals </title>

<h1>Embedded Systems - Tools &amp; Peripherals </h1>

<h2>Compilers and Assemblers</h2>

<h3>Compiler</h3>

<p>A compiler is a computer program (or a set of programs) that transforms the source code written in a programming language (the source language) into another computer language (normally binary format). The most common reason for conversion is to create an executable program. The name "compiler" is primarily used for programs that translate the source code from a highlevel programming language to a low-level language (e.g., assembly language or machine code).</p>

<h3>Cross-Compiler</h3>

<p>If the compiled program can run on a computer having different CPU or operating system than the computer on which the compiler compiled the program, then that compiler is known as a cross-compiler.</p>

<h3>Decompiler</h3>

<p>A program that can translate a program from a low-level language to a high-level language is called a decompiler.</p>

<h3>Language Converter</h3>

<p>A program that translates programs written in different high-level languages is normally called a language translator, source to source translator, or language converter.</p>

<p>A compiler is likely to perform the following operations &minus;</p>

<h3>Assemblers</h3>

<p>An assembler is a program that takes basic computer instructions (called as assembly language) and converts them into a pattern of bits that the computer's processor can use to perform its basic operations. An assembler creates object code by translating assembly instruction mnemonics into opcodes, resolving symbolic names to memory locations. Assembly language uses a mnemonic to represent each low-level machine operation (opcode).</p>

<h2>Debugging Tools in an Embedded System</h2>

<p>Debugging is a methodical process to find and reduce the number of bugs in a computer program or a piece of electronic hardware, so that it works as expected. Debugging is difficult when subsystems are tightly coupled, because a small change in one subsystem can create bugs in another. The debugging tools used in embedded systems differ greatly in terms of their development time and debugging features. We will discuss here the following debugging tools &minus;</p>

<h2>Simulators</h2>

<p>Code is tested for the MCU / system by simulating it on the host computer used for code development. Simulators try to model the behavior of the complete microcontroller in software.</p>

<h3>Functions of Simulators</h3>

<p>A simulator performs the following functions &minus;</p>

<p>Defines the processor or processing device family as well as its various versions for the target system.</p>

<p>Monitors the detailed information of a source code part with labels and symbolic arguments as the execution goes on for each single step.</p>

<p>Provides the status of RAM and simulated ports of the target system for each single step execution.</p>

<p>Monitors system response and determines throughput.</p>

<p>Provides trace of the output of contents of program counter versus the processor registers.</p>

<p>Provides the detailed meaning of the present command.</p>

<p>Monitors the detailed information of the simulator commands as these are entered from the keyboard or selected from the menu.</p>

<p>Supports the conditions (up to 8 or 16 or 32 conditions) and unconditional breakpoints.</p>

<p>Provides breakpoints and the trace which are together the important testing and debugging tool.</p>

<p>Facilitates synchronizing the internal peripherals and delays.</p>

<h2>Microcontroller Starter Kit</h2>

<p>A microcontroller starter kit consists of &minus;</p>

<p>A big advantage of these kits over simulators is that they work in real-time and thus allow for easy input/output functionality verification. Starter kits, however, are completely sufficient and the cheapest option to develop simple microcontroller projects.</p>

<h2>Emulators</h2>

<p>An emulator is a hardware kit or a software program or can be both which emulates the functions of one computer system (the guest) in another computer system (the host), different from the first one, so that the emulated behavior closely resembles the behavior of the real system (the guest).</p>

<p>Emulation refers to the ability of a computer program in an electronic device to emulate (imitate) another program or device. Emulation focuses on recreating an original computer environment. Emulators have the ability to maintain a closer connection to the authenticity of the digital object. An emulator helps the user to work on any kind of application or operating system on a platform in a similar way as the software runs as in its original environment.</p>

<h2>Peripheral Devices in Embedded Systems</h2>

<p>Embedded systems communicate with the outside world via their peripherals, such as following &mins;</p>

<h2>Criteria for Choosing Microcontroller</h2>

<p>While choosing a microcontroller, make sure it meets the task at hand and that it is cost effective. We must see whether an 8-bit, 16-bit or 32-bit microcontroller can best handle the computing needs of a task. In addition, the following points should be kept in mind while choosing a microcontroller &minus;</p>

<p><b>Speed</b> &minus; What is the highest speed the microcontroller can support?</p>

<p><b>Packaging</b> &minus; Is it 40-pin DIP (Dual-inline-package) or QFP (Quad flat package)? This is important in terms of space, assembling, and prototyping the end-product.</p>

<p><b>Power Consumption</b> &minus; This is an important criteria for battery-powered products.</p>

<p><b>Amount of RAM and ROM</b> on the chip.</p>

<p><b>Count of I/O pins and Timers</b> on the chip.</p>

<p><b>Cost per Unit</b> &minus; This is important in terms of final cost of the product in which the microcontroller is to be used.</p>

<p>Further, make sure you have tools such as compilers, debuggers, and assemblers, available with the microcontroller. The most important of all, you should purchase a microcontroller from a reliable source.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Embedded Systems 8051 Microcontroller</title>

<h1>Embedded Systems - 8051 Microcontroller</h1>

<h2>Brief History of 8051</h2>

<p>The first microprocessor <b>4004</b> was invented by Intel Corporation. <b>8085</b> and <b>8086</b> microprocessors were also invented by Intel. In 1981, Intel introduced an 8-bit microcontroller called the <b>8051</b>. It was referred as <b>system on a chip</b> because it had 128 bytes of RAM, 4K byte of on-chip ROM, two timers, one serial port, and 4 ports (8-bit wide), all on a single chip. When it became widely popular, Intel allowed other manufacturers to make and market different flavors of 8051 with its code compatible with 8051. It means that if you write your program for one flavor of 8051, it will run on other flavors too, regardless of the manufacturer. This has led to several versions with different speeds and amounts of on-chip RAM.</p>

<h2>8051 Flavors / Members</h2>

<p><b>8052 microcontroller</b> &minus; 8052 has all the standard features of the 8051 microcontroller as well as an extra 128 bytes of RAM and an extra timer. It also has 8K bytes of on-chip program ROM instead of 4K bytes.</p>

<p><b>8031 microcontroller</b> &minus; It is another member of the 8051 family. This chip is often referred to as a ROM-less 8051, since it has 0K byte of on-chip ROM. You must add external ROM to it in order to use it, which contains the program to be fetched and executed. This program can be as large as 64K bytes. But in the process of adding external ROM to the 8031, it lost 2 ports out of 4 ports. To solve this problem, we can add an external I/O to the 8031</p>

<h2>Comparison between 8051 Family Members</h2>

<p>The following table compares the features available in 8051, 8052, and 8031.</p>

<h2>Features of 8051 Microcontroller</h2>

<p>An 8051 microcontroller comes bundled with the following features &minus;</p>

<h2>Block Diagram of 8051 Microcontroller</h2>

<p>The following illustration shows the block diagram of an 8051 microcontroller &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Embedded Systems I/O Programming</title>

<h1>Embedded Systems - I/O Programming</h1>

<p>In 8051, I/O operations are done using four ports and 40 pins. The following pin diagram shows the details of the 40 pins. I/O operation port reserves 32 pins where each port has 8 pins. The other 8 pins are designated as V<sub>cc</sub>, GND, XTAL1, XTAL2, RST, EA (bar), ALE/PROG (bar), and PSEN (bar).</p>

<p>It is a 40 Pin PDIP (Plastic Dual Inline Package)</p>

<p><b>Note</b> &minus; In a DIP package, you can recognize the first pin and the last pin by the cut at the middle of the IC. The first pin is on the left of this cut mark and the last pin (i.e. the 40<sup>th</sup> pin in this case) is to the right of the cut mark.</p>

<h2>I/O Ports and their Functions</h2>

<p>The four ports P0, P1, P2, and P3, each use 8 pins, making them 8-bit ports. Upon RESET, all the ports are configured as inputs, ready to be used as input ports. When the first 0 is written to a port, it becomes an output. To reconfigure it as an input, a 1 must be sent to a port.</p>

<h3>Port 0 (Pin No 32 – Pin No 39)</h3>

<p>It has 8 pins (32 to 39). It can be used for input or output. Unlike P1, P2, and P3 ports, we normally connect P0 to 10K-ohm pull-up resistors to use it as an input or output port being an open drain.</p>

<p>It is also designated as AD0-AD7, allowing it to be used as both address and data. In case of 8031 (i.e. ROMless Chip), when we need to access the external ROM, then P0 will be used for both Address and Data Bus. ALE (Pin no 31) indicates if P0 has address or data. When ALE = 0, it provides data D0-D7, but when ALE = 1, it has address A0-A7. In case no external memory connection is available, P0 must be connected externally to a 10K-ohm pull-up resistor.</p>

<h3>Port 1 (Pin 1 through 8)</h3>

<p>It is an 8-bit port (pin 1 through 8) and can be used either as input or output. It doesn't require pull-up resistors because they are already connected internally. Upon reset, Port 1 is configured as an input port. The following code can be used to send alternating values of 55H and AAH to Port 1.</p>

<p>If Port 1 is configured to be used as an output port, then to use it as an input port again, program it by writing 1 to all of its bits as in the following code.</p>

<h3>Port 2 (Pins 21 through 28)</h3>

<p>Port 2 occupies a total of 8 pins (pins 21 through 28) and can be used for both input and output operations. Just as P1 (Port 1), P2 also doesn't require external Pull-up resistors because they are already connected internally. It must be used along with P0 to provide the 16-bit address for the external memory. So it is also designated as (A0–A7), as shown in the pin diagram. When the 8051 is connected to an external memory, it provides path for upper 8-bits of 16-bits address, and it cannot be used as I/O. Upon reset, Port 2 is configured as an input port. The following code can be used to send alternating values of 55H and AAH to port 2.</p>

<p>If Port 2 is configured to be used as an output port, then to use it as an input port again, program it by writing 1 to all of its bits as in the following code.</p>

<h3>Port 3 (Pins 10 through 17)</h3>

<p>It is also of 8 bits and can be used as Input/Output. This port provides some extremely important signals. P3.0 and P3.1 are RxD (Receiver) and TxD (Transmitter) respectively and are collectively used for Serial Communication. P3.2 and P3.3 pins are used for external interrupts. P3.4 and P3.5 are used for timers T0 and T1 respectively. P3.6 and P3.7 are Write (WR) and Read (RD) pins. These are active low pins, means they will be active when 0 is given to them and these are used to provide Read and Write operations to External ROM in 8031 based systems.</p>

<h2>Dual Role of Port 0 and Port 2</h2>

<p><b>Dual role of Port 0</b> &minus; Port 0 is also designated as AD0–AD7, as it can be used for both data and address handling. While connecting an 8051 to external memory, Port 0 can provide both address and data. The 8051 microcontroller then multiplexes the input as address or data in order to save pins.</p>

<p><b>Dual role of Port 2</b> &minus; Besides working as I/O, Port P2 is also used to provide 16-bit address bus for external memory along with Port 0. Port P2 is also designated as (A8– A15), while Port 0 provides the lower 8-bits via A0–A7. In other words, we can say that when an 8051 is connected to an external memory (ROM) which can be maximum up to 64KB and this is possible by 16 bit address bus because we know 216 = 64KB. Port2 is used for the upper 8-bit of the 16 bits address, and it cannot be used for I/O and this is the way any Program code of external ROM is addressed.</p>

<h2>Hardware Connection of Pins</h2>

<p><b>V<sub>cc</sub></b> &minus; Pin 40 provides supply to the Chip and it is +5 V.</p>

<p><b>Gnd</b> &minus; Pin 20 provides ground for the Reference.</p>

<p><b>XTAL1, XTAL2 (Pin no 18 &amp; Pin no 19)</b> &minus; 8051 has on-chip oscillator but requires external clock to run it. A quartz crystal is connected between the XTAL1 &amp; XTAL2 pin of the chip. This crystal also needs two capacitors of 30pF for generating a signal of desired frequency. One side of each capacitor is connected to ground. 8051 IC is available in various speeds and it all depends on this Quartz crystal, for example, a 20 MHz microcontroller requires a crystal with a frequency no more than 20 MHz.</p>

<p><b>RST (Pin No. 9)</b> &minus; It is an Input pin and active High pin. Upon applying a high pulse on this pin, that is 1, the microcontroller will reset and terminate all activities. This process is known as <b>Power-On Reset</b>. Activating a power-on reset will cause all values in the register to be lost. It will set a program counter to all 0's. To ensure a valid input of Reset, the high pulse must be high for a minimum of two machine cycles before it is allowed to go low, which depends on the capacitor value and the rate at which it charges. (<b>Machine Cycle</b> is the minimum amount of frequency a single instruction requires in execution).</p>

<p><b>EA or External Access (Pin No. 31)</b> &minus; It is an input pin. This pin is an active low pin; upon applying a low pulse, it gets activated. In case of microcontroller (8051/52) having on-chip ROM, the EA (bar) pin is connected to V<sub>cc</sub>. But in an 8031 microcontroller which does not have an on-chip ROM, the code is stored in an external ROM and then fetched by the microcontroller. In this case, we must connect the (pin no 31) EA to Gnd to indicate that the program code is stored externally.</p>

<p><b>PSEN or Program store Enable (Pin No 29)</b> &minus; This is also an active low pin, i.e., it gets activated after applying a low pulse. It is an output pin and used along with the EA pin in 8031 based (i.e. ROMLESS) Systems to allow storage of program code in external ROM.</p>

<p><b>ALE or (Address Latch Enable)</b> &minus; This is an Output Pin and is active high. It is especially used for 8031 IC to connect it to the external memory. It can be used while deciding whether P0 pins will be used as Address bus or Data bus. When ALE = 1, then the P0 pins work as Data bus and when ALE = 0, then the P0 pins act as Address bus.</p>

<h2>I/O Ports and Bit Addressability</h2>

<p>It is a most widely used feature of 8051 while writing code for 8051. Sometimes we need to access only 1 or 2 bits of the port instead of the entire 8-bits. 8051 provides the capability to access individual bits of the ports.</p>

<p>While accessing a port in a single-bit manner, we use the syntax "SETB X. Y" where X is the port number (0 to 3), and Y is a bit number (0 to 7) for data bits D0-D7 where D0 is the LSB and D7 is the MSB. For example, "SETB P1.5" sets high bit 5 of port 1.</p>

<p>The following code shows how we can toggle the bit P1.2 continuously.</p>

<h2>Single-Bit Instructions</h2>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
MOV A,#0FFH  ;(comments: A=FFH(Hexadecimal  i.e. A=1111 1111)  

MOV P0,A     ;(Port0 have 1's on every pin so that it works as Input)
</pre>
<h3>Port 1 (Pin 1 through 8)</h3>
<p>It is an 8-bit port (pin 1 through 8) and can be used either as input or output. It doesn't require pull-up resistors because they are already connected internally. Upon reset, Port 1 is configured as an input port. The following code can be used to send alternating values of 55H and AAH to Port 1.</p>
<pre class="result notranslate">
;Toggle all bits of continuously 
MOV     A,#55 
BACK:    

MOV     P2,A 
ACALL   DELAY 
CPL     A      ;complement(invert) reg. A 
SJMP    BACK
</pre>
<p>If Port 1 is configured to be used as an output port, then to use it as an input port again, program it by writing 1 to all of its bits as in the following code.</p>
<pre class="result notranslate">
;Toggle all bits of continuously 

MOV     A ,#0FFH    ;A = FF hex 
MOV     P1,A        ;Make P1 an input port                     
MOV     A,P1        ;get data from P1 
MOV     R7,A        ;save it in Reg R7 
ACALL   DELAY       ;wait 

MOV     A,P1        ;get another data from P1 
MOV     R6,A        ;save it in R6 
ACALL   DELAY       ;wait 

MOV     A,P1        ;get another data from P1 
MOV     R5,A        ;save it in R5
</pre>
<h3>Port 2 (Pins 21 through 28)</h3>
<p>Port 2 occupies a total of 8 pins (pins 21 through 28) and can be used for both input and output operations. Just as P1 (Port 1), P2 also doesn't require external Pull-up resistors because they are already connected internally. It must be used along with P0 to provide the 16-bit address for the external memory. So it is also designated as (A0–A7), as shown in the pin diagram. When the 8051 is connected to an external memory, it provides path for upper 8-bits of 16-bits address, and it cannot be used as I/O. Upon reset, Port 2 is configured as an input port. The following code can be used to send alternating values of 55H and AAH to port 2.</p>
<pre class="result notranslate">
;Toggle all bits of continuously 
MOV     A,#55 
BACK: 
MOV     P2,A 
ACALL   DELAY 
CPL     A         ; complement(invert) reg. A 
SJMP    BACK
</pre>
<p>If Port 2 is configured to be used as an output port, then to use it as an input port again, program it by writing 1 to all of its bits as in the following code.</p>
<pre class="result notranslate">
;Get a byte from P2 and send it to P1 
MOV    A,#0FFH    ;A = FF hex 
MOV    P2,A       ;make P2 an input port 
BACK: 
MOV    A,P2       ;get data from P2 
MOV    P1,A       ;send it to Port 1
SJMP   BACK       ;keep doing that
</pre>
<h3>Port 3 (Pins 10 through 17)</h3>
<p>It is also of 8 bits and can be used as Input/Output. This port provides some extremely important signals. P3.0 and P3.1 are RxD (Receiver) and TxD (Transmitter) respectively and are collectively used for Serial Communication. P3.2 and P3.3 pins are used for external interrupts. P3.4 and P3.5 are used for timers T0 and T1 respectively. P3.6 and P3.7 are Write (WR) and Read (RD) pins. These are active low pins, means they will be active when 0 is given to them and these are used to provide Read and Write operations to External ROM in 8031 based systems.</p>
<table class="table table-bordered">
<tr>
<th width="33%" style="text-align:center;">P3 Bit</th>
<th width="33%" style="text-align:center;">Function</th>
<th width="33%" style="text-align:center;">Pin</th>
</tr>
<tr style="text-align:center;">
<td>P3.0</td>
<td>RxD</td>
<td>10</td>
</tr>
<tr style="text-align:center;">
<td>P3.1 &lt;</td>
<td>TxD</td>
<td>11</td>
</tr>
<tr style="text-align:center;">
<td>P3.2 &lt;</td>
<td>Complement of INT0</td>
<td>12</td>
</tr>
<tr style="text-align:center;">
<td>P3.3 &lt;</td>
<td>INT1</td>
<td>13</td>
</tr>
<tr style="text-align:center;">
<td>P3.4 &lt;</td>
<td>T0</td>
<td>14</td>
</tr>
<tr style="text-align:center;">
<td>P3.5 &lt;</td>
<td>T1</td>
<td>15</td>
</tr>
<tr style="text-align:center;">
<td>P3.6 &lt;</td>
<td>WR</td>
<td>16</td>
</tr>
<tr style="text-align:center;">
<td>P3.7 &lt;</td>
<td>Complement of RD</td>
<td>17</td>
</tr>
</table>
<h2>Dual Role of Port 0 and Port 2</h2>
<ul class="list">
<li><p><b>Dual role of Port 0</b> &minus; Port 0 is also designated as AD0–AD7, as it can be used for both data and address handling. While connecting an 8051 to external memory, Port 0 can provide both address and data. The 8051 microcontroller then multiplexes the input as address or data in order to save pins.</p></li>
<li><p><b>Dual role of Port 2</b> &minus; Besides working as I/O, Port P2 is also used to provide 16-bit address bus for external memory along with Port 0. Port P2 is also designated as (A8– A15), while Port 0 provides the lower 8-bits via A0–A7. In other words, we can say that when an 8051 is connected to an external memory (ROM) which can be maximum up to 64KB and this is possible by 16 bit address bus because we know 216 = 64KB. Port2 is used for the upper 8-bit of the 16 bits address, and it cannot be used for I/O and this is the way any Program code of external ROM is addressed.</p></li>
</ul>
<h2>Hardware Connection of Pins</h2>
<ul class="list">
<li><p><b>V<sub>cc</sub></b> &minus; Pin 40 provides supply to the Chip and it is +5 V.</p></li>
<li><p><b>Gnd</b> &minus; Pin 20 provides ground for the Reference.</p></li>
<li><p><b>XTAL1, XTAL2 (Pin no 18 &amp; Pin no 19)</b> &minus; 8051 has on-chip oscillator but requires external clock to run it. A quartz crystal is connected between the XTAL1 &amp; XTAL2 pin of the chip. This crystal also needs two capacitors of 30pF for generating a signal of desired frequency. One side of each capacitor is connected to ground. 8051 IC is available in various speeds and it all depends on this Quartz crystal, for example, a 20 MHz microcontroller requires a crystal with a frequency no more than 20 MHz.</p></li>
</ul>
<img src="/embedded_systems/images/xtal.jpg" alt="XTAL1, XTAL2 diagram" />
<ul class="list">
<li><p><b>RST (Pin No. 9)</b> &minus; It is an Input pin and active High pin. Upon applying a high pulse on this pin, that is 1, the microcontroller will reset and terminate all activities. This process is known as <b>Power-On Reset</b>. Activating a power-on reset will cause all values in the register to be lost. It will set a program counter to all 0's. To ensure a valid input of Reset, the high pulse must be high for a minimum of two machine cycles before it is allowed to go low, which depends on the capacitor value and the rate at which it charges. (<b>Machine Cycle</b> is the minimum amount of frequency a single instruction requires in execution).</p></li>
<li><p><b>EA or External Access (Pin No. 31)</b> &minus; It is an input pin. This pin is an active low pin; upon applying a low pulse, it gets activated. In case of microcontroller (8051/52) having on-chip ROM, the EA (bar) pin is connected to V<sub>cc</sub>. But in an 8031 microcontroller which does not have an on-chip ROM, the code is stored in an external ROM and then fetched by the microcontroller. In this case, we must connect the (pin no 31) EA to Gnd to indicate that the program code is stored externally.</p></li>
</ul>
<img src="/embedded_systems/images/rst.jpg" alt="RST, EA diagram" />
<ul class="list">
<li><p><b>PSEN or Program store Enable (Pin No 29)</b> &minus; This is also an active low pin, i.e., it gets activated after applying a low pulse. It is an output pin and used along with the EA pin in 8031 based (i.e. ROMLESS) Systems to allow storage of program code in external ROM.</p></li>
<li><p><b>ALE or (Address Latch Enable)</b> &minus; This is an Output Pin and is active high. It is especially used for 8031 IC to connect it to the external memory. It can be used while deciding whether P0 pins will be used as Address bus or Data bus. When ALE = 1, then the P0 pins work as Data bus and when ALE = 0, then the P0 pins act as Address bus.</p></li>
</ul>
<h2>I/O Ports and Bit Addressability</h2>
<p>It is a most widely used feature of 8051 while writing code for 8051. Sometimes we need to access only 1 or 2 bits of the port instead of the entire 8-bits. 8051 provides the capability to access individual bits of the ports.</p>
<p>While accessing a port in a single-bit manner, we use the syntax "SETB X. Y" where X is the port number (0 to 3), and Y is a bit number (0 to 7) for data bits D0-D7 where D0 is the LSB and D7 is the MSB. For example, "SETB P1.5" sets high bit 5 of port 1.</p>  
<p>The following code shows how we can toggle the bit P1.2 continuously.</p>
<pre class="result notranslate">
AGAIN: 
SETB    P1.2
ACALL   DELAY    
CLR     P1.2      
ACALL   DELAY 
SJMP    AGAIN
</pre>

<title>Embedded Systems Terms</title>

<h1>Embedded Systems - Terms</h1>

<h2>Program Counter</h2>

<p>The Program Counter is a 16- or 32-bit register which contains the address of the next instruction to be executed. The PC automatically increments to the next sequential memory location every time an instruction is fetched. Branch, jump, and interrupt operations load the Program Counter with an address other than the next sequential location.</p>

<p>Activating a power-on reset will cause all values in the register to be lost. It means the value of the PC (program counter) is 0 upon reset, forcing the CPU to fetch the first opcode from the ROM memory location 0000. It means we must place the first byte of upcode in ROM location 0000 because that is where the CPU expects to find the first instruction</p>

<h2>Reset Vector</h2>

<p>The significance of the reset vector is that it points the processor to the memory address which contains the firmware's first instruction. Without the Reset Vector, the processor would not know where to begin execution. Upon reset, the processor loads the Program Counter (PC) with the reset vector value from a predefined memory location. On CPU08 architecture, this is at location $FFFE:$FFFF.</p>

<p>When the reset vector is not necessary, developers normally take it for granted and don’t program into the final image. As a result, the processor doesn't start up on the final product. It is a common mistake that takes place during the debug phase.</p>

<h2>Stack Pointer</h2>

<p>Stack is implemented in RAM and a CPU register is used to access it called SP (Stack Pointer) register. SP register is an 8-bit register and can address memory addresses of range 00h to FFh. Initially, the SP register contains value 07 to point to location 08 as the first location being used for the stack by the 8051.</p>

<p>When the content of a CPU register is stored in a stack, it is called a PUSH operation. When the content of a stack is stored in a CPU register, it is called a POP operation. In other words, a register is pushed onto the stack to save it and popped off the stack to retrieve it.</p>

<h2>Infinite Loop</h2>

<p>An infinite loop or an endless loop can be identified as a sequence of instructions in a computer program that executes endlessly in a loop, because of the following reasons &minus;</p>

<p>Such infinite loops normally caused older operating systems to become unresponsive, as an infinite loop consumes all the available processor time. I/O operations waiting for user inputs are also called "infinite loops". One possible cause of a computer "freezing" is an infinite loop; other causes include <b>deadlock</b> and <b>access violations</b>.</p>

<p>Embedded systems, unlike a PC, never "exit" an application. They idle through an Infinite Loop waiting for an event to take place in the form of an interrupt, or a <b>pre-scheduled task</b>. In order to save power, some processors enter special <b>sleep</b> or <b>wait modes</b> instead of idling through an Infinite Loop, but they will come out of this mode upon either a timer or an External Interrupt.</p>

<h2>Interrupts</h2>

<p>Interrupts are mostly hardware mechanisms that instruct the program that an event has occurred. They may occur at any time, and are therefore asynchronous to the program flow. They require special handling by the processor, and are ultimately handled by a corresponding Interrupt Service Routine (ISR). Interrupts need to be handled quickly. If you take too much time servicing an interrupt, then you may miss another interrupt.</p>

<h2>Little Endian Vs Big Endian</h2>

<p>Although numbers are always displayed in the same way, they are not stored in the same way in memory. Big-Endian machines store the most significant byte of data in the lowest memory address. A Big-Endian machine stores 0x12345678 as &minus;</p>

<p>Little-Endian machines, on the other hand, store the least significant byte of data in the lowest memory address. A Little-Endian machine stores 0x12345678 as &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
ADD+0: 0x12 
ADD+1: 0x34 
ADD+2: 0x56 
ADD+3: 0x78
</pre>
<p>Little-Endian machines, on the other hand, store the least significant byte of data in the lowest memory address. A Little-Endian machine stores 0x12345678 as &minus;</p>
<pre class="result notranslate">
ADD+0: 0x78 
ADD+1: 0x56 
ADD+2: 0x34 
ADD+3: 0x12
</pre>

<title>Embedded Systems Assembly Language</title>

<h1>Embedded Systems - Assembly Language</h1>

<p>Assembly languages were developed to provide <b>mnemonics</b> or symbols for the machine level code instructions. Assembly language programs consist of mnemonics, thus they should be translated into machine code. A program that is responsible for this conversion is known as <b>assembler</b>. Assembly language is often termed as a low-level language because it directly works with the internal structure of the CPU. To program in assembly language, a programmer must know all the registers of the CPU.</p>

<p>Different programming languages such as C, C++, Java and various other languages are called high-level languages because they do not deal with the internal details of a CPU. In contrast, an assembler is used to translate an assembly language program into machine code (sometimes also called <b>object code</b> or <b>opcode</b>). Similarly, a compiler translates a high-level language into machine code. For example, to write a program in C language, one must use a C compiler to translate the program into machine language.</p>

<h2>Structure of Assembly Language</h2>

<p>An assembly language program is a series of statements, which are either assembly language instructions such as ADD and MOV, or statements called <b>directives</b>.</p>

<p>An <b>instruction</b> tells the CPU what to do, while a <b>directive</b> (also called <b>pseudo-instructions</b>) gives instruction to the assembler. For example, ADD and MOV instructions are commands which the CPU runs, while ORG and END are assembler directives. The assembler places the opcode to the memory location 0 when the ORG directive is used, while END indicates to the end of the source code. A program language instruction consists of the following four fields &minus;</p>

<p>A square bracket ( [ ] ) indicates that the field is optional.</p>

<p>The <b>label field</b> allows the program to refer to a line of code by name. The label fields cannot exceed a certain number of characters.</p>

<p>The <b>mnemonics</b> and <b>operands fields</b> together perform the real work of the program and accomplish the tasks. Statements like ADD A , C &amp; MOV C, #68 where ADD and MOV are the mnemonics, which produce opcodes ; "A, C" and "C, #68" are operands. These two fields could contain directives. Directives do not generate machine code and are used only by the assembler, whereas instructions are translated into machine code for the CPU to execute.</p>

<p>The <b>comment field</b> begins with a semicolon which is a comment indicator.</p>

<p>Notice the Label "HERE" in the program. Any label which refers to an instruction should be followed by a colon.</p>

<h2>Assembling and Running an 8051 Program</h2>

<p>Here we will discuss about the basic form of an assembly language. The steps to create, assemble, and run an assembly language program are as follows &minus;</p>

<p>First, we use an editor to type in a program similar to the above program. Editors like MS-DOS EDIT program that comes with all Microsoft operating systems can be used to create or edit a program. The Editor must be able to produce an ASCII file. The "asm" extension for the source file is used by an assembler in the next step.</p>

<p>The "asm" source file contains the program code created in Step 1. It is fed to an 8051 assembler. The assembler then converts the assembly language instructions into machine code instructions and produces an <b>.obj file</b> (object file) and a <b>.lst file</b> (list file). It is also called as a <b>source file</b>, that's why some assemblers require that this file have the "src" extensions. The "lst" file is optional. It is very useful to the program because it lists all the opcodes and addresses as well as errors that the assemblers detected.</p>

<p>Assemblers require a third step called <b>linking</b>. The link program takes one or more object files and produces an absolute object file with the extension "abs".</p>

<p>Next, the "abs" file is fed to a program called "OH" (object to hex converter), which creates a file with the extension "hex" that is ready to burn in to the ROM.</p>

<h2>Data Type</h2>

<p>The 8051 microcontroller contains a single data type of 8-bits, and each register is also of 8-bits size. The programmer has to break down data larger than 8-bits (00 to FFH, or to 255 in decimal) so that it can be processed by the CPU.</p>

<h3>DB (Define Byte)</h3>

<p>The DB directive is the most widely used data directive in the assembler. It is used to define the 8-bit data. It can also be used to define decimal, binary, hex, or ASCII formats data. For decimal, the "D" after the decimal number is optional, but it is required for "B" (binary) and "Hl" (hexadecimal).</p>

<p>To indicate ASCII, simply place the characters in quotation marks ('like this'). The assembler generates ASCII code for the numbers/characters automatically. The DB directive is the only directive that can be used to define ASCII strings larger than two characters; therefore, it should be used for all the ASCII data definitions. Some examples of DB are given below &minus;</p>

<p>Either single or double quotes can be used around ASCII strings. DB is also used to allocate memory in byte-sized chunks.</p>

<h2>Assembler Directives</h2>

<p>Some of the directives of 8051 are as follows &minus;</p>

<p><b>ORG (origin)</b> &minus; The origin directive is used to indicate the beginning of the address. It takes the numbers in hexa or decimal format. If H is provided after the number, the number is treated as hexa, otherwise decimal. The assembler converts the decimal number to hexa.</p>

<p><b>EQU (equate)</b> &minus; It is used to define a constant without occupying a memory location. EQU associates a constant value with a data label so that the label appears in the program, its constant value will be substituted for the label. While executing the instruction "MOV R3, #COUNT", the register R3 will be loaded with the value 25 (notice the # sign). The advantage of using EQU is that the programmer can change it once and the assembler will change all of its occurrences; the programmer does not have to search the entire program.</p>

<p><b>END directive</b> &minus; It indicates the end of the source (asm) file. The END directive is the last line of the program; anything after the END directive is ignored by the assembler.</p>

<h2>Labels in Assembly Language</h2>

<p>All the labels in assembly language must follow the rules given below &minus;</p>

<p>Each label name must be unique. The names used for labels in assembly language programming consist of alphabetic letters in both uppercase and lowercase, number 0 through 9, and special characters such as question mark (?), period (.), at the rate @, underscore (_), and dollar($).</p>

<p>The first character should be in alphabetical character; it cannot be a number.</p>

<p>Reserved words cannot be used as a label in the program. For example, ADD and MOV words are the reserved words, since they are instruction mnemonics.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
[ label: ]   mnemonics  [ operands ]   [;comment ] 
</pre>
<p>A square bracket ( [ ] ) indicates that the field is optional.</p>
<ul class="list">
<li><p>The <b>label field</b> allows the program to refer to a line of code by name. The label fields cannot exceed a certain number of characters.</p></li>
<li><p>The <b>mnemonics</b> and <b>operands fields</b> together perform the real work of the program and accomplish the tasks. Statements like ADD A , C &amp; MOV C, #68 where ADD and MOV are the mnemonics, which produce opcodes ; "A, C" and "C, #68" are operands. These two fields could contain directives. Directives do not generate machine code and are used only by the assembler, whereas instructions are translated into machine code for the CPU to execute.</p></li>
</ul>
<pre class="result notranslate">
1.0000         ORG  0H            ;start (origin) at location 0 
2 0000 7D25    MOV  R5,#25H       ;load 25H into R5 
3.0002 7F34    MOV  R7,#34H       ;load 34H into  R7 
4.0004 7400    MOV  A,#0          ;load 0 into A 
5.0006 2D      ADD  A,R5          ;add contents of R5 to A 
6.0007 2F      ADD  A,R7          ;add contents of R7 to A
7.0008 2412    ADD  A,#12H        ;add to A value 12 H 
8.000A 80FE    HERE: SJMP HERE    ;stay in this loop 
9.000C END                        ;end of asm source file
</pre>
<ul class="list">
<li><p>The <b>comment field</b> begins with a semicolon which is a comment indicator.</p></li>
<li><p>Notice the Label "HERE" in the program. Any label which refers to an instruction should be followed by a colon.</p></li>
</ul>
<h2>Assembling and Running an 8051 Program</h2>
<p>Here we will discuss about the basic form of an assembly language. The steps to create, assemble, and run an assembly language program are as follows &minus;</p>
<ul class="list">
<li><p>First, we use an editor to type in a program similar to the above program. Editors like MS-DOS EDIT program that comes with all Microsoft operating systems can be used to create or edit a program. The Editor must be able to produce an ASCII file. The "asm" extension for the source file is used by an assembler in the next step.</p></li>
<li><p>The "asm" source file contains the program code created in Step 1. It is fed to an 8051 assembler. The assembler then converts the assembly language instructions into machine code instructions and produces an <b>.obj file</b> (object file) and a <b>.lst file</b> (list file). It is also called as a <b>source file</b>, that's why some assemblers require that this file have the "src" extensions. The "lst" file is optional. It is very useful to the program because it lists all the opcodes and addresses as well as errors that the assemblers detected.</p></li> 
<li><p>Assemblers require a third step called <b>linking</b>. The link program takes one or more object files and produces an absolute object file with the extension "abs".</p></li>  
<li><p>Next, the "abs" file is fed to a program called "OH" (object to hex converter), which creates a file with the extension "hex" that is ready to burn in to the ROM.</p></li>
</ul>
<img src="/embedded_systems/images/steps_program.jpg" alt="Steps to create program" />
<h2>Data Type</h2>
<p>The 8051 microcontroller contains a single data type of 8-bits, and each register is also of 8-bits size. The programmer has to break down data larger than 8-bits (00 to FFH, or to 255 in decimal) so that it can be processed by the CPU.</p>
<h3>DB (Define Byte)</h3>
<p>The DB directive is the most widely used data directive in the assembler. It is used to define the 8-bit data. It can also be used to define decimal, binary, hex, or ASCII formats data. For decimal, the "D" after the decimal number is optional, but it is required for "B" (binary) and "Hl" (hexadecimal).</p>
<p>To indicate ASCII, simply place the characters in quotation marks ('like this'). The assembler generates ASCII code for the numbers/characters automatically. The DB directive is the only directive that can be used to define ASCII strings larger than two characters; therefore, it should be used for all the ASCII data definitions. Some examples of DB are given below &minus;</p>
<pre class="result notranslate">
        ORG  500H 
DATA1:  DB   28                     ;DECIMAL (1C in hex) 
DATA2:  DB   00110101B              ;BINARY  (35 in hex) 
DATA3:  DB   39H                    ;HEX 
        ORG  510H 
DATA4:  DB   "2591"                 ;ASCII  NUMBERS 
        ORG  520H                         
DATA6:  DA   "MY NAME IS Michael"   ;ASCII CHARACTERS 
</pre>

<title>Embedded Systems Registers</title>

<h1>Embedded Systems - Registers</h1>

<p>Registers are used in the CPU to store information on temporarily basis which could be data to be processed, or an address pointing to the data which is to be fetched. In 8051, there is one data type is of 8-bits, from the MSB (most significant bit) D7 to the LSB (least significant bit) D0. With 8-bit data type, any data type larger than 8-bits must be broken into 8-bit chunks before it is processed.</p>

<p>The most widely used registers of the 8051 are A (accumulator), B, R0-R7, DPTR (data pointer), and PC (program counter). All these registers are of 8-bits, except DPTR and PC.</p>

<h2>Storage Registers in 8051</h2>

<p>We will discuss the following types of storage registers here &minus;</p>

<h3>Accumulator</h3>

<p>The accumulator, register A, is used for all arithmetic and logic operations. If the accumulator is not present, then every result of each calculation (addition, multiplication, shift, etc.) is to be stored into the main memory. Access to main memory is slower than access to a register like the accumulator because the technology used for the large main memory is slower (but cheaper) than that used for a register.</p>

<h3>The "R" Registers</h3>

<p>The "R" registers are a set of eight registers, namely, R0, R1 to R7. These registers function as auxiliary or temporary storage registers in many operations. Consider an example of the sum of 10 and 20. Store a variable 10 in an accumulator and another variable 20 in, say, register R4. To process the addition operation, execute the following command &minus;</p>

<p>After executing this instruction, the accumulator will contain the value 30. Thus "R" registers are very important auxiliary or <b>helper registers</b>. The Accumulator alone would not be very useful if it were not for these "R" registers. The "R" registers are meant for temporarily storage of values.</p>

<p>Let us take another example. We will add the values in R1 and R2 together and then subtract the values of R3 and R4 from the result.</p>

<p>As you can see, we used R5 to temporarily hold the sum of R3 and R4. Of course, this is not the most efficient way to calculate (R1 + R2) – (R3 + R4), but it does illustrate the use of the "R" registers as a way to store values temporarily.</p>

<h3>The "B" Register</h3>

<p>The "B" register is very similar to the Accumulator in the sense that it may hold an 8-bit (1-byte) value. The "B" register is used only by two 8051 instructions: <b>MUL AB</b> and <b>DIV AB</b>. To quickly and easily multiply or divide A by another number, you may store the other number in "B" and make use of these two instructions. Apart from using MUL and DIV instructions, the "B" register is often used as yet another temporary storage register, much like a ninth R register.</p>

<h3>The Data Pointer</h3>

<p>The Data Pointer (DPTR) is the 8051’s only user-accessible 16-bit (2-byte) register. The Accumulator, R0–R7 registers and B register are 1-byte value registers. DPTR is meant for pointing to data. It is used by the 8051 to access external memory using the address indicated by DPTR. DPTR is the only 16-bit register available and is often used to store 2-byte values.</p>

<h3>The Program Counter</h3>

<p>The Program Counter (PC) is a 2-byte address which tells the 8051 where the next instruction to execute can be found in the memory. PC starts at 0000h when the 8051 initializes and is incremented every time after an instruction is executed. PC is not always incremented by 1. Some instructions may require 2 or 3 bytes; in such cases, the PC will be incremented by 2 or 3.</p>

<p><b>Branch, jump</b>, and <b>interrupt</b> operations load the Program Counter with an address other than the next sequential location. Activating a power-on reset will cause all values in the register to be lost. It means the value of the PC is 0 upon reset, forcing the CPU to fetch the first opcode from the ROM location 0000. It means we must place the first byte of upcode in ROM location 0000 because that is where the CPU expects to find the first instruction.</p>

<h3>The Stack Pointer (SP)</h3>

<p>The Stack Pointer, like all registers except DPTR and PC, may hold an 8-bit (1-byte) value. The Stack Pointer tells the location from where the next value is to be removed from the stack. When a value is pushed onto the stack, the value of SP is incremented and then the value is stored at the resulting memory location. When a value is popped off the stack, the value is returned from the memory location indicated by SP, and then the value of SP is decremented.</p>

<p>This order of operation is important. SP will be initialized to 07h when the 8051 is initialized. If a value is pushed onto the stack at the same time, the value will be stored in the internal RAM address 08h because the 8051 will first increment the value of SP (from 07h to 08h) and then will store the pushed value at that memory address (08h). SP is modified directly by the 8051 by six instructions: PUSH, POP, ACALL, LCALL, RET, and RETI.</p>

<h2>ROM Space in 8051</h2>

<p>Some family members of 8051 have only 4K bytes of on-chip ROM (e.g. 8751, AT8951); some have 8K ROM like AT89C52, and there are some family members with 32K bytes and 64K bytes of on-chip ROM such as Dallas Semiconductor. The point to remember is that no member of the 8051 family can access more than 64K bytes of opcode since the program counter in 8051 is a 16-bit register (0000 to FFFF address).</p>

<p>The first location of the program ROM inside the 8051 has the address of 0000H, whereas the last location can be different depending on the size of the ROM on the chip. Among the 8051 family members, AT8951 has $k bytes of on-chip ROM having a memory address of 0000 (first location) to 0FFFH (last location).</p>

<h3>8051 Flag Bits and PSW Register</h3>

<p>The program status word (PSW) register is an 8-bit register, also known as <b>flag register</b>. It is of 8-bit wide but only 6-bit of it is used. The two unused bits are <b>user-defined flags</b>. Four of the flags are called <b>conditional flags</b>, which means that they indicate a condition which results after an instruction is executed. These four are <b>CY </b>(Carry), <b>AC</b> (auxiliary carry), <b>P</b> (parity), and <b>OV</b> (overflow). The bits RS0 and RS1 are used to change the bank registers. The following figure shows the program status word register.</p>

<p>The PSW Register contains that status bits that reflect the current status of the CPU.</p>

<p></p>

<p>We can select the corresponding Register Bank bit using RS0 and RS1 bits.</p>

<p><b>CY, the carry flag</b> &minus; This carry flag is set (1) whenever there is a carry out from the D7 bit. It is affected after an 8-bit addition or subtraction operation. It can also be reset to 1 or 0 directly by an instruction such as "SETB C" and "CLR C" where "SETB" stands for set bit carry and "CLR" stands for clear carry.</p>

<p><b>AC, auxiliary carry flag</b> &minus; If there is a carry from D3 and D4 during an ADD or SUB operation, the AC bit is set; otherwise, it is cleared. It is used for the instruction to perform binary coded decimal arithmetic.</p>

<p><b>P, the parity flag</b> &minus; The parity flag represents the number of 1's in the accumulator register only. If the A register contains odd number of 1's, then P = 1; and for even number of 1's, P = 0.</p>

<p><b>OV, the overflow flag</b> &minus; This flag is set whenever the result of a signed number operation is too large causing the high-order bit to overflow into the sign bit. It is used only to detect errors in signed arithmetic operations.</p>

<h3>Example</h3>

<p>Show the status of CY, AC, and P flags after the addition of 9CH and 64H in the following instruction.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
ADD A,R4
</pre>
<p>After executing this instruction, the accumulator will contain the value 30. Thus "R" registers are very important auxiliary or <b>helper registers</b>. The Accumulator alone would not be very useful if it were not for these "R" registers. The "R" registers are meant for temporarily storage of values.</p>
<p>Let us take another example. We will add the values in R1 and R2 together and then subtract the values of R3 and R4 from the result.</p>
<pre class="result notranslate">
MOV A,R3   ;Move the value of R3 into the accumulator 
ADD A,R4   ;Add the value of R4 
MOV R5,A   ;Store the resulting value temporarily in R5 
MOV A,R1   ;Move the value of R1 into the accumulator 
ADD A,R2   ;Add the value of R2 
SUBB A,R5  ;Subtract the value of R5 (which now contains R3 + R4)
</pre>
<p>As you can see, we used R5 to temporarily hold the sum of R3 and R4. Of course, this is not the most efficient way to calculate (R1 + R2) – (R3 + R4), but it does illustrate the use of the "R" registers as a way to store values temporarily.</p>
<img src="/embedded_systems/images/8bit_registers.jpg" alt="8 Bit registers" />
<h3>The "B" Register</h3> 
<p>The "B" register is very similar to the Accumulator in the sense that it may hold an 8-bit (1-byte) value. The "B" register is used only by two 8051 instructions: <b>MUL AB</b> and <b>DIV AB</b>. To quickly and easily multiply or divide A by another number, you may store the other number in "B" and make use of these two instructions. Apart from using MUL and DIV instructions, the "B" register is often used as yet another temporary storage register, much like a ninth R register.</p> 
<h3>The Data Pointer</h3>
<p>The Data Pointer (DPTR) is the 8051’s only user-accessible 16-bit (2-byte) register. The Accumulator, R0–R7 registers and B register are 1-byte value registers. DPTR is meant for pointing to data. It is used by the 8051 to access external memory using the address indicated by DPTR. DPTR is the only 16-bit register available and is often used to store 2-byte values.</p>
<h3>The Program Counter</h3>
<p>The Program Counter (PC) is a 2-byte address which tells the 8051 where the next instruction to execute can be found in the memory. PC starts at 0000h when the 8051 initializes and is incremented every time after an instruction is executed. PC is not always incremented by 1. Some instructions may require 2 or 3 bytes; in such cases, the PC will be incremented by 2 or 3.</p> 
<p><b>Branch, jump</b>, and <b>interrupt</b> operations load the Program Counter with an address other than the next sequential location. Activating a power-on reset will cause all values in the register to be lost. It means the value of the PC is 0 upon reset, forcing the CPU to fetch the first opcode from the ROM location 0000. It means we must place the first byte of upcode in ROM location 0000 because that is where the CPU expects to find the first instruction.</p>
<h3>The Stack Pointer (SP)</h3> 
<p>The Stack Pointer, like all registers except DPTR and PC, may hold an 8-bit (1-byte) value. The Stack Pointer tells the location from where the next value is to be removed from the stack. When a value is pushed onto the stack, the value of SP is incremented and then the value is stored at the resulting memory location. When a value is popped off the stack, the value is returned from the memory location indicated by SP, and then the value of SP is decremented.</p> 
<p>This order of operation is important. SP will be initialized to 07h when the 8051 is initialized. If a value is pushed onto the stack at the same time, the value will be stored in the internal RAM address 08h because the 8051 will first increment the value of SP (from 07h to 08h) and then will store the pushed value at that memory address (08h). SP is modified directly by the 8051 by six instructions: PUSH, POP, ACALL, LCALL, RET, and RETI.</p>
<h2>ROM Space in 8051</h2>
<p>Some family members of 8051 have only 4K bytes of on-chip ROM (e.g. 8751, AT8951); some have 8K ROM like AT89C52, and there are some family members with 32K bytes and 64K bytes of on-chip ROM such as Dallas Semiconductor. The point to remember is that no member of the 8051 family can access more than 64K bytes of opcode since the program counter in 8051 is a 16-bit register (0000 to FFFF address).</p>
<p>The first location of the program ROM inside the 8051 has the address of 0000H, whereas the last location can be different depending on the size of the ROM on the chip. Among the 8051 family members, AT8951 has $k bytes of on-chip ROM having a memory address of 0000 (first location) to 0FFFH (last location).</p>
<img src="/embedded_systems/images/rom_space.jpg" alt="ROM Space" />
<h3>8051 Flag Bits and PSW Register</h3> 
<p>The program status word (PSW) register is an 8-bit register, also known as <b>flag register</b>. It is of 8-bit wide but only 6-bit of it is used. The two unused bits are <b>user-defined flags</b>. Four of the flags are called <b>conditional flags</b>, which means that they indicate a condition which results after an instruction is executed. These four are <b>CY </b>(Carry), <b>AC</b> (auxiliary carry), <b>P</b> (parity), and <b>OV</b> (overflow). The bits RS0 and RS1 are used to change the bank registers. The following figure shows the program status word register.</p>
<p>The PSW Register contains that status bits that reflect the current status of the CPU.</p>
<table class="table table-bordered">
<tr>
<th>CY</th>
<th>CA</th>
<th>F0</th>
<th>RS1</th>
<th>RS0</th>
<th>OV</th>
<th>-</th>
<th>P</th>
</tr>
</table>
<p></p>
<table class="table table-bordered">
<tr>
<td>CY</td>
<td>PSW.7</td>
<td>Carry Flag</td>
</tr>
<tr>
<td>AC</td>
<td>PSW.6</td>
<td>Auxiliary Carry Flag</td>
</tr>
<tr>
<td>F0</td>
<td>PSW.5</td>
<td>Flag 0 available to user for general purpose.</td>
</tr>
<tr>
<td>RS1</td>
<td>PSW.4</td>
<td>Register Bank selector bit 1</td>
</tr>
<tr>
<td>RS0</td>
<td>PSW.3</td>
<td>Register Bank selector bit 0</td>
</tr>
<tr>
<td>OV</td>
<td>PSW.2</td>
<td>Overflow Flag</td>
</tr>
<tr>
<td>-</td>
<td>PSW.1</td>
<td>User definable FLAG</td>
</tr>
<tr>
<td>P</td>
<td>PSW.0</td>
<td>Parity FLAG. Set/ cleared by hardware during instruction cycle to indicate even/odd number of 1 bit in accumulator.</td>
</tr>
</table>
<p>We can select the corresponding Register Bank bit using RS0 and RS1 bits.</p>
<table class="table table-bordered">
<tr>
<th style="text-align:center;">RS1</th>
<th style="text-align:center;">RS2</th>
<th style="text-align:center;">Register Bank</th>
<th style="text-align:center;">Address</th>
</tr>
<tr style="text-align:center;">
<td>0</td>
<td>0</td>
<td>0</td>
<td>00H-07H</td>
</tr>
<tr style="text-align:center;">
<td>0</td>
<td>1</td>
<td>1</td>
<td>08H-0FH</td>
</tr>
<tr style="text-align:center;">
<td>1</td>
<td>0</td>
<td>2</td>
<td>10H-17H</td>
</tr>
<tr style="text-align:center;">
<td>1</td>
<td>1</td>
<td>3</td>
<td>18H-1FH</td>
</tr>
</table>
<ul class="list">
<li><p><b>CY, the carry flag</b> &minus; This carry flag is set (1) whenever there is a carry out from the D7 bit. It is affected after an 8-bit addition or subtraction operation. It can also be reset to 1 or 0 directly by an instruction such as "SETB C" and "CLR C" where "SETB" stands for set bit carry and "CLR" stands for clear carry.</p></li>
<li><p><b>AC, auxiliary carry flag</b> &minus; If there is a carry from D3 and D4 during an ADD or SUB operation, the AC bit is set; otherwise, it is cleared. It is used for the instruction to perform binary coded decimal arithmetic.</p></li>
<li><p><b>P, the parity flag</b> &minus; The parity flag represents the number of 1's in the accumulator register only. If the A register contains odd number of 1's, then P = 1; and for even number of 1's, P = 0.</p></li>
<li><p><b>OV, the overflow flag</b> &minus; This flag is set whenever the result of a signed number operation is too large causing the high-order bit to overflow into the sign bit. It is used only to detect errors in signed arithmetic operations.</p></li>
</ul>
<h3>Example</h3> 
<p>Show the status of CY, AC, and P flags after the addition of 9CH and 64H in the following instruction.</p>
<p style="padding-left:10%;">MOV A, #9CH</p>
<p style="padding-left:10%;">ADD A, # 64H</p>
<pre class="result notranslate">
Solution:  9C   10011100 
          +64   01100100 
          100   00000000 
			 
CY = 1 since there is a carry beyond D7 bit  
AC = 0 since there is a carry from D3 to D4 
P  = 0 because the accumulator has even number of 1's 
</pre>

<title>Embedded Systems Registers Bank/Stack</title>

<h1>Embedded Systems - Registers Bank/Stack</h1>

<p>The 8051 microcontroller has a total of 128 bytes of RAM. We will discuss about the allocation of these 128 bytes of RAM and examine their usage as stack and register.</p>

<h2>RAM Memory Space Allocation in 8051</h2>

<p>The 128 bytes of RAM inside the 8051 are assigned the address 00 to 7FH. They can be accessed directly as memory locations and are divided into three different groups as follows &minus;</p>

<p>32 bytes from 00H to 1FH locations are set aside for register banks and the stack.</p>

<p>16 bytes from 20H to 2FH locations are set aside for bit-addressable read/write memory.</p>

<p>80 bytes from 30H to 7FH locations are used for read and write storage; it is called as <b>scratch pad</b>. These 80 locations RAM are widely used for the purpose of storing data and parameters by 8051 programmers.</p>

<h2>Register Banks in 8051</h2>

<p>A total of 32 bytes of RAM are set aside for the register banks and the stack. These 32 bytes are divided into four register banks in which each bank has 8 registers, R0–R7. RAM locations from 0 to 7 are set aside for bank 0 of R0–R7 where R0 is RAM location 0, R1 is RAM location 1, R2 is location 2, and so on, until the memory location 7, which belongs to R7 of bank 0.</p>

<p>The second bank of registers R0–R7 starts at RAM location 08 and goes to locations OFH. The third bank of R0–R7 starts at memory location 10H and goes to location to 17H. Finally, RAM locations 18H to 1FH are set aside for the fourth bank of R0–R7.</p>

<h2>Default Register Bank</h2>

<p>If RAM locations 00–1F are set aside for the four registers banks, which register bank of R0–R7 do we have access to when the 8051 is powered up? The answer is register bank 0; that is, RAM locations from 0 to 7 are accessed with the names R0 to R7 when programming the 8051. Because it is much easier to refer these RAM locations by names such as R0 to R7, rather than by their memory locations.</p>

<h2>How to Switch Register Banks</h2>

<p>Register bank 0 is the default when the 8051 is powered up. We can switch to the other banks using PSW register. D4 and D3 bits of the PSW are used to select the desired register bank, since they can be accessed by the bit addressable instructions SETB and CLR. For example, "SETB PSW.3" will set PSW.3 = 1 and select the bank register 1.</p>

<h2>Stack and its Operations</h2>

<h3>Stack in the 8051</h3>

<p>The stack is a section of a RAM used by the CPU to store information such as data or memory address on temporary basis. The CPU needs this storage area considering limited number of registers.</p>

<h3>How Stacks are Accessed</h3>

<p>As the stack is a section of a RAM, there are registers inside the CPU to point to it. The register used to access the stack is known as the stack pointer register. The stack pointer in the 8051 is 8-bits wide, and it can take a value of 00 to FFH. When the 8051 is initialized, the SP register contains the value 07H. This means that the RAM location 08 is the first location used for the stack. The storing operation of a CPU register in the stack is known as a <b>PUSH</b>, and getting the contents from the stack back into a CPU register is called a <b>POP</b>.</p>

<h3>Pushing into the Stack</h3>

<p>In the 8051, the stack pointer (SP) points to the last used location of the stack. When data is pushed onto the stack, the stack pointer (SP) is incremented by 1. When PUSH is executed, the contents of the register are saved on the stack and SP is incremented by 1. To push the registers onto the stack, we must use their RAM addresses. For example, the instruction "PUSH 1" pushes register R1 onto the stack.</p>

<h3>Popping from the Stack</h3>

<p>Popping the contents of the stack back into a given register is the opposite to the process of pushing. With every pop operation, the top byte of the stack is copied to the register specified by the instruction and the stack pointer is decremented once.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Embedded Systems Instructions</title>

<h1>Embedded Systems - Instructions</h1>

<p>The flow of program proceeds in a sequential manner, from one instruction to the next instruction, unless a control transfer instruction is executed. The various types of control transfer instruction in assembly language include conditional or unconditional jumps and call instructions.</p>

<h2>Loop and Jump Instructions</h2>

<h3>Looping in the 8051</h3>

<p>Repeating a sequence of instructions a certain number of times is called a <b>loop</b>. An instruction <b>DJNZ reg, label</b> is used to perform a Loop operation. In this instruction, a register is decremented by 1; if it is not zero, then 8051 jumps to the target address referred to by the label.</p>

<p>The register is loaded with the counter for the number of repetitions prior to the start of the loop. In this instruction, both the registers decrement and the decision to jump are combined into a single instruction. The registers can be any of R0–R7. The counter can also be a RAM location.</p>

<h3>Example</h3>

<p><b>Multiply 25 by 10 using the technique of repeated addition.</b></p>

<p><b>Solution</b> &minus; Multiplication can be achieved by adding the multiplicand repeatedly, as many times as the multiplier. For example,</p>

<p>25 * 10 = 250(FAH)</p>

<p>25 + 25 + 25 + 25 + 25 + 25 + 25 + 25 + 25 + 25 = 250</p>

<p><b>Drawback in 8051</b> &minus; Looping action with the instruction <b>DJNZ Reg label</b> is limited to 256 iterations only. If a conditional jump is not taken, then the instruction following the jump is executed.</p>

<h3>Looping inside a Loop</h3>

<p>When we use a loop inside another loop, it is called a <b>nested loop</b>. Two registers are used to hold the count when the maximum count is limited to 256. So we use this method to repeat the action more times than 256.</p>

<p><b>Example</b></p>

<p>Write a program to &minus;</p>

<p><b>Solution</b> &minus; Since 700 is greater than 255 (the maximum capacity of any register), two registers are used to hold the count. The following code shows how to use two registers, R2 and R3, for the count.</p>

<h2>Other Conditional Jumps</h2>

<p>The following table lists the conditional jumps used in 8051 &minus;</p>

<p><b>JZ (jump if A = 0)</b> &minus; In this instruction, the content of the accumulator is checked. If it is zero, then the 8051 jumps to the target address. JZ instruction can be used only for the accumulator, it does not apply to any other register.</p>

<p><b>JNZ (jump if A is not equal to 0)</b> &minus; In this instruction, the content of the accumulator is checked to be non-zero. If it is not zero, then the 8051 jumps to the target address.</p>

<p><b>JNC (Jump if no carry, jumps if CY = 0)</b> &minus; The Carry flag bit in the flag (or PSW) register is used to make the decision whether to jump or not "JNC label". The CPU looks at the carry flag to see if it is raised (CY = 1). If it is not raised, then the CPU starts to fetch and execute instructions from the address of the label. If CY = 1, it will not jump but will execute the next instruction below JNC.</p>

<p><b>JC (Jump if carry, jumps if CY = 1)</b> &minus; If CY = 1, it jumps to the target address.</p>

<p><b>JB (jump if bit is high)</b></p>

<p><b>JNB (jump if bit is low)</b></p>

<p><b>Note</b> &minus; It must be noted that all conditional jumps are short jumps, i.e., the address of the target must be within –128 to +127 bytes of the contents of the program counter.</p>

<h2>Unconditional Jump Instructions</h2>

<p>There are two unconditional jumps in 8051 &minus;</p>

<p><b>LJMP (long jump)</b> &minus; LJMP is 3-byte instruction in which the first byte represents opcode, and the second and third bytes represent the 16-bit address of the target location. The 2-byte target address is to allow a jump to any memory location from 0000 to FFFFH.</p>

<p><b>SJMP (short jump)</b> &minus; It is a 2-byte instruction where the first byte is the opcode and the second byte is the relative address of the target location. The relative address ranges from 00H to FFH which is divided into forward and backward jumps; that is, within –128 to +127 bytes of memory relative to the address of the current PC (program counter). In case of forward jump, the target address can be within a space of 127 bytes from the current PC. In case of backward jump, the target address can be within –128 bytes from the current PC.</p>

<h2>Calculating the Short Jump Address</h2>

<p>All conditional jumps (JNC, JZ, and DJNZ) are short jumps because they are 2-byte instructions. In these instructions, the first byte represents opcode and the second byte represents the relative address. The target address is always relative to the value of the program counter. To calculate the target address, the second byte is added to the PC of the instruction immediately below the jump. Take a look at the program given below &minus;</p>

<h3>Backward Jump Target Address Calculation</h3>

<p>In case of a forward jump, the displacement value is a positive number between 0 to 127 (00 to 7F in hex). However, for a backward jump, the displacement is a negative value of 0 to –128.</p>

<h2>CALL Instructions</h2>

<p>CALL is used to call a subroutine or method. Subroutines are used to perform operations or tasks that need to be performed frequently. This makes a program more structured and saves memory space. There are two instructions &minus; LCALL and ACALL.</p>

<h3>LCALL (Long Call)</h3>

<p>LCALL is a 3-byte instruction where the first byte represents the opcode and the second and third bytes are used to provide the address of the target subroutine. LCALL can be used to call subroutines which are available within the 64K-byte address space of the 8051.</p>

<p>To make a successful return to the point after execution of the called subroutine, the CPU saves the address of the instruction immediately below the LCALL on the stack. Thus, when a subroutine is called, the control is transferred to that subroutine, and the processor saves the PC (program counter) on the stack and begins to fetch instructions from the new location. The instruction RET (return) transfers the control back to the caller after finishing execution of the subroutine. Every subroutine uses RET as the last instruction.</p>

<h3>ACALL (Absolute Call)</h3>

<p>ACALL is a 2-byte instruction, in contrast to LCALL which is 3 bytes. The target address of the subroutine must be within 2K bytes because only 11 bits of the 2 bytes are used for address. The difference between the ACALL and LCALL is that the target address for LCALL can be anywhere within the 64K-bytes address space of the 8051, while the target address of CALL is within a 2K-byte range.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
   MOV A,#0             ;A = 0,clean ACC 
   MOV R2,#10           ; the multiplier is replaced in R2 
   Add A,#25            ;add the multiplicand to the ACC 
	
AGAIN:DJNZ R2, 
AGAIN:repeat  until R2 = 0 (10 times) 

   MOV R5 , A           ;save A in R5 ;R5 (FAH)
</pre>
<p><b>Drawback in 8051</b> &minus; Looping action with the instruction <b>DJNZ Reg label</b> is limited to 256 iterations only. If a conditional jump is not taken, then the instruction following the jump is executed.</p>
<h3>Looping inside a Loop</h3> 
<p>When we use a loop inside another loop, it is called a <b>nested loop</b>. Two registers are used to hold the count when the maximum count is limited to 256. So we use this method to repeat the action more times than 256.</p>
<p><b>Example</b></p>
<p>Write a program to &minus;</p>
<ul class="list">
<li>Load the accumulator with the value 55H.</li>
<li>Complement the ACC 700 times.</li>
</ul>
<p><b>Solution</b> &minus; Since 700 is greater than 255 (the maximum capacity of any register), two registers are used to hold the count. The following code shows how to use two registers, R2 and R3, for the count.</p>
<pre class="prettyprint notranslate">
   MOV A,#55H            ;A = 55H 
	
NEXT: MOV R3,#10         ;R3 the outer loop counter 
AGAIN:MOV R2,#70         ;R2 the inner loop counter 

   CPL A                 ;complement
</pre>
<h2>Other Conditional Jumps</h2>
<p>The following table lists the conditional jumps used in 8051 &minus;</p>
<table class="table table-bordered">
<tr>
<th>Instruction</th>
<th>Action</th>
</tr>
<tr>
<td>JZ</td>
<td>Jump if A = 0</td>
</tr>
<tr>
<td>JNZ</td>
<td>Jump if A &ne; 0</td>
</tr>
<tr>
<td>DJNZ</td>
<td>Decrement and Jump if register &ne; 0</td>
</tr>
<tr>
<td>CJNE A, data</td>
<td>Jump if A &ne; data</td>
</tr>
<tr>
<td>CJNE reg, #data</td>
<td>Jump if byte &ne; data</td>
</tr>
<tr>
<td>JC</td>
<td>Jump if CY = 1</td>
</tr>
<tr>
<td>JNC</td>
<td>Jump if CY &ne; 1</td>
</tr>
<tr>
<td>JB</td>
<td>Jump if bit = 1</td>
</tr>
<tr>
<td>JNB</td>
<td>Jump if bit = 0</td>
</tr>
<tr>
<td>JBC</td>
<td>Jump if bit = 1 and clear bit</td>
</tr>
</table>
<ul class="list">
<li><p><b>JZ (jump if A = 0)</b> &minus; In this instruction, the content of the accumulator is checked. If it is zero, then the 8051 jumps to the target address. JZ instruction can be used only for the accumulator, it does not apply to any other register.</p></li>
<li><p><b>JNZ (jump if A is not equal to 0)</b> &minus; In this instruction, the content of the accumulator is checked to be non-zero. If it is not zero, then the 8051 jumps to the target address.</p></li>
<li><p><b>JNC (Jump if no carry, jumps if CY = 0)</b> &minus; The Carry flag bit in the flag (or PSW) register is used to make the decision whether to jump or not "JNC label". The CPU looks at the carry flag to see if it is raised (CY = 1). If it is not raised, then the CPU starts to fetch and execute instructions from the address of the label. If CY = 1, it will not jump but will execute the next instruction below JNC.</p></li>
<li><p><b>JC (Jump if carry, jumps if CY = 1)</b> &minus; If CY = 1, it jumps to the target address.</p></li>
<li><p><b>JB (jump if bit is high)</b></p></li>
<li><p><b>JNB (jump if bit is low)</b></p></li>
</ul>
<p><b>Note</b> &minus; It must be noted that all conditional jumps are short jumps, i.e., the address of the target must be within –128 to +127 bytes of the contents of the program counter.</p>
<h2>Unconditional Jump Instructions</h2>
<p>There are two unconditional jumps in 8051 &minus;</p>
<ul class="list">
<li><p><b>LJMP (long jump)</b> &minus; LJMP is 3-byte instruction in which the first byte represents opcode, and the second and third bytes represent the 16-bit address of the target location. The 2-byte target address is to allow a jump to any memory location from 0000 to FFFFH.</p></li>
<li><p><b>SJMP (short jump)</b> &minus; It is a 2-byte instruction where the first byte is the opcode and the second byte is the relative address of the target location. The relative address ranges from 00H to FFH which is divided into forward and backward jumps; that is, within –128 to +127 bytes of memory relative to the address of the current PC (program counter). In case of forward jump, the target address can be within a space of 127 bytes from the current PC. In case of backward jump, the target address can be within –128 bytes from the current PC.</p></li>
</ul>
<h2>Calculating the Short Jump Address</h2>
<p>All conditional jumps (JNC, JZ, and DJNZ) are short jumps because they are 2-byte instructions. In these instructions, the first byte represents opcode and the second byte represents the relative address. The target address is always relative to the value of the program counter. To calculate the target address, the second byte is added to the PC of the instruction immediately below the jump. Take a look at the program given below &minus;</p>
<pre class="result notranslate">
Line   PC    Op-code   Mnemonic   Operand 
1      0000               ORG       0000 
2      0000  7800         MOV       R0,#003  
3      0002  7455         MOV       A,#55H0 
4      0004  6003         JZ        NEXT 
5      0006  08           INC       R0 
6      0007  04   AGAIN:  INC       A 
7      0008  04           INC       A 
8      0009  2477 NEXT:   ADD       A, #77h 
9      000B  5005         JNC       OVER 
10     000D  E4           CLR       A
11     000E  F8           MOV       R0, A 
12     000F  F9           MOV       R1, A 
13     0010  FA          MOV       R2, A 
14     0011  FB           MOV       R3, A 
15     0012  2B   OVER:   ADD       A, R3 
16     0013  50F2         JNC       AGAIN 
17     0015  80FE HERE:   SJMP      HERE 
18     0017             END
</pre>

<title>Embedded Systems Addressing Modes</title>

<h1>Embedded Systems - Addressing Modes</h1>

<p>An <b>addressing mode</b> refers to how you are addressing a given memory location. There are five different ways or five addressing modes to execute this instruction which are as follows &minus;</p>

<h2>Immediate Addressing Mode</h2>

<p>Let's begin with an example.</p>

<p>In general, we can write,</p>

<p>It is termed as <b>immediate</b> because 8-bit data is transferred immediately to the accumulator (destination operand).</p>

<p>The following illustration describes the above instruction and its execution. The opcode 74H is saved at 0202 address. The data 6AH is saved at 0203 address in the program memory. After reading the opcode 74H, the data at the next program memory address is transferred to accumulator A (E0H is the address of accumulator). Since the instruction is of 2-bytes and is executed in one cycle, the program counter will be incremented by 2 and will point to 0204 of the program memory.</p>

<p><b>Note</b> &minus; The '#' symbol before 6AH indicates that the operand is a data (8 bit). In the absence of '#', the hexadecimal number would be taken as an address.</p>

<h2>Direct Addressing Mode</h2>

<p>This is another way of addressing an operand. Here, the address of the data (source data) is given as an operand. Let’s take an example.</p>

<p>The register bank#0 (4th register) has the address 04H. When the MOV instruction is executed, the data stored in register 04H is moved to the accumulator. As the register 04H holds the data 1FH, 1FH is moved to the accumulator.</p>

<p><b>Note</b> &minus; We have not used '#' in direct addressing mode, unlike immediate mode. If we had used '#', the data value 04H would have been transferred to the accumulator instead of 1FH.</p>

<p>Now, take a look at the following illustration. It shows how the instruction gets executed.</p>

<p>As shown in the above illustration, this is a 2-byte instruction which requires 1 cycle to complete. The PC will be incremented by 2 and will point to 0204. The opcode for the instruction MOV A, address is E5H. When the instruction at 0202 is executed (E5H), the accumulator is made active and ready to receive data. Then the PC goes to the next address as 0203 and looks up the address of the location of 04H where the source data (to be transferred to accumulator) is located. At 04H, the control finds the data 1F and transfers it to the accumulator and hence the execution is completed.</p>

<h2>Register Direct Addressing Mode</h2>

<p>In this addressing mode, we use the register name directly (as source operand). Let us try to understand with the help of an example.</p>

<p>At a time, the registers can take values from R0 to R7. There are 32 such registers. In order to use 32 registers with just 8 variables to address registers, register banks are used. There are 4 register banks named from 0 to 3. Each bank comprises of 8 registers named from R0 to R7.</p>

<p>At a time, a single register bank can be selected. Selection of a register bank is made possible through a <b>Special Function Register</b> (SFR) named <b>Processor Status Word</b> (PSW). PSW is an 8-bit SFR where each bit can be programmed as required. Bits are designated from PSW.0 to PSW.7. PSW.3 and PSW.4 are used to select register banks.</p>

<p>Now, take a look at the following illustration to get a clear understanding of how it works.</p>

<p>Opcode EC is used for MOV A, R4. The opcode is stored at the address 0202 and when it is executed, the control goes directly to R4 of the respected register bank (that is selected in PSW). If register bank #0 is selected, then the data from R4 of register bank #0 will be moved to the accumulator. Here 2F is stored at 04H. 04H represents the address of R4 of register bank #0.</p>

<p>Data (2F) movement is highlighted in bold. 2F is getting transferred to the accumulator from data memory location 0C H and is shown as dotted line. 0CH is the address location of Register 4 (R4) of register bank #1. The instruction above is 1 byte and requires 1 cycle for complete execution. What it means is, you can save program memory by using register direct addressing mode.</p>

<h2>Register Indirect Addressing Mode</h2>

<p>In this addressing mode, the address of the data is stored in the register as operand.</p>

<p>Here the value inside R0 is considered as an address, which holds the data to be transferred to the accumulator. <b>Example</b>: If R0 has the value 20H, and data 2FH is stored at the address 20H, then the value 2FH will get transferred to the accumulator after executing this instruction. See the following illustration.</p>

<p>So the opcode for <b>MOV A, @R0</b> is E6H. Assuming that the register bank #0 is selected, the R0 of register bank #0 holds the data 20H. Program control moves to 20H where it locates the data 2FH and it transfers 2FH to the accumulator. This is a 1-byte instruction and the program counter increments by 1 and moves to 0203 of the program memory.</p>

<p><b>Note</b> &minus; Only R0 and R1 are allowed to form a register indirect addressing instruction. In other words, the programmer can create an instruction either using @R0 or @R1. All register banks are allowed.</p>

<h2>Indexed Addressing Mode</h2>

<p>We will take two examples to understand the concept of indexed addressing mode. Take a look at the following instructions &minus;</p>

<p>and</p>

<p>where DPTR is the data pointer and PC is the program counter (both are 16-bit registers). Consider the first example.</p>

<p>The source operand is @A+DPTR. It contains the source data from this location. Here we are adding the contents of DPTR with the current content of the accumulator. This addition will give a new address which is the address of the source data. The data pointed by this address is then transferred to the accumulator.</p>

<p>The opcode is 93H. DPTR has the value 01FE, where 01 is located in DPH (higher 8 bits) and FE is located in DPL (lower 8 bits). Accumulator has the value 02H. Then a 16-bit addition is performed and 01FE H+02H results in 0200 H. Data at the location 0200H will get transferred to the accumulator. The previous value inside the accumulator (02H) will be replaced with the new data from 0200H. The new data in the accumulator is highlighted in the illustration.</p>

<p>This is a 1-byte instruction with 2 cycles needed for execution and the execution time required for this instruction is high compared to previous instructions (which were all 1 cycle each).</p>

<p>The other example <b>MOVC A, @A+PC</b> works the same way as the above example. Instead of adding DPTR with the accumulator, here the data inside the program counter (PC) is added with the accumulator to obtain the target address.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
MOV A, #6AH 
</pre>
<p>In general, we can write,</p>
<pre class="result notranslate">
MOV A, #data
</pre>
<p>It is termed as <b>immediate</b> because 8-bit data is transferred immediately to the accumulator (destination operand).</p>  
<p>The following illustration describes the above instruction and its execution. The opcode 74H is saved at 0202 address. The data 6AH is saved at 0203 address in the program memory. After reading the opcode 74H, the data at the next program memory address is transferred to accumulator A (E0H is the address of accumulator). Since the instruction is of 2-bytes and is executed in one cycle, the program counter will be incremented by 2 and will point to 0204 of the program memory.</p>
<img src="/embedded_systems/images/immidiate_addressing_mode.jpg" alt="Immediate Addressing Mode" />
<p><b>Note</b> &minus; The '#' symbol before 6AH indicates that the operand is a data (8 bit). In the absence of '#', the hexadecimal number would be taken as an address.</p>
<h2>Direct Addressing Mode</h2>
<p>This is another way of addressing an operand. Here, the address of the data (source data) is given as an operand. Let’s take an example.</p>
<pre class="result notranslate">
MOV A, 04H 
</pre>
<p>The register bank#0 (4th register) has the address 04H. When the MOV instruction is executed, the data stored in register 04H is moved to the accumulator. As the register 04H holds the data 1FH, 1FH is moved to the accumulator.</p>
<p><b>Note</b> &minus; We have not used '#' in direct addressing mode, unlike immediate mode. If we had used '#', the data value 04H would have been transferred to the accumulator instead of 1FH.</p>
<p>Now, take a look at the following illustration. It shows how the instruction gets executed.</p>
<img src="/embedded_systems/images/direct_addressing_mode.jpg" alt="Direct Addressing Mode" />
<p>As shown in the above illustration, this is a 2-byte instruction which requires 1 cycle to complete. The PC will be incremented by 2 and will point to 0204. The opcode for the instruction MOV A, address is E5H. When the instruction at 0202 is executed (E5H), the accumulator is made active and ready to receive data. Then the PC goes to the next address as 0203 and looks up the address of the location of 04H where the source data (to be transferred to accumulator) is located. At 04H, the control finds the data 1F and transfers it to the accumulator and hence the execution is completed.</p>
<h2>Register Direct Addressing Mode</h2>
<p>In this addressing mode, we use the register name directly (as source operand). Let us try to understand with the help of an example.</p>
<pre class="result notranslate">
MOV A, R4 
</pre>
<p>At a time, the registers can take values from R0 to R7. There are 32 such registers. In order to use 32 registers with just 8 variables to address registers, register banks are used. There are 4 register banks named from 0 to 3. Each bank comprises of 8 registers named from R0 to R7.</p> 
<p>At a time, a single register bank can be selected. Selection of a register bank is made possible through a <b>Special Function Register</b> (SFR) named <b>Processor Status Word</b> (PSW). PSW is an 8-bit SFR where each bit can be programmed as required. Bits are designated from PSW.0 to PSW.7. PSW.3 and PSW.4 are used to select register banks.</p>
<p>Now, take a look at the following illustration to get a clear understanding of how it works.</p>
<img src="/embedded_systems/images/register_direct_mode.jpg" alt="Register Direct Addressing Mode" />
<p>Opcode EC is used for MOV A, R4. The opcode is stored at the address 0202 and when it is executed, the control goes directly to R4 of the respected register bank (that is selected in PSW). If register bank #0 is selected, then the data from R4 of register bank #0 will be moved to the accumulator. Here 2F is stored at 04H. 04H represents the address of R4 of register bank #0.</p>
<p>Data (2F) movement is highlighted in bold. 2F is getting transferred to the accumulator from data memory location 0C H and is shown as dotted line. 0CH is the address location of Register 4 (R4) of register bank #1. The instruction above is 1 byte and requires 1 cycle for complete execution. What it means is, you can save program memory by using register direct addressing mode.</p>
<h2>Register Indirect Addressing Mode</h2>
<p>In this addressing mode, the address of the data is stored in the register as operand.</p>
<pre class="result notranslate">
MOV A, @R0 
</pre>
<p>Here the value inside R0 is considered as an address, which holds the data to be transferred to the accumulator. <b>Example</b>: If R0 has the value 20H, and data 2FH is stored at the address 20H, then the value 2FH will get transferred to the accumulator after executing this instruction. See the following illustration.</p>
<img src="/embedded_systems/images/register_indirect_mode.jpg" alt="Register Indirect Addressing Mode" />
<p>So the opcode for <b>MOV A, @R0</b> is E6H. Assuming that the register bank #0 is selected, the R0 of register bank #0 holds the data 20H. Program control moves to 20H where it locates the data 2FH and it transfers 2FH to the accumulator. This is a 1-byte instruction and the program counter increments by 1 and moves to 0203 of the program memory.</p>
<p><b>Note</b> &minus; Only R0 and R1 are allowed to form a register indirect addressing instruction. In other words, the programmer can create an instruction either using @R0 or @R1. All register banks are allowed.</p>
<h2>Indexed Addressing Mode</h2>
<p>We will take two examples to understand the concept of indexed addressing mode. Take a look at the following instructions &minus;</p>
<p style="padding-left:10%;"><b>MOVC A, @A+DPTR</b></p>
<p>and</p>
<p style="padding-left:10%;"><b>MOVC A, @A+PC</b></p>
<p>where DPTR is the data pointer and PC is the program counter (both are 16-bit registers). Consider the first example.</p>
<pre class="result notranslate">
MOVC A, @A+DPTR
</pre>

<title>Embedded Systems SFR Registers</title>

<h1>Embedded Systems - SFR Registers</h1>

<p>A Special Function Register (or Special Purpose Register, or simply Special Register) is a register within a microprocessor that controls or monitors the various functions of a microprocessor. As the special registers are closely tied to some special function or status of the processor, they might not be directly writable by normal instructions (like add, move, etc.). Instead, some special registers in some processor architectures require special instructions to modify them.</p>

<p>In the 8051, register A, B, DPTR, and PSW are a part of the group of registers commonly referred to as SFR (special function registers). An SFR can be accessed by its name or by its address.</p>

<p>The following table shows a list of SFRs and their addresses.</p>

<p>Consider the following two points about the SFR addresses.</p>

<p>A special function register can have an address between 80H to FFH. These addresses are above 80H, as the addresses from 00 to 7FH are the addresses of RAM memory inside the 8051.</p>

<p>Not all the address space of 80 to FF are used by the SFR. Unused locations, 80H to FFH, are reserved and must not be used by the 8051 programmer.</p>

<p>In the following example, the SFR registers’ names are replaced with their addresses.</p>

<p>We can select the corresponding Register Bank bit using RS0 and RS1 bits.</p>

<p>The Program Status Word (PSW) contains status bits to reflect the current state of the CPU. The 8051 variants provide one special function register, PSW, with this status information. The 8251 provides two additional status flags, Z and N, which are available in a second special function register called PSW1.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Embedded Systems Timer/Counter</title>

<h1>Embedded Systems - Timer/Counter</h1>

<p>A <b>timer</b> is a specialized type of clock which is used to measure time intervals. A timer that counts from zero upwards for measuring time elapsed is often called a <b>stopwatch</b>. It is a device that counts down from a specified time interval and used to generate a time delay, for example, an hourglass is a timer.</p>

<p>A <b>counter</b> is a device that stores (and sometimes displays) the number of times a particular event or process occurred, with respect to a clock signal. It is used to count the events happening outside the microcontroller. In electronics, counters can be implemented quite easily using register-type circuits such as a flip-flop.</p>

<h2>Difference between a Timer and a Counter</h2>

<p>The points that differentiate a timer from a counter are as follows &minus;</p>

<h2>Timers of 8051 and their Associated Registers</h2>

<p>The 8051 has two timers, Timer 0 and Timer 1. They can be used as timers or as event counters. Both Timer 0 and Timer 1 are 16-bit wide. Since the 8051 follows an 8-bit architecture, each 16 bit is accessed as two separate registers of low-byte and high-byte.</p>

<h3>Timer 0 Register</h3>

<p>The 16-bit register of Timer 0 is accessed as low- and high-byte. The low-byte register is called TL0 (Timer 0 low byte) and the high-byte register is called TH0 (Timer 0 high byte). These registers can be accessed like any other register. For example, the instruction <b>MOV TL0, #4H</b> moves the value into the low-byte of Timer #0.</p>

<h3>Timer 1 Register</h3>

<p>The 16-bit register of Timer 1 is accessed as low- and high-byte. The low-byte register is called TL1 (Timer 1 low byte) and the high-byte register is called TH1 (Timer 1 high byte). These registers can be accessed like any other register. For example, the instruction <b>MOV TL1, #4H</b> moves the value into the low-byte of Timer 1.</p>

<h3>TMOD (Timer Mode) Register</h3>

<p>Both Timer 0 and Timer 1 use the same register to set the various timer operation modes. It is an 8-bit register in which the lower 4 bits are set aside for Timer 0 and the upper four bits for Timers. In each case, the lower 2 bits are used to set the timer mode in advance and the upper 2 bits are used to specify the location.</p>

<p><b>Gate</b> &minus; When set, the timer only runs while INT(0,1) is high.</p>

<p><b>C/T</b> &minus; Counter/Timer select bit.</p>

<p><b>M1</b> &minus; Mode bit 1.</p>

<p><b>M0</b> &minus; Mode bit 0.</p>

<h3>GATE</h3>

<p>Every timer has a means of starting and stopping. Some timers do this by software, some by hardware, and some have both software and hardware controls. 8051 timers have both software and hardware controls. The start and stop of a timer is controlled by software using the instruction <b>SETB TR1</b> and <b>CLR TR1</b> for timer 1, and <b>SETB TR0</b> and <b>CLR TR0</b> for timer 0.</p>

<p>The SETB instruction is used to start it and it is stopped by the CLR instruction. These instructions start and stop the timers as long as GATE = 0 in the TMOD register. Timers can be started and stopped by an external source by making GATE = 1 in the TMOD register.</p>

<h3>C/T (CLOCK / TIMER)</h3>

<p>This bit in the TMOD register is used to decide whether a timer is used as a <b>delay generator</b> or an <b>event manager</b>. If C/T = 0, it is used as a timer for timer delay generation. The clock source to create the time delay is the crystal frequency of the 8051. If C/T = 0, the crystal frequency attached to the 8051 also decides the speed at which the 8051 timer ticks at a regular interval.</p>

<p>Timer frequency is always 1/12th of the frequency of the crystal attached to the 8051. Although various 8051 based systems have an XTAL frequency of 10 MHz to 40 MHz, we normally work with the XTAL frequency of 11.0592 MHz. It is because the baud rate for serial communication of the 8051.XTAL = 11.0592 allows the 8051 system to communicate with the PC with no errors.</p>

<h3>M1 / M2</h3>

<h2>Different Modes of Timers</h2>

<h3>Mode 0 (13-Bit Timer Mode) </h3>

<p>Both Timer 1 and Timer 0 in Mode 0 operate as 8-bit counters (with a divide-by-32 prescaler). Timer register is configured as a 13-bit register consisting of all the 8 bits of TH1 and the lower 5 bits of TL1. The upper 3 bits of TL1 are indeterminate and should be ignored. Setting the run flag (TR1) does not clear the register. The timer interrupt flag TF1 is set when the count rolls over from all 1s to all 0s. Mode 0 operation is the same for Timer 0 as it is for Timer 1.</p>

<h3>Mode 1 (16-Bit Timer Mode)</h3>

<p>Timer mode "1" is a 16-bit timer and is a commonly used mode. It functions in the same way as 13-bit mode except that all 16 bits are used. TLx is incremented starting from 0 to a maximum 255. Once the value 255 is reached, TLx resets to 0 and then THx is incremented by 1. As being a full 16-bit timer, the timer may contain up to 65536 distinct values and it will overflow back to 0 after 65,536 machine cycles.</p>

<h3>Mode 2 (8 Bit Auto Reload)</h3>

<p>Both the timer registers are configured as 8-bit counters (TL1 and TL0) with automatic reload. Overflow from TL1 (TL0) sets TF1 (TF0) and also reloads TL1 (TL0) with the contents of Th1 (TH0), which is preset by software. The reload leaves TH1 (TH0) unchanged.</p>

<p>The benefit of auto-reload mode is that you can have the timer to always contain a value from 200 to 255. If you use mode 0 or 1, you would have to check in the code to see the overflow and, in that case, reset the timer to 200. In this case, precious instructions check the value and/or get reloaded. In mode 2, the microcontroller takes care of this. Once you have configured a timer in mode 2, you don't have to worry about checking to see if the timer has overflowed, nor do you have to worry about resetting the value because the microcontroller hardware will do it all for you. The auto-reload mode is used for establishing a common baud rate.</p>

<h3>Mode 3 (Split Timer Mode)</h3>

<p>Timer mode "3" is known as <b>split-timer mode</b>. When Timer 0 is placed in mode 3, it becomes two separate 8-bit timers. Timer 0 is TL0 and Timer 1 is TH0. Both the timers count from 0 to 255 and in case of overflow, reset back to 0. All the bits that are of Timer 1 will now be tied to TH0.</p>

<p>When Timer 0 is in split mode, the real Timer 1 (i.e. TH1 and TL1) can be set in modes 0, 1 or 2, but it cannot be started/stopped as the bits that do that are now linked to TH0. The real timer 1 will be incremented with every machine cycle.</p>

<h3>Initializing a Timer</h3>

<p>Decide the timer mode. Consider a 16-bit timer that runs continuously, and is independent of any external pins.</p>

<p>Initialize the TMOD SFR. Use the lowest 4 bits of TMOD and consider Timer 0. Keep the two bits, GATE 0 and C/T 0, as 0, since we want the timer to be independent of the external pins. As 16-bit mode is timer mode 1, clear T0M1 and set T0M0. Effectively, the only bit to turn on is bit 0 of TMOD. Now execute the following instruction &minus;</p>

<p>Now, Timer 0 is in 16-bit timer mode, but the timer is not running. To start the timer in running mode, set the TR0 bit by executing the following instruction &minus;</p>

<p>Now, Timer 0 will immediately start counting, being incremented once every machine cycle.</p>

<h2>Reading a Timer</h2>

<p>A 16-bit timer can be read in two ways. Either read the actual value of the timer as a 16-bit number, or you detect when the timer has overflowed.</p>

<h2>Detecting Timer Overflow</h2>

<p>When a timer overflows from its highest value to 0, the microcontroller automatically sets the TFx bit in the TCON register. So instead of checking the exact value of the timer, the TFx bit can be checked. If TF0 is set, then Timer 0 has overflowed; if TF1 is set, then Timer 1 has overflowed.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
MOV TMOD,#01h
</pre>
<p>Now, Timer 0 is in 16-bit timer mode, but the timer is not running. To start the timer in running mode, set the TR0 bit by executing the following instruction &minus;</p>
<pre class="result notranslate">
SETB TR0
</pre>

<title>Embedded Systems Interrupts</title>

<h1>Embedded Systems - Interrupts</h1>

<p>An interrupt is a signal to the processor emitted by hardware or software indicating an event that needs immediate attention. Whenever an interrupt occurs, the controller completes the execution of the current instruction and starts the execution of an <b>Interrupt Service Routine</b> (ISR) or <b>Interrupt Handler</b>. ISR tells the processor or controller what to do when the interrupt occurs. The interrupts can be either hardware interrupts or software interrupts.</p>

<h2>Hardware Interrupt</h2>

<p>A hardware interrupt is an electronic alerting signal sent to the processor from an external device, like a disk controller or an external peripheral. For example, when we press a key on the keyboard or move the mouse, they trigger hardware interrupts which cause the processor to read the keystroke or mouse position.</p>

<h2>Software Interrupt</h2>

<p>A software interrupt is caused either by an exceptional condition or a special instruction in the instruction set which causes an interrupt when it is executed by the processor. For example, if the processor's arithmetic logic unit runs a command to divide a number by zero, to cause a divide-by-zero exception, thus causing the computer to abandon the calculation or display an error message. Software interrupt instructions work similar to subroutine calls.</p>

<h2>What is Polling?</h2>

<p>The state of continuous monitoring is known as <b>polling</b>. The microcontroller keeps checking the status of other devices; and while doing so, it does no other operation and consumes all its processing time for monitoring. This problem can be addressed by using interrupts.</p>

<p>In the interrupt method, the controller responds only when an interruption occurs. Thus, the controller is not required to regularly monitor the status (flags, signals etc.) of interfaced and inbuilt devices.</p>

<h3>Interrupts v/s Polling</h3>

<p>Here is an analogy that differentiates an interrupt from polling &minus;</p>

<h2>Interrupt Service Routine</h2>

<p>For every interrupt, there must be an interrupt service routine (ISR), or <b>interrupt handler</b>. When an interrupt occurs, the microcontroller runs the interrupt service routine. For every interrupt, there is a fixed location in memory that holds the address of its interrupt service routine, ISR. The table of memory locations set aside to hold the addresses of ISRs is called as the Interrupt Vector Table.</p>

<h2>Interrupt Vector Table</h2>

<p>There are six interrupts including RESET in 8051.</p>

<p>When the reset pin is activated, the 8051 jumps to the address location 0000. This is power-up reset.</p>

<p>Two interrupts are set aside for the timers: one for timer 0 and one for timer 1. Memory locations are 000BH and 001BH respectively in the interrupt vector table.</p>

<p>Two interrupts are set aside for hardware external interrupts. Pin no. 12 and Pin no. 13 in Port 3 are for the external hardware interrupts INT0 and INT1, respectively. Memory locations are 0003H and 0013H respectively in the interrupt vector table.</p>

<p>Serial communication has a single interrupt that belongs to both receive and transmit. Memory location 0023H belongs to this interrupt.</p>

<h2>Steps to Execute an Interrupt</h2>

<p>When an interrupt gets active, the microcontroller goes through the following steps &minus;</p>

<p>The microcontroller closes the currently executing instruction and saves the address of the next instruction (PC) on the stack.</p>

<p>It also saves the current status of all the interrupts internally (i.e., not on the stack).</p>

<p>It jumps to the memory location of the interrupt vector table that holds the address of the interrupts service routine.</p>

<p>The microcontroller gets the address of the ISR from the interrupt vector table and jumps to it. It starts to execute the interrupt service subroutine, which is RETI (return from interrupt).</p>

<p>Upon executing the RETI instruction, the microcontroller returns to the location where it was interrupted. First, it gets the program counter (PC) address from the stack by popping the top bytes of the stack into the PC. Then, it start to execute from that address.</p>

<h2>Edge Triggering vs. Level Triggering</h2>

<p>Interrupt modules are of two types &minus; level-triggered or edge-triggered.</p>

<h2>Enabling and Disabling an Interrupt</h2>

<p>Upon Reset, all the interrupts are disabled even if they are activated. The interrupts must be enabled using software in order for the microcontroller to respond to those interrupts.</p>

<p>IE (interrupt enable) register is responsible for enabling and disabling the interrupt. IE is a bitaddressable register.</p>

<h3>Interrupt Enable Register</h3>

<p><b>EA</b> &minus; Global enable/disable.</p>

<p><b>-</b> &minus; Undefined.</p>

<p><b>ET2</b> &minus; Enable Timer 2 interrupt.</p>

<p><b>ES</b> &minus; Enable Serial port interrupt.</p>

<p><b>ET1</b> &minus; Enable Timer 1 interrupt.</p>

<p><b>EX1</b> &minus; Enable External 1 interrupt.</p>

<p><b>ET0</b> &minus; Enable Timer 0 interrupt.</p>

<p><b>EX0</b> &minus; Enable External 0 interrupt.</p>

<p>To enable an interrupt, we take the following steps &minus;</p>

<p>Bit D7 of the IE register (EA) must be high to allow the rest of register to take effect.</p>

<p>If EA = 1, interrupts will be enabled and will be responded to, if their corresponding bits in IE are high. If EA = 0, no interrupts will respond, even if their associated pins in the IE register are high.</p>

<h2>Interrupt Priority in 8051</h2>

<p>We can alter the interrupt priority by assigning the higher priority to any one of the interrupts. This is accomplished by programming a register called <b>IP</b> (interrupt priority).</p>

<p>The following figure shows the bits of IP register. Upon reset, the IP register contains all 0's. To give a higher priority to any of the interrupts, we make the corresponding bit in the IP register high.</p>

<p></p>

<h2>Interrupt inside Interrupt</h2>

<p>What happens if the 8051 is executing an ISR that belongs to an interrupt and another one gets active? In such cases, a high-priority interrupt can interrupt a low-priority interrupt. This is known as <b>interrupt inside interrupt</b>. In 8051, a low-priority interrupt can be interrupted by a high-priority interrupt, but not by any another low-priority interrupt.</p>

<h2>Triggering an Interrupt by Software</h2>

<p>There are times when we need to test an ISR by way of simulation. This can be done with the simple instructions to set the interrupt high and thereby cause the 8051 to jump to the interrupt vector table. For example, set the IE bit as 1 for timer 1. An instruction <b>SETB TF1</b> will interrupt the 8051 in whatever it is doing and force it to jump to the interrupt vector table.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Embedded Systems Quick Guide</title>

<h1>Embedded Systems - Quick Guide</h1>

<h1>Embedded Systems - Overview</h1>

<h2>System</h2>

<p>A system is an arrangement in which all its unit assemble work together according to a set of rules. It can also be defined as a way of working, organizing or doing one or many tasks according to a fixed plan. For example, a watch is a time displaying system. Its components follow a set of rules to show time. If one of its parts fails, the watch will stop working. So we can say, in a system, all its subcomponents depend on each other.</p>

<h2>Embedded System</h2>

<p>As its name suggests, Embedded means something that is attached to another thing. An embedded system can be thought of as a computer hardware system having software embedded in it. An embedded system can be an independent system or it can be a part of a large system. An embedded system is a microcontroller or microprocessor based system which is designed to perform a specific task. For example, a fire alarm is an embedded system; it will sense only smoke.</p>

<p>An embedded system has three components &minus;</p>

<p>It has hardware.</p>

<p>It has application software.</p>

<p>It has Real Time Operating system (RTOS) that supervises the application software and provide mechanism to let the processor run a process as per scheduling by following a plan to control the latencies. RTOS defines the way the system works. It sets the rules during the execution of application program. A small scale embedded system may not have RTOS.</p>

<p>So we can define an embedded system as a Microcontroller based, software driven, reliable, real-time control system.</p>

<h2>Characteristics of an Embedded System</h2>

<p><b>Single-functioned</b> &minus; An embedded system usually performs a specialized operation and does the same repeatedly. For example: A pager always functions as a pager.</p>

<p><b>Tightly constrained</b> &minus; All computing systems have constraints on design metrics, but those on an embedded system can be especially tight. Design metrics is a measure of an implementation's features such as its cost, size, power, and performance. It must be of a size to fit on a single chip, must perform fast enough to process data in real time and consume minimum power to extend battery life.</p>

<p><b>Reactive and Real time</b> &minus; Many embedded systems must continually react to changes in the system's environment and must compute certain results in real time without any delay. Consider an example of a car cruise controller; it continually monitors and reacts to speed and brake sensors. It must compute acceleration or de-accelerations repeatedly within a limited time; a delayed computation can result in failure to control of the car.</p>

<p><b>Microprocessors based</b> &minus; It must be microprocessor or microcontroller based.</p>

<p><b>Memory</b> &minus; It must have a memory, as its software usually embeds in ROM. It does not need any secondary memories in the computer.</p>

<p><b>Connected</b> &minus; It must have connected peripherals to connect input and output devices.</p>

<p><b>HW-SW systems</b> &minus; Software is used for more features and flexibility. Hardware is used for performance and security.</p>

<h3>Advantages</h3>

<h3>Disadvantages</h3>

<h2>Basic Structure of an Embedded System</h2>

<p>The following illustration shows the basic structure of an embedded system &minus;</p>

<p><b>Sensor</b> &minus; It measures the physical quantity and converts it to an electrical signal which can be read by an observer or by any electronic instrument like an A2D converter. A sensor stores the measured quantity to the memory.</p>

<p><b>A-D Converter</b> &minus; An analog-to-digital converter converts the analog signal sent by the sensor into a digital signal.</p>

<p><b>Processor &amp; ASICs</b> &minus; Processors process the data to measure the output and store it to the memory.</p>

<p><b>D-A Converter</b> &minus; A digital-to-analog converter converts the digital data fed by the processor to analog data</p>

<p><b>Actuator</b> &minus; An actuator compares the output given by the D-A Converter to the actual (expected) output stored in it and stores the approved output. </p>

<h1>Embedded Systems - Processors</h1>

<p>Processor is the heart of an embedded system. It is the basic unit that takes inputs and produces an output after processing the data. For an embedded system designer, it is necessary to have the knowledge of both microprocessors and microcontrollers.</p>

<h2>Processors in a System</h2>

<p>A processor has two essential units &minus;</p>

<p>The CU includes a fetch unit for fetching instructions from the memory. The EU has circuits that implement the instructions pertaining to data transfer operation and data conversion from one form to another.</p>

<p>The EU includes the Arithmetic and Logical Unit (ALU) and also the circuits that execute instructions for a program control task such as interrupt, or jump to another set of instructions.</p>

<p>A processor runs the cycles of fetch and executes the instructions in the same sequence as they are fetched from memory.</p>

<h2>Types of Processors</h2>

<p>Processors can be of the following categories &minus;</p>

<p>General Purpose Processor (GPP)</p>

<p>Application Specific System Processor (ASSP)</p>

<p>Application Specific Instruction Processors (ASIPs)</p>

<p>GPP core(s) or ASIP core(s) on either an Application Specific Integrated Circuit (ASIC) or a Very Large Scale Integration (VLSI) circuit.</p>

<h2>Microprocessor</h2>

<p>A microprocessor is a single VLSI chip having a CPU. In addition, it may also have other units such as coaches, floating point processing arithmetic unit, and pipelining units that help in faster processing of instructions.</p>

<p>Earlier generation microprocessors’ fetch-and-execute cycle was guided by a clock frequency of order of ~1 MHz. Processors now operate at a clock frequency of 2GHz</p>

<h2>Microcontroller</h2>

<p>A microcontroller is a single-chip VLSI unit (also called <b>microcomputer</b>) which, although having limited computational capabilities, possesses enhanced input/output capability and a number of on-chip functional units.</p>

<p>Microcontrollers are particularly used in embedded systems for real-time control applications with on-chip program memory and devices.</p>

<h2>Microprocessor vs Microcontroller</h2>

<p>Let us now take a look at the most notable differences between a microprocessor and a microcontroller.</p>

<h1>Embedded Systems - Architecture Types</h1>

<p>The 8051 microcontrollers work with 8-bit data bus. So they can support external data memory up to 64K and external program memory of 64k at best. Collectively, 8051 microcontrollers can address 128k of external memory.</p>

<p>When data and code lie in different memory blocks, then the architecture is referred as <b>Harvard architecture</b>. In case data and code lie in the same memory block, then the architecture is referred as <b>Von Neumann architecture</b>.</p>

<h2>Von Neumann Architecture</h2>

<p>The Von Neumann architecture was first proposed by a computer scientist John von Neumann. In this architecture, one data path or bus exists for both instruction and data. As a result, the CPU does one operation at a time. It either fetches an instruction from memory, or performs read/write operation on data. So an instruction fetch and a data operation cannot occur simultaneously, sharing a common bus.</p>

<p>Von-Neumann architecture supports simple hardware. It allows the use of a single, sequential memory. Today's processing speeds vastly outpace memory access times, and we employ a very fast but small amount of memory (cache) local to the processor.</p>

<h2>Harvard Architecture</h2>

<p>The Harvard architecture offers separate storage and signal buses for instructions and data. This architecture has data storage entirely contained within the CPU, and there is no access to the instruction storage as data. Computers have separate memory areas for program instructions and data using internal data buses, allowing simultaneous access to both instructions and data.</p>

<p>Programs needed to be loaded by an operator; the processor could not boot itself. In a Harvard architecture, there is no need to make the two memories share properties.</p>

<h2>Von-Neumann Architecture vs Harvard Architecture</h2>

<p>The following points distinguish the Von Neumann Architecture from the Harvard Architecture.</p>

<h2>CISC and RISC</h2>

<p>CISC is a Complex Instruction Set Computer. It is a computer that can address a large number of instructions.</p>

<p>In the early 1980s, computer designers recommended that computers should use fewer instructions with simple constructs so that they can be executed much faster within the CPU without having to use memory. Such computers are classified as Reduced Instruction Set Computer or RISC.</p>

<h3>CISC vs RISC</h3>

<p>The following points differentiate a CISC from a RISC &minus;</p>

<h1>Embedded Systems - Tools &amp; Peripherals</h1>

<h2>Compilers and Assemblers</h2>

<h3>Compiler</h3>

<p>A compiler is a computer program (or a set of programs) that transforms the source code written in a programming language (the source language) into another computer language (normally binary format). The most common reason for conversion is to create an executable program. The name "compiler" is primarily used for programs that translate the source code from a highlevel programming language to a low-level language (e.g., assembly language or machine code).</p>

<h3>Cross-Compiler</h3>

<p>If the compiled program can run on a computer having different CPU or operating system than the computer on which the compiler compiled the program, then that compiler is known as a cross-compiler.</p>

<h3>Decompiler</h3>

<p>A program that can translate a program from a low-level language to a high-level language is called a decompiler.</p>

<h3>Language Converter</h3>

<p>A program that translates programs written in different high-level languages is normally called a language translator, source to source translator, or language converter.</p>

<p>A compiler is likely to perform the following operations &minus;</p>

<h3>Assemblers</h3>

<p>An assembler is a program that takes basic computer instructions (called as assembly language) and converts them into a pattern of bits that the computer's processor can use to perform its basic operations. An assembler creates object code by translating assembly instruction mnemonics into opcodes, resolving symbolic names to memory locations. Assembly language uses a mnemonic to represent each low-level machine operation (opcode).</p>

<h2>Debugging Tools in an Embedded System</h2>

<p>Debugging is a methodical process to find and reduce the number of bugs in a computer program or a piece of electronic hardware, so that it works as expected. Debugging is difficult when subsystems are tightly coupled, because a small change in one subsystem can create bugs in another. The debugging tools used in embedded systems differ greatly in terms of their development time and debugging features. We will discuss here the following debugging tools &minus;</p>

<h2>Simulators</h2>

<p>Code is tested for the MCU / system by simulating it on the host computer used for code development. Simulators try to model the behavior of the complete microcontroller in software.</p>

<h3>Functions of Simulators</h3>

<p>A simulator performs the following functions &minus;</p>

<p>Defines the processor or processing device family as well as its various versions for the target system.</p>

<p>Monitors the detailed information of a source code part with labels and symbolic arguments as the execution goes on for each single step.</p>

<p>Provides the status of RAM and simulated ports of the target system for each single step execution.</p>

<p>Monitors system response and determines throughput.</p>

<p>Provides trace of the output of contents of program counter versus the processor registers.</p>

<p>Provides the detailed meaning of the present command.</p>

<p>Monitors the detailed information of the simulator commands as these are entered from the keyboard or selected from the menu.</p>

<p>Supports the conditions (up to 8 or 16 or 32 conditions) and unconditional breakpoints.</p>

<p>Provides breakpoints and the trace which are together the important testing and debugging tool.</p>

<p>Facilitates synchronizing the internal peripherals and delays.</p>

<h2>Microcontroller Starter Kit</h2>

<p>A microcontroller starter kit consists of &minus;</p>

<p>A big advantage of these kits over simulators is that they work in real-time and thus allow for easy input/output functionality verification. Starter kits, however, are completely sufficient and the cheapest option to develop simple microcontroller projects.</p>

<h2>Emulators</h2>

<p>An emulator is a hardware kit or a software program or can be both which emulates the functions of one computer system (the guest) in another computer system (the host), different from the first one, so that the emulated behavior closely resembles the behavior of the real system (the guest).</p>

<p>Emulation refers to the ability of a computer program in an electronic device to emulate (imitate) another program or device. Emulation focuses on recreating an original computer environment. Emulators have the ability to maintain a closer connection to the authenticity of the digital object. An emulator helps the user to work on any kind of application or operating system on a platform in a similar way as the software runs as in its original environment.</p>

<h2>Peripheral Devices in Embedded Systems</h2>

<p>Embedded systems communicate with the outside world via their peripherals, such as following &mins;</p>

<h2>Criteria for Choosing Microcontroller</h2>

<p>While choosing a microcontroller, make sure it meets the task at hand and that it is cost effective. We must see whether an 8-bit, 16-bit or 32-bit microcontroller can best handle the computing needs of a task. In addition, the following points should be kept in mind while choosing a microcontroller &minus;</p>

<p><b>Speed</b> &minus; What is the highest speed the microcontroller can support?</p>

<p><b>Packaging</b> &minus; Is it 40-pin DIP (Dual-inline-package) or QFP (Quad flat package)? This is important in terms of space, assembling, and prototyping the end-product.</p>

<p><b>Power Consumption</b> &minus; This is an important criteria for battery-powered products.</p>

<p><b>Amount of RAM and ROM</b> on the chip.</p>

<p><b>Count of I/O pins and Timers</b> on the chip.</p>

<p><b>Cost per Unit</b> &minus; This is important in terms of final cost of the product in which the microcontroller is to be used.</p>

<p>Further, make sure you have tools such as compilers, debuggers, and assemblers, available with the microcontroller. The most important of all, you should purchase a microcontroller from a reliable source.</p>

<h1>Embedded Systems - 8051 Microcontroller</h1>

<h2>Brief History of 8051</h2>

<p>The first microprocessor <b>4004</b> was invented by Intel Corporation. <b>8085</b> and <b>8086</b> microprocessors were also invented by Intel. In 1981, Intel introduced an 8-bit microcontroller called the <b>8051</b>. It was referred as <b>system on a chip</b> because it had 128 bytes of RAM, 4K byte of on-chip ROM, two timers, one serial port, and 4 ports (8-bit wide), all on a single chip. When it became widely popular, Intel allowed other manufacturers to make and market different flavors of 8051 with its code compatible with 8051. It means that if you write your program for one flavor of 8051, it will run on other flavors too, regardless of the manufacturer. This has led to several versions with different speeds and amounts of on-chip RAM.</p>

<h2>8051 Flavors / Members</h2>

<p><b>8052 microcontroller</b> &minus; 8052 has all the standard features of the 8051 microcontroller as well as an extra 128 bytes of RAM and an extra timer. It also has 8K bytes of on-chip program ROM instead of 4K bytes.</p>

<p><b>8031 microcontroller</b> &minus; It is another member of the 8051 family. This chip is often referred to as a ROM-less 8051, since it has 0K byte of on-chip ROM. You must add external ROM to it in order to use it, which contains the program to be fetched and executed. This program can be as large as 64K bytes. But in the process of adding external ROM to the 8031, it lost 2 ports out of 4 ports. To solve this problem, we can add an external I/O to the 8031</p>

<h2>Comparison between 8051 Family Members</h2>

<p>The following table compares the features available in 8051, 8052, and 8031.</p>

<h2>Features of 8051 Microcontroller</h2>

<p>An 8051 microcontroller comes bundled with the following features &minus;</p>

<h2>Block Diagram of 8051 Microcontroller</h2>

<p>The following illustration shows the block diagram of an 8051 microcontroller &minus;</p>

<h1>Embedded System - I/O Programming</h1>

<p>In 8051, I/O operations are done using four ports and 40 pins. The following pin diagram shows the details of the 40 pins. I/O operation port reserves 32 pins where each port has 8 pins. The other 8 pins are designated as V<sub>cc</sub>, GND, XTAL1, XTAL2, RST, EA (bar), ALE/PROG (bar), and PSEN (bar).</p>

<p>It is a 40 Pin PDIP (Plastic Dual Inline Package)</p>

<p><b>Note</b> &minus; In a DIP package, you can recognize the first pin and the last pin by the cut at the middle of the IC. The first pin is on the left of this cut mark and the last pin (i.e. the 40<sup>th</sup> pin in this case) is to the right of the cut mark.</p>

<h2>I/O Ports and their Functions</h2>

<p>The four ports P0, P1, P2, and P3, each use 8 pins, making them 8-bit ports. Upon RESET, all the ports are configured as inputs, ready to be used as input ports. When the first 0 is written to a port, it becomes an output. To reconfigure it as an input, a 1 must be sent to a port.</p>

<h3>Port 0 (Pin No 32 – Pin No 39)</h3>

<p>It has 8 pins (32 to 39). It can be used for input or output. Unlike P1, P2, and P3 ports, we normally connect P0 to 10K-ohm pull-up resistors to use it as an input or output port being an open drain.</p>

<p>It is also designated as AD0-AD7, allowing it to be used as both address and data. In case of 8031 (i.e. ROMless Chip), when we need to access the external ROM, then P0 will be used for both Address and Data Bus. ALE (Pin no 31) indicates if P0 has address or data. When ALE = 0, it provides data D0-D7, but when ALE = 1, it has address A0-A7. In case no external memory connection is available, P0 must be connected externally to a 10K-ohm pull-up resistor.</p>

<h3>Port 1 (Pin 1 through 8)</h3>

<p>It is an 8-bit port (pin 1 through 8) and can be used either as input or output. It doesn't require pull-up resistors because they are already connected internally. Upon reset, Port 1 is configured as an input port. The following code can be used to send alternating values of 55H and AAH to Port 1.</p>

<p>If Port 1 is configured to be used as an output port, then to use it as an input port again, program it by writing 1 to all of its bits as in the following code.</p>

<h3>Port 2 (Pins 21 through 28)</h3>

<p>Port 2 occupies a total of 8 pins (pins 21 through 28) and can be used for both input and output operations. Just as P1 (Port 1), P2 also doesn't require external Pull-up resistors because they are already connected internally. It must be used along with P0 to provide the 16-bit address for the external memory. So it is also designated as (A0–A7), as shown in the pin diagram. When the 8051 is connected to an external memory, it provides path for upper 8-bits of 16-bits address, and it cannot be used as I/O. Upon reset, Port 2 is configured as an input port. The following code can be used to send alternating values of 55H and AAH to port 2.</p>

<p>If Port 2 is configured to be used as an output port, then to use it as an input port again, program it by writing 1 to all of its bits as in the following code.</p>

<h3>Port 3 (Pins 10 through 17)</h3>

<p>It is also of 8 bits and can be used as Input/Output. This port provides some extremely important signals. P3.0 and P3.1 are RxD (Receiver) and TxD (Transmitter) respectively and are collectively used for Serial Communication. P3.2 and P3.3 pins are used for external interrupts. P3.4 and P3.5 are used for timers T0 and T1 respectively. P3.6 and P3.7 are Write (WR) and Read (RD) pins. These are active low pins, means they will be active when 0 is given to them and these are used to provide Read and Write operations to External ROM in 8031 based systems.</p>

<h2>Dual Role of Port 0 and Port 2</h2>

<p><b>Dual role of Port 0</b> &minus; Port 0 is also designated as AD0–AD7, as it can be used for both data and address handling. While connecting an 8051 to external memory, Port 0 can provide both address and data. The 8051 microcontroller then multiplexes the input as address or data in order to save pins.</p>

<p><b>Dual role of Port 2</b> &minus; Besides working as I/O, Port P2 is also used to provide 16-bit address bus for external memory along with Port 0. Port P2 is also designated as (A8– A15), while Port 0 provides the lower 8-bits via A0–A7. In other words, we can say that when an 8051 is connected to an external memory (ROM) which can be maximum up to 64KB and this is possible by 16 bit address bus because we know 216 = 64KB. Port2 is used for the upper 8-bit of the 16 bits address, and it cannot be used for I/O and this is the way any Program code of external ROM is addressed.</p>

<h2>Hardware Connection of Pins</h2>

<p><b>V<sub>cc</sub></b> &minus; Pin 40 provides supply to the Chip and it is +5 V.</p>

<p><b>Gnd</b> &minus; Pin 20 provides ground for the Reference.</p>

<p><b>XTAL1, XTAL2 (Pin no 18 &amp; Pin no 19)</b> &minus; 8051 has on-chip oscillator but requires external clock to run it. A quartz crystal is connected between the XTAL1 &amp; XTAL2 pin of the chip. This crystal also needs two capacitors of 30pF for generating a signal of desired frequency. One side of each capacitor is connected to ground. 8051 IC is available in various speeds and it all depends on this Quartz crystal, for example, a 20 MHz microcontroller requires a crystal with a frequency no more than 20 MHz.</p>

<p><b>RST (Pin No. 9)</b> &minus; It is an Input pin and active High pin. Upon applying a high pulse on this pin, that is 1, the microcontroller will reset and terminate all activities. This process is known as <b>Power-On Reset</b>. Activating a power-on reset will cause all values in the register to be lost. It will set a program counter to all 0's. To ensure a valid input of Reset, the high pulse must be high for a minimum of two machine cycles before it is allowed to go low, which depends on the capacitor value and the rate at which it charges. (<b>Machine Cycle</b> is the minimum amount of frequency a single instruction requires in execution).</p>

<p><b>EA or External Access (Pin No. 31)</b> &minus; It is an input pin. This pin is an active low pin; upon applying a low pulse, it gets activated. In case of microcontroller (8051/52) having on-chip ROM, the EA (bar) pin is connected to V<sub>cc</sub>. But in an 8031 microcontroller which does not have an on-chip ROM, the code is stored in an external ROM and then fetched by the microcontroller. In this case, we must connect the (pin no 31) EA to Gnd to indicate that the program code is stored externally.</p>

<p><b>PSEN or Program store Enable (Pin No 29)</b> &minus; This is also an active low pin, i.e., it gets activated after applying a low pulse. It is an output pin and used along with the EA pin in 8031 based (i.e. ROMLESS) Systems to allow storage of program code in external ROM.</p>

<p><b>ALE or (Address Latch Enable)</b> &minus; This is an Output Pin and is active high. It is especially used for 8031 IC to connect it to the external memory. It can be used while deciding whether P0 pins will be used as Address bus or Data bus. When ALE = 1, then the P0 pins work as Data bus and when ALE = 0, then the P0 pins act as Address bus.</p>

<h2>I/O Ports and Bit Addressability</h2>

<p>It is a most widely used feature of 8051 while writing code for 8051. Sometimes we need to access only 1 or 2 bits of the port instead of the entire 8-bits. 8051 provides the capability to access individual bits of the ports.</p>

<p>While accessing a port in a single-bit manner, we use the syntax "SETB X. Y" where X is the port number (0 to 3), and Y is a bit number (0 to 7) for data bits D0-D7 where D0 is the LSB and D7 is the MSB. For example, "SETB P1.5" sets high bit 5 of port 1.</p>

<p>The following code shows how we can toggle the bit P1.2 continuously.</p>

<h2>Single-Bit Instructions</h2>

<h1>Embedded Systems - Terms</h1>

<h2>Program Counter</h2>

<p>The Program Counter is a 16- or 32-bit register which contains the address of the next instruction to be executed. The PC automatically increments to the next sequential memory location every time an instruction is fetched. Branch, jump, and interrupt operations load the Program Counter with an address other than the next sequential location.</p>

<p>Activating a power-on reset will cause all values in the register to be lost. It means the value of the PC (program counter) is 0 upon reset, forcing the CPU to fetch the first opcode from the ROM memory location 0000. It means we must place the first byte of upcode in ROM location 0000 because that is where the CPU expects to find the first instruction</p>

<h2>Reset Vector</h2>

<p>The significance of the reset vector is that it points the processor to the memory address which contains the firmware's first instruction. Without the Reset Vector, the processor would not know where to begin execution. Upon reset, the processor loads the Program Counter (PC) with the reset vector value from a predefined memory location. On CPU08 architecture, this is at location $FFFE:$FFFF.</p>

<p>When the reset vector is not necessary, developers normally take it for granted and don’t program into the final image. As a result, the processor doesn't start up on the final product. It is a common mistake that takes place during the debug phase.</p>

<h2>Stack Pointer</h2>

<p>Stack is implemented in RAM and a CPU register is used to access it called SP (Stack Pointer) register. SP register is an 8-bit register and can address memory addresses of range 00h to FFh. Initially, the SP register contains value 07 to point to location 08 as the first location being used for the stack by the 8051.</p>

<p>When the content of a CPU register is stored in a stack, it is called a PUSH operation. When the content of a stack is stored in a CPU register, it is called a POP operation. In other words, a register is pushed onto the stack to save it and popped off the stack to retrieve it.</p>

<h2>Infinite Loop</h2>

<p>An infinite loop or an endless loop can be identified as a sequence of instructions in a computer program that executes endlessly in a loop, because of the following reasons &minus;</p>

<p>Such infinite loops normally caused older operating systems to become unresponsive, as an infinite loop consumes all the available processor time. I/O operations waiting for user inputs are also called "infinite loops". One possible cause of a computer "freezing" is an infinite loop; other causes include <b>deadlock</b> and <b>access violations</b>.</p>

<p>Embedded systems, unlike a PC, never "exit" an application. They idle through an Infinite Loop waiting for an event to take place in the form of an interrupt, or a <b>pre-scheduled task</b>. In order to save power, some processors enter special <b>sleep</b> or <b>wait modes</b> instead of idling through an Infinite Loop, but they will come out of this mode upon either a timer or an External Interrupt.</p>

<h2>Interrupts</h2>

<p>Interrupts are mostly hardware mechanisms that instruct the program that an event has occurred. They may occur at any time, and are therefore asynchronous to the program flow. They require special handling by the processor, and are ultimately handled by a corresponding Interrupt Service Routine (ISR). Interrupts need to be handled quickly. If you take too much time servicing an interrupt, then you may miss another interrupt.</p>

<h2>Little Endian Vs Big Endian</h2>

<p>Although numbers are always displayed in the same way, they are not stored in the same way in memory. Big-Endian machines store the most significant byte of data in the lowest memory address. A Big-Endian machine stores 0x12345678 as &minus;</p>

<p>Little-Endian machines, on the other hand, store the least significant byte of data in the lowest memory address. A Little-Endian machine stores 0x12345678 as &minus;</p>

<h1>Embedded Systems - Assembly Language</h1>

<p>Assembly languages were developed to provide <b>mnemonics</b> or symbols for the machine level code instructions. Assembly language programs consist of mnemonics, thus they should be translated into machine code. A program that is responsible for this conversion is known as <b>assembler</b>. Assembly language is often termed as a low-level language because it directly works with the internal structure of the CPU. To program in assembly language, a programmer must know all the registers of the CPU.</p>

<p>Different programming languages such as C, C++, Java and various other languages are called high-level languages because they do not deal with the internal details of a CPU. In contrast, an assembler is used to translate an assembly language program into machine code (sometimes also called <b>object code</b> or <b>opcode</b>). Similarly, a compiler translates a high-level language into machine code. For example, to write a program in C language, one must use a C compiler to translate the program into machine language.</p>

<h2>Structure of Assembly Language</h2>

<p>An assembly language program is a series of statements, which are either assembly language instructions such as ADD and MOV, or statements called <b>directives</b>.</p>

<p>An <b>instruction</b> tells the CPU what to do, while a <b>directive</b> (also called <b>pseudo-instructions</b>) gives instruction to the assembler. For example, ADD and MOV instructions are commands which the CPU runs, while ORG and END are assembler directives. The assembler places the opcode to the memory location 0 when the ORG directive is used, while END indicates to the end of the source code. A program language instruction consists of the following four fields &minus;</p>

<p>A square bracket ( [ ] ) indicates that the field is optional.</p>

<p>The <b>label field</b> allows the program to refer to a line of code by name. The label fields cannot exceed a certain number of characters.</p>

<p>The <b>mnemonics</b> and <b>operands fields</b> together perform the real work of the program and accomplish the tasks. Statements like ADD A , C &amp; MOV C, #68 where ADD and MOV are the mnemonics, which produce opcodes ; "A, C" and "C, #68" are operands. These two fields could contain directives. Directives do not generate machine code and are used only by the assembler, whereas instructions are translated into machine code for the CPU to execute.</p>

<p>The <b>comment field</b> begins with a semicolon which is a comment indicator.</p>

<p>Notice the Label "HERE" in the program. Any label which refers to an instruction should be followed by a colon.</p>

<h2>Assembling and Running an 8051 Program</h2>

<p>Here we will discuss about the basic form of an assembly language. The steps to create, assemble, and run an assembly language program are as follows &minus;</p>

<p>First, we use an editor to type in a program similar to the above program. Editors like MS-DOS EDIT program that comes with all Microsoft operating systems can be used to create or edit a program. The Editor must be able to produce an ASCII file. The "asm" extension for the source file is used by an assembler in the next step.</p>

<p>The "asm" source file contains the program code created in Step 1. It is fed to an 8051 assembler. The assembler then converts the assembly language instructions into machine code instructions and produces an <b>.obj file</b> (object file) and a <b>.lst file</b> (list file). It is also called as a <b>source file</b>, that's why some assemblers require that this file have the "src" extensions. The "lst" file is optional. It is very useful to the program because it lists all the opcodes and addresses as well as errors that the assemblers detected.</p>

<p>Assemblers require a third step called <b>linking</b>. The link program takes one or more object files and produces an absolute object file with the extension "abs".</p>

<p>Next, the "abs" file is fed to a program called "OH" (object to hex converter), which creates a file with the extension "hex" that is ready to burn in to the ROM.</p>

<h2>Data Type</h2>

<p>The 8051 microcontroller contains a single data type of 8-bits, and each register is also of 8-bits size. The programmer has to break down data larger than 8-bits (00 to FFH, or to 255 in decimal) so that it can be processed by the CPU.</p>

<h3>DB (Define Byte)</h3>

<p>The DB directive is the most widely used data directive in the assembler. It is used to define the 8-bit data. It can also be used to define decimal, binary, hex, or ASCII formats data. For decimal, the "D" after the decimal number is optional, but it is required for "B" (binary) and "Hl" (hexadecimal).</p>

<p>To indicate ASCII, simply place the characters in quotation marks ('like this'). The assembler generates ASCII code for the numbers/characters automatically. The DB directive is the only directive that can be used to define ASCII strings larger than two characters; therefore, it should be used for all the ASCII data definitions. Some examples of DB are given below &minus;</p>

<p>Either single or double quotes can be used around ASCII strings. DB is also used to allocate memory in byte-sized chunks.</p>

<h2>Assembler Directives</h2>

<p>Some of the directives of 8051 are as follows &minus;</p>

<p><b>ORG (origin)</b> &minus; The origin directive is used to indicate the beginning of the address. It takes the numbers in hexa or decimal format. If H is provided after the number, the number is treated as hexa, otherwise decimal. The assembler converts the decimal number to hexa.</p>

<p><b>EQU (equate)</b> &minus; It is used to define a constant without occupying a memory location. EQU associates a constant value with a data label so that the label appears in the program, its constant value will be substituted for the label. While executing the instruction "MOV R3, #COUNT", the register R3 will be loaded with the value 25 (notice the # sign). The advantage of using EQU is that the programmer can change it once and the assembler will change all of its occurrences; the programmer does not have to search the entire program.</p>

<p><b>END directive</b> &minus; It indicates the end of the source (asm) file. The END directive is the last line of the program; anything after the END directive is ignored by the assembler.</p>

<h2>Labels in Assembly Language</h2>

<p>All the labels in assembly language must follow the rules given below &minus;</p>

<p>Each label name must be unique. The names used for labels in assembly language programming consist of alphabetic letters in both uppercase and lowercase, number 0 through 9, and special characters such as question mark (?), period (.), at the rate @, underscore (_), and dollar($).</p>

<p>The first character should be in alphabetical character; it cannot be a number.</p>

<p>Reserved words cannot be used as a label in the program. For example, ADD and MOV words are the reserved words, since they are instruction mnemonics.</p>

<h1>Embedded Systems - Registers</h1>

<p>Registers are used in the CPU to store information on temporarily basis which could be data to be processed, or an address pointing to the data which is to be fetched. In 8051, there is one data type is of 8-bits, from the MSB (most significant bit) D7 to the LSB (least significant bit) D0. With 8-bit data type, any data type larger than 8-bits must be broken into 8-bit chunks before it is processed.</p>

<p>The most widely used registers of the 8051 are A (accumulator), B, R0-R7, DPTR (data pointer), and PC (program counter). All these registers are of 8-bits, except DPTR and PC.</p>

<h2>Storage Registers in 8051</h2>

<p>We will discuss the following types of storage registers here &minus;</p>

<h3>Accumulator</h3>

<p>The accumulator, register A, is used for all arithmetic and logic operations. If the accumulator is not present, then every result of each calculation (addition, multiplication, shift, etc.) is to be stored into the main memory. Access to main memory is slower than access to a register like the accumulator because the technology used for the large main memory is slower (but cheaper) than that used for a register.</p>

<h3>The "R" Registers</h3>

<p>The "R" registers are a set of eight registers, namely, R0, R1 to R7. These registers function as auxiliary or temporary storage registers in many operations. Consider an example of the sum of 10 and 20. Store a variable 10 in an accumulator and another variable 20 in, say, register R4. To process the addition operation, execute the following command &minus;</p>

<p>After executing this instruction, the accumulator will contain the value 30. Thus "R" registers are very important auxiliary or <b>helper registers</b>. The Accumulator alone would not be very useful if it were not for these "R" registers. The "R" registers are meant for temporarily storage of values.</p>

<p>Let us take another example. We will add the values in R1 and R2 together and then subtract the values of R3 and R4 from the result.</p>

<p>As you can see, we used R5 to temporarily hold the sum of R3 and R4. Of course, this is not the most efficient way to calculate (R1 + R2) – (R3 + R4), but it does illustrate the use of the "R" registers as a way to store values temporarily.</p>

<h3>The "B" Register</h3>

<p>The "B" register is very similar to the Accumulator in the sense that it may hold an 8-bit (1-byte) value. The "B" register is used only by two 8051 instructions: <b>MUL AB</b> and <b>DIV AB</b>. To quickly and easily multiply or divide A by another number, you may store the other number in "B" and make use of these two instructions. Apart from using MUL and DIV instructions, the "B" register is often used as yet another temporary storage register, much like a ninth R register.</p>

<h3>The Data Pointer</h3>

<p>The Data Pointer (DPTR) is the 8051’s only user-accessible 16-bit (2-byte) register. The Accumulator, R0–R7 registers and B register are 1-byte value registers. DPTR is meant for pointing to data. It is used by the 8051 to access external memory using the address indicated by DPTR. DPTR is the only 16-bit register available and is often used to store 2-byte values.</p>

<h3>The Program Counter</h3>

<p>The Program Counter (PC) is a 2-byte address which tells the 8051 where the next instruction to execute can be found in the memory. PC starts at 0000h when the 8051 initializes and is incremented every time after an instruction is executed. PC is not always incremented by 1. Some instructions may require 2 or 3 bytes; in such cases, the PC will be incremented by 2 or 3.</p>

<p><b>Branch, jump</b>, and <b>interrupt</b> operations load the Program Counter with an address other than the next sequential location. Activating a power-on reset will cause all values in the register to be lost. It means the value of the PC is 0 upon reset, forcing the CPU to fetch the first opcode from the ROM location 0000. It means we must place the first byte of upcode in ROM location 0000 because that is where the CPU expects to find the first instruction.</p>

<h3>The Stack Pointer (SP)</h3>

<p>The Stack Pointer, like all registers except DPTR and PC, may hold an 8-bit (1-byte) value. The Stack Pointer tells the location from where the next value is to be removed from the stack. When a value is pushed onto the stack, the value of SP is incremented and then the value is stored at the resulting memory location. When a value is popped off the stack, the value is returned from the memory location indicated by SP, and then the value of SP is decremented.</p>

<p>This order of operation is important. SP will be initialized to 07h when the 8051 is initialized. If a value is pushed onto the stack at the same time, the value will be stored in the internal RAM address 08h because the 8051 will first increment the value of SP (from 07h to 08h) and then will store the pushed value at that memory address (08h). SP is modified directly by the 8051 by six instructions: PUSH, POP, ACALL, LCALL, RET, and RETI.</p>

<h2>ROM Space in 8051</h2>

<p>Some family members of 8051 have only 4K bytes of on-chip ROM (e.g. 8751, AT8951); some have 8K ROM like AT89C52, and there are some family members with 32K bytes and 64K bytes of on-chip ROM such as Dallas Semiconductor. The point to remember is that no member of the 8051 family can access more than 64K bytes of opcode since the program counter in 8051 is a 16-bit register (0000 to FFFF address).</p>

<p>The first location of the program ROM inside the 8051 has the address of 0000H, whereas the last location can be different depending on the size of the ROM on the chip. Among the 8051 family members, AT8951 has $k bytes of on-chip ROM having a memory address of 0000 (first location) to 0FFFH (last location).</p>

<h3>8051 Flag Bits and PSW Register</h3>

<p>The program status word (PSW) register is an 8-bit register, also known as <b>flag register</b>. It is of 8-bit wide but only 6-bit of it is used. The two unused bits are <b>user-defined flags</b>. Four of the flags are called <b>conditional flags</b>, which means that they indicate a condition which results after an instruction is executed. These four are <b>CY </b>(Carry), <b>AC</b> (auxiliary carry), <b>P</b> (parity), and <b>OV</b> (overflow). The bits RS0 and RS1 are used to change the bank registers. The following figure shows the program status word register.</p>

<p>The PSW Register contains that status bits that reflect the current status of the CPU.</p>

<p></p>

<p>We can select the corresponding Register Bank bit using RS0 and RS1 bits.</p>

<p><b>CY, the carry flag</b> &minus; This carry flag is set (1) whenever there is a carry out from the D7 bit. It is affected after an 8-bit addition or subtraction operation. It can also be reset to 1 or 0 directly by an instruction such as "SETB C" and "CLR C" where "SETB" stands for set bit carry and "CLR" stands for clear carry.</p>

<p><b>AC, auxiliary carry flag</b> &minus; If there is a carry from D3 and D4 during an ADD or SUB operation, the AC bit is set; otherwise, it is cleared. It is used for the instruction to perform binary coded decimal arithmetic.</p>

<p><b>P, the parity flag</b> &minus; The parity flag represents the number of 1's in the accumulator register only. If the A register contains odd number of 1's, then P = 1; and for even number of 1's, P = 0.</p>

<p><b>OV, the overflow flag</b> &minus; This flag is set whenever the result of a signed number operation is too large causing the high-order bit to overflow into the sign bit. It is used only to detect errors in signed arithmetic operations.</p>

<h3>Example</h3>

<p>Show the status of CY, AC, and P flags after the addition of 9CH and 64H in the following instruction.</p>

<h1>Embedded Systems - Registers Bank/Stack</h1>

<p>The 8051 microcontroller has a total of 128 bytes of RAM. We will discuss about the allocation of these 128 bytes of RAM and examine their usage as stack and register.</p>

<h2>RAM Memory Space Allocation in 8051</h2>

<p>The 128 bytes of RAM inside the 8051 are assigned the address 00 to 7FH. They can be accessed directly as memory locations and are divided into three different groups as follows &minus;</p>

<p>32 bytes from 00H to 1FH locations are set aside for register banks and the stack.</p>

<p>16 bytes from 20H to 2FH locations are set aside for bit-addressable read/write memory.</p>

<p>80 bytes from 30H to 7FH locations are used for read and write storage; it is called as <b>scratch pad</b>. These 80 locations RAM are widely used for the purpose of storing data and parameters by 8051 programmers.</p>

<h2>Register Banks in 8051</h2>

<p>A total of 32 bytes of RAM are set aside for the register banks and the stack. These 32 bytes are divided into four register banks in which each bank has 8 registers, R0–R7. RAM locations from 0 to 7 are set aside for bank 0 of R0–R7 where R0 is RAM location 0, R1 is RAM location 1, R2 is location 2, and so on, until the memory location 7, which belongs to R7 of bank 0.</p>

<p>The second bank of registers R0–R7 starts at RAM location 08 and goes to locations OFH. The third bank of R0–R7 starts at memory location 10H and goes to location to 17H. Finally, RAM locations 18H to 1FH are set aside for the fourth bank of R0–R7.</p>

<h2>Default Register Bank</h2>

<p>If RAM locations 00–1F are set aside for the four registers banks, which register bank of R0–R7 do we have access to when the 8051 is powered up? The answer is register bank 0; that is, RAM locations from 0 to 7 are accessed with the names R0 to R7 when programming the 8051. Because it is much easier to refer these RAM locations by names such as R0 to R7, rather than by their memory locations.</p>

<h2>How to Switch Register Banks</h2>

<p>Register bank 0 is the default when the 8051 is powered up. We can switch to the other banks using PSW register. D4 and D3 bits of the PSW are used to select the desired register bank, since they can be accessed by the bit addressable instructions SETB and CLR. For example, "SETB PSW.3" will set PSW.3 = 1 and select the bank register 1.</p>

<h2>Stack and its Operations</h2>

<h3>Stack in the 8051</h3>

<p>The stack is a section of a RAM used by the CPU to store information such as data or memory address on temporary basis. The CPU needs this storage area considering limited number of registers.</p>

<h3>How Stacks are Accessed</h3>

<p>As the stack is a section of a RAM, there are registers inside the CPU to point to it. The register used to access the stack is known as the stack pointer register. The stack pointer in the 8051 is 8-bits wide, and it can take a value of 00 to FFH. When the 8051 is initialized, the SP register contains the value 07H. This means that the RAM location 08 is the first location used for the stack. The storing operation of a CPU register in the stack is known as a <b>PUSH</b>, and getting the contents from the stack back into a CPU register is called a <b>POP</b>.</p>

<h3>Pushing into the Stack</h3>

<p>In the 8051, the stack pointer (SP) points to the last used location of the stack. When data is pushed onto the stack, the stack pointer (SP) is incremented by 1. When PUSH is executed, the contents of the register are saved on the stack and SP is incremented by 1. To push the registers onto the stack, we must use their RAM addresses. For example, the instruction "PUSH 1" pushes register R1 onto the stack.</p>

<h3>Popping from the Stack</h3>

<p>Popping the contents of the stack back into a given register is the opposite to the process of pushing. With every pop operation, the top byte of the stack is copied to the register specified by the instruction and the stack pointer is decremented once.</p>

<h1>Embedded Systems - Instructions</h1>

<p>The flow of program proceeds in a sequential manner, from one instruction to the next instruction, unless a control transfer instruction is executed. The various types of control transfer instruction in assembly language include conditional or unconditional jumps and call instructions.</p>

<h2>Loop and Jump Instructions</h2>

<h3>Looping in the 8051</h3>

<p>Repeating a sequence of instructions a certain number of times is called a <b>loop</b>. An instruction <b>DJNZ reg, label</b> is used to perform a Loop operation. In this instruction, a register is decremented by 1; if it is not zero, then 8051 jumps to the target address referred to by the label.</p>

<p>The register is loaded with the counter for the number of repetitions prior to the start of the loop. In this instruction, both the registers decrement and the decision to jump are combined into a single instruction. The registers can be any of R0–R7. The counter can also be a RAM location.</p>

<h3>Example</h3>

<p><b>Multiply 25 by 10 using the technique of repeated addition.</b></p>

<p><b>Solution</b> &minus; Multiplication can be achieved by adding the multiplicand repeatedly, as many times as the multiplier. For example,</p>

<p>25 * 10 = 250(FAH)</p>

<p>25 + 25 + 25 + 25 + 25 + 25 + 25 + 25 + 25 + 25 = 250</p>

<p><b>Drawback in 8051</b> &minus; Looping action with the instruction <b>DJNZ Reg label</b> is limited to 256 iterations only. If a conditional jump is not taken, then the instruction following the jump is executed.</p>

<h3>Looping inside a Loop</h3>

<p>When we use a loop inside another loop, it is called a <b>nested loop</b>. Two registers are used to hold the count when the maximum count is limited to 256. So we use this method to repeat the action more times than 256.</p>

<p><b>Example</b></p>

<p>Write a program to &minus;</p>

<p><b>Solution</b> &minus; Since 700 is greater than 255 (the maximum capacity of any register), two registers are used to hold the count. The following code shows how to use two registers, R2 and R3, for the count.</p>

<h2>Other Conditional Jumps</h2>

<p>The following table lists the conditional jumps used in 8051 &minus;</p>

<p><b>JZ (jump if A = 0)</b> &minus; In this instruction, the content of the accumulator is checked. If it is zero, then the 8051 jumps to the target address. JZ instruction can be used only for the accumulator, it does not apply to any other register.</p>

<p><b>JNZ (jump if A is not equal to 0)</b> &minus; In this instruction, the content of the accumulator is checked to be non-zero. If it is not zero, then the 8051 jumps to the target address.</p>

<p><b>JNC (Jump if no carry, jumps if CY = 0)</b> &minus; The Carry flag bit in the flag (or PSW) register is used to make the decision whether to jump or not "JNC label". The CPU looks at the carry flag to see if it is raised (CY = 1). If it is not raised, then the CPU starts to fetch and execute instructions from the address of the label. If CY = 1, it will not jump but will execute the next instruction below JNC.</p>

<p><b>JC (Jump if carry, jumps if CY = 1)</b> &minus; If CY = 1, it jumps to the target address.</p>

<p><b>JB (jump if bit is high)</b></p>

<p><b>JNB (jump if bit is low)</b></p>

<p><b>Note</b> &minus; It must be noted that all conditional jumps are short jumps, i.e., the address of the target must be within –128 to +127 bytes of the contents of the program counter.</p>

<h2>Unconditional Jump Instructions</h2>

<p>There are two unconditional jumps in 8051 &minus;</p>

<p><b>LJMP (long jump)</b> &minus; LJMP is 3-byte instruction in which the first byte represents opcode, and the second and third bytes represent the 16-bit address of the target location. The 2-byte target address is to allow a jump to any memory location from 0000 to FFFFH.</p>

<p><b>SJMP (short jump)</b> &minus; It is a 2-byte instruction where the first byte is the opcode and the second byte is the relative address of the target location. The relative address ranges from 00H to FFH which is divided into forward and backward jumps; that is, within –128 to +127 bytes of memory relative to the address of the current PC (program counter). In case of forward jump, the target address can be within a space of 127 bytes from the current PC. In case of backward jump, the target address can be within –128 bytes from the current PC.</p>

<h2>Calculating the Short Jump Address</h2>

<p>All conditional jumps (JNC, JZ, and DJNZ) are short jumps because they are 2-byte instructions. In these instructions, the first byte represents opcode and the second byte represents the relative address. The target address is always relative to the value of the program counter. To calculate the target address, the second byte is added to the PC of the instruction immediately below the jump. Take a look at the program given below &minus;</p>

<h3>Backward Jump Target Address Calculation</h3>

<p>In case of a forward jump, the displacement value is a positive number between 0 to 127 (00 to 7F in hex). However, for a backward jump, the displacement is a negative value of 0 to –128.</p>

<h2>CALL Instructions</h2>

<p>CALL is used to call a subroutine or method. Subroutines are used to perform operations or tasks that need to be performed frequently. This makes a program more structured and saves memory space. There are two instructions &minus; LCALL and ACALL.</p>

<h3>LCALL (Long Call)</h3>

<p>LCALL is a 3-byte instruction where the first byte represents the opcode and the second and third bytes are used to provide the address of the target subroutine. LCALL can be used to call subroutines which are available within the 64K-byte address space of the 8051.</p>

<p>To make a successful return to the point after execution of the called subroutine, the CPU saves the address of the instruction immediately below the LCALL on the stack. Thus, when a subroutine is called, the control is transferred to that subroutine, and the processor saves the PC (program counter) on the stack and begins to fetch instructions from the new location. The instruction RET (return) transfers the control back to the caller after finishing execution of the subroutine. Every subroutine uses RET as the last instruction.</p>

<h3>ACALL (Absolute Call)</h3>

<p>ACALL is a 2-byte instruction, in contrast to LCALL which is 3 bytes. The target address of the subroutine must be within 2K bytes because only 11 bits of the 2 bytes are used for address. The difference between the ACALL and LCALL is that the target address for LCALL can be anywhere within the 64K-bytes address space of the 8051, while the target address of CALL is within a 2K-byte range.</p>

<h1>Embedded Systems - Addressing Modes</h1>

<p>An <b>addressing mode</b> refers to how you are addressing a given memory location. There are five different ways or five addressing modes to execute this instruction which are as follows &minus;</p>

<h2>Immediate Addressing Mode</h2>

<p>Let's begin with an example.</p>

<p>In general, we can write,</p>

<p>It is termed as <b>immediate</b> because 8-bit data is transferred immediately to the accumulator (destination operand).</p>

<p>The following illustration describes the above instruction and its execution. The opcode 74H is saved at 0202 address. The data 6AH is saved at 0203 address in the program memory. After reading the opcode 74H, the data at the next program memory address is transferred to accumulator A (E0H is the address of accumulator). Since the instruction is of 2-bytes and is executed in one cycle, the program counter will be incremented by 2 and will point to 0204 of the program memory.</p>

<p><b>Note</b> &minus; The '#' symbol before 6AH indicates that the operand is a data (8 bit). In the absence of '#', the hexadecimal number would be taken as an address.</p>

<h2>Direct Addressing Mode</h2>

<p>This is another way of addressing an operand. Here, the address of the data (source data) is given as an operand. Let’s take an example.</p>

<p>The register bank#0 (4th register) has the address 04H. When the MOV instruction is executed, the data stored in register 04H is moved to the accumulator. As the register 04H holds the data 1FH, 1FH is moved to the accumulator.</p>

<p><b>Note</b> &minus; We have not used '#' in direct addressing mode, unlike immediate mode. If we had used '#', the data value 04H would have been transferred to the accumulator instead of 1FH.</p>

<p>Now, take a look at the following illustration. It shows how the instruction gets executed.</p>

<p>As shown in the above illustration, this is a 2-byte instruction which requires 1 cycle to complete. The PC will be incremented by 2 and will point to 0204. The opcode for the instruction MOV A, address is E5H. When the instruction at 0202 is executed (E5H), the accumulator is made active and ready to receive data. Then the PC goes to the next address as 0203 and looks up the address of the location of 04H where the source data (to be transferred to accumulator) is located. At 04H, the control finds the data 1F and transfers it to the accumulator and hence the execution is completed.</p>

<h2>Register Direct Addressing Mode</h2>

<p>In this addressing mode, we use the register name directly (as source operand). Let us try to understand with the help of an example.</p>

<p>At a time, the registers can take values from R0 to R7. There are 32 such registers. In order to use 32 registers with just 8 variables to address registers, register banks are used. There are 4 register banks named from 0 to 3. Each bank comprises of 8 registers named from R0 to R7.</p>

<p>At a time, a single register bank can be selected. Selection of a register bank is made possible through a <b>Special Function Register</b> (SFR) named <b>Processor Status Word</b> (PSW). PSW is an 8-bit SFR where each bit can be programmed as required. Bits are designated from PSW.0 to PSW.7. PSW.3 and PSW.4 are used to select register banks.</p>

<p>Now, take a look at the following illustration to get a clear understanding of how it works.</p>

<p>Opcode EC is used for MOV A, R4. The opcode is stored at the address 0202 and when it is executed, the control goes directly to R4 of the respected register bank (that is selected in PSW). If register bank #0 is selected, then the data from R4 of register bank #0 will be moved to the accumulator. Here 2F is stored at 04H. 04H represents the address of R4 of register bank #0.</p>

<p>Data (2F) movement is highlighted in bold. 2F is getting transferred to the accumulator from data memory location 0C H and is shown as dotted line. 0CH is the address location of Register 4 (R4) of register bank #1. The instruction above is 1 byte and requires 1 cycle for complete execution. What it means is, you can save program memory by using register direct addressing mode.</p>

<h2>Register Indirect Addressing Mode</h2>

<p>In this addressing mode, the address of the data is stored in the register as operand.</p>

<p>Here the value inside R0 is considered as an address, which holds the data to be transferred to the accumulator. <b>Example</b>: If R0 has the value 20H, and data 2FH is stored at the address 20H, then the value 2FH will get transferred to the accumulator after executing this instruction. See the following illustration.</p>

<p>So the opcode for <b>MOV A, @R0</b> is E6H. Assuming that the register bank #0 is selected, the R0 of register bank #0 holds the data 20H. Program control moves to 20H where it locates the data 2FH and it transfers 2FH to the accumulator. This is a 1-byte instruction and the program counter increments by 1 and moves to 0203 of the program memory.</p>

<p><b>Note</b> &minus; Only R0 and R1 are allowed to form a register indirect addressing instruction. In other words, the programmer can create an instruction either using @R0 or @R1. All register banks are allowed.</p>

<h2>Indexed Addressing Mode</h2>

<p>We will take two examples to understand the concept of indexed addressing mode. Take a look at the following instructions &minus;</p>

<p>and</p>

<p>where DPTR is the data pointer and PC is the program counter (both are 16-bit registers). Consider the first example.</p>

<p>The source operand is @A+DPTR. It contains the source data from this location. Here we are adding the contents of DPTR with the current content of the accumulator. This addition will give a new address which is the address of the source data. The data pointed by this address is then transferred to the accumulator.</p>

<p>The opcode is 93H. DPTR has the value 01FE, where 01 is located in DPH (higher 8 bits) and FE is located in DPL (lower 8 bits). Accumulator has the value 02H. Then a 16-bit addition is performed and 01FE H+02H results in 0200 H. Data at the location 0200H will get transferred to the accumulator. The previous value inside the accumulator (02H) will be replaced with the new data from 0200H. The new data in the accumulator is highlighted in the illustration.</p>

<p>This is a 1-byte instruction with 2 cycles needed for execution and the execution time required for this instruction is high compared to previous instructions (which were all 1 cycle each).</p>

<p>The other example <b>MOVC A, @A+PC</b> works the same way as the above example. Instead of adding DPTR with the accumulator, here the data inside the program counter (PC) is added with the accumulator to obtain the target address.</p>

<h1>Embedded Systems - SFR Registers</h1>

<p>A Special Function Register (or Special Purpose Register, or simply Special Register) is a register within a microprocessor that controls or monitors the various functions of a microprocessor. As the special registers are closely tied to some special function or status of the processor, they might not be directly writable by normal instructions (like add, move, etc.). Instead, some special registers in some processor architectures require special instructions to modify them.</p>

<p>In the 8051, register A, B, DPTR, and PSW are a part of the group of registers commonly referred to as SFR (special function registers). An SFR can be accessed by its name or by its address.</p>

<p>The following table shows a list of SFRs and their addresses.</p>

<p>Consider the following two points about the SFR addresses.</p>

<p>A special function register can have an address between 80H to FFH. These addresses are above 80H, as the addresses from 00 to 7FH are the addresses of RAM memory inside the 8051.</p>

<p>Not all the address space of 80 to FF are used by the SFR. Unused locations, 80H to FFH, are reserved and must not be used by the 8051 programmer.</p>

<p>In the following example, the SFR registers’ names are replaced with their addresses.</p>

<p>We can select the corresponding Register Bank bit using RS0 and RS1 bits.</p>

<p>The Program Status Word (PSW) contains status bits to reflect the current state of the CPU. The 8051 variants provide one special function register, PSW, with this status information. The 8251 provides two additional status flags, Z and N, which are available in a second special function register called PSW1.</p>

<h1>Embedded Systems - Timer/Counter</h1>

<p>A <b>timer</b> is a specialized type of clock which is used to measure time intervals. A timer that counts from zero upwards for measuring time elapsed is often called a <b>stopwatch</b>. It is a device that counts down from a specified time interval and used to generate a time delay, for example, an hourglass is a timer.</p>

<p>A <b>counter</b> is a device that stores (and sometimes displays) the number of times a particular event or process occurred, with respect to a clock signal. It is used to count the events happening outside the microcontroller. In electronics, counters can be implemented quite easily using register-type circuits such as a flip-flop.</p>

<h2>Difference between a Timer and a Counter</h2>

<p>The points that differentiate a timer from a counter are as follows &minus;</p>

<h2>Timers of 8051 and their Associated Registers</h2>

<p>The 8051 has two timers, Timer 0 and Timer 1. They can be used as timers or as event counters. Both Timer 0 and Timer 1 are 16-bit wide. Since the 8051 follows an 8-bit architecture, each 16 bit is accessed as two separate registers of low-byte and high-byte.</p>

<h3>Timer 0 Register</h3>

<p>The 16-bit register of Timer 0 is accessed as low- and high-byte. The low-byte register is called TL0 (Timer 0 low byte) and the high-byte register is called TH0 (Timer 0 high byte). These registers can be accessed like any other register. For example, the instruction <b>MOV TL0, #4H</b> moves the value into the low-byte of Timer #0.</p>

<h3>Timer 1 Register</h3>

<p>The 16-bit register of Timer 1 is accessed as low- and high-byte. The low-byte register is called TL1 (Timer 1 low byte) and the high-byte register is called TH1 (Timer 1 high byte). These registers can be accessed like any other register. For example, the instruction <b>MOV TL1, #4H</b> moves the value into the low-byte of Timer 1.</p>

<h3>TMOD (Timer Mode) Register</h3>

<p>Both Timer 0 and Timer 1 use the same register to set the various timer operation modes. It is an 8-bit register in which the lower 4 bits are set aside for Timer 0 and the upper four bits for Timers. In each case, the lower 2 bits are used to set the timer mode in advance and the upper 2 bits are used to specify the location.</p>

<p><b>Gate</b> &minus; When set, the timer only runs while INT(0,1) is high.</p>

<p><b>C/T</b> &minus; Counter/Timer select bit.</p>

<p><b>M1</b> &minus; Mode bit 1.</p>

<p><b>M0</b> &minus; Mode bit 0.</p>

<h3>GATE</h3>

<p>Every timer has a means of starting and stopping. Some timers do this by software, some by hardware, and some have both software and hardware controls. 8051 timers have both software and hardware controls. The start and stop of a timer is controlled by software using the instruction <b>SETB TR1</b> and <b>CLR TR1</b> for timer 1, and <b>SETB TR0</b> and <b>CLR TR0</b> for timer 0.</p>

<p>The SETB instruction is used to start it and it is stopped by the CLR instruction. These instructions start and stop the timers as long as GATE = 0 in the TMOD register. Timers can be started and stopped by an external source by making GATE = 1 in the TMOD register.</p>

<h3>C/T (CLOCK / TIMER)</h3>

<p>This bit in the TMOD register is used to decide whether a timer is used as a <b>delay generator</b> or an <b>event manager</b>. If C/T = 0, it is used as a timer for timer delay generation. The clock source to create the time delay is the crystal frequency of the 8051. If C/T = 0, the crystal frequency attached to the 8051 also decides the speed at which the 8051 timer ticks at a regular interval.</p>

<p>Timer frequency is always 1/12th of the frequency of the crystal attached to the 8051. Although various 8051 based systems have an XTAL frequency of 10 MHz to 40 MHz, we normally work with the XTAL frequency of 11.0592 MHz. It is because the baud rate for serial communication of the 8051.XTAL = 11.0592 allows the 8051 system to communicate with the PC with no errors.</p>

<h3>M1 / M2</h3>

<h2>Different Modes of Timers</h2>

<h3>Mode 0 (13-Bit Timer Mode) </h3>

<p>Both Timer 1 and Timer 0 in Mode 0 operate as 8-bit counters (with a divide-by-32 prescaler). Timer register is configured as a 13-bit register consisting of all the 8 bits of TH1 and the lower 5 bits of TL1. The upper 3 bits of TL1 are indeterminate and should be ignored. Setting the run flag (TR1) does not clear the register. The timer interrupt flag TF1 is set when the count rolls over from all 1s to all 0s. Mode 0 operation is the same for Timer 0 as it is for Timer 1.</p>

<h3>Mode 1 (16-Bit Timer Mode)</h3>

<p>Timer mode "1" is a 16-bit timer and is a commonly used mode. It functions in the same way as 13-bit mode except that all 16 bits are used. TLx is incremented starting from 0 to a maximum 255. Once the value 255 is reached, TLx resets to 0 and then THx is incremented by 1. As being a full 16-bit timer, the timer may contain up to 65536 distinct values and it will overflow back to 0 after 65,536 machine cycles.</p>

<h3>Mode 2 (8 Bit Auto Reload)</h3>

<p>Both the timer registers are configured as 8-bit counters (TL1 and TL0) with automatic reload. Overflow from TL1 (TL0) sets TF1 (TF0) and also reloads TL1 (TL0) with the contents of Th1 (TH0), which is preset by software. The reload leaves TH1 (TH0) unchanged.</p>

<p>The benefit of auto-reload mode is that you can have the timer to always contain a value from 200 to 255. If you use mode 0 or 1, you would have to check in the code to see the overflow and, in that case, reset the timer to 200. In this case, precious instructions check the value and/or get reloaded. In mode 2, the microcontroller takes care of this. Once you have configured a timer in mode 2, you don't have to worry about checking to see if the timer has overflowed, nor do you have to worry about resetting the value because the microcontroller hardware will do it all for you. The auto-reload mode is used for establishing a common baud rate.</p>

<h3>Mode 3 (Split Timer Mode)</h3>

<p>Timer mode "3" is known as <b>split-timer mode</b>. When Timer 0 is placed in mode 3, it becomes two separate 8-bit timers. Timer 0 is TL0 and Timer 1 is TH0. Both the timers count from 0 to 255 and in case of overflow, reset back to 0. All the bits that are of Timer 1 will now be tied to TH0.</p>

<p>When Timer 0 is in split mode, the real Timer 1 (i.e. TH1 and TL1) can be set in modes 0, 1 or 2, but it cannot be started/stopped as the bits that do that are now linked to TH0. The real timer 1 will be incremented with every machine cycle.</p>

<h3>Initializing a Timer</h3>

<p>Decide the timer mode. Consider a 16-bit timer that runs continuously, and is independent of any external pins.</p>

<p>Initialize the TMOD SFR. Use the lowest 4 bits of TMOD and consider Timer 0. Keep the two bits, GATE 0 and C/T 0, as 0, since we want the timer to be independent of the external pins. As 16-bit mode is timer mode 1, clear T0M1 and set T0M0. Effectively, the only bit to turn on is bit 0 of TMOD. Now execute the following instruction &minus;</p>

<p>Now, Timer 0 is in 16-bit timer mode, but the timer is not running. To start the timer in running mode, set the TR0 bit by executing the following instruction &minus;</p>

<p>Now, Timer 0 will immediately start counting, being incremented once every machine cycle.</p>

<h2>Reading a Timer</h2>

<p>A 16-bit timer can be read in two ways. Either read the actual value of the timer as a 16-bit number, or you detect when the timer has overflowed.</p>

<h2>Detecting Timer Overflow</h2>

<p>When a timer overflows from its highest value to 0, the microcontroller automatically sets the TFx bit in the TCON register. So instead of checking the exact value of the timer, the TFx bit can be checked. If TF0 is set, then Timer 0 has overflowed; if TF1 is set, then Timer 1 has overflowed.</p>

<h1>Embedded Systems - Interrupt</h1>

<p>An interrupt is a signal to the processor emitted by hardware or software indicating an event that needs immediate attention. Whenever an interrupt occurs, the controller completes the execution of the current instruction and starts the execution of an <b>Interrupt Service Routine</b> (ISR) or <b>Interrupt Handler</b>. ISR tells the processor or controller what to do when the interrupt occurs. The interrupts can be either hardware interrupts or software interrupts.</p>

<h2>Hardware Interrupt</h2>

<p>A hardware interrupt is an electronic alerting signal sent to the processor from an external device, like a disk controller or an external peripheral. For example, when we press a key on the keyboard or move the mouse, they trigger hardware interrupts which cause the processor to read the keystroke or mouse position.</p>

<h2>Software Interrupt</h2>

<p>A software interrupt is caused either by an exceptional condition or a special instruction in the instruction set which causes an interrupt when it is executed by the processor. For example, if the processor's arithmetic logic unit runs a command to divide a number by zero, to cause a divide-by-zero exception, thus causing the computer to abandon the calculation or display an error message. Software interrupt instructions work similar to subroutine calls.</p>

<h2>What is Polling?</h2>

<p>The state of continuous monitoring is known as <b>polling</b>. The microcontroller keeps checking the status of other devices; and while doing so, it does no other operation and consumes all its processing time for monitoring. This problem can be addressed by using interrupts.</p>

<p>In the interrupt method, the controller responds only when an interruption occurs. Thus, the controller is not required to regularly monitor the status (flags, signals etc.) of interfaced and inbuilt devices.</p>

<h3>Interrupts v/s Polling</h3>

<p>Here is an analogy that differentiates an interrupt from polling &minus;</p>

<h2>Interrupt Service Routine</h2>

<p>For every interrupt, there must be an interrupt service routine (ISR), or <b>interrupt handler</b>. When an interrupt occurs, the microcontroller runs the interrupt service routine. For every interrupt, there is a fixed location in memory that holds the address of its interrupt service routine, ISR. The table of memory locations set aside to hold the addresses of ISRs is called as the Interrupt Vector Table.</p>

<h2>Interrupt Vector Table</h2>

<p>There are six interrupts including RESET in 8051.</p>

<p>When the reset pin is activated, the 8051 jumps to the address location 0000. This is power-up reset.</p>

<p>Two interrupts are set aside for the timers: one for timer 0 and one for timer 1. Memory locations are 000BH and 001BH respectively in the interrupt vector table.</p>

<p>Two interrupts are set aside for hardware external interrupts. Pin no. 12 and Pin no. 13 in Port 3 are for the external hardware interrupts INT0 and INT1, respectively. Memory locations are 0003H and 0013H respectively in the interrupt vector table.</p>

<p>Serial communication has a single interrupt that belongs to both receive and transmit. Memory location 0023H belongs to this interrupt.</p>

<h2>Steps to Execute an Interrupt</h2>

<p>When an interrupt gets active, the microcontroller goes through the following steps &minus;</p>

<p>The microcontroller closes the currently executing instruction and saves the address of the next instruction (PC) on the stack.</p>

<p>It also saves the current status of all the interrupts internally (i.e., not on the stack).</p>

<p>It jumps to the memory location of the interrupt vector table that holds the address of the interrupts service routine.</p>

<p>The microcontroller gets the address of the ISR from the interrupt vector table and jumps to it. It starts to execute the interrupt service subroutine, which is RETI (return from interrupt).</p>

<p>Upon executing the RETI instruction, the microcontroller returns to the location where it was interrupted. First, it gets the program counter (PC) address from the stack by popping the top bytes of the stack into the PC. Then, it start to execute from that address.</p>

<h2>Edge Triggering vs. Level Triggering</h2>

<p>Interrupt modules are of two types &minus; level-triggered or edge-triggered.</p>

<h2>Enabling and Disabling an Interrupt</h2>

<p>Upon Reset, all the interrupts are disabled even if they are activated. The interrupts must be enabled using software in order for the microcontroller to respond to those interrupts.</p>

<p>IE (interrupt enable) register is responsible for enabling and disabling the interrupt. IE is a bitaddressable register.</p>

<h3>Interrupt Enable Register</h3>

<p><b>EA</b> &minus; Global enable/disable.</p>

<p><b>-</b> &minus; Undefined.</p>

<p><b>ET2</b> &minus; Enable Timer 2 interrupt.</p>

<p><b>ES</b> &minus; Enable Serial port interrupt.</p>

<p><b>ET1</b> &minus; Enable Timer 1 interrupt.</p>

<p><b>EX1</b> &minus; Enable External 1 interrupt.</p>

<p><b>ET0</b> &minus; Enable Timer 0 interrupt.</p>

<p><b>EX0</b> &minus; Enable External 0 interrupt.</p>

<p>To enable an interrupt, we take the following steps &minus;</p>

<p>Bit D7 of the IE register (EA) must be high to allow the rest of register to take effect.</p>

<p>If EA = 1, interrupts will be enabled and will be responded to, if their corresponding bits in IE are high. If EA = 0, no interrupts will respond, even if their associated pins in the IE register are high.</p>

<h2>Interrupt Priority in 8051</h2>

<p>We can alter the interrupt priority by assigning the higher priority to any one of the interrupts. This is accomplished by programming a register called <b>IP</b> (interrupt priority).</p>

<p>The following figure shows the bits of IP register. Upon reset, the IP register contains all 0's. To give a higher priority to any of the interrupts, we make the corresponding bit in the IP register high.</p>

<p></p>

<h2>Interrupt inside Interrupt</h2>

<p>What happens if the 8051 is executing an ISR that belongs to an interrupt and another one gets active? In such cases, a high-priority interrupt can interrupt a low-priority interrupt. This is known as <b>interrupt inside interrupt</b>. In 8051, a low-priority interrupt can be interrupted by a high-priority interrupt, but not by any another low-priority interrupt.</p>

<h2>Triggering an Interrupt by Software</h2>

<p>There are times when we need to test an ISR by way of simulation. This can be done with the simple instructions to set the interrupt high and thereby cause the 8051 to jump to the interrupt vector table. For example, set the IE bit as 1 for timer 1. An instruction <b>SETB TF1</b> will interrupt the 8051 in whatever it is doing and force it to jump to the interrupt vector table.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
MOV A,#0FFH  ;(comments: A=FFH(Hexadecimal  i.e. A=1111 1111)  

MOV P0,A     ;(Port0 have 1's on every pin so that it works as Input)
</pre>
<h3>Port 1 (Pin 1 through 8)</h3>
<p>It is an 8-bit port (pin 1 through 8) and can be used either as input or output. It doesn't require pull-up resistors because they are already connected internally. Upon reset, Port 1 is configured as an input port. The following code can be used to send alternating values of 55H and AAH to Port 1.</p>
<pre class="result notranslate">
;Toggle all bits of continuously 
MOV     A,#55 
BACK:    

MOV     P2,A 
ACALL   DELAY 
CPL     A      ;complement(invert) reg. A 
SJMP    BACK
</pre>
<p>If Port 1 is configured to be used as an output port, then to use it as an input port again, program it by writing 1 to all of its bits as in the following code.</p>
<pre class="result notranslate">
;Toggle all bits of continuously 

MOV     A ,#0FFH    ;A = FF hex 
MOV     P1,A        ;Make P1 an input port                     
MOV     A,P1        ;get data from P1 
MOV     R7,A        ;save it in Reg R7 
ACALL   DELAY       ;wait 

MOV     A,P1        ;get another data from P1 
MOV     R6,A        ;save it in R6 
ACALL   DELAY       ;wait 

MOV     A,P1        ;get another data from P1 
MOV     R5,A        ;save it in R5
</pre>
<h3>Port 2 (Pins 21 through 28)</h3>
<p>Port 2 occupies a total of 8 pins (pins 21 through 28) and can be used for both input and output operations. Just as P1 (Port 1), P2 also doesn't require external Pull-up resistors because they are already connected internally. It must be used along with P0 to provide the 16-bit address for the external memory. So it is also designated as (A0–A7), as shown in the pin diagram. When the 8051 is connected to an external memory, it provides path for upper 8-bits of 16-bits address, and it cannot be used as I/O. Upon reset, Port 2 is configured as an input port. The following code can be used to send alternating values of 55H and AAH to port 2.</p>
<pre class="result notranslate">
;Toggle all bits of continuously 
MOV     A,#55 
BACK: 
MOV     P2,A 
ACALL   DELAY 
CPL     A         ; complement(invert) reg. A 
SJMP    BACK
</pre>
<p>If Port 2 is configured to be used as an output port, then to use it as an input port again, program it by writing 1 to all of its bits as in the following code.</p>
<pre class="result notranslate">
;Get a byte from P2 and send it to P1 
MOV    A,#0FFH    ;A = FF hex 
MOV    P2,A       ;make P2 an input port 
BACK: 
MOV    A,P2       ;get data from P2 
MOV    P1,A       ;send it to Port 1
SJMP   BACK       ;keep doing that
</pre>
<h3>Port 3 (Pins 10 through 17)</h3>
<p>It is also of 8 bits and can be used as Input/Output. This port provides some extremely important signals. P3.0 and P3.1 are RxD (Receiver) and TxD (Transmitter) respectively and are collectively used for Serial Communication. P3.2 and P3.3 pins are used for external interrupts. P3.4 and P3.5 are used for timers T0 and T1 respectively. P3.6 and P3.7 are Write (WR) and Read (RD) pins. These are active low pins, means they will be active when 0 is given to them and these are used to provide Read and Write operations to External ROM in 8031 based systems.</p>
<table class="table table-bordered">
<tr>
<th width="33%" style="text-align:center;">P3 Bit</th>
<th width="33%" style="text-align:center;">Function</th>
<th width="33%" style="text-align:center;">Pin</th>
</tr>
<tr style="text-align:center;">
<td>P3.0</td>
<td>RxD</td>
<td>10</td>
</tr>
<tr style="text-align:center;">
<td>P3.1 &lt;</td>
<td>TxD</td>
<td>11</td>
</tr>
<tr style="text-align:center;">
<td>P3.2 &lt;</td>
<td>Complement of INT0</td>
<td>12</td>
</tr>
<tr style="text-align:center;">
<td>P3.3 &lt;</td>
<td>INT1</td>
<td>13</td>
</tr>
<tr style="text-align:center;">
<td>P3.4 &lt;</td>
<td>T0</td>
<td>14</td>
</tr>
<tr style="text-align:center;">
<td>P3.5 &lt;</td>
<td>T1</td>
<td>15</td>
</tr>
<tr style="text-align:center;">
<td>P3.6 &lt;</td>
<td>WR</td>
<td>16</td>
</tr>
<tr style="text-align:center;">
<td>P3.7 &lt;</td>
<td>Complement of RD</td>
<td>17</td>
</tr>
</table>
<h2>Dual Role of Port 0 and Port 2</h2>
<ul class="list">
<li><p><b>Dual role of Port 0</b> &minus; Port 0 is also designated as AD0–AD7, as it can be used for both data and address handling. While connecting an 8051 to external memory, Port 0 can provide both address and data. The 8051 microcontroller then multiplexes the input as address or data in order to save pins.</p></li>
<li><p><b>Dual role of Port 2</b> &minus; Besides working as I/O, Port P2 is also used to provide 16-bit address bus for external memory along with Port 0. Port P2 is also designated as (A8– A15), while Port 0 provides the lower 8-bits via A0–A7. In other words, we can say that when an 8051 is connected to an external memory (ROM) which can be maximum up to 64KB and this is possible by 16 bit address bus because we know 216 = 64KB. Port2 is used for the upper 8-bit of the 16 bits address, and it cannot be used for I/O and this is the way any Program code of external ROM is addressed.</p></li>
</ul>
<h2>Hardware Connection of Pins</h2>
<ul class="list">
<li><p><b>V<sub>cc</sub></b> &minus; Pin 40 provides supply to the Chip and it is +5 V.</p></li>
<li><p><b>Gnd</b> &minus; Pin 20 provides ground for the Reference.</p></li>
<li><p><b>XTAL1, XTAL2 (Pin no 18 &amp; Pin no 19)</b> &minus; 8051 has on-chip oscillator but requires external clock to run it. A quartz crystal is connected between the XTAL1 &amp; XTAL2 pin of the chip. This crystal also needs two capacitors of 30pF for generating a signal of desired frequency. One side of each capacitor is connected to ground. 8051 IC is available in various speeds and it all depends on this Quartz crystal, for example, a 20 MHz microcontroller requires a crystal with a frequency no more than 20 MHz.</p></li>
</ul>
<img src="/embedded_systems/images/xtal.jpg" alt="XTAL1, XTAL2 diagram" />
<ul class="list">
<li><p><b>RST (Pin No. 9)</b> &minus; It is an Input pin and active High pin. Upon applying a high pulse on this pin, that is 1, the microcontroller will reset and terminate all activities. This process is known as <b>Power-On Reset</b>. Activating a power-on reset will cause all values in the register to be lost. It will set a program counter to all 0's. To ensure a valid input of Reset, the high pulse must be high for a minimum of two machine cycles before it is allowed to go low, which depends on the capacitor value and the rate at which it charges. (<b>Machine Cycle</b> is the minimum amount of frequency a single instruction requires in execution).</p></li>
<li><p><b>EA or External Access (Pin No. 31)</b> &minus; It is an input pin. This pin is an active low pin; upon applying a low pulse, it gets activated. In case of microcontroller (8051/52) having on-chip ROM, the EA (bar) pin is connected to V<sub>cc</sub>. But in an 8031 microcontroller which does not have an on-chip ROM, the code is stored in an external ROM and then fetched by the microcontroller. In this case, we must connect the (pin no 31) EA to Gnd to indicate that the program code is stored externally.</p></li>
</ul>
<img src="/embedded_systems/images/rst.jpg" alt="RST, EA diagram" />
<ul class="list">
<li><p><b>PSEN or Program store Enable (Pin No 29)</b> &minus; This is also an active low pin, i.e., it gets activated after applying a low pulse. It is an output pin and used along with the EA pin in 8031 based (i.e. ROMLESS) Systems to allow storage of program code in external ROM.</p></li>
<li><p><b>ALE or (Address Latch Enable)</b> &minus; This is an Output Pin and is active high. It is especially used for 8031 IC to connect it to the external memory. It can be used while deciding whether P0 pins will be used as Address bus or Data bus. When ALE = 1, then the P0 pins work as Data bus and when ALE = 0, then the P0 pins act as Address bus.</p></li>
</ul>
<h2>I/O Ports and Bit Addressability</h2>
<p>It is a most widely used feature of 8051 while writing code for 8051. Sometimes we need to access only 1 or 2 bits of the port instead of the entire 8-bits. 8051 provides the capability to access individual bits of the ports.</p>
<p>While accessing a port in a single-bit manner, we use the syntax "SETB X. Y" where X is the port number (0 to 3), and Y is a bit number (0 to 7) for data bits D0-D7 where D0 is the LSB and D7 is the MSB. For example, "SETB P1.5" sets high bit 5 of port 1.</p>  
<p>The following code shows how we can toggle the bit P1.2 continuously.</p>
<pre class="result notranslate">
AGAIN: 
SETB    P1.2
ACALL   DELAY    
CLR     P1.2      
ACALL   DELAY 
SJMP    AGAIN
</pre>
<h2>Single-Bit Instructions</h2>
<table class="table table-bordered">
<tr>
<th>Instructions</th>
<th>Function</th>
</tr>
<tr>
<td>SETB bit</td>
<td>Set the bit (bit = 1)</td>
</tr>
<tr>
<td>CLR bit</td>
<td>clear the bit (bit = 0)</td>
</tr>
<tr>
<td>CPL bit</td>
<td>complement the bit (bit = NOT bit)</td>
</tr>
<tr>
<td>JB bit, target</td>
<td>jump to target if bit = 1 (jump if bit)</td>
</tr>
<tr>
<td>JNB bit, target</td>
<td>jump to target if bit = 0 (jump if no bit)</td>
</tr>
<tr>
<td>JBC bit, target</td>
<td>jump to target if bit = 1, clear bit (jump if bit, then clear)</td>
</tr>
</table>
<h1>Embedded Systems - Terms</h1>
<h2>Program Counter</h2>
<p>The Program Counter is a 16- or 32-bit register which contains the address of the next instruction to be executed. The PC automatically increments to the next sequential memory location every time an instruction is fetched. Branch, jump, and interrupt operations load the Program Counter with an address other than the next sequential location.</p>
<p>Activating a power-on reset will cause all values in the register to be lost. It means the value of the PC (program counter) is 0 upon reset, forcing the CPU to fetch the first opcode from the ROM memory location 0000. It means we must place the first byte of upcode in ROM location 0000 because that is where the CPU expects to find the first instruction</p>
<h2>Reset Vector</h2>
<p>The significance of the reset vector is that it points the processor to the memory address which contains the firmware's first instruction. Without the Reset Vector, the processor would not know where to begin execution. Upon reset, the processor loads the Program Counter (PC) with the reset vector value from a predefined memory location. On CPU08 architecture, this is at location $FFFE:$FFFF.</p>
<p>When the reset vector is not necessary, developers normally take it for granted and don’t program into the final image. As a result, the processor doesn't start up on the final product. It is a common mistake that takes place during the debug phase.</p>
<h2>Stack Pointer</h2>
<p>Stack is implemented in RAM and a CPU register is used to access it called SP (Stack Pointer) register. SP register is an 8-bit register and can address memory addresses of range 00h to FFh. Initially, the SP register contains value 07 to point to location 08 as the first location being used for the stack by the 8051.</p> 
<p>When the content of a CPU register is stored in a stack, it is called a PUSH operation. When the content of a stack is stored in a CPU register, it is called a POP operation. In other words, a register is pushed onto the stack to save it and popped off the stack to retrieve it.</p>
<h2>Infinite Loop</h2>
<p>An infinite loop or an endless loop can be identified as a sequence of instructions in a computer program that executes endlessly in a loop, because of the following reasons &minus;</p>
<ul class="list">
<li>loop with no terminating condition.</li>
<li>loop with a terminating condition that can never be met.</li>
<li>loop with a terminating condition that causes the loop to start over.</li>
</ul>
<p>Such infinite loops normally caused older operating systems to become unresponsive, as an infinite loop consumes all the available processor time. I/O operations waiting for user inputs are also called "infinite loops". One possible cause of a computer "freezing" is an infinite loop; other causes include <b>deadlock</b> and <b>access violations</b>.</p>
<p>Embedded systems, unlike a PC, never "exit" an application. They idle through an Infinite Loop waiting for an event to take place in the form of an interrupt, or a <b>pre-scheduled task</b>. In order to save power, some processors enter special <b>sleep</b> or <b>wait modes</b> instead of idling through an Infinite Loop, but they will come out of this mode upon either a timer or an External Interrupt.</p>
<h2>Interrupts</h2>
<p>Interrupts are mostly hardware mechanisms that instruct the program that an event has occurred. They may occur at any time, and are therefore asynchronous to the program flow. They require special handling by the processor, and are ultimately handled by a corresponding Interrupt Service Routine (ISR). Interrupts need to be handled quickly. If you take too much time servicing an interrupt, then you may miss another interrupt.</p>
<h2>Little Endian Vs Big Endian</h2>
<p>Although numbers are always displayed in the same way, they are not stored in the same way in memory. Big-Endian machines store the most significant byte of data in the lowest memory address. A Big-Endian machine stores 0x12345678 as &minus;</p>
<pre class="result notranslate">
ADD+0: 0x12 
ADD+1: 0x34 
ADD+2: 0x56 
ADD+3: 0x78
</pre>
<p>Little-Endian machines, on the other hand, store the least significant byte of data in the lowest memory address. A Little-Endian machine stores 0x12345678 as &minus;</p>
<pre class="result notranslate">
ADD+0: 0x78 
ADD+1: 0x56 
ADD+2: 0x34 
ADD+3: 0x12
</pre>
<h1>Embedded Systems - Assembly Language</h1>
<p>Assembly languages were developed to provide <b>mnemonics</b> or symbols for the machine level code instructions. Assembly language programs consist of mnemonics, thus they should be translated into machine code. A program that is responsible for this conversion is known as <b>assembler</b>. Assembly language is often termed as a low-level language because it directly works with the internal structure of the CPU. To program in assembly language, a programmer must know all the registers of the CPU.</p>  
<p>Different programming languages such as C, C++, Java and various other languages are called high-level languages because they do not deal with the internal details of a CPU. In contrast, an assembler is used to translate an assembly language program into machine code (sometimes also called <b>object code</b> or <b>opcode</b>). Similarly, a compiler translates a high-level language into machine code. For example, to write a program in C language, one must use a C compiler to translate the program into machine language.</p>
<h2>Structure of Assembly Language</h2>
<p>An assembly language program is a series of statements, which are either assembly language instructions such as ADD and MOV, or statements called <b>directives</b>.</p>
<p>An <b>instruction</b> tells the CPU what to do, while a <b>directive</b> (also called <b>pseudo-instructions</b>) gives instruction to the assembler. For example, ADD and MOV instructions are commands which the CPU runs, while ORG and END are assembler directives. The assembler places the opcode to the memory location 0 when the ORG directive is used, while END indicates to the end of the source code. A program language instruction consists of the following four fields &minus;</p>
<pre class="result notranslate">
[ label: ]   mnemonics  [ operands ]   [;comment ] 
</pre>
<p>A square bracket ( [ ] ) indicates that the field is optional.</p>
<ul class="list">
<li><p>The <b>label field</b> allows the program to refer to a line of code by name. The label fields cannot exceed a certain number of characters.</p></li>
<li><p>The <b>mnemonics</b> and <b>operands fields</b> together perform the real work of the program and accomplish the tasks. Statements like ADD A , C &amp; MOV C, #68 where ADD and MOV are the mnemonics, which produce opcodes ; "A, C" and "C, #68" are operands. These two fields could contain directives. Directives do not generate machine code and are used only by the assembler, whereas instructions are translated into machine code for the CPU to execute.</p></li>
</ul>
<pre class="result notranslate">
1.0000         ORG  0H            ;start (origin) at location 0 
2 0000 7D25    MOV  R5,#25H       ;load 25H into R5 
3.0002 7F34    MOV  R7,#34H       ;load 34H into  R7 
4.0004 7400    MOV  A,#0          ;load 0 into A 
5.0006 2D      ADD  A,R5          ;add contents of R5 to A 
6.0007 2F      ADD  A,R7          ;add contents of R7 to A
7.0008 2412    ADD  A,#12H        ;add to A value 12 H 
8.000A 80FE    HERE: SJMP HERE    ;stay in this loop 
9.000C END                        ;end of asm source file
</pre>
<ul class="list">
<li><p>The <b>comment field</b> begins with a semicolon which is a comment indicator.</p></li>
<li><p>Notice the Label "HERE" in the program. Any label which refers to an instruction should be followed by a colon.</p></li>
</ul>
<h2>Assembling and Running an 8051 Program</h2>
<p>Here we will discuss about the basic form of an assembly language. The steps to create, assemble, and run an assembly language program are as follows &minus;</p>
<ul class="list">
<li><p>First, we use an editor to type in a program similar to the above program. Editors like MS-DOS EDIT program that comes with all Microsoft operating systems can be used to create or edit a program. The Editor must be able to produce an ASCII file. The "asm" extension for the source file is used by an assembler in the next step.</p></li>
<li><p>The "asm" source file contains the program code created in Step 1. It is fed to an 8051 assembler. The assembler then converts the assembly language instructions into machine code instructions and produces an <b>.obj file</b> (object file) and a <b>.lst file</b> (list file). It is also called as a <b>source file</b>, that's why some assemblers require that this file have the "src" extensions. The "lst" file is optional. It is very useful to the program because it lists all the opcodes and addresses as well as errors that the assemblers detected.</p></li> 
<li><p>Assemblers require a third step called <b>linking</b>. The link program takes one or more object files and produces an absolute object file with the extension "abs".</p></li>  
<li><p>Next, the "abs" file is fed to a program called "OH" (object to hex converter), which creates a file with the extension "hex" that is ready to burn in to the ROM.</p></li>
</ul>
<img src="/embedded_systems/images/steps_program.jpg" alt="Steps to create program" />
<h2>Data Type</h2>
<p>The 8051 microcontroller contains a single data type of 8-bits, and each register is also of 8-bits size. The programmer has to break down data larger than 8-bits (00 to FFH, or to 255 in decimal) so that it can be processed by the CPU.</p>
<h3>DB (Define Byte)</h3>
<p>The DB directive is the most widely used data directive in the assembler. It is used to define the 8-bit data. It can also be used to define decimal, binary, hex, or ASCII formats data. For decimal, the "D" after the decimal number is optional, but it is required for "B" (binary) and "Hl" (hexadecimal).</p>
<p>To indicate ASCII, simply place the characters in quotation marks ('like this'). The assembler generates ASCII code for the numbers/characters automatically. The DB directive is the only directive that can be used to define ASCII strings larger than two characters; therefore, it should be used for all the ASCII data definitions. Some examples of DB are given below &minus;</p>
<pre class="result notranslate">
        ORG  500H 
DATA1:  DB   28                     ;DECIMAL (1C in hex) 
DATA2:  DB   00110101B              ;BINARY  (35 in hex) 
DATA3:  DB   39H                    ;HEX 
        ORG  510H 
DATA4:  DB   "2591"                 ;ASCII  NUMBERS 
        ORG  520H                         
DATA6:  DA   "MY NAME IS Michael"   ;ASCII CHARACTERS 
</pre>
<p>Either single or double quotes can be used around ASCII strings. DB is also used to allocate memory in byte-sized chunks.</p>
<h2>Assembler Directives</h2>
<p>Some of the directives of 8051 are as follows &minus;</p>
<ul class="list">
<li><p><b>ORG (origin)</b> &minus; The origin directive is used to indicate the beginning of the address. It takes the numbers in hexa or decimal format. If H is provided after the number, the number is treated as hexa, otherwise decimal. The assembler converts the decimal number to hexa.</p></li>
<li><p><b>EQU (equate)</b> &minus; It is used to define a constant without occupying a memory location. EQU associates a constant value with a data label so that the label appears in the program, its constant value will be substituted for the label. While executing the instruction "MOV R3, #COUNT", the register R3 will be loaded with the value 25 (notice the # sign). The advantage of using EQU is that the programmer can change it once and the assembler will change all of its occurrences; the programmer does not have to search the entire program.</p></li>
<li><p><b>END directive</b> &minus; It indicates the end of the source (asm) file. The END directive is the last line of the program; anything after the END directive is ignored by the assembler.</p></li>
</ul>
<h2>Labels in Assembly Language</h2>
<p>All the labels in assembly language must follow the rules given below &minus;</p>
<ul class="list">
<li><p>Each label name must be unique. The names used for labels in assembly language programming consist of alphabetic letters in both uppercase and lowercase, number 0 through 9, and special characters such as question mark (?), period (.), at the rate @, underscore (_), and dollar($).</p></li>
<li><p>The first character should be in alphabetical character; it cannot be a number.</p></li>
<li><p>Reserved words cannot be used as a label in the program. For example, ADD and MOV words are the reserved words, since they are instruction mnemonics.</p></li>
</ul>
<h1>Embedded Systems - Registers</h1>
<p>Registers are used in the CPU to store information on temporarily basis which could be data to be processed, or an address pointing to the data which is to be fetched. In 8051, there is one data type is of 8-bits, from the MSB (most significant bit) D7 to the LSB (least significant bit) D0. With 8-bit data type, any data type larger than 8-bits must be broken into 8-bit chunks before it is processed.</p>
<p>The most widely used registers of the 8051 are A (accumulator), B, R0-R7, DPTR (data pointer), and PC (program counter). All these registers are of 8-bits, except DPTR and PC.</p>
<h2>Storage Registers in 8051</h2>
<p>We will discuss the following types of storage registers here &minus;</p>
<ul class="list">
<li>Accumulator</li>
<li>R register</li>
<li>B register</li>
<li>Data Pointer (DPTR)</li>
<li>Program Counter (PC)</li>
<li>Stack Pointer (SP)</li>
</ul>
<h3>Accumulator</h3>
<p>The accumulator, register A, is used for all arithmetic and logic operations. If the accumulator is not present, then every result of each calculation (addition, multiplication, shift, etc.) is to be stored into the main memory. Access to main memory is slower than access to a register like the accumulator because the technology used for the large main memory is slower (but cheaper) than that used for a register.</p> 
<h3>The "R" Registers</h3> 
<p>The "R" registers are a set of eight registers, namely, R0, R1 to R7. These registers function as auxiliary or temporary storage registers in many operations. Consider an example of the sum of 10 and 20. Store a variable 10 in an accumulator and another variable 20 in, say, register R4. To process the addition operation, execute the following command &minus;</p>
<pre class="result notranslate">
ADD A,R4
</pre>
<p>After executing this instruction, the accumulator will contain the value 30. Thus "R" registers are very important auxiliary or <b>helper registers</b>. The Accumulator alone would not be very useful if it were not for these "R" registers. The "R" registers are meant for temporarily storage of values.</p>
<p>Let us take another example. We will add the values in R1 and R2 together and then subtract the values of R3 and R4 from the result.</p>
<pre class="result notranslate">
MOV A,R3   ;Move the value of R3 into the accumulator 
ADD A,R4   ;Add the value of R4 
MOV R5,A   ;Store the resulting value temporarily in R5 
MOV A,R1   ;Move the value of R1 into the accumulator 
ADD A,R2   ;Add the value of R2 
SUBB A,R5  ;Subtract the value of R5 (which now contains R3 + R4)
</pre>
<p>As you can see, we used R5 to temporarily hold the sum of R3 and R4. Of course, this is not the most efficient way to calculate (R1 + R2) – (R3 + R4), but it does illustrate the use of the "R" registers as a way to store values temporarily.</p>
<img src="/embedded_systems/images/8bit_registers.jpg" alt="8 Bit registers" />
<h3>The "B" Register</h3> 
<p>The "B" register is very similar to the Accumulator in the sense that it may hold an 8-bit (1-byte) value. The "B" register is used only by two 8051 instructions: <b>MUL AB</b> and <b>DIV AB</b>. To quickly and easily multiply or divide A by another number, you may store the other number in "B" and make use of these two instructions. Apart from using MUL and DIV instructions, the "B" register is often used as yet another temporary storage register, much like a ninth R register.</p> 
<h3>The Data Pointer</h3>
<p>The Data Pointer (DPTR) is the 8051’s only user-accessible 16-bit (2-byte) register. The Accumulator, R0–R7 registers and B register are 1-byte value registers. DPTR is meant for pointing to data. It is used by the 8051 to access external memory using the address indicated by DPTR. DPTR is the only 16-bit register available and is often used to store 2-byte values.</p>
<h3>The Program Counter</h3>
<p>The Program Counter (PC) is a 2-byte address which tells the 8051 where the next instruction to execute can be found in the memory. PC starts at 0000h when the 8051 initializes and is incremented every time after an instruction is executed. PC is not always incremented by 1. Some instructions may require 2 or 3 bytes; in such cases, the PC will be incremented by 2 or 3.</p> 
<p><b>Branch, jump</b>, and <b>interrupt</b> operations load the Program Counter with an address other than the next sequential location. Activating a power-on reset will cause all values in the register to be lost. It means the value of the PC is 0 upon reset, forcing the CPU to fetch the first opcode from the ROM location 0000. It means we must place the first byte of upcode in ROM location 0000 because that is where the CPU expects to find the first instruction.</p>
<h3>The Stack Pointer (SP)</h3> 
<p>The Stack Pointer, like all registers except DPTR and PC, may hold an 8-bit (1-byte) value. The Stack Pointer tells the location from where the next value is to be removed from the stack. When a value is pushed onto the stack, the value of SP is incremented and then the value is stored at the resulting memory location. When a value is popped off the stack, the value is returned from the memory location indicated by SP, and then the value of SP is decremented.</p> 
<p>This order of operation is important. SP will be initialized to 07h when the 8051 is initialized. If a value is pushed onto the stack at the same time, the value will be stored in the internal RAM address 08h because the 8051 will first increment the value of SP (from 07h to 08h) and then will store the pushed value at that memory address (08h). SP is modified directly by the 8051 by six instructions: PUSH, POP, ACALL, LCALL, RET, and RETI.</p>
<h2>ROM Space in 8051</h2>
<p>Some family members of 8051 have only 4K bytes of on-chip ROM (e.g. 8751, AT8951); some have 8K ROM like AT89C52, and there are some family members with 32K bytes and 64K bytes of on-chip ROM such as Dallas Semiconductor. The point to remember is that no member of the 8051 family can access more than 64K bytes of opcode since the program counter in 8051 is a 16-bit register (0000 to FFFF address).</p>
<p>The first location of the program ROM inside the 8051 has the address of 0000H, whereas the last location can be different depending on the size of the ROM on the chip. Among the 8051 family members, AT8951 has $k bytes of on-chip ROM having a memory address of 0000 (first location) to 0FFFH (last location).</p>
<img src="/embedded_systems/images/rom_space.jpg" alt="ROM Space" />
<h3>8051 Flag Bits and PSW Register</h3> 
<p>The program status word (PSW) register is an 8-bit register, also known as <b>flag register</b>. It is of 8-bit wide but only 6-bit of it is used. The two unused bits are <b>user-defined flags</b>. Four of the flags are called <b>conditional flags</b>, which means that they indicate a condition which results after an instruction is executed. These four are <b>CY </b>(Carry), <b>AC</b> (auxiliary carry), <b>P</b> (parity), and <b>OV</b> (overflow). The bits RS0 and RS1 are used to change the bank registers. The following figure shows the program status word register.</p>
<p>The PSW Register contains that status bits that reflect the current status of the CPU.</p>
<table class="table table-bordered">
<tr>
<th>CY</th>
<th>CA</th>
<th>F0</th>
<th>RS1</th>
<th>RS0</th>
<th>OV</th>
<th>-</th>
<th>P</th>
</tr>
</table>
<p></p>
<table class="table table-bordered">
<tr>
<td>CY</td>
<td>PSW.7</td>
<td>Carry Flag</td>
</tr>
<tr>
<td>AC</td>
<td>PSW.6</td>
<td>Auxiliary Carry Flag</td>
</tr>
<tr>
<td>F0</td>
<td>PSW.5</td>
<td>Flag 0 available to user for general purpose.</td>
</tr>
<tr>
<td>RS1</td>
<td>PSW.4</td>
<td>Register Bank selector bit 1</td>
</tr>
<tr>
<td>RS0</td>
<td>PSW.3</td>
<td>Register Bank selector bit 0</td>
</tr>
<tr>
<td>OV</td>
<td>PSW.2</td>
<td>Overflow Flag</td>
</tr>
<tr>
<td>-</td>
<td>PSW.1</td>
<td>User definable FLAG</td>
</tr>
<tr>
<td>P</td>
<td>PSW.0</td>
<td>Parity FLAG. Set/ cleared by hardware during instruction cycle to indicate even/odd number of 1 bit in accumulator.</td>
</tr>
</table>
<p>We can select the corresponding Register Bank bit using RS0 and RS1 bits.</p>
<table class="table table-bordered">
<tr>
<th style="text-align:center;">RS1</th>
<th style="text-align:center;">RS2</th>
<th style="text-align:center;">Register Bank</th>
<th style="text-align:center;">Address</th>
</tr>
<tr style="text-align:center;">
<td>0</td>
<td>0</td>
<td>0</td>
<td>00H-07H</td>
</tr>
<tr style="text-align:center;">
<td>0</td>
<td>1</td>
<td>1</td>
<td>08H-0FH</td>
</tr>
<tr style="text-align:center;">
<td>1</td>
<td>0</td>
<td>2</td>
<td>10H-17H</td>
</tr>
<tr style="text-align:center;">
<td>1</td>
<td>1</td>
<td>3</td>
<td>18H-1FH</td>
</tr>
</table>
<ul class="list">
<li><p><b>CY, the carry flag</b> &minus; This carry flag is set (1) whenever there is a carry out from the D7 bit. It is affected after an 8-bit addition or subtraction operation. It can also be reset to 1 or 0 directly by an instruction such as "SETB C" and "CLR C" where "SETB" stands for set bit carry and "CLR" stands for clear carry.</p></li>
<li><p><b>AC, auxiliary carry flag</b> &minus; If there is a carry from D3 and D4 during an ADD or SUB operation, the AC bit is set; otherwise, it is cleared. It is used for the instruction to perform binary coded decimal arithmetic.</p></li>
<li><p><b>P, the parity flag</b> &minus; The parity flag represents the number of 1's in the accumulator register only. If the A register contains odd number of 1's, then P = 1; and for even number of 1's, P = 0.</p></li>
<li><p><b>OV, the overflow flag</b> &minus; This flag is set whenever the result of a signed number operation is too large causing the high-order bit to overflow into the sign bit. It is used only to detect errors in signed arithmetic operations.</p></li>
</ul>
<h3>Example</h3> 
<p>Show the status of CY, AC, and P flags after the addition of 9CH and 64H in the following instruction.</p>
<p style="padding-left:10%;">MOV A, #9CH</p>
<p style="padding-left:10%;">ADD A, # 64H</p>
<pre class="result notranslate">
Solution:  9C   10011100 
          +64   01100100 
          100   00000000 
			 
CY = 1 since there is a carry beyond D7 bit  
AC = 0 since there is a carry from D3 to D4 
P  = 0 because the accumulator has even number of 1's 
</pre>
<h1>Embedded Systems - Registers Bank/Stack</h1>
<p>The 8051 microcontroller has a total of 128 bytes of RAM. We will discuss about the allocation of these 128 bytes of RAM and examine their usage as stack and register.</p>
<h2>RAM Memory Space Allocation in 8051</h2>
<p>The 128 bytes of RAM inside the 8051 are assigned the address 00 to 7FH. They can be accessed directly as memory locations and are divided into three different groups as follows &minus;</p>
<ul class="list">
<li><p>32 bytes from 00H to 1FH locations are set aside for register banks and the stack.</p></li>
<li><p>16 bytes from 20H to 2FH locations are set aside for bit-addressable read/write memory.</p></li>
<li><p>80 bytes from 30H to 7FH locations are used for read and write storage; it is called as <b>scratch pad</b>. These 80 locations RAM are widely used for the purpose of storing data and parameters by 8051 programmers.</p></li>
</ul>
<img src="/embedded_systems/images/rom_allocation.jpg" alt="ROM Space Allocation" />
<h2>Register Banks in 8051</h2>
<p>A total of 32 bytes of RAM are set aside for the register banks and the stack. These 32 bytes are divided into four register banks in which each bank has 8 registers, R0–R7. RAM locations from 0 to 7 are set aside for bank 0 of R0–R7 where R0 is RAM location 0, R1 is RAM location 1, R2 is location 2, and so on, until the memory location 7, which belongs to R7 of bank 0.</p>  
<p>The second bank of registers R0–R7 starts at RAM location 08 and goes to locations OFH. The third bank of R0–R7 starts at memory location 10H and goes to location to 17H. Finally, RAM locations 18H to 1FH are set aside for the fourth bank of R0–R7.</p>
<h2>Default Register Bank</h2> 
<p>If RAM locations 00–1F are set aside for the four registers banks, which register bank of R0–R7 do we have access to when the 8051 is powered up? The answer is register bank 0; that is, RAM locations from 0 to 7 are accessed with the names R0 to R7 when programming the 8051. Because it is much easier to refer these RAM locations by names such as R0 to R7, rather than by their memory locations.</p>
<h2>How to Switch Register Banks</h2>
<p>Register bank 0 is the default when the 8051 is powered up. We can switch to the other banks using PSW register. D4 and D3 bits of the PSW are used to select the desired register bank, since they can be accessed by the bit addressable instructions SETB and CLR. For example, "SETB PSW.3" will set PSW.3 = 1 and select the bank register 1.</p>
<table class="table table-bordered">
<tr>
<th style="text-align:center;">RS1</th>
<th style="text-align:center;">RS2</th>
<th style="text-align:center;">Bank Selected</th>
</tr>
<tr style="text-align:center;">
<td>0</td>
<td>0</td>
<td>Bank0</td>
</tr>
<tr style="text-align:center;">
<td>0</td>
<td>1</td>
<td>Bank1</td>
</tr>
<tr style="text-align:center;">
<td>1</td>
<td>0</td>
<td>Bank2</td>
</tr>
<tr style="text-align:center;">
<td>1</td>
<td>1</td>
<td>Bank3</td>
</tr>
</table>
<h2>Stack and its Operations</h2>
<h3>Stack in the 8051</h3>  
<p>The stack is a section of a RAM used by the CPU to store information such as data or memory address on temporary basis. The CPU needs this storage area considering limited number of registers.</p>
<h3>How Stacks are Accessed</h3> 
<p>As the stack is a section of a RAM, there are registers inside the CPU to point to it. The register used to access the stack is known as the stack pointer register. The stack pointer in the 8051 is 8-bits wide, and it can take a value of 00 to FFH. When the 8051 is initialized, the SP register contains the value 07H. This means that the RAM location 08 is the first location used for the stack. The storing operation of a CPU register in the stack is known as a <b>PUSH</b>, and getting the contents from the stack back into a CPU register is called a <b>POP</b>.</p>
<h3>Pushing into the Stack</h3>
<p>In the 8051, the stack pointer (SP) points to the last used location of the stack. When data is pushed onto the stack, the stack pointer (SP) is incremented by 1. When PUSH is executed, the contents of the register are saved on the stack and SP is incremented by 1. To push the registers onto the stack, we must use their RAM addresses. For example, the instruction "PUSH 1" pushes register R1 onto the stack.</p>
<h3>Popping from the Stack</h3>
<p>Popping the contents of the stack back into a given register is the opposite to the process of pushing. With every pop operation, the top byte of the stack is copied to the register specified by the instruction and the stack pointer is decremented once.</p>
<h1>Embedded Systems - Instructions</h1>
<p>The flow of program proceeds in a sequential manner, from one instruction to the next instruction, unless a control transfer instruction is executed. The various types of control transfer instruction in assembly language include conditional or unconditional jumps and call instructions.</p>
<h2>Loop and Jump Instructions</h2>
<h3>Looping in the 8051</h3>
<p>Repeating a sequence of instructions a certain number of times is called a <b>loop</b>. An instruction <b>DJNZ reg, label</b> is used to perform a Loop operation. In this instruction, a register is decremented by 1; if it is not zero, then 8051 jumps to the target address referred to by the label.</p>
<p>The register is loaded with the counter for the number of repetitions prior to the start of the loop. In this instruction, both the registers decrement and the decision to jump are combined into a single instruction. The registers can be any of R0–R7. The counter can also be a RAM location.</p>
<h3>Example</h3>
<p><b>Multiply 25 by 10 using the technique of repeated addition.</b></p>
<p><b>Solution</b> &minus; Multiplication can be achieved by adding the multiplicand repeatedly, as many times as the multiplier. For example,</p>
<p>25 * 10 = 250(FAH)</p>
<p>25 + 25 + 25 + 25 + 25 + 25 + 25 + 25 + 25 + 25 = 250</p>
<pre class="result notranslate">
   MOV A,#0             ;A = 0,clean ACC 
   MOV R2,#10           ; the multiplier is replaced in R2 
   Add A,#25            ;add the multiplicand to the ACC 
	
AGAIN:DJNZ R2, 
AGAIN:repeat  until R2 = 0 (10 times) 

   MOV R5 , A           ;save A in R5 ;R5 (FAH)
</pre>
<p><b>Drawback in 8051</b> &minus; Looping action with the instruction <b>DJNZ Reg label</b> is limited to 256 iterations only. If a conditional jump is not taken, then the instruction following the jump is executed.</p>
<h3>Looping inside a Loop</h3> 
<p>When we use a loop inside another loop, it is called a <b>nested loop</b>. Two registers are used to hold the count when the maximum count is limited to 256. So we use this method to repeat the action more times than 256.</p>
<p><b>Example</b></p>
<p>Write a program to &minus;</p>
<ul class="list">
<li>Load the accumulator with the value 55H.</li>
<li>Complement the ACC 700 times.</li>
</ul>
<p><b>Solution</b> &minus; Since 700 is greater than 255 (the maximum capacity of any register), two registers are used to hold the count. The following code shows how to use two registers, R2 and R3, for the count.</p>
<pre class="prettyprint notranslate">
   MOV A,#55H            ;A = 55H 
	
NEXT: MOV R3,#10         ;R3 the outer loop counter 
AGAIN:MOV R2,#70         ;R2 the inner loop counter 

   CPL A                 ;complement
</pre>
<h2>Other Conditional Jumps</h2>
<p>The following table lists the conditional jumps used in 8051 &minus;</p>
<table class="table table-bordered">
<tr>
<th>Instruction</th>
<th>Action</th>
</tr>
<tr>
<td>JZ</td>
<td>Jump if A = 0</td>
</tr>
<tr>
<td>JNZ</td>
<td>Jump if A &ne; 0</td>
</tr>
<tr>
<td>DJNZ</td>
<td>Decrement and Jump if register &ne; 0</td>
</tr>
<tr>
<td>CJNE A, data</td>
<td>Jump if A &ne; data</td>
</tr>
<tr>
<td>CJNE reg, #data</td>
<td>Jump if byte &ne; data</td>
</tr>
<tr>
<td>JC</td>
<td>Jump if CY = 1</td>
</tr>
<tr>
<td>JNC</td>
<td>Jump if CY &ne; 1</td>
</tr>
<tr>
<td>JB</td>
<td>Jump if bit = 1</td>
</tr>
<tr>
<td>JNB</td>
<td>Jump if bit = 0</td>
</tr>
<tr>
<td>JBC</td>
<td>Jump if bit = 1 and clear bit</td>
</tr>
</table>
<ul class="list">
<li><p><b>JZ (jump if A = 0)</b> &minus; In this instruction, the content of the accumulator is checked. If it is zero, then the 8051 jumps to the target address. JZ instruction can be used only for the accumulator, it does not apply to any other register.</p></li>
<li><p><b>JNZ (jump if A is not equal to 0)</b> &minus; In this instruction, the content of the accumulator is checked to be non-zero. If it is not zero, then the 8051 jumps to the target address.</p></li>
<li><p><b>JNC (Jump if no carry, jumps if CY = 0)</b> &minus; The Carry flag bit in the flag (or PSW) register is used to make the decision whether to jump or not "JNC label". The CPU looks at the carry flag to see if it is raised (CY = 1). If it is not raised, then the CPU starts to fetch and execute instructions from the address of the label. If CY = 1, it will not jump but will execute the next instruction below JNC.</p></li>
<li><p><b>JC (Jump if carry, jumps if CY = 1)</b> &minus; If CY = 1, it jumps to the target address.</p></li>
<li><p><b>JB (jump if bit is high)</b></p></li>
<li><p><b>JNB (jump if bit is low)</b></p></li>
</ul>
<p><b>Note</b> &minus; It must be noted that all conditional jumps are short jumps, i.e., the address of the target must be within –128 to +127 bytes of the contents of the program counter.</p>
<h2>Unconditional Jump Instructions</h2>
<p>There are two unconditional jumps in 8051 &minus;</p>
<ul class="list">
<li><p><b>LJMP (long jump)</b> &minus; LJMP is 3-byte instruction in which the first byte represents opcode, and the second and third bytes represent the 16-bit address of the target location. The 2-byte target address is to allow a jump to any memory location from 0000 to FFFFH.</p></li>
<li><p><b>SJMP (short jump)</b> &minus; It is a 2-byte instruction where the first byte is the opcode and the second byte is the relative address of the target location. The relative address ranges from 00H to FFH which is divided into forward and backward jumps; that is, within –128 to +127 bytes of memory relative to the address of the current PC (program counter). In case of forward jump, the target address can be within a space of 127 bytes from the current PC. In case of backward jump, the target address can be within –128 bytes from the current PC.</p></li>
</ul>
<h2>Calculating the Short Jump Address</h2>
<p>All conditional jumps (JNC, JZ, and DJNZ) are short jumps because they are 2-byte instructions. In these instructions, the first byte represents opcode and the second byte represents the relative address. The target address is always relative to the value of the program counter. To calculate the target address, the second byte is added to the PC of the instruction immediately below the jump. Take a look at the program given below &minus;</p>
<pre class="result notranslate">
Line   PC    Op-code   Mnemonic   Operand 
1      0000               ORG       0000 
2      0000  7800         MOV       R0,#003  
3      0002  7455         MOV       A,#55H0 
4      0004  6003         JZ        NEXT 
5      0006  08           INC       R0 
6      0007  04   AGAIN:  INC       A 
7      0008  04           INC       A 
8      0009  2477 NEXT:   ADD       A, #77h 
9      000B  5005         JNC       OVER 
10     000D  E4           CLR       A
11     000E  F8           MOV       R0, A 
12     000F  F9           MOV       R1, A 
13     0010  FA          MOV       R2, A 
14     0011  FB           MOV       R3, A 
15     0012  2B   OVER:   ADD       A, R3 
16     0013  50F2         JNC       AGAIN 
17     0015  80FE HERE:   SJMP      HERE 
18     0017             END
</pre>
<h3>Backward Jump Target Address Calculation</h3> 
<p>In case of a forward jump, the displacement value is a positive number between 0 to 127 (00 to 7F in hex). However, for a backward jump, the displacement is a negative value of 0 to –128.</p>
<h2>CALL Instructions</h2>
<p>CALL is used to call a subroutine or method. Subroutines are used to perform operations or tasks that need to be performed frequently. This makes a program more structured and saves memory space. There are two instructions &minus; LCALL and ACALL.</p>
<h3>LCALL (Long Call)</h3>
<p>LCALL is a 3-byte instruction where the first byte represents the opcode and the second and third bytes are used to provide the address of the target subroutine. LCALL can be used to call subroutines which are available within the 64K-byte address space of the 8051.</p>
<p>To make a successful return to the point after execution of the called subroutine, the CPU saves the address of the instruction immediately below the LCALL on the stack. Thus, when a subroutine is called, the control is transferred to that subroutine, and the processor saves the PC (program counter) on the stack and begins to fetch instructions from the new location. The instruction RET (return) transfers the control back to the caller after finishing execution of the subroutine. Every subroutine uses RET as the last instruction.</p>
<h3>ACALL (Absolute Call)</h3> 
<p>ACALL is a 2-byte instruction, in contrast to LCALL which is 3 bytes. The target address of the subroutine must be within 2K bytes because only 11 bits of the 2 bytes are used for address. The difference between the ACALL and LCALL is that the target address for LCALL can be anywhere within the 64K-bytes address space of the 8051, while the target address of CALL is within a 2K-byte range.</p>
<h1>Embedded Systems - Addressing Modes</h1>
<p>An <b>addressing mode</b> refers to how you are addressing a given memory location. There are five different ways or five addressing modes to execute this instruction which are as follows &minus;</p>
<ul class="list">
<li>Immediate addressing mode</li>
<li>Direct addressing mode</li>
<li>Register direct addressing mode</li>
<li>Register indirect addressing mode</li>
<li>Indexed addressing mode</li>
</ul>
<h2>Immediate Addressing Mode</h2>
<p>Let's begin with an example.</p>
<pre class="result notranslate">
MOV A, #6AH 
</pre>
<p>In general, we can write,</p>
<pre class="result notranslate">
MOV A, #data
</pre>
<p>It is termed as <b>immediate</b> because 8-bit data is transferred immediately to the accumulator (destination operand).</p>  
<p>The following illustration describes the above instruction and its execution. The opcode 74H is saved at 0202 address. The data 6AH is saved at 0203 address in the program memory. After reading the opcode 74H, the data at the next program memory address is transferred to accumulator A (E0H is the address of accumulator). Since the instruction is of 2-bytes and is executed in one cycle, the program counter will be incremented by 2 and will point to 0204 of the program memory.</p>
<img src="/embedded_systems/images/immidiate_addressing_mode.jpg" alt="Immediate Addressing Mode" />
<p><b>Note</b> &minus; The '#' symbol before 6AH indicates that the operand is a data (8 bit). In the absence of '#', the hexadecimal number would be taken as an address.</p>
<h2>Direct Addressing Mode</h2>
<p>This is another way of addressing an operand. Here, the address of the data (source data) is given as an operand. Let’s take an example.</p>
<pre class="result notranslate">
MOV A, 04H 
</pre>
<p>The register bank#0 (4th register) has the address 04H. When the MOV instruction is executed, the data stored in register 04H is moved to the accumulator. As the register 04H holds the data 1FH, 1FH is moved to the accumulator.</p>
<p><b>Note</b> &minus; We have not used '#' in direct addressing mode, unlike immediate mode. If we had used '#', the data value 04H would have been transferred to the accumulator instead of 1FH.</p>
<p>Now, take a look at the following illustration. It shows how the instruction gets executed.</p>
<img src="/embedded_systems/images/direct_addressing_mode.jpg" alt="Direct Addressing Mode" />
<p>As shown in the above illustration, this is a 2-byte instruction which requires 1 cycle to complete. The PC will be incremented by 2 and will point to 0204. The opcode for the instruction MOV A, address is E5H. When the instruction at 0202 is executed (E5H), the accumulator is made active and ready to receive data. Then the PC goes to the next address as 0203 and looks up the address of the location of 04H where the source data (to be transferred to accumulator) is located. At 04H, the control finds the data 1F and transfers it to the accumulator and hence the execution is completed.</p>
<h2>Register Direct Addressing Mode</h2>
<p>In this addressing mode, we use the register name directly (as source operand). Let us try to understand with the help of an example.</p>
<pre class="result notranslate">
MOV A, R4 
</pre>
<p>At a time, the registers can take values from R0 to R7. There are 32 such registers. In order to use 32 registers with just 8 variables to address registers, register banks are used. There are 4 register banks named from 0 to 3. Each bank comprises of 8 registers named from R0 to R7.</p> 
<p>At a time, a single register bank can be selected. Selection of a register bank is made possible through a <b>Special Function Register</b> (SFR) named <b>Processor Status Word</b> (PSW). PSW is an 8-bit SFR where each bit can be programmed as required. Bits are designated from PSW.0 to PSW.7. PSW.3 and PSW.4 are used to select register banks.</p>
<p>Now, take a look at the following illustration to get a clear understanding of how it works.</p>
<img src="/embedded_systems/images/register_direct_mode.jpg" alt="Register Direct Addressing Mode" />
<p>Opcode EC is used for MOV A, R4. The opcode is stored at the address 0202 and when it is executed, the control goes directly to R4 of the respected register bank (that is selected in PSW). If register bank #0 is selected, then the data from R4 of register bank #0 will be moved to the accumulator. Here 2F is stored at 04H. 04H represents the address of R4 of register bank #0.</p>
<p>Data (2F) movement is highlighted in bold. 2F is getting transferred to the accumulator from data memory location 0C H and is shown as dotted line. 0CH is the address location of Register 4 (R4) of register bank #1. The instruction above is 1 byte and requires 1 cycle for complete execution. What it means is, you can save program memory by using register direct addressing mode.</p>
<h2>Register Indirect Addressing Mode</h2>
<p>In this addressing mode, the address of the data is stored in the register as operand.</p>
<pre class="result notranslate">
MOV A, @R0 
</pre>
<p>Here the value inside R0 is considered as an address, which holds the data to be transferred to the accumulator. <b>Example</b>: If R0 has the value 20H, and data 2FH is stored at the address 20H, then the value 2FH will get transferred to the accumulator after executing this instruction. See the following illustration.</p>
<img src="/embedded_systems/images/register_indirect_mode.jpg" alt="Register Indirect Addressing Mode" />
<p>So the opcode for <b>MOV A, @R0</b> is E6H. Assuming that the register bank #0 is selected, the R0 of register bank #0 holds the data 20H. Program control moves to 20H where it locates the data 2FH and it transfers 2FH to the accumulator. This is a 1-byte instruction and the program counter increments by 1 and moves to 0203 of the program memory.</p>
<p><b>Note</b> &minus; Only R0 and R1 are allowed to form a register indirect addressing instruction. In other words, the programmer can create an instruction either using @R0 or @R1. All register banks are allowed.</p>
<h2>Indexed Addressing Mode</h2>
<p>We will take two examples to understand the concept of indexed addressing mode. Take a look at the following instructions &minus;</p>
<p style="padding-left:10%;"><b>MOVC A, @A+DPTR</b></p>
<p>and</p>
<p style="padding-left:10%;"><b>MOVC A, @A+PC</b></p>
<p>where DPTR is the data pointer and PC is the program counter (both are 16-bit registers). Consider the first example.</p>
<pre class="result notranslate">
MOVC A, @A+DPTR
</pre>
<p>The source operand is @A+DPTR. It contains the source data from this location. Here we are adding the contents of DPTR with the current content of the accumulator. This addition will give a new address which is the address of the source data. The data pointed by this address is then transferred to the accumulator.</p>
<img src="/embedded_systems/images/indexed_mode.jpg" alt="Indexed Addressing Mode" />
<p>The opcode is 93H. DPTR has the value 01FE, where 01 is located in DPH (higher 8 bits) and FE is located in DPL (lower 8 bits). Accumulator has the value 02H. Then a 16-bit addition is performed and 01FE H+02H results in 0200 H. Data at the location 0200H will get transferred to the accumulator. The previous value inside the accumulator (02H) will be replaced with the new data from 0200H. The new data in the accumulator is highlighted in the illustration.</p>
<p>This is a 1-byte instruction with 2 cycles needed for execution and the execution time required for this instruction is high compared to previous instructions (which were all 1 cycle each).</p>
<p>The other example <b>MOVC A, @A+PC</b> works the same way as the above example. Instead of adding DPTR with the accumulator, here the data inside the program counter (PC) is added with the accumulator to obtain the target address.</p>
<h1>Embedded Systems - SFR Registers</h1>
<p>A Special Function Register (or Special Purpose Register, or simply Special Register) is a register within a microprocessor that controls or monitors the various functions of a microprocessor. As the special registers are closely tied to some special function or status of the processor, they might not be directly writable by normal instructions (like add, move, etc.). Instead, some special registers in some processor architectures require special instructions to modify them.</p>
<p>In the 8051, register A, B, DPTR, and PSW are a part of the group of registers commonly referred to as SFR (special function registers). An SFR can be accessed by its name or by its address.</p>
<p>The following table shows a list of SFRs and their addresses.</p>
<table class="table table-bordered">
<tr style="text-align:center">
<th width="12%" style="text-align:center">Byte Address</th>
<th width="75%" colspan="8" style="text-align:center">Bit Address </th>
<th width="12%"></th>
</tr>
<tr>
<td width="12%" style="text-align:center">FF</td>
<td width="75%" colspan="8"></td>
<td width="12%"></td>
</tr>
<tr style="text-align:center">
<td>F0</td>
<td>F7</td>
<td>F6</td>
<td>F5</td>
<td>F4</td>
<td>F3</td>
<td>F2</td>
<td>F1</td>
<td>F0</td>
<td>B</td>
</tr>
<tr>
<td width="12%"></td>
<td width="75%" colspan="8"></td>
<td width="12%"></td>
</tr>
<tr style="text-align:center">
<td>E0</td>
<td>E7</td>
<td>E6</td>
<td>E5</td>
<td>E4</td>
<td>E3</td>
<td>E2</td>
<td>E1</td>
<td>E0</td>
<td>ACC</td>
</tr>
<tr>
<td width="12%"></td>
<td width="75%" colspan="8"></td>
<td width="12%"></td>
</tr>
<tr style="text-align:center">
<td>D0</td>
<td>D7</td>
<td>D6</td>
<td>D5</td>
<td>D4</td>
<td>D3</td>
<td>D2</td>
<td>-</td>
<td>D0</td>
<td>PSW</td>
</tr>
<tr style="text-align:center">
<td>B8</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>BC</td>
<td>BB</td>
<td>BA</td>
<td>B9</td>
<td>B8</td>
<td>IP</td>
</tr>
<tr style="text-align:center">
<td>B0</td>
<td>B7</td>
<td>B6</td>
<td>B5</td>
<td>B4</td>
<td>B3</td>
<td>B2</td>
<td>B1</td>
<td>B0</td>
<td>P3</td>
</tr>
<tr>
<td width="12%"></td>
<td width="75%" colspan="8"></td>
<td width="12%"></td>
</tr>
<tr style="text-align:center">
<td>A2</td>
<td>AF</td>
<td>-</td>
<td>-</td>
<td>AC</td>
<td>AB</td>
<td>AA</td>
<td>A9</td>
<td>A8</td>
<td>IE</td>
</tr>
<tr>
<td width="12%"></td>
<td width="75%" colspan="8"></td>
<td width="12%"></td>
</tr>
<tr style="text-align:center">
<td>A0</td>
<td>A7</td>
<td>A6</td>
<td>A5</td>
<td>A4</td>
<td>A3</td>
<td>A2</td>
<td>A1</td>
<td>A0</td>
<td>P2</td>
</tr>
<tr>
<td width="12%"></td>
<td width="75%" colspan="8"></td>
<td width="12%"></td>
</tr>
<tr style="text-align:center">
<td width="12%">99</td>
<td width="75%" colspan="8">Not bit Addressable</td>
<td width="12%">SBUF</td>
</tr>
<tr style="text-align:center">
<td>98</td>
<td>9F</td>
<td>9E</td>
<td>9D</td>
<td>9C</td>
<td>9B</td>
<td>9A</td>
<td>99</td>
<td>98</td>
<td>SCON</td>
</tr>
<tr>
<td width="12%"></td>
<td width="75%" colspan="8"></td>
<td width="12%"></td>
</tr>
<tr style="text-align:center">
<td>90</td>
<td>97</td>
<td>96</td>
<td>95</td>
<td>94</td>
<td>93</td>
<td>92</td>
<td>91</td>
<td>90</td>
<td>P1</td>
</tr>
<tr>
<td width="12%"></td>
<td width="75%" colspan="8"></td>
<td width="12%"></td>
</tr>
<tr style="text-align:center">
<td width="12%">8D</td>
<td width="75%" colspan="8">Not bit Addressable</td>
<td width="12%">TH1</td>
</tr>
<tr style="text-align:center">
<td width="12%">8C</td>
<td width="75%" colspan="8">Not bit Addressable</td>
<td width="12%">TH0</td>
</tr>
<tr style="text-align:center">
<td width="12%">8B</td>
<td width="75%" colspan="8">Not bit Addressable</td>
<td width="12%">TL1</td>
</tr>
<tr style="text-align:center">
<td width="12%">8A</td>
<td width="75%" colspan="8">Not bit Addressable</td>
<td width="12%">TL0</td>
</tr>
<tr style="text-align:center">
<td width="12%">89</td>
<td width="75%" colspan="8">Not bit Addressable</td>
<td width="12%">TMOD</td>
</tr>
<tr style="text-align:center">
<td>88</td>
<td>8F</td>
<td>8E</td>
<td>8D</td>
<td>8C</td>
<td>8B</td>
<td>8A</td>
<td>89</td>
<td>88</td>
<td>TCON</td>
</tr>
<tr style="text-align:center">
<td width="12%">87</td>
<td width="75%" colspan="8">Not bit Addressable</td>
<td width="12%">PCON</td>
</tr>
<tr>
<td width="12%"></td>
<td width="75%" colspan="8"></td>
<td width="12%"></td>
</tr>
<tr style="text-align:center">
<td width="12%">83</td>
<td width="75%" colspan="8">Not bit Addressable</td>
<td width="12%">DPH</td>
</tr>
<tr style="text-align:center">
<td width="12%">82</td>
<td width="75%" colspan="8">Not bit Addressable</td>
<td width="12%">DPL</td>
</tr>
<tr style="text-align:center">
<td width="12%">81</td>
<td width="75%" colspan="8">Not bit Addressable</td>
<td width="12%">SP</td>
</tr>
<tr style="text-align:center">
<td>80</td>
<td>87</td>
<td>87</td>
<td>85</td>
<td>84</td>
<td>83</td>
<td>82</td>
<td>81</td>
<td>80</td>
<td>P0</td>
</tr>
</table>
<p>Consider the following two points about the SFR addresses.</p>
<ul class="list">
<li><p>A special function register can have an address between 80H to FFH. These addresses are above 80H, as the addresses from 00 to 7FH are the addresses of RAM memory inside the 8051.</p></li>
<li><p>Not all the address space of 80 to FF are used by the SFR. Unused locations, 80H to FFH, are reserved and must not be used by the 8051 programmer.</p></li>
</ul>
<table class="table table-bordered">
<tr>
<td>CY</td>
<td>PSW.7</td>
<td>Carry Flag</td>
</tr>
<tr>
<td>AC</td>
<td>PSW.6</td>
<td>Auxiliary Carry Flag</td>
</tr>
<tr>
<td>F0</td>
<td>PSW.5</td>
<td>Flag 0 available to user for general purpose.</td>
</tr>
<tr>
<td>RS1</td>
<td>PSW.4</td>
<td>Register Bank selector bit 1</td>
</tr>
<tr>
<td>RS0</td>
<td>PSW.3</td>
<td>Register Bank selector bit 0</td>
</tr>
<tr>
<td>OV</td>
<td>PSW.2</td>
<td>Overflow Flag</td>
</tr>
<tr>
<td>-</td>
<td>PSW.1</td>
<td>User definable FLAG</td>
</tr>
<tr>
<td>P</td>
<td>PSW.0</td>
<td>Parity FLAG. Set/ cleared by hardware during instruction cycle to indicate even/odd number of 1 bit in accumulator.</td>
</tr>
</table>
<p>In the following example, the SFR registers’ names are replaced with their addresses.</p>
<table class="table table-bordered">
<tr>
<th>CY</th>
<th>AC</th>
<th>F0</th>
<th>RS1</th>
<th>RS0</th>
<th>OV</th>
<th>-</th>
<th>P</th>
</tr>
</table>
<p>We can select the corresponding Register Bank bit using RS0 and RS1 bits.</p>
<table class="table table-bordered">
<tr>
<th style="text-align:center;">RS1</th>
<th style="text-align:center;">RS2</th>
<th style="text-align:center;">Register Bank</th>
<th style="text-align:center;">Address</th>
</tr>
<tr style="text-align:center;">
<td>0</td>
<td>0</td>
<td>0</td>
<td>00H-07H</td>
</tr>
<tr style="text-align:center;">
<td>0</td>
<td>1</td>
<td>1</td>
<td>08H-0FH</td>
</tr>
<tr style="text-align:center;">
<td>1</td>
<td>0</td>
<td>2</td>
<td>10H-17H</td>
</tr>
<tr style="text-align:center;">
<td>1</td>
<td>1</td>
<td>3</td>
<td>18H-1FH</td>
</tr>
</table>
<p>The Program Status Word (PSW) contains status bits to reflect the current state of the CPU. The 8051 variants provide one special function register, PSW, with this status information. The 8251 provides two additional status flags, Z and N, which are available in a second special function register called PSW1.</p>
<h1>Embedded Systems - Timer/Counter</h1>
<p>A <b>timer</b> is a specialized type of clock which is used to measure time intervals. A timer that counts from zero upwards for measuring time elapsed is often called a <b>stopwatch</b>. It is a device that counts down from a specified time interval and used to generate a time delay, for example, an hourglass is a timer.</p>
<p>A <b>counter</b> is a device that stores (and sometimes displays) the number of times a particular event or process occurred, with respect to a clock signal. It is used to count the events happening outside the microcontroller. In electronics, counters can be implemented quite easily using register-type circuits such as a flip-flop.</p>
<h2>Difference between a Timer and a Counter</h2>
<p>The points that differentiate a timer from a counter are as follows &minus;</p>
<table class="table table-bordered">
<tr>
<th>Timer</th>
<th>Counter</th>
</tr>
<tr>
<td>The register incremented for every machine cycle.</td>
<td>The register is incremented considering 1 to 0 transition at its corresponding to an external input pin (T0, T1).</td>
</tr>
<tr>
<td>Maximum count rate is 1/12 of the oscillator frequency.</td>
<td>Maximum count rate is 1/24 of the oscillator frequency.</td>
</tr>
<tr>
<td>A timer uses the frequency of the internal clock, and generates delay.</td>
<td>A counter uses an external signal to count pulses.</td>
</tr>
</table>
<h2>Timers of 8051 and their Associated Registers</h2>
<p>The 8051 has two timers, Timer 0 and Timer 1. They can be used as timers or as event counters. Both Timer 0 and Timer 1 are 16-bit wide. Since the 8051 follows an 8-bit architecture, each 16 bit is accessed as two separate registers of low-byte and high-byte.</p>
<h3>Timer 0 Register</h3> 
<p>The 16-bit register of Timer 0 is accessed as low- and high-byte. The low-byte register is called TL0 (Timer 0 low byte) and the high-byte register is called TH0 (Timer 0 high byte). These registers can be accessed like any other register. For example, the instruction <b>MOV TL0, #4H</b> moves the value into the low-byte of Timer #0.</p>
<img src="/embedded_systems/images/timer0.jpg" alt="Timer 0" />
<h3>Timer 1 Register</h3>
<p>The 16-bit register of Timer 1 is accessed as low- and high-byte. The low-byte register is called TL1 (Timer 1 low byte) and the high-byte register is called TH1 (Timer 1 high byte). These registers can be accessed like any other register. For example, the instruction <b>MOV TL1, #4H</b> moves the value into the low-byte of Timer 1.</p>
<img src="/embedded_systems/images/timer1.jpg" alt="Timer 1" />
<h3>TMOD (Timer Mode) Register</h3>
<p>Both Timer 0 and Timer 1 use the same register to set the various timer operation modes. It is an 8-bit register in which the lower 4 bits are set aside for Timer 0 and the upper four bits for Timers. In each case, the lower 2 bits are used to set the timer mode in advance and the upper 2 bits are used to specify the location.</p>
<img src="/embedded_systems/images/tmod.jpg" alt="TMOD Register" />
<p><b>Gate</b> &minus; When set, the timer only runs while INT(0,1) is high.</p> 
<p><b>C/T</b> &minus; Counter/Timer select bit.</p> 
<p><b>M1</b> &minus; Mode bit 1.</p> 
<p><b>M0</b> &minus; Mode bit 0.</p>
<h3>GATE</h3>
<p>Every timer has a means of starting and stopping. Some timers do this by software, some by hardware, and some have both software and hardware controls. 8051 timers have both software and hardware controls. The start and stop of a timer is controlled by software using the instruction <b>SETB TR1</b> and <b>CLR TR1</b> for timer 1, and <b>SETB TR0</b> and <b>CLR TR0</b> for timer 0.</p>
<p>The SETB instruction is used to start it and it is stopped by the CLR instruction. These instructions start and stop the timers as long as GATE = 0 in the TMOD register. Timers can be started and stopped by an external source by making GATE = 1 in the TMOD register.</p>
<h3>C/T (CLOCK / TIMER)</h3>
<p>This bit in the TMOD register is used to decide whether a timer is used as a <b>delay generator</b> or an <b>event manager</b>. If C/T = 0, it is used as a timer for timer delay generation. The clock source to create the time delay is the crystal frequency of the 8051. If C/T = 0, the crystal frequency attached to the 8051 also decides the speed at which the 8051 timer ticks at a regular interval.</p>
<p>Timer frequency is always 1/12th of the frequency of the crystal attached to the 8051. Although various 8051 based systems have an XTAL frequency of 10 MHz to 40 MHz, we normally work with the XTAL frequency of 11.0592 MHz. It is because the baud rate for serial communication of the 8051.XTAL = 11.0592 allows the 8051 system to communicate with the PC with no errors.</p>
<h3>M1 / M2</h3>
<table class="table table-bordered">
<tr>
<th style="text-align:center;">M1</th>
<th style="text-align:center;">M2</th>
<th style="text-align:center;">Mode</th>
</tr>
<tr style="text-align:center;">
<td>0</td>
<td>0</td>
<td>13-bit timer mode.</td>
</tr>
<tr style="text-align:center;">
<td>0</td>
<td>1</td>
<td>16-bit timer mode.</td>
</tr>
<tr style="text-align:center;">
<td>1</td>
<td>0</td>
<td>8-bit auto reload mode.</td>
</tr>
<tr style="text-align:center;">
<td>1</td>
<td>1</td>
<td>Spilt mode.</td>
</tr>
</table>
<h2>Different Modes of Timers</h2>
<h3>Mode 0 (13-Bit Timer Mode) </h3>
<p>Both Timer 1 and Timer 0 in Mode 0 operate as 8-bit counters (with a divide-by-32 prescaler). Timer register is configured as a 13-bit register consisting of all the 8 bits of TH1 and the lower 5 bits of TL1. The upper 3 bits of TL1 are indeterminate and should be ignored. Setting the run flag (TR1) does not clear the register. The timer interrupt flag TF1 is set when the count rolls over from all 1s to all 0s. Mode 0 operation is the same for Timer 0 as it is for Timer 1.</p>
<h3>Mode 1 (16-Bit Timer Mode)</h3>
<p>Timer mode "1" is a 16-bit timer and is a commonly used mode. It functions in the same way as 13-bit mode except that all 16 bits are used. TLx is incremented starting from 0 to a maximum 255. Once the value 255 is reached, TLx resets to 0 and then THx is incremented by 1. As being a full 16-bit timer, the timer may contain up to 65536 distinct values and it will overflow back to 0 after 65,536 machine cycles.</p>
<h3>Mode 2 (8 Bit Auto Reload)</h3> 
<p>Both the timer registers are configured as 8-bit counters (TL1 and TL0) with automatic reload. Overflow from TL1 (TL0) sets TF1 (TF0) and also reloads TL1 (TL0) with the contents of Th1 (TH0), which is preset by software. The reload leaves TH1 (TH0) unchanged.</p>
<p>The benefit of auto-reload mode is that you can have the timer to always contain a value from 200 to 255. If you use mode 0 or 1, you would have to check in the code to see the overflow and, in that case, reset the timer to 200. In this case, precious instructions check the value and/or get reloaded. In mode 2, the microcontroller takes care of this. Once you have configured a timer in mode 2, you don't have to worry about checking to see if the timer has overflowed, nor do you have to worry about resetting the value because the microcontroller hardware will do it all for you. The auto-reload mode is used for establishing a common baud rate.</p>
<h3>Mode 3 (Split Timer Mode)</h3> 
<p>Timer mode "3" is known as <b>split-timer mode</b>. When Timer 0 is placed in mode 3, it becomes two separate 8-bit timers. Timer 0 is TL0 and Timer 1 is TH0. Both the timers count from 0 to 255 and in case of overflow, reset back to 0. All the bits that are of Timer 1 will now be tied to TH0.</p>
<p>When Timer 0 is in split mode, the real Timer 1 (i.e. TH1 and TL1) can be set in modes 0, 1 or 2, but it cannot be started/stopped as the bits that do that are now linked to TH0. The real timer 1 will be incremented with every machine cycle.</p>
<h3>Initializing a Timer</h3>
<p>Decide the timer mode. Consider a 16-bit timer that runs continuously, and is independent of any external pins.</p> 
<p>Initialize the TMOD SFR. Use the lowest 4 bits of TMOD and consider Timer 0. Keep the two bits, GATE 0 and C/T 0, as 0, since we want the timer to be independent of the external pins. As 16-bit mode is timer mode 1, clear T0M1 and set T0M0. Effectively, the only bit to turn on is bit 0 of TMOD. Now execute the following instruction &minus;</p>
<pre class="result notranslate">
MOV TMOD,#01h
</pre>
<p>Now, Timer 0 is in 16-bit timer mode, but the timer is not running. To start the timer in running mode, set the TR0 bit by executing the following instruction &minus;</p>
<pre class="result notranslate">
SETB TR0
</pre>

<title>Embedded Systems Useful Resources</title>

<h1>Embedded Systems - Useful Resources</h1>

<p>The following resources contain additional information on Embedded Systems. Please use them to get more in-depth knowledge on this.</p>

<h2>Useful Links on Embedded Systems</h2>

<p><a rel="nofollow" target="_blank" href="https://en.wikipedia.org/wiki/Embedded_system">Embedded Systems Wiki</a> &minus;  Wikipedia Reference for Embedded Systems.</p>

<h2>Useful Books on Embedded Systems</h2>

<p>To enlist your site on this page, please drop an email to <b>contact@tutorialspoint.com</b></p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Discuss Embedded Systems</title>

<h1>Discuss Embedded Systems</h1>

<p>We can broadly define an embedded system as a microcontroller-based, software-driven, reliable, real-time control system, designed to perform a specific task. It can be thought of as a computer hardware system having software embedded in it. An embedded system can be either an independent system or a part of a large system. In this tutorial, we will explain all the steps necessary to design an embedded system and use it.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

</body></html>