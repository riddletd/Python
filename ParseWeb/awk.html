<!DOCTYPE html><html><body><title>AWK Tutorial</title>

<h1>Awk Tutorial</h1>

<p>This tutorial takes you through AWK, one of the most prominent text-processing utility on GNU/Linux. It is very powerful and uses simple programming language. It can solve complex text processing tasks with a few lines of code. Starting with an overview of AWK, its environment, and workflow, the tutorial proceeds to explain the syntax, variables, operators, arrays, loops, and functions used in AWK. It also covers topics such as output redirection and pretty printing.</p>

<h1>Audience</h1>

<p>This tutorial will be useful for software developers, system administrators, or any enthusiastic reader inclined to learn how to do text processing and data extraction in Unix-like environment.</p>

<h1>Prerequisites</h1>

<p>You must have a basic understanding of GNU/Linux operating system and shell scripting.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>AWK Overview</title>

<h1>AWK - Overview</h1>

<p>AWK is an interpreted programming language. It is very powerful and specially designed for text processing. Its name is derived from the family names of its authors &minus; <b>Alfred Aho, Peter Weinberger, and Brian Kernighan.</b></p>

<p>The version of AWK that GNU/Linux distributes is written and maintained by the Free Software Foundation (FSF); it is often referred to as <b>GNU AWK.</b></p>

<h2>Types of AWK</h2>

<p>Following are the variants of AWK &minus;</p>

<p><b>AWK</b> &minus; Original AWK from AT &amp; T Laboratory.</p>

<p><b>NAWK</b> &minus; Newer and improved version of AWK from AT &amp; T Laboratory.</p>

<p><b>GAWK</b> &minus; It is GNU AWK. All GNU/Linux distributions ship GAWK. It is fully compatible with AWK and NAWK.</p>

<h2>Typical Uses of AWK</h2>

<p>Myriad of tasks can be done with AWK. Listed below are just a few of them &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>AWK Environment</title>

<h1>AWK - Environment</h1>

<p>This chapter describes how to set up the AWK environment on your GNU/Linux system.</p>

<h2>Installation Using Package Manager</h2>

<p>Generally, AWK is available by default on most GNU/Linux distributions. You can use <b>which</b> command to check whether it is present on your system or not. In case you donâ€™t have AWK, then install it on Debian based GNU/Linux using Advance Package Tool <b>(APT)</b> package manager as follows &minus;</p>

<p>Similarly, to install AWK on RPM based GNU/Linux, use Yellowdog Updator Modifier <b>yum</b> package manager as follows &minus;</p>

<p>After installation, ensure that AWK is accessible via command line.</p>

<p>On executing the above code, you get the following result &minus;</p>

<h2>Installation from Source Code</h2>

<p>As GNU AWK is a part of the GNU project, its source code is available for free download. We have already seen how to install AWK using package manager. Let us now understand how to install AWK from its source code.</p>

<p>The following installation is applicable to any GNU/Linux software, and for most other freely-available programs as well. Here are the installation steps &minus;</p>

<p><b>Step 1</b> &minus; Download the source code from an authentic place. The command-line utility <b>wget</b> serves this purpose.</p>

<p><b>Step 2</b> &minus; Decompress and extract the downloaded source code.</p>

<p><b>Step 3</b> &minus; Change into the directory and run configure.</p>

<p><b>Step 4</b> &minus; Upon successful completion, the <b>configure</b> generates Makefile. To compile the source code, issue a <b>make</b> command.</p>

<p><b>Step 5</b> &minus; You can run the test suite to ensure the build is clean. This is an optional step.</p>

<p><b>Step 6</b> &minus; Finally, install AWK. Make sure you have super-user privileges.</p>

<p>That is it! You have successfully compiled and installed AWK. Verify it by executing the <b>awk</b> command as follows &minus;</p>

<p>On executing this code, you get the following result &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
[jeryy]$ sudo apt-get update
[jeryy]$ sudo apt-get install gawk
</pre>
<p>Similarly, to install AWK on RPM based GNU/Linux, use Yellowdog Updator Modifier <b>yum</b> package manager as follows &minus;</p>
<pre class="prettyprint notranslate">
[root]# yum install gawk
</pre>
<p>After installation, ensure that AWK is accessible via command line.</p>
<pre class="prettyprint notranslate">
[jerry]$ which awk
</pre>
<p>On executing the above code, you get the following result &minus;</p>
<pre class="result notranslate">
/usr/bin/awk
</pre>
<h2>Installation from Source Code</h2>
<p>As GNU AWK is a part of the GNU project, its source code is available for free download. We have already seen how to install AWK using package manager. Let us now understand how to install AWK from its source code.</p>
<p>The following installation is applicable to any GNU/Linux software, and for most other freely-available programs as well. Here are the installation steps &minus;</p>
<p><b>Step 1</b> &minus; Download the source code from an authentic place. The command-line utility <b>wget</b> serves this purpose.</p>
<pre class="prettyprint notranslate">
[jerry]$ wget http://ftp.gnu.org/gnu/gawk/gawk-4.1.1.tar.xz
</pre>
<p><b>Step 2</b> &minus; Decompress and extract the downloaded source code.</p>
<pre class="prettyprint notranslate">
[jerry]$ tar xvf gawk-4.1.1.tar.xz
</pre>
<p><b>Step 3</b> &minus; Change into the directory and run configure.</p>
<pre class="prettyprint notranslate">
[jerry]$ ./configure
</pre>
<p><b>Step 4</b> &minus; Upon successful completion, the <b>configure</b> generates Makefile. To compile the source code, issue a <b>make</b> command.</p>
<pre class="prettyprint notranslate">
[jerry]$ make
</pre>
<p><b>Step 5</b> &minus; You can run the test suite to ensure the build is clean. This is an optional step.</p>
<pre class="prettyprint notranslate">
[jerry]$ make check
</pre>
<p><b>Step 6</b> &minus; Finally, install AWK. Make sure you have super-user privileges.</p>
<pre class="prettyprint notranslate">
[jerry]$ sudo make install
</pre>
<p>That is it! You have successfully compiled and installed AWK. Verify it by executing the <b>awk</b> command as follows &minus;</p>
<pre class="prettyprint notranslate">
[jerry]$ which awk
</pre>
<p>On executing this code, you get the following result &minus;</p>
<pre class="result notranslate">
/usr/bin/awk
</pre>

<title>AWK Workflow</title>

<h1>AWK - Workflow</h1>

<p>To become an expert AWK programmer, you need to know its internals. AWK follows a simple workflow &minus; Read, Execute, and Repeat. The following diagram depicts the workflow of AWK &minus;</p>

<h3>Read</h3>

<p>AWK reads a line from the input stream (file, pipe, or stdin) and stores it in memory.</p>

<h3>Execute</h3>

<p>All AWK commands are applied sequentially on the input. By default AWK execute commands on every line. We can restrict this by providing patterns.</p>

<h3>Repeat</h3>

<p>This process repeats until the file reaches its end.</p>

<h2>Program Structure</h2>

<p>Let us now understand the program structure of AWK.</p>

<h3>BEGIN block</h3>

<p>The syntax of the BEGIN block is as follows &minus;</p>

<p><b>Syntax</b></p>

<p>The BEGIN block gets executed at program start-up. It executes only once. This is good place to initialize variables. BEGIN is an AWK keyword and hence it must be in upper-case. Please note that this block is optional.</p>

<h3>Body Block</h3>

<p>The syntax of the body block is as follows &minus;</p>

<p><b>Syntax</b></p>

<p>The body block applies AWK commands on every input line. By default, AWK executes commands on every line. We can restrict this by providing patterns. Note that there are no keywords for the Body block.</p>

<h3>END Block</h3>

<p>The syntax of the END block is as follows &minus;</p>

<p><b>Syntax</b></p>

<p>The END block executes at the end of the program. END is an AWK keyword and hence it must be in upper-case. Please note that this block is optional.</p>

<p>Let us create a file <b>marks.txt</b> which contains the serial number, name of the student, subject name, and number of marks obtained.</p>

<p>Let us now display the file contents with header by using AWK script.</p>

<p><b>Example</b></p>

<p>When this code is executed, it produces the following result &minus;</p>

<p><b>Output</b></p>

<p>At the start, AWK prints the header from the BEGIN block. Then in the body block, it reads a line from a file and executes AWK's print command which just prints the contents on the standard output stream. This process repeats until file reaches the end.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
BEGIN {awk-commands}
</pre>
<p>The BEGIN block gets executed at program start-up. It executes only once. This is good place to initialize variables. BEGIN is an AWK keyword and hence it must be in upper-case. Please note that this block is optional.</p>
<h3>Body Block</h3>
<p>The syntax of the body block is as follows &minus;</p>
<p><b>Syntax</b></p>
<pre class="result notranslate">
/pattern/ {awk-commands}
</pre>
<p>The body block applies AWK commands on every input line. By default, AWK executes commands on every line. We can restrict this by providing patterns. Note that there are no keywords for the Body block.</p>
<h3>END Block</h3>
<p>The syntax of the END block is as follows &minus;</p>
<p><b>Syntax</b></p>
<pre class="result notranslate">
END {awk-commands}
</pre>
<p>The END block executes at the end of the program. END is an AWK keyword and hence it must be in upper-case. Please note that this block is optional.</p>
<p>Let us create a file <b>marks.txt</b> which contains the serial number, name of the student, subject name, and number of marks obtained.</p>
<pre class="result notranslate">
1)  Amit    Physics  80
2)  Rahul   Maths    90
3)  Shyam   Biology  87
4)  Kedar   English  85
5)  Hari    History  89
</pre>
<p>Let us now display the file contents with header by using AWK script.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN{printf "Sr No\tName\tSub\tMarks\n"} {print}' marks.txt
</pre>
<p>When this code is executed, it produces the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Sr No Name Sub Marks
1) Amit Physics 80
2) Rahul Maths 90
3) Shyam Biology 87
4) Kedar English 85
5) Hari History 89
</pre>

<title>AWK Basic Syntax</title>

<h1>AWK - Basic Syntax</h1>

<p>AWK is simple to use. We can provide AWK commands either directly from the command line or in the form of a text file containing AWK commands.</p>

<h2>AWK Command Line</h2>

<p>We can specify an AWK command within single quotes at command line as shown &minus;</p>

<h3>Example</h3>

<p>Consider a text file <b>marks.txt</b> with the following content &minus;</p>

<p>Let us display the complete content of the file using AWK as follows &minus;</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h2>AWK Program File</h2>

<p>We can provide AWK commands in a script file as shown &minus;</p>

<p>First, create a text file <b>command.awk</b> containing the AWK command as shown below &minus;</p>

<p>Now we can instruct the AWK to read commands from the text file and perform the action. Here, we achieve the same result as shown in the above example.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h2>AWK Standard Options</h2>

<p>AWK supports the following standard options which can be provided from the command line.</p>

<h3>The -v option</h3>

<p>This option assigns a value to a variable. It allows assignment before the program execution. The following example describes the usage of the -v option.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>The --dump-variables[=file] option</h3>

<p>It prints a sorted list of global variables and their final values to file. The default file is <b>awkvars.out</b>.</p>

<p><b>Example</b></p>

<p>On executing the above code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>The --help option</h3>

<p>This option prints the help message on standard output.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>The --lint[=fatal] option</h3>

<p>This option enables checking of non-portable or dubious constructs. When an argument <b>fatal</b> is provided, it treats warning messages as errors. The following example demonstrates this &minus;</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>The --posix option</h3>

<p>This option turns on strict POSIX compatibility, in which all common and gawk-specific extensions are disabled.</p>

<h3>The --profile[=file] option</h3>

<p>This option generates a pretty-printed version of the program in file. Default file is <b>awkprof.out</b>. Below simple example illustrates this &minus;</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>The --traditional option</h3>

<p>This option disables all gawk-specific extensions.</p>

<h3>The --version option</h3>

<p>This option displays the version information of the AWK program.</p>

<p><b>Example</b></p>

<p>When this code is executed, it produces the following result &minus;</p>

<p><b>Output</b></p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
awk [options] file ...
</pre>
<h3>Example</h3>
<p>Consider a text file <b>marks.txt</b> with the following content &minus;</p>
<pre class="result notranslate">
1) Amit     Physics    80
2) Rahul    Maths      90
3) Shyam    Biology    87
4) Kedar    English    85
5) Hari     History    89
</pre>
<p>Let us display the complete content of the file using AWK as follows &minus;</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk '{print}' marks.txt 
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
1) Amit     Physics    80
2) Rahul    Maths      90
3) Shyam    Biology    87
4) Kedar    English    85
5) Hari     History    89
</pre>
<h2>AWK Program File</h2>
<p>We can provide AWK commands in a script file as shown &minus;</p>
<pre class="result notranslate">
awk [options] -f file ....
</pre>
<p>First, create a text file <b>command.awk</b> containing the AWK command as shown below &minus;</p>
<pre class="result notranslate">
{print}
</pre>
<p>Now we can instruct the AWK to read commands from the text file and perform the action. Here, we achieve the same result as shown in the above example.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk -f command.awk marks.txt
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
1) Amit  Physics 80
2) Rahul Maths   90
3) Shyam Biology 87
4) Kedar English 85
5) Hari  History 89
</pre>
<h2>AWK Standard Options</h2>
<p>AWK supports the following standard options which can be provided from the command line.</p>
<h3>The -v option</h3>
<p>This option assigns a value to a variable. It allows assignment before the program execution. The following example describes the usage of the -v option.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk -v name=Jerry 'BEGIN{printf "Name = %s\n", name}'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Name = Jerry
</pre>
<h3>The --dump-variables[=file] option</h3>
<p>It prints a sorted list of global variables and their final values to file. The default file is <b>awkvars.out</b>.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk --dump-variables ''
[jerry]$ cat awkvars.out 
</pre>
<p>On executing the above code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
ARGC: 1
ARGIND: 0
ARGV: array, 1 elements
BINMODE: 0
CONVFMT: "%.6g"
ERRNO: ""
FIELDWIDTHS: ""
FILENAME: ""
FNR: 0
FPAT: "[^[:space:]]+"
FS: " "
IGNORECASE: 0
LINT: 0
NF: 0
NR: 0
OFMT: "%.6g"
OFS: " "
ORS: "\n"
RLENGTH: 0
RS: "\n"
RSTART: 0
RT: ""
SUBSEP: "\034"
TEXTDOMAIN: "messages"
</pre>
<h3>The --help option</h3>
<p>This option prints the help message on standard output.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk --help
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Usage: awk [POSIX or GNU style options] -f progfile [--] file ...
Usage: awk [POSIX or GNU style options] [--] 'program' file ...
POSIX options : GNU long options: (standard)
   -f progfile                --file=progfile
   -F fs                      --field-separator=fs
   -v var=val                 --assign=var=val
Short options : GNU long options: (extensions)
   -b                         --characters-as-bytes
   -c                         --traditional
   -C                         --copyright
   -d[file]                   --dump-variables[=file]
   -e 'program-text'          --source='program-text'
   -E file                    --exec=file
   -g                         --gen-pot
   -h                         --help
   -L [fatal]                 --lint[=fatal]
   -n                         --non-decimal-data
   -N                         --use-lc-numeric
   -O                         --optimize
   -p[file]                   --profile[=file]
   -P                         --posix
   -r                         --re-interval
   -S                         --sandbox
   -t                         --lint-old
   -V                         --version
</pre>
<h3>The --lint[=fatal] option</h3>
<p>This option enables checking of non-portable or dubious constructs. When an argument <b>fatal</b> is provided, it treats warning messages as errors. The following example demonstrates this &minus;</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk --lint '' /bin/ls
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
awk: cmd. line:1: warning: empty program text on command line
awk: cmd. line:1: warning: source file does not end in newline
awk: warning: no program text at all!
</pre>
<h3>The --posix option</h3>
<p>This option turns on strict POSIX compatibility, in which all common and gawk-specific extensions are disabled.</p>
<h3>The --profile[=file] option</h3>
<p>This option generates a pretty-printed version of the program in file. Default file is <b>awkprof.out</b>. Below simple example illustrates this &minus;</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk --profile 'BEGIN{printf"---|Header|--\n"} {print} 
END{printf"---|Footer|---\n"}' marks.txt &gt; /dev/null 
[jerry]$ cat awkprof.out
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
# gawk profile, created Sun Oct 26 19:50:48 2014

   # BEGIN block(s)

   BEGIN {
      printf "---|Header|--\n"
   }

   # Rule(s) {
      print $0
   }

   # END block(s)

   END {
      printf "---|Footer|---\n"
   }
</pre>
<h3>The --traditional option</h3>
<p>This option disables all gawk-specific extensions.</p>
<h3>The --version option</h3>
<p>This option displays the version information of the AWK program.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk --version
</pre>
<p>When this code is executed, it produces the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
GNU Awk 4.0.1
Copyright (C) 1989, 1991-2012 Free Software Foundation.
</pre>

<title>AWK Basic Examples</title>

<h1>AWK - Basic Examples</h1>

<p>This chapter describes several useful AWK commands and their appropriate examples. Consider a text file <b>marks.txt</b> to be processed with the following content &minus;</p>

<h2>Printing Column or Field</h2>

<p>You can instruct AWK to print only certain columns from the input field. The following example demonstrates this &minus;</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<p>In the file <b>marks.txt</b>, the third column contains the subject name and the fourth column contains the marks obtained in a particular subject. Let us print these two columns using AWK print command. In the above example, <b>$3 and $4</b> represent the third and the fourth fields respectively from the input record.</p>

<h2>Printing All Lines</h2>

<p>By default, AWK prints all the lines that match pattern.</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<p>In the above example, we are searching form pattern <b>a</b>. When a pattern match succeeds, it executes a command from the body block. In the absence of a body block &minus; default action is taken which is print the record. Hence, the following command produces the same result &minus;</p>

<h3>Example</h3>

<h2>Printing Columns by Pattern</h2>

<p>When a pattern match succeeds, AWK prints the entire record by default. But you can instruct AWK to print only certain fields. For instance, the following example prints the third and fourth field when a pattern match succeeds.</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<h2>Printing Column in Any Order</h2>

<p>You can print columns in any order. For instance, the following example prints the fourth column followed by the third column.</p>

<h3>Example</h3>

<p>On executing the above code, you get the following result &minus;</p>

<h3>Output</h3>

<h2>Counting and Printing Matched Pattern</h2>

<p>Let us see an example where you can count and print the number of lines for which a pattern match succeeded.</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<p>In this example, we increment the value of counter when a pattern match succeeds and we print this value in the END block. Note that unlike other programming languages, there is no need to declare a variable before using it.</p>

<h2>Printing Lines with More than 18 Characters</h2>

<p>Let us print only those lines that contain more than 18 characters.</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<p>AWK provides a built-in <b>length</b>  function that returns the length of the string. <b>$0</b> variable stores the entire line and in the absence of a body block, default action is taken, i.e., the print action. Hence, if a line has more than 18 characters, then the comparison results true and the line gets printed.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
1) Amit     Physics   80
2) Rahul    Maths     90
3) Shyam    Biology   87
4) Kedar    English   85
5) Hari     History   89
</pre>
<h2>Printing Column or Field</h2>
<p>You can instruct AWK to print only certain columns from the input field. The following example demonstrates this &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ awk '{print $3 "\t" $4}' marks.txt
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
Physics   80
Maths     90
Biology   87
English   85
History   89
</pre>
<p>In the file <b>marks.txt</b>, the third column contains the subject name and the fourth column contains the marks obtained in a particular subject. Let us print these two columns using AWK print command. In the above example, <b>$3 and $4</b> represent the third and the fourth fields respectively from the input record.</p>
<h2>Printing All Lines</h2>
<p>By default, AWK prints all the lines that match pattern.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ awk '/a/ {print $0}' marks.txt
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
2) Rahul    Maths     90
3) Shyam    Biology   87
4) Kedar    English   85
5) Hari     History   89
</pre>
<p>In the above example, we are searching form pattern <b>a</b>. When a pattern match succeeds, it executes a command from the body block. In the absence of a body block &minus; default action is taken which is print the record. Hence, the following command produces the same result &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ awk '/a/' marks.txt
</pre>
<h2>Printing Columns by Pattern</h2>
<p>When a pattern match succeeds, AWK prints the entire record by default. But you can instruct AWK to print only certain fields. For instance, the following example prints the third and fourth field when a pattern match succeeds.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ awk '/a/ {print $3 "\t" $4}' marks.txt
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
Maths    90
Biology  87
English  85
History  89
</pre>
<h2>Printing Column in Any Order</h2>
<p>You can print columns in any order. For instance, the following example prints the fourth column followed by the third column.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ awk '/a/ {print $4 "\t" $3}' marks.txt
</pre>
<p>On executing the above code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
90   Maths
87   Biology
85   English
89   History
</pre>
<h2>Counting and Printing Matched Pattern</h2>
<p>Let us see an example where you can count and print the number of lines for which a pattern match succeeded.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ awk '/a/{++cnt} END {print "Count = ", cnt}' marks.txt
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
Count = 4
</pre>
<p>In this example, we increment the value of counter when a pattern match succeeds and we print this value in the END block. Note that unlike other programming languages, there is no need to declare a variable before using it.</p>
<h2>Printing Lines with More than 18 Characters</h2>
<p>Let us print only those lines that contain more than 18 characters.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ awk 'length($0) &gt; 18' marks.txt
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
3) Shyam   Biology   87
4) Kedar   English   85
</pre>

<title>AWK Built-in Variables</title>

<h1>AWK - Built-in Variables</h1>

<p>AWK provides several built-in variables. They play an important role while writing AWK scripts. This chapter demonstrates the usage of built-in variables.</p>

<h2>Standard AWK variables</h2>

<p>The standard AWK variables are discussed below.</p>

<h3>ARGC</h3>

<p>It implies the number of arguments provided at the command line.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<p>But why AWK shows 5 when you passed only 4 arguments? Just check the following example to clear your doubt.</p>

<h3>ARGV</h3>

<p>It is an array that stores the command-line arguments. The array's valid index ranges from 0 to ARGC-1.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>CONVFMT</h3>

<p>It represents the conversion format for numbers. Its default value is <b>%.6g</b>.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>ENVIRON</h3>

<p>It is an associative array of environment variables.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<p>To find names of other environment variables, use <b>env</b> command.</p>

<h3>FILENAME</h3>

<p>It represents the current file name.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<p>Please note that FILENAME is undefined in the BEGIN block.</p>

<h3>FS</h3>

<p>It represents the (input) field separator and its default value is space. You can also change this by using <b>-F</b> command line option.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>NF</h3>

<p>It represents the number of fields in the current record. For instance, the following example prints only those lines that contain more than two fields.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>NR</h3>

<p>It represents the number of the current record. For instance, the following example prints the record if the current record contains less than three fields.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>FNR</h3>

<p>It is similar to NR, but relative to the current file. It is useful when AWK is operating on multiple files. Value of FNR resets with new file.</p>

<h3>OFMT</h3>

<p>It represents the output format number and its default value is <b>%.6g</b>.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>OFS</h3>

<p>It represents the output field separator and its default value is space.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>ORS</h3>

<p>It represents the output record separator and its default value is newline.</p>

<p><b>Example</b></p>

<p>On executing the above code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>RLENGTH</h3>

<p>It represents the length of the string matched by <b>match</b> function. AWK's match function searches for a given string in the input-string.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>RS</h3>

<p>It represents (input) record separator and its default value is newline.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>RSTART</h3>

<p>It represents the first position in the string matched by <b>match</b> function.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>SUBSEP</h3>

<p>It represents the separator character for array subscripts and its default value is <b>\034</b>.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>$0</h3>

<p>It represents the entire input record.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>$n</h3>

<p>It represents the n<sup>th</sup> field in the current record where the fields are separated by FS.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h2>GNU AWK Specific Variables</h2>

<p>GNU AWK specific variables are as follows &minus;</p>

<h3>ARGIND</h3>

<p>It represents the index in ARGV of the current file being processed.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>BINMODE</h3>

<p>It is used to specify binary mode for all file I/O on non-POSIX systems. Numeric values of 1, 2, or 3 specify that input files, output files, or all files, respectively, should use binary I/O. String values of <b>r</b> or <b>w</b> specify that input files or output files, respectively, should use binary I/O. String values of <b>rw</b> or <b>wr</b> specify that all files should use binary I/O.</p>

<h3>ERRNO</h3>

<p>A string indicates an error when a redirection fails for <b>getline</b> or if <b>close</b> call fails.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>FIELDWIDTHS</h3>

<p>A space separated list of field widths variable is set, GAWK parses the input into fields of fixed width, instead of using the value of the FS variable as the field separator.</p>

<h3>IGNORECASE</h3>

<p>When this variable is set, GAWK becomes case-insensitive. The following example demonstrates this &minus;</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>LINT</h3>

<p>It provides dynamic control of the <b>--lint</b> option from the GAWK program. When this variable is set, GAWK prints lint warnings. When assigned the string value fatal, lint warnings become fatal errors, exactly like <b>--lint=fatal</b>.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>PROCINFO</h3>

<p>This is an associative array containing information about the process, such as real and effective UID numbers, process ID number, and so on.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>TEXTDOMAIN</h3>

<p>It represents the text domain of the AWK program. It is used to find the localized translations for the program's strings.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<p>The above output shows English text due to <b>en_IN</b> locale</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN {print "Arguments =", ARGC}' One Two Three Four
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Arguments = 5
</pre>
<p>But why AWK shows 5 when you passed only 4 arguments? Just check the following example to clear your doubt.</p>
<h3>ARGV</h3>
<p>It is an array that stores the command-line arguments. The array's valid index ranges from 0 to ARGC-1.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { 
   for (i = 0; i &lt; ARGC - 1; ++i) { 
      printf "ARGV[%d] = %s\n", i, ARGV[i] 
   } 
}' one two three four
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
ARGV[0] = awk
ARGV[1] = one
ARGV[2] = two
ARGV[3] = three
</pre>
<h3>CONVFMT</h3>
<p>It represents the conversion format for numbers. Its default value is <b>%.6g</b>.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { print "Conversion Format =", CONVFMT }'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Conversion Format = %.6g
</pre>
<h3>ENVIRON</h3>
<p>It is an associative array of environment variables.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { print ENVIRON["USER"] }'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
jerry
</pre>
<p>To find names of other environment variables, use <b>env</b> command.</p>
<h3>FILENAME</h3>
<p>It represents the current file name.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'END {print FILENAME}' marks.txt
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
marks.txt
</pre>
<p>Please note that FILENAME is undefined in the BEGIN block.</p>
<h3>FS</h3>
<p>It represents the (input) field separator and its default value is space. You can also change this by using <b>-F</b> command line option.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN {print "FS = " FS}' | cat -vte
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
FS =  $
</pre>
<h3>NF</h3>
<p>It represents the number of fields in the current record. For instance, the following example prints only those lines that contain more than two fields.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ echo -e "One Two\nOne Two Three\nOne Two Three Four" | awk 'NF &gt; 2'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
One Two Three
One Two Three Four
</pre>
<h3>NR</h3>
<p>It represents the number of the current record. For instance, the following example prints the record if the current record contains less than three fields.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ echo -e "One Two\nOne Two Three\nOne Two Three Four" | awk 'NR &lt; 3'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
One Two
One Two Three
</pre>
<h3>FNR</h3>
<p>It is similar to NR, but relative to the current file. It is useful when AWK is operating on multiple files. Value of FNR resets with new file.</p>
<h3>OFMT</h3>
<p>It represents the output format number and its default value is <b>%.6g</b>.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN {print "OFMT = " OFMT}'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
OFMT = %.6g
</pre>
<h3>OFS</h3>
<p>It represents the output field separator and its default value is space.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN {print "OFS = " OFS}' | cat -vte
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
OFS =  $
</pre>
<h3>ORS</h3>
<p>It represents the output record separator and its default value is newline.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN {print "ORS = " ORS}' | cat -vte
</pre>
<p>On executing the above code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
ORS = $
$
</pre>
<h3>RLENGTH</h3>
<p>It represents the length of the string matched by <b>match</b> function. AWK's match function searches for a given string in the input-string.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { if (match("One Two Three", "re")) { print RLENGTH } }'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
2
</pre>
<h3>RS</h3>
<p>It represents (input) record separator and its default value is newline.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN {print "RS = " RS}' | cat -vte
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
RS = $
$
</pre>
<h3>RSTART</h3>
<p>It represents the first position in the string matched by <b>match</b> function.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { if (match("One Two Three", "Thre")) { print RSTART } }'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
9
</pre>
<h3>SUBSEP</h3>
<p>It represents the separator character for array subscripts and its default value is <b>\034</b>.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { print "SUBSEP = " SUBSEP }' | cat -vte
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
SUBSEP = ^\$
</pre>
<h3>$0</h3>
<p>It represents the entire input record.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk '{print $0}' marks.txt
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
1) Amit     Physics   80
2) Rahul    Maths     90
3) Shyam    Biology   87
4) Kedar    English   85
5) Hari     History   89
</pre>
<h3>$n</h3>
<p>It represents the n<sup>th</sup> field in the current record where the fields are separated by FS.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk '{print $3 "\t" $4}' marks.txt
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Physics   80
Maths     90
Biology   87
English   85
History   89
</pre>
<h2>GNU AWK Specific Variables</h2>
<p>GNU AWK specific variables are as follows &minus;</p>
<h3>ARGIND</h3>
<p>It represents the index in ARGV of the current file being processed.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk '{ 
   print "ARGIND   = ", ARGIND; print "Filename = ", ARGV[ARGIND] 
}' junk1 junk2 junk3
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
ARGIND   =  1
Filename =  junk1
ARGIND   =  2
Filename =  junk2
ARGIND   =  3
Filename =  junk3
</pre>
<h3>BINMODE</h3>
<p>It is used to specify binary mode for all file I/O on non-POSIX systems. Numeric values of 1, 2, or 3 specify that input files, output files, or all files, respectively, should use binary I/O. String values of <b>r</b> or <b>w</b> specify that input files or output files, respectively, should use binary I/O. String values of <b>rw</b> or <b>wr</b> specify that all files should use binary I/O.</p>
<h3>ERRNO</h3>
<p>A string indicates an error when a redirection fails for <b>getline</b> or if <b>close</b> call fails.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { ret = getline &lt; "junk.txt"; if (ret == -1) print "Error:", ERRNO }'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Error: No such file or directory
</pre>
<h3>FIELDWIDTHS</h3>
<p>A space separated list of field widths variable is set, GAWK parses the input into fields of fixed width, instead of using the value of the FS variable as the field separator.</p>
<h3>IGNORECASE</h3>
<p>When this variable is set, GAWK becomes case-insensitive. The following example demonstrates this &minus;</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN{IGNORECASE = 1} /amit/' marks.txt
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
1) Amit  Physics   80
</pre>
<h3>LINT</h3>
<p>It provides dynamic control of the <b>--lint</b> option from the GAWK program. When this variable is set, GAWK prints lint warnings. When assigned the string value fatal, lint warnings become fatal errors, exactly like <b>--lint=fatal</b>.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN {LINT = 1; a}'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
awk: cmd. line:1: warning: reference to uninitialized variable `a'
awk: cmd. line:1: warning: statement has no effect
</pre>
<h3>PROCINFO</h3>
<p>This is an associative array containing information about the process, such as real and effective UID numbers, process ID number, and so on.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { print PROCINFO["pid"] }'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
4316
</pre>
<h3>TEXTDOMAIN</h3>
<p>It represents the text domain of the AWK program. It is used to find the localized translations for the program's strings.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { print TEXTDOMAIN }'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
messages
</pre>

<title>AWK Operators</title>

<h1>AWK - Operators</h1>

<p>Like other programming languages, AWK also provides a large set of operators. This chapter explains AWK operators with suitable examples.</p>

<p>AWK supports the following arithmetic operators.</p>

<p>AWK supports the following increment and decrement operators.</p>

<p>AWK supports the following assignment operators.</p>

<p>AWK supports the following relational operators.</p>

<p>AWK supports the following logical operators.</p>

<p>We can easily implement a condition expression using ternary operator.</p>

<p>AWK supports the following unary operators.</p>

<p>There are two formats of exponential operators.</p>

<p>Space is a string concatenation operator that merges two strings.</p>

<p>It is represented by <b>in</b>. It is used while accessing array elements.</p>

<p>This example explains the two forms of regular expressions operators.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>AWK Regular Expressions</title>

<h1>AWK - Regular Expressions</h1>

<p>AWK is very powerful and efficient in handling regular expressions. A number of complex tasks can be solved with simple regular expressions. Any command-line expert knows the power of regular expressions.</p>

<p>This chapter covers standard regular expressions with suitable examples.</p>

<h2>Dot</h2>

<p>It matches any single character except the end of line character. For instance, the following example matches <b>fin, fun, fan</b> etc.</p>

<h3>Example</h3>

<p>On executing the above code, you get the following result &minus;</p>

<h3>Output</h3>

<h2>Start of line</h2>

<p>It matches the start of line. For instance, the following example prints all the lines that start with pattern <b>The</b>.</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<h2>End of line</h2>

<p>It matches the end of line. For instance, the following example prints the lines that end with the letter <b>n</b>.</p>

<h3>Example</h3>

<h3>Output</h3>

<p>On executing this code, you get the following result &minus;</p>

<h2>Match character set</h2>

<p>It is used to match only one out of several characters. For instance, the following example matches pattern <b>Call</b> and <b>Tall</b> but not <b>Ball</b>.</p>

<h3>Example</h3>

<h3>Output</h3>

<p>On executing this code, you get the following result &minus;</p>

<h2>Exclusive set</h2>

<p>In exclusive set, the carat negates the set of characters in the square brackets. For instance, the following example prints only <b>Ball</b>.</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<h2>Alteration</h2>

<p>A vertical bar allows regular expressions to be logically ORed. For instance, the following example prints <b>Ball</b> and <b>Call</b>.</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<h2>Zero or One Occurrence</h2>

<p>It matches zero or one occurrence of the preceding character. For instance, the following example matches <b>Colour</b> as well as <b>Color</b>. We have made <b>u</b> as an optional character by using <b>?</b>.</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<h2>Zero or More Occurrence</h2>

<p>It matches zero or more occurrences of the preceding character. For instance, the following example matches <b>ca, cat, catt,</b> and so on.</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<h2>One or More Occurrence</h2>

<p>It matches one or more occurrence of the preceding character. For instance below example matches one or more occurrences of the <b>2</b>.</p>

<h3>Example</h3>

<p>On executing the above code, you get the following result &minus;</p>

<h3>Output</h3>

<h2>Grouping</h2>

<p><b>Parentheses ()</b> are used for grouping and the character | is used for alternatives. For instance, the following regular expression matches the lines containing either <b>Apple Juice or Apple Cake</b>.</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
[jerry]$ echo -e "cat\nbat\nfun\nfin\nfan" | awk '/f.n/'
</pre>
<p>On executing the above code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
fun
fin
fan
</pre>
<h2>Start of line</h2>
<p>It matches the start of line. For instance, the following example prints all the lines that start with pattern <b>The</b>.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ echo -e "This\nThat\nThere\nTheir\nthese" | awk '/^The/'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
There
Their
</pre>
<h2>End of line</h2>
<p>It matches the end of line. For instance, the following example prints the lines that end with the letter <b>n</b>.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ echo -e "knife\nknow\nfun\nfin\nfan\nnine" | awk '/n$/'
</pre>
<h3>Output</h3>
<p>On executing this code, you get the following result &minus;</p>
<pre class="result notranslate">
fun
fin
fan
</pre>
<h2>Match character set</h2>
<p>It is used to match only one out of several characters. For instance, the following example matches pattern <b>Call</b> and <b>Tall</b> but not <b>Ball</b>.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ echo -e "Call\nTall\nBall" | awk '/[CT]all/'
</pre>
<h3>Output</h3>
<p>On executing this code, you get the following result &minus;</p>
<pre class="result notranslate">
Call
Tall
</pre>
<h2>Exclusive set</h2>
<p>In exclusive set, the carat negates the set of characters in the square brackets. For instance, the following example prints only <b>Ball</b>.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ echo -e "Call\nTall\nBall" | awk '/[^CT]all/'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
Ball
</pre>
<h2>Alteration</h2>
<p>A vertical bar allows regular expressions to be logically ORed. For instance, the following example prints <b>Ball</b> and <b>Call</b>.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ echo -e "Call\nTall\nBall\nSmall\nShall" | awk '/Call|Ball/'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
Call
Ball
</pre>
<h2>Zero or One Occurrence</h2>
<p>It matches zero or one occurrence of the preceding character. For instance, the following example matches <b>Colour</b> as well as <b>Color</b>. We have made <b>u</b> as an optional character by using <b>?</b>.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ echo -e "Colour\nColor" | awk '/Colou?r/'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
Colour
Color
</pre>
<h2>Zero or More Occurrence</h2>
<p>It matches zero or more occurrences of the preceding character. For instance, the following example matches <b>ca, cat, catt,</b> and so on.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ echo -e "ca\ncat\ncatt" | awk '/cat*/'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
ca
cat
catt
</pre>
<h2>One or More Occurrence</h2>
<p>It matches one or more occurrence of the preceding character. For instance below example matches one or more occurrences of the <b>2</b>.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ echo -e "111\n22\n123\n234\n456\n222"  | awk '/2+/'
</pre>
<p>On executing the above code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
22
123
234
222
</pre>
<h2>Grouping</h2>
<p><b>Parentheses ()</b> are used for grouping and the character | is used for alternatives. For instance, the following regular expression matches the lines containing either <b>Apple Juice or Apple Cake</b>.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ echo -e "Apple Juice\nApple Pie\nApple Tart\nApple Cake" | awk 
   '/Apple (Juice|Cake)/'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
Apple Juice
Apple Cake
</pre>

<title>AWK Arrays</title>

<h1>AWK - Arrays</h1>

<p>AWK has associative arrays and one of the best thing about it is â€“ the indexes need not to be continuous set of number; you can use either string or number as an array index. Also, there is no need to declare the size of an array in advance â€“ arrays can expand/shrink at runtime.</p>

<p>Its syntax is as follows &minus;</p>

<h3>Syntax</h3>

<p>Where <b>array_name</b> is the name of array, <b>index</b> is the array index, and <b>value</b> is any value assigning to the element of the array.</p>

<h2>Creating Array</h2>

<p>To gain more insight on array, let us create and access the elements of an array.</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<p>In the above example, we declare the array as <b>fruits</b> whose index is fruit name and the value is the color of the fruit. To access array elements, we use <b>array_name[index]</b> format.</p>

<h2>Deleting Array Elements</h2>

<p>For insertion, we used assignment operator. Similarly, we can use <b>delete</b> statement to remove an element from the array. The syntax of delete statement is as follows &minus;</p>

<h3>Syntax</h3>

<p>The following example deletes the element <b>orange</b>. Hence the command does not show any output.</p>

<h3>Example</h3>

<h2>Multi-Dimensional arrays</h2>

<p>AWK only supports one-dimensional arrays. But you can easily simulate a multi-dimensional array using the one-dimensional array itself.</p>

<p>For instance, given below is a 3x3 three-dimensional array &minus;</p>

<p>In the above example, array[0][0] stores 100, array[0][1] stores 200, and so on. To store 100 at array location [0][0], we can use the following syntax &minus;</p>

<h3>Syntax</h3>

<p>Though we gave <b>0,0</b> as index, these are not two indexes. In reality, it is just one index with the string <b>0,0</b>.</p>

<p>The following example simulates a 2-D array &minus;</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<p>You can also perform a variety of operations on an array such as sorting its elements/indexes. For that purpose, you can use <b>assort</b> and <b>asorti</b> functions</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
array_name[index] = value
</pre>
<p>Where <b>array_name</b> is the name of array, <b>index</b> is the array index, and <b>value</b> is any value assigning to the element of the array.</p>
<h2>Creating Array</h2>
<p>To gain more insight on array, let us create and access the elements of an array.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN {
   fruits["mango"] = "yellow";
   fruits["orange"] = "orange"
   print fruits["orange"] "\n" fruits["mango"]
}'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
orange
yellow
</pre>
<p>In the above example, we declare the array as <b>fruits</b> whose index is fruit name and the value is the color of the fruit. To access array elements, we use <b>array_name[index]</b> format.</p>
<h2>Deleting Array Elements</h2>
<p>For insertion, we used assignment operator. Similarly, we can use <b>delete</b> statement to remove an element from the array. The syntax of delete statement is as follows &minus;</p>
<h3>Syntax</h3>
<pre class="result notranslate">
delete array_name[index]
</pre>
<p>The following example deletes the element <b>orange</b>. Hence the command does not show any output.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN {
   fruits["mango"] = "yellow";
   fruits["orange"] = "orange";
   delete fruits["orange"];
   print fruits["orange"]
}'
</pre>
<h2>Multi-Dimensional arrays</h2>
<p>AWK only supports one-dimensional arrays. But you can easily simulate a multi-dimensional array using the one-dimensional array itself.</p>
<p>For instance, given below is a 3x3 three-dimensional array &minus;</p>
<pre class="result notranslate">
100   200   300
400   500   600
700   800   900
</pre>
<p>In the above example, array[0][0] stores 100, array[0][1] stores 200, and so on. To store 100 at array location [0][0], we can use the following syntax &minus;</p>
<h3>Syntax</h3>
<pre class="result notranslate">
array["0,0"] = 100
</pre>
<p>Though we gave <b>0,0</b> as index, these are not two indexes. In reality, it is just one index with the string <b>0,0</b>.</p>
<p>The following example simulates a 2-D array &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN {
   array["0,0"] = 100;
   array["0,1"] = 200;
   array["0,2"] = 300;
   array["1,0"] = 400;
   array["1,1"] = 500;
   array["1,2"] = 600;

   # print array elements
   print "array[0,0] = " array["0,0"];
   print "array[0,1] = " array["0,1"];
   print "array[0,2] = " array["0,2"];
   print "array[1,0] = " array["1,0"];
   print "array[1,1] = " array["1,1"];
   print "array[1,2] = " array["1,2"];
}'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
array[0,0] = 100
array[0,1] = 200
array[0,2] = 300
array[1,0] = 400
array[1,1] = 500
array[1,2] = 600
</pre>

<title>AWK Control Flow</title>

<h1>AWK - Control Flow</h1>

<p>Like other programming languages, AWK provides conditional statements to control the flow of a program. This chapter explains AWK's control statements with suitable examples.</p>

<h2>If statement</h2>

<p>It simply tests the condition and performs certain actions depending upon the condition. Given below is the syntax of <b>if</b> statement &minus;</p>

<h3>Syntax</h3>

<p>We can also use a pair of curly braces as given below to execute multiple actions &minus;</p>

<h3>Syntax</h3>

<p>For instance, the following example checks whether a number is even or not &minus;</p>

<h3>Example</h3>

<p>On executing the above code, you get the following result &minus;</p>

<h3>Output</h3>

<h2>If Else Statement</h2>

<p>In <b>if-else</b> syntax, we can provide a list of actions to be performed when a condition becomes false.</p>

<p>The syntax of <b>if-else</b> statement is as follows &minus;</p>

<h3>Syntax</h3>

<p>In the above syntax, action-1 is performed when the condition evaluates to true and action-2 is performed when the condition evaluates to false. For instance, the following example checks whether a number is even or not &minus;</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<h2>If-Else-If Ladder</h2>

<p>We can easily create an <b>if-else-if</b> ladder by using multiple <b>if-else</b> statements. The following example demonstrates this &minus;</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
if (condition)
   action
</pre>
<p>We can also use a pair of curly braces as given below to execute multiple actions &minus;</p>
<h3>Syntax</h3>
<pre class="result notranslate">
if (condition) {
   action-1
   action-1
   .
   .
   action-n
}
</pre>
<p>For instance, the following example checks whether a number is even or not &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN {num = 10; if (num % 2 == 0) printf "%d is even number.\n", num }'
</pre>
<p>On executing the above code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
10 is even number.
</pre>
<h2>If Else Statement</h2>
<p>In <b>if-else</b> syntax, we can provide a list of actions to be performed when a condition becomes false.</p>
<p>The syntax of <b>if-else</b> statement is as follows &minus;</p>
<h3>Syntax</h3>
<pre class="result notranslate">
if (condition)
   action-1
else
   action-2
</pre>
<p>In the above syntax, action-1 is performed when the condition evaluates to true and action-2 is performed when the condition evaluates to false. For instance, the following example checks whether a number is even or not &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN {
   num = 11; if (num % 2 == 0) printf "%d is even number.\n", num; 
      else printf "%d is odd number.\n", num 
}'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
11 is odd number.
</pre>
<h2>If-Else-If Ladder</h2>
<p>We can easily create an <b>if-else-if</b> ladder by using multiple <b>if-else</b> statements. The following example demonstrates this &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN {
   a = 30;
   
   if (a==10)
   print "a = 10";
   else if (a == 20)
   print "a = 20";
   else if (a == 30)
   print "a = 30";
}'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
a = 30
</pre>

<title>AWK Loops</title>

<h1>AWK - Loops</h1>

<p>This chapter explains AWK's loops with suitable example. Loops are used to execute a set of actions in a repeated manner. The loop execution continues as long as the loop condition is true.</p>

<h2>For Loop</h2>

<p>The syntax of <b>for</b> loop is &minus;</p>

<h3>Syntax</h3>

<p>Initially, the <b>for</b> statement performs initialization action, then it checks the condition. If the condition is true, it executes actions, thereafter it performs increment or decrement operation. The loop execution continues as long as the condition is true. For instance, the following example prints 1 to 5 using <b>for</b> loop &minus;</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<h2>While Loop</h2>

<p>The <b>while</b> loop keeps executing the action until a particular logical condition evaluates to true. Here is the syntax of <b>while</b> loop &minus;</p>

<h3>Syntax</h3>

<p>AWK first checks the condition; if the condition is true, it executes the action. This process repeats as long as the loop condition evaluates to true. For instance, the following example prints 1 to 5 using <b>while</b> loop &minus;</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<h2>Do-While Loop</h2>

<p>The <b>do-while</b> loop is similar to the while loop, except that the test condition is evaluated at the end of the loop. Here is the syntax of <b>do-while</b>loop &minus;</p>

<h3>Syntax</h3>

<p>In a <b>do-while</b> loop, the action statement gets executed at least once even when the condition statement evaluates to false. For instance, the following example prints 1 to 5 numbers using <b>do-while</b> loop &minus;</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<h2>Break Statement</h2>

<p>As its name suggests, it is used to end the loop execution. Here is an example which ends the loop when the sum becomes greater than 50.</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<h2>Continue Statement</h2>

<p>The <b>continue</b> statement is used inside a loop to skip to the next iteration of the loop. It is useful when you wish to skip the processing of some data inside the loop. For instance, the following example uses <b>continue</b> statement to print the even numbers between 1 to 20.</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<h2>Exit Statement</h2>

<p>It is used to stop the execution of the script. It accepts an integer as an argument which is the exit status code for AWK process. If no argument is supplied, <b>exit</b> returns status zero. Here is an example that stops the execution when the sum becomes greater than 50.</p>

<h3>Example</h3>

<h3>Output</h3>

<p>On executing this code, you get the following result &minus;</p>

<p>Let us check the return status of the script.</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
for (initialisation; condition; increment/decrement)
   action
</pre>
<p>Initially, the <b>for</b> statement performs initialization action, then it checks the condition. If the condition is true, it executes actions, thereafter it performs increment or decrement operation. The loop execution continues as long as the condition is true. For instance, the following example prints 1 to 5 using <b>for</b> loop &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { for (i = 1; i &lt;= 5; ++i) print i }'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
1
2
3
4
5
</pre>
<h2>While Loop</h2>
<p>The <b>while</b> loop keeps executing the action until a particular logical condition evaluates to true. Here is the syntax of <b>while</b> loop &minus;</p>
<h3>Syntax</h3>
<pre class="result notranslate">
while (condition)
   action
</pre>
<p>AWK first checks the condition; if the condition is true, it executes the action. This process repeats as long as the loop condition evaluates to true. For instance, the following example prints 1 to 5 using <b>while</b> loop &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN {i = 1; while (i &lt; 6) { print i; ++i } }'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
1
2
3
4
5
</pre>
<h2>Do-While Loop</h2>
<p>The <b>do-while</b> loop is similar to the while loop, except that the test condition is evaluated at the end of the loop. Here is the syntax of <b>do-while</b>loop &minus;</p>
<h3>Syntax</h3>
<pre class="result notranslate">
do
   action
while (condition)
</pre>
<p>In a <b>do-while</b> loop, the action statement gets executed at least once even when the condition statement evaluates to false. For instance, the following example prints 1 to 5 numbers using <b>do-while</b> loop &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN {i = 1; do { print i; ++i } while (i &lt; 6) }'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
1
2
3
4
5
</pre>
<h2>Break Statement</h2>
<p>As its name suggests, it is used to end the loop execution. Here is an example which ends the loop when the sum becomes greater than 50.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN {
   sum = 0; for (i = 0; i &lt; 20; ++i) { 
      sum += i; if (sum &gt; 50) break; else print "Sum =", sum 
   } 
}'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
Sum = 0
Sum = 1
Sum = 3
Sum = 6
Sum = 10
Sum = 15
Sum = 21
Sum = 28
Sum = 36
Sum = 45
</pre>
<h2>Continue Statement</h2>
<p>The <b>continue</b> statement is used inside a loop to skip to the next iteration of the loop. It is useful when you wish to skip the processing of some data inside the loop. For instance, the following example uses <b>continue</b> statement to print the even numbers between 1 to 20.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN {
   for (i = 1; i &lt;= 20; ++i) {
      if (i % 2 == 0) print i ; else continue
   } 
}'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
2
4
6
8
10
12
14
16
18
20
</pre>
<h2>Exit Statement</h2>
<p>It is used to stop the execution of the script. It accepts an integer as an argument which is the exit status code for AWK process. If no argument is supplied, <b>exit</b> returns status zero. Here is an example that stops the execution when the sum becomes greater than 50.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN {
   sum = 0; for (i = 0; i &lt; 20; ++i) {
      sum += i; if (sum &gt; 50) exit(10); else print "Sum =", sum 
   } 
}'
</pre>
<h3>Output</h3>
<p>On executing this code, you get the following result &minus;</p>
<pre class="result notranslate">
Sum = 0
Sum = 1
Sum = 3
Sum = 6
Sum = 10
Sum = 15
Sum = 21
Sum = 28
Sum = 36
Sum = 45
</pre>
<p>Let us check the return status of the script.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ echo $?
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
10
</pre>

<title>AWK Built-in Functions</title>

<h1>AWK - Built-in Functions</h1>

<p>AWK has a number of functions built into it that are always available to the programmer. This chapter describes Arithmetic, String, Time, Bit manipulation, and other miscellaneous functions with suitable examples.</p>

<p>AWK has the following built-in arithmetic functions.</p>

<p>AWK has the following built-in String functions.</p>

<p>AWK has the following built-in time functions.</p>

<p>AWK has the following built-in bit manipulation functions.</p>

<p>AWK has the following miscellaneous functions.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>AWK User Defined Functions</title>

<h1>AWK - User Defined Functions</h1>

<p>Functions are basic building blocks of a program. AWK allows us to define our own functions. A large program can be divided into functions and each function can be written/tested independently. It provides re-usability of code.</p>

<p>Given below is the general format of a user-defined function &minus;</p>

<h3>Syntax</h3>

<p>In this syntax, the<b> function_name</b> is the name of the user-defined function. Function name should begin with a letter and the rest of the characters can be any combination of numbers, alphabetic characters, or underscore. AWK's reserve words cannot be used as function names.</p>

<p>Functions can accept multiple arguments separated by comma. Arguments are not mandatory. You can also create a user-defined function without any argument.</p>

<p><b>function body</b> consists of one or more AWK statements.</p>

<p>Let us write two functions that calculate the minimum and the maximum number and call these functions from another function called <b>main</b>. The <b>functions.awk</b> file contains &minus;</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
function function_name(argument1, argument2, ...) { 
   function body
}
</pre>
<p>In this syntax, the<b> function_name</b> is the name of the user-defined function. Function name should begin with a letter and the rest of the characters can be any combination of numbers, alphabetic characters, or underscore. AWK's reserve words cannot be used as function names.</p>
<p>Functions can accept multiple arguments separated by comma. Arguments are not mandatory. You can also create a user-defined function without any argument.</p>
<p><b>function body</b> consists of one or more AWK statements.</p>
<p>Let us write two functions that calculate the minimum and the maximum number and call these functions from another function called <b>main</b>. The <b>functions.awk</b> file contains &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
# Returns minimum number
function find_min(num1, num2){
   if (num1 &lt; num2)
   return num1
   return num2
}
# Returns maximum number
function find_max(num1, num2){
   if (num1 &gt; num2)
   return num1
   return num2
}
# Main function
function main(num1, num2){
   # Find minimum number
   result = find_min(10, 20)
   print "Minimum =", result
  
   # Find maximum number
   result = find_max(10, 20)
   print "Maximum =", result
}
# Script execution starts here
BEGIN {
   main(10, 20)
}
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
Minimum = 10
Maximum = 20
</pre>

<title>AWK Output Redirection</title>

<h1>AWK - Output Redirection</h1>

<p>So far, we displayed data on standard output stream. We can also redirect data to a file. A redirection appears after the <b>print</b> or <b>printf</b> statement. Redirections in AWK are written just like redirection in shell commands, except that they are written inside the AWK program. This chapter explains redirection with suitable examples.</p>

<h2>Redirection Operator</h2>

<p>The syntax of the redirection operator is &minus;</p>

<h3>Syntax</h3>

<p>It writes the data into the <b>output-file</b>. If the output-file does not exist, then it creates one. When this type of redirection is used, the output-file is erased before the first output is written to it. Subsequent write operations to the same output-file do not erase the output-file, but append to it. For instance, the following example writes <b>Hello, World !!!</b> to the file.</p>

<p>Let us create a file with some text data.</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<p>Now let us redirect some contents into it using AWK's redirection operator.</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<h2>Append Operator</h2>

<p>The syntax of append operator is as follows &minus;</p>

<h3>Syntax</h3>

<p>It appends the data into the <b>output-file</b>. If the output-file does not exist, then it creates one. When this type of redirection is used, new contents are appended at the end of file. For instance, the following example appends <b>Hello, World !!!</b> to the file.</p>

<p>Let us create a file with some text data.</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<p>Now let us append some contents to it using AWK's append operator.</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<h2>Pipe</h2>

<p>It is possible to send output to another program through a pipe instead of using a file. This redirection opens a pipe to command, and writes the values of items through this pipe to another process to execute the command. The redirection argument command is actually an AWK expression. Here is the syntax of pipe &minus;</p>

<h3>Syntax</h3>

<p>Let us use <b>tr</b> command to convert lowercase letters to uppercase.</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<h2>Two way communication</h2>

<p>AWK can communicate to an external process using <b>|&amp;</b>, which is two-way communication. For instance, the following example uses <b>tr</b> command to convert lowercase letters to uppercase. Our <b>command.awk</b> file contains &minus;</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<p>Does the script look cryptic? Let us demystify it.</p>

<p>The first statement, <b>cmd = "tr [a-z] [A-Z]"</b>, is the command to which we establish the two-way communication from AWK.</p>

<p>The next statement, i.e., the print command provides input to the <b>tr</b> command. Here <b>&amp;|</b> indicates two-way communication.</p>

<p>The third statement, i.e., <b>close(cmd, "to")</b>, closes the <b>to</b> process after competing its execution.</p>

<p>The next statement <b>cmd |&amp; getline out</b> stores the <b>output</b> into out variable with the aid of getline function.</p>

<p>The next print statement prints the output and finally the <b>close</b> function closes the command.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
print DATA &gt; output-file
</pre>
<p>It writes the data into the <b>output-file</b>. If the output-file does not exist, then it creates one. When this type of redirection is used, the output-file is erased before the first output is written to it. Subsequent write operations to the same output-file do not erase the output-file, but append to it. For instance, the following example writes <b>Hello, World !!!</b> to the file.</p>
<p>Let us create a file with some text data.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ echo "Old data" &gt; /tmp/message.txt
[jerry]$ cat /tmp/message.txt
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
Old data
</pre>
<p>Now let us redirect some contents into it using AWK's redirection operator.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { print "Hello, World !!!" &gt; "/tmp/message.txt" }'
[jerry]$ cat /tmp/message.txt
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
Hello, World !!!
</pre>
<h2>Append Operator</h2>
<p>The syntax of append operator is as follows &minus;</p>
<h3>Syntax</h3>
<pre class="result notranslate">
print DATA &gt;&gt; output-file
</pre>
<p>It appends the data into the <b>output-file</b>. If the output-file does not exist, then it creates one. When this type of redirection is used, new contents are appended at the end of file. For instance, the following example appends <b>Hello, World !!!</b> to the file.</p>
<p>Let us create a file with some text data.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ echo "Old data" &gt; /tmp/message.txt 
[jerry]$ cat /tmp/message.txt
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
Old data
</pre>
<p>Now let us append some contents to it using AWK's append operator.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { print "Hello, World !!!" &gt;&gt; "/tmp/message.txt" }'
[jerry]$ cat /tmp/message.txt
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
Old data
Hello, World !!!
</pre>
<h2>Pipe</h2>
<p>It is possible to send output to another program through a pipe instead of using a file. This redirection opens a pipe to command, and writes the values of items through this pipe to another process to execute the command. The redirection argument command is actually an AWK expression. Here is the syntax of pipe &minus;</p>
<h3>Syntax</h3>
<pre class="result notranslate">
print items | command
</pre>
<p>Let us use <b>tr</b> command to convert lowercase letters to uppercase.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { print "hello, world !!!" | "tr [a-z] [A-Z]" }'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
HELLO, WORLD !!!
</pre>
<h2>Two way communication</h2>
<p>AWK can communicate to an external process using <b>|&amp;</b>, which is two-way communication. For instance, the following example uses <b>tr</b> command to convert lowercase letters to uppercase. Our <b>command.awk</b> file contains &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
BEGIN {
   cmd = "tr [a-z] [A-Z]"
   print "hello, world !!!" |&amp; cmd
   close(cmd, "to")
   
   cmd |&amp; getline out
   print out;
   close(cmd);
}
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
HELLO, WORLD !!!
</pre>

<title>AWK Pretty Printing</title>

<h1>AWK - Pretty Printing</h1>

<p>So far we have used AWK's <b>print</b> and <b>printf</b> functions to display data on standard output. But printf is much more powerful than what we have seen before. This function is borrowed from the C language and is very helpful while producing formatted output. Below is the syntax of the printf statement &minus;</p>

<h3>Syntax</h3>

<p>In the above syntax <b>fmt</b> is a string of format specifications and constants. <b>expr-list</b> is a list of arguments corresponding to format specifiers.</p>

<h2>Escape Sequences</h2>

<p>Similar to any string, format can contain embedded escape sequences. Discussed below are the escape sequences supported by AWK &minus;</p>

<h3>New Line</h3>

<p>The following example prints <b>Hello</b> and <b>World</b> in separate lines using newline character &minus;</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>Horizontal Tab</h3>

<p>The following example uses horizontal tab to display different field &minus;</p>

<p><b>Example</b></p>

<p>On executing the above code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>Vertical Tab</h3>

<p>The following example uses vertical tab after each filed &minus;</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>Backspace</h3>

<p>The following example prints a backspace after every field except the last one. It erases the last number from the first three fields. For instance, <b>Field 1</b> is displayed as <b>Field</b>, because the last character is erased with backspace. However, the last field <b>Field 4</b> is displayed as it is, as we did not have a <b>\b</b> after <b>Field 4</b>.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>Carriage Return</h3>

<p>In the following example, after printing every field, we do a <b>Carriage Return </b>and print the next value on top of the current printed value. It means, in the final output, you can see only <b>Field 4</b>, as it was the last thing to be printed on top of all the previous fields.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>Form Feed</h3>

<p>The following example uses form feed after printing each field.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h2>Format Specifier</h2>

<p>As in C-language, AWK also has format specifiers. The AWK version of the printf statement accepts the following conversion specification formats &minus;</p>

<h3>%c</h3>

<p>It prints a single character. If the argument used for <b>%c</b> is numeric, it is treated as a character and printed. Otherwise, the argument is assumed to be a string, and the only first character of that string is printed.</p>

<p><b>Example</b></p>

<p><b>Output</b></p>

<p>On executing this code, you get the following result &minus;</p>

<h3>%d and %i</h3>

<p>It prints only the integer part of a decimal number.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>%e and %E</h3>

<p>It prints a floating point number of the form [-]d.dddddde[+-]dd.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<p>The <b>%E</b> format uses <b>E</b> instead of e.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>%f</h3>

<p>It prints a floating point number of the form [-]ddd.dddddd.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>%g and %G</h3>

<p>Uses %e or %f conversion, whichever is shorter, with non-significant zeros suppressed.</p>

<p><b>Example</b></p>

<p><b>Output</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p>The <b>%G</b> format uses <b>%E</b> instead of %e.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>%o</h3>

<p>It prints an unsigned octal number.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>%u</h3>

<p>It prints an unsigned decimal number.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>%s</h3>

<p>It prints a character string.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>%x and %X</h3>

<p>It prints an unsigned hexadecimal number. The <b>%X</b> format uses uppercase letters instead of lowercase.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<p>Now let use %X and observe the result &minus;</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>%%</h3>

<p>It prints a single <b>%</b> character and no argument is converted.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h2>Optional Parameters with %</h2>

<p>With <b>%</b> we can use following optional parameters &minus;</p>

<h3>Width</h3>

<p>The field is padded to the <b>width</b>. By default, the field is padded with spaces but when 0 flag is used, it is padded with zeroes.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>Leading Zeros</h3>

<p>A leading zero acts as a flag, which indicates that the output should be padded with zeroes instead of spaces. Please note that this flag only has an effect when the field is wider than the value to be printed. The following example describes this &minus;</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>Left Justification</h3>

<p>The expression should be left-justified within its field. When the input-string is less than the number of characters specified, and you want it to be left justified, i.e., by adding spaces to the right, use a minus symbol (â€“) immediately after the % and before the number.</p>

<p>In the following example, output of the AWK command is piped to the cat command to display the END OF LINE($) character.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>Prefix Sign</h3>

<p>It always prefixes numeric values with a sign, even if the value is positive.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>Hash</h3>

<p>For %o, it supplies a leading zero. For %x and %X, it supplies a leading 0x or 0X respectively, only if the result is non-zero. For %e, %E, %f, and %F, the result always contains a decimal point. For %g and %G, trailing zeros are not removed from the result. The following example describes this &minus;</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
printf fmt, expr-list
</pre>
<p>In the above syntax <b>fmt</b> is a string of format specifications and constants. <b>expr-list</b> is a list of arguments corresponding to format specifiers.</p>
<h2>Escape Sequences</h2>
<p>Similar to any string, format can contain embedded escape sequences. Discussed below are the escape sequences supported by AWK &minus;</p>
<h3>New Line</h3>
<p>The following example prints <b>Hello</b> and <b>World</b> in separate lines using newline character &minus;</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { printf "Hello\nWorld\n" }'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Hello
World
</pre>
<h3>Horizontal Tab</h3>
<p>The following example uses horizontal tab to display different field &minus;</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { printf "Sr No\tName\tSub\tMarks\n" }'
</pre>
<p>On executing the above code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Sr No   Name    Sub Marks
</pre>
<h3>Vertical Tab</h3>
<p>The following example uses vertical tab after each filed &minus;</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { printf "Sr No\vName\vSub\vMarks\n" }'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Sr No
   Name
      Sub
         Marks
</pre>
<h3>Backspace</h3>
<p>The following example prints a backspace after every field except the last one. It erases the last number from the first three fields. For instance, <b>Field 1</b> is displayed as <b>Field</b>, because the last character is erased with backspace. However, the last field <b>Field 4</b> is displayed as it is, as we did not have a <b>\b</b> after <b>Field 4</b>.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { printf "Field 1\bField 2\bField 3\bField 4\n" }'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Field Field Field Field 4
</pre>
<h3>Carriage Return</h3>
<p>In the following example, after printing every field, we do a <b>Carriage Return </b>and print the next value on top of the current printed value. It means, in the final output, you can see only <b>Field 4</b>, as it was the last thing to be printed on top of all the previous fields.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { printf "Field 1\rField 2\rField 3\rField 4\n" }'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Field 4
</pre>
<h3>Form Feed</h3>
<p>The following example uses form feed after printing each field.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { printf "Sr No\fName\fSub\fMarks\n" }'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Sr No
   Name
      Sub
         Marks
</pre>
<h2>Format Specifier</h2>
<p>As in C-language, AWK also has format specifiers. The AWK version of the printf statement accepts the following conversion specification formats &minus;</p>
<h3>%c</h3>
<p>It prints a single character. If the argument used for <b>%c</b> is numeric, it is treated as a character and printed. Otherwise, the argument is assumed to be a string, and the only first character of that string is printed.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { printf "ASCII value 65 = character %c\n", 65 }'
</pre>
<p><b>Output</b></p>
<p>On executing this code, you get the following result &minus;</p>
<pre class="result notranslate">
ASCII value 65 = character A
</pre>
<h3>%d and %i</h3>
<p>It prints only the integer part of a decimal number.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { printf "Percentags = %d\n", 80.66 }'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Percentags = 80
</pre>
<h3>%e and %E</h3>
<p>It prints a floating point number of the form [-]d.dddddde[+-]dd.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { printf "Percentags = %E\n", 80.66 }'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Percentags = 8.066000e+01
</pre>
<p>The <b>%E</b> format uses <b>E</b> instead of e.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { printf "Percentags = %e\n", 80.66 }'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Percentags = 8.066000E+01
</pre>
<h3>%f</h3>
<p>It prints a floating point number of the form [-]ddd.dddddd.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { printf "Percentags = %f\n", 80.66 }'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Percentags = 80.660000
</pre>
<h3>%g and %G</h3>
<p>Uses %e or %f conversion, whichever is shorter, with non-significant zeros suppressed.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { printf "Percentags = %g\n", 80.66 }'
</pre>
<p><b>Output</b></p>
<p>On executing this code, you get the following result &minus;</p>
<pre class="result notranslate">
Percentags = 80.66
</pre>
<p>The <b>%G</b> format uses <b>%E</b> instead of %e.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { printf "Percentags = %G\n", 80.66 }'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Percentags = 80.66
</pre>
<h3>%o</h3>
<p>It prints an unsigned octal number.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { printf "Octal representation of decimal number 10 = %o\n", 10}'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Octal representation of decimal number 10 = 12
</pre>
<h3>%u</h3>
<p>It prints an unsigned decimal number.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { printf "Unsigned 10 = %u\n", 10 }'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Unsigned 10 = 10
</pre>
<h3>%s</h3>
<p>It prints a character string.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { printf "Name = %s\n", "Sherlock Holmes" }'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Name = Sherlock Holmes
</pre>
<h3>%x and %X</h3>
<p>It prints an unsigned hexadecimal number. The <b>%X</b> format uses uppercase letters instead of lowercase.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { 
   printf "Hexadecimal representation of decimal number 15 = %x\n", 15
}'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Hexadecimal representation of decimal number 15 = f
</pre>
<p>Now let use %X and observe the result &minus;</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { 
   printf "Hexadecimal representation of decimal number 15 = %X\n", 15
}'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Hexadecimal representation of decimal number 15 = F
</pre>
<h3>%%</h3>
<p>It prints a single <b>%</b> character and no argument is converted.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { printf "Percentags = %d%%\n", 80.66 }'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Percentags = 80%
</pre>
<h2>Optional Parameters with %</h2>
<p>With <b>%</b> we can use following optional parameters &minus;</p>
<h3>Width</h3>
<p>The field is padded to the <b>width</b>. By default, the field is padded with spaces but when 0 flag is used, it is padded with zeroes.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { 
   num1 = 10; num2 = 20; printf "Num1 = %10d\nNum2 = %10d\n", num1, num2 
}'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Num1 =         10
Num2 =         20
</pre>
<h3>Leading Zeros</h3>
<p>A leading zero acts as a flag, which indicates that the output should be padded with zeroes instead of spaces. Please note that this flag only has an effect when the field is wider than the value to be printed. The following example describes this &minus;</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { 
   num1 = -10; num2 = 20; printf "Num1 = %05d\nNum2 = %05d\n", num1, num2 
}'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Num1 = -0010
Num2 = 00020
</pre>
<h3>Left Justification</h3>
<p>The expression should be left-justified within its field. When the input-string is less than the number of characters specified, and you want it to be left justified, i.e., by adding spaces to the right, use a minus symbol (â€“) immediately after the % and before the number.</p>
<p>In the following example, output of the AWK command is piped to the cat command to display the END OF LINE($) character.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { num = 10; printf "Num = %-5d\n", num }' | cat -vte
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Num = 10   $
</pre>
<h3>Prefix Sign</h3>
<p>It always prefixes numeric values with a sign, even if the value is positive.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { 
   num1 = -10; num2 = 20; printf "Num1 = %+d\nNum2 = %+d\n", num1, num2 
}'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Num1 = -10
Num2 = +20
</pre>
<h3>Hash</h3>
<p>For %o, it supplies a leading zero. For %x and %X, it supplies a leading 0x or 0X respectively, only if the result is non-zero. For %e, %E, %f, and %F, the result always contains a decimal point. For %g and %G, trailing zeros are not removed from the result. The following example describes this &minus;</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { 
   printf "Octal representation = %#o\nHexadecimal representaion = %#X\n", 10, 10
}'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Octal representation = 012
Hexadecimal representation = 0XA
</pre>

<title>Awk Quick Guide</title>

<h1>AWK - Quick Guide</h1>

<h1>AWK - Overview</h1>

<p>AWK is an interpreted programming language. It is very powerful and specially designed for text processing. Its name is derived from the family names of its authors &minus; <b>Alfred Aho, Peter Weinberger, and Brian Kernighan.</b></p>

<p>The version of AWK that GNU/Linux distributes is written and maintained by the Free Software Foundation (FSF); it is often referred to as <b>GNU AWK.</b></p>

<h2>Types of AWK</h2>

<p>Following are the variants of AWK &minus;</p>

<p><b>AWK</b> &minus; Original AWK from AT &amp; T Laboratory.</p>

<p><b>NAWK</b> &minus; Newer and improved version of AWK from AT &amp; T Laboratory.</p>

<p><b>GAWK</b> &minus; It is GNU AWK. All GNU/Linux distributions ship GAWK. It is fully compatible with AWK and NAWK.</p>

<h2>Typical Uses of AWK</h2>

<p>Myriad of tasks can be done with AWK. Listed below are just a few of them &minus;</p>

<h1>AWK - Environment</h1>

<p>This chapter describes how to set up the AWK environment on your GNU/Linux system.</p>

<h2>Installation Using Package Manager</h2>

<p>Generally, AWK is available by default on most GNU/Linux distributions. You can use <b>which</b> command to check whether it is present on your system or not. In case you donâ€™t have AWK, then install it on Debian based GNU/Linux using Advance Package Tool <b>(APT)</b> package manager as follows &minus;</p>

<p>Similarly, to install AWK on RPM based GNU/Linux, use Yellowdog Updator Modifier <b>yum</b> package manager as follows &minus;</p>

<p>After installation, ensure that AWK is accessible via command line.</p>

<p>On executing the above code, you get the following result &minus;</p>

<h2>Installation from Source Code</h2>

<p>As GNU AWK is a part of the GNU project, its source code is available for free download. We have already seen how to install AWK using package manager. Let us now understand how to install AWK from its source code.</p>

<p>The following installation is applicable to any GNU/Linux software, and for most other freely-available programs as well. Here are the installation steps &minus;</p>

<p><b>Step 1</b> &minus; Download the source code from an authentic place. The command-line utility <b>wget</b> serves this purpose.</p>

<p><b>Step 2</b> &minus; Decompress and extract the downloaded source code.</p>

<p><b>Step 3</b> &minus; Change into the directory and run configure.</p>

<p><b>Step 4</b> &minus; Upon successful completion, the <b>configure</b> generates Makefile. To compile the source code, issue a <b>make</b> command.</p>

<p><b>Step 5</b> &minus; You can run the test suite to ensure the build is clean. This is an optional step.</p>

<p><b>Step 6</b> &minus; Finally, install AWK. Make sure you have super-user privileges.</p>

<p>That is it! You have successfully compiled and installed AWK. Verify it by executing the <b>awk</b> command as follows &minus;</p>

<p>On executing this code, you get the following result &minus;</p>

<h1>AWK - Workflow</h1>

<p>To become an expert AWK programmer, you need to know its internals. AWK follows a simple workflow &minus; Read, Execute, and Repeat. The following diagram depicts the workflow of AWK &minus;</p>

<h3>Read</h3>

<p>AWK reads a line from the input stream (file, pipe, or stdin) and stores it in memory.</p>

<h3>Execute</h3>

<p>All AWK commands are applied sequentially on the input. By default AWK execute commands on every line. We can restrict this by providing patterns.</p>

<h3>Repeat</h3>

<p>This process repeats until the file reaches its end.</p>

<h2>Program Structure</h2>

<p>Let us now understand the program structure of AWK.</p>

<h3>BEGIN block</h3>

<p>The syntax of the BEGIN block is as follows &minus;</p>

<p><b>Syntax</b></p>

<p>The BEGIN block gets executed at program start-up. It executes only once. This is good place to initialize variables. BEGIN is an AWK keyword and hence it must be in upper-case. Please note that this block is optional.</p>

<h3>Body Block</h3>

<p>The syntax of the body block is as follows &minus;</p>

<p><b>Syntax</b></p>

<p>The body block applies AWK commands on every input line. By default, AWK executes commands on every line. We can restrict this by providing patterns. Note that there are no keywords for the Body block.</p>

<h3>END Block</h3>

<p>The syntax of the END block is as follows &minus;</p>

<p><b>Syntax</b></p>

<p>The END block executes at the end of the program. END is an AWK keyword and hence it must be in upper-case. Please note that this block is optional.</p>

<p>Let us create a file <b>marks.txt</b> which contains the serial number, name of the student, subject name, and number of marks obtained.</p>

<p>Let us now display the file contents with header by using AWK script.</p>

<p><b>Example</b></p>

<p>When this code is executed, it produces the following result &minus;</p>

<p><b>Output</b></p>

<p>At the start, AWK prints the header from the BEGIN block. Then in the body block, it reads a line from a file and executes AWK's print command which just prints the contents on the standard output stream. This process repeats until file reaches the end.</p>

<h1>AWK - Basic Syntax</h1>

<p>AWK is simple to use. We can provide AWK commands either directly from the command line or in the form of a text file containing AWK commands.</p>

<h2>AWK Command Line</h2>

<p>We can specify an AWK command within single quotes at command line as shown &minus;</p>

<h3>Example</h3>

<p>Consider a text file <b>marks.txt</b> with the following content &minus;</p>

<p>Let us display the complete content of the file using AWK as follows &minus;</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h2>AWK Program File</h2>

<p>We can provide AWK commands in a script file as shown &minus;</p>

<p>First, create a text file <b>command.awk</b> containing the AWK command as shown below &minus;</p>

<p>Now we can instruct the AWK to read commands from the text file and perform the action. Here, we achieve the same result as shown in the above example.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h2>AWK Standard Options</h2>

<p>AWK supports the following standard options which can be provided from the command line.</p>

<h3>The -v option</h3>

<p>This option assigns a value to a variable. It allows assignment before the program execution. The following example describes the usage of the -v option.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>The --dump-variables[=file] option</h3>

<p>It prints a sorted list of global variables and their final values to file. The default file is <b>awkvars.out</b>.</p>

<p><b>Example</b></p>

<p>On executing the above code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>The --help option</h3>

<p>This option prints the help message on standard output.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>The --lint[=fatal] option</h3>

<p>This option enables checking of non-portable or dubious constructs. When an argument <b>fatal</b> is provided, it treats warning messages as errors. The following example demonstrates this &minus;</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>The --posix option</h3>

<p>This option turns on strict POSIX compatibility, in which all common and gawk-specific extensions are disabled.</p>

<h3>The --profile[=file] option</h3>

<p>This option generates a pretty-printed version of the program in file. Default file is <b>awkprof.out</b>. Below simple example illustrates this &minus;</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>The --traditional option</h3>

<p>This option disables all gawk-specific extensions.</p>

<h3>The --version option</h3>

<p>This option displays the version information of the AWK program.</p>

<p><b>Example</b></p>

<p>When this code is executed, it produces the following result &minus;</p>

<p><b>Output</b></p>

<h1>AWK - Basic Examples</h1>

<p>This chapter describes several useful AWK commands and their appropriate examples. Consider a text file <b>marks.txt</b> to be processed with the following content &minus;</p>

<h2>Printing Column or Field</h2>

<p>You can instruct AWK to print only certain columns from the input field. The following example demonstrates this &minus;</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<p>In the file <b>marks.txt</b>, the third column contains the subject name and the fourth column contains the marks obtained in a particular subject. Let us print these two columns using AWK print command. In the above example, <b>$3 and $4</b> represent the third and the fourth fields respectively from the input record.</p>

<h2>Printing All Lines</h2>

<p>By default, AWK prints all the lines that match pattern.</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<p>In the above example, we are searching form pattern <b>a</b>. When a pattern match succeeds, it executes a command from the body block. In the absence of a body block &minus; default action is taken which is print the record. Hence, the following command produces the same result &minus;</p>

<h3>Example</h3>

<h2>Printing Columns by Pattern</h2>

<p>When a pattern match succeeds, AWK prints the entire record by default. But you can instruct AWK to print only certain fields. For instance, the following example prints the third and fourth field when a pattern match succeeds.</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<h2>Printing Column in Any Order</h2>

<p>You can print columns in any order. For instance, the following example prints the fourth column followed by the third column.</p>

<h3>Example</h3>

<p>On executing the above code, you get the following result &minus;</p>

<h3>Output</h3>

<h2>Counting and Printing Matched Pattern</h2>

<p>Let us see an example where you can count and print the number of lines for which a pattern match succeeded.</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<p>In this example, we increment the value of counter when a pattern match succeeds and we print this value in the END block. Note that unlike other programming languages, there is no need to declare a variable before using it.</p>

<h2>Printing Lines with More than 18 Characters</h2>

<p>Let us print only those lines that contain more than 18 characters.</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<p>AWK provides a built-in <b>length</b>  function that returns the length of the string. <b>$0</b> variable stores the entire line and in the absence of a body block, default action is taken, i.e., the print action. Hence, if a line has more than 18 characters, then the comparison results true and the line gets printed.</p>

<h1>AWK - Built-in Variables</h1>

<p>AWK provides several built-in variables. They play an important role while writing AWK scripts. This chapter demonstrates the usage of built-in variables.</p>

<h2>Standard AWK variables</h2>

<p>The standard AWK variables are discussed below.</p>

<h3>ARGC</h3>

<p>It implies the number of arguments provided at the command line.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<p>But why AWK shows 5 when you passed only 4 arguments? Just check the following example to clear your doubt.</p>

<h3>ARGV</h3>

<p>It is an array that stores the command-line arguments. The array's valid index ranges from 0 to ARGC-1.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>CONVFMT</h3>

<p>It represents the conversion format for numbers. Its default value is <b>%.6g</b>.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>ENVIRON</h3>

<p>It is an associative array of environment variables.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<p>To find names of other environment variables, use <b>env</b> command.</p>

<h3>FILENAME</h3>

<p>It represents the current file name.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<p>Please note that FILENAME is undefined in the BEGIN block.</p>

<h3>FS</h3>

<p>It represents the (input) field separator and its default value is space. You can also change this by using <b>-F</b> command line option.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>NF</h3>

<p>It represents the number of fields in the current record. For instance, the following example prints only those lines that contain more than two fields.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>NR</h3>

<p>It represents the number of the current record. For instance, the following example prints the record if the current record contains less than three fields.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>FNR</h3>

<p>It is similar to NR, but relative to the current file. It is useful when AWK is operating on multiple files. Value of FNR resets with new file.</p>

<h3>OFMT</h3>

<p>It represents the output format number and its default value is <b>%.6g</b>.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>OFS</h3>

<p>It represents the output field separator and its default value is space.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>ORS</h3>

<p>It represents the output record separator and its default value is newline.</p>

<p><b>Example</b></p>

<p>On executing the above code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>RLENGTH</h3>

<p>It represents the length of the string matched by <b>match</b> function. AWK's match function searches for a given string in the input-string.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>RS</h3>

<p>It represents (input) record separator and its default value is newline.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>RSTART</h3>

<p>It represents the first position in the string matched by <b>match</b> function.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>SUBSEP</h3>

<p>It represents the separator character for array subscripts and its default value is <b>\034</b>.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>$0</h3>

<p>It represents the entire input record.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>$n</h3>

<p>It represents the n<sup>th</sup> field in the current record where the fields are separated by FS.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h2>GNU AWK Specific Variables</h2>

<p>GNU AWK specific variables are as follows &minus;</p>

<h3>ARGIND</h3>

<p>It represents the index in ARGV of the current file being processed.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>BINMODE</h3>

<p>It is used to specify binary mode for all file I/O on non-POSIX systems. Numeric values of 1, 2, or 3 specify that input files, output files, or all files, respectively, should use binary I/O. String values of <b>r</b> or <b>w</b> specify that input files or output files, respectively, should use binary I/O. String values of <b>rw</b> or <b>wr</b> specify that all files should use binary I/O.</p>

<h3>ERRNO</h3>

<p>A string indicates an error when a redirection fails for <b>getline</b> or if <b>close</b> call fails.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>FIELDWIDTHS</h3>

<p>A space separated list of field widths variable is set, GAWK parses the input into fields of fixed width, instead of using the value of the FS variable as the field separator.</p>

<h3>IGNORECASE</h3>

<p>When this variable is set, GAWK becomes case-insensitive. The following example demonstrates this &minus;</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>LINT</h3>

<p>It provides dynamic control of the <b>--lint</b> option from the GAWK program. When this variable is set, GAWK prints lint warnings. When assigned the string value fatal, lint warnings become fatal errors, exactly like <b>--lint=fatal</b>.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>PROCINFO</h3>

<p>This is an associative array containing information about the process, such as real and effective UID numbers, process ID number, and so on.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>TEXTDOMAIN</h3>

<p>It represents the text domain of the AWK program. It is used to find the localized translations for the program's strings.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<p>The above output shows English text due to <b>en_IN</b> locale</p>

<h1>AWK - Operators</h1>

<p>Like other programming languages, AWK also provides a large set of operators. This chapter explains AWK operators with suitable examples.</p>

<p>AWK supports the following arithmetic operators.</p>

<p>AWK supports the following increment and decrement operators.</p>

<p>AWK supports the following assignment operators.</p>

<p>AWK supports the following relational operators.</p>

<p>AWK supports the following logical operators.</p>

<p>We can easily implement a condition expression using ternary operator.</p>

<p>AWK supports the following unary operators.</p>

<p>There are two formats of exponential operators.</p>

<p>Space is a string concatenation operator that merges two strings.</p>

<p>It is represented by <b>in</b>. It is used while accessing array elements.</p>

<p>This example explains the two forms of regular expressions operators.</p>

<h1>AWK - Regular Expressions</h1>

<p>AWK is very powerful and efficient in handling regular expressions. A number of complex tasks can be solved with simple regular expressions. Any command-line expert knows the power of regular expressions.</p>

<p>This chapter covers standard regular expressions with suitable examples.</p>

<h2>Dot</h2>

<p>It matches any single character except the end of line character. For instance, the following example matches <b>fin, fun, fan</b> etc.</p>

<h3>Example</h3>

<p>On executing the above code, you get the following result &minus;</p>

<h3>Output</h3>

<h2>Start of line</h2>

<p>It matches the start of line. For instance, the following example prints all the lines that start with pattern <b>The</b>.</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<h2>End of line</h2>

<p>It matches the end of line. For instance, the following example prints the lines that end with the letter <b>n</b>.</p>

<h3>Example</h3>

<h3>Output</h3>

<p>On executing this code, you get the following result &minus;</p>

<h2>Match character set</h2>

<p>It is used to match only one out of several characters. For instance, the following example matches pattern <b>Call</b> and <b>Tall</b> but not <b>Ball</b>.</p>

<h3>Example</h3>

<h3>Output</h3>

<p>On executing this code, you get the following result &minus;</p>

<h2>Exclusive set</h2>

<p>In exclusive set, the carat negates the set of characters in the square brackets. For instance, the following example prints only <b>Ball</b>.</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<h2>Alteration</h2>

<p>A vertical bar allows regular expressions to be logically ORed. For instance, the following example prints <b>Ball</b> and <b>Call</b>.</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<h2>Zero or One Occurrence</h2>

<p>It matches zero or one occurrence of the preceding character. For instance, the following example matches <b>Colour</b> as well as <b>Color</b>. We have made <b>u</b> as an optional character by using <b>?</b>.</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<h2>Zero or More Occurrence</h2>

<p>It matches zero or more occurrences of the preceding character. For instance, the following example matches <b>ca, cat, catt,</b> and so on.</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<h2>One or More Occurrence</h2>

<p>It matches one or more occurrence of the preceding character. For instance below example matches one or more occurrences of the <b>2</b>.</p>

<h3>Example</h3>

<p>On executing the above code, you get the following result &minus;</p>

<h3>Output</h3>

<h2>Grouping</h2>

<p><b>Parentheses ()</b> are used for grouping and the character | is used for alternatives. For instance, the following regular expression matches the lines containing either <b>Apple Juice or Apple Cake</b>.</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<h1>AWK - Arrays</h1>

<p>AWK has associative arrays and one of the best thing about it is â€“ the indexes need not to be continuous set of number; you can use either string or number as an array index. Also, there is no need to declare the size of an array in advance â€“ arrays can expand/shrink at runtime.</p>

<p>Its syntax is as follows &minus;</p>

<h3>Syntax</h3>

<p>Where <b>array_name</b> is the name of array, <b>index</b> is the array index, and <b>value</b> is any value assigning to the element of the array.</p>

<h2>Creating Array</h2>

<p>To gain more insight on array, let us create and access the elements of an array.</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<p>In the above example, we declare the array as <b>fruits</b> whose index is fruit name and the value is the color of the fruit. To access array elements, we use <b>array_name[index]</b> format.</p>

<h2>Deleting Array Elements</h2>

<p>For insertion, we used assignment operator. Similarly, we can use <b>delete</b> statement to remove an element from the array. The syntax of delete statement is as follows &minus;</p>

<h3>Syntax</h3>

<p>The following example deletes the element <b>orange</b>. Hence the command does not show any output.</p>

<h3>Example</h3>

<h2>Multi-Dimensional arrays</h2>

<p>AWK only supports one-dimensional arrays. But you can easily simulate a multi-dimensional array using the one-dimensional array itself.</p>

<p>For instance, given below is a 3x3 three-dimensional array &minus;</p>

<p>In the above example, array[0][0] stores 100, array[0][1] stores 200, and so on. To store 100 at array location [0][0], we can use the following syntax &minus;</p>

<h3>Syntax</h3>

<p>Though we gave <b>0,0</b> as index, these are not two indexes. In reality, it is just one index with the string <b>0,0</b>.</p>

<p>The following example simulates a 2-D array &minus;</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<p>You can also perform a variety of operations on an array such as sorting its elements/indexes. For that purpose, you can use <b>assort</b> and <b>asorti</b> functions</p>

<h1>AWK - Control Flow</h1>

<p>Like other programming languages, AWK provides conditional statements to control the flow of a program. This chapter explains AWK's control statements with suitable examples.</p>

<h2>If statement</h2>

<p>It simply tests the condition and performs certain actions depending upon the condition. Given below is the syntax of <b>if</b> statement &minus;</p>

<h3>Syntax</h3>

<p>We can also use a pair of curly braces as given below to execute multiple actions &minus;</p>

<h3>Syntax</h3>

<p>For instance, the following example checks whether a number is even or not &minus;</p>

<h3>Example</h3>

<p>On executing the above code, you get the following result &minus;</p>

<h3>Output</h3>

<h2>If Else Statement</h2>

<p>In <b>if-else</b> syntax, we can provide a list of actions to be performed when a condition becomes false.</p>

<p>The syntax of <b>if-else</b> statement is as follows &minus;</p>

<h3>Syntax</h3>

<p>In the above syntax, action-1 is performed when the condition evaluates to true and action-2 is performed when the condition evaluates to false. For instance, the following example checks whether a number is even or not &minus;</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<h2>If-Else-If Ladder</h2>

<p>We can easily create an <b>if-else-if</b> ladder by using multiple <b>if-else</b> statements. The following example demonstrates this &minus;</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<h1>AWK - Loops</h1>

<p>This chapter explains AWK's loops with suitable example. Loops are used to execute a set of actions in a repeated manner. The loop execution continues as long as the loop condition is true.</p>

<h2>For Loop</h2>

<p>The syntax of <b>for</b> loop is &minus;</p>

<h3>Syntax</h3>

<p>Initially, the <b>for</b> statement performs initialization action, then it checks the condition. If the condition is true, it executes actions, thereafter it performs increment or decrement operation. The loop execution continues as long as the condition is true. For instance, the following example prints 1 to 5 using <b>for</b> loop &minus;</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<h2>While Loop</h2>

<p>The <b>while</b> loop keeps executing the action until a particular logical condition evaluates to true. Here is the syntax of <b>while</b> loop &minus;</p>

<h3>Syntax</h3>

<p>AWK first checks the condition; if the condition is true, it executes the action. This process repeats as long as the loop condition evaluates to true. For instance, the following example prints 1 to 5 using <b>while</b> loop &minus;</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<h2>Do-While Loop</h2>

<p>The <b>do-while</b> loop is similar to the while loop, except that the test condition is evaluated at the end of the loop. Here is the syntax of <b>do-while</b>loop &minus;</p>

<h3>Syntax</h3>

<p>In a <b>do-while</b> loop, the action statement gets executed at least once even when the condition statement evaluates to false. For instance, the following example prints 1 to 5 numbers using <b>do-while</b> loop &minus;</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<h2>Break Statement</h2>

<p>As its name suggests, it is used to end the loop execution. Here is an example which ends the loop when the sum becomes greater than 50.</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<h2>Continue Statement</h2>

<p>The <b>continue</b> statement is used inside a loop to skip to the next iteration of the loop. It is useful when you wish to skip the processing of some data inside the loop. For instance, the following example uses <b>continue</b> statement to print the even numbers between 1 to 20.</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<h2>Exit Statement</h2>

<p>It is used to stop the execution of the script. It accepts an integer as an argument which is the exit status code for AWK process. If no argument is supplied, <b>exit</b> returns status zero. Here is an example that stops the execution when the sum becomes greater than 50.</p>

<h3>Example</h3>

<h3>Output</h3>

<p>On executing this code, you get the following result &minus;</p>

<p>Let us check the return status of the script.</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<h1>AWK - Built-in Functions</h1>

<p>AWK has a number of functions built into it that are always available to the programmer. This chapter describes Arithmetic, String, Time, Bit manipulation, and other miscellaneous functions with suitable examples.</p>

<p>AWK has the following built-in arithmetic functions.</p>

<p>AWK has the following built-in String functions.</p>

<p>AWK has the following built-in time functions.</p>

<p>AWK has the following built-in bit manipulation functions.</p>

<p>AWK has the following miscellaneous functions.</p>

<h1>AWK - User Defined Functions</h1>

<p>Functions are basic building blocks of a program. AWK allows us to define our own functions. A large program can be divided into functions and each function can be written/tested independently. It provides re-usability of code.</p>

<p>Given below is the general format of a user-defined function &minus;</p>

<h3>Syntax</h3>

<p>In this syntax, the<b> function_name</b> is the name of the user-defined function. Function name should begin with a letter and the rest of the characters can be any combination of numbers, alphabetic characters, or underscore. AWK's reserve words cannot be used as function names.</p>

<p>Functions can accept multiple arguments separated by comma. Arguments are not mandatory. You can also create a user-defined function without any argument.</p>

<p><b>function body</b> consists of one or more AWK statements.</p>

<p>Let us write two functions that calculate the minimum and the maximum number and call these functions from another function called <b>main</b>. The <b>functions.awk</b> file contains &minus;</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<h1>AWK - Output Redirection</h1>

<p>So far, we displayed data on standard output stream. We can also redirect data to a file. A redirection appears after the <b>print</b> or <b>printf</b> statement. Redirections in AWK are written just like redirection in shell commands, except that they are written inside the AWK program. This chapter explains redirection with suitable examples.</p>

<h2>Redirection Operator</h2>

<p>The syntax of the redirection operator is &minus;</p>

<h3>Syntax</h3>

<p>It writes the data into the <b>output-file</b>. If the output-file does not exist, then it creates one. When this type of redirection is used, the output-file is erased before the first output is written to it. Subsequent write operations to the same output-file do not erase the output-file, but append to it. For instance, the following example writes <b>Hello, World !!!</b> to the file.</p>

<p>Let us create a file with some text data.</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<p>Now let us redirect some contents into it using AWK's redirection operator.</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<h2>Append Operator</h2>

<p>The syntax of append operator is as follows &minus;</p>

<h3>Syntax</h3>

<p>It appends the data into the <b>output-file</b>. If the output-file does not exist, then it creates one. When this type of redirection is used, new contents are appended at the end of file. For instance, the following example appends <b>Hello, World !!!</b> to the file.</p>

<p>Let us create a file with some text data.</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<p>Now let us append some contents to it using AWK's append operator.</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<h2>Pipe</h2>

<p>It is possible to send output to another program through a pipe instead of using a file. This redirection opens a pipe to command, and writes the values of items through this pipe to another process to execute the command. The redirection argument command is actually an AWK expression. Here is the syntax of pipe &minus;</p>

<h3>Syntax</h3>

<p>Let us use <b>tr</b> command to convert lowercase letters to uppercase.</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<h2>Two way communication</h2>

<p>AWK can communicate to an external process using <b>|&amp;</b>, which is two-way communication. For instance, the following example uses <b>tr</b> command to convert lowercase letters to uppercase. Our <b>command.awk</b> file contains &minus;</p>

<h3>Example</h3>

<p>On executing this code, you get the following result &minus;</p>

<h3>Output</h3>

<p>Does the script look cryptic? Let us demystify it.</p>

<p>The first statement, <b>cmd = "tr [a-z] [A-Z]"</b>, is the command to which we establish the two-way communication from AWK.</p>

<p>The next statement, i.e., the print command provides input to the <b>tr</b> command. Here <b>&amp;|</b> indicates two-way communication.</p>

<p>The third statement, i.e., <b>close(cmd, "to")</b>, closes the <b>to</b> process after competing its execution.</p>

<p>The next statement <b>cmd |&amp; getline out</b> stores the <b>output</b> into out variable with the aid of getline function.</p>

<p>The next print statement prints the output and finally the <b>close</b> function closes the command.</p>

<h1>AWK - Pretty Printing</h1>

<p>So far we have used AWK's <b>print</b> and <b>printf</b> functions to display data on standard output. But printf is much more powerful than what we have seen before. This function is borrowed from the C language and is very helpful while producing formatted output. Below is the syntax of the printf statement &minus;</p>

<h3>Syntax</h3>

<p>In the above syntax <b>fmt</b> is a string of format specifications and constants. <b>expr-list</b> is a list of arguments corresponding to format specifiers.</p>

<h2>Escape Sequences</h2>

<p>Similar to any string, format can contain embedded escape sequences. Discussed below are the escape sequences supported by AWK &minus;</p>

<h3>New Line</h3>

<p>The following example prints <b>Hello</b> and <b>World</b> in separate lines using newline character &minus;</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>Horizontal Tab</h3>

<p>The following example uses horizontal tab to display different field &minus;</p>

<p><b>Example</b></p>

<p>On executing the above code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>Vertical Tab</h3>

<p>The following example uses vertical tab after each filed &minus;</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>Backspace</h3>

<p>The following example prints a backspace after every field except the last one. It erases the last number from the first three fields. For instance, <b>Field 1</b> is displayed as <b>Field</b>, because the last character is erased with backspace. However, the last field <b>Field 4</b> is displayed as it is, as we did not have a <b>\b</b> after <b>Field 4</b>.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>Carriage Return</h3>

<p>In the following example, after printing every field, we do a <b>Carriage Return </b>and print the next value on top of the current printed value. It means, in the final output, you can see only <b>Field 4</b>, as it was the last thing to be printed on top of all the previous fields.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>Form Feed</h3>

<p>The following example uses form feed after printing each field.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h2>Format Specifier</h2>

<p>As in C-language, AWK also has format specifiers. The AWK version of the printf statement accepts the following conversion specification formats &minus;</p>

<h3>%c</h3>

<p>It prints a single character. If the argument used for <b>%c</b> is numeric, it is treated as a character and printed. Otherwise, the argument is assumed to be a string, and the only first character of that string is printed.</p>

<p><b>Example</b></p>

<p><b>Output</b></p>

<p>On executing this code, you get the following result &minus;</p>

<h3>%d and %i</h3>

<p>It prints only the integer part of a decimal number.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>%e and %E</h3>

<p>It prints a floating point number of the form [-]d.dddddde[+-]dd.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<p>The <b>%E</b> format uses <b>E</b> instead of e.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>%f</h3>

<p>It prints a floating point number of the form [-]ddd.dddddd.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>%g and %G</h3>

<p>Uses %e or %f conversion, whichever is shorter, with non-significant zeros suppressed.</p>

<p><b>Example</b></p>

<p><b>Output</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p>The <b>%G</b> format uses <b>%E</b> instead of %e.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>%o</h3>

<p>It prints an unsigned octal number.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>%u</h3>

<p>It prints an unsigned decimal number.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>%s</h3>

<p>It prints a character string.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>%x and %X</h3>

<p>It prints an unsigned hexadecimal number. The <b>%X</b> format uses uppercase letters instead of lowercase.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<p>Now let use %X and observe the result &minus;</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>%%</h3>

<p>It prints a single <b>%</b> character and no argument is converted.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h2>Optional Parameters with %</h2>

<p>With <b>%</b> we can use following optional parameters &minus;</p>

<h3>Width</h3>

<p>The field is padded to the <b>width</b>. By default, the field is padded with spaces but when 0 flag is used, it is padded with zeroes.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>Leading Zeros</h3>

<p>A leading zero acts as a flag, which indicates that the output should be padded with zeroes instead of spaces. Please note that this flag only has an effect when the field is wider than the value to be printed. The following example describes this &minus;</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>Left Justification</h3>

<p>The expression should be left-justified within its field. When the input-string is less than the number of characters specified, and you want it to be left justified, i.e., by adding spaces to the right, use a minus symbol (â€“) immediately after the % and before the number.</p>

<p>In the following example, output of the AWK command is piped to the cat command to display the END OF LINE($) character.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>Prefix Sign</h3>

<p>It always prefixes numeric values with a sign, even if the value is positive.</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<h3>Hash</h3>

<p>For %o, it supplies a leading zero. For %x and %X, it supplies a leading 0x or 0X respectively, only if the result is non-zero. For %e, %E, %f, and %F, the result always contains a decimal point. For %g and %G, trailing zeros are not removed from the result. The following example describes this &minus;</p>

<p><b>Example</b></p>

<p>On executing this code, you get the following result &minus;</p>

<p><b>Output</b></p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
[jeryy]$ sudo apt-get update
[jeryy]$ sudo apt-get install gawk
</pre>
<p>Similarly, to install AWK on RPM based GNU/Linux, use Yellowdog Updator Modifier <b>yum</b> package manager as follows &minus;</p>
<pre class="prettyprint notranslate">
[root]# yum install gawk
</pre>
<p>After installation, ensure that AWK is accessible via command line.</p>
<pre class="prettyprint notranslate">
[jerry]$ which awk
</pre>
<p>On executing the above code, you get the following result &minus;</p>
<pre class="result notranslate">
/usr/bin/awk
</pre>
<h2>Installation from Source Code</h2>
<p>As GNU AWK is a part of the GNU project, its source code is available for free download. We have already seen how to install AWK using package manager. Let us now understand how to install AWK from its source code.</p>
<p>The following installation is applicable to any GNU/Linux software, and for most other freely-available programs as well. Here are the installation steps &minus;</p>
<p><b>Step 1</b> &minus; Download the source code from an authentic place. The command-line utility <b>wget</b> serves this purpose.</p>
<pre class="prettyprint notranslate">
[jerry]$ wget http://ftp.gnu.org/gnu/gawk/gawk-4.1.1.tar.xz
</pre>
<p><b>Step 2</b> &minus; Decompress and extract the downloaded source code.</p>
<pre class="prettyprint notranslate">
[jerry]$ tar xvf gawk-4.1.1.tar.xz
</pre>
<p><b>Step 3</b> &minus; Change into the directory and run configure.</p>
<pre class="prettyprint notranslate">
[jerry]$ ./configure
</pre>
<p><b>Step 4</b> &minus; Upon successful completion, the <b>configure</b> generates Makefile. To compile the source code, issue a <b>make</b> command.</p>
<pre class="prettyprint notranslate">
[jerry]$ make
</pre>
<p><b>Step 5</b> &minus; You can run the test suite to ensure the build is clean. This is an optional step.</p>
<pre class="prettyprint notranslate">
[jerry]$ make check
</pre>
<p><b>Step 6</b> &minus; Finally, install AWK. Make sure you have super-user privileges.</p>
<pre class="prettyprint notranslate">
[jerry]$ sudo make install
</pre>
<p>That is it! You have successfully compiled and installed AWK. Verify it by executing the <b>awk</b> command as follows &minus;</p>
<pre class="prettyprint notranslate">
[jerry]$ which awk
</pre>
<p>On executing this code, you get the following result &minus;</p>
<pre class="result notranslate">
/usr/bin/awk
</pre>
<h1>AWK - Workflow</h1>
<p>To become an expert AWK programmer, you need to know its internals. AWK follows a simple workflow &minus; Read, Execute, and Repeat. The following diagram depicts the workflow of AWK &minus;</p>
<img src="/awk/images/awk_workflow.jpg" alt="AWK Workflow" />
<h3>Read</h3>
<p>AWK reads a line from the input stream (file, pipe, or stdin) and stores it in memory.</p>
<h3>Execute</h3>
<p>All AWK commands are applied sequentially on the input. By default AWK execute commands on every line. We can restrict this by providing patterns.</p>
<h3>Repeat</h3>
<p>This process repeats until the file reaches its end.</p>
<h2>Program Structure</h2>
<p>Let us now understand the program structure of AWK.</p>
<h3>BEGIN block</h3>
<p>The syntax of the BEGIN block is as follows &minus;</p>
<p><b>Syntax</b></p>
<pre class="result notranslate">
BEGIN {awk-commands}
</pre>
<p>The BEGIN block gets executed at program start-up. It executes only once. This is good place to initialize variables. BEGIN is an AWK keyword and hence it must be in upper-case. Please note that this block is optional.</p>
<h3>Body Block</h3>
<p>The syntax of the body block is as follows &minus;</p>
<p><b>Syntax</b></p>
<pre class="result notranslate">
/pattern/ {awk-commands}
</pre>
<p>The body block applies AWK commands on every input line. By default, AWK executes commands on every line. We can restrict this by providing patterns. Note that there are no keywords for the Body block.</p>
<h3>END Block</h3>
<p>The syntax of the END block is as follows &minus;</p>
<p><b>Syntax</b></p>
<pre class="result notranslate">
END {awk-commands}
</pre>
<p>The END block executes at the end of the program. END is an AWK keyword and hence it must be in upper-case. Please note that this block is optional.</p>
<p>Let us create a file <b>marks.txt</b> which contains the serial number, name of the student, subject name, and number of marks obtained.</p>
<pre class="result notranslate">
1)  Amit    Physics  80
2)  Rahul   Maths    90
3)  Shyam   Biology  87
4)  Kedar   English  85
5)  Hari    History  89
</pre>
<p>Let us now display the file contents with header by using AWK script.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN{printf "Sr No\tName\tSub\tMarks\n"} {print}' marks.txt
</pre>
<p>When this code is executed, it produces the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Sr No Name Sub Marks
1) Amit Physics 80
2) Rahul Maths 90
3) Shyam Biology 87
4) Kedar English 85
5) Hari History 89
</pre>
<p>At the start, AWK prints the header from the BEGIN block. Then in the body block, it reads a line from a file and executes AWK's print command which just prints the contents on the standard output stream. This process repeats until file reaches the end.</p>
<h1>AWK - Basic Syntax</h1>
<p>AWK is simple to use. We can provide AWK commands either directly from the command line or in the form of a text file containing AWK commands.</p>
<h2>AWK Command Line</h2>
<p>We can specify an AWK command within single quotes at command line as shown &minus;</p>
<pre class="result notranslate">
awk [options] file ...
</pre>
<h3>Example</h3>
<p>Consider a text file <b>marks.txt</b> with the following content &minus;</p>
<pre class="result notranslate">
1) Amit     Physics    80
2) Rahul    Maths      90
3) Shyam    Biology    87
4) Kedar    English    85
5) Hari     History    89
</pre>
<p>Let us display the complete content of the file using AWK as follows &minus;</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk '{print}' marks.txt 
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
1) Amit     Physics    80
2) Rahul    Maths      90
3) Shyam    Biology    87
4) Kedar    English    85
5) Hari     History    89
</pre>
<h2>AWK Program File</h2>
<p>We can provide AWK commands in a script file as shown &minus;</p>
<pre class="result notranslate">
awk [options] -f file ....
</pre>
<p>First, create a text file <b>command.awk</b> containing the AWK command as shown below &minus;</p>
<pre class="result notranslate">
{print}
</pre>
<p>Now we can instruct the AWK to read commands from the text file and perform the action. Here, we achieve the same result as shown in the above example.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk -f command.awk marks.txt
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
1) Amit  Physics 80
2) Rahul Maths   90
3) Shyam Biology 87
4) Kedar English 85
5) Hari  History 89
</pre>
<h2>AWK Standard Options</h2>
<p>AWK supports the following standard options which can be provided from the command line.</p>
<h3>The -v option</h3>
<p>This option assigns a value to a variable. It allows assignment before the program execution. The following example describes the usage of the -v option.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk -v name=Jerry 'BEGIN{printf "Name = %s\n", name}'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Name = Jerry
</pre>
<h3>The --dump-variables[=file] option</h3>
<p>It prints a sorted list of global variables and their final values to file. The default file is <b>awkvars.out</b>.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk --dump-variables ''
[jerry]$ cat awkvars.out 
</pre>
<p>On executing the above code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
ARGC: 1
ARGIND: 0
ARGV: array, 1 elements
BINMODE: 0
CONVFMT: "%.6g"
ERRNO: ""
FIELDWIDTHS: ""
FILENAME: ""
FNR: 0
FPAT: "[^[:space:]]+"
FS: " "
IGNORECASE: 0
LINT: 0
NF: 0
NR: 0
OFMT: "%.6g"
OFS: " "
ORS: "\n"
RLENGTH: 0
RS: "\n"
RSTART: 0
RT: ""
SUBSEP: "\034"
TEXTDOMAIN: "messages"
</pre>
<h3>The --help option</h3>
<p>This option prints the help message on standard output.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk --help
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Usage: awk [POSIX or GNU style options] -f progfile [--] file ...
Usage: awk [POSIX or GNU style options] [--] 'program' file ...
POSIX options : GNU long options: (standard)
   -f progfile                --file=progfile
   -F fs                      --field-separator=fs
   -v var=val                 --assign=var=val
Short options : GNU long options: (extensions)
   -b                         --characters-as-bytes
   -c                         --traditional
   -C                         --copyright
   -d[file]                   --dump-variables[=file]
   -e 'program-text'          --source='program-text'
   -E file                    --exec=file
   -g                         --gen-pot
   -h                         --help
   -L [fatal]                 --lint[=fatal]
   -n                         --non-decimal-data
   -N                         --use-lc-numeric
   -O                         --optimize
   -p[file]                   --profile[=file]
   -P                         --posix
   -r                         --re-interval
   -S                         --sandbox
   -t                         --lint-old
   -V                         --version
</pre>
<h3>The --lint[=fatal] option</h3>
<p>This option enables checking of non-portable or dubious constructs. When an argument <b>fatal</b> is provided, it treats warning messages as errors. The following example demonstrates this &minus;</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk --lint '' /bin/ls
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
awk: cmd. line:1: warning: empty program text on command line
awk: cmd. line:1: warning: source file does not end in newline
awk: warning: no program text at all!
</pre>
<h3>The --posix option</h3>
<p>This option turns on strict POSIX compatibility, in which all common and gawk-specific extensions are disabled.</p>
<h3>The --profile[=file] option</h3>
<p>This option generates a pretty-printed version of the program in file. Default file is <b>awkprof.out</b>. Below simple example illustrates this &minus;</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk --profile 'BEGIN{printf"---|Header|--\n"} {print} 
END{printf"---|Footer|---\n"}' marks.txt &gt; /dev/null 
[jerry]$ cat awkprof.out
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
# gawk profile, created Sun Oct 26 19:50:48 2014

   # BEGIN block(s)

   BEGIN {
      printf "---|Header|--\n"
   }

   # Rule(s) {
      print $0
   }

   # END block(s)

   END {
      printf "---|Footer|---\n"
   }
</pre>
<h3>The --traditional option</h3>
<p>This option disables all gawk-specific extensions.</p>
<h3>The --version option</h3>
<p>This option displays the version information of the AWK program.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk --version
</pre>
<p>When this code is executed, it produces the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
GNU Awk 4.0.1
Copyright (C) 1989, 1991-2012 Free Software Foundation.
</pre>
<h1>AWK - Basic Examples</h1>
<p>This chapter describes several useful AWK commands and their appropriate examples. Consider a text file <b>marks.txt</b> to be processed with the following content &minus;</p>
<pre class="result notranslate">
1) Amit     Physics   80
2) Rahul    Maths     90
3) Shyam    Biology   87
4) Kedar    English   85
5) Hari     History   89
</pre>
<h2>Printing Column or Field</h2>
<p>You can instruct AWK to print only certain columns from the input field. The following example demonstrates this &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ awk '{print $3 "\t" $4}' marks.txt
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
Physics   80
Maths     90
Biology   87
English   85
History   89
</pre>
<p>In the file <b>marks.txt</b>, the third column contains the subject name and the fourth column contains the marks obtained in a particular subject. Let us print these two columns using AWK print command. In the above example, <b>$3 and $4</b> represent the third and the fourth fields respectively from the input record.</p>
<h2>Printing All Lines</h2>
<p>By default, AWK prints all the lines that match pattern.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ awk '/a/ {print $0}' marks.txt
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
2) Rahul    Maths     90
3) Shyam    Biology   87
4) Kedar    English   85
5) Hari     History   89
</pre>
<p>In the above example, we are searching form pattern <b>a</b>. When a pattern match succeeds, it executes a command from the body block. In the absence of a body block &minus; default action is taken which is print the record. Hence, the following command produces the same result &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ awk '/a/' marks.txt
</pre>
<h2>Printing Columns by Pattern</h2>
<p>When a pattern match succeeds, AWK prints the entire record by default. But you can instruct AWK to print only certain fields. For instance, the following example prints the third and fourth field when a pattern match succeeds.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ awk '/a/ {print $3 "\t" $4}' marks.txt
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
Maths    90
Biology  87
English  85
History  89
</pre>
<h2>Printing Column in Any Order</h2>
<p>You can print columns in any order. For instance, the following example prints the fourth column followed by the third column.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ awk '/a/ {print $4 "\t" $3}' marks.txt
</pre>
<p>On executing the above code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
90   Maths
87   Biology
85   English
89   History
</pre>
<h2>Counting and Printing Matched Pattern</h2>
<p>Let us see an example where you can count and print the number of lines for which a pattern match succeeded.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ awk '/a/{++cnt} END {print "Count = ", cnt}' marks.txt
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
Count = 4
</pre>
<p>In this example, we increment the value of counter when a pattern match succeeds and we print this value in the END block. Note that unlike other programming languages, there is no need to declare a variable before using it.</p>
<h2>Printing Lines with More than 18 Characters</h2>
<p>Let us print only those lines that contain more than 18 characters.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ awk 'length($0) &gt; 18' marks.txt
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
3) Shyam   Biology   87
4) Kedar   English   85
</pre>
<p>AWK provides a built-in <b>length</b>  function that returns the length of the string. <b>$0</b> variable stores the entire line and in the absence of a body block, default action is taken, i.e., the print action. Hence, if a line has more than 18 characters, then the comparison results true and the line gets printed.</p>
<h1>AWK - Built-in Variables</h1>
<p>AWK provides several built-in variables. They play an important role while writing AWK scripts. This chapter demonstrates the usage of built-in variables.</p>
<h2>Standard AWK variables</h2>
<p>The standard AWK variables are discussed below.</p>
<h3>ARGC</h3>
<p>It implies the number of arguments provided at the command line.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN {print "Arguments =", ARGC}' One Two Three Four
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Arguments = 5
</pre>
<p>But why AWK shows 5 when you passed only 4 arguments? Just check the following example to clear your doubt.</p>
<h3>ARGV</h3>
<p>It is an array that stores the command-line arguments. The array's valid index ranges from 0 to ARGC-1.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { 
   for (i = 0; i &lt; ARGC - 1; ++i) { 
      printf "ARGV[%d] = %s\n", i, ARGV[i] 
   } 
}' one two three four
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
ARGV[0] = awk
ARGV[1] = one
ARGV[2] = two
ARGV[3] = three
</pre>
<h3>CONVFMT</h3>
<p>It represents the conversion format for numbers. Its default value is <b>%.6g</b>.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { print "Conversion Format =", CONVFMT }'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Conversion Format = %.6g
</pre>
<h3>ENVIRON</h3>
<p>It is an associative array of environment variables.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { print ENVIRON["USER"] }'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
jerry
</pre>
<p>To find names of other environment variables, use <b>env</b> command.</p>
<h3>FILENAME</h3>
<p>It represents the current file name.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'END {print FILENAME}' marks.txt
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
marks.txt
</pre>
<p>Please note that FILENAME is undefined in the BEGIN block.</p>
<h3>FS</h3>
<p>It represents the (input) field separator and its default value is space. You can also change this by using <b>-F</b> command line option.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN {print "FS = " FS}' | cat -vte
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
FS =  $
</pre>
<h3>NF</h3>
<p>It represents the number of fields in the current record. For instance, the following example prints only those lines that contain more than two fields.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ echo -e "One Two\nOne Two Three\nOne Two Three Four" | awk 'NF &gt; 2'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
One Two Three
One Two Three Four
</pre>
<h3>NR</h3>
<p>It represents the number of the current record. For instance, the following example prints the record if the current record contains less than three fields.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ echo -e "One Two\nOne Two Three\nOne Two Three Four" | awk 'NR &lt; 3'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
One Two
One Two Three
</pre>
<h3>FNR</h3>
<p>It is similar to NR, but relative to the current file. It is useful when AWK is operating on multiple files. Value of FNR resets with new file.</p>
<h3>OFMT</h3>
<p>It represents the output format number and its default value is <b>%.6g</b>.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN {print "OFMT = " OFMT}'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
OFMT = %.6g
</pre>
<h3>OFS</h3>
<p>It represents the output field separator and its default value is space.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN {print "OFS = " OFS}' | cat -vte
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
OFS =  $
</pre>
<h3>ORS</h3>
<p>It represents the output record separator and its default value is newline.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN {print "ORS = " ORS}' | cat -vte
</pre>
<p>On executing the above code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
ORS = $
$
</pre>
<h3>RLENGTH</h3>
<p>It represents the length of the string matched by <b>match</b> function. AWK's match function searches for a given string in the input-string.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { if (match("One Two Three", "re")) { print RLENGTH } }'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
2
</pre>
<h3>RS</h3>
<p>It represents (input) record separator and its default value is newline.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN {print "RS = " RS}' | cat -vte
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
RS = $
$
</pre>
<h3>RSTART</h3>
<p>It represents the first position in the string matched by <b>match</b> function.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { if (match("One Two Three", "Thre")) { print RSTART } }'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
9
</pre>
<h3>SUBSEP</h3>
<p>It represents the separator character for array subscripts and its default value is <b>\034</b>.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { print "SUBSEP = " SUBSEP }' | cat -vte
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
SUBSEP = ^\$
</pre>
<h3>$0</h3>
<p>It represents the entire input record.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk '{print $0}' marks.txt
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
1) Amit     Physics   80
2) Rahul    Maths     90
3) Shyam    Biology   87
4) Kedar    English   85
5) Hari     History   89
</pre>
<h3>$n</h3>
<p>It represents the n<sup>th</sup> field in the current record where the fields are separated by FS.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk '{print $3 "\t" $4}' marks.txt
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Physics   80
Maths     90
Biology   87
English   85
History   89
</pre>
<h2>GNU AWK Specific Variables</h2>
<p>GNU AWK specific variables are as follows &minus;</p>
<h3>ARGIND</h3>
<p>It represents the index in ARGV of the current file being processed.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk '{ 
   print "ARGIND   = ", ARGIND; print "Filename = ", ARGV[ARGIND] 
}' junk1 junk2 junk3
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
ARGIND   =  1
Filename =  junk1
ARGIND   =  2
Filename =  junk2
ARGIND   =  3
Filename =  junk3
</pre>
<h3>BINMODE</h3>
<p>It is used to specify binary mode for all file I/O on non-POSIX systems. Numeric values of 1, 2, or 3 specify that input files, output files, or all files, respectively, should use binary I/O. String values of <b>r</b> or <b>w</b> specify that input files or output files, respectively, should use binary I/O. String values of <b>rw</b> or <b>wr</b> specify that all files should use binary I/O.</p>
<h3>ERRNO</h3>
<p>A string indicates an error when a redirection fails for <b>getline</b> or if <b>close</b> call fails.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { ret = getline &lt; "junk.txt"; if (ret == -1) print "Error:", ERRNO }'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Error: No such file or directory
</pre>
<h3>FIELDWIDTHS</h3>
<p>A space separated list of field widths variable is set, GAWK parses the input into fields of fixed width, instead of using the value of the FS variable as the field separator.</p>
<h3>IGNORECASE</h3>
<p>When this variable is set, GAWK becomes case-insensitive. The following example demonstrates this &minus;</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN{IGNORECASE = 1} /amit/' marks.txt
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
1) Amit  Physics   80
</pre>
<h3>LINT</h3>
<p>It provides dynamic control of the <b>--lint</b> option from the GAWK program. When this variable is set, GAWK prints lint warnings. When assigned the string value fatal, lint warnings become fatal errors, exactly like <b>--lint=fatal</b>.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN {LINT = 1; a}'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
awk: cmd. line:1: warning: reference to uninitialized variable `a'
awk: cmd. line:1: warning: statement has no effect
</pre>
<h3>PROCINFO</h3>
<p>This is an associative array containing information about the process, such as real and effective UID numbers, process ID number, and so on.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { print PROCINFO["pid"] }'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
4316
</pre>
<h3>TEXTDOMAIN</h3>
<p>It represents the text domain of the AWK program. It is used to find the localized translations for the program's strings.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { print TEXTDOMAIN }'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
messages
</pre>
<p>The above output shows English text due to <b>en_IN</b> locale</p>
<h1>AWK - Operators</h1>
<p>Like other programming languages, AWK also provides a large set of operators. This chapter explains AWK operators with suitable examples.</p>
<table class="table table-bordered">
<tr>
<th>S.No.</th>
<th style="text-align:center;">Operators &amp; Description</th>
</tr>
<tr>
<td>1</td>
<td><a href="/awk/awk_arithmetic_operators.htm">Arithmetic Operators</a>
<p>AWK supports the following arithmetic operators.</p></td>
</tr>
<tr>
<td>2</td>
<td><a href="/awk/awk_increment_decrement_operators.htm">Increment and Decrement Operators</a>
<p>AWK supports the following increment and decrement operators.</p></td>
</tr>
<tr>
<td>3</td>
<td><a href="/awk/awk_assignment_operators.htm">Assignment Operators</a>
<p>AWK supports the following assignment operators.</p></td>
</tr>
<tr>
<td>4</td>
<td><a href="/awk/awk_relational_operators.htm">Relational Operators</a>
<p>AWK supports the following relational operators.</p></td>
</tr>
<tr>
<td>5</td>
<td><a href="/awk/awk_logical_operators.htm">Logical Operators</a>
<p>AWK supports the following logical operators.</p></td>
</tr>
<tr>
<td>6</td>
<td><a href="/awk/awk_ternary_operators.htm">Ternary Operator</a>
<p>We can easily implement a condition expression using ternary operator.</p></td>
</tr>
<tr>
<td>7</td>
<td><a href="/awk/awk_unary_operators.htm">Unary Operators</a>
<p>AWK supports the following unary operators.</p></td>
</tr>
<tr>
<td>8</td>
<td><a href="/awk/awk_exponential_operators.htm">Exponential Operators</a>
<p>There are two formats of exponential operators.</p></td>
</tr>
<tr>
<td>9</td>
<td><a href="/awk/awk_string_concatenation_operator.htm">String Concatenation Operator</a>
<p>Space is a string concatenation operator that merges two strings.</p></td>
</tr>
<tr>
<td>10</td>
<td><a href="/awk/awk_array_membership_operator.htm">Array Membership Operator</a>
<p>It is represented by <b>in</b>. It is used while accessing array elements.</p></td>
</tr>
<tr>
<td>11</td>
<td><a href="/awk/awk_regular_expression_operators.htm">Regular Expression Operators</a>
<p>This example explains the two forms of regular expressions operators.</p></td>
</tr>
</table>
<h1>AWK - Regular Expressions</h1>
<p>AWK is very powerful and efficient in handling regular expressions. A number of complex tasks can be solved with simple regular expressions. Any command-line expert knows the power of regular expressions.</p>
<p>This chapter covers standard regular expressions with suitable examples.</p>
<h2>Dot</h2>
<p>It matches any single character except the end of line character. For instance, the following example matches <b>fin, fun, fan</b> etc.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ echo -e "cat\nbat\nfun\nfin\nfan" | awk '/f.n/'
</pre>
<p>On executing the above code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
fun
fin
fan
</pre>
<h2>Start of line</h2>
<p>It matches the start of line. For instance, the following example prints all the lines that start with pattern <b>The</b>.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ echo -e "This\nThat\nThere\nTheir\nthese" | awk '/^The/'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
There
Their
</pre>
<h2>End of line</h2>
<p>It matches the end of line. For instance, the following example prints the lines that end with the letter <b>n</b>.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ echo -e "knife\nknow\nfun\nfin\nfan\nnine" | awk '/n$/'
</pre>
<h3>Output</h3>
<p>On executing this code, you get the following result &minus;</p>
<pre class="result notranslate">
fun
fin
fan
</pre>
<h2>Match character set</h2>
<p>It is used to match only one out of several characters. For instance, the following example matches pattern <b>Call</b> and <b>Tall</b> but not <b>Ball</b>.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ echo -e "Call\nTall\nBall" | awk '/[CT]all/'
</pre>
<h3>Output</h3>
<p>On executing this code, you get the following result &minus;</p>
<pre class="result notranslate">
Call
Tall
</pre>
<h2>Exclusive set</h2>
<p>In exclusive set, the carat negates the set of characters in the square brackets. For instance, the following example prints only <b>Ball</b>.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ echo -e "Call\nTall\nBall" | awk '/[^CT]all/'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
Ball
</pre>
<h2>Alteration</h2>
<p>A vertical bar allows regular expressions to be logically ORed. For instance, the following example prints <b>Ball</b> and <b>Call</b>.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ echo -e "Call\nTall\nBall\nSmall\nShall" | awk '/Call|Ball/'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
Call
Ball
</pre>
<h2>Zero or One Occurrence</h2>
<p>It matches zero or one occurrence of the preceding character. For instance, the following example matches <b>Colour</b> as well as <b>Color</b>. We have made <b>u</b> as an optional character by using <b>?</b>.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ echo -e "Colour\nColor" | awk '/Colou?r/'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
Colour
Color
</pre>
<h2>Zero or More Occurrence</h2>
<p>It matches zero or more occurrences of the preceding character. For instance, the following example matches <b>ca, cat, catt,</b> and so on.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ echo -e "ca\ncat\ncatt" | awk '/cat*/'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
ca
cat
catt
</pre>
<h2>One or More Occurrence</h2>
<p>It matches one or more occurrence of the preceding character. For instance below example matches one or more occurrences of the <b>2</b>.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ echo -e "111\n22\n123\n234\n456\n222"  | awk '/2+/'
</pre>
<p>On executing the above code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
22
123
234
222
</pre>
<h2>Grouping</h2>
<p><b>Parentheses ()</b> are used for grouping and the character | is used for alternatives. For instance, the following regular expression matches the lines containing either <b>Apple Juice or Apple Cake</b>.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ echo -e "Apple Juice\nApple Pie\nApple Tart\nApple Cake" | awk 
   '/Apple (Juice|Cake)/'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
Apple Juice
Apple Cake
</pre>
<h1>AWK - Arrays</h1>
<p>AWK has associative arrays and one of the best thing about it is â€“ the indexes need not to be continuous set of number; you can use either string or number as an array index. Also, there is no need to declare the size of an array in advance â€“ arrays can expand/shrink at runtime.</p>
<p>Its syntax is as follows &minus;</p>
<h3>Syntax</h3>
<pre class="result notranslate">
array_name[index] = value
</pre>
<p>Where <b>array_name</b> is the name of array, <b>index</b> is the array index, and <b>value</b> is any value assigning to the element of the array.</p>
<h2>Creating Array</h2>
<p>To gain more insight on array, let us create and access the elements of an array.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN {
   fruits["mango"] = "yellow";
   fruits["orange"] = "orange"
   print fruits["orange"] "\n" fruits["mango"]
}'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
orange
yellow
</pre>
<p>In the above example, we declare the array as <b>fruits</b> whose index is fruit name and the value is the color of the fruit. To access array elements, we use <b>array_name[index]</b> format.</p>
<h2>Deleting Array Elements</h2>
<p>For insertion, we used assignment operator. Similarly, we can use <b>delete</b> statement to remove an element from the array. The syntax of delete statement is as follows &minus;</p>
<h3>Syntax</h3>
<pre class="result notranslate">
delete array_name[index]
</pre>
<p>The following example deletes the element <b>orange</b>. Hence the command does not show any output.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN {
   fruits["mango"] = "yellow";
   fruits["orange"] = "orange";
   delete fruits["orange"];
   print fruits["orange"]
}'
</pre>
<h2>Multi-Dimensional arrays</h2>
<p>AWK only supports one-dimensional arrays. But you can easily simulate a multi-dimensional array using the one-dimensional array itself.</p>
<p>For instance, given below is a 3x3 three-dimensional array &minus;</p>
<pre class="result notranslate">
100   200   300
400   500   600
700   800   900
</pre>
<p>In the above example, array[0][0] stores 100, array[0][1] stores 200, and so on. To store 100 at array location [0][0], we can use the following syntax &minus;</p>
<h3>Syntax</h3>
<pre class="result notranslate">
array["0,0"] = 100
</pre>
<p>Though we gave <b>0,0</b> as index, these are not two indexes. In reality, it is just one index with the string <b>0,0</b>.</p>
<p>The following example simulates a 2-D array &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN {
   array["0,0"] = 100;
   array["0,1"] = 200;
   array["0,2"] = 300;
   array["1,0"] = 400;
   array["1,1"] = 500;
   array["1,2"] = 600;

   # print array elements
   print "array[0,0] = " array["0,0"];
   print "array[0,1] = " array["0,1"];
   print "array[0,2] = " array["0,2"];
   print "array[1,0] = " array["1,0"];
   print "array[1,1] = " array["1,1"];
   print "array[1,2] = " array["1,2"];
}'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
array[0,0] = 100
array[0,1] = 200
array[0,2] = 300
array[1,0] = 400
array[1,1] = 500
array[1,2] = 600
</pre>
<p>You can also perform a variety of operations on an array such as sorting its elements/indexes. For that purpose, you can use <b>assort</b> and <b>asorti</b> functions</p>
<h1>AWK - Control Flow</h1>
<p>Like other programming languages, AWK provides conditional statements to control the flow of a program. This chapter explains AWK's control statements with suitable examples.</p>
<h2>If statement</h2>
<p>It simply tests the condition and performs certain actions depending upon the condition. Given below is the syntax of <b>if</b> statement &minus;</p>
<h3>Syntax</h3>
<pre class="result notranslate">
if (condition)
   action
</pre>
<p>We can also use a pair of curly braces as given below to execute multiple actions &minus;</p>
<h3>Syntax</h3>
<pre class="result notranslate">
if (condition) {
   action-1
   action-1
   .
   .
   action-n
}
</pre>
<p>For instance, the following example checks whether a number is even or not &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN {num = 10; if (num % 2 == 0) printf "%d is even number.\n", num }'
</pre>
<p>On executing the above code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
10 is even number.
</pre>
<h2>If Else Statement</h2>
<p>In <b>if-else</b> syntax, we can provide a list of actions to be performed when a condition becomes false.</p>
<p>The syntax of <b>if-else</b> statement is as follows &minus;</p>
<h3>Syntax</h3>
<pre class="result notranslate">
if (condition)
   action-1
else
   action-2
</pre>
<p>In the above syntax, action-1 is performed when the condition evaluates to true and action-2 is performed when the condition evaluates to false. For instance, the following example checks whether a number is even or not &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN {
   num = 11; if (num % 2 == 0) printf "%d is even number.\n", num; 
      else printf "%d is odd number.\n", num 
}'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
11 is odd number.
</pre>
<h2>If-Else-If Ladder</h2>
<p>We can easily create an <b>if-else-if</b> ladder by using multiple <b>if-else</b> statements. The following example demonstrates this &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN {
   a = 30;
   
   if (a==10)
   print "a = 10";
   else if (a == 20)
   print "a = 20";
   else if (a == 30)
   print "a = 30";
}'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
a = 30
</pre>
<h1>AWK - Loops</h1>
<p>This chapter explains AWK's loops with suitable example. Loops are used to execute a set of actions in a repeated manner. The loop execution continues as long as the loop condition is true.</p>
<h2>For Loop</h2>
<p>The syntax of <b>for</b> loop is &minus;</p>
<h3>Syntax</h3>
<pre class="result notranslate">
for (initialisation; condition; increment/decrement)
   action
</pre>
<p>Initially, the <b>for</b> statement performs initialization action, then it checks the condition. If the condition is true, it executes actions, thereafter it performs increment or decrement operation. The loop execution continues as long as the condition is true. For instance, the following example prints 1 to 5 using <b>for</b> loop &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { for (i = 1; i &lt;= 5; ++i) print i }'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
1
2
3
4
5
</pre>
<h2>While Loop</h2>
<p>The <b>while</b> loop keeps executing the action until a particular logical condition evaluates to true. Here is the syntax of <b>while</b> loop &minus;</p>
<h3>Syntax</h3>
<pre class="result notranslate">
while (condition)
   action
</pre>
<p>AWK first checks the condition; if the condition is true, it executes the action. This process repeats as long as the loop condition evaluates to true. For instance, the following example prints 1 to 5 using <b>while</b> loop &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN {i = 1; while (i &lt; 6) { print i; ++i } }'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
1
2
3
4
5
</pre>
<h2>Do-While Loop</h2>
<p>The <b>do-while</b> loop is similar to the while loop, except that the test condition is evaluated at the end of the loop. Here is the syntax of <b>do-while</b>loop &minus;</p>
<h3>Syntax</h3>
<pre class="result notranslate">
do
   action
while (condition)
</pre>
<p>In a <b>do-while</b> loop, the action statement gets executed at least once even when the condition statement evaluates to false. For instance, the following example prints 1 to 5 numbers using <b>do-while</b> loop &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN {i = 1; do { print i; ++i } while (i &lt; 6) }'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
1
2
3
4
5
</pre>
<h2>Break Statement</h2>
<p>As its name suggests, it is used to end the loop execution. Here is an example which ends the loop when the sum becomes greater than 50.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN {
   sum = 0; for (i = 0; i &lt; 20; ++i) { 
      sum += i; if (sum &gt; 50) break; else print "Sum =", sum 
   } 
}'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
Sum = 0
Sum = 1
Sum = 3
Sum = 6
Sum = 10
Sum = 15
Sum = 21
Sum = 28
Sum = 36
Sum = 45
</pre>
<h2>Continue Statement</h2>
<p>The <b>continue</b> statement is used inside a loop to skip to the next iteration of the loop. It is useful when you wish to skip the processing of some data inside the loop. For instance, the following example uses <b>continue</b> statement to print the even numbers between 1 to 20.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN {
   for (i = 1; i &lt;= 20; ++i) {
      if (i % 2 == 0) print i ; else continue
   } 
}'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
2
4
6
8
10
12
14
16
18
20
</pre>
<h2>Exit Statement</h2>
<p>It is used to stop the execution of the script. It accepts an integer as an argument which is the exit status code for AWK process. If no argument is supplied, <b>exit</b> returns status zero. Here is an example that stops the execution when the sum becomes greater than 50.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN {
   sum = 0; for (i = 0; i &lt; 20; ++i) {
      sum += i; if (sum &gt; 50) exit(10); else print "Sum =", sum 
   } 
}'
</pre>
<h3>Output</h3>
<p>On executing this code, you get the following result &minus;</p>
<pre class="result notranslate">
Sum = 0
Sum = 1
Sum = 3
Sum = 6
Sum = 10
Sum = 15
Sum = 21
Sum = 28
Sum = 36
Sum = 45
</pre>
<p>Let us check the return status of the script.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ echo $?
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
10
</pre>
<h1>AWK - Built-in Functions</h1>
<p>AWK has a number of functions built into it that are always available to the programmer. This chapter describes Arithmetic, String, Time, Bit manipulation, and other miscellaneous functions with suitable examples.</p>
<table class="table table-bordered">
<tr>
<th>S.No.</th>
<th style="text-align:center;">Built in functions &amp; Description</th>
</tr>
<tr>
<td>1</td>
<td><a href="/awk/awk_arithmetic_functions.htm">Arithmetic Functions</a>
<p>AWK has the following built-in arithmetic functions.</p></td>
</tr>
<tr>
<td>2</td>
<td><a href="/awk/awk_string_functions.htm">String Functions</a>
<p>AWK has the following built-in String functions.</p></td>
</tr>
<tr>
<td>3</td>
<td><a href="/awk/awk_time_functions.htm">Time Functions</a>
<p>AWK has the following built-in time functions.</p></td>
</tr>
<tr>
<td>4</td>
<td><a href="/awk/awk_bit_manipulation_functions.htm">Bit Manipulation Functions</a>
<p>AWK has the following built-in bit manipulation functions.</p></td>
</tr>
<tr>
<td>5</td>
<td><a href="/awk/awk_miscellaneous_functions.htm">Miscellaneous Functions</a>
<p>AWK has the following miscellaneous functions.</p></td>
</tr>
</table>
<h1>AWK - User Defined Functions</h1>
<p>Functions are basic building blocks of a program. AWK allows us to define our own functions. A large program can be divided into functions and each function can be written/tested independently. It provides re-usability of code.</p>
<p>Given below is the general format of a user-defined function &minus;</p>
<h3>Syntax</h3>
<pre class="result notranslate">
function function_name(argument1, argument2, ...) { 
   function body
}
</pre>
<p>In this syntax, the<b> function_name</b> is the name of the user-defined function. Function name should begin with a letter and the rest of the characters can be any combination of numbers, alphabetic characters, or underscore. AWK's reserve words cannot be used as function names.</p>
<p>Functions can accept multiple arguments separated by comma. Arguments are not mandatory. You can also create a user-defined function without any argument.</p>
<p><b>function body</b> consists of one or more AWK statements.</p>
<p>Let us write two functions that calculate the minimum and the maximum number and call these functions from another function called <b>main</b>. The <b>functions.awk</b> file contains &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
# Returns minimum number
function find_min(num1, num2){
   if (num1 &lt; num2)
   return num1
   return num2
}
# Returns maximum number
function find_max(num1, num2){
   if (num1 &gt; num2)
   return num1
   return num2
}
# Main function
function main(num1, num2){
   # Find minimum number
   result = find_min(10, 20)
   print "Minimum =", result
  
   # Find maximum number
   result = find_max(10, 20)
   print "Maximum =", result
}
# Script execution starts here
BEGIN {
   main(10, 20)
}
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
Minimum = 10
Maximum = 20
</pre>
<h1>AWK - Output Redirection</h1>
<p>So far, we displayed data on standard output stream. We can also redirect data to a file. A redirection appears after the <b>print</b> or <b>printf</b> statement. Redirections in AWK are written just like redirection in shell commands, except that they are written inside the AWK program. This chapter explains redirection with suitable examples.</p>
<h2>Redirection Operator</h2>
<p>The syntax of the redirection operator is &minus;</p>
<h3>Syntax</h3>
<pre class="result notranslate">
print DATA &gt; output-file
</pre>
<p>It writes the data into the <b>output-file</b>. If the output-file does not exist, then it creates one. When this type of redirection is used, the output-file is erased before the first output is written to it. Subsequent write operations to the same output-file do not erase the output-file, but append to it. For instance, the following example writes <b>Hello, World !!!</b> to the file.</p>
<p>Let us create a file with some text data.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ echo "Old data" &gt; /tmp/message.txt
[jerry]$ cat /tmp/message.txt
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
Old data
</pre>
<p>Now let us redirect some contents into it using AWK's redirection operator.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { print "Hello, World !!!" &gt; "/tmp/message.txt" }'
[jerry]$ cat /tmp/message.txt
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
Hello, World !!!
</pre>
<h2>Append Operator</h2>
<p>The syntax of append operator is as follows &minus;</p>
<h3>Syntax</h3>
<pre class="result notranslate">
print DATA &gt;&gt; output-file
</pre>
<p>It appends the data into the <b>output-file</b>. If the output-file does not exist, then it creates one. When this type of redirection is used, new contents are appended at the end of file. For instance, the following example appends <b>Hello, World !!!</b> to the file.</p>
<p>Let us create a file with some text data.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ echo "Old data" &gt; /tmp/message.txt 
[jerry]$ cat /tmp/message.txt
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
Old data
</pre>
<p>Now let us append some contents to it using AWK's append operator.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { print "Hello, World !!!" &gt;&gt; "/tmp/message.txt" }'
[jerry]$ cat /tmp/message.txt
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
Old data
Hello, World !!!
</pre>
<h2>Pipe</h2>
<p>It is possible to send output to another program through a pipe instead of using a file. This redirection opens a pipe to command, and writes the values of items through this pipe to another process to execute the command. The redirection argument command is actually an AWK expression. Here is the syntax of pipe &minus;</p>
<h3>Syntax</h3>
<pre class="result notranslate">
print items | command
</pre>
<p>Let us use <b>tr</b> command to convert lowercase letters to uppercase.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { print "hello, world !!!" | "tr [a-z] [A-Z]" }'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
HELLO, WORLD !!!
</pre>
<h2>Two way communication</h2>
<p>AWK can communicate to an external process using <b>|&amp;</b>, which is two-way communication. For instance, the following example uses <b>tr</b> command to convert lowercase letters to uppercase. Our <b>command.awk</b> file contains &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
BEGIN {
   cmd = "tr [a-z] [A-Z]"
   print "hello, world !!!" |&amp; cmd
   close(cmd, "to")
   
   cmd |&amp; getline out
   print out;
   close(cmd);
}
</pre>
<p>On executing this code, you get the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
HELLO, WORLD !!!
</pre>
<p>Does the script look cryptic? Let us demystify it.</p>
<ul class="list">
<li><p>The first statement, <b>cmd = "tr [a-z] [A-Z]"</b>, is the command to which we establish the two-way communication from AWK.</p></li>
<li><p>The next statement, i.e., the print command provides input to the <b>tr</b> command. Here <b>&amp;|</b> indicates two-way communication.</p></li>
<li><p>The third statement, i.e., <b>close(cmd, "to")</b>, closes the <b>to</b> process after competing its execution.</p></li>
<li><p>The next statement <b>cmd |&amp; getline out</b> stores the <b>output</b> into out variable with the aid of getline function.</p></li>
<li><p>The next print statement prints the output and finally the <b>close</b> function closes the command.</p></li>
</ul>
<h1>AWK - Pretty Printing</h1>
<p>So far we have used AWK's <b>print</b> and <b>printf</b> functions to display data on standard output. But printf is much more powerful than what we have seen before. This function is borrowed from the C language and is very helpful while producing formatted output. Below is the syntax of the printf statement &minus;</p>
<h3>Syntax</h3>
<pre class="result notranslate">
printf fmt, expr-list
</pre>
<p>In the above syntax <b>fmt</b> is a string of format specifications and constants. <b>expr-list</b> is a list of arguments corresponding to format specifiers.</p>
<h2>Escape Sequences</h2>
<p>Similar to any string, format can contain embedded escape sequences. Discussed below are the escape sequences supported by AWK &minus;</p>
<h3>New Line</h3>
<p>The following example prints <b>Hello</b> and <b>World</b> in separate lines using newline character &minus;</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { printf "Hello\nWorld\n" }'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Hello
World
</pre>
<h3>Horizontal Tab</h3>
<p>The following example uses horizontal tab to display different field &minus;</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { printf "Sr No\tName\tSub\tMarks\n" }'
</pre>
<p>On executing the above code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Sr No   Name    Sub Marks
</pre>
<h3>Vertical Tab</h3>
<p>The following example uses vertical tab after each filed &minus;</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { printf "Sr No\vName\vSub\vMarks\n" }'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Sr No
   Name
      Sub
         Marks
</pre>
<h3>Backspace</h3>
<p>The following example prints a backspace after every field except the last one. It erases the last number from the first three fields. For instance, <b>Field 1</b> is displayed as <b>Field</b>, because the last character is erased with backspace. However, the last field <b>Field 4</b> is displayed as it is, as we did not have a <b>\b</b> after <b>Field 4</b>.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { printf "Field 1\bField 2\bField 3\bField 4\n" }'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Field Field Field Field 4
</pre>
<h3>Carriage Return</h3>
<p>In the following example, after printing every field, we do a <b>Carriage Return </b>and print the next value on top of the current printed value. It means, in the final output, you can see only <b>Field 4</b>, as it was the last thing to be printed on top of all the previous fields.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { printf "Field 1\rField 2\rField 3\rField 4\n" }'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Field 4
</pre>
<h3>Form Feed</h3>
<p>The following example uses form feed after printing each field.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { printf "Sr No\fName\fSub\fMarks\n" }'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Sr No
   Name
      Sub
         Marks
</pre>
<h2>Format Specifier</h2>
<p>As in C-language, AWK also has format specifiers. The AWK version of the printf statement accepts the following conversion specification formats &minus;</p>
<h3>%c</h3>
<p>It prints a single character. If the argument used for <b>%c</b> is numeric, it is treated as a character and printed. Otherwise, the argument is assumed to be a string, and the only first character of that string is printed.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { printf "ASCII value 65 = character %c\n", 65 }'
</pre>
<p><b>Output</b></p>
<p>On executing this code, you get the following result &minus;</p>
<pre class="result notranslate">
ASCII value 65 = character A
</pre>
<h3>%d and %i</h3>
<p>It prints only the integer part of a decimal number.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { printf "Percentags = %d\n", 80.66 }'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Percentags = 80
</pre>
<h3>%e and %E</h3>
<p>It prints a floating point number of the form [-]d.dddddde[+-]dd.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { printf "Percentags = %E\n", 80.66 }'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Percentags = 8.066000e+01
</pre>
<p>The <b>%E</b> format uses <b>E</b> instead of e.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { printf "Percentags = %e\n", 80.66 }'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Percentags = 8.066000E+01
</pre>
<h3>%f</h3>
<p>It prints a floating point number of the form [-]ddd.dddddd.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { printf "Percentags = %f\n", 80.66 }'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Percentags = 80.660000
</pre>
<h3>%g and %G</h3>
<p>Uses %e or %f conversion, whichever is shorter, with non-significant zeros suppressed.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { printf "Percentags = %g\n", 80.66 }'
</pre>
<p><b>Output</b></p>
<p>On executing this code, you get the following result &minus;</p>
<pre class="result notranslate">
Percentags = 80.66
</pre>
<p>The <b>%G</b> format uses <b>%E</b> instead of %e.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { printf "Percentags = %G\n", 80.66 }'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Percentags = 80.66
</pre>
<h3>%o</h3>
<p>It prints an unsigned octal number.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { printf "Octal representation of decimal number 10 = %o\n", 10}'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Octal representation of decimal number 10 = 12
</pre>
<h3>%u</h3>
<p>It prints an unsigned decimal number.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { printf "Unsigned 10 = %u\n", 10 }'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Unsigned 10 = 10
</pre>
<h3>%s</h3>
<p>It prints a character string.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { printf "Name = %s\n", "Sherlock Holmes" }'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Name = Sherlock Holmes
</pre>
<h3>%x and %X</h3>
<p>It prints an unsigned hexadecimal number. The <b>%X</b> format uses uppercase letters instead of lowercase.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { 
   printf "Hexadecimal representation of decimal number 15 = %x\n", 15
}'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Hexadecimal representation of decimal number 15 = f
</pre>
<p>Now let use %X and observe the result &minus;</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { 
   printf "Hexadecimal representation of decimal number 15 = %X\n", 15
}'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Hexadecimal representation of decimal number 15 = F
</pre>
<h3>%%</h3>
<p>It prints a single <b>%</b> character and no argument is converted.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { printf "Percentags = %d%%\n", 80.66 }'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Percentags = 80%
</pre>
<h2>Optional Parameters with %</h2>
<p>With <b>%</b> we can use following optional parameters &minus;</p>
<h3>Width</h3>
<p>The field is padded to the <b>width</b>. By default, the field is padded with spaces but when 0 flag is used, it is padded with zeroes.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { 
   num1 = 10; num2 = 20; printf "Num1 = %10d\nNum2 = %10d\n", num1, num2 
}'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Num1 =         10
Num2 =         20
</pre>
<h3>Leading Zeros</h3>
<p>A leading zero acts as a flag, which indicates that the output should be padded with zeroes instead of spaces. Please note that this flag only has an effect when the field is wider than the value to be printed. The following example describes this &minus;</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { 
   num1 = -10; num2 = 20; printf "Num1 = %05d\nNum2 = %05d\n", num1, num2 
}'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Num1 = -0010
Num2 = 00020
</pre>
<h3>Left Justification</h3>
<p>The expression should be left-justified within its field. When the input-string is less than the number of characters specified, and you want it to be left justified, i.e., by adding spaces to the right, use a minus symbol (â€“) immediately after the % and before the number.</p>
<p>In the following example, output of the AWK command is piped to the cat command to display the END OF LINE($) character.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { num = 10; printf "Num = %-5d\n", num }' | cat -vte
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Num = 10   $
</pre>
<h3>Prefix Sign</h3>
<p>It always prefixes numeric values with a sign, even if the value is positive.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { 
   num1 = -10; num2 = 20; printf "Num1 = %+d\nNum2 = %+d\n", num1, num2 
}'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Num1 = -10
Num2 = +20
</pre>
<h3>Hash</h3>
<p>For %o, it supplies a leading zero. For %x and %X, it supplies a leading 0x or 0X respectively, only if the result is non-zero. For %e, %E, %f, and %F, the result always contains a decimal point. For %g and %G, trailing zeros are not removed from the result. The following example describes this &minus;</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
[jerry]$ awk 'BEGIN { 
   printf "Octal representation = %#o\nHexadecimal representaion = %#X\n", 10, 10
}'
</pre>
<p>On executing this code, you get the following result &minus;</p>
<p><b>Output</b></p>
<pre class="result notranslate">
Octal representation = 012
Hexadecimal representation = 0XA
</pre>

<title>AWK Useful Resources</title>

<h1>AWK - Useful Resources</h1>

<p>The following resources contain additional information on AWK. Please use them to get more in-depth knowledge on this.</p>

<h2>Useful Links on AWK</h2>

<p><a rel="nofollow" target="_blank" href="https://en.wikipedia.org/wiki/AWK">AWK Wiki</a> &minus;  Wikipedia Reference for AWK.</p>

<h2>Useful Books on AWK</h2>

<p>To enlist your site on this page, please drop an email to <b>contact@tutorialspoint.com</b></p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Discuss AWK</title>

<h1>Discuss AWK</h1>

<p>This tutorial takes you through AWK, one of the most prominent text-processing utility on GNU/Linux. It is very powerful and uses simple programming language. It can solve complex text processing tasks with a few lines of code. Starting with an overview of AWK, its environment, and workflow, the tutorial proceeds to explain the syntax, variables, operators, arrays, loops, and functions used in AWK. It also covers topics such as output redirection and pretty printing.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

</body></html>