<!DOCTYPE html><html><body><title>Software Engineering Tutorial</title>

<h1>Software Engineering Tutorial</h1>

<p>Software engineering is an engineering branch associated with development of software product using well-defined scientific principles, methods and procedures. The outcome of software engineering is an efficient and reliable software product.</p>

<p>Software project management has wider scope than software engineering process as it involves communication, pre and post delivery support etc.</p>

<p>This tutorial should provide you basic understanding of software product, software design and development process, software project management and design complexities etc. At the end of the tutorial you should be equipped with well understanding of software engineering concepts.</p>

<h1>Audience</h1>

<p>This tutorial is designed for the readers pursuing education in software development domain, Software Testing aspirants and all enthusiastic readers. </p>

<h1>Prerequisites</h1>

<p>This tutorial is designed and developed for absolute beginners. Though, awareness about software systems, software development process and computer fundamentals would be beneficial.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Software Engineering Overview</title>

<h1>Software Engineering Overview</h1>

<p>Let us first understand what software engineering stands for. The term is made of two words, software and engineering.</p>

<p><b>Software </b>is more than just a program code. A program is an executable code, which serves some computational purpose. Software is considered to be collection of executable programming code, associated libraries and  documentations. Software, when made for a specific requirement is called <b>software product.</b></p>

<p><b>Engineering</b> on the other hand, is all about developing products, using well-defined, scientific principles and methods.</p>

<p><b>Software engineering</b> is an engineering branch associated with development of software product using well-defined scientific principles, methods and procedures. The outcome of software engineering is an efficient and reliable software product.</p>

<h2>Definitions</h2>

<p>IEEE defines software engineering as:</p>

<p>(1)&nbsp;The application of a systematic,disciplined,quantifiable approach to the development,operation and maintenance of software; that is, the application of engineering to software.</p>

<p>(2)&nbsp;The study of approaches as in the above statement.</p>

<p>Fritz Bauer, a German computer scientist, defines software engineering as:</p>

<p>Software engineering is the establishment and use of sound engineering principles in order to obtain economically software that is reliable and work efficiently on real machines.</p>

<h2>Software Evolution</h2>

<p>The process of developing a software product using software engineering principles and methods is referred to as <b>software evolution.</b> This includes the initial development of software and its maintenance and updates, till desired software product is developed, which satisfies the expected requirements.</p>

<p>Evolution starts from the requirement gathering process. After which developers create a prototype of the intended software and show it to the users to get their feedback at the early stage of software product development.  The users suggest changes, on which several consecutive updates and maintenance keep on changing too. This process changes to the original software, till the desired software is accomplished.</p>

<p>Even after the user has desired software in hand,  the advancing technology and the changing requirements force the software product to change accordingly. Re-creating software from scratch and to go one-on-one with requirement is not feasible. The only feasible and economical solution is to update the existing software so that it matches the latest  requirements.</p>

<h2>Software Evolution Laws</h2>

<p>Lehman has given laws for software evolution. He divided the software into three different categories:</p>

<h2>E-Type software evolution </h2>

<p>Lehman has given eight laws for E-Type software evolution -  </p>

<h2>Software Paradigms</h2>

<p>Software paradigms refer to the methods and steps, which are taken while designing the software. There are many methods proposed and are in work today, but we need to see where in the software engineering these paradigms stand. These can be combined into various categories, though each of them is contained in one another:</p>

<p>Programming paradigm is a subset of Software design paradigm which is further a subset of Software development paradigm.</p>

<h3>Software Development Paradigm</h3>

<p>This Paradigm is known as software engineering paradigms where all the engineering concepts pertaining to the development of software are applied. It includes various researches and requirement gathering which helps the software product to build. It consists of – </p>

<h3>Software Design Paradigm</h3>

<p>This paradigm is a part of Software Development and includes – </p>

<h3>Programming Paradigm</h3>

<p>This paradigm is related closely to programming aspect of software development. This includes –</p>

<h2>Need of Software Engineering</h2>

<p>The need of software engineering arises because of higher rate of change in user requirements and environment on which the software is working.</p>

<h2>Characteristics of good software</h2>

<p>A software product can be judged  by what it offers and how well it can be used. This software must satisfy on the following grounds:</p>

<p>Well-engineered and crafted software is expected to have the following characteristics:</p>

<h3>Operational</h3>

<p> This tells us how well software works in operations. It can be measured on:</p>

<h3>Transitional</h3>

<p> This aspect is important when the software is moved from one platform to another:</p>

<h3>Maintenance</h3>

<p> This aspect briefs about how well a software has the capabilities to maintain itself in the ever-changing environment:</p>

<p>In short, Software engineering is a branch of computer science, which uses well-defined engineering concepts required to produce efficient, durable, scalable, in-budget and on-time software products.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Software Development Life Cycle</title>

<h1>Software Development Life Cycle</h1>

<p>Software Development Life Cycle, SDLC for short, is a well-defined, structured sequence of stages in software engineering to develop the intended software product. </p>

<h2>SDLC Activities</h2>

<p>SDLC provides a series of steps to be followed to design and develop a software product efficiently. SDLC framework includes the following steps:</p>

<h3>Communication</h3>

<p>This is the first step where the user initiates the request for a desired software product.  He contacts the service provider and tries to negotiate the terms. He submits his request to the service providing organization in writing.</p>

<h3>Requirement Gathering</h3>

<p>This step onwards the software development team works to carry on the project. The team holds discussions with various stakeholders from problem domain and tries to bring out as much information as possible on their requirements. The requirements are contemplated and segregated into user requirements, system requirements and functional requirements. The requirements are collected using a number of practices as given - </p>

<h3>Feasibility Study</h3>

<p>After requirement gathering, the team comes up with a rough plan of software process. At this step the team analyzes if a software can be made to fulfill all requirements of the user and if there is any possibility of software being no more useful. It is found out, if the project is financially, practically and technologically feasible for the organization to take up. There are many algorithms available, which help the developers to conclude the feasibility of a software project.</p>

<h3>System Analysis</h3>

<p>At this step the developers decide a roadmap of their plan and try to bring up the best software model suitable for the project. System analysis includes Understanding of software product limitations, learning system related problems or changes to be done in existing systems beforehand, identifying and addressing the impact of project on organization and personnel etc. The project team   analyzes the scope of the project and plans the schedule and resources accordingly.</p>

<h3>Software Design</h3>

<p>Next step is to bring down whole knowledge of requirements and analysis on the desk and design the software product.  The inputs from users and information gathered in requirement gathering phase are the inputs of this step. The output of this step comes in the form of two designs; logical design and physical design. Engineers produce meta-data and data dictionaries, logical diagrams, data-flow diagrams and in some cases pseudo codes.</p>

<h3>Coding</h3>

<p>This step is also known as programming phase. The implementation of software design starts in terms of writing program code in the suitable programming language and developing error-free executable programs efficiently.</p>

<h3>Testing</h3>

<p>An estimate says that 50% of whole software development process should be tested. Errors may ruin the software from critical level to its own removal. Software testing is done while coding by the developers and thorough testing is conducted by testing experts at various levels of code such as module testing, program testing, product testing, in-house testing and testing the product at user’s end. Early discovery of errors and their remedy is the key to reliable software.</p>

<h3>Integration</h3>

<p>Software may need to be integrated with the libraries, databases and other program(s). This stage of SDLC is involved in the integration of software with outer world entities.</p>

<h3>Implementation</h3>

<p>This means installing the software on user machines. At times, software needs post-installation configurations at user end. Software is tested for portability and adaptability and integration related issues are solved during implementation.</p>

<h3>Operation and Maintenance</h3>

<p>This phase confirms the software operation in terms of more efficiency and less errors. If required, the users are trained on, or aided with the documentation on how to operate the software and how to keep the software operational. The software is maintained timely by updating the code according to the changes taking place in user end environment or technology. This phase may face challenges from hidden bugs and real-world unidentified problems.</p>

<h3>Disposition</h3>

<p>As time elapses, the software may  decline on the performance front. It may go completely obsolete or may need intense upgradation. Hence a pressing need to eliminate a major portion of the system arises. This phase includes archiving data and required software components, closing down the system, planning disposition activity and terminating system at appropriate end-of-system time.</p>

<h2>Software Development Paradigm</h2>

<p>The software development paradigm helps developer to select a strategy to develop the software. A software development paradigm has its own set of tools, methods and procedures, which are expressed clearly and defines software development life cycle. A few of software development paradigms or process models are defined as follows:</p>

<h3>Waterfall Model</h3>

<p>Waterfall model is the simplest model of software development paradigm. It says the all the phases of SDLC will function one after another in linear manner. That is, when the first phase is finished then only the second phase will start and so on.</p>

<p>This model assumes that everything is carried out and taken place perfectly as planned in the previous stage and there is no need to think about the past issues that may arise in the next phase. This model does not work smoothly if there are some issues left at the previous step. The sequential nature of model does not allow us go back and undo or redo our actions.</p>

<p>This model is best suited when developers already have designed and developed similar software in the past and are aware of all its domains. </p>

<h3>Iterative Model</h3>

<p>This model leads the software development process in iterations. It projects the process of development in cyclic manner repeating every step after every cycle of SDLC process.</p>

<p>The software is first developed on very small scale and all the steps are followed which are taken into consideration. Then, on every next iteration, more features and modules are designed, coded, tested and added to the software. Every cycle produces a software, which is complete in itself and has more features and capabilities than that of the previous one.</p>

<p>After each iteration, the management team can do work on risk management and prepare for the next iteration. Because a cycle includes small portion of whole software process, it is easier to manage the development process but it consumes more resources.</p>

<h3>Spiral Model</h3>

<p>Spiral model is a combination of both, iterative model and one of the SDLC model. It can be seen as if you choose one SDLC model and combine it with cyclic process (iterative model).</p>

<p>This model considers risk, which often goes un-noticed by most other models. The model starts with determining objectives and constraints of the software at the start of one iteration. Next phase is of prototyping the software. This includes risk analysis. Then one standard SDLC model is used to build the software. In the fourth phase of the plan of next iteration is prepared.</p>

<h3>V – model</h3>

<p>The major drawback of waterfall model is we move to the next stage only when the previous one is finished and there was no chance to go back if something is found wrong in later stages. V-Model provides means of testing of software at each stage in reverse manner.</p>

<p>At every stage, test plans and test cases are created to verify and validate the product according to the requirement of that stage. For example, in requirement gathering stage the test team prepares all the test cases in correspondence to the requirements. Later, when the product is developed and is ready for testing, test cases of this stage verify the software against its validity towards requirements at this stage.</p>

<p>This makes both verification and validation go in parallel. This model is also known as verification and validation model.</p>

<h3>Big Bang Model</h3>

<p>This model is the simplest model in its form. It requires little planning, lots of programming and lots of funds. This model is conceptualized around the big bang of universe. As scientists say that after big bang lots of galaxies, planets and stars evolved just as an event. Likewise, if we put together lots of programming and funds, you may achieve the best software product.</p>

<p>For this model, very small amount of planning is required. It does not follow any process, or at times the customer is not sure about the requirements and future needs. So the input requirements are arbitrary.</p>

<p>This model is not suitable for large software projects but good one for learning and experimenting.</p>

<p>For an in-depth reading on SDLC and its various models,<a href="http://www.tutorialspoint.com/sdlc/index.htm" style="color:blue" target="_blank"> click here.</a></p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Software Project Management</title>

<h1>Software Project Management</h1>

<p>The job pattern of an IT company engaged in software development can be seen split in two parts:</p>

<p>A project is well-defined task, which is a collection of several operations done in order to achieve a goal (for example, software development and delivery).  A Project can be characterized as:</p>

<h2>Software Project</h2>

<p>A Software Project is the complete procedure of software development from requirement gathering to testing and maintenance, carried out according to the execution methodologies, in a specified period of time to achieve intended software product.</p>

<h2>Need of software project management</h2>

<p>Software is said to be an intangible product. Software development is a kind of all new stream in world business and there’s very little experience in building software products.  Most software products are tailor made to fit client’s requirements. The most important is that the underlying technology changes and advances so frequently and rapidly that experience of one product may not be applied to the other one. All such business and environmental constraints bring risk in software development hence it is essential to manage software projects efficiently.</p>

<p></p>

<p>The image above shows triple constraints for software projects. It is an essential part of software organization to deliver quality product, keeping the cost within client’s budget constrain and deliver the project as per scheduled.  There are several factors, both internal and external, which may impact this triple constrain triangle.  Any of three factor can severely impact the other two. </p>

<p>Therefore, software project management is essential to incorporate user requirements along with budget and time constraints.</p>

<h2>Software Project Manager</h2>

<p>A software project manager is a person who undertakes the responsibility of executing the software project.  Software project manager is thoroughly aware of all the phases of SDLC that the software would go through. Project manager may never directly involve in producing the end product but he controls and manages the activities involved in production.</p>

<p>A project manager closely monitors the development process, prepares and executes various plans, arranges necessary and adequate resources, maintains communication among all team members in order to address issues of cost, budget, resources, time, quality and customer satisfaction.</p>

<p>Let us see few responsibilities that a project manager shoulders -</p>

<h3>Managing People</h3>

<h3>Managing Project</h3>

<h2>Software Management Activities</h2>

<p>Software project management comprises of a number of activities, which contains planning of project, deciding scope of software product, estimation of cost in various terms, scheduling of tasks and events, and resource management.  Project management activities may include:</p>

<h2>Project Planning</h2>

<p>Software project planning is task, which is performed before the production of software actually starts.  It is there for the software production but involves no concrete activity that has any direction connection with software production; rather it is a set of multiple processes, which facilitates software production.  Project planning may include the following: </p>

<h2>Scope Management</h2>

<p>It defines the scope of project; this includes all the activities, process need to be done in order to make a deliverable software product.  Scope management is essential because it creates boundaries of the project by clearly defining what would be done in the project and what would not be done. This makes project to contain limited and quantifiable tasks, which can easily be documented and in turn avoids cost and time overrun.  </p>

<p>During Project Scope management, it is necessary to -</p>

<h2>Project Estimation</h2>

<p>For an effective management accurate estimation of various measures is a must.  With correct estimation managers can manage and control the project more efficiently and effectively. </p>

<p>Project estimation may involve the following:</p>

<p>Software size may be estimated either in terms of KLOC (Kilo Line of Code) or by calculating number of function points in the software. Lines of code depend upon coding practices and Function points vary according to the user or software requirement.</p>

<p>Once size and efforts are estimated, the time required to produce the software  can be estimated. Efforts required is segregated into sub categories as per the requirement specifications and interdependency of various components of software. Software tasks are divided into smaller tasks, activities or events by Work Breakthrough Structure (WBS).  The tasks are scheduled on day-to-day basis or in calendar months.</p>

<p>The sum of time required to complete all tasks in hours or days is the total time invested to complete the project.</p>

<p>This might be considered as the most difficult of all because it depends on more elements than any of the previous ones.  For estimating project cost, it is required to consider - </p>

<h2>Project Estimation Techniques</h2>

<p>We discussed various parameters involving project estimation such as size, effort, time and cost.</p>

<p>Project manager can estimate the listed factors using two broadly recognized techniques –</p>

<h3>Decomposition Technique</h3>

<p>This technique assumes the software as a product of various compositions.</p>

<p>There are two main models -</p>

<h3>Empirical Estimation Technique</h3>

<p>This technique uses empirically derived formulae to make estimation.These formulae are based on LOC or FPs.</p>

<p>This model is made by Lawrence H. Putnam, which is based on Norden’s frequency distribution (Rayleigh curve).  Putnam model maps time and efforts required with software size.  </p>

<p>COCOMO stands for COnstructive COst MOdel, developed by Barry W. Boehm.  It divides the software product into three categories of software: organic, semi-detached and embedded.</p>

<h2>Project Scheduling</h2>

<p>For scheduling a project, it is necessary to -</p>

<h2>Resource management</h2>

<p>All elements used to develop a software product may be assumed as resource for that project.  This may include human resource, productive tools and software libraries.</p>

<p>The resources are available in limited quantity and stay in the organization as a pool of assets. The shortage of resources hampers the development of project and it can lag behind the schedule. Allocating extra resources increases development cost in the end. It is therefore necessary to estimate and allocate adequate resources for the project.</p>

<p>Resource management includes -</p>

<h2>Project Risk Management</h2>

<p>Risk management involves all activities pertaining to identification, analyzing and making provision for predictable and non-predictable risks in the project.  Risk may include the following:</p>

<h2>Risk Management Process</h2>

<p>There are following activities involved in risk management process:</p>

<h2>Project Execution &amp; Monitoring</h2>

<p>In this phase, the tasks described in project plans are executed according to their schedules.</p>

<p>Execution needs monitoring in order to check whether everything is going according to the plan.  Monitoring is observing to check the probability of risk and taking measures to address the risk or report the status of various tasks.</p>

<p>These measures include -</p>

<h2>Project Communication Management</h2>

<p>Effective communication plays vital role in the success of a project. It bridges gaps between client and the organization, among the team members as well as other stake holders in the project such as hardware suppliers.</p>

<p>Communication can be oral or written. Communication management process may have the following steps: </p>

<p>After closure, the team moves to next phase or project.</p>

<h2>Configuration Management</h2>

<p>Configuration management is a process of tracking and controlling the changes in software in terms of the requirements, design, functions and development of the product.</p>

<p>IEEE defines it as “the process of identifying and defining the items in the system, controlling the change of these items throughout their life cycle, recording and reporting the status of items and change requests, and verifying the completeness and correctness of items”.</p>

<p>Generally, once the SRS is finalized there is less chance of requirement of changes from user. If they occur, the changes are addressed only with prior approval of higher management, as there is a possibility of cost and time overrun.</p>

<h3>Baseline</h3>

<p>A phase of SDLC is assumed over if it baselined, i.e. baseline is a measurement that defines completeness of a phase.  A phase is baselined when all activities pertaining to it are finished and well documented.  If it was not the final phase, its output would be used in next immediate phase.</p>

<p>Configuration management is a discipline of organization administration, which takes care of occurrence of any change (process, requirement, technological, strategical etc.) after a phase is baselined.  CM keeps check on any changes done in software.</p>

<h3>Change Control</h3>

<p>Change control is function of configuration management, which ensures that all changes made to software system are consistent and made as per organizational rules and regulations.</p>

<p>A change in the configuration of product goes through following steps -</p>

<p><b>Identification</b> - A change request arrives from either internal or external source. When change request is identified formally, it is properly documented.</p>

<p><b>Validation</b> - Validity of the change request is checked and its handling procedure is confirmed.</p>

<p><b>Analysis</b> - The impact of change request is analyzed in terms of schedule, cost and required efforts. Overall impact of the prospective change on system is analyzed.</p>

<p><b>Control</b> - If the prospective change either impacts too many entities in the system or it is unavoidable, it is mandatory to take approval of high authorities before change is incorporated into the system. It is decided if the change is worth incorporation or not. If it is not, change request is refused formally.</p>

<p><b>Execution</b> - If the previous phase determines to execute the change request, this phase take appropriate actions to execute the change, does a thorough revision if necessary.</p>

<p><b>Close request</b> - The change is verified for correct implementation and merging with the rest of the system. This newly incorporated change in the software is documented properly and the request is formally is closed.</p>

<h2>Project Management Tools</h2>

<p>The risk and uncertainty rises multifold with respect to the size of the project, even when the project is developed according to set methodologies.</p>

<p>There are tools available, which aid for effective project management. A few are described -</p>

<h3>Gantt Chart</h3>

<p>Gantt charts was devised by Henry Gantt (1917). It represents project schedule with respect to time periods.  It is a horizontal bar chart with bars representing activities and time scheduled for the project activities.</p>

<h3>PERT Chart</h3>

<p>PERT (Program Evaluation &amp; Review Technique) chart is a tool that depicts project as network diagram.  It is capable of graphically representing main events of project in both parallel and consecutive way.  Events, which occur one after another, show dependency of the later event over the previous one.</p>

<p>Events are shown as numbered nodes. They are connected by labeled arrows depicting sequence of tasks in the project.</p>

<h3>Resource Histogram</h3>

<p>This is a graphical tool that contains bar or chart representing number of resources (usually skilled staff) required over time for a project event (or phase).  Resource Histogram is an effective tool for staff planning and coordination.</p>

<h3>Critical Path Analysis</h3>

<p>This tools is useful in recognizing interdependent tasks in the project. It also helps to find out the shortest path or critical path to complete the project successfully. Like PERT diagram, each event is allotted a specific time frame. This tool shows dependency of event assuming an event can proceed to next only if the previous one is completed.</p>

<p>The events are arranged according to their earliest possible start time. Path between start and end node is critical path which cannot be further reduced and all events require to be executed in same order.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Software Requirements</title>

<h1>Software Requirements</h1>

<p>The software requirements are description of features and functionalities of the target system.  Requirements convey the expectations of users from the software product. The requirements can be obvious or hidden, known or unknown, expected or unexpected from client’s point of view.</p>

<h2>Requirement Engineering</h2>

<p>The process to gather the software requirements from client, analyze and document them is known as requirement engineering.</p>

<p>The goal of requirement engineering is to develop and maintain sophisticated and descriptive ‘System Requirements Specification’ document.</p>

<h2>Requirement Engineering Process</h2>

<p>It is a four step process, which includes – </p>

<p>Let us see the process briefly - </p>

<h3>Feasibility study</h3>

<p>When  the client  approaches the organization for getting the desired product developed, it comes up with rough idea about what all functions the software must perform and which all features are expected from the software. </p>

<p>Referencing to this information, the analysts  does a detailed study about whether the  desired system and its functionality are feasible to develop. </p>

<p>This feasibility study is focused towards goal of the organization.  This study analyzes whether the software product can be practically materialized in terms of implementation, contribution of project to organization, cost constraints and as per values and objectives of the organization.  It explores technical aspects of the project and product such as usability, maintainability, productivity and integration ability.</p>

<p>The output of this phase should be a feasibility study report that should contain adequate comments and recommendations for management about whether or not the project should be undertaken.</p>

<h3>Requirement Gathering</h3>

<p>If the feasibility report is positive towards undertaking the project, next phase starts with gathering requirements from the user. Analysts and engineers communicate with the client and end-users to know their ideas on what the software should provide and which features they want the software to include. </p>

<h3>Software Requirement Specification</h3>

<p>SRS is a document created by system analyst after the requirements are collected from various stakeholders. </p>

<p>SRS defines how the intended software will interact with hardware, external interfaces, speed of operation, response time of system, portability of software across various platforms, maintainability, speed of recovery after crashing, Security, Quality, Limitations etc. </p>

<p>The requirements received from client are written in natural language. It is the responsibility of system analyst to document the requirements in technical language so that they can be comprehended and useful by the software development team. </p>

<p>SRS should come up with following features: </p>

<h3>Software Requirement Validation</h3>

<p>After requirement specifications are developed, the requirements mentioned in this document are validated.  User might ask for illegal, impractical solution or experts may interpret the requirements incorrectly. This results in huge increase in cost if not nipped in the bud. Requirements can be checked against following conditions -</p>

<h2>Requirement Elicitation Process</h2>

<p>Requirement elicitation process can be depicted using the folloiwng diagram:</p>

<p><b>Negotiation & discussion - </b>If requirements are ambiguous or there are some conflicts in requirements of various stakeholders, if they are, it is then negotiated and discussed with stakeholders.  Requirements may then be prioritized and reasonably compromised.</p>

<p>The requirements come from various stakeholders. To remove the ambiguity and conflicts, they are discussed for clarity and correctness. Unrealistic requirements are compromised reasonably.</p>

<h2>Requirement Elicitation Techniques</h2>

<p>Requirements Elicitation is the process to find out the requirements for an intended software system by communicating with client, end users, system users and others who have a stake in the software system development.</p>

<p>There are various ways to discover requirements</p>

<h3>Interviews</h3>

<p>Interviews are strong medium to collect requirements. Organization may conduct several types of interviews such as: </p>

<h3>Surveys</h3>

<p>Organization may conduct surveys among various stakeholders by querying about their expectation and requirements from the upcoming system. </p>

<h3>Questionnaires</h3>

<p>A document with pre-defined set of objective questions and respective options is handed over to all stakeholders to answer, which are collected and compiled.</p>

<p>A shortcoming of this technique is, if an option for some issue is not mentioned in the questionnaire, the issue might be left unattended.</p>

<h3>Task analysis</h3>

<p>Team of engineers and developers may analyze the operation for which the new system is required. If the client already has some software to perform certain operation, it is studied and requirements of proposed system are collected. </p>

<h3>Domain Analysis</h3>

<p>Every software falls into some domain category. The expert people in the domain can be a great help to analyze general and specific requirements.  </p>

<h3>Brainstorming</h3>

<p>An informal debate is held among various stakeholders and all their inputs are recorded for further requirements analysis.</p>

<h3>Prototyping</h3>

<p>Prototyping is building user interface without adding detail functionality for user to interpret the features of intended software product. It helps giving better idea of requirements. If there is no software installed at client’s end for developer’s reference and the client is not aware of its own requirements, the developer  creates a prototype based on initially mentioned requirements. The prototype is shown to the client and the feedback is noted. The client feedback serves as an  input for requirement gathering.</p>

<h3>Observation</h3>

<p>Team of experts visit the client’s organization or workplace. They observe the actual working of the existing installed systems. They observe the workflow at client’s end and how execution problems are dealt. The team itself draws some conclusions which aid to form requirements expected from the software.</p>

<h2>Software Requirements Characteristics</h2>

<p>Gathering software requirements is the foundation of the entire software development project. Hence they must be clear, correct and well-defined.</p>

<p>A complete Software Requirement Specifications must be: </p>

<h2>Software Requirements</h2>

<p>We should try to understand what sort of requirements may arise in the requirement elicitation phase and what kinds of requirements are expected from the software system. </p>

<p>Broadly software requirements should be categorized in two categories:</p>

<h3>Functional Requirements</h3>

<p>Requirements, which are related to functional aspect of software fall into this category.</p>

<p>They define functions and functionality within and from the software system.</p>

<h4>Examples -</h4>

<h3>Non-Functional Requirements</h3>

<p>Requirements, which are not related to functional aspect of software, fall into this category.  They are implicit or expected characteristics of software, which users make assumption of.</p>

<p> Non-functional requirements include -</p>

<p>Requirements are categorized logically as </p>

<p>While developing software, ‘Must have’ must be implemented, ‘Should have’ is a matter of debate with stakeholders and negation, whereas ‘could have’ and ‘wish list’ can be kept for software updates.</p>

<h2>User Interface requirements</h2>

<p>UI is an important part of any software or hardware or hybrid system.  A software is widely accepted if it is -</p>

<p>User acceptance majorly depends upon how user can use the software.  UI is the only way for users to perceive the system. A well performing software system must also be equipped with attractive, clear, consistent and responsive user interface. Otherwise the functionalities of software system can not be used in convenient way.  A system is said be good if it provides means to use it efficiently.  User interface requirements are briefly mentioned below -</p>

<h2>Software System Analyst</h2>

<p>System analyst in an IT organization is a person, who analyzes the requirement of proposed system and ensures that requirements are conceived and documented properly & correctly. Role of an analyst starts during Software Analysis Phase of SDLC. It is the responsibility of analyst to make sure that the developed software meets the requirements of the client.</p>

<p>System Analysts have the following responsibilities:</p>

<h2>Software Metrics and Measures</h2>

<p>Software Measures can be understood as a process of quantifying and symbolizing various attributes and aspects of software.</p>

<p>Software Metrics provide measures for various aspects of software process and software product.</p>

<p>Software measures are fundamental requirement of software engineering. They not only help to control the software development process but also aid to keep quality of ultimate product excellent.</p>

<p>According to Tom DeMarco, a (Software Engineer), “You cannot control what you cannot measure.” By his saying, it is very clear how important software measures are.</p>

<p>Let us see some software metrics:</p>

<p><b>Size Metrics - </b>LOC (Lines of Code), mostly calculated in thousands of delivered source code lines, denoted as KLOC.</p>

<p><b>Quality Metrics - </b>Defects, their types and causes, consequence, intensity of severity and their implications define the quality of product. </p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Software Design Basics</title>

<h1>Software Design Basics</h1>

<p>Software design is a process to transform user requirements into some suitable form, which helps the programmer in software coding and implementation.</p>

<p>For assessing user requirements, an SRS (Software Requirement Specification) document is created whereas for coding and implementation, there is a need of more specific and detailed requirements in software terms.  The output of this process can directly be used into implementation in programming languages.</p>

<p>Software design is the first step in SDLC (Software Design Life Cycle), which moves the concentration from problem domain to solution domain. It tries to specify how to fulfill the requirements mentioned in SRS.</p>

<h2>Software Design Levels</h2>

<p>Software design yields three levels of results:</p>

<h2>Modularization</h2>

<p>Modularization is a technique to divide a software system into multiple discrete and independent modules, which are expected to be capable of carrying out task(s) independently. These modules may work as basic constructs for the entire software. Designers tend to design modules such that they can be executed and/or compiled separately and independently.</p>

<p>Modular design unintentionally follows the rules of ‘divide and conquer’ problem-solving strategy this is because there are many other benefits attached with the modular design of a software.</p>

<p>Advantage of modularization:</p>

<h2>Concurrency</h2>

<p>Back in time, all software are meant to be executed sequentially.  By sequential execution we mean that the coded instruction will be executed one after another implying only one portion of program being activated at any given time.  Say, a software has multiple modules, then only one of all the modules can be found active at any time of execution.</p>

<p>In software design, concurrency is implemented by splitting the software into multiple independent units of execution, like modules and executing them in parallel.  In other words, concurrency provides capability to the software to execute more than one part of code in parallel to each other.</p>

<p>It is necessary for the programmers and designers to recognize those modules, which can be made parallel execution. </p>

<h3>Example</h3>

<p>The spell check feature in word processor is a  module of software, which runs along side the word processor itself.</p>

<h2>Coupling and Cohesion</h2>

<p>When a software program is modularized, its tasks are divided into several modules based on some characteristics.  As we know, modules are set of instructions put together in order to achieve some tasks.  They are though, considered as single entity but may refer to each other to work together.  There are measures by which the quality of a design of modules and their interaction among them can be measured. These measures are called coupling and cohesion.</p>

<h2>Cohesion</h2>

<p>Cohesion is a measure that defines the degree of intra-dependability within elements of a module.  The greater the cohesion, the better is the program design.</p>

<p>There are seven types of cohesion, namely –</p>

<h2>Coupling </h2>

<p>Coupling  is a measure that defines the level of inter-dependability among modules of a program.  It tells at what level the modules interfere and interact with each other. The lower the coupling, the better the program.</p>

<p>There are five levels of coupling, namely -</p>

<p>Ideally, no coupling is considered to be the best.</p>

<h2>Design Verification</h2>

<p>The output of software design process is design documentation, pseudo codes, detailed logic diagrams, process diagrams, and detailed description of all functional or non-functional requirements. </p>

<p>The next phase, which is the implementation of software, depends on all outputs  mentioned above.  </p>

<p>It is then becomes necessary to verify the output before proceeding to the next phase. The early any mistake is detected, the better it is or it might not be detected until testing of the product.  If the outputs of design phase are in formal notation form, then their associated tools for verification should be used otherwise a thorough design review can be used for verification and validation.</p>

<p>By structured verification approach, reviewers can detect defects that might be caused by overlooking some conditions.  A good design review is important for good software design, accuracy and quality.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Software Analysis & Design Tools</title>

<h1>Software Analysis & Design Tools</h1>

<p>Software analysis and design includes all activities, which help the transformation of requirement specification into implementation.  Requirement specifications specify all functional and non-functional expectations from the software. These requirement specifications come in the shape of human readable and understandable  documents, to which a computer has nothing to do. </p>

<p>Software analysis and design is the intermediate stage, which helps human-readable requirements to be transformed into actual code.</p>

<p>Let us see few analysis and design tools used by software designers:</p>

<h2>Data Flow Diagram</h2>

<p>Data flow diagram is graphical representation of flow of data in an information system. It is capable of depicting incoming data flow, outgoing data flow and stored data. The DFD does not mention anything about how data flows through the system.</p>

<p>There is a prominent difference between DFD and Flowchart. The flowchart depicts flow of control in program modules. DFDs depict flow of data in the system at various levels. DFD does not contain any control or branch elements.</p>

<h3>Types of DFD</h3>

<p>Data Flow Diagrams are either Logical or Physical.</p>

<h3>DFD Components</h3>

<p>DFD can represent Source, destination, storage and flow of data using the following set of components -</p>

<h3>Levels of DFD</h3>

<p><b>Level 2</b> - At this level, DFD shows how data flows inside the modules mentioned in Level 1.</p>

<h2>Structure Charts</h2>

<p>Structure chart is a chart derived from Data Flow Diagram.  It represents the system in more detail than DFD.  It  breaks down the entire system into lowest functional modules, describes functions and  sub-functions of each module of the system to a greater detail than DFD.</p>

<p>Structure chart represents hierarchical structure of modules. At each layer a specific task is performed.</p>

<p>Here are the symbols used in  construction of structure charts -</p>

<h2>HIPO Diagram</h2>

<p>HIPO (Hierarchical Input Process Output) diagram is a combination of two organized method to analyze the system and provide the means of documentation. HIPO model was developed by IBM in year 1970.</p>

<p>HIPO  diagram represents the hierarchy of modules in the software system. Analyst uses HIPO diagram in order to obtain high-level view of system functions. It decomposes functions into sub-functions in a hierarchical manner. It depicts the functions performed by system.     </p>

<p>HIPO diagrams are good for documentation purpose. Their graphical representation makes it easier for designers and managers to  get the pictorial idea of the system structure. </p>

<p>In contrast to IPO (Input Process Output) diagram, which depicts  the flow of control and data in a module, HIPO does not provide any information about data flow or control flow.</p>

<h3>Example</h3>

<p>Both parts of HIPO diagram, Hierarchical presentation and IPO Chart are used for structure design of software program as well as documentation of the same.</p>

<h2>Structured English</h2>

<p>Most programmers are unaware of the large picture of software so they only rely on what their managers tell them to do. It is the responsibility of higher  software management to provide accurate information to the programmers to develop accurate yet fast code.</p>

<p>Other forms of methods, which use graphs or diagrams, may are sometimes interpreted differently by different people.</p>

<p>Hence, analysts and designers of the software come up with tools such as Structured English. It is nothing but the description of what is required to code and how to code it. Structured English helps the programmer to write error-free code. </p>

<p>Other form of methods, which use graphs or diagrams, may are sometimes interpreted differently by different people. Here, both Structured English and Pseudo-Code tries to mitigate that understanding gap.</p>

<p>Structured English is the It uses plain English words in structured programming paradigm.  It is not the ultimate code but a kind of description what is required to code and how to code it. The following are some tokens of structured programming.</p>

<p>Analyst uses the same variable and data name, which are stored in Data Dictionary, making it much simpler to write and understand the code.</p>

<h3>Example</h3>

<p>We take the same example of Customer Authentication in the online shopping environment. This procedure to authenticate customer can be written in Structured English as:</p>

<p>The code written in Structured English is more  like day-to-day spoken English. It can not be implemented directly as a code of software. Structured English is independent of programming language.</p>

<h2>Pseudo-Code</h2>

<p>Pseudo code is written more close to programming language.  It may be considered as augmented programming language, full of comments and descriptions.  </p>

<p>Pseudo code avoids variable declaration but they are written using some actual programming language’s constructs, like C, Fortran, Pascal etc.</p>

<p>Pseudo code contains more programming details than Structured English.  It provides a method to perform the task, as if a computer is executing the code.</p>

<h3>Example</h3>

<p>Program to print Fibonacci up to n numbers.</p>

<h2>Decision Tables </h2>

<p>A Decision table represents conditions and the respective actions to be taken to address them, in a structured tabular format.</p>

<p>It is a powerful tool to debug and prevent errors. It helps group similar information into a single table and then by combining tables it delivers easy and convenient decision-making.</p>

<h3>Creating Decision Table</h3>

<p>To create the decision table, the developer must follow basic four steps:</p>

<p>Decision Tables should be verified by end-users and can lately be simplified by eliminating duplicate rules and actions.</p>

<h3>Example</h3>

<p>Let us take a simple example of day-to-day problem with our Internet connectivity. We begin by identifying all problems that can arise while starting the internet and their respective possible solutions.  </p>

<p>We list all possible problems under column conditions and the prospective actions under column Actions.</p>

<h2>Entity-Relationship Model</h2>

<p>Entity-Relationship model is a type of database model based on the notion of real world entities and relationship among them.  We can map real world scenario onto ER database model. ER Model creates a set of entities with their attributes, a set of constraints and relation among them.</p>

<p>ER Model is best used for the conceptual design of database. ER Model can be represented as follows :</p>

<p><b>Entity</b> - An entity in ER Model is a real world  being, which has some properties called <b><i>attributes</i></b>.  Every attribute is defined by its corresponding set of values, called <b><i>domain</i></b>.</p>

<p>For example,  Consider a school database. Here, a student is  an entity. Student has various attributes like name, id, age and class etc.</p>

<p><b>Relationship</b> - The logical association among entities is called <b><i>relationship</i></b>.  Relationships are mapped with entities in various ways. Mapping cardinalities define the number of associations between two entities.</p>

<p>Mapping cardinalities:</p>

<h2>Data Dictionary</h2>

<p>Data dictionary is the centralized collection of information about data. It stores meaning and origin of data, its relationship with other data, data format for usage etc. Data dictionary  has rigorous definitions of all names in order to facilitate user and software designers.</p>

<p>Data dictionary is often referenced as meta-data (data about data) repository.  It is created along  with DFD (Data Flow Diagram) model of software program and is expected to be updated whenever DFD is changed or updated.</p>

<h3>Requirement of Data Dictionary</h3>

<p>The data is referenced via data dictionary while designing and implementing software.  Data dictionary removes any chances of ambiguity.  It helps keeping work of programmers and designers synchronized while using same object reference everywhere in the program.</p>

<p>Data dictionary provides a way of documentation for the  complete database system in one place.  Validation of DFD is carried out using data dictionary.</p>

<h3>Contents</h3>

<p>Data dictionary should contain information about the following </p>

<p>Data Flow is described by means of DFDs as studied earlier and represented in algebraic form as described.</p>

<h3>Example</h3>

<p>Address = House No + (Street / Area) + City + State</p>

<p>Course ID = Course Number + Course Name + Course Level + Course Grades</p>

<h3>Data Elements</h3>

<p>Data elements consist of Name and descriptions of Data and Control Items, Internal or External data stores etc. with the following details:</p>

<h3>Data Store</h3>

<p>It  stores the information from where the data enters into the system and exists out of the system. The Data Store may include -</p>

<h3>Data Processing</h3>

<p>There are two types of Data Processing:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
IF-THEN-ELSE,  
DO-WHILE-UNTIL
</pre>
<p>Analyst uses the same variable and data name, which are stored in Data Dictionary, making it much simpler to write and understand the code.</p>
<h3>Example</h3>
<p>We take the same example of Customer Authentication in the online shopping environment. This procedure to authenticate customer can be written in Structured English as:</p>
<pre class="prettyprint notranslate">
Enter Customer_Name
SEEK Customer_Name in Customer_Name_DB file
IF Customer_Name found THEN
   Call procedure USER_PASSWORD_AUTHENTICATE()
ELSE
   PRINT error message
   Call procedure NEW_CUSTOMER_REQUEST()
ENDIF
</pre>
<p>The code written in Structured English is more  like day-to-day spoken English. It can not be implemented directly as a code of software. Structured English is independent of programming language.</p>
<h2>Pseudo-Code</h2>
<p>Pseudo code is written more close to programming language.  It may be considered as augmented programming language, full of comments and descriptions.  </p>
<p>Pseudo code avoids variable declaration but they are written using some actual programming language’s constructs, like C, Fortran, Pascal etc.</p>
<p>Pseudo code contains more programming details than Structured English.  It provides a method to perform the task, as if a computer is executing the code.</p>
<h3>Example</h3>
<p>Program to print Fibonacci up to n numbers.</p>
<pre class="prettyprint notranslate">
void function Fibonacci
Get value of n;
Set value of a to 1;
Set value of b to 1;
Initialize I to 0
for (i=0; i&lt; n; i++)
{
   if a greater than b 
   {
      Increase b by a;
      Print b;
   } 
   else if b greater than a
   {
      increase a by b;
      print a;
   }
}
</pre>

<title>Software Design Strategies</title>

<h1>Software Design Strategies</h1>

<p>Software design is a process to conceptualize the software requirements into software implementation. Software design takes the user requirements as challenges and tries to find optimum solution. While the software is being conceptualized, a plan is chalked out to find the best possible design for implementing the intended solution.  </p>

<p>There are multiple variants of software design. Let us study them briefly:</p>

<h2>Structured Design</h2>

<p>Structured design is a conceptualization of problem into several well-organized elements of solution.  It is basically concerned with the solution design.  Benefit of structured design is, it gives better understanding of how the problem is being solved.  Structured design also makes it simpler for designer to concentrate on the problem more accurately. </p>

<p>Structured design is mostly based on ‘divide and conquer’ strategy where a problem is broken into several small problems and each small problem is individually solved until the whole problem is solved.</p>

<p>The small pieces of problem are solved by means of solution modules.  Structured design emphasis that these modules be well organized in order to achieve precise solution.  </p>

<p>These modules are arranged in hierarchy. They communicate with each other. A good structured design always follows some rules for communication among multiple modules, namely -</p>

<p><b>Cohesion</b> -  grouping of all functionally related elements.</p>

<p><b>Coupling</b> - communication between different modules.</p>

<p>A good structured design has high cohesion and low coupling arrangements.</p>

<h2>Function Oriented Design</h2>

<p>In function-oriented design, the system is comprised of many smaller sub-systems known as functions.  These functions are capable of performing significant task in the system. The system is considered as top view of all functions.</p>

<p>Function oriented design inherits some properties of structured design where divide and conquer methodology is used.</p>

<p>This design mechanism divides the whole system into smaller functions, which provides means of abstraction by concealing the information and their operation.. These functional modules can share information among themselves by means of information passing and using information available globally.</p>

<p>Another characteristic of functions is that when a program calls a function, the function changes the state of the program, which sometimes is not acceptable by other modules. Function oriented design works well where the system state does not matter and program/functions work on input rather than on a state.</p>

<h3>Design Process</h3>

<h2>Object Oriented Design</h2>

<p>Object oriented design works around the entities and their characteristics instead of functions involved in the software system.  This design strategies focuses on entities and its characteristics.  The whole concept of software solution revolves around the engaged entities.</p>

<p>Let us see the important concepts of Object Oriented Design:</p>

<p><b>Classes - </b>A class is a generalized description of an object.  An object is an instance of a class.  Class defines all the attributes, which an object can have and methods, which defines the functionality of the object.</p>

<h3>Design Process</h3>

<p>Software design process can be perceived as series of well-defined steps.  Though it varies according to design approach (function oriented or object oriented, yet It may have the following steps involved:</p>

<h2>Software Design Approaches</h2>

<p>Here are two generic approaches for software designing:</p>

<h3>Top Down Design</h3>

<p>We know that a system is composed of more than one sub-systems and it contains a number of components.  Further, these sub-systems and components may have their on set of sub-system and components and creates hierarchical structure in the system.</p>

<p>Top-down design takes the whole software system as one entity and then decomposes it to achieve more than one sub-system or component based on some characteristics.  Each sub-system or component is then treated as a system and decomposed further.  This process keeps on running until the lowest level of system in the top-down hierarchy is achieved.</p>

<p>Top-down design starts with a generalized model of system and keeps on defining the more specific part of it.  When all components are composed the whole system comes into existence.</p>

<p>Top-down design is more suitable when the software solution needs to be designed from scratch and specific details are unknown.</p>

<h3>Bottom-up Design</h3>

<p>The bottom up design model starts with most specific and basic components.  It proceeds with composing higher level of components by using basic or lower level components. It keeps creating higher level components until the desired system is not evolved as one single component.  With each higher level, the amount of abstraction is increased.</p>

<p>Bottom-up strategy is more suitable when a system  needs to be created from some existing system, where the basic primitives can be used in the newer system.</p>

<p>Both, top-down and bottom-up approaches are not practical individually. Instead, a good combination of both is used.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Software User Interface Design</title>

<h1>Software User Interface Design</h1>

<p>User interface is the front-end application view to which user interacts in order to use the software. User can manipulate and control the software as well as hardware by means of user interface.   Today, user interface is found at almost every place where digital technology exists, right from computers, mobile phones, cars, music players, airplanes, ships etc.</p>

<p>User interface is part of software and is designed such a way that it is expected to provide the user insight of the software.  UI provides fundamental platform for human-computer interaction.  </p>

<p>UI can be graphical, text-based, audio-video based, depending upon the underlying hardware and software combination.  UI can be hardware or software or a combination of both.</p>

<p>The software becomes more popular if its user interface is:</p>

<p>UI is broadly divided into two categories:</p>

<h2>Command Line Interface (CLI)</h2>

<p>CLI has been a great tool of interaction with computers until the video display monitors came into existence. CLI is first choice of many technical users and programmers. CLI is minimum interface a software can provide to its users.</p>

<p>CLI provides a command prompt, the place where the user types the command and feeds to the system. The user needs to remember the syntax of command and its use.  Earlier CLI were not programmed to handle the user errors effectively.</p>

<p>A command is a text-based reference to set of instructions, which are expected to be executed by the system. There are methods like macros, scripts that make it easy for the user to operate.</p>

<p>CLI uses less amount of computer resource as compared to GUI.</p>

<h3>CLI Elements</h3>

<p>A text-based command line interface can have the following elements:</p>

<p><b>Command Prompt</b>  - It is text-based notifier that is mostly shows the context in which the user is working.  It is generated by the software system.</p>

<p><b>Cursor</b> - It is a small horizontal line or a vertical bar of the height of line, to represent position of character while typing. Cursor is mostly found in blinking state.  It moves as the user writes or deletes something.</p>

<p><b>Command</b> - A command is an executable instruction. It may have one or more parameters. Output on command execution is shown inline on the screen.  When output is produced, command prompt is displayed on the next line.</p>

<h2>Graphical User Interface</h2>

<p>Graphical User Interface provides the user graphical means to interact with the system. GUI can be combination of both hardware and software. Using GUI, user interprets the software.</p>

<p>Typically, GUI is more resource consuming than that of CLI. With advancing technology, the programmers and designers create complex GUI designs that work with more efficiency, accuracy and speed.</p>

<h3>GUI Elements</h3>

<p>GUI provides a set of components to interact with software or hardware.</p>

<p>Every graphical component provides a way to work with the system. A GUI system has following elements such as:</p>

<p><b>Window</b> - An area where contents of application are displayed. Contents in a window can be displayed in the form of icons or lists, if the window represents file structure. It is easier for a user to navigate in the file system in an exploring window. Windows can be minimized, resized or maximized to the size of screen. They can be moved anywhere on the screen. A window may contain another window of the same application, called child window.</p>

<p><b>Tabs</b> - If an application allows executing multiple instances of itself, they appear on the screen as separate windows.<b> Tabbed Document Interface</b> has come up to open multiple documents in the same window. This interface also helps in viewing preference panel in application. All modern web-browsers use this feature.</p>

<p><b>Menu</b> - Menu is an array of standard commands, grouped together and placed at a visible place (usually top) inside the application window. The menu can be programmed to appear or hide on mouse clicks.</p>

<p><b>Icon</b> - An icon is small picture representing an associated application. When these icons are clicked or double clicked, the application window is opened. Icon displays application and programs installed on a system in the form of small pictures.</p>

<p><b>Cursor</b> - Interacting devices such as mouse, touch pad, digital pen are represented in GUI as cursors. On screen cursor follows the instructions from hardware in almost real-time. Cursors are also named pointers in GUI systems. They are used to select menus, windows and other application features.</p>

<h3>Application specific GUI components</h3>

<p>A GUI of an application contains one or more of the listed GUI elements:</p>

<p><b>Application Window</b> - Most application windows uses the constructs supplied by operating systems but many use their own customer created windows to contain the contents of application.</p>

<p><b>Dialogue Box </b> - It is a child window that contains message for the user and request for some action to be taken. For Example: Application generate a dialogue to get confirmation from user to delete a file.</p>

<p><b>Text-Box</b> -  Provides an area for user to type and enter text-based data.</p>

<p><b>Buttons</b> - They imitate real life buttons and are used to submit inputs to the software.</p>

<p><b>Radio-button</b> - Displays available options for selection. Only one can be selected among all offered.</p>

<p><b>Check-box</b> - Functions similar to list-box. When an option is selected, the box is marked as checked. Multiple options represented by check boxes can be selected.</p>

<p><b>List-box </b> - Provides list of available items for selection. More than one item can be selected.</p>

<p>Other impressive GUI components are:</p>

<h2>User Interface Design Activities</h2>

<p>There are a number of activities performed for designing user interface. The process of GUI design and implementation is alike SDLC. Any model can be used for GUI implementation among Waterfall, Iterative or Spiral Model.</p>

<p>A model used for GUI design and development should fulfill these GUI specific steps.</p>

<p><b>GUI Requirement Gathering</b> - The designers may like to have list of all functional and non-functional requirements of GUI. This can be taken from user and their existing software solution.</p>

<p><b>User Analysis</b> - The designer studies who is going to use the software GUI. The target audience matters as the design details change according to the knowledge and competency level of the user. If user is technical savvy, advanced and complex GUI can be incorporated. For a novice user, more information is included on how-to of software.</p>

<p><b>Task Analysis</b> - Designers have to analyze what task is to be done by the software solution.  Here in GUI, it does not matter how it will be done.  Tasks can be represented in hierarchical manner taking one major task and dividing it further into smaller sub-tasks.  Tasks provide goals for GUI presentation. Flow of information among sub-tasks determines the flow of GUI contents in the software.</p>

<p><b>GUI Design & implementation</b> - Designers after having information about requirements, tasks and user environment, design the GUI and implements into code and embed the GUI with working or dummy software in the background.  It is then self-tested by the developers.</p>

<p><b>Testing</b> - GUI testing can be done in various ways.  Organization can have in-house inspection, direct involvement of users and release of beta version are few of them.  Testing may include usability, compatibility, user acceptance etc.</p>

<h2>GUI Implementation Tools</h2>

<p>There are several tools available using which the designers can create entire GUI on a mouse click. Some tools can be embedded into the software environment (IDE).</p>

<p>GUI implementation tools provide powerful array of GUI controls. For software customization, designers can change the code accordingly.</p>

<p>There are different segments of GUI tools according to their different use and platform.</p>

<h3>Example</h3>

<p>Mobile GUI, Computer GUI, Touch-Screen GUI etc. Here is a list of few tools which come handy to build GUI:</p>

<h2>User Interface Golden rules</h2>

<p>The following rules are mentioned to be the golden rules for GUI design, described by Shneiderman and Plaisant in their book (Designing the User Interface).</p>

<p><b>Strive for consistency</b> - Consistent sequences of actions should be required in similar situations. Identical terminology should be used in prompts, menus, and help screens. Consistent commands should be employed throughout.</p>

<p><b>Enable frequent users to use short-cuts</b> - The user’s desire to reduce the number of interactions increases with the frequency of use.  Abbreviations, function keys, hidden commands, and macro facilities are very helpful to an expert user.</p>

<p><b>Offer informative feedback</b> - For every operator action, there should be some system feedback. For frequent and minor actions, the response must be modest, while for infrequent and major actions, the response must be more substantial.</p>

<p><b>Design dialog to yield closure</b> - Sequences of actions should be organized into groups with a beginning, middle, and end. The informative feedback at the completion of a group of actions gives the operators the satisfaction of accomplishment, a sense of relief, the signal to drop contingency plans and options from their minds, and  this indicates that the way ahead is clear to prepare for the next group of actions.</p>

<p><b>Offer simple error handling</b> - As much as possible, design the system so the user will not make a serious error. If an error is made, the system should be able to detect  it and offer simple, comprehensible mechanisms for handling the error.</p>

<p><b>Permit easy reversal of actions</b> - This feature relieves anxiety, since the user knows that errors can be undone. Easy reversal of actions  encourages exploration of unfamiliar options. The units of reversibility may be a single action, a data entry, or a complete group of actions.</p>

<p><b>Support internal locus of control</b> - Experienced operators strongly desire the sense that they are in charge of the system and that the system responds to their actions. Design the system to make users the initiators of actions rather than the responders.</p>

<p><b>Reduce short-term memory load</b> - The limitation of human information processing in short-term memory requires the  displays to be kept simple, multiple page displays be consolidated, window-motion frequency be reduced, and sufficient training time be allotted for codes, mnemonics, and sequences of actions. </p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Software Design Complexity</title>

<h1>Software Design Complexity</h1>

<p>The term complexity stands for state of events or things, which have multiple interconnected links and highly complicated structures. In software programming, as the design of software is realized, the number of  elements and their interconnections gradually emerge to be huge, which becomes too difficult to understand at once.</p>

<p>Software design complexity  is difficult to assess without using complexity metrics and measures. Let us see three important software complexity measures.</p>

<h2>Halstead's Complexity Measures</h2>

<p>In 1977, Mr. Maurice Howard Halstead introduced metrics to measure software complexity.  Halstead’s metrics depends upon the actual implementation of program and its measures, which are computed directly from the operators and operands from source code, in static manner. It allows to evaluate testing time, vocabulary, size, difficulty, errors, and efforts for C/C++/Java source code.</p>

<p>According to Halstead, “A computer program is an implementation of an algorithm considered to be a collection of tokens which can be classified as either operators or operands”.  Halstead metrics think a program as sequence of operators and their associated operands.</p>

<p>He defines various indicators to check complexity of module.</p>

<p>When we select source file to view its complexity details in Metric Viewer, the following result is seen in Metric Report:</p>

<h2>Cyclomatic Complexity Measures</h2>

<p>Every program encompasses statements to execute in order to perform some task and other decision-making statements that decide, what statements need to be executed. These decision-making constructs change the flow of the program. </p>

<p>If we compare two programs of same size, the one with more decision-making statements will be more complex as the control of program jumps frequently.</p>

<p>McCabe, in 1976, proposed Cyclomatic Complexity Measure to quantify complexity of a given software.  It is graph driven model that is based on decision-making constructs of program such as if-else, do-while, repeat-until, switch-case and goto statements.</p>

<p>Process to make flow control graph:</p>

<p>If control can branch from block i to block j</p>

<p>Draw an arc</p>

<p>From exit node to entry node</p>

<p>Draw an arc.</p>

<p>To calculate Cyclomatic complexity of a program module, we use the formula -</p>

<p>The Cyclomatic complexity of the above module is</p>

<p>According to P. Jorgensen, Cyclomatic Complexity of a module should not exceed 10.</p>

<h2>Function Point</h2>

<p>It is widely used to measure the size of software.  Function Point concentrates on functionality provided by the system.  Features and functionality of the system are used to measure the software complexity.</p>

<p>Function point counts on five parameters, named as External Input, External Output, Logical Internal Files, External Interface Files, and External Inquiry. To consider the complexity of software  each parameter is further categorized as simple, average or complex.  </p>

<p>Let us see parameters of function point:</p>

<h3>External Input</h3>

<p>Every unique input to the system, from outside, is considered as external input.  Uniqueness of input is measured, as no two inputs should have same formats.  These inputs can either be data or control parameters.</p>

<p><b>Simple</b> - if input count is low and affects less internal files</p>

<p><b>Complex</b> - if input count is high and affects more internal files</p>

<p><b>Average</b> - in-between simple and complex.</p>

<h3>External Output</h3>

<p> All output types provided by the system are counted in this category. Output is considered unique if their output format and/or processing are unique.</p>

<p><b>Simple</b> - if output count is low</p>

<p><b>Complex</b> - if output count is high</p>

<p><b>Average</b> - in between simple and complex.</p>

<h3>Logical Internal Files</h3>

<p> Every software system maintains internal files in order to maintain its functional information and to function properly. These files hold logical data of the system.  This logical data may contain both functional data and control data.</p>

<p><b>Simple</b> - if number of record types are low</p>

<p><b>Complex</b> - if number of record types are high</p>

<p><b>Average</b> - in between simple and complex.</p>

<h3>External Interface Files</h3>

<p> Software system may need to share its files with some external software or it may need to pass the file for processing or as parameter to some function. All these files are counted as external interface files.</p>

<p><b>Simple</b> - if number of record types in shared file are low</p>

<p><b>Complex</b> - if number of record types in shared file are high</p>

<p><b>Average</b> - in between simple and complex.</p>

<h3>External Inquiry </h3>

<p> An inquiry is a combination of input and output, where user sends some data to inquire about as input and the system responds to the user with the output of inquiry processed.  The complexity of a query is more than External Input and External Output.  Query is said to be unique if its input and output are unique in terms of format and data.</p>

<p><b>Simple</b> - if query needs low processing and yields small amount of output data</p>

<p><b>Complex</b> - if query needs high process and yields large amount of output data</p>

<p><b>Average</b> - in between simple and complex.</p>

<p>Each of these parameters in the system is given weightage according to their class and complexity.  The table below mentions the weightage given to each parameter:</p>

<p>The table above yields raw Function Points. These function points are  adjusted according to the environment complexity. System is described using  fourteen different characteristics:</p>

<p>These characteristics factors are then rated from 0 to 5, as mentioned below:</p>

<p>All ratings are then summed up as N. The value of N ranges from 0 to 70 (14 types of characteristics x 5 types of ratings).  It is used to calculate Complexity Adjustment Factors (CAF), using the following formulae:</p>

<p>Then,</p>

<p>This FP can then be used in various metrics, such as:</p>

<p><b>Cost</b> = $ / FP</p>

<p><b>Quality</b> = Errors / FP</p>

<p><b>Productivity</b> = FP / person-month</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
V(G) = e – n + 2

Where
e is total number of edges
n is total number of nodes
</pre>
<img src="/software_engineering/images/cyclomatic_complexity.png" alt="Cyclomatic Complexity Measures"/>
<p>The Cyclomatic complexity of the above module is</p>
<pre class="prettyprint notranslate">
e = 10
n = 8
Cyclomatic Complexity = 10 - 8 + 2
                      = 4
</pre>
<p>According to P. Jorgensen, Cyclomatic Complexity of a module should not exceed 10.</p>
<h2>Function Point</h2>
<p>It is widely used to measure the size of software.  Function Point concentrates on functionality provided by the system.  Features and functionality of the system are used to measure the software complexity.</p>
<p>Function point counts on five parameters, named as External Input, External Output, Logical Internal Files, External Interface Files, and External Inquiry. To consider the complexity of software  each parameter is further categorized as simple, average or complex.  </p>
<img src="/software_engineering/images/function_points.png" alt="Function Point"/>
<p>Let us see parameters of function point:</p>
<h3>External Input</h3>
<p>Every unique input to the system, from outside, is considered as external input.  Uniqueness of input is measured, as no two inputs should have same formats.  These inputs can either be data or control parameters.</p>
<ul class="list">
<li><p><b>Simple</b> - if input count is low and affects less internal files</p></li>
<li><p><b>Complex</b> - if input count is high and affects more internal files</p></li>
<li><p><b>Average</b> - in-between simple and complex.</p></li>
</ul>
<h3>External Output</h3>
<p> All output types provided by the system are counted in this category. Output is considered unique if their output format and/or processing are unique.</p>
<ul class="list">
<li><p><b>Simple</b> - if output count is low</p></li>
<li><p><b>Complex</b> - if output count is high</p></li>
<li><p><b>Average</b> - in between simple and complex.</p></li>
</ul>
<h3>Logical Internal Files</h3>
<p> Every software system maintains internal files in order to maintain its functional information and to function properly. These files hold logical data of the system.  This logical data may contain both functional data and control data.</p>
<ul class="list">
<li><p><b>Simple</b> - if number of record types are low</p></li>
<li><p><b>Complex</b> - if number of record types are high</p></li>
<li><p><b>Average</b> - in between simple and complex.</p></li>
</ul>
<h3>External Interface Files</h3>
<p> Software system may need to share its files with some external software or it may need to pass the file for processing or as parameter to some function. All these files are counted as external interface files.</p>
<ul class="list">
<li><p><b>Simple</b> - if number of record types in shared file are low</p></li>
<li><p><b>Complex</b> - if number of record types in shared file are high</p></li>
<li><p><b>Average</b> - in between simple and complex.</p></li>
</ul>
<h3>External Inquiry </h3>
<p> An inquiry is a combination of input and output, where user sends some data to inquire about as input and the system responds to the user with the output of inquiry processed.  The complexity of a query is more than External Input and External Output.  Query is said to be unique if its input and output are unique in terms of format and data.</p>
<ul class="list">
<li><p><b>Simple</b> - if query needs low processing and yields small amount of output data</p></li>
<li><p><b>Complex</b> - if query needs high process and yields large amount of output data</p></li>
<li><p><b>Average</b> - in between simple and complex.</p></li>
</ul>
<p>Each of these parameters in the system is given weightage according to their class and complexity.  The table below mentions the weightage given to each parameter:</p>
<table class="src">
<tr>
<th>Parameter</th>
<th>Simple</th>
<th>Average</th>
<th>Complex</th>
</tr>
<tr>
<td>Inputs</td>
<td>3</td>
<td>4</td>
<td>6</td>
</tr>
<tr>
<td>Outputs</td>
<td>4</td>
<td>5</td>
<td>7</td>
</tr>
<tr>
<td>Enquiry</td>
<td>3</td>
<td>4</td>
<td>6</td>
</tr>
<tr>
<td>Files</td>
<td>7</td>
<td>10</td>
<td>15</td>
</tr>
<tr>
<td>Interfaces</td>
<td>5</td>
<td>7</td>
<td>10</td>
</tr>
</table>
<p>The table above yields raw Function Points. These function points are  adjusted according to the environment complexity. System is described using  fourteen different characteristics:</p>
<ul class="list">
<li>Data communications</li>
<li>Distributed processing</li>
<li>Performance objectives</li>
<li>Operation configuration load</li>
<li>Transaction rate</li>
<li>Online data entry,</li>
<li>End user efficiency</li>
<li>Online update</li>
<li>Complex processing logic</li>
<li>Re-usability</li>
<li>Installation ease</li>
<li>Operational ease</li>
<li>Multiple sites</li>
<li>Desire to facilitate changes</li>
</ul>
<p>These characteristics factors are then rated from 0 to 5, as mentioned below:</p>
<ul class="list">
<li>No influence</li>
<li>Incidental</li>
<li>Moderate</li>
<li>Average</li>
<li>Significant</li>
<li>Essential</li>
</ul>
<p>All ratings are then summed up as N. The value of N ranges from 0 to 70 (14 types of characteristics x 5 types of ratings).  It is used to calculate Complexity Adjustment Factors (CAF), using the following formulae:</p>
<pre class="prettyprint notranslate;">
CAF = 0.65 + 0.01N
</pre>
<p>Then,</p>
<pre class="prettyprint notranslate;">
Delivered Function Points (FP)= CAF x Raw FP
</pre>

<title>Software Implementation</title>

<h1>Software Implementation</h1>

<p>In this chapter, we will study about programming methods, documentation and challenges in software implementation.</p>

<h2>Structured Programming</h2>

<p>In the process of coding, the lines of code keep multiplying, thus, size of the software increases. Gradually, it becomes next to impossible to remember the flow of program. If one forgets how software and its underlying programs, files, procedures are constructed it then becomes very difficult to share, debug and modify the program. The solution to this is structured programming. It encourages the developer to use subroutines and loops instead of using simple jumps in the code, thereby bringing clarity in the code and improving its efficiency Structured programming also helps programmer to reduce coding time and organize code properly.</p>

<p>Structured programming states how the program shall be coded.  Structured programming uses three main concepts:</p>

<p><b>Top-down analysis</b> - A software is always made to perform some rational work. This rational work is known as problem in the software parlance. Thus it is very important that we understand how to solve the problem. Under top-down analysis, the problem is broken down into small pieces where each one has some significance. Each problem is individually solved and steps are clearly stated about how to solve the problem.</p>

<p><b>Modular Programming</b> - While programming, the code is broken down into smaller group of instructions. These groups are known as modules, subprograms or subroutines. Modular programming based on the understanding of top-down analysis. It discourages jumps using ‘goto’ statements in the program, which often makes the program flow non-traceable. Jumps are prohibited and modular format is encouraged in structured programming. </p>

<p><b>Structured Coding </b> - In reference with top-down analysis, structured coding sub-divides the modules into further smaller units of code in the order of their execution. Structured programming uses control structure, which controls the flow of the program, whereas structured coding uses control structure to organize its instructions in definable patterns.</p>

<h2>Functional Programming</h2>

<p>Functional programming is style of programming language, which uses the concepts of mathematical functions. A function in mathematics should always produce the same result on receiving the same argument. In procedural languages, the flow of the program runs through procedures, i.e. the control of program is transferred to the called procedure. While control flow is transferring from one procedure to another, the program changes its state.</p>

<p>In procedural programming, it is possible for a procedure to produce different results when it is called with the same argument, as the program itself can be in different state while calling it. This is a property as well as a drawback of procedural programming, in which the sequence or timing of the procedure execution becomes important.</p>

<p>Functional programming provides means of computation as mathematical functions, which produces results irrespective of program state. This makes it possible to predict the behavior of the program.</p>

<p>Functional programming uses the following concepts:</p>

<p><b>First class and High-order functions</b> - These functions have capability to accept another function as argument or they return other functions as results.</p>

<p><b>Pure functions</b> - These functions do not include destructive updates, that is, they do not affect any I/O or memory and if they are not in use, they can easily be removed without hampering the rest of the program.</p>

<p><b>Recursion</b> - Recursion is a programming technique where a function calls itself and repeats the program code in it unless some pre-defined condition matches. Recursion is the way of creating loops in functional programming.</p>

<p><b>Strict evaluation</b> - It is a method of evaluating the expression passed to a function as an argument. Functional programming has two types of evaluation methods, strict (eager) or non-strict (lazy). Strict evaluation always evaluates the expression before invoking the function. Non-strict evaluation does not evaluate the expression unless it is needed.</p>

<p><b>λ-calculus</b> - Most functional programming languages use λ-calculus as their type systems. λ-expressions are executed by evaluating them as they occur.</p>

<p>Common Lisp, Scala, Haskell, Erlang and F# are some examples of functional programming languages.</p>

<h2>Programming style</h2>

<p>Programming style is set of coding rules followed by all the programmers to write the code. When multiple programmers work on the same software project, they frequently need to work with the program code written by some other developer. This becomes tedious or at times impossible, if all developers do not follow some standard programming style to code the program. </p>

<p>An appropriate programming style includes using function and variable names relevant to the intended task, using well-placed indentation, commenting code for the convenience of reader and overall presentation of code. This makes the program code readable and understandable by all, which in turn makes debugging and error solving easier. Also, proper coding style helps ease the documentation and updation.</p>

<h3>Coding Guidelines</h3>

<p>Practice of coding style varies with organizations, operating systems and language of coding itself. </p>

<p>The following coding elements may be defined under coding guidelines of an organization:</p>

<p><b>Naming conventions</b> - This section defines how to name functions, variables, constants and global variables.</p>

<p><b>Indenting</b> - This is the space left at the beginning of line, usually 2-8 whitespace or single tab.</p>

<p><b>Whitespace</b> - It is generally omitted at the end of line.</p>

<p><b>Operators</b> - Defines the rules of writing mathematical, assignment and logical operators. For example, assignment operator ‘=’ should have space before and after it, as in “x = 2”.</p>

<p><b>Control Structures</b> - The rules of writing if-then-else, case-switch, while-until and for control flow statements solely and in nested fashion.</p>

<p><b>Line length and wrapping</b> - Defines how many characters should be there in one line, mostly a line is 80 characters long. Wrapping defines how a line should be wrapped, if is too long.</p>

<p><b>Functions</b> - This defines how functions should be declared and invoked, with and without parameters.</p>

<p><b>Variables</b> - This mentions how variables of different data types are declared and defined.</p>

<p><b>Comments</b> - This is one of the important coding components, as the comments included in the code describe what the code actually does and all other associated descriptions. This section also helps creating help documentations for other developers.</p>

<h2>Software Documentation</h2>

<p>Software documentation is an important part of software process. A well written document provides a great tool and means of information repository necessary to know about software process. Software documentation also provides information about how to use the product.</p>

<p>A well-maintained documentation should involve the following documents:</p>

<p><b>Requirement documentation </b> - This documentation works as key tool for software designer, developer and the test team to carry out their respective tasks. This document contains all the functional, non-functional and behavioral description of the intended software.  </p>

<p>Source of this document can be previously stored data about the software, already running software at the client’s end, client’s interview, questionnaires and research. Generally it is stored in the form of spreadsheet or word processing document with the high-end software management team.</p>

<p>This documentation works as foundation for the software to be developed and is majorly used in verification and validation phases. Most test-cases are built directly from requirement documentation.</p>

<p><b>Software Design documentation </b> - These documentations contain all the necessary information, which are needed to build the software. It contains: <b>(a)</b> High-level software architecture, <b>(b)</b> Software design details, <b>(c)</b> Data flow diagrams, <b>(d)</b> Database design</p>

<p>These documents work as repository for developers to implement the software. Though these documents do not give any details on how to code the program, they give all necessary information that is required for coding and implementation. </p>

<p><b>Technical documentation</b> - These documentations are maintained by the developers and actual coders. These documents, as a whole, represent information about the code. While writing the code, the programmers also mention objective of the code, who wrote it, where will it be required, what it does and how it does, what other resources the code uses, etc.</p>

<p>The technical documentation increases the understanding between various programmers working on the same code. It enhances re-use capability of the code. It makes debugging easy and traceable.</p>

<p>There are various automated tools available and some comes with the programming language itself. For example java comes JavaDoc tool to generate technical documentation of code.</p>

<p><b>User documentation</b> - This documentation is different from all the above explained. All previous documentations are maintained to provide information about the software and its development process. But user documentation explains how the software product should work and how it should be used to get the desired results.</p>

<p>These documentations may include, software installation procedures, how-to guides, user-guides, uninstallation method and special references to get more information like license updation etc.</p>

<h2>Software Implementation Challenges</h2>

<p>There are some challenges faced by the development team while implementing the software. Some of them are mentioned below:</p>

<p><b>Code-reuse</b> - Programming interfaces of present-day languages are very sophisticated and are equipped huge library functions. Still, to bring the cost down of end product, the organization management prefers to re-use the code, which was created earlier for some other software. There are huge issues faced by programmers for compatibility checks and deciding how much code to re-use.</p>

<p><b>Version Management</b> - Every time a new software is issued to the customer, developers have to maintain version and configuration related documentation. This documentation needs to be highly accurate and available on time.</p>

<p><b>Target-Host</b> - The software program, which is being developed in the organization, needs to be designed for host machines at the customers end. But at times, it is impossible to design a software that works on the target machines.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Software Testing Overview</title>

<h1>Software Testing Overview</h1>

<p>Software Testing is evaluation of the software against requirements gathered from users and system specifications. Testing is conducted at the phase level in software development life cycle or at module level in program code. Software testing comprises of Validation and Verification.</p>

<h2>Software Validation</h2>

<p>Validation is process of examining whether or not the software satisfies the user requirements. It is carried out at the end of the SDLC. If the software matches requirements for which it was made, it is validated.</p>

<h2>Software Verification</h2>

<p>Verification is the process of confirming if the software is meeting the business requirements, and is developed adhering to the proper specifications and methodologies. </p>

<p>Target of the test are - </p>

<p><b>Errors</b> - These are actual coding mistakes made by developers. In addition, there is a difference in output of software and desired output, is considered as an error.</p>

<p><b>Fault</b> - When error exists fault occurs. A fault, also known as a bug, is a result of an error which can cause system to fail.</p>

<p><b>Failure </b> - failure is said to be the inability of the system to perform the desired task.  Failure occurs when fault exists in the system.</p>

<h2>Manual Vs Automated Testing</h2>

<p>Testing can either be done manually or using an automated testing tool:</p>

<p><b>Manual</b> - This testing is performed without taking help of automated testing tools. The software tester prepares test cases for different sections and levels of the code, executes the tests and reports the result to the manager. </p>

<p>Manual testing is time and resource consuming. The tester needs to confirm whether or not right test cases are used. Major portion of testing involves manual testing.</p>

<p><b>Automated</b> This testing is a testing procedure done with aid of automated testing tools. The limitations with manual testing can be overcome using automated test tools.</p>

<p>A test needs to check if a webpage can be opened in Internet Explorer. This can be easily done with manual testing. But to check if the web-server can take the load of 1 million users, it is quite impossible to test manually. </p>

<p>There are software and hardware tools which helps tester in conducting load testing, stress testing, regression testing.</p>

<h2>Testing Approaches</h2>

<p>Tests can be conducted based on two approaches – </p>

<p>When functionality is being tested without taking the actual implementation in concern it is known as black-box testing.  The other side is known as white-box testing where not only functionality is tested but the way it is implemented is also analyzed.</p>

<p>Exhaustive tests are the best-desired method for a perfect testing. Every single possible value in the range of the input and output values is tested. It is not possible to test each and every value in real world scenario if the range of values is large.</p>

<h3>Black-box testing</h3>

<p>It is carried out to test functionality of the program. It is also called ‘Behavioral’ testing. The tester in this case, has a set of input values and respective desired results. On providing input, if the output matches with the desired results, the program is tested ‘ok’, and problematic otherwise. </p>

<p>In this testing method, the design and structure of the code are not known to the tester, and testing engineers and end users conduct this test on the software.</p>

<p>Black-box testing techniques:</p>

<p><b>Equivalence class</b> - The input is divided into similar classes.  If one element of a class passes the test, it is assumed that all the class is passed.</p>

<p><b>Boundary values</b> - The input is divided into higher and lower end values.  If these values pass the test, it is assumed that all values in between may pass too.</p>

<p><b>Cause-effect graphing</b> - In both previous methods, only one input value at a time is tested. Cause (input) – Effect (output) is a testing technique where combinations of input values are tested in a systematic way.</p>

<p><b>Pair-wise Testing</b> - The behavior of software depends on multiple parameters. In pairwise testing, the multiple parameters are tested pair-wise for their different values.</p>

<p><b>State-based testing</b> - The system changes state on provision of input. These systems are tested based on their states and input.</p>

<h3>White-box testing</h3>

<p> It is conducted to test program and its implementation, in order to improve code efficiency or structure. It is also known as ‘Structural’ testing.</p>

<p>In this testing method, the design and structure of the code are known to the tester. Programmers of the code conduct this test on the code.</p>

<p>The below are some White-box testing techniques:</p>

<p><b>Control-flow testing</b> - The purpose of the control-flow testing to set up test cases which covers all statements and branch conditions.  The branch conditions are tested for both being true and false, so that all statements can be covered.</p>

<p><b>Data-flow testing</b> - This testing technique emphasis to cover all the data variables included in the program.  It tests where the variables were declared and defined and where they were used or changed.</p>

<h2>Testing Levels</h2>

<p>Testing itself may be defined at various levels of SDLC. The testing process runs parallel to software development. Before jumping on the next stage, a stage is tested, validated and verified.</p>

<p>Testing separately is done just to make sure that there are no hidden bugs or issues left in the software.  Software is tested on various levels -</p>

<h3>Unit Testing</h3>

<p> While coding, the programmer performs some tests on that unit of program to know if it is error free.  Testing is performed under white-box testing approach. Unit testing helps developers decide that individual units of the program are working as per requirement and are error free.</p>

<h3>Integration Testing</h3>

<p>Even if the units of software are working fine individually, there is a need to find out if the units if integrated together would also work without errors. For example, argument passing and data updation etc.</p>

<h3>System Testing </h3>

<p>The software is compiled as product and then it is tested as a whole.  This can be accomplished using one or more of the following tests:</p>

<p><b>Functionality testing</b> - Tests all functionalities of the software against the requirement.</p>

<p><b>Performance testing</b> - This test proves how efficient the software is.  It tests the effectiveness and average time taken by the software to do desired task.  Performance testing is done by means of load testing and stress testing where the software is put under high user and data load under various environment conditions.</p>

<p><b>Security & Portability</b> - These tests are done when the software is meant to work on various platforms and accessed by number of persons.</p>

<h3>Acceptance Testing</h3>

<p> When the software is ready to hand over to the customer it has to go through last phase of testing where it is tested for user-interaction and response.  This is important because even if the software matches all user requirements and if user does not like the way it appears or works, it may be rejected.</p>

<p><b>Alpha testing</b> - The team of developer themselves perform alpha testing by using the system as if it is being used in work environment. They try to find out how user would react to some action in software and how the system should respond to inputs.</p>

<p><b>Beta testing</b> - After the software is tested internally, it is handed over to the users to use it under their production environment only for testing purpose. This is not as yet the delivered product. Developers expect that users at this stage will bring minute problems, which were skipped to attend.</p>

<h3>Regression Testing</h3>

<p>Whenever a software product is updated with new code, feature or functionality, it is tested thoroughly to detect if there is any negative impact of the added code. This is known as regression testing.</p>

<h2>Testing Documentation</h2>

<p>Testing documents are prepared at different stages -</p>

<h3>Before Testing</h3>

<p>Testing starts with test cases generation. Following documents are needed for reference –</p>

<p><b>SRS document</b> - Functional Requirements document</p>

<p><b>Test Policy document</b> - This describes how far testing should take place before releasing the product.</p>

<p><b>Test Strategy document</b> - This mentions detail aspects of test team, responsibility matrix and rights/responsibility of test manager and test engineer.</p>

<p><b>Traceability Matrix document</b> - This is SDLC document, which is related to requirement gathering process. As new requirements come, they are added to this matrix. These matrices help testers know the source of requirement.  They can be traced forward and backward.</p>

<h3>While Being Tested</h3>

<p>The following documents may be required while testing is started and is being done:</p>

<p><b>Test Case document</b> - This document contains list of tests required to be conducted.  It includes Unit test plan, Integration test plan, System test plan and Acceptance test plan.</p>

<p><b>Test description</b> - This document is a detailed description of all test cases and procedures to execute them.</p>

<p><b>Test case report</b> - This document contains test case report as a result of the test.</p>

<p><b>Test logs</b> - This document contains test logs for every test case report.</p>

<h3>After Testing</h3>

<p>The following documents may be generated after testing :</p>

<p><b>Test summary</b> - This test summary is collective analysis of all test reports and logs.  It summarizes and concludes if the software is ready to be launched. The software is released under version control system if it is ready to launch.</p>

<h2>Testing vs. Quality Control, Quality Assurance and Audit</h2>

<p>We need to understand that software testing is different from software quality assurance, software quality control and software auditing.</p>

<p><b>Software quality assurance</b> - These are software development process monitoring means, by which it is assured that all the measures are taken as per the standards of organization. This monitoring is done to make sure that proper software development methods were followed.</p>

<p><b>Software quality control</b> - This is a system to maintain the quality of software product. It may include functional and non-functional aspects of software product, which enhance the goodwill of the organization. This system makes sure that the customer is receiving quality product for their requirement and the product certified as ‘fit for use’.</p>

<p><b>Software audit</b> - This is a review of procedure used by the organization to develop the software.  A team of auditors, independent of development team examines the software process, procedure, requirements and other aspects of SDLC.  The purpose of software audit is to check that software and its development process, both conform standards, rules and regulations.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Software Maintenance Overview</title>

<h1>Software Maintenance Overview</h1>

<p>Software maintenance is widely accepted part of SDLC now a days.  It stands for all the modifications and updations done after the delivery of software product.  There are number of reasons, why modifications are required, some of them are briefly mentioned below:</p>

<p><b>Market Conditions </b> - Policies, which changes over the time, such as taxation and newly introduced constraints like, how to maintain bookkeeping, may trigger need for modification.</p>

<p><b>Client Requirements</b> - Over the time, customer may ask for new features or functions in the software.</p>

<p><b>Host Modifications </b> - If any of the hardware and/or platform (such as operating system) of the target host changes, software changes are needed to keep adaptability.</p>

<p><b>Organization Changes</b> - If there is any business level change at client end, such as reduction of organization strength, acquiring another company, organization venturing into new business, need to modify in the original software may arise.</p>

<h2>Types of maintenance </h2>

<p>In a software lifetime, type of maintenance may vary based on its nature.  It may be just a routine maintenance tasks as some bug discovered by some user or it may be a large event in itself based on maintenance size or nature.  Following are some types of maintenance based on their characteristics:</p>

<p><b>Corrective Maintenance</b> - This includes modifications and updations done in order to correct or fix problems, which are either discovered by user or concluded by user error reports.</p>

<p><b>Adaptive Maintenance</b> - This includes modifications and updations applied to keep the software product up-to date and tuned to the ever changing world of technology and business environment.</p>

<p><b>Perfective Maintenance</b> - This  includes modifications and updates done in order to keep the software usable over long period of time. It includes new features, new user requirements for refining the software and improve  its reliability and performance.</p>

<p><b>Preventive Maintenance</b> - This includes modifications and updations to prevent future problems of the software. It aims to attend problems, which are not significant at this moment but may cause serious issues in future.</p>

<h2>Cost of Maintenance</h2>

<p>Reports suggest that the cost of maintenance is high. A study on estimating software maintenance found that the cost of maintenance is as high as 67% of the cost of entire software process cycle.</p>

<p>On an average, the cost of software maintenance is more than 50% of all SDLC phases. There are various factors, which trigger maintenance cost go high, such as: </p>

<h3>Real-world factors affecting Maintenance Cost</h3>

<h3>Software-end factors  affecting Maintenance Cost</h3>

<h2>Maintenance Activities</h2>

<p>IEEE provides a framework for sequential maintenance process activities.  It can be used in iterative manner and can be extended so that customized items and processes can be included. </p>

<p>These activities go hand-in-hand with each of the following phase:</p>

<p><b>Identification &amp; Tracing</b> - It involves activities pertaining to identification of requirement of  modification or maintenance.  It is generated by user or system may itself report via logs or error messages.Here, the maintenance type is classified also.</p>

<p><b>Analysis</b> - The modification is analyzed for its impact on the system including safety and security implications. If probable impact is severe, alternative solution is looked for. A set of required modifications is then materialized into requirement specifications. The cost of modification/maintenance is analyzed and estimation is concluded.</p>

<p><b>Design</b> - New modules, which need to be replaced or modified, are designed against requirement specifications set in the previous stage. Test cases are created for validation and verification.</p>

<p><b>Implementation</b> - The new modules are coded with the help of structured design created in the design step.Every programmer is expected to do unit testing in parallel.</p>

<p><b>System Testing</b> - Integration testing is done among newly created modules. Integration testing is also carried out between  new modules and the system. Finally the system is tested as a whole, following regressive testing procedures.</p>

<p><b>Acceptance Testing</b> - After testing the system internally, it is tested for acceptance with the help of users. If at this state, user complaints some issues they are addressed or noted to address in next iteration.</p>

<p><b>Delivery</b> - After acceptance test, the system is deployed all over the organization either by small update package or fresh installation of the system. The final testing takes place at client end after the software is delivered. </p>

<p>Training facility is provided if required, in addition to the hard copy of user manual.</p>

<p><b>Maintenance management</b> - Configuration management is an essential part of system maintenance. It is aided with version control tools to control versions, semi-version or patch management.</p>

<h2>Software Re-engineering</h2>

<p>When we need to update the software to keep it to the current market, without impacting its functionality, it is called software re-engineering. It is a thorough process  where the design of software is changed and programs are re-written.</p>

<p>Legacy software cannot keep tuning with the latest technology available in the market. As the hardware become obsolete, updating of software becomes a headache. Even if software  grows old with time, its functionality does not.  </p>

<p>For example, initially Unix was developed in assembly language. When language C came into existence, Unix was re-engineered in C, because working in assembly language was difficult.</p>

<p>Other than  this, sometimes programmers notice that few parts of software need more maintenance than others and they  also need re-engineering.</p>

<h3>Re-Engineering Process</h3>

<p>There are few important terms used in Software re-engineering</p>

<h3>Reverse Engineering</h3>

<p>It is a process to achieve system specification by thoroughly analyzing, understanding the existing system.  This process can be seen as reverse SDLC model, i.e. we try to get higher abstraction level by analyzing lower abstraction levels.</p>

<p>An existing system is previously implemented design, about which we know nothing.  Designers then do reverse engineering by looking at the code and try to get the design.  With design in hand, they try to conclude the specifications.  Thus, going in reverse from code to system specification.</p>

<h3>Program Restructuring</h3>

<p>It is a process to re-structure and re-construct the existing software.  It is all about re-arranging the source code, either in same programming language or from one programming language to a different one.  Restructuring can have either source code-restructuring and data-restructuring or both.</p>

<p>Re-structuring does not impact the functionality of the software but enhance reliability and maintainability.  Program  components, which cause errors very frequently can be changed, or updated with re-structuring.</p>

<p>The dependability of software on obsolete hardware platform can be removed via re-structuring.</p>

<h3>Forward Engineering</h3>

<p>Forward engineering is a process of obtaining desired software from the specifications in hand which were brought down by means of reverse engineering. It assumes that there was some software engineering already done in the past.</p>

<p> Forward engineering is same as software engineering process with only one difference – it is carried out always after reverse engineering.</p>

<h2>Component reusability</h2>

<p>A component is a part of software program code, which executes an independent task in the system.  It can be a small module or sub-system itself.</p>

<h3>Example</h3>

<p>The login procedures used on the web can be considered as components, printing system in software can be seen as a component of the software.</p>

<p>Components have high  cohesion of functionality and lower rate of coupling, i.e. they work independently and can perform tasks without depending on other modules.</p>

<p>In OOP, the objects are designed are very specific to their concern and have fewer chances to be used in some other software. </p>

<p>In modular programming, the modules are coded to perform specific tasks which can be used across number of other software programs.</p>

<p>There is a whole new vertical, which is based on re-use of software component, and is known as Component Based Software Engineering (CBSE).</p>

<p>Re-use can be done at various levels</p>

<p><b>Application level </b> - Where an entire application is used as sub-system of new software.</p>

<p><b>Component level </b> -  Where sub-system of an application is used.</p>

<p><b>Modules level </b> - Where functional modules are re-used.</p>

<p>Software components provide interfaces, which can be used to establish communication among different components.</p>

<h3>Reuse Process</h3>

<p>Two kinds of method can be adopted: either by keeping requirements same and adjusting components or by keeping components same and modifying requirements.</p>

<p><b>Requirement Specification</b> - The functional and non-functional requirements are specified, which a software product must comply to, with the help of existing system, user input or both. </p>

<p><b>Design</b> - This is also a standard SDLC process step, where requirements are defined in terms of software parlance.  Basic architecture of system as a whole and its sub-systems are created.</p>

<p><b>Specify Components </b> - By studying the software design, the designers segregate the entire system into smaller components or sub-systems. One  complete software design turns into a collection of a huge set of components working together.</p>

<p><b>Search Suitable Components</b> - The software component repository is referred by designers to search for the matching component, on the basis of functionality and intended software requirements..</p>

<p><b>Incorporate Components</b> - All matched components are packed together to shape them as complete software.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Software Case Tools Overview</title>

<h1>Software Case Tools Overview</h1>

<h2>CASE Tools </h2>

<p>CASE tools are set of software application programs, which are used to automate SDLC activities. CASE tools are used by software project managers, analysts and engineers to develop  software system. </p>

<p>There are number of CASE tools available to simplify various stages of Software Development Life Cycle such as Analysis tools, Design tools, Project management tools, Database Management tools, Documentation tools are to name a few. </p>

<p>Use of CASE tools accelerates the development of project to produce desired result and helps to uncover flaws before moving ahead with next stage in software development. </p>

<h2>Components of CASE Tools</h2>

<p>CASE tools can be broadly divided into the following parts based on their use at a particular SDLC stage:</p>

<p><b>Central Repository</b> - CASE tools require  a central repository, which can serve as a source of common, integrated and consistent information.  Central repository  is a central place of storage where product specifications, requirement documents, related reports and diagrams, other useful information regarding management is stored.  Central repository also serves as data dictionary.</p>

<p><b>Upper Case Tools</b> - Upper CASE tools are used in planning, analysis and design stages of SDLC.</p>

<p><b>Lower Case Tools</b> - Lower CASE tools are used in implementation, testing and maintenance.</p>

<p><b>Integrated Case Tools</b> - Integrated CASE tools are helpful in all the stages of SDLC, from Requirement gathering to Testing and documentation.</p>

<p>CASE tools can be grouped together if they have similar functionality, process activities and capability of getting integrated with other tools. </p>

<h2>Scope of Case Tools</h2>

<p>The scope of CASE tools goes throughout the SDLC.</p>

<h2>Case Tools Types</h2>

<p>Now we briefly go through various CASE tools</p>

<h3>Diagram tools </h3>

<p>These tools are used to represent  system components, data and control flow among various software components and system structure in a graphical form.  For example, Flow Chart Maker tool for creating state-of-the-art flowcharts.</p>

<h3>Process Modeling Tools</h3>

<p>Process modeling is method to create software process model, which is  used to develop the software. Process modeling tools help the managers to choose a process model or modify it as per the requirement of software product. For example, EPF Composer</p>

<h3>Project Management Tools</h3>

<p>These tools are used for project planning, cost and effort estimation, project scheduling and resource planning. Managers have to strictly comply project execution with every mentioned step in software project management. Project management tools help in storing and sharing project information in real-time throughout the organization. For example, Creative Pro Office, Trac Project, Basecamp.</p>

<h3>Documentation Tools</h3>

<p>Documentation in a software project starts prior to the software process, goes throughout all phases of SDLC and after the completion of the project. </p>

<p>Documentation tools generate documents for technical users and end users. Technical users are mostly in-house professionals of the development team who refer to system manual, reference manual, training manual, installation manuals etc. The end user documents describe the functioning and how-to of the system such as user manual. For example, Doxygen, DrExplain, Adobe RoboHelp for documentation.</p>

<h3>Analysis Tools</h3>

<p>These tools help to gather requirements, automatically check for any inconsistency, inaccuracy in the diagrams, data redundancies or erroneous omissions. For example, Accept 360, Accompa, CaseComplete for requirement analysis, Visible Analyst for total analysis.</p>

<h3>Design Tools</h3>

<p>These tools help software designers to design the block structure of the software, which may further be broken down in smaller modules using refinement techniques. These tools provides detailing of each module and interconnections among modules. For example, Animated Software Design</p>

<h3>Configuration Management Tools</h3>

<p>An instance of software is released under one version.  Configuration Management tools deal with –</p>

<p>CASE tools help in this by automatic tracking, version management and release management. For example,  Fossil, Git, Accu REV.</p>

<h3>Change Control Tools</h3>

<p>These tools are considered as a part of configuration management tools. They deal with changes made to the software after its baseline is fixed or when the software is first released. CASE tools automate change tracking, file management, code management and more. It also helps in enforcing change policy of the organization.</p>

<h3>Programming Tools </h3>

<p>These tools consist of programming environments like IDE (Integrated Development Environment), in-built modules library and simulation tools. These tools provide comprehensive aid in building software product and include features for simulation and testing. For example,  Cscope to search code in C, Eclipse.</p>

<h3>Prototyping Tools </h3>

<p>Software prototype is simulated version of the intended software product. Prototype provides initial look and feel of the product and simulates few aspect of actual product.  </p>

<p>Prototyping CASE tools essentially come with graphical libraries. They can create hardware independent user interfaces and design. These tools help us to build rapid prototypes based on existing information. In addition, they provide simulation of software prototype. For example,  Serena prototype composer, Mockup Builder.</p>

<h3>Web Development Tools</h3>

<p>These tools assist in designing web pages with all allied elements like  forms, text, script, graphic and so on. Web tools also provide live preview of what is being developed and how will it look after completion. For example,  Fontello, Adobe Edge Inspect, Foundation 3, Brackets.</p>

<h3>Quality Assurance Tools</h3>

<p>Quality assurance in a software organization is monitoring the engineering process and methods adopted to develop the software product in order to ensure conformance of quality as per organization standards. QA tools consist of configuration and change control tools and software testing tools. For example,  SoapTest, AppsWatch, JMeter.</p>

<h3>Maintenance Tools</h3>

<p>Software maintenance includes modifications in the software product after it is delivered.  Automatic logging and error reporting techniques, automatic error ticket generation and root cause Analysis are few CASE tools, which help software organization in maintenance phase of SDLC. For example,  Bugzilla for defect tracking, HP Quality Center.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>SE - Exams Questions with Answers</title>

<h1>SE Exams Questions with Answers </h1>

<p>These selected questions and answers are prepared from <a href="/software_engineering/index.htm">Software Engineering</a> Exam point of view and will also help in quick revision to get good marks in Software Engineering Examination. These questions has been prepared for the computer science graduates (B.C.A, M.C.A, B.Tech, B.E. and so...), to help them understand and revise the basic to advanced concepts related to Software Engineering.</p>

<p>Following is the selected list of questions and their answers and will help in quick revision to get good marks in Software Engineering Examination.</p>

<h2>Software Engineering Overview</h2>

<p><a href="/software_engineering/se_overview_qa1.htm">Explain the meaning of software danger and its importance in concerned of software engineering.</a></p>

<p><a href="/software_engineering/se_overview_qa2.htm">Describe the importance of software Engineering? What should be steps taken under the process of developing a software system.</a></p>

<p><a href="/software_engineering/se_overview_qa3.htm">Explain the principles which play a major role in development of software.</a></p>

<p><a href="/software_engineering/se_overview_qa4.htm">Explain the design principle of software Engineering.</a></p>

<h2>Software Engineering Process</h2>

<p><a href="/software_engineering/se_process_qa1.htm">Describe the components and quality which is necessary for the documents of software specification.</a></p>

<p><a href="/software_engineering/se_process_qa2.htm">What are the benefits of metrics in software engineering?</a></p>

<p><a href="/software_engineering/se_process_qa3.htm">Explain the term Configuration management.</a></p>

<p><a href="/software_engineering/se_process_qa4.htm">Explain concept of data flow diagram.</a></p>

<p><a href="/software_engineering/se_process_qa5.htm">Write a short note on review process.</a></p>

<p><a href="/software_engineering/se_process_qa6.htm">Define the blue print methodology.</a></p>

<p><a href="/software_engineering/se_process_qa7.htm">Give your views about what is more important - the product or the process.</a></p>

<h2>Software Engineering Quality</h2>

<p><a href="/software_engineering/se_quality_qa1.htm">Write a short note on Software Testing process.</a></p>

<p><a href="/software_engineering/se_quality_qa2.htm">What are the differences between verification and validation in software development?</a></p>

<p><a href="/software_engineering/se_quality_qa3.htm">Give the benefits of verification and validation in software development and tell about the techniques of verification and validation in the process of software development.</a></p>

<p><a href="/software_engineering/se_quality_qa4.htm">Define the meaning of software quality and detail the factors which affects the quality not productivity of a software product?</a></p>

<p><a href="/software_engineering/se_quality_qa5.htm">Give the detail  of quality parameters which are used in a software system.</a></p>

<p><a href="/software_engineering/se_quality_qa6.htm">Define the meaning of quality assurance. Explain the role of testing in Quality assurance.</a></p>

<p><a href="/software_engineering/se_quality_qa7.htm">What are the difference between alpha testing and Beta testing?</a></p>

<p><a href="/software_engineering/se_quality_qa8.htm">What are the difference between white box testing and black box testing techniques?</a></p>

<p><a href="/software_engineering/se_quality_qa9.htm">Explain software reliability and define how software and hardware reliability related to each other.</a></p>

<p><a href="/software_engineering/se_quality_qa10.htm">Write short note on Software failure, Black box testing, White box testing and Stress Testing.</a></p>

<p><a href="/software_engineering/se_quality_qa11.htm">What are test cases in Software Engineering?</a></p>

<h2>Software Engineering Models</h2>

<p><a href="/software_engineering/se_models_qa1.htm">Explain the various types of models which used in software Engineering.</a></p>

<p><a href="/software_engineering/se_models_qa2.htm">Explain the generic views of software Engineering.</a></p>

<p><a href="/software_engineering/se_models_qa3.htm">What is Coding Standard?</a></p>

<p><a href="/software_engineering/se_models_qa4.htm">Explain the objectives of a)coding b) structured programming.</a></p>

<p><a href="/software_engineering/se_models_qa5.htm">What is the process of implementation of a software?</a></p>

<p><a href="/software_engineering/se_models_qa6.htm">Explain the term, software maintenance.</a></p>

<p><a href="/software_engineering/se_models_qa7.htm">Explain the waterfall model in detail.</a></p>

<p><a href="/software_engineering/se_models_qa8.htm">Give a description of prototyping model.</a></p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Software Engineering Interview Questions</title>

<h1>Software Engineering Interview Questions</h1>

<p>Dear readers, these <b>Software Engineering Interview Questions</b> have been designed especially to get you acquainted with the nature of questions you may encounter during your interview for the subject of <b>Software Engineering</b>. As per my experience, good interviewers hardly planned to ask any particular question during your interview, normally questions start with some basic concept of the subject and later they continue based on further discussion and what you answer:</p>

<p><b>Q.What is computer software?</b></p>

<p> <b>A.</b> Computer software is a complete package, which includes software program, its documentation and user guide on how to use the software.</p>

<p><b>Q.Can you differentiate computer software and computer program?</b></p>

<p><b>A.</b> A computer program is piece of programming code which performs a well defined task where as software includes programming code, its documentation and user guide.</p>

<p><b>Q.What is software engineering?</b></p>

<p><b>A.</b> Software engineering is an engineering branch associated with software system development.  </p>

<p><b>Q.When you know programming, what is the need to learn software engineering concepts?</b></p>

<p><b>A.</b> A person who knows how to build a wall may not be good at building an entire house.  Likewise, a person who can write programs may not have knowledge of other concepts of Software Engineering.  The software engineering concepts guide programmers on how to assess requirements of end user, design the algorithms before actual coding starts, create programs by coding, testing the code and its documentation. </p>

<p><b>Q.What is software process or Software Development Life Cycle (SDLC)?</b></p>

<p><b>A.</b>Software Development Life Cycle, or software process is the systematic development of  software by following every stage in the development process namely, Requirement Gathering, System Analysis, Design, Coding, Testing, Maintenance and Documentation in that order. </p>

<p><b>Q.What are SDLC models available?</b></p>

<p><b>A.</b> There are several SDLC models available such as Waterfall Model, Iterative Model, Spiral model, V-model and Big-bang Model etc.</p>

<p><b>Q.What are various phases of SDLC?</b></p>

<p><b>A.</b> The generic phases of SDLC are: Requirement Gathering, System Analysis and Design, Coding, Testing and implementation. The phases depend upon the model we choose to develop software.</p>

<p><b>Q.Which SDLC model is the best?</b></p>

<p><b>A.</b> SDLC Models are adopted as per requirements of development process.  It may very software-to-software to ensuring which model is suitable.</p>

<p>We can select the best SDLC model if following answers are satisfied - </p>

<p><b>Q.What is software project management?</b></p>

<p><b>A.</b> Software project management is process of managing all activities like time, cost and quality management involved in software development.</p>

<p><b>Q.Who is software project manager?</b></p>

<p><b>A. </b> A software project manager is a person who undertakes the responsibility of carrying out the software project.</p>

<p><b>Q.What does software project manager do?</b></p>

<p><b>A. </b> Software project manager is engaged with software management activities. He is responsible for  project planning, monitoring the progress, communication among stakeholders, managing risks and resources, smooth execution of development and delivering the project within time, cost and quality contraints. </p>

<p><b>Q.What is software scope?</b></p>

<p><b>A.</b>  Software scope is a well-defined boundary, which encompasses all the activities that are done to develop and deliver the software product.</p>

<p>The software scope clearly defines all functionalities and artifacts to be delivered as a part of the software. The scope identifies what the product will do and what it will not do, what the end product will contain and what it will not contain. </p>

<p><b>Q.What is project estimation?</b></p>

<p><b>A.</b> It is a process to estimate various aspects of software product in order to calculate the cost of development in terms of efforts, time and resources. This estimation can be derived from past experience, by consulting experts or by using pre-defined formulas.</p>

<p><b>Q.How can we derive the size of software product?</b></p>

<p><b>A.</b>  Size of software product can be calculated using either of two methods - </p>

<p><b>Q.What are function points?</b></p>

<p><b>A.</b>  Function points are the various features provided by the software product.  It is considered as a unit of measurement for software size. </p>

<p><b>Q.What are software project estimation techniques available?</b></p>

<p><b>A.</b> There are many estimation techniques available.The most widely used are - </p>

<p><b>Q.What is baseline?</b></p>

<p><b>A.</b> Baseline is a measurement that defines completeness of a phase. After all activities associated with a particular phase are  accomplished, the phase is complete and acts as a baseline for next phase.</p>

<p><b>Q.What is Software configuration management?</b></p>

<p><b>A.</b> Software Configuration management is a process of tracking and controlling the changes in software in terms of the requirements, design, functions and development of the product.</p>

<p><b>Q.What is change control?</b></p>

<p><b>A.</b> Change control is function of configuration management, which ensures that all changes made to software system are consistent and made as per organizational rules and regulations.</p>

<p><b>Q.How can you measure project execution?</b></p>

<p><b>A.</b> We can measure project execution by means of Activity Monitoring, Status Reports and Milestone Checklists.</p>

<p><b>Q.Mention some project management tools.</b></p>

<p><b>A.</b> There are various project management tools  used as per the requirements of software project and organization policies.  They include Gantt Chart, PERT Chart, Resource Histogram, Critical Path Analysis, Status Reports, Milestone Checklists etc.</p>

<p><b>Q.What are software requirements?</b></p>

<p><b>A.</b> Software requirements are functional description of proposed software system.  Requirements are assumed to be the description of target system, its functionalities and features. Requirements convey the expectations of users from the system.</p>

<p><b>Q.What is feasibility study?</b></p>

<p><b>A.</b> It is a measure to assess how practical and beneficial the software project development will be for an organization. The software analyzer conducts a thorough study to  understand economic, technical and operational feasibility of the project.</p>

<p><b>Economic </b> - Resource transportation, cost for training, cost of additional utilities and tools and overall estimation of costs and benefits of the project.</p>

<p><b>Technical </b> - Is it possible to develop this system ? Assessing suitability of machine(s) and operating system(s) on which software will execute, existing developers’ knowledge and skills, training, utilities or tools for project.</p>

<p><b>Operational </b> - Can the organization adjust smoothly to the changes done as per the demand of project ? Is the problem worth solving ? </p>

<p><b>Q.How can you gather requirements?</b></p>

<p><b>A.</b>  Requirements can be gathered from users via interviews, surveys, task analysis, brainstorming, domain analysis, prototyping, studying existing usable version of software, and by observation. </p>

<p><b>Q.What is SRS?</b></p>

<p><b>A.</b>  SRS or Software Requirement Specification is a document produced at the time of requirement gathering process. It can be also seen as a process of refining requirements and documenting them.</p>

<p><b>Q.What are functional requirements?</b></p>

<p><b>A.</b> Functional requirements are functional features and specifications expected by users from the proposed software product.</p>

<p><b>Q.What are non-functional requirements?</b></p>

<p><b>A.</b>  Non-functional requirements are implicit and are related to security, performance, look and feel of user interface, interoperability, cost etc.</p>

<p><b>Q.What is software measure?</b></p>

<p><b>A.</b> Software Measures can be understood as a process of quantifying and symbolizing various attributes and aspects of software.</p>

<p><b>Q.What is software metric?</b></p>

<p><b>A.</b> Software Metrics provide measures for various aspects of software process and software product. They are divided into –</p>

<p><b>Q.What is modularization?</b></p>

<p><b>A.</b>  Modularization is a technique to divide a software system into multiple discreet modules, which are expected to  carry out task(s) independently.</p>

<p><b>Q.What is concurrency and how it is achieved in software?</b></p>

<p><b>A.</b> Concurrency is the tendency of events or actions to happen simultaneously. In software, when two or more processes execute simultaneously, they are called concurrent processes. </p>

<h3>Example </h3>

<p>While you initiate print command and printing starts, you can open a new application. </p>

<p>Concurrency,  is implemented by splitting the software into multiple independent units of execution namely processes and threads, and  executing them in parallel.</p>

<p><b>Q.What is cohesion?</b></p>

<p><b>A.</b> Cohesion is a measure that defines the degree of intra-dependability among the elements of the module.</p>

<p><b>Q.What is coupling?</b></p>

<p><b>A.</b> Coupling is a measure that defines the level of inter-dependability among modules of a program.</p>

<p><b>Q.Mentions some software analysis & design tools?</b></p>

<p><b>A.</b> These can be: DFDs (Data Flow Diagrams), Structured Charts, Structured English, Data Dictionary, HIPO (Hierarchical Input Process Output) diagrams, ER (Entity Relationship) Diagrams and Decision tables.</p>

<p><b>Q.What is level-0 DFD?</b></p>

<p><b>A.</b> Highest abstraction level DFD is known as Level 0 DFD also called a context level DFD, which depicts the entire information system as one diagram concealing all the underlying details.</p>

<p><b>Q.What is the difference between structured English and Pseudo Code?</b></p>

<p><b>A.</b> Structured English is native English language used to write the structure of a program module  by using programming language keywords, whereas, Pseudo Code is more close to programming language and uses native English language words or sentences to write parts of code.</p>

<p><b>Q.What is data dictionary?</b></p>

<p><b>A.</b> Data dictionary  is referred to as meta-data. Meaning, it is a repository of data about data. Data dictionary is  used to organize the names and their references used in system such as objects and files along with their naming conventions.</p>

<p><b>Q.What is structured design?</b></p>

<p><b>A.</b> Structured design is a conceptualization of problem into several well-organized elements of solution. It is concern with the solution design and based on ‘divide and conquer’ strategy.</p>

<p><b>Q.What is the difference between function oriented and object oriented design?</b></p>

<p><b>A.</b> Function-oriented design is comprised of many smaller sub-systems known as functions.  Each function is capable of performing significant task in the system. Object oriented design works around the real world objects (entities), their classes (categories) and methods operating on objects (functions).</p>

<p><b>Q.Briefly define top-down and bottom-up design model.</b></p>

<p><b>A.</b> Top-down model starts with generalized view of system and decomposes it to more specific ones, whereas bottom-up model starts with most specific and basic components first and keeps composing the components to get higher level of abstraction.</p>

<p><b>Q.What is the basis of Halstead’s complexity measure?</b></p>

<p><b>A.</b> Halstead’s complexity measure depends up on the actual implementation of the program and it considers tokens used in the program as basis of measure.</p>

<p><b>Q.Mention the formula to calculate Cyclomatic complexity of a program?</b></p>

<p><b>A.</b> Cyclomatic complexity uses graph theory’s formula: V(G) = e – n + 2</p>

<p><b>Q.What is functional programming?</b></p>

<p><b>A.</b> Functional programming is style of programming language, which uses the concepts of mathematical function.  It provides means of computation as mathematical functions, which produces results irrespective of program state.</p>

<p><b>Q.Differentiate validation and verification?</b></p>

<p><b>A.</b> Validation checks if the product is made as per user requirements whereas verification checks if proper  steps are followed to develop the product. </p>

<p>Validation confirms the right product and verification confirms if the product is built in a right way.</p>

<p><b>Q.What is black-box and white-box testing?</b></p>

<p><b>A.</b>  Black-box testing checks if the desired outputs are produced when valid input values are given. It does not verify the actual implementation of the program.</p>

<p>White-box testing not only checks for desired and valid output when valid input is provided but also it checks if the code is implemented correctly. </p>

<p><b>Q.Quality assurance vs. Quality Control?</b></p>

<p><b>A.</b> Quality Assurance monitors to check if proper process is followed while software developing the software.</p>

<p>Quality Control deals with maintaining the quality of software product.</p>

<p><b>Q.What are various types of software maintenance?</b></p>

<p><b>A.</b>   Maintenance types are: corrective, adaptive, perfective and preventive.</p>

<p> Removing errors spotted by users</p>

<p> tackling the changes in the hardware and software environment where the software works </p>

<p> implementing changes in existing or new requirements of user</p>

<p> taking appropriate measures to avoid future problems</p>

<p><b>Q.What is software re-engineering?</b></p>

<p><b>A.</b> Software re-engineering is process to upgrade the technology on which the software is built without changing the functionality of the software. This is done in order to keep the software tuned with the latest technology.</p>

<p><b>Q.What are CASE tools?</b></p>

<p><b>A.</b> CASE stands for Computer Aided Software Engineering. CASE tools are set of automated software application programs, which are used to support, accelerate and smoothen the SDLC  activities.</p>

<h2>What is Next?</h2>

<p>Further, you can go through your past assignments you have done with the subject and make sure you are able to speak confidently on them. If you are fresher then interviewer does not expect you will answer very complex questions, rather you have to make your basics concepts very strong.</p>

<p>Second it really doesn't matter much if you could not answer few questions but it matters that whatever you answered, you must have answered with confidence. So just feel confident during your interview. We at tutorialspoint wish you best luck to have a good interviewer and all the very best for your future endeavor. Cheers :-)</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Software Engineering Useful Resources</title>

<h1>Software Engineering - Useful Resources</h1>

<p>The following resources contain additional information on Software Engineering. Please use them to get more in-depth knowledge on this topic.</p>

<h2>Useful Links on Software Engineering</h2>

<h2>Useful Books on Software Engineering</h2>

<p>To enlist your site on this page, please drop an email to <b>contact@tutorialspoint.com</b></p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Software Engineering Quick Guide</title>

<h1>Software Engineering - Quick Guide</h1>

<h1>Software Engineering Overview</h1>

<p>Let us first understand what software engineering stands for. The term is made of two words, software and engineering.</p>

<p><b>Software </b>is more than just a program code. A program is an executable code, which serves some computational purpose. Software is considered to be collection of executable programming code, associated libraries and  documentations. Software, when made for a specific requirement is called <b>software product.</b></p>

<p><b>Engineering</b> on the other hand, is all about developing products, using well-defined, scientific principles and methods.</p>

<p><b>Software engineering</b> is an engineering branch associated with development of software product using well-defined scientific principles, methods and procedures. The outcome of software engineering is an efficient and reliable software product.</p>

<h2>Definitions</h2>

<p>IEEE defines software engineering as:</p>

<p>(1)&nbsp;The application of a systematic,disciplined,quantifiable approach to the development,operation and maintenance of software; that is, the application of engineering to software.</p>

<p>(2)&nbsp;The study of approaches as in the above statement.</p>

<p>Fritz Bauer, a German computer scientist, defines software engineering as:</p>

<p>Software engineering is the establishment and use of sound engineering principles in order to obtain economically software that is reliable and work efficiently on real machines.</p>

<h2>Software Evolution</h2>

<p>The process of developing a software product using software engineering principles and methods is referred to as <b>software evolution.</b> This includes the initial development of software and its maintenance and updates, till desired software product is developed, which satisfies the expected requirements.</p>

<p>Evolution starts from the requirement gathering process. After which developers create a prototype of the intended software and show it to the users to get their feedback at the early stage of software product development.  The users suggest changes, on which several consecutive updates and maintenance keep on changing too. This process changes to the original software, till the desired software is accomplished.</p>

<p>Even after the user has desired software in hand,  the advancing technology and the changing requirements force the software product to change accordingly. Re-creating software from scratch and to go one-on-one with requirement is not feasible. The only feasible and economical solution is to update the existing software so that it matches the latest  requirements.</p>

<h2>Software Evolution Laws</h2>

<p>Lehman has given laws for software evolution. He divided the software into three different categories:</p>

<h2>E-Type software evolution </h2>

<p>Lehman has given eight laws for E-Type software evolution -  </p>

<h2>Software Paradigms</h2>

<p>Software paradigms refer to the methods and steps, which are taken while designing the software. There are many methods proposed and are in work today, but we need to see where in the software engineering these paradigms stand. These can be combined into various categories, though each of them is contained in one another:</p>

<p>Programming paradigm is a subset of Software design paradigm which is further a subset of Software development paradigm.</p>

<h3>Software Development Paradigm</h3>

<p>This Paradigm is known as software engineering paradigms where all the engineering concepts pertaining to the development of software are applied. It includes various researches and requirement gathering which helps the software product to build. It consists of – </p>

<h3>Software Design Paradigm</h3>

<p>This paradigm is a part of Software Development and includes – </p>

<h3>Programming Paradigm</h3>

<p>This paradigm is related closely to programming aspect of software development. This includes –</p>

<h2>Need of Software Engineering</h2>

<p>The need of software engineering arises because of higher rate of change in user requirements and environment on which the software is working.</p>

<h2>Characteristics of good software</h2>

<p>A software product can be judged  by what it offers and how well it can be used. This software must satisfy on the following grounds:</p>

<p>Well-engineered and crafted software is expected to have the following characteristics:</p>

<h3>Operational</h3>

<p> This tells us how well software works in operations. It can be measured on:</p>

<h3>Transitional</h3>

<p> This aspect is important when the software is moved from one platform to another:</p>

<h3>Maintenance</h3>

<p> This aspect briefs about how well a software has the capabilities to maintain itself in the ever-changing environment:</p>

<p>In short, Software engineering is a branch of computer science, which uses well-defined engineering concepts required to produce efficient, durable, scalable, in-budget and on-time software products.</p>

<h1>Software Development Life Cycle</h1>

<p>Software Development Life Cycle, SDLC for short, is a well-defined, structured sequence of stages in software engineering to develop the intended software product. </p>

<h2>SDLC Activities</h2>

<p>SDLC provides a series of steps to be followed to design and develop a software product efficiently. SDLC framework includes the following steps:</p>

<h3>Communication</h3>

<p>This is the first step where the user initiates the request for a desired software product.  He contacts the service provider and tries to negotiate the terms. He submits his request to the service providing organization in writing.</p>

<h3>Requirement Gathering</h3>

<p>This step onwards the software development team works to carry on the project. The team holds discussions with various stakeholders from problem domain and tries to bring out as much information as possible on their requirements. The requirements are contemplated and segregated into user requirements, system requirements and functional requirements. The requirements are collected using a number of practices as given - </p>

<h3>Feasibility Study</h3>

<p>After requirement gathering, the team comes up with a rough plan of software process. At this step the team analyzes if a software can be made to fulfill all requirements of the user and if there is any possibility of software being no more useful. It is found out, if the project is financially, practically and technologically feasible for the organization to take up. There are many algorithms available, which help the developers to conclude the feasibility of a software project.</p>

<h3>System Analysis</h3>

<p>At this step the developers decide a roadmap of their plan and try to bring up the best software model suitable for the project. System analysis includes Understanding of software product limitations, learning system related problems or changes to be done in existing systems beforehand, identifying and addressing the impact of project on organization and personnel etc. The project team   analyzes the scope of the project and plans the schedule and resources accordingly.</p>

<h3>Software Design</h3>

<p>Next step is to bring down whole knowledge of requirements and analysis on the desk and design the software product.  The inputs from users and information gathered in requirement gathering phase are the inputs of this step. The output of this step comes in the form of two designs; logical design and physical design. Engineers produce meta-data and data dictionaries, logical diagrams, data-flow diagrams and in some cases pseudo codes.</p>

<h3>Coding</h3>

<p>This step is also known as programming phase. The implementation of software design starts in terms of writing program code in the suitable programming language and developing error-free executable programs efficiently.</p>

<h3>Testing</h3>

<p>An estimate says that 50% of whole software development process should be tested. Errors may ruin the software from critical level to its own removal. Software testing is done while coding by the developers and thorough testing is conducted by testing experts at various levels of code such as module testing, program testing, product testing, in-house testing and testing the product at user’s end. Early discovery of errors and their remedy is the key to reliable software.</p>

<h3>Integration</h3>

<p>Software may need to be integrated with the libraries, databases and other program(s). This stage of SDLC is involved in the integration of software with outer world entities.</p>

<h3>Implementation</h3>

<p>This means installing the software on user machines. At times, software needs post-installation configurations at user end. Software is tested for portability and adaptability and integration related issues are solved during implementation.</p>

<h3>Operation and Maintenance</h3>

<p>This phase confirms the software operation in terms of more efficiency and less errors. If required, the users are trained on, or aided with the documentation on how to operate the software and how to keep the software operational. The software is maintained timely by updating the code according to the changes taking place in user end environment or technology. This phase may face challenges from hidden bugs and real-world unidentified problems.</p>

<h3>Disposition</h3>

<p>As time elapses, the software may  decline on the performance front. It may go completely obsolete or may need intense upgradation. Hence a pressing need to eliminate a major portion of the system arises. This phase includes archiving data and required software components, closing down the system, planning disposition activity and terminating system at appropriate end-of-system time.</p>

<h2>Software Development Paradigm</h2>

<p>The software development paradigm helps developer to select a strategy to develop the software. A software development paradigm has its own set of tools, methods and procedures, which are expressed clearly and defines software development life cycle. A few of software development paradigms or process models are defined as follows:</p>

<h3>Waterfall Model</h3>

<p>Waterfall model is the simplest model of software development paradigm. It says the all the phases of SDLC will function one after another in linear manner. That is, when the first phase is finished then only the second phase will start and so on.</p>

<p>This model assumes that everything is carried out and taken place perfectly as planned in the previous stage and there is no need to think about the past issues that may arise in the next phase. This model does not work smoothly if there are some issues left at the previous step. The sequential nature of model does not allow us go back and undo or redo our actions.</p>

<p>This model is best suited when developers already have designed and developed similar software in the past and are aware of all its domains. </p>

<h3>Iterative Model</h3>

<p>This model leads the software development process in iterations. It projects the process of development in cyclic manner repeating every step after every cycle of SDLC process.</p>

<p>The software is first developed on very small scale and all the steps are followed which are taken into consideration. Then, on every next iteration, more features and modules are designed, coded, tested and added to the software. Every cycle produces a software, which is complete in itself and has more features and capabilities than that of the previous one.</p>

<p>After each iteration, the management team can do work on risk management and prepare for the next iteration. Because a cycle includes small portion of whole software process, it is easier to manage the development process but it consumes more resources.</p>

<h3>Spiral Model</h3>

<p>Spiral model is a combination of both, iterative model and one of the SDLC model. It can be seen as if you choose one SDLC model and combine it with cyclic process (iterative model).</p>

<p>This model considers risk, which often goes un-noticed by most other models. The model starts with determining objectives and constraints of the software at the start of one iteration. Next phase is of prototyping the software. This includes risk analysis. Then one standard SDLC model is used to build the software. In the fourth phase of the plan of next iteration is prepared.</p>

<h3>V – model</h3>

<p>The major drawback of waterfall model is we move to the next stage only when the previous one is finished and there was no chance to go back if something is found wrong in later stages. V-Model provides means of testing of software at each stage in reverse manner.</p>

<p>At every stage, test plans and test cases are created to verify and validate the product according to the requirement of that stage. For example, in requirement gathering stage the test team prepares all the test cases in correspondence to the requirements. Later, when the product is developed and is ready for testing, test cases of this stage verify the software against its validity towards requirements at this stage.</p>

<p>This makes both verification and validation go in parallel. This model is also known as verification and validation model.</p>

<h3>Big Bang Model</h3>

<p>This model is the simplest model in its form. It requires little planning, lots of programming and lots of funds. This model is conceptualized around the big bang of universe. As scientists say that after big bang lots of galaxies, planets and stars evolved just as an event. Likewise, if we put together lots of programming and funds, you may achieve the best software product.</p>

<p>For this model, very small amount of planning is required. It does not follow any process, or at times the customer is not sure about the requirements and future needs. So the input requirements are arbitrary.</p>

<p>This model is not suitable for large software projects but good one for learning and experimenting.</p>

<p>For an in-depth reading on SDLC and its various models,<a href="http://www.tutorialspoint.com/sdlc/index.htm" style="color:blue" target="_blank"> click here.</a></p>

<h1>Software Project Management</h1>

<p>The job pattern of an IT company engaged in software development can be seen split in two parts:</p>

<p>A project is well-defined task, which is a collection of several operations done in order to achieve a goal (for example, software development and delivery).  A Project can be characterized as:</p>

<h2>Software Project</h2>

<p>A Software Project is the complete procedure of software development from requirement gathering to testing and maintenance, carried out according to the execution methodologies, in a specified period of time to achieve intended software product.</p>

<h2>Need of software project management</h2>

<p>Software is said to be an intangible product. Software development is a kind of all new stream in world business and there’s very little experience in building software products.  Most software products are tailor made to fit client’s requirements. The most important is that the underlying technology changes and advances so frequently and rapidly that experience of one product may not be applied to the other one. All such business and environmental constraints bring risk in software development hence it is essential to manage software projects efficiently.</p>

<p></p>

<p>The image above shows triple constraints for software projects. It is an essential part of software organization to deliver quality product, keeping the cost within client’s budget constrain and deliver the project as per scheduled.  There are several factors, both internal and external, which may impact this triple constrain triangle.  Any of three factor can severely impact the other two. </p>

<p>Therefore, software project management is essential to incorporate user requirements along with budget and time constraints.</p>

<h2>Software Project Manager</h2>

<p>A software project manager is a person who undertakes the responsibility of executing the software project.  Software project manager is thoroughly aware of all the phases of SDLC that the software would go through. Project manager may never directly involve in producing the end product but he controls and manages the activities involved in production.</p>

<p>A project manager closely monitors the development process, prepares and executes various plans, arranges necessary and adequate resources, maintains communication among all team members in order to address issues of cost, budget, resources, time, quality and customer satisfaction.</p>

<p>Let us see few responsibilities that a project manager shoulders -</p>

<h3>Managing People</h3>

<h3>Managing Project</h3>

<h2>Software Management Activities</h2>

<p>Software project management comprises of a number of activities, which contains planning of project, deciding scope of software product, estimation of cost in various terms, scheduling of tasks and events, and resource management.  Project management activities may include:</p>

<h2>Project Planning</h2>

<p>Software project planning is task, which is performed before the production of software actually starts.  It is there for the software production but involves no concrete activity that has any direction connection with software production; rather it is a set of multiple processes, which facilitates software production.  Project planning may include the following: </p>

<h2>Scope Management</h2>

<p>It defines the scope of project; this includes all the activities, process need to be done in order to make a deliverable software product.  Scope management is essential because it creates boundaries of the project by clearly defining what would be done in the project and what would not be done. This makes project to contain limited and quantifiable tasks, which can easily be documented and in turn avoids cost and time overrun.  </p>

<p>During Project Scope management, it is necessary to -</p>

<h2>Project Estimation</h2>

<p>For an effective management accurate estimation of various measures is a must.  With correct estimation managers can manage and control the project more efficiently and effectively. </p>

<p>Project estimation may involve the following:</p>

<p>Software size may be estimated either in terms of KLOC (Kilo Line of Code) or by calculating number of function points in the software. Lines of code depend upon coding practices and Function points vary according to the user or software requirement.</p>

<p>Once size and efforts are estimated, the time required to produce the software  can be estimated. Efforts required is segregated into sub categories as per the requirement specifications and interdependency of various components of software. Software tasks are divided into smaller tasks, activities or events by Work Breakthrough Structure (WBS).  The tasks are scheduled on day-to-day basis or in calendar months.</p>

<p>The sum of time required to complete all tasks in hours or days is the total time invested to complete the project.</p>

<p>This might be considered as the most difficult of all because it depends on more elements than any of the previous ones.  For estimating project cost, it is required to consider - </p>

<h2>Project Estimation Techniques</h2>

<p>We discussed various parameters involving project estimation such as size, effort, time and cost.</p>

<p>Project manager can estimate the listed factors using two broadly recognized techniques –</p>

<h3>Decomposition Technique</h3>

<p>This technique assumes the software as a product of various compositions.</p>

<p>There are two main models -</p>

<h3>Empirical Estimation Technique</h3>

<p>This technique uses empirically derived formulae to make estimation.These formulae are based on LOC or FPs.</p>

<p>This model is made by Lawrence H. Putnam, which is based on Norden’s frequency distribution (Rayleigh curve).  Putnam model maps time and efforts required with software size.  </p>

<p>COCOMO stands for COnstructive COst MOdel, developed by Barry W. Boehm.  It divides the software product into three categories of software: organic, semi-detached and embedded.</p>

<h2>Project Scheduling</h2>

<p>For scheduling a project, it is necessary to -</p>

<h2>Resource management</h2>

<p>All elements used to develop a software product may be assumed as resource for that project.  This may include human resource, productive tools and software libraries.</p>

<p>The resources are available in limited quantity and stay in the organization as a pool of assets. The shortage of resources hampers the development of project and it can lag behind the schedule. Allocating extra resources increases development cost in the end. It is therefore necessary to estimate and allocate adequate resources for the project.</p>

<p>Resource management includes -</p>

<h2>Project Risk Management</h2>

<p>Risk management involves all activities pertaining to identification, analyzing and making provision for predictable and non-predictable risks in the project.  Risk may include the following:</p>

<h2>Risk Management Process</h2>

<p>There are following activities involved in risk management process:</p>

<h2>Project Execution &amp; Monitoring</h2>

<p>In this phase, the tasks described in project plans are executed according to their schedules.</p>

<p>Execution needs monitoring in order to check whether everything is going according to the plan.  Monitoring is observing to check the probability of risk and taking measures to address the risk or report the status of various tasks.</p>

<p>These measures include -</p>

<h2>Project Communication Management</h2>

<p>Effective communication plays vital role in the success of a project. It bridges gaps between client and the organization, among the team members as well as other stake holders in the project such as hardware suppliers.</p>

<p>Communication can be oral or written. Communication management process may have the following steps: </p>

<p>After closure, the team moves to next phase or project.</p>

<h2>Configuration Management</h2>

<p>Configuration management is a process of tracking and controlling the changes in software in terms of the requirements, design, functions and development of the product.</p>

<p>IEEE defines it as “the process of identifying and defining the items in the system, controlling the change of these items throughout their life cycle, recording and reporting the status of items and change requests, and verifying the completeness and correctness of items”.</p>

<p>Generally, once the SRS is finalized there is less chance of requirement of changes from user. If they occur, the changes are addressed only with prior approval of higher management, as there is a possibility of cost and time overrun.</p>

<h3>Baseline</h3>

<p>A phase of SDLC is assumed over if it baselined, i.e. baseline is a measurement that defines completeness of a phase.  A phase is baselined when all activities pertaining to it are finished and well documented.  If it was not the final phase, its output would be used in next immediate phase.</p>

<p>Configuration management is a discipline of organization administration, which takes care of occurrence of any change (process, requirement, technological, strategical etc.) after a phase is baselined.  CM keeps check on any changes done in software.</p>

<h3>Change Control</h3>

<p>Change control is function of configuration management, which ensures that all changes made to software system are consistent and made as per organizational rules and regulations.</p>

<p>A change in the configuration of product goes through following steps -</p>

<p><b>Identification</b> - A change request arrives from either internal or external source. When change request is identified formally, it is properly documented.</p>

<p><b>Validation</b> - Validity of the change request is checked and its handling procedure is confirmed.</p>

<p><b>Analysis</b> - The impact of change request is analyzed in terms of schedule, cost and required efforts. Overall impact of the prospective change on system is analyzed.</p>

<p><b>Control</b> - If the prospective change either impacts too many entities in the system or it is unavoidable, it is mandatory to take approval of high authorities before change is incorporated into the system. It is decided if the change is worth incorporation or not. If it is not, change request is refused formally.</p>

<p><b>Execution</b> - If the previous phase determines to execute the change request, this phase take appropriate actions to execute the change, does a thorough revision if necessary.</p>

<p><b>Close request</b> - The change is verified for correct implementation and merging with the rest of the system. This newly incorporated change in the software is documented properly and the request is formally is closed.</p>

<h2>Project Management Tools</h2>

<p>The risk and uncertainty rises multifold with respect to the size of the project, even when the project is developed according to set methodologies.</p>

<p>There are tools available, which aid for effective project management. A few are described -</p>

<h3>Gantt Chart</h3>

<p>Gantt charts was devised by Henry Gantt (1917). It represents project schedule with respect to time periods.  It is a horizontal bar chart with bars representing activities and time scheduled for the project activities.</p>

<h3>PERT Chart</h3>

<p>PERT (Program Evaluation &amp; Review Technique) chart is a tool that depicts project as network diagram.  It is capable of graphically representing main events of project in both parallel and consecutive way.  Events, which occur one after another, show dependency of the later event over the previous one.</p>

<p>Events are shown as numbered nodes. They are connected by labeled arrows depicting sequence of tasks in the project.</p>

<h3>Resource Histogram</h3>

<p>This is a graphical tool that contains bar or chart representing number of resources (usually skilled staff) required over time for a project event (or phase).  Resource Histogram is an effective tool for staff planning and coordination.</p>

<h3>Critical Path Analysis</h3>

<p>This tools is useful in recognizing interdependent tasks in the project. It also helps to find out the shortest path or critical path to complete the project successfully. Like PERT diagram, each event is allotted a specific time frame. This tool shows dependency of event assuming an event can proceed to next only if the previous one is completed.</p>

<p>The events are arranged according to their earliest possible start time. Path between start and end node is critical path which cannot be further reduced and all events require to be executed in same order.</p>

<h1>Software Requirements</h1>

<p>The software requirements are description of features and functionalities of the target system.  Requirements convey the expectations of users from the software product. The requirements can be obvious or hidden, known or unknown, expected or unexpected from client’s point of view.</p>

<h2>Requirement Engineering</h2>

<p>The process to gather the software requirements from client, analyze and document them is known as requirement engineering.</p>

<p>The goal of requirement engineering is to develop and maintain sophisticated and descriptive ‘System Requirements Specification’ document.</p>

<h2>Requirement Engineering Process</h2>

<p>It is a four step process, which includes – </p>

<p>Let us see the process briefly - </p>

<h3>Feasibility study</h3>

<p>When  the client  approaches the organization for getting the desired product developed, it comes up with rough idea about what all functions the software must perform and which all features are expected from the software. </p>

<p>Referencing to this information, the analysts  does a detailed study about whether the  desired system and its functionality are feasible to develop. </p>

<p>This feasibility study is focused towards goal of the organization.  This study analyzes whether the software product can be practically materialized in terms of implementation, contribution of project to organization, cost constraints and as per values and objectives of the organization.  It explores technical aspects of the project and product such as usability, maintainability, productivity and integration ability.</p>

<p>The output of this phase should be a feasibility study report that should contain adequate comments and recommendations for management about whether or not the project should be undertaken.</p>

<h3>Requirement Gathering</h3>

<p>If the feasibility report is positive towards undertaking the project, next phase starts with gathering requirements from the user. Analysts and engineers communicate with the client and end-users to know their ideas on what the software should provide and which features they want the software to include. </p>

<h3>Software Requirement Specification</h3>

<p>SRS is a document created by system analyst after the requirements are collected from various stakeholders. </p>

<p>SRS defines how the intended software will interact with hardware, external interfaces, speed of operation, response time of system, portability of software across various platforms, maintainability, speed of recovery after crashing, Security, Quality, Limitations etc. </p>

<p>The requirements received from client are written in natural language. It is the responsibility of system analyst to document the requirements in technical language so that they can be comprehended and useful by the software development team. </p>

<p>SRS should come up with following features: </p>

<h3>Software Requirement Validation</h3>

<p>After requirement specifications are developed, the requirements mentioned in this document are validated.  User might ask for illegal, impractical solution or experts may interpret the requirements incorrectly. This results in huge increase in cost if not nipped in the bud. Requirements can be checked against following conditions -</p>

<h2>Requirement Elicitation Process</h2>

<p>Requirement elicitation process can be depicted using the folloiwng diagram:</p>

<p><b>Negotiation & discussion - </b>If requirements are ambiguous or there are some conflicts in requirements of various stakeholders, if they are, it is then negotiated and discussed with stakeholders.  Requirements may then be prioritized and reasonably compromised.</p>

<p>The requirements come from various stakeholders. To remove the ambiguity and conflicts, they are discussed for clarity and correctness. Unrealistic requirements are compromised reasonably.</p>

<h2>Requirement Elicitation Techniques</h2>

<p>Requirements Elicitation is the process to find out the requirements for an intended software system by communicating with client, end users, system users and others who have a stake in the software system development.</p>

<p>There are various ways to discover requirements</p>

<h3>Interviews</h3>

<p>Interviews are strong medium to collect requirements. Organization may conduct several types of interviews such as: </p>

<h3>Surveys</h3>

<p>Organization may conduct surveys among various stakeholders by querying about their expectation and requirements from the upcoming system. </p>

<h3>Questionnaires</h3>

<p>A document with pre-defined set of objective questions and respective options is handed over to all stakeholders to answer, which are collected and compiled.</p>

<p>A shortcoming of this technique is, if an option for some issue is not mentioned in the questionnaire, the issue might be left unattended.</p>

<h3>Task analysis</h3>

<p>Team of engineers and developers may analyze the operation for which the new system is required. If the client already has some software to perform certain operation, it is studied and requirements of proposed system are collected. </p>

<h3>Domain Analysis</h3>

<p>Every software falls into some domain category. The expert people in the domain can be a great help to analyze general and specific requirements.  </p>

<h3>Brainstorming</h3>

<p>An informal debate is held among various stakeholders and all their inputs are recorded for further requirements analysis.</p>

<h3>Prototyping</h3>

<p>Prototyping is building user interface without adding detail functionality for user to interpret the features of intended software product. It helps giving better idea of requirements. If there is no software installed at client’s end for developer’s reference and the client is not aware of its own requirements, the developer  creates a prototype based on initially mentioned requirements. The prototype is shown to the client and the feedback is noted. The client feedback serves as an  input for requirement gathering.</p>

<h3>Observation</h3>

<p>Team of experts visit the client’s organization or workplace. They observe the actual working of the existing installed systems. They observe the workflow at client’s end and how execution problems are dealt. The team itself draws some conclusions which aid to form requirements expected from the software.</p>

<h2>Software Requirements Characteristics</h2>

<p>Gathering software requirements is the foundation of the entire software development project. Hence they must be clear, correct and well-defined.</p>

<p>A complete Software Requirement Specifications must be: </p>

<h2>Software Requirements</h2>

<p>We should try to understand what sort of requirements may arise in the requirement elicitation phase and what kinds of requirements are expected from the software system. </p>

<p>Broadly software requirements should be categorized in two categories:</p>

<h3>Functional Requirements</h3>

<p>Requirements, which are related to functional aspect of software fall into this category.</p>

<p>They define functions and functionality within and from the software system.</p>

<h4>Examples -</h4>

<h3>Non-Functional Requirements</h3>

<p>Requirements, which are not related to functional aspect of software, fall into this category.  They are implicit or expected characteristics of software, which users make assumption of.</p>

<p> Non-functional requirements include -</p>

<p>Requirements are categorized logically as </p>

<p>While developing software, ‘Must have’ must be implemented, ‘Should have’ is a matter of debate with stakeholders and negation, whereas ‘could have’ and ‘wish list’ can be kept for software updates.</p>

<h2>User Interface requirements</h2>

<p>UI is an important part of any software or hardware or hybrid system.  A software is widely accepted if it is -</p>

<p>User acceptance majorly depends upon how user can use the software.  UI is the only way for users to perceive the system. A well performing software system must also be equipped with attractive, clear, consistent and responsive user interface. Otherwise the functionalities of software system can not be used in convenient way.  A system is said be good if it provides means to use it efficiently.  User interface requirements are briefly mentioned below -</p>

<h2>Software System Analyst</h2>

<p>System analyst in an IT organization is a person, who analyzes the requirement of proposed system and ensures that requirements are conceived and documented properly & correctly. Role of an analyst starts during Software Analysis Phase of SDLC. It is the responsibility of analyst to make sure that the developed software meets the requirements of the client.</p>

<p>System Analysts have the following responsibilities:</p>

<h2>Software Metrics and Measures</h2>

<p>Software Measures can be understood as a process of quantifying and symbolizing various attributes and aspects of software.</p>

<p>Software Metrics provide measures for various aspects of software process and software product.</p>

<p>Software measures are fundamental requirement of software engineering. They not only help to control the software development process but also aid to keep quality of ultimate product excellent.</p>

<p>According to Tom DeMarco, a (Software Engineer), “You cannot control what you cannot measure.” By his saying, it is very clear how important software measures are.</p>

<p>Let us see some software metrics:</p>

<p><b>Size Metrics - </b>LOC (Lines of Code), mostly calculated in thousands of delivered source code lines, denoted as KLOC.</p>

<p><b>Quality Metrics - </b>Defects, their types and causes, consequence, intensity of severity and their implications define the quality of product. </p>

<h1>Software Design Basics</h1>

<p>Software design is a process to transform user requirements into some suitable form, which helps the programmer in software coding and implementation.</p>

<p>For assessing user requirements, an SRS (Software Requirement Specification) document is created whereas for coding and implementation, there is a need of more specific and detailed requirements in software terms.  The output of this process can directly be used into implementation in programming languages.</p>

<p>Software design is the first step in SDLC (Software Design Life Cycle), which moves the concentration from problem domain to solution domain. It tries to specify how to fulfill the requirements mentioned in SRS.</p>

<h2>Software Design Levels</h2>

<p>Software design yields three levels of results:</p>

<h2>Modularization</h2>

<p>Modularization is a technique to divide a software system into multiple discrete and independent modules, which are expected to be capable of carrying out task(s) independently. These modules may work as basic constructs for the entire software. Designers tend to design modules such that they can be executed and/or compiled separately and independently.</p>

<p>Modular design unintentionally follows the rules of ‘divide and conquer’ problem-solving strategy this is because there are many other benefits attached with the modular design of a software.</p>

<p>Advantage of modularization:</p>

<h2>Concurrency</h2>

<p>Back in time, all software are meant to be executed sequentially.  By sequential execution we mean that the coded instruction will be executed one after another implying only one portion of program being activated at any given time.  Say, a software has multiple modules, then only one of all the modules can be found active at any time of execution.</p>

<p>In software design, concurrency is implemented by splitting the software into multiple independent units of execution, like modules and executing them in parallel.  In other words, concurrency provides capability to the software to execute more than one part of code in parallel to each other.</p>

<p>It is necessary for the programmers and designers to recognize those modules, which can be made parallel execution. </p>

<h3>Example</h3>

<p>The spell check feature in word processor is a  module of software, which runs along side the word processor itself.</p>

<h2>Coupling and Cohesion</h2>

<p>When a software program is modularized, its tasks are divided into several modules based on some characteristics.  As we know, modules are set of instructions put together in order to achieve some tasks.  They are though, considered as single entity but may refer to each other to work together.  There are measures by which the quality of a design of modules and their interaction among them can be measured. These measures are called coupling and cohesion.</p>

<h2>Cohesion</h2>

<p>Cohesion is a measure that defines the degree of intra-dependability within elements of a module.  The greater the cohesion, the better is the program design.</p>

<p>There are seven types of cohesion, namely –</p>

<h2>Coupling </h2>

<p>Coupling  is a measure that defines the level of inter-dependability among modules of a program.  It tells at what level the modules interfere and interact with each other. The lower the coupling, the better the program.</p>

<p>There are five levels of coupling, namely -</p>

<p>Ideally, no coupling is considered to be the best.</p>

<h2>Design Verification</h2>

<p>The output of software design process is design documentation, pseudo codes, detailed logic diagrams, process diagrams, and detailed description of all functional or non-functional requirements. </p>

<p>The next phase, which is the implementation of software, depends on all outputs  mentioned above.  </p>

<p>It is then becomes necessary to verify the output before proceeding to the next phase. The early any mistake is detected, the better it is or it might not be detected until testing of the product.  If the outputs of design phase are in formal notation form, then their associated tools for verification should be used otherwise a thorough design review can be used for verification and validation.</p>

<p>By structured verification approach, reviewers can detect defects that might be caused by overlooking some conditions.  A good design review is important for good software design, accuracy and quality.</p>

<h1>Software Analysis & Design Tools</h1>

<p>Software analysis and design includes all activities, which help the transformation of requirement specification into implementation.  Requirement specifications specify all functional and non-functional expectations from the software. These requirement specifications come in the shape of human readable and understandable  documents, to which a computer has nothing to do. </p>

<p>Software analysis and design is the intermediate stage, which helps human-readable requirements to be transformed into actual code.</p>

<p>Let us see few analysis and design tools used by software designers:</p>

<h2>Data Flow Diagram</h2>

<p>Data flow diagram is graphical representation of flow of data in an information system. It is capable of depicting incoming data flow, outgoing data flow and stored data. The DFD does not mention anything about how data flows through the system.</p>

<p>There is a prominent difference between DFD and Flowchart. The flowchart depicts flow of control in program modules. DFDs depict flow of data in the system at various levels. DFD does not contain any control or branch elements.</p>

<h3>Types of DFD</h3>

<p>Data Flow Diagrams are either Logical or Physical.</p>

<h3>DFD Components</h3>

<p>DFD can represent Source, destination, storage and flow of data using the following set of components -</p>

<h3>Levels of DFD</h3>

<p><b>Level 2</b> - At this level, DFD shows how data flows inside the modules mentioned in Level 1.</p>

<h2>Structure Charts</h2>

<p>Structure chart is a chart derived from Data Flow Diagram.  It represents the system in more detail than DFD.  It  breaks down the entire system into lowest functional modules, describes functions and  sub-functions of each module of the system to a greater detail than DFD.</p>

<p>Structure chart represents hierarchical structure of modules. At each layer a specific task is performed.</p>

<p>Here are the symbols used in  construction of structure charts -</p>

<h2>HIPO Diagram</h2>

<p>HIPO (Hierarchical Input Process Output) diagram is a combination of two organized method to analyze the system and provide the means of documentation. HIPO model was developed by IBM in year 1970.</p>

<p>HIPO  diagram represents the hierarchy of modules in the software system. Analyst uses HIPO diagram in order to obtain high-level view of system functions. It decomposes functions into sub-functions in a hierarchical manner. It depicts the functions performed by system.     </p>

<p>HIPO diagrams are good for documentation purpose. Their graphical representation makes it easier for designers and managers to  get the pictorial idea of the system structure. </p>

<p>In contrast to IPO (Input Process Output) diagram, which depicts  the flow of control and data in a module, HIPO does not provide any information about data flow or control flow.</p>

<h3>Example</h3>

<p>Both parts of HIPO diagram, Hierarchical presentation and IPO Chart are used for structure design of software program as well as documentation of the same.</p>

<h2>Structured English</h2>

<p>Most programmers are unaware of the large picture of software so they only rely on what their managers tell them to do. It is the responsibility of higher  software management to provide accurate information to the programmers to develop accurate yet fast code.</p>

<p>Other forms of methods, which use graphs or diagrams, may are sometimes interpreted differently by different people.</p>

<p>Hence, analysts and designers of the software come up with tools such as Structured English. It is nothing but the description of what is required to code and how to code it. Structured English helps the programmer to write error-free code. </p>

<p>Other form of methods, which use graphs or diagrams, may are sometimes interpreted differently by different people. Here, both Structured English and Pseudo-Code tries to mitigate that understanding gap.</p>

<p>Structured English is the It uses plain English words in structured programming paradigm.  It is not the ultimate code but a kind of description what is required to code and how to code it. The following are some tokens of structured programming.</p>

<p>Analyst uses the same variable and data name, which are stored in Data Dictionary, making it much simpler to write and understand the code.</p>

<h3>Example</h3>

<p>We take the same example of Customer Authentication in the online shopping environment. This procedure to authenticate customer can be written in Structured English as:</p>

<p>The code written in Structured English is more  like day-to-day spoken English. It can not be implemented directly as a code of software. Structured English is independent of programming language.</p>

<h2>Pseudo-Code</h2>

<p>Pseudo code is written more close to programming language.  It may be considered as augmented programming language, full of comments and descriptions.  </p>

<p>Pseudo code avoids variable declaration but they are written using some actual programming language’s constructs, like C, Fortran, Pascal etc.</p>

<p>Pseudo code contains more programming details than Structured English.  It provides a method to perform the task, as if a computer is executing the code.</p>

<h3>Example</h3>

<p>Program to print Fibonacci up to n numbers.</p>

<h2>Decision Tables </h2>

<p>A Decision table represents conditions and the respective actions to be taken to address them, in a structured tabular format.</p>

<p>It is a powerful tool to debug and prevent errors. It helps group similar information into a single table and then by combining tables it delivers easy and convenient decision-making.</p>

<h3>Creating Decision Table</h3>

<p>To create the decision table, the developer must follow basic four steps:</p>

<p>Decision Tables should be verified by end-users and can lately be simplified by eliminating duplicate rules and actions.</p>

<h3>Example</h3>

<p>Let us take a simple example of day-to-day problem with our Internet connectivity. We begin by identifying all problems that can arise while starting the internet and their respective possible solutions.  </p>

<p>We list all possible problems under column conditions and the prospective actions under column Actions.</p>

<h2>Entity-Relationship Model</h2>

<p>Entity-Relationship model is a type of database model based on the notion of real world entities and relationship among them.  We can map real world scenario onto ER database model. ER Model creates a set of entities with their attributes, a set of constraints and relation among them.</p>

<p>ER Model is best used for the conceptual design of database. ER Model can be represented as follows :</p>

<p><b>Entity</b> - An entity in ER Model is a real world  being, which has some properties called <b><i>attributes</i></b>.  Every attribute is defined by its corresponding set of values, called <b><i>domain</i></b>.</p>

<p>For example,  Consider a school database. Here, a student is  an entity. Student has various attributes like name, id, age and class etc.</p>

<p><b>Relationship</b> - The logical association among entities is called <b><i>relationship</i></b>.  Relationships are mapped with entities in various ways. Mapping cardinalities define the number of associations between two entities.</p>

<p>Mapping cardinalities:</p>

<h2>Data Dictionary</h2>

<p>Data dictionary is the centralized collection of information about data. It stores meaning and origin of data, its relationship with other data, data format for usage etc. Data dictionary  has rigorous definitions of all names in order to facilitate user and software designers.</p>

<p>Data dictionary is often referenced as meta-data (data about data) repository.  It is created along  with DFD (Data Flow Diagram) model of software program and is expected to be updated whenever DFD is changed or updated.</p>

<h3>Requirement of Data Dictionary</h3>

<p>The data is referenced via data dictionary while designing and implementing software.  Data dictionary removes any chances of ambiguity.  It helps keeping work of programmers and designers synchronized while using same object reference everywhere in the program.</p>

<p>Data dictionary provides a way of documentation for the  complete database system in one place.  Validation of DFD is carried out using data dictionary.</p>

<h3>Contents</h3>

<p>Data dictionary should contain information about the following </p>

<p>Data Flow is described by means of DFDs as studied earlier and represented in algebraic form as described.</p>

<h3>Example</h3>

<p>Address = House No + (Street / Area) + City + State</p>

<p>Course ID = Course Number + Course Name + Course Level + Course Grades</p>

<h3>Data Elements</h3>

<p>Data elements consist of Name and descriptions of Data and Control Items, Internal or External data stores etc. with the following details:</p>

<h3>Data Store</h3>

<p>It  stores the information from where the data enters into the system and exists out of the system. The Data Store may include -</p>

<h3>Data Processing</h3>

<p>There are two types of Data Processing:</p>

<h1>Software Design Strategies</h1>

<p>Software design is a process to conceptualize the software requirements into software implementation. Software design takes the user requirements as challenges and tries to find optimum solution. While the software is being conceptualized, a plan is chalked out to find the best possible design for implementing the intended solution.  </p>

<p>There are multiple variants of software design. Let us study them briefly:</p>

<h2>Structured Design</h2>

<p>Structured design is a conceptualization of problem into several well-organized elements of solution.  It is basically concerned with the solution design.  Benefit of structured design is, it gives better understanding of how the problem is being solved.  Structured design also makes it simpler for designer to concentrate on the problem more accurately. </p>

<p>Structured design is mostly based on ‘divide and conquer’ strategy where a problem is broken into several small problems and each small problem is individually solved until the whole problem is solved.</p>

<p>The small pieces of problem are solved by means of solution modules.  Structured design emphasis that these modules be well organized in order to achieve precise solution.  </p>

<p>These modules are arranged in hierarchy. They communicate with each other. A good structured design always follows some rules for communication among multiple modules, namely -</p>

<p><b>Cohesion</b> -  grouping of all functionally related elements.</p>

<p><b>Coupling</b> - communication between different modules.</p>

<p>A good structured design has high cohesion and low coupling arrangements.</p>

<h2>Function Oriented Design</h2>

<p>In function-oriented design, the system is comprised of many smaller sub-systems known as functions.  These functions are capable of performing significant task in the system. The system is considered as top view of all functions.</p>

<p>Function oriented design inherits some properties of structured design where divide and conquer methodology is used.</p>

<p>This design mechanism divides the whole system into smaller functions, which provides means of abstraction by concealing the information and their operation.. These functional modules can share information among themselves by means of information passing and using information available globally.</p>

<p>Another characteristic of functions is that when a program calls a function, the function changes the state of the program, which sometimes is not acceptable by other modules. Function oriented design works well where the system state does not matter and program/functions work on input rather than on a state.</p>

<h3>Design Process</h3>

<h2>Object Oriented Design</h2>

<p>Object oriented design works around the entities and their characteristics instead of functions involved in the software system.  This design strategies focuses on entities and its characteristics.  The whole concept of software solution revolves around the engaged entities.</p>

<p>Let us see the important concepts of Object Oriented Design:</p>

<p><b>Classes - </b>A class is a generalized description of an object.  An object is an instance of a class.  Class defines all the attributes, which an object can have and methods, which defines the functionality of the object.</p>

<h3>Design Process</h3>

<p>Software design process can be perceived as series of well-defined steps.  Though it varies according to design approach (function oriented or object oriented, yet It may have the following steps involved:</p>

<h2>Software Design Approaches</h2>

<p>Here are two generic approaches for software designing:</p>

<h3>Top Down Design</h3>

<p>We know that a system is composed of more than one sub-systems and it contains a number of components.  Further, these sub-systems and components may have their on set of sub-system and components and creates hierarchical structure in the system.</p>

<p>Top-down design takes the whole software system as one entity and then decomposes it to achieve more than one sub-system or component based on some characteristics.  Each sub-system or component is then treated as a system and decomposed further.  This process keeps on running until the lowest level of system in the top-down hierarchy is achieved.</p>

<p>Top-down design starts with a generalized model of system and keeps on defining the more specific part of it.  When all components are composed the whole system comes into existence.</p>

<p>Top-down design is more suitable when the software solution needs to be designed from scratch and specific details are unknown.</p>

<h3>Bottom-up Design</h3>

<p>The bottom up design model starts with most specific and basic components.  It proceeds with composing higher level of components by using basic or lower level components. It keeps creating higher level components until the desired system is not evolved as one single component.  With each higher level, the amount of abstraction is increased.</p>

<p>Bottom-up strategy is more suitable when a system  needs to be created from some existing system, where the basic primitives can be used in the newer system.</p>

<p>Both, top-down and bottom-up approaches are not practical individually. Instead, a good combination of both is used.</p>

<h1>Software User Interface Design</h1>

<p>User interface is the front-end application view to which user interacts in order to use the software. User can manipulate and control the software as well as hardware by means of user interface.   Today, user interface is found at almost every place where digital technology exists, right from computers, mobile phones, cars, music players, airplanes, ships etc.</p>

<p>User interface is part of software and is designed such a way that it is expected to provide the user insight of the software.  UI provides fundamental platform for human-computer interaction.  </p>

<p>UI can be graphical, text-based, audio-video based, depending upon the underlying hardware and software combination.  UI can be hardware or software or a combination of both.</p>

<p>The software becomes more popular if its user interface is:</p>

<p>UI is broadly divided into two categories:</p>

<h2>Command Line Interface (CLI)</h2>

<p>CLI has been a great tool of interaction with computers until the video display monitors came into existence. CLI is first choice of many technical users and programmers. CLI is minimum interface a software can provide to its users.</p>

<p>CLI provides a command prompt, the place where the user types the command and feeds to the system. The user needs to remember the syntax of command and its use.  Earlier CLI were not programmed to handle the user errors effectively.</p>

<p>A command is a text-based reference to set of instructions, which are expected to be executed by the system. There are methods like macros, scripts that make it easy for the user to operate.</p>

<p>CLI uses less amount of computer resource as compared to GUI.</p>

<h3>CLI Elements</h3>

<p>A text-based command line interface can have the following elements:</p>

<p><b>Command Prompt</b>  - It is text-based notifier that is mostly shows the context in which the user is working.  It is generated by the software system.</p>

<p><b>Cursor</b> - It is a small horizontal line or a vertical bar of the height of line, to represent position of character while typing. Cursor is mostly found in blinking state.  It moves as the user writes or deletes something.</p>

<p><b>Command</b> - A command is an executable instruction. It may have one or more parameters. Output on command execution is shown inline on the screen.  When output is produced, command prompt is displayed on the next line.</p>

<h2>Graphical User Interface</h2>

<p>Graphical User Interface provides the user graphical means to interact with the system. GUI can be combination of both hardware and software. Using GUI, user interprets the software.</p>

<p>Typically, GUI is more resource consuming than that of CLI. With advancing technology, the programmers and designers create complex GUI designs that work with more efficiency, accuracy and speed.</p>

<h3>GUI Elements</h3>

<p>GUI provides a set of components to interact with software or hardware.</p>

<p>Every graphical component provides a way to work with the system. A GUI system has following elements such as:</p>

<p><b>Window</b> - An area where contents of application are displayed. Contents in a window can be displayed in the form of icons or lists, if the window represents file structure. It is easier for a user to navigate in the file system in an exploring window. Windows can be minimized, resized or maximized to the size of screen. They can be moved anywhere on the screen. A window may contain another window of the same application, called child window.</p>

<p><b>Tabs</b> - If an application allows executing multiple instances of itself, they appear on the screen as separate windows.<b> Tabbed Document Interface</b> has come up to open multiple documents in the same window. This interface also helps in viewing preference panel in application. All modern web-browsers use this feature.</p>

<p><b>Menu</b> - Menu is an array of standard commands, grouped together and placed at a visible place (usually top) inside the application window. The menu can be programmed to appear or hide on mouse clicks.</p>

<p><b>Icon</b> - An icon is small picture representing an associated application. When these icons are clicked or double clicked, the application window is opened. Icon displays application and programs installed on a system in the form of small pictures.</p>

<p><b>Cursor</b> - Interacting devices such as mouse, touch pad, digital pen are represented in GUI as cursors. On screen cursor follows the instructions from hardware in almost real-time. Cursors are also named pointers in GUI systems. They are used to select menus, windows and other application features.</p>

<h3>Application specific GUI components</h3>

<p>A GUI of an application contains one or more of the listed GUI elements:</p>

<p><b>Application Window</b> - Most application windows uses the constructs supplied by operating systems but many use their own customer created windows to contain the contents of application.</p>

<p><b>Dialogue Box </b> - It is a child window that contains message for the user and request for some action to be taken. For Example: Application generate a dialogue to get confirmation from user to delete a file.</p>

<p><b>Text-Box</b> -  Provides an area for user to type and enter text-based data.</p>

<p><b>Buttons</b> - They imitate real life buttons and are used to submit inputs to the software.</p>

<p><b>Radio-button</b> - Displays available options for selection. Only one can be selected among all offered.</p>

<p><b>Check-box</b> - Functions similar to list-box. When an option is selected, the box is marked as checked. Multiple options represented by check boxes can be selected.</p>

<p><b>List-box </b> - Provides list of available items for selection. More than one item can be selected.</p>

<p>Other impressive GUI components are:</p>

<h2>User Interface Design Activities</h2>

<p>There are a number of activities performed for designing user interface. The process of GUI design and implementation is alike SDLC. Any model can be used for GUI implementation among Waterfall, Iterative or Spiral Model.</p>

<p>A model used for GUI design and development should fulfill these GUI specific steps.</p>

<p><b>GUI Requirement Gathering</b> - The designers may like to have list of all functional and non-functional requirements of GUI. This can be taken from user and their existing software solution.</p>

<p><b>User Analysis</b> - The designer studies who is going to use the software GUI. The target audience matters as the design details change according to the knowledge and competency level of the user. If user is technical savvy, advanced and complex GUI can be incorporated. For a novice user, more information is included on how-to of software.</p>

<p><b>Task Analysis</b> - Designers have to analyze what task is to be done by the software solution.  Here in GUI, it does not matter how it will be done.  Tasks can be represented in hierarchical manner taking one major task and dividing it further into smaller sub-tasks.  Tasks provide goals for GUI presentation. Flow of information among sub-tasks determines the flow of GUI contents in the software.</p>

<p><b>GUI Design & implementation</b> - Designers after having information about requirements, tasks and user environment, design the GUI and implements into code and embed the GUI with working or dummy software in the background.  It is then self-tested by the developers.</p>

<p><b>Testing</b> - GUI testing can be done in various ways.  Organization can have in-house inspection, direct involvement of users and release of beta version are few of them.  Testing may include usability, compatibility, user acceptance etc.</p>

<h2>GUI Implementation Tools</h2>

<p>There are several tools available using which the designers can create entire GUI on a mouse click. Some tools can be embedded into the software environment (IDE).</p>

<p>GUI implementation tools provide powerful array of GUI controls. For software customization, designers can change the code accordingly.</p>

<p>There are different segments of GUI tools according to their different use and platform.</p>

<h3>Example</h3>

<p>Mobile GUI, Computer GUI, Touch-Screen GUI etc. Here is a list of few tools which come handy to build GUI:</p>

<h2>User Interface Golden rules</h2>

<p>The following rules are mentioned to be the golden rules for GUI design, described by Shneiderman and Plaisant in their book (Designing the User Interface).</p>

<p><b>Strive for consistency</b> - Consistent sequences of actions should be required in similar situations. Identical terminology should be used in prompts, menus, and help screens. Consistent commands should be employed throughout.</p>

<p><b>Enable frequent users to use short-cuts</b> - The user’s desire to reduce the number of interactions increases with the frequency of use.  Abbreviations, function keys, hidden commands, and macro facilities are very helpful to an expert user.</p>

<p><b>Offer informative feedback</b> - For every operator action, there should be some system feedback. For frequent and minor actions, the response must be modest, while for infrequent and major actions, the response must be more substantial.</p>

<p><b>Design dialog to yield closure</b> - Sequences of actions should be organized into groups with a beginning, middle, and end. The informative feedback at the completion of a group of actions gives the operators the satisfaction of accomplishment, a sense of relief, the signal to drop contingency plans and options from their minds, and  this indicates that the way ahead is clear to prepare for the next group of actions.</p>

<p><b>Offer simple error handling</b> - As much as possible, design the system so the user will not make a serious error. If an error is made, the system should be able to detect  it and offer simple, comprehensible mechanisms for handling the error.</p>

<p><b>Permit easy reversal of actions</b> - This feature relieves anxiety, since the user knows that errors can be undone. Easy reversal of actions  encourages exploration of unfamiliar options. The units of reversibility may be a single action, a data entry, or a complete group of actions.</p>

<p><b>Support internal locus of control</b> - Experienced operators strongly desire the sense that they are in charge of the system and that the system responds to their actions. Design the system to make users the initiators of actions rather than the responders.</p>

<p><b>Reduce short-term memory load</b> - The limitation of human information processing in short-term memory requires the  displays to be kept simple, multiple page displays be consolidated, window-motion frequency be reduced, and sufficient training time be allotted for codes, mnemonics, and sequences of actions. </p>

<h1>Software Design Complexity</h1>

<p>The term complexity stands for state of events or things, which have multiple interconnected links and highly complicated structures. In software programming, as the design of software is realized, the number of  elements and their interconnections gradually emerge to be huge, which becomes too difficult to understand at once.</p>

<p>Software design complexity  is difficult to assess without using complexity metrics and measures. Let us see three important software complexity measures.</p>

<h2>Halstead's Complexity Measures</h2>

<p>In 1977, Mr. Maurice Howard Halstead introduced metrics to measure software complexity.  Halstead’s metrics depends upon the actual implementation of program and its measures, which are computed directly from the operators and operands from source code, in static manner. It allows to evaluate testing time, vocabulary, size, difficulty, errors, and efforts for C/C++/Java source code.</p>

<p>According to Halstead, “A computer program is an implementation of an algorithm considered to be a collection of tokens which can be classified as either operators or operands”.  Halstead metrics think a program as sequence of operators and their associated operands.</p>

<p>He defines various indicators to check complexity of module.</p>

<p>When we select source file to view its complexity details in Metric Viewer, the following result is seen in Metric Report:</p>

<h2>Cyclomatic Complexity Measures</h2>

<p>Every program encompasses statements to execute in order to perform some task and other decision-making statements that decide, what statements need to be executed. These decision-making constructs change the flow of the program. </p>

<p>If we compare two programs of same size, the one with more decision-making statements will be more complex as the control of program jumps frequently.</p>

<p>McCabe, in 1976, proposed Cyclomatic Complexity Measure to quantify complexity of a given software.  It is graph driven model that is based on decision-making constructs of program such as if-else, do-while, repeat-until, switch-case and goto statements.</p>

<p>Process to make flow control graph:</p>

<p>If control can branch from block i to block j</p>

<p>Draw an arc</p>

<p>From exit node to entry node</p>

<p>Draw an arc.</p>

<p>To calculate Cyclomatic complexity of a program module, we use the formula -</p>

<p>The Cyclomatic complexity of the above module is</p>

<p>According to P. Jorgensen, Cyclomatic Complexity of a module should not exceed 10.</p>

<h2>Function Point</h2>

<p>It is widely used to measure the size of software.  Function Point concentrates on functionality provided by the system.  Features and functionality of the system are used to measure the software complexity.</p>

<p>Function point counts on five parameters, named as External Input, External Output, Logical Internal Files, External Interface Files, and External Inquiry. To consider the complexity of software  each parameter is further categorized as simple, average or complex.  </p>

<p>Let us see parameters of function point:</p>

<h3>External Input</h3>

<p>Every unique input to the system, from outside, is considered as external input.  Uniqueness of input is measured, as no two inputs should have same formats.  These inputs can either be data or control parameters.</p>

<p><b>Simple</b> - if input count is low and affects less internal files</p>

<p><b>Complex</b> - if input count is high and affects more internal files</p>

<p><b>Average</b> - in-between simple and complex.</p>

<h3>External Output</h3>

<p> All output types provided by the system are counted in this category. Output is considered unique if their output format and/or processing are unique.</p>

<p><b>Simple</b> - if output count is low</p>

<p><b>Complex</b> - if output count is high</p>

<p><b>Average</b> - in between simple and complex.</p>

<h3>Logical Internal Files</h3>

<p> Every software system maintains internal files in order to maintain its functional information and to function properly. These files hold logical data of the system.  This logical data may contain both functional data and control data.</p>

<p><b>Simple</b> - if number of record types are low</p>

<p><b>Complex</b> - if number of record types are high</p>

<p><b>Average</b> - in between simple and complex.</p>

<h3>External Interface Files</h3>

<p> Software system may need to share its files with some external software or it may need to pass the file for processing or as parameter to some function. All these files are counted as external interface files.</p>

<p><b>Simple</b> - if number of record types in shared file are low</p>

<p><b>Complex</b> - if number of record types in shared file are high</p>

<p><b>Average</b> - in between simple and complex.</p>

<h3>External Inquiry </h3>

<p> An inquiry is a combination of input and output, where user sends some data to inquire about as input and the system responds to the user with the output of inquiry processed.  The complexity of a query is more than External Input and External Output.  Query is said to be unique if its input and output are unique in terms of format and data.</p>

<p><b>Simple</b> - if query needs low processing and yields small amount of output data</p>

<p><b>Complex</b> - if query needs high process and yields large amount of output data</p>

<p><b>Average</b> - in between simple and complex.</p>

<p>Each of these parameters in the system is given weightage according to their class and complexity.  The table below mentions the weightage given to each parameter:</p>

<p>The table above yields raw Function Points. These function points are  adjusted according to the environment complexity. System is described using  fourteen different characteristics:</p>

<p>These characteristics factors are then rated from 0 to 5, as mentioned below:</p>

<p>All ratings are then summed up as N. The value of N ranges from 0 to 70 (14 types of characteristics x 5 types of ratings).  It is used to calculate Complexity Adjustment Factors (CAF), using the following formulae:</p>

<p>Then,</p>

<p>This FP can then be used in various metrics, such as:</p>

<p><b>Cost</b> = $ / FP</p>

<p><b>Quality</b> = Errors / FP</p>

<p><b>Productivity</b> = FP / person-month</p>

<h1>Software Implementation</h1>

<p>In this chapter, we will study about programming methods, documentation and challenges in software implementation.</p>

<h2>Structured Programming</h2>

<p>In the process of coding, the lines of code keep multiplying, thus, size of the software increases. Gradually, it becomes next to impossible to remember the flow of program. If one forgets how software and its underlying programs, files, procedures are constructed it then becomes very difficult to share, debug and modify the program. The solution to this is structured programming. It encourages the developer to use subroutines and loops instead of using simple jumps in the code, thereby bringing clarity in the code and improving its efficiency Structured programming also helps programmer to reduce coding time and organize code properly.</p>

<p>Structured programming states how the program shall be coded.  Structured programming uses three main concepts:</p>

<p><b>Top-down analysis</b> - A software is always made to perform some rational work. This rational work is known as problem in the software parlance. Thus it is very important that we understand how to solve the problem. Under top-down analysis, the problem is broken down into small pieces where each one has some significance. Each problem is individually solved and steps are clearly stated about how to solve the problem.</p>

<p><b>Modular Programming</b> - While programming, the code is broken down into smaller group of instructions. These groups are known as modules, subprograms or subroutines. Modular programming based on the understanding of top-down analysis. It discourages jumps using ‘goto’ statements in the program, which often makes the program flow non-traceable. Jumps are prohibited and modular format is encouraged in structured programming. </p>

<p><b>Structured Coding </b> - In reference with top-down analysis, structured coding sub-divides the modules into further smaller units of code in the order of their execution. Structured programming uses control structure, which controls the flow of the program, whereas structured coding uses control structure to organize its instructions in definable patterns.</p>

<h2>Functional Programming</h2>

<p>Functional programming is style of programming language, which uses the concepts of mathematical functions. A function in mathematics should always produce the same result on receiving the same argument. In procedural languages, the flow of the program runs through procedures, i.e. the control of program is transferred to the called procedure. While control flow is transferring from one procedure to another, the program changes its state.</p>

<p>In procedural programming, it is possible for a procedure to produce different results when it is called with the same argument, as the program itself can be in different state while calling it. This is a property as well as a drawback of procedural programming, in which the sequence or timing of the procedure execution becomes important.</p>

<p>Functional programming provides means of computation as mathematical functions, which produces results irrespective of program state. This makes it possible to predict the behavior of the program.</p>

<p>Functional programming uses the following concepts:</p>

<p><b>First class and High-order functions</b> - These functions have capability to accept another function as argument or they return other functions as results.</p>

<p><b>Pure functions</b> - These functions do not include destructive updates, that is, they do not affect any I/O or memory and if they are not in use, they can easily be removed without hampering the rest of the program.</p>

<p><b>Recursion</b> - Recursion is a programming technique where a function calls itself and repeats the program code in it unless some pre-defined condition matches. Recursion is the way of creating loops in functional programming.</p>

<p><b>Strict evaluation</b> - It is a method of evaluating the expression passed to a function as an argument. Functional programming has two types of evaluation methods, strict (eager) or non-strict (lazy). Strict evaluation always evaluates the expression before invoking the function. Non-strict evaluation does not evaluate the expression unless it is needed.</p>

<p><b>λ-calculus</b> - Most functional programming languages use λ-calculus as their type systems. λ-expressions are executed by evaluating them as they occur.</p>

<p>Common Lisp, Scala, Haskell, Erlang and F# are some examples of functional programming languages.</p>

<h2>Programming style</h2>

<p>Programming style is set of coding rules followed by all the programmers to write the code. When multiple programmers work on the same software project, they frequently need to work with the program code written by some other developer. This becomes tedious or at times impossible, if all developers do not follow some standard programming style to code the program. </p>

<p>An appropriate programming style includes using function and variable names relevant to the intended task, using well-placed indentation, commenting code for the convenience of reader and overall presentation of code. This makes the program code readable and understandable by all, which in turn makes debugging and error solving easier. Also, proper coding style helps ease the documentation and updation.</p>

<h3>Coding Guidelines</h3>

<p>Practice of coding style varies with organizations, operating systems and language of coding itself. </p>

<p>The following coding elements may be defined under coding guidelines of an organization:</p>

<p><b>Naming conventions</b> - This section defines how to name functions, variables, constants and global variables.</p>

<p><b>Indenting</b> - This is the space left at the beginning of line, usually 2-8 whitespace or single tab.</p>

<p><b>Whitespace</b> - It is generally omitted at the end of line.</p>

<p><b>Operators</b> - Defines the rules of writing mathematical, assignment and logical operators. For example, assignment operator ‘=’ should have space before and after it, as in “x = 2”.</p>

<p><b>Control Structures</b> - The rules of writing if-then-else, case-switch, while-until and for control flow statements solely and in nested fashion.</p>

<p><b>Line length and wrapping</b> - Defines how many characters should be there in one line, mostly a line is 80 characters long. Wrapping defines how a line should be wrapped, if is too long.</p>

<p><b>Functions</b> - This defines how functions should be declared and invoked, with and without parameters.</p>

<p><b>Variables</b> - This mentions how variables of different data types are declared and defined.</p>

<p><b>Comments</b> - This is one of the important coding components, as the comments included in the code describe what the code actually does and all other associated descriptions. This section also helps creating help documentations for other developers.</p>

<h2>Software Documentation</h2>

<p>Software documentation is an important part of software process. A well written document provides a great tool and means of information repository necessary to know about software process. Software documentation also provides information about how to use the product.</p>

<p>A well-maintained documentation should involve the following documents:</p>

<p><b>Requirement documentation </b> - This documentation works as key tool for software designer, developer and the test team to carry out their respective tasks. This document contains all the functional, non-functional and behavioral description of the intended software.  </p>

<p>Source of this document can be previously stored data about the software, already running software at the client’s end, client’s interview, questionnaires and research. Generally it is stored in the form of spreadsheet or word processing document with the high-end software management team.</p>

<p>This documentation works as foundation for the software to be developed and is majorly used in verification and validation phases. Most test-cases are built directly from requirement documentation.</p>

<p><b>Software Design documentation </b> - These documentations contain all the necessary information, which are needed to build the software. It contains: <b>(a)</b> High-level software architecture, <b>(b)</b> Software design details, <b>(c)</b> Data flow diagrams, <b>(d)</b> Database design</p>

<p>These documents work as repository for developers to implement the software. Though these documents do not give any details on how to code the program, they give all necessary information that is required for coding and implementation. </p>

<p><b>Technical documentation</b> - These documentations are maintained by the developers and actual coders. These documents, as a whole, represent information about the code. While writing the code, the programmers also mention objective of the code, who wrote it, where will it be required, what it does and how it does, what other resources the code uses, etc.</p>

<p>The technical documentation increases the understanding between various programmers working on the same code. It enhances re-use capability of the code. It makes debugging easy and traceable.</p>

<p>There are various automated tools available and some comes with the programming language itself. For example java comes JavaDoc tool to generate technical documentation of code.</p>

<p><b>User documentation</b> - This documentation is different from all the above explained. All previous documentations are maintained to provide information about the software and its development process. But user documentation explains how the software product should work and how it should be used to get the desired results.</p>

<p>These documentations may include, software installation procedures, how-to guides, user-guides, uninstallation method and special references to get more information like license updation etc.</p>

<h2>Software Implementation Challenges</h2>

<p>There are some challenges faced by the development team while implementing the software. Some of them are mentioned below:</p>

<p><b>Code-reuse</b> - Programming interfaces of present-day languages are very sophisticated and are equipped huge library functions. Still, to bring the cost down of end product, the organization management prefers to re-use the code, which was created earlier for some other software. There are huge issues faced by programmers for compatibility checks and deciding how much code to re-use.</p>

<p><b>Version Management</b> - Every time a new software is issued to the customer, developers have to maintain version and configuration related documentation. This documentation needs to be highly accurate and available on time.</p>

<p><b>Target-Host</b> - The software program, which is being developed in the organization, needs to be designed for host machines at the customers end. But at times, it is impossible to design a software that works on the target machines.</p>

<h1>Software Testing Overview</h1>

<p>Software Testing is evaluation of the software against requirements gathered from users and system specifications. Testing is conducted at the phase level in software development life cycle or at module level in program code. Software testing comprises of Validation and Verification.</p>

<h2>Software Validation</h2>

<p>Validation is process of examining whether or not the software satisfies the user requirements. It is carried out at the end of the SDLC. If the software matches requirements for which it was made, it is validated.</p>

<h2>Software Verification</h2>

<p>Verification is the process of confirming if the software is meeting the business requirements, and is developed adhering to the proper specifications and methodologies. </p>

<p>Target of the test are - </p>

<p><b>Errors</b> - These are actual coding mistakes made by developers. In addition, there is a difference in output of software and desired output, is considered as an error.</p>

<p><b>Fault</b> - When error exists fault occurs. A fault, also known as a bug, is a result of an error which can cause system to fail.</p>

<p><b>Failure </b> - failure is said to be the inability of the system to perform the desired task.  Failure occurs when fault exists in the system.</p>

<h2>Manual Vs Automated Testing</h2>

<p>Testing can either be done manually or using an automated testing tool:</p>

<p><b>Manual</b> - This testing is performed without taking help of automated testing tools. The software tester prepares test cases for different sections and levels of the code, executes the tests and reports the result to the manager. </p>

<p>Manual testing is time and resource consuming. The tester needs to confirm whether or not right test cases are used. Major portion of testing involves manual testing.</p>

<p><b>Automated</b> This testing is a testing procedure done with aid of automated testing tools. The limitations with manual testing can be overcome using automated test tools.</p>

<p>A test needs to check if a webpage can be opened in Internet Explorer. This can be easily done with manual testing. But to check if the web-server can take the load of 1 million users, it is quite impossible to test manually. </p>

<p>There are software and hardware tools which helps tester in conducting load testing, stress testing, regression testing.</p>

<h2>Testing Approaches</h2>

<p>Tests can be conducted based on two approaches – </p>

<p>When functionality is being tested without taking the actual implementation in concern it is known as black-box testing.  The other side is known as white-box testing where not only functionality is tested but the way it is implemented is also analyzed.</p>

<p>Exhaustive tests are the best-desired method for a perfect testing. Every single possible value in the range of the input and output values is tested. It is not possible to test each and every value in real world scenario if the range of values is large.</p>

<h3>Black-box testing</h3>

<p>It is carried out to test functionality of the program. It is also called ‘Behavioral’ testing. The tester in this case, has a set of input values and respective desired results. On providing input, if the output matches with the desired results, the program is tested ‘ok’, and problematic otherwise. </p>

<p>In this testing method, the design and structure of the code are not known to the tester, and testing engineers and end users conduct this test on the software.</p>

<p>Black-box testing techniques:</p>

<p><b>Equivalence class</b> - The input is divided into similar classes.  If one element of a class passes the test, it is assumed that all the class is passed.</p>

<p><b>Boundary values</b> - The input is divided into higher and lower end values.  If these values pass the test, it is assumed that all values in between may pass too.</p>

<p><b>Cause-effect graphing</b> - In both previous methods, only one input value at a time is tested. Cause (input) – Effect (output) is a testing technique where combinations of input values are tested in a systematic way.</p>

<p><b>Pair-wise Testing</b> - The behavior of software depends on multiple parameters. In pairwise testing, the multiple parameters are tested pair-wise for their different values.</p>

<p><b>State-based testing</b> - The system changes state on provision of input. These systems are tested based on their states and input.</p>

<h3>White-box testing</h3>

<p> It is conducted to test program and its implementation, in order to improve code efficiency or structure. It is also known as ‘Structural’ testing.</p>

<p>In this testing method, the design and structure of the code are known to the tester. Programmers of the code conduct this test on the code.</p>

<p>The below are some White-box testing techniques:</p>

<p><b>Control-flow testing</b> - The purpose of the control-flow testing to set up test cases which covers all statements and branch conditions.  The branch conditions are tested for both being true and false, so that all statements can be covered.</p>

<p><b>Data-flow testing</b> - This testing technique emphasis to cover all the data variables included in the program.  It tests where the variables were declared and defined and where they were used or changed.</p>

<h2>Testing Levels</h2>

<p>Testing itself may be defined at various levels of SDLC. The testing process runs parallel to software development. Before jumping on the next stage, a stage is tested, validated and verified.</p>

<p>Testing separately is done just to make sure that there are no hidden bugs or issues left in the software.  Software is tested on various levels -</p>

<h3>Unit Testing</h3>

<p> While coding, the programmer performs some tests on that unit of program to know if it is error free.  Testing is performed under white-box testing approach. Unit testing helps developers decide that individual units of the program are working as per requirement and are error free.</p>

<h3>Integration Testing</h3>

<p>Even if the units of software are working fine individually, there is a need to find out if the units if integrated together would also work without errors. For example, argument passing and data updation etc.</p>

<h3>System Testing </h3>

<p>The software is compiled as product and then it is tested as a whole.  This can be accomplished using one or more of the following tests:</p>

<p><b>Functionality testing</b> - Tests all functionalities of the software against the requirement.</p>

<p><b>Performance testing</b> - This test proves how efficient the software is.  It tests the effectiveness and average time taken by the software to do desired task.  Performance testing is done by means of load testing and stress testing where the software is put under high user and data load under various environment conditions.</p>

<p><b>Security & Portability</b> - These tests are done when the software is meant to work on various platforms and accessed by number of persons.</p>

<h3>Acceptance Testing</h3>

<p> When the software is ready to hand over to the customer it has to go through last phase of testing where it is tested for user-interaction and response.  This is important because even if the software matches all user requirements and if user does not like the way it appears or works, it may be rejected.</p>

<p><b>Alpha testing</b> - The team of developer themselves perform alpha testing by using the system as if it is being used in work environment. They try to find out how user would react to some action in software and how the system should respond to inputs.</p>

<p><b>Beta testing</b> - After the software is tested internally, it is handed over to the users to use it under their production environment only for testing purpose. This is not as yet the delivered product. Developers expect that users at this stage will bring minute problems, which were skipped to attend.</p>

<h3>Regression Testing</h3>

<p>Whenever a software product is updated with new code, feature or functionality, it is tested thoroughly to detect if there is any negative impact of the added code. This is known as regression testing.</p>

<h2>Testing Documentation</h2>

<p>Testing documents are prepared at different stages -</p>

<h3>Before Testing</h3>

<p>Testing starts with test cases generation. Following documents are needed for reference –</p>

<p><b>SRS document</b> - Functional Requirements document</p>

<p><b>Test Policy document</b> - This describes how far testing should take place before releasing the product.</p>

<p><b>Test Strategy document</b> - This mentions detail aspects of test team, responsibility matrix and rights/responsibility of test manager and test engineer.</p>

<p><b>Traceability Matrix document</b> - This is SDLC document, which is related to requirement gathering process. As new requirements come, they are added to this matrix. These matrices help testers know the source of requirement.  They can be traced forward and backward.</p>

<h3>While Being Tested</h3>

<p>The following documents may be required while testing is started and is being done:</p>

<p><b>Test Case document</b> - This document contains list of tests required to be conducted.  It includes Unit test plan, Integration test plan, System test plan and Acceptance test plan.</p>

<p><b>Test description</b> - This document is a detailed description of all test cases and procedures to execute them.</p>

<p><b>Test case report</b> - This document contains test case report as a result of the test.</p>

<p><b>Test logs</b> - This document contains test logs for every test case report.</p>

<h3>After Testing</h3>

<p>The following documents may be generated after testing :</p>

<p><b>Test summary</b> - This test summary is collective analysis of all test reports and logs.  It summarizes and concludes if the software is ready to be launched. The software is released under version control system if it is ready to launch.</p>

<h2>Testing vs. Quality Control, Quality Assurance and Audit</h2>

<p>We need to understand that software testing is different from software quality assurance, software quality control and software auditing.</p>

<p><b>Software quality assurance</b> - These are software development process monitoring means, by which it is assured that all the measures are taken as per the standards of organization. This monitoring is done to make sure that proper software development methods were followed.</p>

<p><b>Software quality control</b> - This is a system to maintain the quality of software product. It may include functional and non-functional aspects of software product, which enhance the goodwill of the organization. This system makes sure that the customer is receiving quality product for their requirement and the product certified as ‘fit for use’.</p>

<p><b>Software audit</b> - This is a review of procedure used by the organization to develop the software.  A team of auditors, independent of development team examines the software process, procedure, requirements and other aspects of SDLC.  The purpose of software audit is to check that software and its development process, both conform standards, rules and regulations.</p>

<h1>Software Maintenance Overview</h1>

<p>Software maintenance is widely accepted part of SDLC now a days.  It stands for all the modifications and updations done after the delivery of software product.  There are number of reasons, why modifications are required, some of them are briefly mentioned below:</p>

<p><b>Market Conditions </b> - Policies, which changes over the time, such as taxation and newly introduced constraints like, how to maintain bookkeeping, may trigger need for modification.</p>

<p><b>Client Requirements</b> - Over the time, customer may ask for new features or functions in the software.</p>

<p><b>Host Modifications </b> - If any of the hardware and/or platform (such as operating system) of the target host changes, software changes are needed to keep adaptability.</p>

<p><b>Organization Changes</b> - If there is any business level change at client end, such as reduction of organization strength, acquiring another company, organization venturing into new business, need to modify in the original software may arise.</p>

<h2>Types of maintenance </h2>

<p>In a software lifetime, type of maintenance may vary based on its nature.  It may be just a routine maintenance tasks as some bug discovered by some user or it may be a large event in itself based on maintenance size or nature.  Following are some types of maintenance based on their characteristics:</p>

<p><b>Corrective Maintenance</b> - This includes modifications and updations done in order to correct or fix problems, which are either discovered by user or concluded by user error reports.</p>

<p><b>Adaptive Maintenance</b> - This includes modifications and updations applied to keep the software product up-to date and tuned to the ever changing world of technology and business environment.</p>

<p><b>Perfective Maintenance</b> - This  includes modifications and updates done in order to keep the software usable over long period of time. It includes new features, new user requirements for refining the software and improve  its reliability and performance.</p>

<p><b>Preventive Maintenance</b> - This includes modifications and updations to prevent future problems of the software. It aims to attend problems, which are not significant at this moment but may cause serious issues in future.</p>

<h2>Cost of Maintenance</h2>

<p>Reports suggest that the cost of maintenance is high. A study on estimating software maintenance found that the cost of maintenance is as high as 67% of the cost of entire software process cycle.</p>

<p>On an average, the cost of software maintenance is more than 50% of all SDLC phases. There are various factors, which trigger maintenance cost go high, such as: </p>

<h3>Real-world factors affecting Maintenance Cost</h3>

<h3>Software-end factors  affecting Maintenance Cost</h3>

<h2>Maintenance Activities</h2>

<p>IEEE provides a framework for sequential maintenance process activities.  It can be used in iterative manner and can be extended so that customized items and processes can be included. </p>

<p>These activities go hand-in-hand with each of the following phase:</p>

<p><b>Identification &amp; Tracing</b> - It involves activities pertaining to identification of requirement of  modification or maintenance.  It is generated by user or system may itself report via logs or error messages.Here, the maintenance type is classified also.</p>

<p><b>Analysis</b> - The modification is analyzed for its impact on the system including safety and security implications. If probable impact is severe, alternative solution is looked for. A set of required modifications is then materialized into requirement specifications. The cost of modification/maintenance is analyzed and estimation is concluded.</p>

<p><b>Design</b> - New modules, which need to be replaced or modified, are designed against requirement specifications set in the previous stage. Test cases are created for validation and verification.</p>

<p><b>Implementation</b> - The new modules are coded with the help of structured design created in the design step.Every programmer is expected to do unit testing in parallel.</p>

<p><b>System Testing</b> - Integration testing is done among newly created modules. Integration testing is also carried out between  new modules and the system. Finally the system is tested as a whole, following regressive testing procedures.</p>

<p><b>Acceptance Testing</b> - After testing the system internally, it is tested for acceptance with the help of users. If at this state, user complaints some issues they are addressed or noted to address in next iteration.</p>

<p><b>Delivery</b> - After acceptance test, the system is deployed all over the organization either by small update package or fresh installation of the system. The final testing takes place at client end after the software is delivered. </p>

<p>Training facility is provided if required, in addition to the hard copy of user manual.</p>

<p><b>Maintenance management</b> - Configuration management is an essential part of system maintenance. It is aided with version control tools to control versions, semi-version or patch management.</p>

<h2>Software Re-engineering</h2>

<p>When we need to update the software to keep it to the current market, without impacting its functionality, it is called software re-engineering. It is a thorough process  where the design of software is changed and programs are re-written.</p>

<p>Legacy software cannot keep tuning with the latest technology available in the market. As the hardware become obsolete, updating of software becomes a headache. Even if software  grows old with time, its functionality does not.  </p>

<p>For example, initially Unix was developed in assembly language. When language C came into existence, Unix was re-engineered in C, because working in assembly language was difficult.</p>

<p>Other than  this, sometimes programmers notice that few parts of software need more maintenance than others and they  also need re-engineering.</p>

<h3>Re-Engineering Process</h3>

<p>There are few important terms used in Software re-engineering</p>

<h3>Reverse Engineering</h3>

<p>It is a process to achieve system specification by thoroughly analyzing, understanding the existing system.  This process can be seen as reverse SDLC model, i.e. we try to get higher abstraction level by analyzing lower abstraction levels.</p>

<p>An existing system is previously implemented design, about which we know nothing.  Designers then do reverse engineering by looking at the code and try to get the design.  With design in hand, they try to conclude the specifications.  Thus, going in reverse from code to system specification.</p>

<h3>Program Restructuring</h3>

<p>It is a process to re-structure and re-construct the existing software.  It is all about re-arranging the source code, either in same programming language or from one programming language to a different one.  Restructuring can have either source code-restructuring and data-restructuring or both.</p>

<p>Re-structuring does not impact the functionality of the software but enhance reliability and maintainability.  Program  components, which cause errors very frequently can be changed, or updated with re-structuring.</p>

<p>The dependability of software on obsolete hardware platform can be removed via re-structuring.</p>

<h3>Forward Engineering</h3>

<p>Forward engineering is a process of obtaining desired software from the specifications in hand which were brought down by means of reverse engineering. It assumes that there was some software engineering already done in the past.</p>

<p> Forward engineering is same as software engineering process with only one difference – it is carried out always after reverse engineering.</p>

<h2>Component reusability</h2>

<p>A component is a part of software program code, which executes an independent task in the system.  It can be a small module or sub-system itself.</p>

<h3>Example</h3>

<p>The login procedures used on the web can be considered as components, printing system in software can be seen as a component of the software.</p>

<p>Components have high  cohesion of functionality and lower rate of coupling, i.e. they work independently and can perform tasks without depending on other modules.</p>

<p>In OOP, the objects are designed are very specific to their concern and have fewer chances to be used in some other software. </p>

<p>In modular programming, the modules are coded to perform specific tasks which can be used across number of other software programs.</p>

<p>There is a whole new vertical, which is based on re-use of software component, and is known as Component Based Software Engineering (CBSE).</p>

<p>Re-use can be done at various levels</p>

<p><b>Application level </b> - Where an entire application is used as sub-system of new software.</p>

<p><b>Component level </b> -  Where sub-system of an application is used.</p>

<p><b>Modules level </b> - Where functional modules are re-used.</p>

<p>Software components provide interfaces, which can be used to establish communication among different components.</p>

<h3>Reuse Process</h3>

<p>Two kinds of method can be adopted: either by keeping requirements same and adjusting components or by keeping components same and modifying requirements.</p>

<p><b>Requirement Specification</b> - The functional and non-functional requirements are specified, which a software product must comply to, with the help of existing system, user input or both. </p>

<p><b>Design</b> - This is also a standard SDLC process step, where requirements are defined in terms of software parlance.  Basic architecture of system as a whole and its sub-systems are created.</p>

<p><b>Specify Components </b> - By studying the software design, the designers segregate the entire system into smaller components or sub-systems. One  complete software design turns into a collection of a huge set of components working together.</p>

<p><b>Search Suitable Components</b> - The software component repository is referred by designers to search for the matching component, on the basis of functionality and intended software requirements..</p>

<p><b>Incorporate Components</b> - All matched components are packed together to shape them as complete software.</p>

<h1>Software Case Tools Overview</h1>

<h2>CASE Tools </h2>

<p>CASE tools are set of software application programs, which are used to automate SDLC activities. CASE tools are used by software project managers, analysts and engineers to develop  software system. </p>

<p>There are number of CASE tools available to simplify various stages of Software Development Life Cycle such as Analysis tools, Design tools, Project management tools, Database Management tools, Documentation tools are to name a few. </p>

<p>Use of CASE tools accelerates the development of project to produce desired result and helps to uncover flaws before moving ahead with next stage in software development. </p>

<h2>Components of CASE Tools</h2>

<p>CASE tools can be broadly divided into the following parts based on their use at a particular SDLC stage:</p>

<p><b>Central Repository</b> - CASE tools require  a central repository, which can serve as a source of common, integrated and consistent information.  Central repository  is a central place of storage where product specifications, requirement documents, related reports and diagrams, other useful information regarding management is stored.  Central repository also serves as data dictionary.</p>

<p><b>Upper Case Tools</b> - Upper CASE tools are used in planning, analysis and design stages of SDLC.</p>

<p><b>Lower Case Tools</b> - Lower CASE tools are used in implementation, testing and maintenance.</p>

<p><b>Integrated Case Tools</b> - Integrated CASE tools are helpful in all the stages of SDLC, from Requirement gathering to Testing and documentation.</p>

<p>CASE tools can be grouped together if they have similar functionality, process activities and capability of getting integrated with other tools. </p>

<h2>Scope of Case Tools</h2>

<p>The scope of CASE tools goes throughout the SDLC.</p>

<h2>Case Tools Types</h2>

<p>Now we briefly go through various CASE tools</p>

<h3>Diagram tools </h3>

<p>These tools are used to represent  system components, data and control flow among various software components and system structure in a graphical form.  For example, Flow Chart Maker tool for creating state-of-the-art flowcharts.</p>

<h3>Process Modeling Tools</h3>

<p>Process modeling is method to create software process model, which is  used to develop the software. Process modeling tools help the managers to choose a process model or modify it as per the requirement of software product. For example, EPF Composer</p>

<h3>Project Management Tools</h3>

<p>These tools are used for project planning, cost and effort estimation, project scheduling and resource planning. Managers have to strictly comply project execution with every mentioned step in software project management. Project management tools help in storing and sharing project information in real-time throughout the organization. For example, Creative Pro Office, Trac Project, Basecamp.</p>

<h3>Documentation Tools</h3>

<p>Documentation in a software project starts prior to the software process, goes throughout all phases of SDLC and after the completion of the project. </p>

<p>Documentation tools generate documents for technical users and end users. Technical users are mostly in-house professionals of the development team who refer to system manual, reference manual, training manual, installation manuals etc. The end user documents describe the functioning and how-to of the system such as user manual. For example, Doxygen, DrExplain, Adobe RoboHelp for documentation.</p>

<h3>Analysis Tools</h3>

<p>These tools help to gather requirements, automatically check for any inconsistency, inaccuracy in the diagrams, data redundancies or erroneous omissions. For example, Accept 360, Accompa, CaseComplete for requirement analysis, Visible Analyst for total analysis.</p>

<h3>Design Tools</h3>

<p>These tools help software designers to design the block structure of the software, which may further be broken down in smaller modules using refinement techniques. These tools provides detailing of each module and interconnections among modules. For example, Animated Software Design</p>

<h3>Configuration Management Tools</h3>

<p>An instance of software is released under one version.  Configuration Management tools deal with –</p>

<p>CASE tools help in this by automatic tracking, version management and release management. For example,  Fossil, Git, Accu REV.</p>

<h3>Change Control Tools</h3>

<p>These tools are considered as a part of configuration management tools. They deal with changes made to the software after its baseline is fixed or when the software is first released. CASE tools automate change tracking, file management, code management and more. It also helps in enforcing change policy of the organization.</p>

<h3>Programming Tools </h3>

<p>These tools consist of programming environments like IDE (Integrated Development Environment), in-built modules library and simulation tools. These tools provide comprehensive aid in building software product and include features for simulation and testing. For example,  Cscope to search code in C, Eclipse.</p>

<h3>Prototyping Tools </h3>

<p>Software prototype is simulated version of the intended software product. Prototype provides initial look and feel of the product and simulates few aspect of actual product.  </p>

<p>Prototyping CASE tools essentially come with graphical libraries. They can create hardware independent user interfaces and design. These tools help us to build rapid prototypes based on existing information. In addition, they provide simulation of software prototype. For example,  Serena prototype composer, Mockup Builder.</p>

<h3>Web Development Tools</h3>

<p>These tools assist in designing web pages with all allied elements like  forms, text, script, graphic and so on. Web tools also provide live preview of what is being developed and how will it look after completion. For example,  Fontello, Adobe Edge Inspect, Foundation 3, Brackets.</p>

<h3>Quality Assurance Tools</h3>

<p>Quality assurance in a software organization is monitoring the engineering process and methods adopted to develop the software product in order to ensure conformance of quality as per organization standards. QA tools consist of configuration and change control tools and software testing tools. For example,  SoapTest, AppsWatch, JMeter.</p>

<h3>Maintenance Tools</h3>

<p>Software maintenance includes modifications in the software product after it is delivered.  Automatic logging and error reporting techniques, automatic error ticket generation and root cause Analysis are few CASE tools, which help software organization in maintenance phase of SDLC. For example,  Bugzilla for defect tracking, HP Quality Center.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
IF-THEN-ELSE,  
DO-WHILE-UNTIL
</pre>
<p>Analyst uses the same variable and data name, which are stored in Data Dictionary, making it much simpler to write and understand the code.</p>
<h3>Example</h3>
<p>We take the same example of Customer Authentication in the online shopping environment. This procedure to authenticate customer can be written in Structured English as:</p>
<pre class="prettyprint notranslate">
Enter Customer_Name
SEEK Customer_Name in Customer_Name_DB file
IF Customer_Name found THEN
   Call procedure USER_PASSWORD_AUTHENTICATE()
ELSE
   PRINT error message
   Call procedure NEW_CUSTOMER_REQUEST()
ENDIF
</pre>
<p>The code written in Structured English is more  like day-to-day spoken English. It can not be implemented directly as a code of software. Structured English is independent of programming language.</p>
<h2>Pseudo-Code</h2>
<p>Pseudo code is written more close to programming language.  It may be considered as augmented programming language, full of comments and descriptions.  </p>
<p>Pseudo code avoids variable declaration but they are written using some actual programming language’s constructs, like C, Fortran, Pascal etc.</p>
<p>Pseudo code contains more programming details than Structured English.  It provides a method to perform the task, as if a computer is executing the code.</p>
<h3>Example</h3>
<p>Program to print Fibonacci up to n numbers.</p>
<pre class="prettyprint notranslate">
void function Fibonacci
Get value of n;
Set value of a to 1;
Set value of b to 1;
Initialize I to 0
for (i=0; i&lt; n; i++)
{
   if a greater than b 
   {
      Increase b by a;
      Print b;
   } 
   else if b greater than a
   {
      increase a by b;
      print a;
   }
}
</pre>
<h2>Decision Tables </h2>
<p>A Decision table represents conditions and the respective actions to be taken to address them, in a structured tabular format.</p>
<p>It is a powerful tool to debug and prevent errors. It helps group similar information into a single table and then by combining tables it delivers easy and convenient decision-making.</p>
<h3>Creating Decision Table</h3>
<p>To create the decision table, the developer must follow basic four steps:</p>
<ul class="list">
<li>Identify all possible conditions to be addressed</li>
<li>Determine actions for all identified conditions</li>
<li>Create Maximum possible rules</li>
<li>Define action for each rule</li>
</ul>
<p>Decision Tables should be verified by end-users and can lately be simplified by eliminating duplicate rules and actions.</p>
<h3>Example</h3>
<p>Let us take a simple example of day-to-day problem with our Internet connectivity. We begin by identifying all problems that can arise while starting the internet and their respective possible solutions.  </p>
<p>We list all possible problems under column conditions and the prospective actions under column Actions.</p>
<table  class="src">
  <tr>
  <th></th>
  <th>Conditions/Actions</th>
  <th colspan="8">Rules</th>
  </tr>
  <tr>
  <th rowspan="3" style="border-bottom:1px solid #999;">Conditions</th>
  <td>Shows Connected</td>
  <td>N</td>
  <td>N</td>
  <td>N</td>
  <td>N</td>
  <td>Y</td>
  <td>Y</td>
  <td>Y</td>
  <td>Y</td>
  </tr>
  <tr>
  <td>Ping is Working</td>
  <td>N</td>
  <td>N</td>
  <td>Y</td>
  <td>Y</td>
  <td>N</td>
  <td>N</td>
  <td>Y</td>
  <td>Y</td>
  </tr>
  <tr>
  <td style="border-bottom:1px solid #999;">Opens Website</td>
  <td style="border-bottom:1px solid #999;">Y</td>
  <td style="border-bottom:1px solid #999;">N</td>
  <td style="border-bottom:1px solid #999;">Y</td>
  <td style="border-bottom:1px solid #999;">N</td>
  <td style="border-bottom:1px solid #999;">Y</td>
  <td style="border-bottom:1px solid #999;">N</td>
  <td style="border-bottom:1px solid #999;">Y</td>
  <td style="border-bottom:1px solid #999;">N</td>
  </tr>
  <tr>
   <th rowspan="5">Actions</th>
  <td>Check network cable</td>
  <td>X</td>
  <td></td>
  <td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
  </tr>
  <tr>
  <td>Check internet router</td>
  <td>X</td>
  <td></td>
<td></td>
<td></td>
  <td>X</td>
  <td>X</td>
<td>X</td>
<td></td>
  </tr>
  <tr>
  <td>Restart Web Browser</td>
  <td></td>
<td></td>
  <td></td>
<td></td>
  <td></td>
  <td></td>
  <td>X</td>
  <td></td>
  </tr>
  <tr>
  <td>Contact Service provider</td>
  <td></td>
  <td>X</td>
  <td>X</td>
 <td>X</td>
 <td>X</td>
 <td>X</td>
 <td>X</td>
   <td></td>
  </tr>
<tr>
<td>Do no action</td>
<td></td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
<td></td>
<td> </td>
<td></td>
</tr>
</table>
  
<center><u>Table : Decision Table – In-house Internet Troubleshooting</u></center>
<h2>Entity-Relationship Model</h2>
<p>Entity-Relationship model is a type of database model based on the notion of real world entities and relationship among them.  We can map real world scenario onto ER database model. ER Model creates a set of entities with their attributes, a set of constraints and relation among them.</p>
<p>ER Model is best used for the conceptual design of database. ER Model can be represented as follows :</p>
<img src="/software_engineering/images/er_model_intro.png" alt="ER Model"/>
<ul class="list">
<li><p><b>Entity</b> - An entity in ER Model is a real world  being, which has some properties called <b><i>attributes</i></b>.  Every attribute is defined by its corresponding set of values, called <b><i>domain</i></b>.</p>
<p>For example,  Consider a school database. Here, a student is  an entity. Student has various attributes like name, id, age and class etc.</p></li>
<li><p><b>Relationship</b> - The logical association among entities is called <b><i>relationship</i></b>.  Relationships are mapped with entities in various ways. Mapping cardinalities define the number of associations between two entities.</p>
<p>Mapping cardinalities:</p>
<ul class="list">
<li>one to one</li>
<li>one to many</li>
<li>many to one</li>
<li>many to many</li>
</ul>
</li>
</ul>  
<h2>Data Dictionary</h2>
<p>Data dictionary is the centralized collection of information about data. It stores meaning and origin of data, its relationship with other data, data format for usage etc. Data dictionary  has rigorous definitions of all names in order to facilitate user and software designers.</p>
<p>Data dictionary is often referenced as meta-data (data about data) repository.  It is created along  with DFD (Data Flow Diagram) model of software program and is expected to be updated whenever DFD is changed or updated.</p>
<h3>Requirement of Data Dictionary</h3>
<p>The data is referenced via data dictionary while designing and implementing software.  Data dictionary removes any chances of ambiguity.  It helps keeping work of programmers and designers synchronized while using same object reference everywhere in the program.</p>
<p>Data dictionary provides a way of documentation for the  complete database system in one place.  Validation of DFD is carried out using data dictionary.</p>
<h3>Contents</h3>
<p>Data dictionary should contain information about the following </p>
<ul class="list">
<li>Data Flow</li>
<li>Data Structure</li>
<li>Data Elements</li>
<li>Data Stores</li>
<li>Data Processing</li>
</ul>
<p>Data Flow is described by means of DFDs as studied earlier and represented in algebraic form as described.</p>
<table class="src">
<tr>
<th >=</th>
<th>Composed of</th>
</tr>
<tr>
<td>{}</td>
<td>Repetition</td>
</tr>
<tr>
<td>()</td>
<td>Optional</td>
</tr>
<tr>
<td>+</td>
<td>And</td>
</tr>
<tr>
<td>[ / ]</td>
<td>Or</td>
</tr>
</table>
<h3>Example</h3>
<p>Address = House No + (Street / Area) + City + State</p>
<p>Course ID = Course Number + Course Name + Course Level + Course Grades</p>
<h3>Data Elements</h3>
<p>Data elements consist of Name and descriptions of Data and Control Items, Internal or External data stores etc. with the following details:</p>
<ul class="list">
<li>Primary Name</li>
<li>Secondary Name (Alias)</li>
<li>Use-case (How  and where to use)</li>
<li>Content Description (Notation etc. )</li>
<li>Supplementary Information (preset values, constraints etc.)</li>
</ul>
<h3>Data Store</h3>
<p>It  stores the information from where the data enters into the system and exists out of the system. The Data Store may include -</p>
<ul class="list">
<li><b>Files</b>
<ul class="list">
<li>Internal to software.</li>
<li>External to software but on the same machine.</li>
<li>External to software and system, located on different machine.</li>
</ul>
</li>
<li><b>Tables</b>
<ul class="list">
<li>Naming convention</li>
<li>  Indexing property</li>
</ul>
</li>
</ul>
<h3>Data Processing</h3>
<p>There are two types of Data Processing:</p>
<ul class="list">
<li><b>Logical:</b> As user sees it</li>
<li><b>Physical:</b> As software sees it</li>
</ul>

<h1>Software Design Strategies</h1>
<p>Software design is a process to conceptualize the software requirements into software implementation. Software design takes the user requirements as challenges and tries to find optimum solution. While the software is being conceptualized, a plan is chalked out to find the best possible design for implementing the intended solution.  </p>
<p>There are multiple variants of software design. Let us study them briefly:</p>
<h2>Structured Design</h2>
<p>Structured design is a conceptualization of problem into several well-organized elements of solution.  It is basically concerned with the solution design.  Benefit of structured design is, it gives better understanding of how the problem is being solved.  Structured design also makes it simpler for designer to concentrate on the problem more accurately. </p>
<p>Structured design is mostly based on ‘divide and conquer’ strategy where a problem is broken into several small problems and each small problem is individually solved until the whole problem is solved.</p>
<p>The small pieces of problem are solved by means of solution modules.  Structured design emphasis that these modules be well organized in order to achieve precise solution.  </p>
<p>These modules are arranged in hierarchy. They communicate with each other. A good structured design always follows some rules for communication among multiple modules, namely -</p>
<p><b>Cohesion</b> -  grouping of all functionally related elements.</p>
<p><b>Coupling</b> - communication between different modules.</p>
<p>A good structured design has high cohesion and low coupling arrangements.</p>
<h2>Function Oriented Design</h2>
<p>In function-oriented design, the system is comprised of many smaller sub-systems known as functions.  These functions are capable of performing significant task in the system. The system is considered as top view of all functions.</p>
<p>Function oriented design inherits some properties of structured design where divide and conquer methodology is used.</p>
<p>This design mechanism divides the whole system into smaller functions, which provides means of abstraction by concealing the information and their operation.. These functional modules can share information among themselves by means of information passing and using information available globally.</p>
<p>Another characteristic of functions is that when a program calls a function, the function changes the state of the program, which sometimes is not acceptable by other modules. Function oriented design works well where the system state does not matter and program/functions work on input rather than on a state.</p>
<h3>Design Process</h3>
<ul class="list">
<li>The whole system is seen as how data flows in the system by means of data flow diagram.</li>
<li>DFD depicts  how functions changes data and state of entire system.</li>
<li>The entire system is logically broken down into smaller units known as functions on the basis of their operation in the system.</li>
<li>Each function is then described at large.</li>
</ul>
<h2>Object Oriented Design</h2>
<p>Object oriented design works around the entities and their characteristics instead of functions involved in the software system.  This design strategies focuses on entities and its characteristics.  The whole concept of software solution revolves around the engaged entities.</p>
<p>Let us see the important concepts of Object Oriented Design:</p>
<ul class="list">
<li><b>Objects - </b>All entities involved in the solution design are known as objects.  For example, person, banks, company and customers are treated as objects.  Every entity has some attributes associated to it and has some methods to perform on the attributes.</li>
<li><p><b>Classes - </b>A class is a generalized description of an object.  An object is an instance of a class.  Class defines all the attributes, which an object can have and methods, which defines the functionality of the object.</p>
<p>In the solution design, attributes are stored as variables and functionalities are defined by means of methods or procedures.</li>
<li><b>Encapsulation - </b>In OOD, the attributes (data variables) and methods (operation on the data) are bundled together is called encapsulation. Encapsulation not only bundles important information of an object together, but also restricts access of the data and methods from the outside world. This is called information hiding.</li>
<li><b>Inheritance - </b>OOD allows similar classes to stack up in hierarchical manner where the lower or sub-classes can import, implement and re-use allowed variables and methods from their immediate super classes. This property of OOD is known  as inheritance.  This makes it easier to define specific class and to create generalized classes from specific ones.</li>
<li><b>Polymorphism - </b>OOD languages provide a mechanism where methods performing similar tasks but vary in arguments, can be assigned same name. This is called polymorphism, which allows a single interface performing tasks for different types.  Depending upon how the function is invoked, respective portion of the code gets executed. </li>
</ul>
<h3>Design Process</h3>
<p>Software design process can be perceived as series of well-defined steps.  Though it varies according to design approach (function oriented or object oriented, yet It may have the following steps involved:</p>
<ul class="list">
<li>A solution design is created from requirement or previous used system and/or system sequence diagram.</li>
<li>Objects are identified and grouped into classes on behalf of similarity in attribute characteristics.</li>
<li>Class hierarchy and relation among them is defined.</li>
<li>Application framework is defined.</li>
</ul>
<h2>Software Design Approaches</h2>
<p>Here are two generic approaches for software designing:</p>
<h3>Top Down Design</h3>
<p>We know that a system is composed of more than one sub-systems and it contains a number of components.  Further, these sub-systems and components may have their on set of sub-system and components and creates hierarchical structure in the system.</p>
<p>Top-down design takes the whole software system as one entity and then decomposes it to achieve more than one sub-system or component based on some characteristics.  Each sub-system or component is then treated as a system and decomposed further.  This process keeps on running until the lowest level of system in the top-down hierarchy is achieved.</p>
<p>Top-down design starts with a generalized model of system and keeps on defining the more specific part of it.  When all components are composed the whole system comes into existence.</p>
<p>Top-down design is more suitable when the software solution needs to be designed from scratch and specific details are unknown.</p>
<h3>Bottom-up Design</h3>
<p>The bottom up design model starts with most specific and basic components.  It proceeds with composing higher level of components by using basic or lower level components. It keeps creating higher level components until the desired system is not evolved as one single component.  With each higher level, the amount of abstraction is increased.</p>
<p>Bottom-up strategy is more suitable when a system  needs to be created from some existing system, where the basic primitives can be used in the newer system.</p>
<p>Both, top-down and bottom-up approaches are not practical individually. Instead, a good combination of both is used.</p>

<h1>Software User Interface Design</h1>
<p>User interface is the front-end application view to which user interacts in order to use the software. User can manipulate and control the software as well as hardware by means of user interface.   Today, user interface is found at almost every place where digital technology exists, right from computers, mobile phones, cars, music players, airplanes, ships etc.</p>
<p>User interface is part of software and is designed such a way that it is expected to provide the user insight of the software.  UI provides fundamental platform for human-computer interaction.  </p>
<p>UI can be graphical, text-based, audio-video based, depending upon the underlying hardware and software combination.  UI can be hardware or software or a combination of both.</p>
<p>The software becomes more popular if its user interface is:</p>
<ul class="list">
<li>Attractive</li>
<li>Simple to use</li>
<li>Responsive in short time</li>
<li>Clear to understand</li>
<li>Consistent on all interfacing screens</li>
</ul>
<p>UI is broadly divided into two categories:</p>
<ul class="list">
<li>Command Line Interface</li>
<li>Graphical User Interface</li>
</ul>
<h2>Command Line Interface (CLI)</h2>
<p>CLI has been a great tool of interaction with computers until the video display monitors came into existence. CLI is first choice of many technical users and programmers. CLI is minimum interface a software can provide to its users.</p>
<p>CLI provides a command prompt, the place where the user types the command and feeds to the system. The user needs to remember the syntax of command and its use.  Earlier CLI were not programmed to handle the user errors effectively.</p>
<p>A command is a text-based reference to set of instructions, which are expected to be executed by the system. There are methods like macros, scripts that make it easy for the user to operate.</p>
<p>CLI uses less amount of computer resource as compared to GUI.</p>
<h3>CLI Elements</h3>
<img src="/software_engineering/images/CLI.png" alt="Command Line Interface (CLI)"/>
<p>A text-based command line interface can have the following elements:</p>
<ul class="list">
<li><p><b>Command Prompt</b>  - It is text-based notifier that is mostly shows the context in which the user is working.  It is generated by the software system.</p></li>
<li><p><b>Cursor</b> - It is a small horizontal line or a vertical bar of the height of line, to represent position of character while typing. Cursor is mostly found in blinking state.  It moves as the user writes or deletes something.</p></li>
<li><p><b>Command</b> - A command is an executable instruction. It may have one or more parameters. Output on command execution is shown inline on the screen.  When output is produced, command prompt is displayed on the next line.</p></li>
</ul>
<h2>Graphical User Interface</h2>
<p>Graphical User Interface provides the user graphical means to interact with the system. GUI can be combination of both hardware and software. Using GUI, user interprets the software.</p> 
<p>Typically, GUI is more resource consuming than that of CLI. With advancing technology, the programmers and designers create complex GUI designs that work with more efficiency, accuracy and speed.</p>
<h3>GUI Elements</h3>
<p>GUI provides a set of components to interact with software or hardware.</p>
<p>Every graphical component provides a way to work with the system. A GUI system has following elements such as:</p>
<img src="/software_engineering/images/GUI.png" alt="Graphical User Interface"/>
<ul class="list">
<li><p><b>Window</b> - An area where contents of application are displayed. Contents in a window can be displayed in the form of icons or lists, if the window represents file structure. It is easier for a user to navigate in the file system in an exploring window. Windows can be minimized, resized or maximized to the size of screen. They can be moved anywhere on the screen. A window may contain another window of the same application, called child window.</p></li>
<li><p><b>Tabs</b> - If an application allows executing multiple instances of itself, they appear on the screen as separate windows.<b> Tabbed Document Interface</b> has come up to open multiple documents in the same window. This interface also helps in viewing preference panel in application. All modern web-browsers use this feature.</p></li>
<li><p><b>Menu</b> - Menu is an array of standard commands, grouped together and placed at a visible place (usually top) inside the application window. The menu can be programmed to appear or hide on mouse clicks.</p></li>
<li><p><b>Icon</b> - An icon is small picture representing an associated application. When these icons are clicked or double clicked, the application window is opened. Icon displays application and programs installed on a system in the form of small pictures.</p></li>
<li><p><b>Cursor</b> - Interacting devices such as mouse, touch pad, digital pen are represented in GUI as cursors. On screen cursor follows the instructions from hardware in almost real-time. Cursors are also named pointers in GUI systems. They are used to select menus, windows and other application features.</p></li>
</ul>
<h3>Application specific GUI components</h3>
<p>A GUI of an application contains one or more of the listed GUI elements:</p>
<ul class="list">
<li><p><b>Application Window</b> - Most application windows uses the constructs supplied by operating systems but many use their own customer created windows to contain the contents of application.</p></li>
<li><p><b>Dialogue Box </b> - It is a child window that contains message for the user and request for some action to be taken. For Example: Application generate a dialogue to get confirmation from user to delete a file.</p>
<img src="/software_engineering/images/dialog_box.png" alt="Dialogue Box"/></li>
<li><p><b>Text-Box</b> -  Provides an area for user to type and enter text-based data.</p></li>
<li><p><b>Buttons</b> - They imitate real life buttons and are used to submit inputs to the software.</p>
<img src="/software_engineering/images/GUI_buttons.png" alt="Radio-button"/></li>
<li><p><b>Radio-button</b> - Displays available options for selection. Only one can be selected among all offered.</p></li>
<li><p><b>Check-box</b> - Functions similar to list-box. When an option is selected, the box is marked as checked. Multiple options represented by check boxes can be selected.</p></li>
<li><p><b>List-box </b> - Provides list of available items for selection. More than one item can be selected.</p>
<img src="/software_engineering/images/GUI_list.png" alt="List-box"/></li>
</ul>
<p>Other impressive GUI components are:</p>
<ul class="list">
<li>Sliders</li>
<li>Combo-box</li>
<li>Data-grid</li>
<li>Drop-down list</li>
</ul>
<h2>User Interface Design Activities</h2>
<p>There are a number of activities performed for designing user interface. The process of GUI design and implementation is alike SDLC. Any model can be used for GUI implementation among Waterfall, Iterative or Spiral Model.</p> 
<p>A model used for GUI design and development should fulfill these GUI specific steps.</p>
<img src="/software_engineering/images/GUI_process.png" alt="GUI Process"/>
<ul class="list">
<li><p><b>GUI Requirement Gathering</b> - The designers may like to have list of all functional and non-functional requirements of GUI. This can be taken from user and their existing software solution.</p></li>
<li><p><b>User Analysis</b> - The designer studies who is going to use the software GUI. The target audience matters as the design details change according to the knowledge and competency level of the user. If user is technical savvy, advanced and complex GUI can be incorporated. For a novice user, more information is included on how-to of software.</p></li>
<li><p><b>Task Analysis</b> - Designers have to analyze what task is to be done by the software solution.  Here in GUI, it does not matter how it will be done.  Tasks can be represented in hierarchical manner taking one major task and dividing it further into smaller sub-tasks.  Tasks provide goals for GUI presentation. Flow of information among sub-tasks determines the flow of GUI contents in the software.</p></li>
<li><p><b>GUI Design & implementation</b> - Designers after having information about requirements, tasks and user environment, design the GUI and implements into code and embed the GUI with working or dummy software in the background.  It is then self-tested by the developers.</p></li>
<li><p><b>Testing</b> - GUI testing can be done in various ways.  Organization can have in-house inspection, direct involvement of users and release of beta version are few of them.  Testing may include usability, compatibility, user acceptance etc.</p></li>
</ul>
<h2>GUI Implementation Tools</h2>
<p>There are several tools available using which the designers can create entire GUI on a mouse click. Some tools can be embedded into the software environment (IDE).</p>  
<p>GUI implementation tools provide powerful array of GUI controls. For software customization, designers can change the code accordingly.</p>
<p>There are different segments of GUI tools according to their different use and platform.</p>
<h3>Example</h3>
<p>Mobile GUI, Computer GUI, Touch-Screen GUI etc. Here is a list of few tools which come handy to build GUI:</p>
<ul class="list">
<li>FLUID</li>
<li>AppInventor (Android)</li>
<li>LucidChart</li>
<li>Wavemaker</li>
<li>Visual Studio</li>
</ul>
<h2>User Interface Golden rules</h2>
<p>The following rules are mentioned to be the golden rules for GUI design, described by Shneiderman and Plaisant in their book (Designing the User Interface).</p>
<ul class="list">
<li><p><b>Strive for consistency</b> - Consistent sequences of actions should be required in similar situations. Identical terminology should be used in prompts, menus, and help screens. Consistent commands should be employed throughout.</p></li>
<li><p><b>Enable frequent users to use short-cuts</b> - The user’s desire to reduce the number of interactions increases with the frequency of use.  Abbreviations, function keys, hidden commands, and macro facilities are very helpful to an expert user.</p></li>
<li><p><b>Offer informative feedback</b> - For every operator action, there should be some system feedback. For frequent and minor actions, the response must be modest, while for infrequent and major actions, the response must be more substantial.</p></li>
<li><p><b>Design dialog to yield closure</b> - Sequences of actions should be organized into groups with a beginning, middle, and end. The informative feedback at the completion of a group of actions gives the operators the satisfaction of accomplishment, a sense of relief, the signal to drop contingency plans and options from their minds, and  this indicates that the way ahead is clear to prepare for the next group of actions.</p></li>
<li><p><b>Offer simple error handling</b> - As much as possible, design the system so the user will not make a serious error. If an error is made, the system should be able to detect  it and offer simple, comprehensible mechanisms for handling the error.</p></li>
<li><p><b>Permit easy reversal of actions</b> - This feature relieves anxiety, since the user knows that errors can be undone. Easy reversal of actions  encourages exploration of unfamiliar options. The units of reversibility may be a single action, a data entry, or a complete group of actions.</p></li>
<li><p><b>Support internal locus of control</b> - Experienced operators strongly desire the sense that they are in charge of the system and that the system responds to their actions. Design the system to make users the initiators of actions rather than the responders.</p></li>
<li><p><b>Reduce short-term memory load</b> - The limitation of human information processing in short-term memory requires the  displays to be kept simple, multiple page displays be consolidated, window-motion frequency be reduced, and sufficient training time be allotted for codes, mnemonics, and sequences of actions. </p></li>
</ul>

<h1>Software Design Complexity</h1>
<p>The term complexity stands for state of events or things, which have multiple interconnected links and highly complicated structures. In software programming, as the design of software is realized, the number of  elements and their interconnections gradually emerge to be huge, which becomes too difficult to understand at once.</p>
<p>Software design complexity  is difficult to assess without using complexity metrics and measures. Let us see three important software complexity measures.</p>
<h2>Halstead's Complexity Measures</h2>
<p>In 1977, Mr. Maurice Howard Halstead introduced metrics to measure software complexity.  Halstead’s metrics depends upon the actual implementation of program and its measures, which are computed directly from the operators and operands from source code, in static manner. It allows to evaluate testing time, vocabulary, size, difficulty, errors, and efforts for C/C++/Java source code.</p>
<p>According to Halstead, “A computer program is an implementation of an algorithm considered to be a collection of tokens which can be classified as either operators or operands”.  Halstead metrics think a program as sequence of operators and their associated operands.</p>
<p>He defines various indicators to check complexity of module.</p>
<table class="src">
<tr>
<th>Parameter</th>
<th>Meaning</th>
</tr>
<tr>
<td>n1</td>
<td>Number of unique operators</td>
</tr>
<tr>
<td>n2</td>
<td>Number of unique operands</td>
</tr>
<tr>
<td>N1</td>
<td>Number of total occurrence of operators</td>
</tr>
<tr>
<td>N2</td>
<td>Number of total occurrence of operands</td>
</tr>
</table>
<p>When we select source file to view its complexity details in Metric Viewer, the following result is seen in Metric Report:</p>
<table class="src">
<tr>
<th>Metric</th>
<th>Meaning</th>
<th>Mathematical Representation</th>
</tr>
<tr>
<td>n</td>
<td>Vocabulary</td>
<td>n1 + n2</td>
</tr>
<tr>
<td>N</td>
<td>Size</td>
<td>N1 + N2</td>
</tr>
<tr>
<td>V</td>
<td>Volume</td>
<td>Length * Log2 Vocabulary</td>
</tr>
<tr>
<td>D</td>
<td>Difficulty</td>
<td>(n1/2) * (N1/n2)</td>
</tr>
<tr>
<td>E</td>
<td>Efforts</td>
<td>Difficulty * Volume</td>
</tr>
<tr>
<td>B</td>
<td>Errors</td>
<td>Volume / 3000</td>
</tr>
<tr>
<td>T</td>
<td>Testing time</td>
<td>Time = Efforts / S, where S=18 seconds.</td>
</tr>
</table>
<h2>Cyclomatic Complexity Measures</h2>
<p>Every program encompasses statements to execute in order to perform some task and other decision-making statements that decide, what statements need to be executed. These decision-making constructs change the flow of the program. </p>
<p>If we compare two programs of same size, the one with more decision-making statements will be more complex as the control of program jumps frequently.</p>
<p>McCabe, in 1976, proposed Cyclomatic Complexity Measure to quantify complexity of a given software.  It is graph driven model that is based on decision-making constructs of program such as if-else, do-while, repeat-until, switch-case and goto statements.</p>
<p>Process to make flow control graph:</p>
<ul class="list">
<li>Break program in smaller blocks, delimited by decision-making constructs.</li>
<li>Create nodes representing each of these nodes.</li>
<li>Connect nodes as follows: </li>
<ul class="list">
<li><p>If control can branch from block i to block j</p>
<p>Draw an arc</p></li>
<li><p>From exit node to entry node</p>
<p>Draw an arc.</p></li>
</ul>
</ul>
<p>To calculate Cyclomatic complexity of a program module, we use the formula -</p> 
<pre class="prettyprint notranslate">
V(G) = e – n + 2

Where
e is total number of edges
n is total number of nodes
</pre>
<img src="/software_engineering/images/cyclomatic_complexity.png" alt="Cyclomatic Complexity Measures"/>
<p>The Cyclomatic complexity of the above module is</p>
<pre class="prettyprint notranslate">
e = 10
n = 8
Cyclomatic Complexity = 10 - 8 + 2
                      = 4
</pre>
<p>According to P. Jorgensen, Cyclomatic Complexity of a module should not exceed 10.</p>
<h2>Function Point</h2>
<p>It is widely used to measure the size of software.  Function Point concentrates on functionality provided by the system.  Features and functionality of the system are used to measure the software complexity.</p>
<p>Function point counts on five parameters, named as External Input, External Output, Logical Internal Files, External Interface Files, and External Inquiry. To consider the complexity of software  each parameter is further categorized as simple, average or complex.  </p>
<img src="/software_engineering/images/function_points.png" alt="Function Point"/>
<p>Let us see parameters of function point:</p>
<h3>External Input</h3>
<p>Every unique input to the system, from outside, is considered as external input.  Uniqueness of input is measured, as no two inputs should have same formats.  These inputs can either be data or control parameters.</p>
<ul class="list">
<li><p><b>Simple</b> - if input count is low and affects less internal files</p></li>
<li><p><b>Complex</b> - if input count is high and affects more internal files</p></li>
<li><p><b>Average</b> - in-between simple and complex.</p></li>
</ul>
<h3>External Output</h3>
<p> All output types provided by the system are counted in this category. Output is considered unique if their output format and/or processing are unique.</p>
<ul class="list">
<li><p><b>Simple</b> - if output count is low</p></li>
<li><p><b>Complex</b> - if output count is high</p></li>
<li><p><b>Average</b> - in between simple and complex.</p></li>
</ul>
<h3>Logical Internal Files</h3>
<p> Every software system maintains internal files in order to maintain its functional information and to function properly. These files hold logical data of the system.  This logical data may contain both functional data and control data.</p>
<ul class="list">
<li><p><b>Simple</b> - if number of record types are low</p></li>
<li><p><b>Complex</b> - if number of record types are high</p></li>
<li><p><b>Average</b> - in between simple and complex.</p></li>
</ul>
<h3>External Interface Files</h3>
<p> Software system may need to share its files with some external software or it may need to pass the file for processing or as parameter to some function. All these files are counted as external interface files.</p>
<ul class="list">
<li><p><b>Simple</b> - if number of record types in shared file are low</p></li>
<li><p><b>Complex</b> - if number of record types in shared file are high</p></li>
<li><p><b>Average</b> - in between simple and complex.</p></li>
</ul>
<h3>External Inquiry </h3>
<p> An inquiry is a combination of input and output, where user sends some data to inquire about as input and the system responds to the user with the output of inquiry processed.  The complexity of a query is more than External Input and External Output.  Query is said to be unique if its input and output are unique in terms of format and data.</p>
<ul class="list">
<li><p><b>Simple</b> - if query needs low processing and yields small amount of output data</p></li>
<li><p><b>Complex</b> - if query needs high process and yields large amount of output data</p></li>
<li><p><b>Average</b> - in between simple and complex.</p></li>
</ul>
<p>Each of these parameters in the system is given weightage according to their class and complexity.  The table below mentions the weightage given to each parameter:</p>
<table class="src">
<tr>
<th>Parameter</th>
<th>Simple</th>
<th>Average</th>
<th>Complex</th>
</tr>
<tr>
<td>Inputs</td>
<td>3</td>
<td>4</td>
<td>6</td>
</tr>
<tr>
<td>Outputs</td>
<td>4</td>
<td>5</td>
<td>7</td>
</tr>
<tr>
<td>Enquiry</td>
<td>3</td>
<td>4</td>
<td>6</td>
</tr>
<tr>
<td>Files</td>
<td>7</td>
<td>10</td>
<td>15</td>
</tr>
<tr>
<td>Interfaces</td>
<td>5</td>
<td>7</td>
<td>10</td>
</tr>
</table>
<p>The table above yields raw Function Points. These function points are  adjusted according to the environment complexity. System is described using  fourteen different characteristics:</p>
<ul class="list">
<li>Data communications</li>
<li>Distributed processing</li>
<li>Performance objectives</li>
<li>Operation configuration load</li>
<li>Transaction rate</li>
<li>Online data entry,</li>
<li>End user efficiency</li>
<li>Online update</li>
<li>Complex processing logic</li>
<li>Re-usability</li>
<li>Installation ease</li>
<li>Operational ease</li>
<li>Multiple sites</li>
<li>Desire to facilitate changes</li>
</ul>
<p>These characteristics factors are then rated from 0 to 5, as mentioned below:</p>
<ul class="list">
<li>No influence</li>
<li>Incidental</li>
<li>Moderate</li>
<li>Average</li>
<li>Significant</li>
<li>Essential</li>
</ul>
<p>All ratings are then summed up as N. The value of N ranges from 0 to 70 (14 types of characteristics x 5 types of ratings).  It is used to calculate Complexity Adjustment Factors (CAF), using the following formulae:</p>
<pre class="prettyprint notranslate;">
CAF = 0.65 + 0.01N
</pre>
<p>Then,</p>
<pre class="prettyprint notranslate;">
Delivered Function Points (FP)= CAF x Raw FP
</pre>

<title>Page Not Found</title>

<h2>404 - Page Not Found</h2>

<h2>404 <i class="icon icon-file"></i></h2>

<p>We're sorry, but the page you were looking for doesn't exist.</p>

<p>Here are some useful links</p>

<h4>Mobile First</h4>

<h4>About us</h4>

<h4>Extra Links</h4>

<h4>Contact Us</h4>

<p><i class="icon icon-map-marker"></i> <strong>Address:</strong> 3rd Floor, Jyoti Celestia, Madhapur, Hyderabad, Telangana 500081</p>

<p><i class="icon icon-envelope"></i> <strong>Email:</strong> <a href="about/contact_us.htm">Click Here</a></p>

<p><i class="icon icon-dribbble"></i> <strong>Website:</strong> <a href="http://www.tutorialspoint.com">www.tutorialspoint.com</a></p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

</body></html>