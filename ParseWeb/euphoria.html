<!DOCTYPE html><html><body><title>Euphoria Programming Language Tutorial</title>

<h1>Euphoria Programming Language Tutorial</h1>

<p>This tutorial gives you basic understanding of Euphoria programming language. Euphoria is simple, flexible, easy to learn, and interpreted high-level programming language for DOS, Windows, Linux, FreeBSD, and more. This tutorial describes everything a programmer needs to know such as its environment, data types, syntax and operators, file handling, and controlling the flow of program.</p>

<h1>Audience</h1>

<p>This tutorial is designed for the aspiring students who are keen to learn and understand Euphoria in detail. This tutorial would be of great help for the IT professionals working as programmers. The enthusiastic readers can access this tutorial as a source of additional reading.</p>

<h1>Prerequisites</h1>

<p>Before proceeding with this tutorial, you need to have a basic knowledge of working on Windows or Linux. You need to be familiar with any programming language such as C, C++. You need to have sound understanding of operating system, memory allocation and de-allocation, and basics of efficient programming and debugging.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Euphoria Overview</title>

<h1>Euphoria - Overview</h1>

<p>Euphoria stands for <b>E</b>nd-<b>U</b>ser <b>P</b>rogramming with <b>H</b>ierarchical <b>O</b>bjects for <b>R</b>obust <b>I</b>nterpreted <b>A</b>pplications. Euphoria's first incarnation was created by Robert Craig on an Atari Mega-ST and it was first released in 1993. It is now maintained by Rapid Deployment Software.</p>

<p>It is a free, simple, flexible, easy to learn, and interpreted but extremely fast 32-bit high-level programming language for DOS, Windows, Linux, FreeBSD and more.</p>

<p>Euphoria is being used to develop Windows GUI programs, high-speed DOS games, and Linux/FreeBSD X Windows programs. Euphoria can also be used for CGI (Webbased) programming.</p>

<h2>Euphoria Features</h2>

<p>Here is the list of major features of Euphoria &minus;</p>

<p>It is a simple, flexible, powerful language definition that is easy to learn and use.</p>

<p>It supports dynamic storage allocation which means variables grow or shrink without the programmer having to worry about allocating and freeing the memory. It takes care of garbage collection automatically.</p>

<p>It is extremely faster than conventional interpreters such as Perl and Python.</p>

<p>Euphoria programs run under Linux, FreeBSD, 32-bit Windows, and any DOS environment.</p>

<p>Euphoria programs are not subject to any 640K memory limitations.</p>

<p>It provides an optimizing Euphoria-To-C translator which you can use to translate your Euphoria program into C and then compile it with a C compiler to get an executable (.exe) file. This can boost your program speed by 2 to 5 times.</p>

<p>Underlying hardware are completely hidden which means programs are not aware of word-lengths, underlying bit-level representation of values, byte-order etc.</p>

<p>Euphoria installation comes along with a full-screen source debugger, an execution profiler, and a full-screen multi-file editor.</p>

<p>It supports run-time error-handling, subscript, and type checking.</p>

<p>It is an open source language and comes completely free of cost.</p>

<h2>Platform Requirements</h2>

<p>Euphoria is available on Windows, Linux, FreeBSD, and OSX. Here is the bare minimum version required with the following platforms &minus;</p>

<p><b>WIN32 version</b> &minus; You need Windows 95 or any later version of Windows. It runs fine on XP and Vista.</p>

<p><b>Linux version</b> &minus; You need any reasonably up-to-date Linux distribution, that has libc6 or later. For example, Red Hat 5.2 or later works fine.</p>

<p><b>FreeBSD version</b> &minus; You need any reasonably up-to-date FreeBSD distribution.</p>

<p><b>Mac OS X version</b> &minus; You need any reasonably up-to-date Intel based Mac.</p>

<h2>Euphoria Limitations</h2>

<p>Here are some prominent limitations of Euphoria &minus;</p>

<p>Even though Euphoria is simple, fast, and flexible enough for the programmers; it does not provide call support for many important functionalities. For example, network programming.</p>

<p>Euphoria was invented in 1993, and still you would not find any book written on this language. There is also not much documentation available for the language.</p>

<p>But these days, the language is getting popular very fast and you can hope to have nice utilities and books available for the language very soon.</p>

<h2>Euphoria Licensing</h2>

<p>This product is free and open source, and has benefited from the contributions of many people. You have complete royalty-free rights to distribute any Euphoria programs that you develop.</p>

<p>Icon files, such as euphoria.ico and binaries available in euphoria\bin, may be distributed with or without your changes.</p>

<p>You can <b>shroud</b> or <b>bind</b> your program and distribute the resulting files royalty-free. Some additional 3<sup>rd</sup> party legal restrictions might apply when you use the Euphoria- To-C translator.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Euphoria Environment</title>

<h1>Euphoria - Environment</h1>

<p>This chapter describes about the installation of Euphoria on various platforms. You can follow the steps to install Euphoria on Linux, FreeBSD, and 32-bit Windows. So you can choose the steps based on your working environment.</p>

<h2>Linux, Free BSD Installation</h2>

<p>Official website provides <b>.tar.gz</b> file to install Euphoria on your Linux or BSD OS. You can download your latest version of Euphoria from its official website &minus; <a rel="nofollow" href="http://www.rapideuphoria.com/" target="_blank">Download Euphoria</a>.</p>

<p>Once you have .tar.gz file, here are three simple steps to be performed to install Euphoria on your Linux or Free BSD machine &minus;</p>

<p><b>Step 1</b> &minus; Installing Files</p>

<p>Untar the downloaded file <b>euphoria-4.0b2.tar.gz</b> in a directory where you want to install Euphoria. If you want to install it in /home directory as follows, then &minus;</p>

<p>This creates a directory hierarchy inside <b>/home/euphoria-4.0b2</b> directory as follows &minus;</p>

<p><b>NOTE</b> &minus; File name euphoria-4.0b2.tar.gz depends on latest version available. We are using 4.0b2 version of the language for this tutorial.</p>

<p><b>Step 2</b> &minus; Setting Up the Path</p>

<p>After installing Euphoria, you need to set proper paths so that your shell can find required Euphoria binaries and utilities. Before proceeding, there are following three important environment variables you need to set up &minus;</p>

<p>Set PATH environment variable to point /home/euphoria-4.0b2/bin directory.</p>

<p>Set EUDIR environment variable to point to /home/euphoria-4.0b2.</p>

<p>Set EUINC environment variable to point to /home/euphoria-4.0b2/include.</p>

<p>These variables can be set as follows &minus;</p>

<p><b>NOTE</b> &minus; The above commands used to set environment variables may differ depending on your Shell. We used <i>bash</i> shell for executing these commands to set the variables.</p>

<p><b>Step 3</b> &minus; Confirmation Installation</p>

<p>Confirm if you installed Euphoria successfully or not.</p>

<p>Execute the following command &minus;</p>

<p>If you get following result, then it means you have installed Euphoria successfully; otherwise you have to go back and check all the steps again.</p>

<p>That is it, Euphoria Programming Environment is ready on your UNIX machine, and you can start writing complex programs in easy steps.</p>

<h2>WIN32, and DOS Installation</h2>

<p>Official website provides <b>.exe</b> file to install Euphoria on your WIN32 or DOS OS. You can download your latest version of Euphoria from its official website &minus; <a href="http://www.rapideuphoria.com/" rel="nofollow" target="_blank">Download Euphoria</a>.</p>

<p>Once you have .exe file, here are three simple steps to follow for installing Euphoria Programming language on your WIN32 or DOS machine &minus;</p>

<p><b>Step 1</b> &minus; Installing Files</p>

<p>Double click on the downloaded <b>.exe</b> setup program to install all the files. We downloaded euphoria-40b2.exe file for installation.</p>

<p>The filename euphoria-40b2.exe depends on latest version available. We use version 4 beta 2 of the language.</p>

<p>By default Euphoria would be installed in C:\<i>euphoria-40b2</i> directory but you can also select a desired location.</p>

<p><b>Step 2</b> &minus; Rebooting the Machine</p>

<p>Re-boot your machine to complete the installation.</p>

<p><b>Step 3</b> &minus; Confirmation Installation</p>

<p>Confirm if you installed Euphoria successfully or not.</p>

<p>Execute the following command &minus;</p>

<p>If you get following result, then it means you have installed Euphoria successfully; otherwise you have to go back and check all the steps again.</p>

<p>That is it, Euphoria Programming Environment is ready on your WIN32 machine, and you can start writing complex programs in easy steps.</p>

<h2>Euphoria Interpreters</h2>

<p>Depending on the platform you are using, Euphoria has multiple interpreters &minus;</p>

<p>The main interpreter is <b>eui</b>.</p>

<p>On windows platforms, you have two choices. If you run <b>eui</b> then a console window is created. If you run <b>euiw</b> then no console is created, making it suitable for GUI applications.</p>

<p>Euphoria does not care about your choice of file extensions. By convention however; the console-based applications come with <b>.ex</b> extension.</p>

<p>GUI-based applications have <b>.exw</b> extension and the include files have <b>.e</b> extension.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
$cp euphoria-4.0b2.tar.gz /home
$cd /home
$gunzip euphoria-4.0b2.tar.gz
$tar -xvf euphoria-4.0b2.tar
</pre>
<p>This creates a directory hierarchy inside <b>/home/euphoria-4.0b2</b> directory as follows &minus;</p>
<pre class="result notranslate">
$ls -l
-rw-r--r-- 1 1001 1001 2485 Aug 17 06:15 Jamfile
-rw-r--r-- 1 1001 1001 5172 Aug 20 12:37 Jamrules
-rw-r--r-- 1 1001 1001 1185 Aug 13 06:21 License.txt
drwxr-xr-x 2 1001 1001 4096 Aug 31 10:07 bin
drwxr-xr-x 7 1001 1001 4096 Aug 31 10:07 demo
-rw-r--r-- 1 1001 1001 366 Mar 18 09:02 file_id.diz
drwxr-xr-x 4 1001 1001 4096 Aug 31 10:07 include
-rw-r--r-- 1 1001 1001 1161 Mar 18 09:02 installu.doc
drwxr-xr-x 4 1001 1001 4096 Aug 31 10:07 source
drwxr-xr-x 19 1001 1001 4096 Sep 7 12:09 tests
drwxr-xr-x 2 1001 1001 4096 Aug 31 10:07 tutorial
</pre>
<p><b>NOTE</b> &minus; File name euphoria-4.0b2.tar.gz depends on latest version available. We are using 4.0b2 version of the language for this tutorial.</p>
<p><b>Step 2</b> &minus; Setting Up the Path</p>
<p>After installing Euphoria, you need to set proper paths so that your shell can find required Euphoria binaries and utilities. Before proceeding, there are following three important environment variables you need to set up &minus;</p>
<ul class="list">
<li><p>Set PATH environment variable to point /home/euphoria-4.0b2/bin directory.</p></li>
<li><p>Set EUDIR environment variable to point to /home/euphoria-4.0b2.</p></li>
<li><p>Set EUINC environment variable to point to /home/euphoria-4.0b2/include.</p></li>
</ul>
<p>These variables can be set as follows &minus;</p>
<pre class="result notranslate">
$export PATH=$PATH:/home/euphoria-4.0b2/bin
$export EUDIR=/home/euphoria-4.0b2
$export EUINC=/home/euphoria-4.0b2/include
</pre>
<p><b>NOTE</b> &minus; The above commands used to set environment variables may differ depending on your Shell. We used <i>bash</i> shell for executing these commands to set the variables.</p>
<p><b>Step 3</b> &minus; Confirmation Installation</p>
<p>Confirm if you installed Euphoria successfully or not.</p>
<p>Execute the following command &minus;</p>
<pre class="result notranslate">
$eui -version
</pre>
<p>If you get following result, then it means you have installed Euphoria successfully; otherwise you have to go back and check all the steps again.</p>
<pre class="result notranslate">
$eui -version
Euphoria Interpreter 4.0.0 beta 2 (r2670) for Linux
Using System Memory
$
</pre>
<p>That is it, Euphoria Programming Environment is ready on your UNIX machine, and you can start writing complex programs in easy steps.</p>
<h2>WIN32, and DOS Installation</h2>
<p>Official website provides <b>.exe</b> file to install Euphoria on your WIN32 or DOS OS. You can download your latest version of Euphoria from its official website &minus; <a href="http://www.rapideuphoria.com/" rel="nofollow" target="_blank">Download Euphoria</a>.</p>
<p>Once you have .exe file, here are three simple steps to follow for installing Euphoria Programming language on your WIN32 or DOS machine &minus;</p>
<p><b>Step 1</b> &minus; Installing Files</p>
<p>Double click on the downloaded <b>.exe</b> setup program to install all the files. We downloaded euphoria-40b2.exe file for installation.</p>
<p>The filename euphoria-40b2.exe depends on latest version available. We use version 4 beta 2 of the language.</p>
<p>By default Euphoria would be installed in C:\<i>euphoria-40b2</i> directory but you can also select a desired location.</p>
<p><b>Step 2</b> &minus; Rebooting the Machine</p>
<p>Re-boot your machine to complete the installation.</p>
<p><b>Step 3</b> &minus; Confirmation Installation</p>
<p>Confirm if you installed Euphoria successfully or not.</p>
<p>Execute the following command &minus;</p>
<pre class="result notranslate">
c:\&gt;eui -version
</pre>
<p>If you get following result, then it means you have installed Euphoria successfully; otherwise you have to go back and check all the steps again.</p>
<pre class="result notranslate">
c:\&gt;eui -version
Euphoria Interpreter 4.0.0 beta 2 (r2670) for Windows
Using Managed Memory

c:\&gt;
</pre>

<title>Euphoria Basic Syntax</title>

<h1>Euphoria - Basic Syntax</h1>

<p>The Euphoria language has many similarities to Perl, C, and Java. However, there are some definite differences between the languages. This chapter is designed to quickly get you up to speed on the syntax that is expected in Euphoria.</p>

<p>This tutorial assumes you are working with Linux and all the examples have been written on Linux platform. But it is observed that there is no any prominent difference in program syntax on Linux and WIN32. Hence you can follow the same steps on WIN32.</p>

<h2>First Euphoria Program</h2>

<p>Let us write a simple Euphoria program in a script. Type the following source code in test.ex file and save it.</p>

<p>Let us say, Euphoria interpreter is available in <i>/home/euphoria-4.0b2/bin/</i> directory. Now run this program as follows &minus;</p>

<p>This produces the following result &minus;</p>

<p>This script used a built-in function <b>puts()</b> which takes two arguments. First argument indicates file name or device number, and second argument indicates a string which you want to print. Here 1 indicates STDOUT device.</p>

<h2>Euphoria Identifiers</h2>

<p>A Euphoria identifier is a name used to identify a variable, function, class, module, or other object. An identifier starts with a letter A to Z or a to z and then followed by letters, digits, or underscores.</p>

<p>Euphoria does not allow punctuation characters such as @, $, and % within identifiers.</p>

<p>Euphoria is a case sensitive programming language. Thus <b>Manpower</b> and <b>manpower</b> are two different identifiers in Euphoria. For example, the valid identifiers are &minus;</p>

<h2>Reserved Words</h2>

<p>The following list shows the reserved words in Euphoria. These reserved words may not be used as constant or variable or any other identifier names. Euphoria keywords contain lowercase letters only.</p>

<h2>Expressions</h2>

<p>Euphoria lets you calculate results by forming expressions. However, in Euphoria you can perform calculations on entire sequences of data with one expression.</p>

<p>You can handle a sequence much as you would handle a single number. It can be copied, passed to a subroutine, or calculated upon as a unit. For example &minus;</p>

<p>This is an expression that adds the sequence {1, 2, 3} and the atom 5 to get the resulting sequence {6, 7, 8}. You would learn sequences in subsequent chapters.</p>

<h2>Blocks of code</h2>

<p>One of the first caveats programmers encounter when learning Euphoria is the fact that there are no braces to indicate blocks of code for procedure and function definitions or flow control. Blocks of code are denoted by associated keywords.</p>

<p>The following example shows <b>if...then...end if</b> block &minus;</p>

<h2>Multi-Line Statements</h2>

<p>Statements in Euphoria typically end with a new line. Euphoria does however, allow to write a single statement in multiple lines. For example &minus;</p>

<h2>Escape Characters</h2>

<p>Escape characters may be entered using a back-slash. For example &minus;</p>

<p>The following table is a list of escape or non-printable characters that can be represented with backslash notation.</p>

<h2>Comments in Euphoria</h2>

<p>Any comments are ignored by the compiler and have no effect on execution speed. It is advisable to use more comments in your program to make it more readable.</p>

<p>There are three forms of comment text &minus;</p>

<p>Comments start by two dashes and extend to the end of the current line.</p>

<p>The multi-line format comment is kept inside /*...*/, even if that occurs on a different line.</p>

<p>You can use a special comment beginning with the two character sequence “#!” only on the first line of the program.</p>

<h3>Examples</h3>

<p>This produces the following result &minus;</p>

<p><b>Note</b> &minus; You can use a special comment beginning with “#!”. This informs the Linux shell that your file should be executed by the Euphoria interpreter.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui

puts(1, "Hello, Euphoria!\n")
</pre>
<p>Let us say, Euphoria interpreter is available in <i>/home/euphoria-4.0b2/bin/</i> directory. Now run this program as follows &minus;</p>
<pre class="prettyprint notranslate">
$ chmod +x test.ex    # This is to make file executable
$ ./test.ex
</pre>
<p>This produces the following result &minus;</p>
<pre class="result notranslate">
Hello, Euphoria!
</pre>
<p>This script used a built-in function <b>puts()</b> which takes two arguments. First argument indicates file name or device number, and second argument indicates a string which you want to print. Here 1 indicates STDOUT device.</p>
<h2>Euphoria Identifiers</h2>
<p>A Euphoria identifier is a name used to identify a variable, function, class, module, or other object. An identifier starts with a letter A to Z or a to z and then followed by letters, digits, or underscores.</p>
<p>Euphoria does not allow punctuation characters such as @, $, and % within identifiers.</p>
<p>Euphoria is a case sensitive programming language. Thus <b>Manpower</b> and <b>manpower</b> are two different identifiers in Euphoria. For example, the valid identifiers are &minus;</p>
<ul class="list">
<li>n</li>
<li>color26</li>
<li>ShellSort</li>
<li>quick_sort</li>
<li>a_very_long_indentifier</li>
</ul>
<h2>Reserved Words</h2>
<p>The following list shows the reserved words in Euphoria. These reserved words may not be used as constant or variable or any other identifier names. Euphoria keywords contain lowercase letters only.</p>
<table class="table table-bordered">
<tr>
<td>and</td>
<td>exit</td>
<td>override</td>
</tr>
<tr>
<td>as</td>
<td>export</td>
<td>procedure</td>
</tr>
<tr>
<td>break</td>
<td>fallthru</td>
<td>public</td>
</tr>
<tr>
<td>by</td>
<td>for</td>
<td>retry</td>
</tr>
<tr>
<td>case</td>
<td>function</td>
<td>return</td>
</tr>
<tr>
<td>constant</td>
<td>global</td>
<td>routine</td>
</tr>
<tr>
<td>continue</td>
<td>goto</td>
<td>switch</td>
</tr>
<tr>
<td>do</td>
<td>if</td>
<td>then</td>
</tr>
<tr>
<td>else</td>
<td>ifdef</td>
<td>to</td>
</tr>
<tr>
<td>elsedef</td>
<td>include</td>
<td>type</td>
</tr>
<tr>
<td>elsif</td>
<td>label</td>
<td>until</td>
</tr>
<tr>
<td>elsifdef</td>
<td>loop</td>
<td>while</td>
</tr>
<tr>
<td>end</td>
<td>namespace</td>
<td>with</td>
</tr>
<tr>
<td>entry</td>
<td>not</td>
<td>without</td>
</tr>
<tr>
<td>enum</td>
<td>or</td>
<td>xor</td>
</tr>
</table>
<h2>Expressions</h2>
<p>Euphoria lets you calculate results by forming expressions. However, in Euphoria you can perform calculations on entire sequences of data with one expression.</p>
<p>You can handle a sequence much as you would handle a single number. It can be copied, passed to a subroutine, or calculated upon as a unit. For example &minus;</p>
<pre class="result notranslate">
{1,2,3} + 5
</pre>
<p>This is an expression that adds the sequence {1, 2, 3} and the atom 5 to get the resulting sequence {6, 7, 8}. You would learn sequences in subsequent chapters.</p>
<h2>Blocks of code</h2>
<p>One of the first caveats programmers encounter when learning Euphoria is the fact that there are no braces to indicate blocks of code for procedure and function definitions or flow control. Blocks of code are denoted by associated keywords.</p>
<p>The following example shows <b>if...then...end if</b> block &minus;</p>
<pre class="prettyprint notranslate">
if condition then
   code block comes here
end if
</pre>
<h2>Multi-Line Statements</h2>
<p>Statements in Euphoria typically end with a new line. Euphoria does however, allow to write a single statement in multiple lines. For example &minus;</p>
<pre class="prettyprint notranslate">
total = item_one + 
   item_two + 
   item_three
</pre>
<h2>Escape Characters</h2>
<p>Escape characters may be entered using a back-slash. For example &minus;</p>
<p>The following table is a list of escape or non-printable characters that can be represented with backslash notation.</p>
<table style="text-align:center;" class="table table-bordered">
<tr>
<th style="text-align:center;">Backslash notation</th>
<th style="text-align:center;">Description</th>
</tr>
<tr>
<td>\n</td>
<td>Newline</td>
</tr>
<tr>
<td>\r</td>
<td>Carriage return</td>
</tr>
<tr>
<td>\t</td>
<td>Tab</td>
</tr>
<tr>
<td>\\</td>
<td>Backslash</td>
</tr>
<tr>
<td>\"</td>
<td>Double quote</td>
</tr>
<tr>
<td>\'</td>
<td>Single quote</td>
</tr>
</table>
<h2>Comments in Euphoria</h2>
<p>Any comments are ignored by the compiler and have no effect on execution speed. It is advisable to use more comments in your program to make it more readable.</p>
<p>There are three forms of comment text &minus;</p>
<ul class="list">
<li><p>Comments start by two dashes and extend to the end of the current line.</p></li>
<li><p>The multi-line format comment is kept inside /*...*/, even if that occurs on a different line.</p></li>
<li><p>You can use a special comment beginning with the two character sequence “#!” only on the first line of the program.</p></li>
</ul>
<h3>Examples</h3>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui
-- First comment
puts(1, "Hello, Euphoria!\n") -- second comment

/* This is a comment which extends over a number
   of text lines and has no impact on the program
*/
</pre>
<p>This produces the following result &minus;</p>
<pre class="result notranslate">
Hello, Euphoria!
</pre>

<title>Euphoria Variables</title>

<h1>Euphoria - Variables</h1>

<p>Variables are nothing but reserved memory locations to store values. This means when you create a variable, you reserve some space in memory.</p>

<p>Based on the data type of a variable, the interpreter allocates memory and decides what can be stored in the reserved memory. Therefore, by assigning different data types to variables, you can store integers, decimals, or characters in these variables. Euphoria data types are explained in different chapter.</p>

<p>These memory locations are called variables because their value can be changed during their life time.</p>

<h2>Variable Declaration</h2>

<p>Euphoria variables have to be explicitly declared to reserve memory space. Thus declaration of a variable is mandatory before you assign a value to a variable.</p>

<p>Variable declarations have a type name followed by a list of the variables being declared. For example &minus;</p>

<p>When you declare a variable, you name the variable and you define which sort of values may legally be assigned to the variable during execution of your program.</p>

<p>The simple act of declaring a variable does not assign any value to it. If you attempt to read it before assigning any value to it, Euphoria will issue a run-time error as <i>"variable xyz has never been assigned a value"</i>.</p>

<h2>Assigning Values</h2>

<p>The equal sign (=) is used to assign values to variables. Variable can be assigned in the following manner &minus;</p>

<p>Variable_Name = Variable_Value</p>

<p>For example &minus;</p>

<p>Here 100, 1000.0 and "John" are the values assigned to <i>counter</i>, <i>miles</i> and <i>name</i> variables, respectively. This program produces the following result &minus;</p>

<p>To guard against forgetting to initialize a variable, and also because it may make the code clearer to read, you can combine declaration and assignment &minus;</p>

<p>This is equivalent to the following &minus;</p>

<h2>Identifier Scope</h2>

<p>The scope of an identifier is a description of what code can access it. Code in the same scope of an identifier can access that identifier and code not in the same scope as identifier cannot access it.</p>

<p>The scope of a variable depends upon where and how it is declared.</p>

<p>If it is declared within a <b>for, while, loop</b> or <b>switch</b>, its scope starts at the declaration and ends at the respective <b>end</b> statement.</p>

<p>In an <b>if</b> statement, the scope starts at the declaration and ends either at the next <b>else, elsif</b> or <b>end if</b> statement.</p>

<p>If a variable is declared within a routine, the scope of the variable starts at the declaration and ends at the routine's end statement. This is knows as a private variable.</p>

<p>If a variable is declared outside of a routine, its scope starts at the declaration and ends and the end of the file it is declared in. This is known as a module variable.</p>

<p>The scope of a <b>constant</b> that does not have a scope modifier, starts at the declaration and ends and the end of the file it is declared in.</p>

<p>The scope of a <b>enum</b> that does not have a scope modifier, starts at the declaration and ends and the end of the file it is declared in.</p>

<p>The scope of all <b>procedures, functions</b> and <b>types</b>, which do not have a scope modifier, starts at the beginning of the source file and ends at the end of the source file in which they are declared.</p>

<p>Constants, enums, module variables, procedures, functions and types, which do not have a scope modifier are referred to as <b>locals</b>. However, these identifiers can have a scope modifier preceding their declaration, which causes their scope to extend beyond the file they are declared in.</p>

<p>If the keyword <b>global</b> precedes the declaration, the scope of these identifiers extends to the whole application. They can be accessed by code anywhere in the application files.</p>

<p>If the keyword <b>public</b> precedes the declaration, the scope extends to any file that explicitly includes the file in which the identifier is declared, or to any file that includes a file that in turn <i>public</i> includes the file containing the <i>public</i> declaration.</p>

<p>If the keyword <b>export</b> precedes the declaration, the scope only extends to any file that directly includes the file in which the identifier is declared.</p>

<p>When you <b>include</b> a Euphoria file in another file, only the identifiers declared using a scope modifier are accessible to the file doing the <i>include</i>. The other declarations in the included file are invisible to the file doing the <i>include</i>.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
integer x, y, z

sequence a, b, x
</pre>
<p>When you declare a variable, you name the variable and you define which sort of values may legally be assigned to the variable during execution of your program.</p>
<p>The simple act of declaring a variable does not assign any value to it. If you attempt to read it before assigning any value to it, Euphoria will issue a run-time error as <i>"variable xyz has never been assigned a value"</i>.</p>
<h2>Assigning Values</h2>
<p>The equal sign (=) is used to assign values to variables. Variable can be assigned in the following manner &minus;</p>
<p>Variable_Name = Variable_Value</p>
<p>For example &minus;</p>
<pre class="prettyprint notranslate">
#!/home/euphoria/bin/eui

-- Here is the declaration of the variables.
integer counter
integer miles
sequence name

counter = 100 -- An integer assignment
miles = 1000.0 -- A floating point
name = "John" -- A string ( sequence )

printf(1, "Value of counter %d\n", counter )
printf(1, "Value of miles %f\n", miles )
printf(1, "Value of name %s\n", {name} )
</pre>
<p>Here 100, 1000.0 and "John" are the values assigned to <i>counter</i>, <i>miles</i> and <i>name</i> variables, respectively. This program produces the following result &minus;</p>
<pre class="result notranslate">
Value of counter 100
Value of miles 1000.000000
Value of name John
</pre>
<p>To guard against forgetting to initialize a variable, and also because it may make the code clearer to read, you can combine declaration and assignment &minus;</p>
<pre class="result notranslate">
integer n = 5
</pre>
<p>This is equivalent to the following &minus;</p>
<pre class="result notranslate">
integer n
n = 5
</pre>

<title>Euphoria Constants</title>

<h1>Euphoria - Constants</h1>

<p>Constants are also variables that are assigned an initial value that can never change in the program’s life. Euphoria allows to define constants using constant keyword as follows &minus;</p>

<p>The result of any expression can be assigned to a constant, even one involving calls to previously defined functions, but once the assignment is made, the value of the constant variable is "locked in".</p>

<p>Constants may not be declared inside a subroutine. The scope of a <b>constant</b> that does not have a scope modifier, starts at the declaration and ends and the end of the file it is declared in.</p>

<h3>Examples</h3>

<p>This produces the following error &minus;</p>

<p>If you delete last two lines from the example, then it produces the following result &minus;</p>

<h2>The <i>enums</i></h2>

<p>An enumerated value is a special type of constant where the first value defaults to the number 1 and each item after that is incremented by 1. Enums can only take numeric values.</p>

<p>Enums may not be declared inside a subroutine. The scope of an <b>enum</b> that does not have a scope modifier, starts at the declaration and ends and the end of the file it is declared in.</p>

<h3>Examples</h3>

<p>This will produce following result &minus;</p>

<p>You can change the value of any one item by assigning it a numeric value. Subsequent values are always the previous value plus one, unless they too are assigned a default value.</p>

<p>This produce the following result &minus;</p>

<p>Sequences use integer indices, but with enum you may write code like this &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
constant MAX = 100
constant Upper = MAX - 10, Lower = 5
constant name_list = {"Fred", "George", "Larry"}
</pre>
<p>The result of any expression can be assigned to a constant, even one involving calls to previously defined functions, but once the assignment is made, the value of the constant variable is "locked in".</p>
<p>Constants may not be declared inside a subroutine. The scope of a <b>constant</b> that does not have a scope modifier, starts at the declaration and ends and the end of the file it is declared in.</p>
<h3>Examples</h3>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui

constant MAX = 100
constant Upper = MAX - 10, Lower = 5

printf(1, "Value of MAX %d\n", MAX )
printf(1, "Value of Upper %d\n", Upper )
printf(1, "Value of Lower %d\n", Lower )

MAX = MAX + 1
printf(1, "Value of MAX %d\n", MAX )
</pre>
<p>This produces the following error &minus;</p>
<pre class="result notranslate">
./test.ex:10
&lt;0110&gt;:: may not change the value of a constant
MAX = MAX + 1
   ^

Press Enter
</pre>
<p>If you delete last two lines from the example, then it produces the following result &minus;</p>
<pre class="result notranslate">
Value of MAX 100
Value of Upper 90
Value of Lower 5
</pre>
<h2>The <i>enums</i></h2>
<p>An enumerated value is a special type of constant where the first value defaults to the number 1 and each item after that is incremented by 1. Enums can only take numeric values.</p>
<p>Enums may not be declared inside a subroutine. The scope of an <b>enum</b> that does not have a scope modifier, starts at the declaration and ends and the end of the file it is declared in.</p>
<h3>Examples</h3>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui

enum ONE, TWO, THREE, FOUR

printf(1, "Value of ONE %d\n", ONE )
printf(1, "Value of TWO %d\n", TWO )
printf(1, "Value of THREE %d\n", THREE )
printf(1, "Value of FOUR %d\n", FOUR )
</pre>
<p>This will produce following result &minus;</p>
<pre class="result notranslate">
Value of ONE 1
Value of TWO 2
Value of THREE 3
Value of FOUR 4
</pre>
<p>You can change the value of any one item by assigning it a numeric value. Subsequent values are always the previous value plus one, unless they too are assigned a default value.</p>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui

enum ONE, TWO, THREE, ABC=10, XYZ

printf(1, "Value of ONE %d\n", ONE )
printf(1, "Value of TWO %d\n", TWO )
printf(1, "Value of THREE %d\n", THREE )
printf(1, "Value of ABC %d\n", ABC )
printf(1, "Value of XYZ %d\n", XYZ )
</pre>
<p>This produce the following result &minus;</p>
<pre class="result notranslate">
Value of ONE 1
Value of TWO 2
Value of THREE 3
Value of ABC 10
Value of XYZ 11
</pre>
<p>Sequences use integer indices, but with enum you may write code like this &minus;</p>
<pre class="prettyprint notranslate">
enum X, Y
sequence point = { 0,0 }

point[X] = 3
point[Y] = 4
</pre>

<title>Euphoria Data Types</title>

<h1>Euphoria - Data Types</h1>

<p>The data stored in memory can be of many types. For example, a person's age is stored as a numeric value and his or her address is stored as alphanumeric characters.</p>

<p>Euphoria has some standard types that are used to define the operations possible on them and the storage method for each of them.</p>

<p>Euphoria has following four standard data types &minus;</p>

<p>The understanding of atoms and sequences is the key to understanding Euphoria.</p>

<h2>Integers</h2>

<p>Euphoria integer data types store numeric values. They are declared and defined as follows &minus;</p>

<p>The variables declared with type integer must be atoms with <b>integer</b> values from -1073741824 to +1073741823 inclusive. You can perform exact calculations on larger integer values, up to about 15 decimal digits, but declare them as atom, rather than integer.</p>

<h2>Atoms</h2>

<p>All data objects in Euphoria are either atoms or sequences. An atom is a single numeric value. Atoms can have any integer or double-precision floating point value. Euphoria atoms are declared and defined as follows&minus;</p>

<p>The atoms can range from approximately -1e300 to +1e300 with 15 decimal digits of accuracy. An individual character is an <b>atom</b> which must may be entered using single quotes. For example, all the following statements are legal &minus;</p>

<h2>Sequences</h2>

<p>A sequence is a collection of numeric values which can be accessed through their index. All data objects in Euphoria are either atoms or sequences.</p>

<p>Sequence index starts from 1 unlike other programming languages where array index starts from 0. Euphoria sequences are declared and defined as follows &minus;</p>

<p>A character string is just a <b>sequence</b> of characters which may be entered using double quotes. For example, all the following statements are legal &minus;</p>

<p>Character strings may be manipulated and operated upon just like any other sequences. For example, the above string is entirely equivalent to the sequence &minus;</p>

<p>You will learn more about sequence in <a href="/euphoria/euphoria_sequences.htm">Euphoria &minus; Sequences</a>.</p>

<h2>Objects</h2>

<p>This is a super data type in Euphoria which may take on any value including atoms, sequences, or integers. Euphoria objects are declared and defined as follows &minus;</p>

<p>An object may have one of the following values &minus;</p>

<p>a sequence</p>

<p>an atom</p>

<p>an integer</p>

<p>an integer used as a file number</p>

<p>a string sequence, or single-character atom</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
integer var1, var2

var1 = 1
var2 = 100
</pre>
<p>The variables declared with type integer must be atoms with <b>integer</b> values from -1073741824 to +1073741823 inclusive. You can perform exact calculations on larger integer values, up to about 15 decimal digits, but declare them as atom, rather than integer.</p>
<h2>Atoms</h2>
<p>All data objects in Euphoria are either atoms or sequences. An atom is a single numeric value. Atoms can have any integer or double-precision floating point value. Euphoria atoms are declared and defined as follows&minus;</p>
<pre class="prettyprint notranslate">
atom var1, var2, var3

var1 = 1000
var2 = 198.6121324234
var3 = 'E'       
</pre>
<p>The atoms can range from approximately -1e300 to +1e300 with 15 decimal digits of accuracy. An individual character is an <b>atom</b> which must may be entered using single quotes. For example, all the following statements are legal &minus;</p>
<pre class="result notranslate">
-- Following is equivalent to the atom 66 - the ASCII code for B
char = 'B'

-- Following is equivalent to the sequence {66}
sentence = "B"
</pre>
<h2>Sequences</h2>
<p>A sequence is a collection of numeric values which can be accessed through their index. All data objects in Euphoria are either atoms or sequences.</p>
<p>Sequence index starts from 1 unlike other programming languages where array index starts from 0. Euphoria sequences are declared and defined as follows &minus;</p>
<pre class="prettyprint notranslate">
sequence var1, var2, var3, var4

var1 = {2, 3, 5, 7, 11, 13, 17, 19}
var2 = {1, 2, {3, 3, 3}, 4, {5, {6}}}
var3 = {{"zara", "ali"}, 52389, 97.25}     
var4 = {} -- the 0 element sequence
</pre>
<p>A character string is just a <b>sequence</b> of characters which may be entered using double quotes. For example, all the following statements are legal &minus;</p>
<pre class="prettyprint notranslate">
word = 'word'
sentence = "ABCDEFG"
</pre>
<p>Character strings may be manipulated and operated upon just like any other sequences. For example, the above string is entirely equivalent to the sequence &minus;</p>
<pre class="prettyprint notranslate">
sentence = {65, 66, 67, 68, 69, 70, 71}
</pre>
<p>You will learn more about sequence in <a href="/euphoria/euphoria_sequences.htm">Euphoria &minus; Sequences</a>.</p>
<h2>Objects</h2>
<p>This is a super data type in Euphoria which may take on any value including atoms, sequences, or integers. Euphoria objects are declared and defined as follows &minus;</p>
<pre class="prettyprint notranslate">
object var1, var2, var3

var1 = {2, 3, 5, 7, 11, 13, 17, 19}
var2 = 100
var3 = 'E'     
</pre>

<title>Euphoria Operators</title>

<h1>Euphoria - Operators</h1>

<p>Euphoria provides a rich set of operators to manipulate variables. We can divide all the Euphoria operators into the following groups &minus;</p>

<h2>The Arithmetic Operators</h2>

<p>Arithmetic operators are used in mathematical expressions in the same way that they are used in Algebra. The following table lists the arithmetic operators. Assume integer variable A holds 10 and variable B holds 20 then &minus;</p>

<p><a href="/euphoria/euphoria_arithmatic_operators.htm">Show Examples</a></p>

<h2>The Relational Operators</h2>

<p>There are following relational operators supported by Euphoria language. Assume variable A holds 10 and variable B holds 20 then &minus;</p>

<p><a href="/euphoria/euphoria_relational_operators.htm">Show Examples</a></p>

<h2>The Logical Operators</h2>

<p>The following table lists the logical operators. Assume boolean variables A holds 1 and variable B holds 0 then &minus;</p>

<p><a href="/euphoria/euphoria_logical_operators.htm">Show Examples</a></p>

<p>You can also apply these operators to numbers other than 1 or 0. The convention is: zero means false and non-zero means <i>true</i>.</p>

<h2>The Assignment Operators</h2>

<p>There are following assignment operators supported by Euphoria language &minus;</p>

<p><a href="/euphoria/euphoria_assignment_operators.htm">Show Examples</a></p>

<p><b>Note</b> &minus; The equals symbol '=' used in an assignment statement is not an operator, it is just a part of the syntax.</p>

<h2>Miscellaneous Operators</h2>

<p>There are few other operators supported by Euphoria Language.</p>

<h3>The '&amp;' Operator</h3>

<p>Any two objects may be concatenated using “&amp;” operator. The result is a sequence with a length equal to the sum of the lengths of the concatenated objects.</p>

<p>For example &minus;</p>

<p>This produces the following result &minus;</p>

<h2>Precedence of Euphoria Operators</h2>

<p>Operator precedence determines the grouping of terms in an expression. This affects how an expression is evaluated. Certain operators have higher precedence than others; for example, the multiplication operator has higher precedence than the addition operator.</p>

<p>For example, x = 7 + 3 * 2</p>

<p>Here, x is assigned 13, not 20 because operator * has higher precedence than +.</p>

<p>Hence it first starts with 3*2 and then adds into 7.</p>

<p>Here operators with the highest precedence appear at the top of the table, those with the lowest appear at the bottom. Within an expression, higher precedence operators is evaluated first.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui

sequence a, b, c
a = {1, 2, 3}
b = {4}
c = {1, 2, 3} &amp; {4}

printf(1, "Value of c[1] %d\n", c[1] )
printf(1, "Value of c[2] %d\n", c[2] )
printf(1, "Value of c[3] %d\n", c[3] )
printf(1, "Value of c[4] %d\n", c[4] )
</pre>
<p>This produces the following result &minus;</p>
<pre class="result notranslate">
Value of c[1] 1
Value of c[2] 2
Value of c[3] 3
Value of c[4] 4
</pre>

<title>Euphoria Branching</title>

<h1>Euphoria - Branching</h1>

<p>Branching is the most important aspect of any programming language. While writing your program, you may encounter a situation when you have to take a decision or you have to select one option out of the given many options.</p>

<p>Following diagram shows a simple scenario where a program needs to take one of the two paths based on the given condition.</p>

<p>Euphoria provides following three types of decision making (branching or conditional) statements &minus;</p>

<p><a href="/euphoria/euphoria_if_statement.htm">if statement</a></p>

<p><a href="/euphoria/euphoria_switch_statement.htm">switch statement</a></p>

<p><a href="/euphoria/euphoria_ifdef_statement.htm">ifdef statement</a></p>

<p>Let us see the statements in detail &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Euphoria Loop Types</title>

<h1>Euphoria - Loop Types</h1>

<p>Looping is yet another most important aspect of any programming language. While writing your program, you may encounter a situation when you have to execute same statement many times and sometime may be infinite number of times.</p>

<p>There are several ways to specify for how long the process should go on, and how to stop or otherwise alter it. An iterative block may be informally called a loop, and each execution of code in a loop is called an iteration of the loop.</p>

<p>The following diagram shows a simple logical flow of a loop &minus;</p>

<p>Euphoria provides following three types of loop statements &minus;</p>

<p><a href="/euphoria/euphoria_while_statement.htm" title="while statement">while statement</a></p>

<p><a href="/euphoria/euphoria_until_statement.htm" title="loop until statement">loop until statement</a></p>

<p><a href="/euphoria/euphoria_for_statement.htm" title="for statement">for statement</a></p>

<p>All the above statements provide you flexibility and ease of use based on different situations. Let us see them in detail one by one &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Euphoria Flow Control</title>

<h1>Euphoria - Flow Control</h1>

<p>Program execution flow refers to the order in which program statements get executed. By default the statements get executed one after another.</p>

<p>However; many times the order of execution needs to be altered from the default order, to get the task done.</p>

<p>Euphoria has a number of <i>flow</i> control statements that you can use to arrange the execution order of statements.</p>

<h2>The <i>exit</i> statement</h2>

<p>Exiting a loop is done with the keyword <b>exit</b>. This causes flow to immediately leave the current loop and recommence with the first statement after the end of the loop.</p>

<h3>Syntax</h3>

<p>The syntax of an exit statement is as follows &minus;</p>

<p>The <b>exit</b> statement terminates the latest and innermost loop until an optional label name or number is specified.</p>

<p>A special form of <b>exit N</b> is <b>exit 0</b>. This leaves all levels of loop, regardless of the depth. Control continues after the outermost loop block. Likewise, exit -1 exits the second outermost loop, and so on.</p>

<h3>Example</h3>

<p>This produces the following result &minus;</p>

<h2>The <i>break</i> statement</h2>

<p>The <b>break</b> statement works exactly like the <b>exit</b> statement, but applies to if statements or switch statements rather than to loop statements of any kind.</p>

<h3>Syntax</h3>

<p>The syntax of break statement is as follows &minus;</p>

<p>The <b>break</b> statement terminates the latest and innermost if or switch block until an optional label name or number is specified.</p>

<p>A special form of <b>break N</b> is <b>break 0</b>. This leaves the outer most if or switch block, regardless of the depth. Control continues after the outermost block. Likewise, break -1 breaks the second outermost if or switch block, and so on.</p>

<h3>Example</h3>

<p>This produces the following result &minus;</p>

<h2>The <i>continue</i> statement</h2>

<p>The <b>continue</b> statement continues execution of the loop it applies to by going to the next iteration and skipping the rest of an iteration.</p>

<p>Going to the next iteration means testing a condition variable index and checking whether it is still within bounds.</p>

<h3>Syntax</h3>

<p>The syntax of continue statement is as follows &minus;</p>

<p>The <b>continue</b> statement would re-iterate the latest and inner most loop until an optional label name or number is specified.</p>

<p>A special form of <b>continue N</b> is <b>continue 0</b>. This re-iterate the outer most loop, regardless of the depth. Likewise, continue -1 starts from the second outermost loop, and so on.</p>

<h3>Example</h3>

<h2>The <i>retry</i> statement</h2>

<p>The <b>retry</b> statement continues execution of the loop it applies to by going to the next iteration and skipping the rest of an iteration.</p>

<h3>Syntax</h3>

<p>The syntax of retry statement is as follows &minus;</p>

<p>The <b>retry</b> statement retries executing the current iteration of the loop it applies to. The statement branches to the first statement of the designated loop neither testing anything nor incrementing the for loop index.</p>

<p>A special form of <b>retry N</b> is <b>retry 0</b>. This retries executing the outer most loop, regardless of the depth. Likewise, retry -1 retries the second outermost loop, and so on.</p>

<p>Normally, a sub-block which contains a retry statement also contains another flow control keyword like exit, continue, or break. Otherwise, the iteration would be endlessly executed.</p>

<h3>Example</h3>

<p>Since retry does not change the value of i and tries again opening the same file, there has to be a way to break from the loop, which the exit statement provides.</p>

<h2>The goto statement</h2>

<p>The <b>goto</b> statement instructs the computer to resume code execution at a labeled place.</p>

<p>The place to resume execution is called the target of the statement. It is restricted to lie in the current routine, or the current file if outside any routine.</p>

<h3>Syntax</h3>

<p>The syntax of goto statement is as follows &minus;</p>

<p>The target of a goto statement can be any accessible <b>label</b> statement &minus;</p>

<p>Label names must be double quoted constant strings. Characters that are illegal in Euphoria identifiers may appear in a label name, since it is a regular string.</p>

<h3>Example</h3>

<p>This produces the following result &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
exit [ "Label Name" ] [Number]
</pre>
<p>The <b>exit</b> statement terminates the latest and innermost loop until an optional label name or number is specified.</p>
<p>A special form of <b>exit N</b> is <b>exit 0</b>. This leaves all levels of loop, regardless of the depth. Control continues after the outermost loop block. Likewise, exit -1 exits the second outermost loop, and so on.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui

integer b

for a = 1 to 16 do
   printf(1, "value of a %d\n", a)
   
   if a = 10 then
      b = a
      exit
   end if
end for

printf(1, "value of b %d\n", b)
</pre>
<p>This produces the following result &minus;</p>
<pre class="result notranslate">
value of a 1
value of a 2
value of a 3
value of a 4
value of a 5
value of a 6
value of a 7
value of a 8
value of a 9
value of a 10
value of b 10
</pre>
<h2>The <i>break</i> statement</h2>
<p>The <b>break</b> statement works exactly like the <b>exit</b> statement, but applies to if statements or switch statements rather than to loop statements of any kind.</p>
<h3>Syntax</h3>
<p>The syntax of break statement is as follows &minus;</p>
<pre class="result notranslate">
break [ "Label Name" ] [Number]
</pre>
<p>The <b>break</b> statement terminates the latest and innermost if or switch block until an optional label name or number is specified.</p>
<p>A special form of <b>break N</b> is <b>break 0</b>. This leaves the outer most if or switch block, regardless of the depth. Control continues after the outermost block. Likewise, break -1 breaks the second outermost if or switch block, and so on.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui

integer a, b
sequence s = {'E','u', 'p'}

if s[1] = 'E' then
   a = 3
   
   if s[2] = 'u' then
      b = 1
      if s[3] = 'p' then
         break 0 -- leave topmost if block
      end if
      a = 2
   else
      b = 4
   end if
else
   a = 0
   b = 0
end if

printf(1, "value of a %d\n", a)
printf(1, "value of b %d\n", b)
</pre>
<p>This produces the following result &minus;</p>
<pre class="result notranslate">
value of a 3
value of b 1
</pre>
<h2>The <i>continue</i> statement</h2>
<p>The <b>continue</b> statement continues execution of the loop it applies to by going to the next iteration and skipping the rest of an iteration.</p>
<p>Going to the next iteration means testing a condition variable index and checking whether it is still within bounds.</p>
<h3>Syntax</h3>
<p>The syntax of continue statement is as follows &minus;</p>
<pre class="result notranslate">
continue [ "Label Name" ] [Number]
</pre>
<p>The <b>continue</b> statement would re-iterate the latest and inner most loop until an optional label name or number is specified.</p>
<p>A special form of <b>continue N</b> is <b>continue 0</b>. This re-iterate the outer most loop, regardless of the depth. Likewise, continue -1 starts from the second outermost loop, and so on.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui

for a = 3 to 6 do
   printf(1, "value of a %d\n", a)

   if a = 4 then
      puts(1,"(2)\n")
      continue
   end if

   printf(1, "value of a %d\n", a*a)
end for
This would produce following result:

value of a 3
value of a 9
value of a 4
(2)
value of a 5
value of a 25
value of a 6
value of a 36
</pre>
<h2>The <i>retry</i> statement</h2>
<p>The <b>retry</b> statement continues execution of the loop it applies to by going to the next iteration and skipping the rest of an iteration.</p>
<h3>Syntax</h3>
<p>The syntax of retry statement is as follows &minus;</p>
<pre class="result notranslate">
retry [ "Label Name" ] [Number]
</pre>
<p>The <b>retry</b> statement retries executing the current iteration of the loop it applies to. The statement branches to the first statement of the designated loop neither testing anything nor incrementing the for loop index.</p>
<p>A special form of <b>retry N</b> is <b>retry 0</b>. This retries executing the outer most loop, regardless of the depth. Likewise, retry -1 retries the second outermost loop, and so on.</p>
<p>Normally, a sub-block which contains a retry statement also contains another flow control keyword like exit, continue, or break. Otherwise, the iteration would be endlessly executed.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui

integer errors = 0
integer files_to_open = 10

for i = 1 to length(files_to_open) do
   fh = open(files_to_open[i], "rb")
   
   if fh = -1 then
      if errors &gt; 5 then
         exit
      else
         errors += 1
         retry
      end if
   end if
   file_handles[i] = fh
end for
</pre>
<p>Since retry does not change the value of i and tries again opening the same file, there has to be a way to break from the loop, which the exit statement provides.</p>
<h2>The goto statement</h2>
<p>The <b>goto</b> statement instructs the computer to resume code execution at a labeled place.</p>
<p>The place to resume execution is called the target of the statement. It is restricted to lie in the current routine, or the current file if outside any routine.</p>
<h3>Syntax</h3>
<p>The syntax of goto statement is as follows &minus;</p>
<pre class="result notranslate">
goto "Label Name"
</pre>
<p>The target of a goto statement can be any accessible <b>label</b> statement &minus;</p>
<pre class="prettyprint notranslate">
label "Label Name"
</pre>
<p>Label names must be double quoted constant strings. Characters that are illegal in Euphoria identifiers may appear in a label name, since it is a regular string.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui

integer a = 0

label "FIRST"
printf(1, "value of a %d\n", a)
a += 10

if a &lt; 50 then
   goto "FIRST"
end if 
printf(1, "Final value of a %d\n", a)
</pre>
<p>This produces the following result &minus;</p>
<pre class="result notranslate">
value of a 0
value of a 10
value of a 20
value of a 30
value of a 40
Final value of a 50
</pre>

<title>Euphoria Short Circuit Evaluation</title>

<h1>Euphoria - Short Circuit Evaluation</h1>

<p>When a condition is tested by <b>if, elsif, until</b>, or <b>while</b> using <b>and</b> or <b>or</b> operators, a short-circuit evaluation is used. For example &minus;</p>

<p>If a &lt; 0 is false, then Euphoria does not bother to test if b is greater than 0. It knows that the overall result is false regardless. Similarly &minus;</p>

<p>if a &lt; 0 is true, then Euphoria immediately decides that the result true, without testing the value of b, since the result of this test is irrelevant.</p>

<p>In General, whenever you have a condition of the following form &minus;</p>

<p>Where A and B can be any two expressions, Euphoria takes a short-cut when A is false and immediately makes the overall result false, without even looking at expression B.</p>

<p>Similarly, whenever you have a condition of the following form &minus;</p>

<p>Where A is true, Euphoria skips the evaluation of expression B, and declares the result to be true.</p>

<p><b>Short-circuit</b> evaluation of and and or takes place for if, elsif, until, and while conditions only. It is not used in other contexts. For example &minus;</p>

<p>If short-circuiting were used here, you would set x to 1, and not even look at {1,2,3,4,5}, which would be wrong.</p>

<p>Thus, short-circuiting can be used in if, elsif, until, or while conditions, because you need to only care if the result is true or false, and conditions are required to produce an atom as a result.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
if a &lt; 0 and b &gt; 0 then
   -- block of code
end if
</pre>
<p>If a &lt; 0 is false, then Euphoria does not bother to test if b is greater than 0. It knows that the overall result is false regardless. Similarly &minus;</p>
<pre class="prettyprint notranslate">
if a &lt; 0 or b &gt; 0 then
   -- block of code
end if
</pre>
<p>if a &lt; 0 is true, then Euphoria immediately decides that the result true, without testing the value of b, since the result of this test is irrelevant.</p>
<p>In General, whenever you have a condition of the following form &minus;</p>
<pre class="result notranslate">
A and B
</pre>
<p>Where A and B can be any two expressions, Euphoria takes a short-cut when A is false and immediately makes the overall result false, without even looking at expression B.</p>
<p>Similarly, whenever you have a condition of the following form &minus;</p>
<pre class="result notranslate">
A or  B
</pre>
<p>Where A is true, Euphoria skips the evaluation of expression B, and declares the result to be true.</p>
<p><b>Short-circuit</b> evaluation of and and or takes place for if, elsif, until, and while conditions only. It is not used in other contexts. For example &minus;</p>
<pre class="prettyprint notranslate">
x = 1 or {1,2,3,4,5} -- x should be set to {1,1,1,1,1}
</pre>

<title>Euphoria Sequences</title>

<h1>Euphoria - Sequences</h1>

<p>A sequence is represented by a list of objects in brace brackets { }, separated by commas. A sequence can contain both atoms and other sequences. For example &minus;</p>

<p>A single element of a sequence may be selected by giving the element number in square brackets. Element numbers start at 1.</p>

<p>For example, if x contains {5, 7.2, 9, 0.5, 13} then x[2] is 7.2.</p>

<p>Suppose x[2] contains {11,22,33}, Now if you ask for x[2] you get {11,22,33} and if you ask for x[2][3], you get the atom 33.</p>

<h3>Example</h3>

<p>Here, length() is the built-in function which returns length of the sequence. The above example produces the following result &minus;</p>

<h2>Character String</h2>

<p>A character string is just a <b>sequence</b> of characters. It may be entered in one of the two ways &minus;</p>

<p><b>(a) Using Double Quotes &minus;</b></p>

<p><b>(b) Using Raw String Notation &minus;</b></p>

<p>You can try the following example to understand the concept &minus;</p>

<p>This produces the following result &minus;</p>

<h2>String Arrays</h2>

<p>An array of strings can be implemented using Sequences as follows &minus;</p>

<p>This produces the following result &minus;</p>

<h2>Euphoria Structures</h2>

<p>A structure can be implemented using Sequences as follows &minus;</p>

<p>This produces the following result &minus;</p>

<p>There are various operations which can be performed directly on sequences. Let us see them in detail &minus;</p>

<h2>Urinary Operation</h2>

<p>When applied to a sequence, a unary operator is actually applied to each element in the sequence to yield a sequence of results of the same length.</p>

<p>This produces the following result &minus;</p>

<h2>Arithmetic Operations</h2>

<p>Almost all arithmetic operations can be performed on sequences as follows &minus;</p>

<p>This produces the following result &minus;</p>

<h2>Command Line Options</h2>

<p>A user can pass command line options to a Euphoria script and it can be accessed as a sequence using <b>command_line()</b> function as follows &minus;</p>

<p>Here <b>printf()</b> is Euphoria's built-in function. Now if you run this script as follows &minus;</p>

<p>This produces the following result &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
{2, 3, 5, 7, 11, 13, 17, 19}
{1, 2, {3, 3, 3}, 4, {5, {6}}}
{{"Zara", "Ayan"}, 52389, 97.25}
{} -- the 0-element sequence
</pre>
<p>A single element of a sequence may be selected by giving the element number in square brackets. Element numbers start at 1.</p>
<p>For example, if x contains {5, 7.2, 9, 0.5, 13} then x[2] is 7.2.</p>
<p>Suppose x[2] contains {11,22,33}, Now if you ask for x[2] you get {11,22,33} and if you ask for x[2][3], you get the atom 33.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui

sequence x
x = {1, 2, 3, 4}

for a = 1 to length(x) do
   printf(1, "value of x[%d] = %d\n", {a, x[a]})
end for
</pre>
<p>Here, length() is the built-in function which returns length of the sequence. The above example produces the following result &minus;</p>
<pre class="result notranslate">
value of x[1] = 1
value of x[2] = 2
value of x[3] = 3
value of x[4] = 4
</pre>
<h2>Character String</h2>
<p>A character string is just a <b>sequence</b> of characters. It may be entered in one of the two ways &minus;</p>
<p><b>(a) Using Double Quotes &minus;</b></p>
<pre class="result notranslate">
"ABCDEFG"
</pre>
<p><b>(b) Using Raw String Notation &minus;</b></p>
<pre class="result notranslate">
-- Using back-quotes
`ABCDEFG`

or

-- Using three double-quotes
"""ABCDEFG"""
</pre>
<p>You can try the following example to understand the concept &minus;</p>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui

sequence x
x = "ABCD"

for a = 1 to length(x) do
   printf(1, "value of x[%d] = %s\n", {a, x[a]})
end for
</pre>
<p>This produces the following result &minus;</p>
<pre class="result notranslate">
value of x[1] = A
value of x[2] = B
value of x[3] = C
value of x[4] = D
</pre>
<h2>String Arrays</h2>
<p>An array of strings can be implemented using Sequences as follows &minus;</p>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui

sequence x = {"Hello", "World", "Euphoria", "", "Last One"}

for a = 1 to length(x) do
   printf(1, "value of x[%d] = %s\n", {a, x[a]})
end for
</pre>
<p>This produces the following result &minus;</p>
<pre class="result notranslate">
value of x[1] = Hello
value of x[2] = World
value of x[3] = Euphoria
value of x[4] =
value of x[5] = Last One
</pre>
<h2>Euphoria Structures</h2>
<p>A structure can be implemented using Sequences as follows &minus;</p>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui

sequence employee = {
   {"John","Smith"},
      45000,
      27,
      185.5
}
printf(1, "First Name = %s, Last Name = %s\n", {employee[1][1],employee[1][2]} )
</pre>
<p>This produces the following result &minus;</p>
<pre class="result notranslate">
First Name = John, Last Name = Smith
</pre>
<p>There are various operations which can be performed directly on sequences. Let us see them in detail &minus;</p>
<h2>Urinary Operation</h2>
<p>When applied to a sequence, a unary operator is actually applied to each element in the sequence to yield a sequence of results of the same length.</p>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui

sequence x
x = -{1, 2, 3, 4}

for a = 1 to length(x) do
   printf(1, "value of x[%d] = %d\n", {a, x[a]})
end for
</pre>
<p>This produces the following result &minus;</p>
<pre class="result notranslate">
value of x[1] = -1
value of x[2] = -2
value of x[3] = -3
value of x[4] = -4
</pre>
<h2>Arithmetic Operations</h2>
<p>Almost all arithmetic operations can be performed on sequences as follows &minus;</p>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui

sequence x, y, a, b, c
x = {1, 2, 3}
y = {10, 20, 30}

a = x + y
puts(1, "Value of a = {")

for i = 1 to length(a) do
   printf(1, "%d,", a[i])
end for
puts(1, "}\n")

b = x - y
puts(1, "Value of b = {")
for i = 1 to length(a) do
   printf(1, "%d,", b[i])
end for
puts(1, "}\n")

c = x * 3
puts(1, "Value of c = {")

for i = 1 to length(c) do
   printf(1, "%d,", c[i])
end for
puts(1, "}\n")
</pre>
<p>This produces the following result &minus;</p>
<pre class="result notranslate">
Value of a = {11,22,33,}
Value of b = {-9,-18,-27,}
Value of c = {3,6,9,}
</pre>
<h2>Command Line Options</h2>
<p>A user can pass command line options to a Euphoria script and it can be accessed as a sequence using <b>command_line()</b> function as follows &minus;</p>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui

sequence x

x = command_line()

printf(1, "Interpeter Name: %s\n", {x[1]} )
printf(1, "Script Name: %s\n", {x[2]} )
printf(1, "First Argument: %s\n", {x[3]})
printf(1, "Second Argument: %s\n", {x[4]})
</pre>
<p>Here <b>printf()</b> is Euphoria's built-in function. Now if you run this script as follows &minus;</p>
<pre class="result notranslate">
$eui test.ex "one" "two"
</pre>
<p>This produces the following result &minus;</p>
<pre class="result notranslate">
Interpeter Name: /home/euphoria-4.0b2/bin/eui
Script Name: test.ex
First Argument: one
Second Argument: two
</pre>

<title>Euphoria Date &amp; Time</title>

<h1>Euphoria - Date &amp; Time</h1>

<p>Euphoria has a library routine that returns the date and time to your program.</p>

<h2>The <i>date()</i> Method</h2>

<p>The date() method returns a sequence value composed of eight atom elements. The following example explains it in detail &minus;</p>

<p>This produces the following result on your standard screen &minus;</p>

<h2>The <i>time()</i> Method</h2>

<p>The time() method returns an atom value, representing the number of seconds elapsed since a fixed point in time. The following example explains it in detail &minus;</p>

<p>This produces the following result &minus;</p>

<h2>Date &amp; Time Related Methods</h2>

<p>Euphoria provides a list of methods which helps you in manipulating date and time. These methods are listed in <a href="/euphoria/euphoria_library_routines.htm"> Euphoria Library Routines</a>.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui
 
integer curr_year, curr_day, curr_day_of_year, curr_hour, curr_minute, curr_second
sequence system_date, word_week, word_month, notation, 
   curr_day_of_week, curr_month
   word_week = {"Sunday", 
      "Monday", 
      "Tuesday", 
      "Wednesday", 
      "Thursday", 
      "Friday", 
      "Saturday"}
   word_month = {"January", "February", 
      "March", 
      "April", 
      "May", 
      "June", 
      "July", 
      "August", 
      "September", 
      "October", 
      "November", 
      "December"}
-- Get current system date.
system_date = date()

-- Now take individual elements
curr_year = system_date[1] + 1900
curr_month = word_month[system_date[2]]
curr_day = system_date[3]
curr_hour = system_date[4]
curr_minute = system_date[5]
curr_second = system_date[6]
curr_day_of_week = word_week[system_date[7]]
curr_day_of_year = system_date[8]

if curr_hour &gt;= 12 then 
   notation = "p.m."
else 
   notation = "a.m."
end if

if curr_hour &gt; 12 then 
   curr_hour = curr_hour - 12
end if

if curr_hour = 0 then 
   curr_hour = 12
end if

puts(1, "\nHello Euphoria!\n\n")
printf(1, "Today is %s, %s %d, %d.\n", {curr_day_of_week, 
   curr_month, curr_day, curr_year})

printf(1, "The time is %.2d:%.2d:%.2d %s\n", {curr_hour, 
   curr_minute, curr_second, notation})

printf(1, "It is %3d days into the current year.\n", {curr_day_of_year})
</pre>
<p>This produces the following result on your standard screen &minus;</p>
<pre class="result notranslate">
Hello Euphoria!

Today is Friday, January 22, 2010.
The time is 02:54:58 p.m.
It is  22 days into the current year.
</pre>
<h2>The <i>time()</i> Method</h2>
<p>The time() method returns an atom value, representing the number of seconds elapsed since a fixed point in time. The following example explains it in detail &minus;</p>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui
 
constant ITERATIONS = 100000000
integer p
atom t0, t1, loop_overhead

t0 = time()
for i = 1 to ITERATIONS do
   -- time an empty loop
end for

loop_overhead = time() - t0

printf(1, "Loop overhead:%d\n", loop_overhead)

t0 = time()
for i = 1 to ITERATIONS do
    p = power(2, 20)
end for

t1 = (time() - (t0 + loop_overhead))/ITERATIONS

printf(1, "Time (in seconds) for one call to power:%d\n", t1)
</pre>
<p>This produces the following result &minus;</p>
<pre class="result notranslate">
Loop overhead:1
Time (in seconds) for one call to power:0
</pre>

<title>Euphoria Procedures</title>

<h1>Euphoria - Procedures</h1>

<p>A procedure is a group of reusable code which can be called from anywhere in your program. This eliminates the need of writing same code again and again. This helps programmers to write modular code.</p>

<p>Like any other advance programming language, Euphoria also supports all the features necessary to write modular code using procedures.</p>

<p>You must have seen procedures like <i>printf()</i> and <i>length()</i> in previous chapters. We are using these procedure again and again but they have been written in core Euphoria only once.</p>

<p>Euphoria allows you to write your own procedures as well. This section explains how to write your own procedure in Euphoria.</p>

<h2>Procedure Definition</h2>

<p>Before you use a procedure, you need to define it. The most common way to define a procedure in Euphoria is by using the <b>procedure</b> keyword, followed by a unique procedure name, a list of parameters (that might be empty), and a statement block which ends with <b>end procedure</b> statement. The basic syntax is as shown below &minus;</p>

<h3>Example</h3>

<p>A simple procedure called sayHello that takes no parameters is defined here &minus;</p>

<h2>Calling a Procedure</h2>

<p>To invoke a procedure somewhere later in the script, you simply need to write the name of that procedure as follows &minus;</p>

<p>This produces the following result &minus;</p>

<h2>Procedure Parameters</h2>

<p>Till now you have seen procedure without a parameter. But there is a facility to pass different parameters while calling a procedure. These passed parameters can be captured inside the procedure and any manipulation can be done over those parameters.</p>

<p>A procedure can take multiple parameters separated by comma.</p>

<h3>Example</h3>

<p>Let us do a bit modification in our <i>sayHello</i> procedure. This time it takes two parameters &minus;</p>

<p>This produces the following result &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
procedure procedurename(parameter-list)

   statements
   ..........

end procedure
</pre>
<h3>Example</h3>
<p>A simple procedure called sayHello that takes no parameters is defined here &minus;</p>
<pre class="prettyprint notranslate">
procedure  sayHello()
   puts(1, "Hello there")
end procedure
</pre>
<h2>Calling a Procedure</h2>
<p>To invoke a procedure somewhere later in the script, you simply need to write the name of that procedure as follows &minus;</p>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui

procedure  sayHello()
   puts(1, "Hello there")
end procedure 

-- Call above defined procedure.
sayHello()
</pre>
<p>This produces the following result &minus;</p>
<pre class="result notranslate">
Hello there
</pre>
<h2>Procedure Parameters</h2>
<p>Till now you have seen procedure without a parameter. But there is a facility to pass different parameters while calling a procedure. These passed parameters can be captured inside the procedure and any manipulation can be done over those parameters.</p>
<p>A procedure can take multiple parameters separated by comma.</p>
<h3>Example</h3>
<p>Let us do a bit modification in our <i>sayHello</i> procedure. This time it takes two parameters &minus;</p>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui

procedure sayHello(sequence name,atom  age)
   printf(1, "%s is %d years old.", {name, age})
end procedure

-- Call above defined procedure.
sayHello("zara", 8)
</pre>
<p>This produces the following result &minus;</p>
<pre class="result notranslate">
zara is 8 years old.
</pre>

<title>Euphoria Functions</title>

<h1>Euphoria - Functions</h1>

<p>Euphoria functions are just like procedures, but they return a value, and can be used in an expression. This chapter explains how to write your own functions in Euphoria.</p>

<h2>Function Definition</h2>

<p>Before we use a function we need to define it. The most common way to define a function in Euphoria is by using the <b>function</b> keyword, followed by a unique function name, a list of parameters (that might be empty), and a statement block which ends with <b>end function</b> statement. The basic syntax is shown here &minus;</p>

<h3>Example</h3>

<p>A simple function called sayHello that takes no parameters is defined here &minus;</p>

<h2>Calling a Function</h2>

<p>To invoke a function somewhere later in the script, you would simple need to write the name of that function as follows &minus;</p>

<p>This produces the following result &minus;</p>

<h2>Function Parameters</h2>

<p>Till now we have seen function without a parameters. But there is a facility to pass different parameters while calling a function. These passed parameters can be captured inside the function and any manipulation can be done over those parameters.</p>

<p>A function can take multiple parameters separated by comma.</p>

<h3>Example</h3>

<p>Let us do a bit modification in our <i>sayHello</i> function. This time it takes two parameters &minus;</p>

<p>This produces the following result &minus;</p>

<h2>The <i>return</i> Statement</h2>

<p>A Euphoria function must have <i>return</i> statement before closing statement <b>end function</b>. Any Euphoria object can be returned. You can, in effect, have multiple return values, by returning a sequence of objects. For example</p>

<p>If you have nothing to return, then simply return 1 or 0. The return value 1 indicates success and 0 indicates failure</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
function functionname(parameter-list)

   statements
   ..........
   return [Euphoria Object]

end function
</pre>
<h3>Example</h3>
<p>A simple function called sayHello that takes no parameters is defined here &minus;</p>
<pre class="prettyprint notranslate">
function sayHello()
   puts(1, "Hello there")
   return 1
end function
</pre>
<h2>Calling a Function</h2>
<p>To invoke a function somewhere later in the script, you would simple need to write the name of that function as follows &minus;</p>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui

function sayHello()
   puts(1, "Hello there")
   return 1
end function

-- Call above defined function.
sayHello()
</pre>
<p>This produces the following result &minus;</p>
<pre class="result notranslate">
Hello there
</pre>
<h2>Function Parameters</h2>
<p>Till now we have seen function without a parameters. But there is a facility to pass different parameters while calling a function. These passed parameters can be captured inside the function and any manipulation can be done over those parameters.</p>
<p>A function can take multiple parameters separated by comma.</p>
<h3>Example</h3>
<p>Let us do a bit modification in our <i>sayHello</i> function. This time it takes two parameters &minus;</p>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui

function sayHello(sequence name,atom  age)
   printf(1, "%s is %d years old.", {name, age})
   return 1
end function

-- Call above defined function.
sayHello("zara", 8)
</pre>
<p>This produces the following result &minus;</p>
<pre class="result notranslate">
zara is 8 years old.
</pre>
<h2>The <i>return</i> Statement</h2>
<p>A Euphoria function must have <i>return</i> statement before closing statement <b>end function</b>. Any Euphoria object can be returned. You can, in effect, have multiple return values, by returning a sequence of objects. For example</p>
<pre class="prettyprint notranslate">
return {x_pos, y_pos}
</pre>

<title>Euphoria Files I/O</title>

<h1>Euphoria - Files I/O</h1>

<p>Using Euphoria programming language, you can write programs that read and change file data on your floppy drive or hard drive, or create new files as a form of output. You can even access devices on your computer such as the printer and modem.</p>

<p>This chapter described all the basic I/O functions available in Euphoria. For information on more functions, please refer to standard Euphoria documentation.</p>

<h2>Displaying on the Screen</h2>

<p>The simplest way to produce output is using the <i>puts()</i> statement where you can pass any string to be displayed on the screen. There is another method <i>printf()</i> which can also be used in case you have to format a string using dynamic values.</p>

<p>These methods convert the expressions you pass them to a string and write the result to standard output as follows &minus;</p>

<p>This produces the following result on your standard screen &minus;</p>

<h2>Opening and Closing Files</h2>

<p>Euphoria provides basic methods necessary to manipulate files by default. You can do your most of the file manipulation using the following methods &minus;</p>

<h2>The <i>open</i> Method</h2>

<p>Before you can read or write a file, you have to open it using Euphoria's built-in <i>open()</i>method. This function creates a file descriptor which is utilized to call other supporting methods associated with it.</p>

<h3>Syntax</h3>

<p>Above method returns -1 in case there is an error in opening the given file name. Here are the parameters &minus;</p>

<p><b>file_name</b> &minus; The file_name argument is a string value that contains the name of the file that you want to access.</p>

<p><b>access_mode</b> &minus; The access_mode determines the mode in which the file has to be opened. For example, read, write append, etc. A complete list of possible values for file opening modes is given in the following table &minus;</p>

<p><b>r</b></p>

<p>Opens a text file for reading only. The file pointer is placed at the beginning of the file.</p>

<p><b>rb</b></p>

<p>Opens a file for reading only in binary format. The file pointer is placed at the beginning of the file.</p>

<p><b>w</b></p>

<p>Opens a text file for writing only. Overwrites the file if the file exists. If the file does not exist, creates a new file for writing.</p>

<p><b>wb</b></p>

<p>Opens a file for writing only in binary format. Overwrites the file if the file exists. If the file does not exist, creates a new file for writing.</p>

<p><b>u</b></p>

<p>Opens a file for both reading and writing. The file pointer is set at the beginning of the file.</p>

<p><b>ub</b></p>

<p>Opens a file for both reading and writing in binary format. The file pointer is placed at the beginning of the file.</p>

<p><b>a</b></p>

<p>Opens a file for appending. The file pointer is at the end of the file if the file exists (append mode). If the file does not exist, it creates a new file for writing.</p>

<p><b>ab</b></p>

<p>Opens a file for appending in binary format. The file pointer is at the end of the file if the file exists (append mode). If the file does not exist, it creates a new file for writing.</p>

<h3>Example</h3>

<p>The following example creates a new text file in the current directory on your Linux system &minus;</p>

<p>If file opens successfully, then it "myfile.txt" is created in your current directory and produces the following result &minus;</p>

<h2>The <i>close()</i> Method</h2>

<p>The close() method flushes any unwritten information and closes the file, after which no more reading or writing can be done on the file.</p>

<p>Euphoria automatically closes a file when the reference object of a file is reassigned to another file. It is a good practice to use the close() method to close a file.</p>

<h3>Syntax</h3>

<p>Here the file descriptor received while opening a file is passed as a parameter.</p>

<h3>Example</h3>

<p>The following example creates a file as above and then closes it before existing the program &minus;</p>

<p>This produces the following result &minus;</p>

<h2>Reading and Writing Files</h2>

<p>Euphoria provides a set of access methods to make our lives easier while reading or writing a file either in text mode or binary mode. Let us see how to use <i>printf()</i> and <i>gets()</i> methods to read and write files.</p>

<h2>The <i>printf()</i> Method</h2>

<p>The <i>printf()</i> method writes any string to an open file.</p>

<h3>Syntax</h3>

<p>Here are the parameters &minus;</p>

<p><b>fn</b> &minus; File descriptor received from open() method.</p>

<p><b>st</b> &minus; Format string where decimal or atom is formatted using %d and string or sequence is formatted using %s.</p>

<p><b>x</b> &minus; If x is a sequence, then format specifiers from st are matched with corresponding elements of x. If x is an atom, then normally st contains just one format specifier and it is applied to x. However; if st contains multiple format specifiers, then each one is applied to the same value x.</p>

<h3>Example</h3>

<p>The following example opens a file and writes the name and age of a person in this file &minus;</p>

<p>The above example creates <i>myfile.txt</i> file. Is writes given content in that file and finally closes. If you open this file, it would have the following content &minus;</p>

<h2>The <i>gets()</i> Method</h2>

<p>The <i>gets()</i> method reads a string from an open file.</p>

<h3>Syntax</h3>

<p>Here passed parameter is file description return by the <i>opend()</i> method. This method starts reading from the beginning of the file line by line. The characters have values from 0 to 255. The atom -1 is returned on end of file.</p>

<h3>Example</h3>

<p>Let us take a file <i>myfile.txt</i> which is already created.</p>

<p>This produces the following result &minus;</p>

<p>Euphoria provides a list of many methods which helps you in manipulating files. These methods are listed in <a href="/euphoria/euphoria_library_routines.htm"> Euphoria Library Routines</a>.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui
 
puts(1, "Euphoria is really a great language, isn't it?" )
</pre>
<p>This produces the following result on your standard screen &minus;</p>
<pre class="result notranslate">
Euphoria is really a great language, isn't it?
</pre>
<h2>Opening and Closing Files</h2>
<p>Euphoria provides basic methods necessary to manipulate files by default. You can do your most of the file manipulation using the following methods &minus;</p>
<ul class="list">
<li>open()</li>
<li>close()</li>
<li>printf()</li>
<li>gets()</li>
<li>getc()</li>
</ul>
<h2>The <i>open</i> Method</h2>
<p>Before you can read or write a file, you have to open it using Euphoria's built-in <i>open()</i>method. This function creates a file descriptor which is utilized to call other supporting methods associated with it.</p>
<h3>Syntax</h3>
<pre class="result notranslate">
integer file_num = open(file_name, access_mode)
</pre>
<p>Above method returns -1 in case there is an error in opening the given file name. Here are the parameters &minus;</p>
<ul class="list">
<li><p><b>file_name</b> &minus; The file_name argument is a string value that contains the name of the file that you want to access.</p></li>
<li><p><b>access_mode</b> &minus; The access_mode determines the mode in which the file has to be opened. For example, read, write append, etc. A complete list of possible values for file opening modes is given in the following table &minus;</p></li>
</ul>
<table class="table table-bordered">
<tr>
<th>S.No</th>
<th style="text-align:center;">Modes &amp; Description</th>
</tr>
<tr>
<td>1</td>
<td><p><b>r</b></p>
<p>Opens a text file for reading only. The file pointer is placed at the beginning of the file.</p></td>
</tr>
<tr>
<td>2</td>
<td><p><b>rb</b></p>
<p>Opens a file for reading only in binary format. The file pointer is placed at the beginning of the file.</p></td>
</tr>
<tr>
<td>3</td>
<td><p><b>w</b></p>
<p>Opens a text file for writing only. Overwrites the file if the file exists. If the file does not exist, creates a new file for writing.</p></td>
</tr>
<tr>
<td>4</td>
<td><p><b>wb</b></p>
<p>Opens a file for writing only in binary format. Overwrites the file if the file exists. If the file does not exist, creates a new file for writing.</p></td>
</tr>
<tr>
<td>5</td>
<td><p><b>u</b></p>
<p>Opens a file for both reading and writing. The file pointer is set at the beginning of the file.</p></td>
</tr>
<tr>
<td>6</td>
<td><p><b>ub</b></p>
<p>Opens a file for both reading and writing in binary format. The file pointer is placed at the beginning of the file.</p></td>
</tr>
<tr>
<td>7</td>
<td><p><b>a</b></p>
<p>Opens a file for appending. The file pointer is at the end of the file if the file exists (append mode). If the file does not exist, it creates a new file for writing.</p></td>
</tr> 
<tr>
<td>8</td>
<td><p><b>ab</b></p>
<p>Opens a file for appending in binary format. The file pointer is at the end of the file if the file exists (append mode). If the file does not exist, it creates a new file for writing.</p></td>
</tr> 
</table>
<h3>Example</h3>
<p>The following example creates a new text file in the current directory on your Linux system &minus;</p>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui

integer file_num
constant ERROR = 2
constant STDOUT = 1

file_num = open("myfile,txt", "w")

if file_num = -1 then
   puts(ERROR, "couldn't open myfile\n")
else
   puts(STDOUT, "File opend successfully\n")
end if
</pre>
<p>If file opens successfully, then it "myfile.txt" is created in your current directory and produces the following result &minus;</p>
<pre class="result notranslate">
File opend successfully
</pre>
<h2>The <i>close()</i> Method</h2>
<p>The close() method flushes any unwritten information and closes the file, after which no more reading or writing can be done on the file.</p>
<p>Euphoria automatically closes a file when the reference object of a file is reassigned to another file. It is a good practice to use the close() method to close a file.</p>
<h3>Syntax</h3>
<pre class="result notranslate">
close( file_num );
</pre>
<p>Here the file descriptor received while opening a file is passed as a parameter.</p>
<h3>Example</h3>
<p>The following example creates a file as above and then closes it before existing the program &minus;</p>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui

integer file_num
constant ERROR = 2
constant STDOUT = 1

file_num = open("myfile.txt", "w")

if file_num = -1 then
   puts(ERROR, "couldn't open myfile\n")
else
   puts(STDOUT, "File opend successfully\n")
end if

if file_num = -1 then
   puts(ERROR, "No need to close the file\n")
else
   close( file_num )
   puts(STDOUT, "File closed successfully\n")
end if
</pre>
<p>This produces the following result &minus;</p>
<pre class="result notranslate">
File opend successfully
File closed successfully
</pre>
<h2>Reading and Writing Files</h2>
<p>Euphoria provides a set of access methods to make our lives easier while reading or writing a file either in text mode or binary mode. Let us see how to use <i>printf()</i> and <i>gets()</i> methods to read and write files.</p>
<h2>The <i>printf()</i> Method</h2>
<p>The <i>printf()</i> method writes any string to an open file.</p>
<h3>Syntax</h3>
<pre class="result notranslate">
printf(fn, st, x) 
</pre>
<p>Here are the parameters &minus;</p>
<ul class="list">
<li><p><b>fn</b> &minus; File descriptor received from open() method.</p></li>
<li><p><b>st</b> &minus; Format string where decimal or atom is formatted using %d and string or sequence is formatted using %s.</p></li>
<li><p><b>x</b> &minus; If x is a sequence, then format specifiers from st are matched with corresponding elements of x. If x is an atom, then normally st contains just one format specifier and it is applied to x. However; if st contains multiple format specifiers, then each one is applied to the same value x.</p></li>
</ul>
<h3>Example</h3>
<p>The following example opens a file and writes the name and age of a person in this file &minus;</p>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui

integer file_num
constant ERROR = 2
constant STDOUT = 1

file_num = open("myfile.txt", "w")

if file_num = -1 then
   puts(ERROR, "couldn't open myfile\n")
else
   puts(STDOUT, "File opend successfully\n")
end if

printf(file_num, "My name is %s and age is %d\n", {"Zara", 8})

if file_num = -1 then
   puts(ERROR, "No need to close the file\n")
else
   close( file_num )
   puts(STDOUT, "File closed successfully\n")
end if
</pre>
<p>The above example creates <i>myfile.txt</i> file. Is writes given content in that file and finally closes. If you open this file, it would have the following content &minus;</p>
<pre class="result notranslate">
My name is Zara and age is 8
</pre>
<h2>The <i>gets()</i> Method</h2>
<p>The <i>gets()</i> method reads a string from an open file.</p>
<h3>Syntax</h3>
<pre class="result notranslate">
gets(file_num)
</pre>
<p>Here passed parameter is file description return by the <i>opend()</i> method. This method starts reading from the beginning of the file line by line. The characters have values from 0 to 255. The atom -1 is returned on end of file.</p>
<h3>Example</h3>
<p>Let us take a file <i>myfile.txt</i> which is already created.</p>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui

integer file_num
object line

constant ERROR = 2
constant STDOUT = 1

file_num = open("myfile.txt", "r")
if file_num = -1 then
   puts(ERROR, "couldn't open myfile\n")
else
   puts(STDOUT, "File opend successfully\n")
end if

line = gets(file_num)
printf( STDOUT, "Read content : %s\n", {line})

if file_num = -1 then
   puts(ERROR, "No need to close the file\n")
else
   close( file_num )
   puts(STDOUT, "File closed successfully\n")
end if
</pre>
<p>This produces the following result &minus;</p>
<pre class="result notranslate">
File opend successfully
Read content : My name is Zara and age is 8

File closed successfully
</pre>

<title>Euphoria Quick Guide</title>

<h1>Euphoria - Quick Guide</h1>

<h1>Euphoria - Overview</h1>

<p>Euphoria stands for <b>E</b>nd-<b>U</b>ser <b>P</b>rogramming with <b>H</b>ierarchical <b>O</b>bjects for <b>R</b>obust <b>I</b>nterpreted <b>A</b>pplications. Euphoria's first incarnation was created by Robert Craig on an Atari Mega-ST and it was first released in 1993. It is now maintained by Rapid Deployment Software.</p>

<p>It is a free, simple, flexible, easy to learn, and interpreted but extremely fast 32-bit high-level programming language for DOS, Windows, Linux, FreeBSD and more.</p>

<p>Euphoria is being used to develop Windows GUI programs, high-speed DOS games, and Linux/FreeBSD X Windows programs. Euphoria can also be used for CGI (Webbased) programming.</p>

<h2>Euphoria Features</h2>

<p>Here is the list of major features of Euphoria &minus;</p>

<p>It is a simple, flexible, powerful language definition that is easy to learn and use.</p>

<p>It supports dynamic storage allocation which means variables grow or shrink without the programmer having to worry about allocating and freeing the memory. It takes care of garbage collection automatically.</p>

<p>It is extremely faster than conventional interpreters such as Perl and Python.</p>

<p>Euphoria programs run under Linux, FreeBSD, 32-bit Windows, and any DOS environment.</p>

<p>Euphoria programs are not subject to any 640K memory limitations.</p>

<p>It provides an optimizing Euphoria-To-C translator which you can use to translate your Euphoria program into C and then compile it with a C compiler to get an executable (.exe) file. This can boost your program speed by 2 to 5 times.</p>

<p>Underlying hardware are completely hidden which means programs are not aware of word-lengths, underlying bit-level representation of values, byte-order etc.</p>

<p>Euphoria installation comes along with a full-screen source debugger, an execution profiler, and a full-screen multi-file editor.</p>

<p>It supports run-time error-handling, subscript, and type checking.</p>

<p>It is an open source language and comes completely free of cost.</p>

<h2>Platform Requirements</h2>

<p>Euphoria is available on Windows, Linux, FreeBSD, and OSX. Here is the bare minimum version required with the following platforms &minus;</p>

<p><b>WIN32 version</b> &minus; You need Windows 95 or any later version of Windows. It runs fine on XP and Vista.</p>

<p><b>Linux version</b> &minus; You need any reasonably up-to-date Linux distribution, that has libc6 or later. For example, Red Hat 5.2 or later works fine.</p>

<p><b>FreeBSD version</b> &minus; You need any reasonably up-to-date FreeBSD distribution.</p>

<p><b>Mac OS X version</b> &minus; You need any reasonably up-to-date Intel based Mac.</p>

<h2>Euphoria Limitations</h2>

<p>Here are some prominent limitations of Euphoria &minus;</p>

<p>Even though Euphoria is simple, fast, and flexible enough for the programmers; it does not provide call support for many important functionalities. For example, network programming.</p>

<p>Euphoria was invented in 1993, and still you would not find any book written on this language. There is also not much documentation available for the language.</p>

<p>But these days, the language is getting popular very fast and you can hope to have nice utilities and books available for the language very soon.</p>

<h2>Euphoria Licensing</h2>

<p>This product is free and open source, and has benefited from the contributions of many people. You have complete royalty-free rights to distribute any Euphoria programs that you develop.</p>

<p>Icon files, such as euphoria.ico and binaries available in euphoria\bin, may be distributed with or without your changes.</p>

<p>You can <b>shroud</b> or <b>bind</b> your program and distribute the resulting files royalty-free. Some additional 3<sup>rd</sup> party legal restrictions might apply when you use the Euphoria- To-C translator.</p>

<h1>Euphoria - Environment</h1>

<p>This chapter describes about the installation of Euphoria on various platforms. You can follow the steps to install Euphoria on Linux, FreeBSD, and 32-bit Windows. So you can choose the steps based on your working environment.</p>

<h2>Linux, Free BSD Installation</h2>

<p>Official website provides <b>.tar.gz</b> file to install Euphoria on your Linux or BSD OS. You can download your latest version of Euphoria from its official website &minus; <a rel="nofollow" href="http://www.rapideuphoria.com/" target="_blank">Download Euphoria</a>.</p>

<p>Once you have .tar.gz file, here are three simple steps to be performed to install Euphoria on your Linux or Free BSD machine &minus;</p>

<p><b>Step 1</b> &minus; Installing Files</p>

<p>Untar the downloaded file <b>euphoria-4.0b2.tar.gz</b> in a directory where you want to install Euphoria. If you want to install it in /home directory as follows, then &minus;</p>

<p>This creates a directory hierarchy inside <b>/home/euphoria-4.0b2</b> directory as follows &minus;</p>

<p><b>NOTE</b> &minus; File name euphoria-4.0b2.tar.gz depends on latest version available. We are using 4.0b2 version of the language for this tutorial.</p>

<p><b>Step 2</b> &minus; Setting Up the Path</p>

<p>After installing Euphoria, you need to set proper paths so that your shell can find required Euphoria binaries and utilities. Before proceeding, there are following three important environment variables you need to set up &minus;</p>

<p>Set PATH environment variable to point /home/euphoria-4.0b2/bin directory.</p>

<p>Set EUDIR environment variable to point to /home/euphoria-4.0b2.</p>

<p>Set EUINC environment variable to point to /home/euphoria-4.0b2/include.</p>

<p>These variables can be set as follows &minus;</p>

<p><b>NOTE</b> &minus; The above commands used to set environment variables may differ depending on your Shell. We used <i>bash</i> shell for executing these commands to set the variables.</p>

<p><b>Step 3</b> &minus; Confirmation Installation</p>

<p>Confirm if you installed Euphoria successfully or not.</p>

<p>Execute the following command &minus;</p>

<p>If you get following result, then it means you have installed Euphoria successfully; otherwise you have to go back and check all the steps again.</p>

<p>That is it, Euphoria Programming Environment is ready on your UNIX machine, and you can start writing complex programs in easy steps.</p>

<h2>WIN32, and DOS Installation</h2>

<p>Official website provides <b>.exe</b> file to install Euphoria on your WIN32 or DOS OS. You can download your latest version of Euphoria from its official website &minus; <a href="http://www.rapideuphoria.com/" rel="nofollow" target="_blank">Download Euphoria</a>.</p>

<p>Once you have .exe file, here are three simple steps to follow for installing Euphoria Programming language on your WIN32 or DOS machine &minus;</p>

<p><b>Step 1</b> &minus; Installing Files</p>

<p>Double click on the downloaded <b>.exe</b> setup program to install all the files. We downloaded euphoria-40b2.exe file for installation.</p>

<p>The filename euphoria-40b2.exe depends on latest version available. We use version 4 beta 2 of the language.</p>

<p>By default Euphoria would be installed in C:\<i>euphoria-40b2</i> directory but you can also select a desired location.</p>

<p><b>Step 2</b> &minus; Rebooting the Machine</p>

<p>Re-boot your machine to complete the installation.</p>

<p><b>Step 3</b> &minus; Confirmation Installation</p>

<p>Confirm if you installed Euphoria successfully or not.</p>

<p>Execute the following command &minus;</p>

<p>If you get following result, then it means you have installed Euphoria successfully; otherwise you have to go back and check all the steps again.</p>

<p>That is it, Euphoria Programming Environment is ready on your WIN32 machine, and you can start writing complex programs in easy steps.</p>

<h2>Euphoria Interpreters</h2>

<p>Depending on the platform you are using, Euphoria has multiple interpreters &minus;</p>

<p>The main interpreter is <b>eui</b>.</p>

<p>On windows platforms, you have two choices. If you run <b>eui</b> then a console window is created. If you run <b>euiw</b> then no console is created, making it suitable for GUI applications.</p>

<p>Euphoria does not care about your choice of file extensions. By convention however; the console-based applications come with <b>.ex</b> extension.</p>

<p>GUI-based applications have <b>.exw</b> extension and the include files have <b>.e</b> extension.</p>

<h1>Euphoria - Basic Syntax</h1>

<p>The Euphoria language has many similarities to Perl, C, and Java. However, there are some definite differences between the languages. This chapter is designed to quickly get you up to speed on the syntax that is expected in Euphoria.</p>

<p>This tutorial assumes you are working with Linux and all the examples have been written on Linux platform. But it is observed that there is no any prominent difference in program syntax on Linux and WIN32. Hence you can follow the same steps on WIN32.</p>

<h2>First Euphoria Program</h2>

<p>Let us write a simple Euphoria program in a script. Type the following source code in test.ex file and save it.</p>

<p>Let us say, Euphoria interpreter is available in <i>/home/euphoria-4.0b2/bin/</i> directory. Now run this program as follows &minus;</p>

<p>This produces the following result &minus;</p>

<p>This script used a built-in function <b>puts()</b> which takes two arguments. First argument indicates file name or device number, and second argument indicates a string which you want to print. Here 1 indicates STDOUT device.</p>

<h2>Euphoria Identifiers</h2>

<p>A Euphoria identifier is a name used to identify a variable, function, class, module, or other object. An identifier starts with a letter A to Z or a to z and then followed by letters, digits, or underscores.</p>

<p>Euphoria does not allow punctuation characters such as @, $, and % within identifiers.</p>

<p>Euphoria is a case sensitive programming language. Thus <b>Manpower</b> and <b>manpower</b> are two different identifiers in Euphoria. For example, the valid identifiers are &minus;</p>

<h2>Reserved Words</h2>

<p>The following list shows the reserved words in Euphoria. These reserved words may not be used as constant or variable or any other identifier names. Euphoria keywords contain lowercase letters only.</p>

<h2>Expressions</h2>

<p>Euphoria lets you calculate results by forming expressions. However, in Euphoria you can perform calculations on entire sequences of data with one expression.</p>

<p>You can handle a sequence much as you would handle a single number. It can be copied, passed to a subroutine, or calculated upon as a unit. For example &minus;</p>

<p>This is an expression that adds the sequence {1, 2, 3} and the atom 5 to get the resulting sequence {6, 7, 8}. You would learn sequences in subsequent chapters.</p>

<h2>Blocks of code</h2>

<p>One of the first caveats programmers encounter when learning Euphoria is the fact that there are no braces to indicate blocks of code for procedure and function definitions or flow control. Blocks of code are denoted by associated keywords.</p>

<p>The following example shows <b>if...then...end if</b> block &minus;</p>

<h2>Multi-Line Statements</h2>

<p>Statements in Euphoria typically end with a new line. Euphoria does however, allow to write a single statement in multiple lines. For example &minus;</p>

<h2>Escape Characters</h2>

<p>Escape characters may be entered using a back-slash. For example &minus;</p>

<p>The following table is a list of escape or non-printable characters that can be represented with backslash notation.</p>

<h2>Comments in Euphoria</h2>

<p>Any comments are ignored by the compiler and have no effect on execution speed. It is advisable to use more comments in your program to make it more readable.</p>

<p>There are three forms of comment text &minus;</p>

<p>Comments start by two dashes and extend to the end of the current line.</p>

<p>The multi-line format comment is kept inside /*...*/, even if that occurs on a different line.</p>

<p>You can use a special comment beginning with the two character sequence “#!” only on the first line of the program.</p>

<h3>Examples</h3>

<p>This produces the following result &minus;</p>

<p><b>Note</b> &minus; You can use a special comment beginning with “#!”. This informs the Linux shell that your file should be executed by the Euphoria interpreter.</p>

<h1>Euphoria - Variables</h1>

<p>Variables are nothing but reserved memory locations to store values. This means when you create a variable, you reserve some space in memory.</p>

<p>Based on the data type of a variable, the interpreter allocates memory and decides what can be stored in the reserved memory. Therefore, by assigning different data types to variables, you can store integers, decimals, or characters in these variables. Euphoria data types are explained in different chapter.</p>

<p>These memory locations are called variables because their value can be changed during their life time.</p>

<h2>Variable Declaration</h2>

<p>Euphoria variables have to be explicitly declared to reserve memory space. Thus declaration of a variable is mandatory before you assign a value to a variable.</p>

<p>Variable declarations have a type name followed by a list of the variables being declared. For example &minus;</p>

<p>When you declare a variable, you name the variable and you define which sort of values may legally be assigned to the variable during execution of your program.</p>

<p>The simple act of declaring a variable does not assign any value to it. If you attempt to read it before assigning any value to it, Euphoria will issue a run-time error as <i>"variable xyz has never been assigned a value"</i>.</p>

<h2>Assigning Values</h2>

<p>The equal sign (=) is used to assign values to variables. Variable can be assigned in the following manner &minus;</p>

<p>Variable_Name = Variable_Value</p>

<p>For example &minus;</p>

<p>Here 100, 1000.0 and "John" are the values assigned to <i>counter</i>, <i>miles</i> and <i>name</i> variables, respectively. This program produces the following result &minus;</p>

<p>To guard against forgetting to initialize a variable, and also because it may make the code clearer to read, you can combine declaration and assignment &minus;</p>

<p>This is equivalent to the following &minus;</p>

<h2>Identifier Scope</h2>

<p>The scope of an identifier is a description of what code can access it. Code in the same scope of an identifier can access that identifier and code not in the same scope as identifier cannot access it.</p>

<p>The scope of a variable depends upon where and how it is declared.</p>

<p>If it is declared within a <b>for, while, loop</b> or <b>switch</b>, its scope starts at the declaration and ends at the respective <b>end</b> statement.</p>

<p>In an <b>if</b> statement, the scope starts at the declaration and ends either at the next <b>else, elsif</b> or <b>end if</b> statement.</p>

<p>If a variable is declared within a routine, the scope of the variable starts at the declaration and ends at the routine's end statement. This is knows as a private variable.</p>

<p>If a variable is declared outside of a routine, its scope starts at the declaration and ends and the end of the file it is declared in. This is known as a module variable.</p>

<p>The scope of a <b>constant</b> that does not have a scope modifier, starts at the declaration and ends and the end of the file it is declared in.</p>

<p>The scope of a <b>enum</b> that does not have a scope modifier, starts at the declaration and ends and the end of the file it is declared in.</p>

<p>The scope of all <b>procedures, functions</b> and <b>types</b>, which do not have a scope modifier, starts at the beginning of the source file and ends at the end of the source file in which they are declared.</p>

<p>Constants, enums, module variables, procedures, functions and types, which do not have a scope modifier are referred to as <b>locals</b>. However, these identifiers can have a scope modifier preceding their declaration, which causes their scope to extend beyond the file they are declared in.</p>

<p>If the keyword <b>global</b> precedes the declaration, the scope of these identifiers extends to the whole application. They can be accessed by code anywhere in the application files.</p>

<p>If the keyword <b>public</b> precedes the declaration, the scope extends to any file that explicitly includes the file in which the identifier is declared, or to any file that includes a file that in turn <i>public</i> includes the file containing the <i>public</i> declaration.</p>

<p>If the keyword <b>export</b> precedes the declaration, the scope only extends to any file that directly includes the file in which the identifier is declared.</p>

<p>When you <b>include</b> a Euphoria file in another file, only the identifiers declared using a scope modifier are accessible to the file doing the <i>include</i>. The other declarations in the included file are invisible to the file doing the <i>include</i>.</p>

<h1>Euphoria - Constants</h1>

<p>Constants are also variables that are assigned an initial value that can never change in the program’s life. Euphoria allows to define constants using constant keyword as follows &minus;</p>

<p>The result of any expression can be assigned to a constant, even one involving calls to previously defined functions, but once the assignment is made, the value of the constant variable is "locked in".</p>

<p>Constants may not be declared inside a subroutine. The scope of a <b>constant</b> that does not have a scope modifier, starts at the declaration and ends and the end of the file it is declared in.</p>

<h3>Examples</h3>

<p>This produces the following error &minus;</p>

<p>If you delete last two lines from the example, then it produces the following result &minus;</p>

<h2>The <i>enums</i></h2>

<p>An enumerated value is a special type of constant where the first value defaults to the number 1 and each item after that is incremented by 1. Enums can only take numeric values.</p>

<p>Enums may not be declared inside a subroutine. The scope of an <b>enum</b> that does not have a scope modifier, starts at the declaration and ends and the end of the file it is declared in.</p>

<h3>Examples</h3>

<p>This will produce following result &minus;</p>

<p>You can change the value of any one item by assigning it a numeric value. Subsequent values are always the previous value plus one, unless they too are assigned a default value.</p>

<p>This produce the following result &minus;</p>

<p>Sequences use integer indices, but with enum you may write code like this &minus;</p>

<h1>Euphoria - Data Types</h1>

<p>The data stored in memory can be of many types. For example, a person's age is stored as a numeric value and his or her address is stored as alphanumeric characters.</p>

<p>Euphoria has some standard types that are used to define the operations possible on them and the storage method for each of them.</p>

<p>Euphoria has following four standard data types &minus;</p>

<p>The understanding of atoms and sequences is the key to understanding Euphoria.</p>

<h2>Integers</h2>

<p>Euphoria integer data types store numeric values. They are declared and defined as follows &minus;</p>

<p>The variables declared with type integer must be atoms with <b>integer</b> values from -1073741824 to +1073741823 inclusive. You can perform exact calculations on larger integer values, up to about 15 decimal digits, but declare them as atom, rather than integer.</p>

<h2>Atoms</h2>

<p>All data objects in Euphoria are either atoms or sequences. An atom is a single numeric value. Atoms can have any integer or double-precision floating point value. Euphoria atoms are declared and defined as follows&minus;</p>

<p>The atoms can range from approximately -1e300 to +1e300 with 15 decimal digits of accuracy. An individual character is an <b>atom</b> which must may be entered using single quotes. For example, all the following statements are legal &minus;</p>

<h2>Sequences</h2>

<p>A sequence is a collection of numeric values which can be accessed through their index. All data objects in Euphoria are either atoms or sequences.</p>

<p>Sequence index starts from 1 unlike other programming languages where array index starts from 0. Euphoria sequences are declared and defined as follows &minus;</p>

<p>A character string is just a <b>sequence</b> of characters which may be entered using double quotes. For example, all the following statements are legal &minus;</p>

<p>Character strings may be manipulated and operated upon just like any other sequences. For example, the above string is entirely equivalent to the sequence &minus;</p>

<p>You will learn more about sequence in <a href="/euphoria/euphoria_sequences.htm">Euphoria &minus; Sequences</a>.</p>

<h2>Objects</h2>

<p>This is a super data type in Euphoria which may take on any value including atoms, sequences, or integers. Euphoria objects are declared and defined as follows &minus;</p>

<p>An object may have one of the following values &minus;</p>

<p>a sequence</p>

<p>an atom</p>

<p>an integer</p>

<p>an integer used as a file number</p>

<p>a string sequence, or single-character atom</p>

<h1>Euphoria - Operators</h1>

<p>Euphoria provides a rich set of operators to manipulate variables. We can divide all the Euphoria operators into the following groups &minus;</p>

<h2>The Arithmetic Operators</h2>

<p>Arithmetic operators are used in mathematical expressions in the same way that they are used in Algebra. The following table lists the arithmetic operators. Assume integer variable A holds 10 and variable B holds 20 then &minus;</p>

<p><a href="/euphoria/euphoria_arithmatic_operators.htm">Show Examples</a></p>

<h2>The Relational Operators</h2>

<p>There are following relational operators supported by Euphoria language. Assume variable A holds 10 and variable B holds 20 then &minus;</p>

<p><a href="/euphoria/euphoria_relational_operators.htm">Show Examples</a></p>

<h2>The Logical Operators</h2>

<p>The following table lists the logical operators. Assume boolean variables A holds 1 and variable B holds 0 then &minus;</p>

<p><a href="/euphoria/euphoria_logical_operators.htm">Show Examples</a></p>

<p>You can also apply these operators to numbers other than 1 or 0. The convention is: zero means false and non-zero means <i>true</i>.</p>

<h2>The Assignment Operators</h2>

<p>There are following assignment operators supported by Euphoria language &minus;</p>

<p><a href="/euphoria/euphoria_assignment_operators.htm">Show Examples</a></p>

<p><b>Note</b> &minus; The equals symbol '=' used in an assignment statement is not an operator, it is just a part of the syntax.</p>

<h2>Miscellaneous Operators</h2>

<p>There are few other operators supported by Euphoria Language.</p>

<h3>The '&amp;' Operator</h3>

<p>Any two objects may be concatenated using “&amp;” operator. The result is a sequence with a length equal to the sum of the lengths of the concatenated objects.</p>

<p>For example &minus;</p>

<p>This produces the following result &minus;</p>

<h2>Precedence of Euphoria Operators</h2>

<p>Operator precedence determines the grouping of terms in an expression. This affects how an expression is evaluated. Certain operators have higher precedence than others; for example, the multiplication operator has higher precedence than the addition operator.</p>

<p>For example, x = 7 + 3 * 2</p>

<p>Here, x is assigned 13, not 20 because operator * has higher precedence than +.</p>

<p>Hence it first starts with 3*2 and then adds into 7.</p>

<p>Here operators with the highest precedence appear at the top of the table, those with the lowest appear at the bottom. Within an expression, higher precedence operators is evaluated first.</p>

<h1>Euphoria - Branching</h1>

<p>Branching is the most important aspect of any programming language. While writing your program, you may encounter a situation when you have to take a decision or you have to select one option out of the given many options.</p>

<p>Following diagram shows a simple scenario where a program needs to take one of the two paths based on the given condition.</p>

<p>Euphoria provides following three types of decision making (branching or conditional) statements &minus;</p>

<p><a href="/euphoria/euphoria_if_statement.htm">if statement</a></p>

<p><a href="/euphoria/euphoria_switch_statement.htm">switch statement</a></p>

<p><a href="/euphoria/euphoria_ifdef_statement.htm">ifdef statement</a></p>

<p>Let us see the statements in detail &minus;</p>

<h1>Euphoria - Loop Types</h1>

<p>Looping is yet another most important aspect of any programming language. While writing your program, you may encounter a situation when you have to execute same statement many times and sometime may be infinite number of times.</p>

<p>There are several ways to specify for how long the process should go on, and how to stop or otherwise alter it. An iterative block may be informally called a loop, and each execution of code in a loop is called an iteration of the loop.</p>

<p>The following diagram shows a simple logical flow of a loop &minus;</p>

<p>Euphoria provides following three types of loop statements &minus;</p>

<p><a href="/euphoria/euphoria_while_statement.htm" title="while statement">while statement</a></p>

<p><a href="/euphoria/euphoria_until_statement.htm" title="loop until statement">loop until statement</a></p>

<p><a href="/euphoria/euphoria_for_statement.htm" title="for statement">for statement</a></p>

<p>All the above statements provide you flexibility and ease of use based on different situations. Let us see them in detail one by one &minus;</p>

<h1>Euphoria - Flow Control</h1>

<p>Program execution flow refers to the order in which program statements get executed. By default the statements get executed one after another.</p>

<p>However; many times the order of execution needs to be altered from the default order, to get the task done.</p>

<p>Euphoria has a number of <i>flow</i> control statements that you can use to arrange the execution order of statements.</p>

<h2>The <i>exit</i> statement</h2>

<p>Exiting a loop is done with the keyword <b>exit</b>. This causes flow to immediately leave the current loop and recommence with the first statement after the end of the loop.</p>

<h3>Syntax</h3>

<p>The syntax of an exit statement is as follows &minus;</p>

<p>The <b>exit</b> statement terminates the latest and innermost loop until an optional label name or number is specified.</p>

<p>A special form of <b>exit N</b> is <b>exit 0</b>. This leaves all levels of loop, regardless of the depth. Control continues after the outermost loop block. Likewise, exit -1 exits the second outermost loop, and so on.</p>

<h3>Example</h3>

<p>This produces the following result &minus;</p>

<h2>The <i>break</i> statement</h2>

<p>The <b>break</b> statement works exactly like the <b>exit</b> statement, but applies to if statements or switch statements rather than to loop statements of any kind.</p>

<h3>Syntax</h3>

<p>The syntax of break statement is as follows &minus;</p>

<p>The <b>break</b> statement terminates the latest and innermost if or switch block until an optional label name or number is specified.</p>

<p>A special form of <b>break N</b> is <b>break 0</b>. This leaves the outer most if or switch block, regardless of the depth. Control continues after the outermost block. Likewise, break -1 breaks the second outermost if or switch block, and so on.</p>

<h3>Example</h3>

<p>This produces the following result &minus;</p>

<h2>The <i>continue</i> statement</h2>

<p>The <b>continue</b> statement continues execution of the loop it applies to by going to the next iteration and skipping the rest of an iteration.</p>

<p>Going to the next iteration means testing a condition variable index and checking whether it is still within bounds.</p>

<h3>Syntax</h3>

<p>The syntax of continue statement is as follows &minus;</p>

<p>The <b>continue</b> statement would re-iterate the latest and inner most loop until an optional label name or number is specified.</p>

<p>A special form of <b>continue N</b> is <b>continue 0</b>. This re-iterate the outer most loop, regardless of the depth. Likewise, continue -1 starts from the second outermost loop, and so on.</p>

<h3>Example</h3>

<h2>The <i>retry</i> statement</h2>

<p>The <b>retry</b> statement continues execution of the loop it applies to by going to the next iteration and skipping the rest of an iteration.</p>

<h3>Syntax</h3>

<p>The syntax of retry statement is as follows &minus;</p>

<p>The <b>retry</b> statement retries executing the current iteration of the loop it applies to. The statement branches to the first statement of the designated loop neither testing anything nor incrementing the for loop index.</p>

<p>A special form of <b>retry N</b> is <b>retry 0</b>. This retries executing the outer most loop, regardless of the depth. Likewise, retry -1 retries the second outermost loop, and so on.</p>

<p>Normally, a sub-block which contains a retry statement also contains another flow control keyword like exit, continue, or break. Otherwise, the iteration would be endlessly executed.</p>

<h3>Example</h3>

<p>Since retry does not change the value of i and tries again opening the same file, there has to be a way to break from the loop, which the exit statement provides.</p>

<h2>The goto statement</h2>

<p>The <b>goto</b> statement instructs the computer to resume code execution at a labeled place.</p>

<p>The place to resume execution is called the target of the statement. It is restricted to lie in the current routine, or the current file if outside any routine.</p>

<h3>Syntax</h3>

<p>The syntax of goto statement is as follows &minus;</p>

<p>The target of a goto statement can be any accessible <b>label</b> statement &minus;</p>

<p>Label names must be double quoted constant strings. Characters that are illegal in Euphoria identifiers may appear in a label name, since it is a regular string.</p>

<h3>Example</h3>

<p>This produces the following result &minus;</p>

<h1>Euphoria - Short Circuit Evaluation</h1>

<p>When a condition is tested by <b>if, elsif, until</b>, or <b>while</b> using <b>and</b> or <b>or</b> operators, a short-circuit evaluation is used. For example &minus;</p>

<p>If a &lt; 0 is false, then Euphoria does not bother to test if b is greater than 0. It knows that the overall result is false regardless. Similarly &minus;</p>

<p>if a &lt; 0 is true, then Euphoria immediately decides that the result true, without testing the value of b, since the result of this test is irrelevant.</p>

<p>In General, whenever you have a condition of the following form &minus;</p>

<p>Where A and B can be any two expressions, Euphoria takes a short-cut when A is false and immediately makes the overall result false, without even looking at expression B.</p>

<p>Similarly, whenever you have a condition of the following form &minus;</p>

<p>Where A is true, Euphoria skips the evaluation of expression B, and declares the result to be true.</p>

<p><b>Short-circuit</b> evaluation of and and or takes place for if, elsif, until, and while conditions only. It is not used in other contexts. For example &minus;</p>

<p>If short-circuiting were used here, you would set x to 1, and not even look at {1,2,3,4,5}, which would be wrong.</p>

<p>Thus, short-circuiting can be used in if, elsif, until, or while conditions, because you need to only care if the result is true or false, and conditions are required to produce an atom as a result.</p>

<h1>Euphoria - Sequences</h1>

<p>A sequence is represented by a list of objects in brace brackets { }, separated by commas. A sequence can contain both atoms and other sequences. For example &minus;</p>

<p>A single element of a sequence may be selected by giving the element number in square brackets. Element numbers start at 1.</p>

<p>For example, if x contains {5, 7.2, 9, 0.5, 13} then x[2] is 7.2.</p>

<p>Suppose x[2] contains {11,22,33}, Now if you ask for x[2] you get {11,22,33} and if you ask for x[2][3], you get the atom 33.</p>

<h3>Example</h3>

<p>Here, length() is the built-in function which returns length of the sequence. The above example produces the following result &minus;</p>

<h2>Character String</h2>

<p>A character string is just a <b>sequence</b> of characters. It may be entered in one of the two ways &minus;</p>

<p><b>(a) Using Double Quotes &minus;</b></p>

<p><b>(b) Using Raw String Notation &minus;</b></p>

<p>You can try the following example to understand the concept &minus;</p>

<p>This produces the following result &minus;</p>

<h2>String Arrays</h2>

<p>An array of strings can be implemented using Sequences as follows &minus;</p>

<p>This produces the following result &minus;</p>

<h2>Euphoria Structures</h2>

<p>A structure can be implemented using Sequences as follows &minus;</p>

<p>This produces the following result &minus;</p>

<p>There are various operations which can be performed directly on sequences. Let us see them in detail &minus;</p>

<h2>Urinary Operation</h2>

<p>When applied to a sequence, a unary operator is actually applied to each element in the sequence to yield a sequence of results of the same length.</p>

<p>This produces the following result &minus;</p>

<h2>Arithmetic Operations</h2>

<p>Almost all arithmetic operations can be performed on sequences as follows &minus;</p>

<p>This produces the following result &minus;</p>

<h2>Command Line Options</h2>

<p>A user can pass command line options to a Euphoria script and it can be accessed as a sequence using <b>command_line()</b> function as follows &minus;</p>

<p>Here <b>printf()</b> is Euphoria's built-in function. Now if you run this script as follows &minus;</p>

<p>This produces the following result &minus;</p>

<h1>Euphoria - Date &amp; Time</h1>

<p>Euphoria has a library routine that returns the date and time to your program.</p>

<h2>The <i>date()</i> Method</h2>

<p>The date() method returns a sequence value composed of eight atom elements. The following example explains it in detail &minus;</p>

<p>This produces the following result on your standard screen &minus;</p>

<h2>The <i>time()</i> Method</h2>

<p>The time() method returns an atom value, representing the number of seconds elapsed since a fixed point in time. The following example explains it in detail &minus;</p>

<p>This produces the following result &minus;</p>

<h2>Date &amp; Time Related Methods</h2>

<p>Euphoria provides a list of methods which helps you in manipulating date and time. These methods are listed in <a href="/euphoria/euphoria_library_routines.htm"> Euphoria Library Routines</a>.</p>

<h1>Euphoria - Procedures</h1>

<p>A procedure is a group of reusable code which can be called from anywhere in your program. This eliminates the need of writing same code again and again. This helps programmers to write modular code.</p>

<p>Like any other advance programming language, Euphoria also supports all the features necessary to write modular code using procedures.</p>

<p>You must have seen procedures like <i>printf()</i> and <i>length()</i> in previous chapters. We are using these procedure again and again but they have been written in core Euphoria only once.</p>

<p>Euphoria allows you to write your own procedures as well. This section explains how to write your own procedure in Euphoria.</p>

<h2>Procedure Definition</h2>

<p>Before you use a procedure, you need to define it. The most common way to define a procedure in Euphoria is by using the <b>procedure</b> keyword, followed by a unique procedure name, a list of parameters (that might be empty), and a statement block which ends with <b>end procedure</b> statement. The basic syntax is as shown below &minus;</p>

<h3>Example</h3>

<p>A simple procedure called sayHello that takes no parameters is defined here &minus;</p>

<h2>Calling a Procedure</h2>

<p>To invoke a procedure somewhere later in the script, you simply need to write the name of that procedure as follows &minus;</p>

<p>This produces the following result &minus;</p>

<h2>Procedure Parameters</h2>

<p>Till now you have seen procedure without a parameter. But there is a facility to pass different parameters while calling a procedure. These passed parameters can be captured inside the procedure and any manipulation can be done over those parameters.</p>

<p>A procedure can take multiple parameters separated by comma.</p>

<h3>Example</h3>

<p>Let us do a bit modification in our <i>sayHello</i> procedure. This time it takes two parameters &minus;</p>

<p>This produces the following result &minus;</p>

<h1>Euphoria - Functions</h1>

<p>Euphoria functions are just like procedures, but they return a value, and can be used in an expression. This chapter explains how to write your own functions in Euphoria.</p>

<h2>Function Definition</h2>

<p>Before we use a function we need to define it. The most common way to define a function in Euphoria is by using the <b>function</b> keyword, followed by a unique function name, a list of parameters (that might be empty), and a statement block which ends with <b>end function</b> statement. The basic syntax is shown here &minus;</p>

<h3>Example</h3>

<p>A simple function called sayHello that takes no parameters is defined here &minus;</p>

<h2>Calling a Function</h2>

<p>To invoke a function somewhere later in the script, you would simple need to write the name of that function as follows &minus;</p>

<p>This produces the following result &minus;</p>

<h2>Function Parameters</h2>

<p>Till now we have seen function without a parameters. But there is a facility to pass different parameters while calling a function. These passed parameters can be captured inside the function and any manipulation can be done over those parameters.</p>

<p>A function can take multiple parameters separated by comma.</p>

<h3>Example</h3>

<p>Let us do a bit modification in our <i>sayHello</i> function. This time it takes two parameters &minus;</p>

<p>This produces the following result &minus;</p>

<h2>The <i>return</i> Statement</h2>

<p>A Euphoria function must have <i>return</i> statement before closing statement <b>end function</b>. Any Euphoria object can be returned. You can, in effect, have multiple return values, by returning a sequence of objects. For example</p>

<p>If you have nothing to return, then simply return 1 or 0. The return value 1 indicates success and 0 indicates failure</p>

<h1>Euphoria - Files I/O</h1>

<p>Using Euphoria programming language, you can write programs that read and change file data on your floppy drive or hard drive, or create new files as a form of output. You can even access devices on your computer such as the printer and modem.</p>

<p>This chapter described all the basic I/O functions available in Euphoria. For information on more functions, please refer to standard Euphoria documentation.</p>

<h2>Displaying on the Screen</h2>

<p>The simplest way to produce output is using the <i>puts()</i> statement where you can pass any string to be displayed on the screen. There is another method <i>printf()</i> which can also be used in case you have to format a string using dynamic values.</p>

<p>These methods convert the expressions you pass them to a string and write the result to standard output as follows &minus;</p>

<p>This produces the following result on your standard screen &minus;</p>

<h2>Opening and Closing Files</h2>

<p>Euphoria provides basic methods necessary to manipulate files by default. You can do your most of the file manipulation using the following methods &minus;</p>

<h2>The <i>open</i> Method</h2>

<p>Before you can read or write a file, you have to open it using Euphoria's built-in <i>open()</i>method. This function creates a file descriptor which is utilized to call other supporting methods associated with it.</p>

<h3>Syntax</h3>

<p>Above method returns -1 in case there is an error in opening the given file name. Here are the parameters &minus;</p>

<p><b>file_name</b> &minus; The file_name argument is a string value that contains the name of the file that you want to access.</p>

<p><b>access_mode</b> &minus; The access_mode determines the mode in which the file has to be opened. For example, read, write append, etc. A complete list of possible values for file opening modes is given in the following table &minus;</p>

<p><b>r</b></p>

<p>Opens a text file for reading only. The file pointer is placed at the beginning of the file.</p>

<p><b>rb</b></p>

<p>Opens a file for reading only in binary format. The file pointer is placed at the beginning of the file.</p>

<p><b>w</b></p>

<p>Opens a text file for writing only. Overwrites the file if the file exists. If the file does not exist, creates a new file for writing.</p>

<p><b>wb</b></p>

<p>Opens a file for writing only in binary format. Overwrites the file if the file exists. If the file does not exist, creates a new file for writing.</p>

<p><b>u</b></p>

<p>Opens a file for both reading and writing. The file pointer is set at the beginning of the file.</p>

<p><b>ub</b></p>

<p>Opens a file for both reading and writing in binary format. The file pointer is placed at the beginning of the file.</p>

<p><b>a</b></p>

<p>Opens a file for appending. The file pointer is at the end of the file if the file exists (append mode). If the file does not exist, it creates a new file for writing.</p>

<p><b>ab</b></p>

<p>Opens a file for appending in binary format. The file pointer is at the end of the file if the file exists (append mode). If the file does not exist, it creates a new file for writing.</p>

<h3>Example</h3>

<p>The following example creates a new text file in the current directory on your Linux system &minus;</p>

<p>If file opens successfully, then it "myfile.txt" is created in your current directory and produces the following result &minus;</p>

<h2>The <i>close()</i> Method</h2>

<p>The close() method flushes any unwritten information and closes the file, after which no more reading or writing can be done on the file.</p>

<p>Euphoria automatically closes a file when the reference object of a file is reassigned to another file. It is a good practice to use the close() method to close a file.</p>

<h3>Syntax</h3>

<p>Here the file descriptor received while opening a file is passed as a parameter.</p>

<h3>Example</h3>

<p>The following example creates a file as above and then closes it before existing the program &minus;</p>

<p>This produces the following result &minus;</p>

<h2>Reading and Writing Files</h2>

<p>Euphoria provides a set of access methods to make our lives easier while reading or writing a file either in text mode or binary mode. Let us see how to use <i>printf()</i> and <i>gets()</i> methods to read and write files.</p>

<h2>The <i>printf()</i> Method</h2>

<p>The <i>printf()</i> method writes any string to an open file.</p>

<h3>Syntax</h3>

<p>Here are the parameters &minus;</p>

<p><b>fn</b> &minus; File descriptor received from open() method.</p>

<p><b>st</b> &minus; Format string where decimal or atom is formatted using %d and string or sequence is formatted using %s.</p>

<p><b>x</b> &minus; If x is a sequence, then format specifiers from st are matched with corresponding elements of x. If x is an atom, then normally st contains just one format specifier and it is applied to x. However; if st contains multiple format specifiers, then each one is applied to the same value x.</p>

<h3>Example</h3>

<p>The following example opens a file and writes the name and age of a person in this file &minus;</p>

<p>The above example creates <i>myfile.txt</i> file. Is writes given content in that file and finally closes. If you open this file, it would have the following content &minus;</p>

<h2>The <i>gets()</i> Method</h2>

<p>The <i>gets()</i> method reads a string from an open file.</p>

<h3>Syntax</h3>

<p>Here passed parameter is file description return by the <i>opend()</i> method. This method starts reading from the beginning of the file line by line. The characters have values from 0 to 255. The atom -1 is returned on end of file.</p>

<h3>Example</h3>

<p>Let us take a file <i>myfile.txt</i> which is already created.</p>

<p>This produces the following result &minus;</p>

<p>Euphoria provides a list of many methods which helps you in manipulating files. These methods are listed in <a href="/euphoria/euphoria_library_routines.htm"> Euphoria Library Routines</a>.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
$cp euphoria-4.0b2.tar.gz /home
$cd /home
$gunzip euphoria-4.0b2.tar.gz
$tar -xvf euphoria-4.0b2.tar
</pre>
<p>This creates a directory hierarchy inside <b>/home/euphoria-4.0b2</b> directory as follows &minus;</p>
<pre class="result notranslate">
$ls -l
-rw-r--r-- 1 1001 1001 2485 Aug 17 06:15 Jamfile
-rw-r--r-- 1 1001 1001 5172 Aug 20 12:37 Jamrules
-rw-r--r-- 1 1001 1001 1185 Aug 13 06:21 License.txt
drwxr-xr-x 2 1001 1001 4096 Aug 31 10:07 bin
drwxr-xr-x 7 1001 1001 4096 Aug 31 10:07 demo
-rw-r--r-- 1 1001 1001 366 Mar 18 09:02 file_id.diz
drwxr-xr-x 4 1001 1001 4096 Aug 31 10:07 include
-rw-r--r-- 1 1001 1001 1161 Mar 18 09:02 installu.doc
drwxr-xr-x 4 1001 1001 4096 Aug 31 10:07 source
drwxr-xr-x 19 1001 1001 4096 Sep 7 12:09 tests
drwxr-xr-x 2 1001 1001 4096 Aug 31 10:07 tutorial
</pre>
<p><b>NOTE</b> &minus; File name euphoria-4.0b2.tar.gz depends on latest version available. We are using 4.0b2 version of the language for this tutorial.</p>
<p><b>Step 2</b> &minus; Setting Up the Path</p>
<p>After installing Euphoria, you need to set proper paths so that your shell can find required Euphoria binaries and utilities. Before proceeding, there are following three important environment variables you need to set up &minus;</p>
<ul class="list">
<li><p>Set PATH environment variable to point /home/euphoria-4.0b2/bin directory.</p></li>
<li><p>Set EUDIR environment variable to point to /home/euphoria-4.0b2.</p></li>
<li><p>Set EUINC environment variable to point to /home/euphoria-4.0b2/include.</p></li>
</ul>
<p>These variables can be set as follows &minus;</p>
<pre class="result notranslate">
$export PATH=$PATH:/home/euphoria-4.0b2/bin
$export EUDIR=/home/euphoria-4.0b2
$export EUINC=/home/euphoria-4.0b2/include
</pre>
<p><b>NOTE</b> &minus; The above commands used to set environment variables may differ depending on your Shell. We used <i>bash</i> shell for executing these commands to set the variables.</p>
<p><b>Step 3</b> &minus; Confirmation Installation</p>
<p>Confirm if you installed Euphoria successfully or not.</p>
<p>Execute the following command &minus;</p>
<pre class="result notranslate">
$eui -version
</pre>
<p>If you get following result, then it means you have installed Euphoria successfully; otherwise you have to go back and check all the steps again.</p>
<pre class="result notranslate">
$eui -version
Euphoria Interpreter 4.0.0 beta 2 (r2670) for Linux
Using System Memory
$
</pre>
<p>That is it, Euphoria Programming Environment is ready on your UNIX machine, and you can start writing complex programs in easy steps.</p>
<h2>WIN32, and DOS Installation</h2>
<p>Official website provides <b>.exe</b> file to install Euphoria on your WIN32 or DOS OS. You can download your latest version of Euphoria from its official website &minus; <a href="http://www.rapideuphoria.com/" rel="nofollow" target="_blank">Download Euphoria</a>.</p>
<p>Once you have .exe file, here are three simple steps to follow for installing Euphoria Programming language on your WIN32 or DOS machine &minus;</p>
<p><b>Step 1</b> &minus; Installing Files</p>
<p>Double click on the downloaded <b>.exe</b> setup program to install all the files. We downloaded euphoria-40b2.exe file for installation.</p>
<p>The filename euphoria-40b2.exe depends on latest version available. We use version 4 beta 2 of the language.</p>
<p>By default Euphoria would be installed in C:\<i>euphoria-40b2</i> directory but you can also select a desired location.</p>
<p><b>Step 2</b> &minus; Rebooting the Machine</p>
<p>Re-boot your machine to complete the installation.</p>
<p><b>Step 3</b> &minus; Confirmation Installation</p>
<p>Confirm if you installed Euphoria successfully or not.</p>
<p>Execute the following command &minus;</p>
<pre class="result notranslate">
c:\&gt;eui -version
</pre>
<p>If you get following result, then it means you have installed Euphoria successfully; otherwise you have to go back and check all the steps again.</p>
<pre class="result notranslate">
c:\&gt;eui -version
Euphoria Interpreter 4.0.0 beta 2 (r2670) for Windows
Using Managed Memory

c:\&gt;
</pre>
<p>That is it, Euphoria Programming Environment is ready on your WIN32 machine, and you can start writing complex programs in easy steps.</p>
<h2>Euphoria Interpreters</h2>
<p>Depending on the platform you are using, Euphoria has multiple interpreters &minus;</p>
<ul class="list">
<li><p>The main interpreter is <b>eui</b>.</p></li>
<li><p>On windows platforms, you have two choices. If you run <b>eui</b> then a console window is created. If you run <b>euiw</b> then no console is created, making it suitable for GUI applications.</p></li>
<li><p>Euphoria does not care about your choice of file extensions. By convention however; the console-based applications come with <b>.ex</b> extension.</p></li>
<li><p>GUI-based applications have <b>.exw</b> extension and the include files have <b>.e</b> extension.</p></li>
</ul>
<h1>Euphoria - Basic Syntax</h1>
<p>The Euphoria language has many similarities to Perl, C, and Java. However, there are some definite differences between the languages. This chapter is designed to quickly get you up to speed on the syntax that is expected in Euphoria.</p>
<p>This tutorial assumes you are working with Linux and all the examples have been written on Linux platform. But it is observed that there is no any prominent difference in program syntax on Linux and WIN32. Hence you can follow the same steps on WIN32.</p>
<h2>First Euphoria Program</h2>
<p>Let us write a simple Euphoria program in a script. Type the following source code in test.ex file and save it.</p>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui

puts(1, "Hello, Euphoria!\n")
</pre>
<p>Let us say, Euphoria interpreter is available in <i>/home/euphoria-4.0b2/bin/</i> directory. Now run this program as follows &minus;</p>
<pre class="prettyprint notranslate">
$ chmod +x test.ex    # This is to make file executable
$ ./test.ex
</pre>
<p>This produces the following result &minus;</p>
<pre class="result notranslate">
Hello, Euphoria!
</pre>
<p>This script used a built-in function <b>puts()</b> which takes two arguments. First argument indicates file name or device number, and second argument indicates a string which you want to print. Here 1 indicates STDOUT device.</p>
<h2>Euphoria Identifiers</h2>
<p>A Euphoria identifier is a name used to identify a variable, function, class, module, or other object. An identifier starts with a letter A to Z or a to z and then followed by letters, digits, or underscores.</p>
<p>Euphoria does not allow punctuation characters such as @, $, and % within identifiers.</p>
<p>Euphoria is a case sensitive programming language. Thus <b>Manpower</b> and <b>manpower</b> are two different identifiers in Euphoria. For example, the valid identifiers are &minus;</p>
<ul class="list">
<li>n</li>
<li>color26</li>
<li>ShellSort</li>
<li>quick_sort</li>
<li>a_very_long_indentifier</li>
</ul>
<h2>Reserved Words</h2>
<p>The following list shows the reserved words in Euphoria. These reserved words may not be used as constant or variable or any other identifier names. Euphoria keywords contain lowercase letters only.</p>
<table class="table table-bordered">
<tr>
<td>and</td>
<td>exit</td>
<td>override</td>
</tr>
<tr>
<td>as</td>
<td>export</td>
<td>procedure</td>
</tr>
<tr>
<td>break</td>
<td>fallthru</td>
<td>public</td>
</tr>
<tr>
<td>by</td>
<td>for</td>
<td>retry</td>
</tr>
<tr>
<td>case</td>
<td>function</td>
<td>return</td>
</tr>
<tr>
<td>constant</td>
<td>global</td>
<td>routine</td>
</tr>
<tr>
<td>continue</td>
<td>goto</td>
<td>switch</td>
</tr>
<tr>
<td>do</td>
<td>if</td>
<td>then</td>
</tr>
<tr>
<td>else</td>
<td>ifdef</td>
<td>to</td>
</tr>
<tr>
<td>elsedef</td>
<td>include</td>
<td>type</td>
</tr>
<tr>
<td>elsif</td>
<td>label</td>
<td>until</td>
</tr>
<tr>
<td>elsifdef</td>
<td>loop</td>
<td>while</td>
</tr>
<tr>
<td>end</td>
<td>namespace</td>
<td>with</td>
</tr>
<tr>
<td>entry</td>
<td>not</td>
<td>without</td>
</tr>
<tr>
<td>enum</td>
<td>or</td>
<td>xor</td>
</tr>
</table>
<h2>Expressions</h2>
<p>Euphoria lets you calculate results by forming expressions. However, in Euphoria you can perform calculations on entire sequences of data with one expression.</p>
<p>You can handle a sequence much as you would handle a single number. It can be copied, passed to a subroutine, or calculated upon as a unit. For example &minus;</p>
<pre class="result notranslate">
{1,2,3} + 5
</pre>
<p>This is an expression that adds the sequence {1, 2, 3} and the atom 5 to get the resulting sequence {6, 7, 8}. You would learn sequences in subsequent chapters.</p>
<h2>Blocks of code</h2>
<p>One of the first caveats programmers encounter when learning Euphoria is the fact that there are no braces to indicate blocks of code for procedure and function definitions or flow control. Blocks of code are denoted by associated keywords.</p>
<p>The following example shows <b>if...then...end if</b> block &minus;</p>
<pre class="prettyprint notranslate">
if condition then
   code block comes here
end if
</pre>
<h2>Multi-Line Statements</h2>
<p>Statements in Euphoria typically end with a new line. Euphoria does however, allow to write a single statement in multiple lines. For example &minus;</p>
<pre class="prettyprint notranslate">
total = item_one + 
   item_two + 
   item_three
</pre>
<h2>Escape Characters</h2>
<p>Escape characters may be entered using a back-slash. For example &minus;</p>
<p>The following table is a list of escape or non-printable characters that can be represented with backslash notation.</p>
<table style="text-align:center;" class="table table-bordered">
<tr>
<th style="text-align:center;">Backslash notation</th>
<th style="text-align:center;">Description</th>
</tr>
<tr>
<td>\n</td>
<td>Newline</td>
</tr>
<tr>
<td>\r</td>
<td>Carriage return</td>
</tr>
<tr>
<td>\t</td>
<td>Tab</td>
</tr>
<tr>
<td>\\</td>
<td>Backslash</td>
</tr>
<tr>
<td>\"</td>
<td>Double quote</td>
</tr>
<tr>
<td>\'</td>
<td>Single quote</td>
</tr>
</table>
<h2>Comments in Euphoria</h2>
<p>Any comments are ignored by the compiler and have no effect on execution speed. It is advisable to use more comments in your program to make it more readable.</p>
<p>There are three forms of comment text &minus;</p>
<ul class="list">
<li><p>Comments start by two dashes and extend to the end of the current line.</p></li>
<li><p>The multi-line format comment is kept inside /*...*/, even if that occurs on a different line.</p></li>
<li><p>You can use a special comment beginning with the two character sequence “#!” only on the first line of the program.</p></li>
</ul>
<h3>Examples</h3>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui
-- First comment
puts(1, "Hello, Euphoria!\n") -- second comment

/* This is a comment which extends over a number
   of text lines and has no impact on the program
*/
</pre>
<p>This produces the following result &minus;</p>
<pre class="result notranslate">
Hello, Euphoria!
</pre>
<p><b>Note</b> &minus; You can use a special comment beginning with “#!”. This informs the Linux shell that your file should be executed by the Euphoria interpreter.</p>
<h1>Euphoria - Variables</h1>
<p>Variables are nothing but reserved memory locations to store values. This means when you create a variable, you reserve some space in memory.</p>
<p>Based on the data type of a variable, the interpreter allocates memory and decides what can be stored in the reserved memory. Therefore, by assigning different data types to variables, you can store integers, decimals, or characters in these variables. Euphoria data types are explained in different chapter.</p>
<p>These memory locations are called variables because their value can be changed during their life time.</p>
<h2>Variable Declaration</h2>
<p>Euphoria variables have to be explicitly declared to reserve memory space. Thus declaration of a variable is mandatory before you assign a value to a variable.</p>
<p>Variable declarations have a type name followed by a list of the variables being declared. For example &minus;</p>
<pre class="result notranslate">
integer x, y, z

sequence a, b, x
</pre>
<p>When you declare a variable, you name the variable and you define which sort of values may legally be assigned to the variable during execution of your program.</p>
<p>The simple act of declaring a variable does not assign any value to it. If you attempt to read it before assigning any value to it, Euphoria will issue a run-time error as <i>"variable xyz has never been assigned a value"</i>.</p>
<h2>Assigning Values</h2>
<p>The equal sign (=) is used to assign values to variables. Variable can be assigned in the following manner &minus;</p>
<p>Variable_Name = Variable_Value</p>
<p>For example &minus;</p>
<pre class="prettyprint notranslate">
#!/home/euphoria/bin/eui

-- Here is the declaration of the variables.
integer counter
integer miles
sequence name

counter = 100 -- An integer assignment
miles = 1000.0 -- A floating point
name = "John" -- A string ( sequence )

printf(1, "Value of counter %d\n", counter )
printf(1, "Value of miles %f\n", miles )
printf(1, "Value of name %s\n", {name} )
</pre>
<p>Here 100, 1000.0 and "John" are the values assigned to <i>counter</i>, <i>miles</i> and <i>name</i> variables, respectively. This program produces the following result &minus;</p>
<pre class="result notranslate">
Value of counter 100
Value of miles 1000.000000
Value of name John
</pre>
<p>To guard against forgetting to initialize a variable, and also because it may make the code clearer to read, you can combine declaration and assignment &minus;</p>
<pre class="result notranslate">
integer n = 5
</pre>
<p>This is equivalent to the following &minus;</p>
<pre class="result notranslate">
integer n
n = 5
</pre>
<h2>Identifier Scope</h2>
<p>The scope of an identifier is a description of what code can access it. Code in the same scope of an identifier can access that identifier and code not in the same scope as identifier cannot access it.</p>
<p>The scope of a variable depends upon where and how it is declared.</p>
<ul class="list">
<li><p>If it is declared within a <b>for, while, loop</b> or <b>switch</b>, its scope starts at the declaration and ends at the respective <b>end</b> statement.</p></li>
<li><p>In an <b>if</b> statement, the scope starts at the declaration and ends either at the next <b>else, elsif</b> or <b>end if</b> statement.</p></li>
<li><p>If a variable is declared within a routine, the scope of the variable starts at the declaration and ends at the routine's end statement. This is knows as a private variable.</p></li>
<li><p>If a variable is declared outside of a routine, its scope starts at the declaration and ends and the end of the file it is declared in. This is known as a module variable.</p></li>
<li><p>The scope of a <b>constant</b> that does not have a scope modifier, starts at the declaration and ends and the end of the file it is declared in.</p></li>
<li><p>The scope of a <b>enum</b> that does not have a scope modifier, starts at the declaration and ends and the end of the file it is declared in.</p></li>
<li><p>The scope of all <b>procedures, functions</b> and <b>types</b>, which do not have a scope modifier, starts at the beginning of the source file and ends at the end of the source file in which they are declared.</p></li>
</ul>
<p>Constants, enums, module variables, procedures, functions and types, which do not have a scope modifier are referred to as <b>locals</b>. However, these identifiers can have a scope modifier preceding their declaration, which causes their scope to extend beyond the file they are declared in.</p>
<ul class="list">
<li><p>If the keyword <b>global</b> precedes the declaration, the scope of these identifiers extends to the whole application. They can be accessed by code anywhere in the application files.</p></li>
<li><p>If the keyword <b>public</b> precedes the declaration, the scope extends to any file that explicitly includes the file in which the identifier is declared, or to any file that includes a file that in turn <i>public</i> includes the file containing the <i>public</i> declaration.</p></li>
<li><p>If the keyword <b>export</b> precedes the declaration, the scope only extends to any file that directly includes the file in which the identifier is declared.</p></li>
</ul>
<p>When you <b>include</b> a Euphoria file in another file, only the identifiers declared using a scope modifier are accessible to the file doing the <i>include</i>. The other declarations in the included file are invisible to the file doing the <i>include</i>.</p>
<h1>Euphoria - Constants</h1>
<p>Constants are also variables that are assigned an initial value that can never change in the program’s life. Euphoria allows to define constants using constant keyword as follows &minus;</p>
<pre class="prettyprint notranslate">
constant MAX = 100
constant Upper = MAX - 10, Lower = 5
constant name_list = {"Fred", "George", "Larry"}
</pre>
<p>The result of any expression can be assigned to a constant, even one involving calls to previously defined functions, but once the assignment is made, the value of the constant variable is "locked in".</p>
<p>Constants may not be declared inside a subroutine. The scope of a <b>constant</b> that does not have a scope modifier, starts at the declaration and ends and the end of the file it is declared in.</p>
<h3>Examples</h3>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui

constant MAX = 100
constant Upper = MAX - 10, Lower = 5

printf(1, "Value of MAX %d\n", MAX )
printf(1, "Value of Upper %d\n", Upper )
printf(1, "Value of Lower %d\n", Lower )

MAX = MAX + 1
printf(1, "Value of MAX %d\n", MAX )
</pre>
<p>This produces the following error &minus;</p>
<pre class="result notranslate">
./test.ex:10
&lt;0110&gt;:: may not change the value of a constant
MAX = MAX + 1
   ^

Press Enter
</pre>
<p>If you delete last two lines from the example, then it produces the following result &minus;</p>
<pre class="result notranslate">
Value of MAX 100
Value of Upper 90
Value of Lower 5
</pre>
<h2>The <i>enums</i></h2>
<p>An enumerated value is a special type of constant where the first value defaults to the number 1 and each item after that is incremented by 1. Enums can only take numeric values.</p>
<p>Enums may not be declared inside a subroutine. The scope of an <b>enum</b> that does not have a scope modifier, starts at the declaration and ends and the end of the file it is declared in.</p>
<h3>Examples</h3>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui

enum ONE, TWO, THREE, FOUR

printf(1, "Value of ONE %d\n", ONE )
printf(1, "Value of TWO %d\n", TWO )
printf(1, "Value of THREE %d\n", THREE )
printf(1, "Value of FOUR %d\n", FOUR )
</pre>
<p>This will produce following result &minus;</p>
<pre class="result notranslate">
Value of ONE 1
Value of TWO 2
Value of THREE 3
Value of FOUR 4
</pre>
<p>You can change the value of any one item by assigning it a numeric value. Subsequent values are always the previous value plus one, unless they too are assigned a default value.</p>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui

enum ONE, TWO, THREE, ABC=10, XYZ

printf(1, "Value of ONE %d\n", ONE )
printf(1, "Value of TWO %d\n", TWO )
printf(1, "Value of THREE %d\n", THREE )
printf(1, "Value of ABC %d\n", ABC )
printf(1, "Value of XYZ %d\n", XYZ )
</pre>
<p>This produce the following result &minus;</p>
<pre class="result notranslate">
Value of ONE 1
Value of TWO 2
Value of THREE 3
Value of ABC 10
Value of XYZ 11
</pre>
<p>Sequences use integer indices, but with enum you may write code like this &minus;</p>
<pre class="prettyprint notranslate">
enum X, Y
sequence point = { 0,0 }

point[X] = 3
point[Y] = 4
</pre>
<h1>Euphoria - Data Types</h1>
<p>The data stored in memory can be of many types. For example, a person's age is stored as a numeric value and his or her address is stored as alphanumeric characters.</p>
<p>Euphoria has some standard types that are used to define the operations possible on them and the storage method for each of them.</p>
<p>Euphoria has following four standard data types &minus;</p>
<ul class="list">
<li>integer</li>
<li>atom</li>
<li>sequence</li>
<li>object</li>
</ul>
<p>The understanding of atoms and sequences is the key to understanding Euphoria.</p>
<h2>Integers</h2>
<p>Euphoria integer data types store numeric values. They are declared and defined as follows &minus;</p>
<pre class="prettyprint notranslate">
integer var1, var2

var1 = 1
var2 = 100
</pre>
<p>The variables declared with type integer must be atoms with <b>integer</b> values from -1073741824 to +1073741823 inclusive. You can perform exact calculations on larger integer values, up to about 15 decimal digits, but declare them as atom, rather than integer.</p>
<h2>Atoms</h2>
<p>All data objects in Euphoria are either atoms or sequences. An atom is a single numeric value. Atoms can have any integer or double-precision floating point value. Euphoria atoms are declared and defined as follows&minus;</p>
<pre class="prettyprint notranslate">
atom var1, var2, var3

var1 = 1000
var2 = 198.6121324234
var3 = 'E'       
</pre>
<p>The atoms can range from approximately -1e300 to +1e300 with 15 decimal digits of accuracy. An individual character is an <b>atom</b> which must may be entered using single quotes. For example, all the following statements are legal &minus;</p>
<pre class="result notranslate">
-- Following is equivalent to the atom 66 - the ASCII code for B
char = 'B'

-- Following is equivalent to the sequence {66}
sentence = "B"
</pre>
<h2>Sequences</h2>
<p>A sequence is a collection of numeric values which can be accessed through their index. All data objects in Euphoria are either atoms or sequences.</p>
<p>Sequence index starts from 1 unlike other programming languages where array index starts from 0. Euphoria sequences are declared and defined as follows &minus;</p>
<pre class="prettyprint notranslate">
sequence var1, var2, var3, var4

var1 = {2, 3, 5, 7, 11, 13, 17, 19}
var2 = {1, 2, {3, 3, 3}, 4, {5, {6}}}
var3 = {{"zara", "ali"}, 52389, 97.25}     
var4 = {} -- the 0 element sequence
</pre>
<p>A character string is just a <b>sequence</b> of characters which may be entered using double quotes. For example, all the following statements are legal &minus;</p>
<pre class="prettyprint notranslate">
word = 'word'
sentence = "ABCDEFG"
</pre>
<p>Character strings may be manipulated and operated upon just like any other sequences. For example, the above string is entirely equivalent to the sequence &minus;</p>
<pre class="prettyprint notranslate">
sentence = {65, 66, 67, 68, 69, 70, 71}
</pre>
<p>You will learn more about sequence in <a href="/euphoria/euphoria_sequences.htm">Euphoria &minus; Sequences</a>.</p>
<h2>Objects</h2>
<p>This is a super data type in Euphoria which may take on any value including atoms, sequences, or integers. Euphoria objects are declared and defined as follows &minus;</p>
<pre class="prettyprint notranslate">
object var1, var2, var3

var1 = {2, 3, 5, 7, 11, 13, 17, 19}
var2 = 100
var3 = 'E'     
</pre>
<p>An object may have one of the following values &minus;</p>
<ul class="list">
<li><p>a sequence</p></li>
<li><p>an atom</p></li>
<li><p>an integer</p></li>
<li><p>an integer used as a file number</p></li>
<li><p>a string sequence, or single-character atom</p></li>
</ul>
<h1>Euphoria - Operators</h1>
<p>Euphoria provides a rich set of operators to manipulate variables. We can divide all the Euphoria operators into the following groups &minus;</p>
<ul class="list">
<li>Arithmetic Operators</li>
<li>Relational Operators</li>
<li>Logical Operators</li>
<li>Assignment Operators</li>
<li>Misc Operators</li>
</ul>
<h2>The Arithmetic Operators</h2>
<p>Arithmetic operators are used in mathematical expressions in the same way that they are used in Algebra. The following table lists the arithmetic operators. Assume integer variable A holds 10 and variable B holds 20 then &minus;</p>
<p><a href="/euphoria/euphoria_arithmatic_operators.htm">Show Examples</a></p>
<table class="table table-bordered">
<tr>
<th style="text-align:center;" >Operator</th>
<th style="text-align:center;">Description</th>
<th style="text-align:center; width:24%">Example</th>
</tr>
<tr>
<td>+</td>
<td>Addition - Adds values on either side of the operator</td>
<td>A + B will give 30</td>
</tr>
<tr>
<td>-</td>
<td>Subtraction - Subtracts right hand operand from left hand operand</td>
<td>A - B will give -10</td>
</tr>
<tr>
<td>*</td>
<td>Multiplication - Multiplies values on either side of the operator</td>
<td>A * B will give 200</td>
</tr>
<tr>
<td>/</td>
<td>Division - Divides left hand operand by right hand operand</td>
<td>B / A will give 2</td>
</tr>
<tr>
<td>+</td>
<td>Unary plus - This has no impact on the variable value.</td>
<td>+B gives 20</td>
</tr>
<tr>
<td>-</td>
<td>Unary minus - This creates a negative value of the given variable.</td>
<td>-B gives -20</td>
</tr>
</table>
<h2>The Relational Operators</h2>
<p>There are following relational operators supported by Euphoria language. Assume variable A holds 10 and variable B holds 20 then &minus;</p>
<p><a href="/euphoria/euphoria_relational_operators.htm">Show Examples</a></p>
<table class="table table-bordered">
<tr>
<th style="text-align:center;">Operator</th>
<th style="text-align:center;">Description</th>
<th style="text-align:center; width:26%;">Example</th>
</tr>
<tr>
<td>=</td>
<td>Checks if the value of two operands are equal or not, if yes then condition becomes true.</td>
<td>(A = B) is not true.</td>
</tr>
<tr>
<td>!=</td>
<td>Checks if the value of two operands are equal or not, if values are not equal then condition becomes true.</td>
<td>(A != B) is true.</td>
</tr>
<tr>
<td>&gt;</td>
<td>Checks if the value of left operand is greater than the value of right operand, if yes then condition becomes true.</td>
<td>(A &gt; B) is not true.</td>
</tr>
<tr>
<td>&lt;</td>
<td>Checks if the value of left operand is less than the value of right operand, if yes then condition becomes true.</td>
<td>(A &lt; B) is true.</td>
</tr>
<tr>
<td>&gt;=</td>
<td>Checks if the value of left operand is greater than or equal to the value of right operand, if yes then condition becomes true.</td>
<td>(A &gt;= B) is not true.</td>
</tr>
<tr>
<td>&lt;=</td>
<td>Checks if the value of left operand is less than or equal to the value of right operand, if yes then condition becomes true.</td>
<td>(A &lt;= B) is true.</td>
</tr>
</table>
<h2>The Logical Operators</h2>
<p>The following table lists the logical operators. Assume boolean variables A holds 1 and variable B holds 0 then &minus;</p>
<p><a href="/euphoria/euphoria_logical_operators.htm">Show Examples</a></p>
<table class="table table-bordered">
<tr>
<th style="text-align:center;">Operator</th>
<th style="text-align:center;">Description</th>
<th style="text-align:center; width:23%">Example</th>
</tr>
<tr>
<td>and</td>
<td>Called Logical AND operator. If both the operands are non zero then then condition becomes true.</td>
<td>(A and B) is false.</td>
</tr>
<tr>
<td>or</td>
<td>Called Logical OR Operator. If any of the two operands are non zero then then condition becomes true.</td>
<td>(A or B) is true.</td>
</tr>
<tr>
<td>xor</td>
<td>Called Logical XOR Operator. Condition is true if one of them is true, if both operands are true or false then condition becomes false.</td>
<td>(A xor B) is true.</td>
</tr>
<tr>
<td>not</td>
<td>Called Logical NOT Operator which negates the result. Using this operator, true becomes false and false becomes true</td>
<td>not(B) is true.</td>
</tr>
</table>
<p>You can also apply these operators to numbers other than 1 or 0. The convention is: zero means false and non-zero means <i>true</i>.</p>
<h2>The Assignment Operators</h2>
<p>There are following assignment operators supported by Euphoria language &minus;</p>
<p><a href="/euphoria/euphoria_assignment_operators.htm">Show Examples</a></p>
<table class="table table-bordered">
<tr>
<th style="text-align:center;">Operator</th>
<th style="text-align:center;">Description</th>
<th style="text-align:center; width:25%;">Example</th>
</tr>
<tr>
<td>=</td>
<td>Simple assignment operator, Assigns values from right side operands to left side operand</td>
<td>C = A + B will assigne value of A + B into C</td>
</tr>
<tr>
<td>+=</td>
<td>Add AND assignment operator, It adds right operand to the left operand and assign the result to left operand</td>
<td>C += A is equivalent to C = C + A</td>
</tr>
<tr>
<td>-=</td>
<td>Subtract AND assignment operator, It subtracts right operand from the left operand and assign the result to left operand</td>
<td>C -= A is equivalent to C = C - A</td>
</tr>
<tr>
<td>*=</td>
<td>Multiply AND assignment operator, It multiplies right operand with the left operand and assign the result to left operand</td>
<td>C *= A is equivalent to C = C * A</td>
</tr>
<tr>
<td>/=</td>
<td>Divide AND assignment operator, It divides left operand with the right operand and assign the result to left operand</td>
<td>C /= A is equivalent to C = C / A</td>
</tr>
<tr>
<td>&amp;=</td>
<td>Concatenation operator</td>
<td>C &amp;= {2} is same as  C = {C} &amp; {2}</td>
</tr>
</table>
<p><b>Note</b> &minus; The equals symbol '=' used in an assignment statement is not an operator, it is just a part of the syntax.</p>
<h2>Miscellaneous Operators</h2>
<p>There are few other operators supported by Euphoria Language.</p>
<h3>The '&amp;' Operator</h3>
<p>Any two objects may be concatenated using “&amp;” operator. The result is a sequence with a length equal to the sum of the lengths of the concatenated objects.</p>
<p>For example &minus;</p>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui

sequence a, b, c
a = {1, 2, 3}
b = {4}
c = {1, 2, 3} &amp; {4}

printf(1, "Value of c[1] %d\n", c[1] )
printf(1, "Value of c[2] %d\n", c[2] )
printf(1, "Value of c[3] %d\n", c[3] )
printf(1, "Value of c[4] %d\n", c[4] )
</pre>
<p>This produces the following result &minus;</p>
<pre class="result notranslate">
Value of c[1] 1
Value of c[2] 2
Value of c[3] 3
Value of c[4] 4
</pre>
<h2>Precedence of Euphoria Operators</h2>
<p>Operator precedence determines the grouping of terms in an expression. This affects how an expression is evaluated. Certain operators have higher precedence than others; for example, the multiplication operator has higher precedence than the addition operator.</p>
<p>For example, x = 7 + 3 * 2</p>
<p>Here, x is assigned 13, not 20 because operator * has higher precedence than +.</p>
<p>Hence it first starts with 3*2 and then adds into 7.</p>
<p>Here operators with the highest precedence appear at the top of the table, those with the lowest appear at the bottom. Within an expression, higher precedence operators is evaluated first.</p>
<table class="table table-bordered">
<tr> 
<th style="text-align:center;">Category</th> 
<th style="text-align:center;">Operator</th>
<th style="text-align:center;">Associativity</th> 
</tr> 
<tr> 
<td>Postfix</td>
<td>function/type calls</td> 
<td>&nbsp;</td> 
</tr> 
<tr> 
<td>Unary</td> 
<td>+ - ! not</td> 
<td>Right to left</td>
</tr> 
<tr> 
<td>Multiplicative</td> 
<td>*  /</td>
<td>Left to right</td>
</tr> 
<tr> 
<td>Additive</td>
<td>+  -</td> 
<td>Left to right</td> 
</tr>
<tr> 
<td>Concatenation</td>
<td>&amp;</td> 
<td>Left to right</td> 
</tr>
<tr> 
<td>Relational</td>
<td>&gt; &gt;=  &lt; &lt;=</td> 
<td>Left to right</td> 
</tr>
<tr> 
<td>Equality</td> 
<td>=  !=</td> 
<td>Left to right</td> 
</tr> 
<tr> 
<td>Logical AND</td>
<td>and</td> 
<td>Left to right</td> 
</tr> 
<tr> 
<td>Logical OR</td> 
<td>or</td> 
<td>Left to right</td> 
</tr> 
<tr> 
<td>Logical XOR</td> 
<td>xor</td> 
<td>Left to right</td> 
</tr> 
<tr> 
<td>Comma</td> 
<td>,</td> 
<td>Left to right</td> 
</tr> 
</table>
<h1>Euphoria - Branching</h1>
<p>Branching is the most important aspect of any programming language. While writing your program, you may encounter a situation when you have to take a decision or you have to select one option out of the given many options.</p>
<p>Following diagram shows a simple scenario where a program needs to take one of the two paths based on the given condition.</p>
<img alt="Branching" src="/euphoria/images/branching.jpg" />
<p>Euphoria provides following three types of decision making (branching or conditional) statements &minus;</p>
<ul class="list">
<li><p><a href="/euphoria/euphoria_if_statement.htm">if statement</a></p></li>
<li><p><a href="/euphoria/euphoria_switch_statement.htm">switch statement</a></p></li>
<li><p><a href="/euphoria/euphoria_ifdef_statement.htm">ifdef statement</a></p></li>
</ul>
<p>Let us see the statements in detail &minus;</p>
<h1>Euphoria - Loop Types</h1>
<p>Looping is yet another most important aspect of any programming language. While writing your program, you may encounter a situation when you have to execute same statement many times and sometime may be infinite number of times.</p>
<p>There are several ways to specify for how long the process should go on, and how to stop or otherwise alter it. An iterative block may be informally called a loop, and each execution of code in a loop is called an iteration of the loop.</p>
<p>The following diagram shows a simple logical flow of a loop &minus;</p>
<center>
<img alt="Looping" src="/euphoria/images/looping.jpg" />
</center>
<p>Euphoria provides following three types of loop statements &minus;</p>
<ul class="list">
<li><p><a href="/euphoria/euphoria_while_statement.htm" title="while statement">while statement</a></p></li>
<li><p><a href="/euphoria/euphoria_until_statement.htm" title="loop until statement">loop until statement</a></p></li>
<li><p><a href="/euphoria/euphoria_for_statement.htm" title="for statement">for statement</a></p></li>
</ul>
<p>All the above statements provide you flexibility and ease of use based on different situations. Let us see them in detail one by one &minus;</p>
<h1>Euphoria - Flow Control</h1>
<p>Program execution flow refers to the order in which program statements get executed. By default the statements get executed one after another.</p>
<p>However; many times the order of execution needs to be altered from the default order, to get the task done.</p>
<p>Euphoria has a number of <i>flow</i> control statements that you can use to arrange the execution order of statements.</p>
<h2>The <i>exit</i> statement</h2>
<p>Exiting a loop is done with the keyword <b>exit</b>. This causes flow to immediately leave the current loop and recommence with the first statement after the end of the loop.</p>
<h3>Syntax</h3>
<p>The syntax of an exit statement is as follows &minus;</p>
<pre class="result notranslate">
exit [ "Label Name" ] [Number]
</pre>
<p>The <b>exit</b> statement terminates the latest and innermost loop until an optional label name or number is specified.</p>
<p>A special form of <b>exit N</b> is <b>exit 0</b>. This leaves all levels of loop, regardless of the depth. Control continues after the outermost loop block. Likewise, exit -1 exits the second outermost loop, and so on.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui

integer b

for a = 1 to 16 do
   printf(1, "value of a %d\n", a)
   
   if a = 10 then
      b = a
      exit
   end if
end for

printf(1, "value of b %d\n", b)
</pre>
<p>This produces the following result &minus;</p>
<pre class="result notranslate">
value of a 1
value of a 2
value of a 3
value of a 4
value of a 5
value of a 6
value of a 7
value of a 8
value of a 9
value of a 10
value of b 10
</pre>
<h2>The <i>break</i> statement</h2>
<p>The <b>break</b> statement works exactly like the <b>exit</b> statement, but applies to if statements or switch statements rather than to loop statements of any kind.</p>
<h3>Syntax</h3>
<p>The syntax of break statement is as follows &minus;</p>
<pre class="result notranslate">
break [ "Label Name" ] [Number]
</pre>
<p>The <b>break</b> statement terminates the latest and innermost if or switch block until an optional label name or number is specified.</p>
<p>A special form of <b>break N</b> is <b>break 0</b>. This leaves the outer most if or switch block, regardless of the depth. Control continues after the outermost block. Likewise, break -1 breaks the second outermost if or switch block, and so on.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui

integer a, b
sequence s = {'E','u', 'p'}

if s[1] = 'E' then
   a = 3
   
   if s[2] = 'u' then
      b = 1
      if s[3] = 'p' then
         break 0 -- leave topmost if block
      end if
      a = 2
   else
      b = 4
   end if
else
   a = 0
   b = 0
end if

printf(1, "value of a %d\n", a)
printf(1, "value of b %d\n", b)
</pre>
<p>This produces the following result &minus;</p>
<pre class="result notranslate">
value of a 3
value of b 1
</pre>
<h2>The <i>continue</i> statement</h2>
<p>The <b>continue</b> statement continues execution of the loop it applies to by going to the next iteration and skipping the rest of an iteration.</p>
<p>Going to the next iteration means testing a condition variable index and checking whether it is still within bounds.</p>
<h3>Syntax</h3>
<p>The syntax of continue statement is as follows &minus;</p>
<pre class="result notranslate">
continue [ "Label Name" ] [Number]
</pre>
<p>The <b>continue</b> statement would re-iterate the latest and inner most loop until an optional label name or number is specified.</p>
<p>A special form of <b>continue N</b> is <b>continue 0</b>. This re-iterate the outer most loop, regardless of the depth. Likewise, continue -1 starts from the second outermost loop, and so on.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui

for a = 3 to 6 do
   printf(1, "value of a %d\n", a)

   if a = 4 then
      puts(1,"(2)\n")
      continue
   end if

   printf(1, "value of a %d\n", a*a)
end for
This would produce following result:

value of a 3
value of a 9
value of a 4
(2)
value of a 5
value of a 25
value of a 6
value of a 36
</pre>
<h2>The <i>retry</i> statement</h2>
<p>The <b>retry</b> statement continues execution of the loop it applies to by going to the next iteration and skipping the rest of an iteration.</p>
<h3>Syntax</h3>
<p>The syntax of retry statement is as follows &minus;</p>
<pre class="result notranslate">
retry [ "Label Name" ] [Number]
</pre>
<p>The <b>retry</b> statement retries executing the current iteration of the loop it applies to. The statement branches to the first statement of the designated loop neither testing anything nor incrementing the for loop index.</p>
<p>A special form of <b>retry N</b> is <b>retry 0</b>. This retries executing the outer most loop, regardless of the depth. Likewise, retry -1 retries the second outermost loop, and so on.</p>
<p>Normally, a sub-block which contains a retry statement also contains another flow control keyword like exit, continue, or break. Otherwise, the iteration would be endlessly executed.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui

integer errors = 0
integer files_to_open = 10

for i = 1 to length(files_to_open) do
   fh = open(files_to_open[i], "rb")
   
   if fh = -1 then
      if errors &gt; 5 then
         exit
      else
         errors += 1
         retry
      end if
   end if
   file_handles[i] = fh
end for
</pre>
<p>Since retry does not change the value of i and tries again opening the same file, there has to be a way to break from the loop, which the exit statement provides.</p>
<h2>The goto statement</h2>
<p>The <b>goto</b> statement instructs the computer to resume code execution at a labeled place.</p>
<p>The place to resume execution is called the target of the statement. It is restricted to lie in the current routine, or the current file if outside any routine.</p>
<h3>Syntax</h3>
<p>The syntax of goto statement is as follows &minus;</p>
<pre class="result notranslate">
goto "Label Name"
</pre>
<p>The target of a goto statement can be any accessible <b>label</b> statement &minus;</p>
<pre class="prettyprint notranslate">
label "Label Name"
</pre>
<p>Label names must be double quoted constant strings. Characters that are illegal in Euphoria identifiers may appear in a label name, since it is a regular string.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui

integer a = 0

label "FIRST"
printf(1, "value of a %d\n", a)
a += 10

if a &lt; 50 then
   goto "FIRST"
end if 
printf(1, "Final value of a %d\n", a)
</pre>
<p>This produces the following result &minus;</p>
<pre class="result notranslate">
value of a 0
value of a 10
value of a 20
value of a 30
value of a 40
Final value of a 50
</pre>
<h1>Euphoria - Short Circuit Evaluation</h1>
<p>When a condition is tested by <b>if, elsif, until</b>, or <b>while</b> using <b>and</b> or <b>or</b> operators, a short-circuit evaluation is used. For example &minus;</p>
<pre class="prettyprint notranslate">
if a &lt; 0 and b &gt; 0 then
   -- block of code
end if
</pre>
<p>If a &lt; 0 is false, then Euphoria does not bother to test if b is greater than 0. It knows that the overall result is false regardless. Similarly &minus;</p>
<pre class="prettyprint notranslate">
if a &lt; 0 or b &gt; 0 then
   -- block of code
end if
</pre>
<p>if a &lt; 0 is true, then Euphoria immediately decides that the result true, without testing the value of b, since the result of this test is irrelevant.</p>
<p>In General, whenever you have a condition of the following form &minus;</p>
<pre class="result notranslate">
A and B
</pre>
<p>Where A and B can be any two expressions, Euphoria takes a short-cut when A is false and immediately makes the overall result false, without even looking at expression B.</p>
<p>Similarly, whenever you have a condition of the following form &minus;</p>
<pre class="result notranslate">
A or  B
</pre>
<p>Where A is true, Euphoria skips the evaluation of expression B, and declares the result to be true.</p>
<p><b>Short-circuit</b> evaluation of and and or takes place for if, elsif, until, and while conditions only. It is not used in other contexts. For example &minus;</p>
<pre class="prettyprint notranslate">
x = 1 or {1,2,3,4,5} -- x should be set to {1,1,1,1,1}
</pre>
<p>If short-circuiting were used here, you would set x to 1, and not even look at {1,2,3,4,5}, which would be wrong.</p>
<p>Thus, short-circuiting can be used in if, elsif, until, or while conditions, because you need to only care if the result is true or false, and conditions are required to produce an atom as a result.</p>
<h1>Euphoria - Sequences</h1>
<p>A sequence is represented by a list of objects in brace brackets { }, separated by commas. A sequence can contain both atoms and other sequences. For example &minus;</p>
<pre class="result notranslate">
{2, 3, 5, 7, 11, 13, 17, 19}
{1, 2, {3, 3, 3}, 4, {5, {6}}}
{{"Zara", "Ayan"}, 52389, 97.25}
{} -- the 0-element sequence
</pre>
<p>A single element of a sequence may be selected by giving the element number in square brackets. Element numbers start at 1.</p>
<p>For example, if x contains {5, 7.2, 9, 0.5, 13} then x[2] is 7.2.</p>
<p>Suppose x[2] contains {11,22,33}, Now if you ask for x[2] you get {11,22,33} and if you ask for x[2][3], you get the atom 33.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui

sequence x
x = {1, 2, 3, 4}

for a = 1 to length(x) do
   printf(1, "value of x[%d] = %d\n", {a, x[a]})
end for
</pre>
<p>Here, length() is the built-in function which returns length of the sequence. The above example produces the following result &minus;</p>
<pre class="result notranslate">
value of x[1] = 1
value of x[2] = 2
value of x[3] = 3
value of x[4] = 4
</pre>
<h2>Character String</h2>
<p>A character string is just a <b>sequence</b> of characters. It may be entered in one of the two ways &minus;</p>
<p><b>(a) Using Double Quotes &minus;</b></p>
<pre class="result notranslate">
"ABCDEFG"
</pre>
<p><b>(b) Using Raw String Notation &minus;</b></p>
<pre class="result notranslate">
-- Using back-quotes
`ABCDEFG`

or

-- Using three double-quotes
"""ABCDEFG"""
</pre>
<p>You can try the following example to understand the concept &minus;</p>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui

sequence x
x = "ABCD"

for a = 1 to length(x) do
   printf(1, "value of x[%d] = %s\n", {a, x[a]})
end for
</pre>
<p>This produces the following result &minus;</p>
<pre class="result notranslate">
value of x[1] = A
value of x[2] = B
value of x[3] = C
value of x[4] = D
</pre>
<h2>String Arrays</h2>
<p>An array of strings can be implemented using Sequences as follows &minus;</p>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui

sequence x = {"Hello", "World", "Euphoria", "", "Last One"}

for a = 1 to length(x) do
   printf(1, "value of x[%d] = %s\n", {a, x[a]})
end for
</pre>
<p>This produces the following result &minus;</p>
<pre class="result notranslate">
value of x[1] = Hello
value of x[2] = World
value of x[3] = Euphoria
value of x[4] =
value of x[5] = Last One
</pre>
<h2>Euphoria Structures</h2>
<p>A structure can be implemented using Sequences as follows &minus;</p>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui

sequence employee = {
   {"John","Smith"},
      45000,
      27,
      185.5
}
printf(1, "First Name = %s, Last Name = %s\n", {employee[1][1],employee[1][2]} )
</pre>
<p>This produces the following result &minus;</p>
<pre class="result notranslate">
First Name = John, Last Name = Smith
</pre>
<p>There are various operations which can be performed directly on sequences. Let us see them in detail &minus;</p>
<h2>Urinary Operation</h2>
<p>When applied to a sequence, a unary operator is actually applied to each element in the sequence to yield a sequence of results of the same length.</p>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui

sequence x
x = -{1, 2, 3, 4}

for a = 1 to length(x) do
   printf(1, "value of x[%d] = %d\n", {a, x[a]})
end for
</pre>
<p>This produces the following result &minus;</p>
<pre class="result notranslate">
value of x[1] = -1
value of x[2] = -2
value of x[3] = -3
value of x[4] = -4
</pre>
<h2>Arithmetic Operations</h2>
<p>Almost all arithmetic operations can be performed on sequences as follows &minus;</p>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui

sequence x, y, a, b, c
x = {1, 2, 3}
y = {10, 20, 30}

a = x + y
puts(1, "Value of a = {")

for i = 1 to length(a) do
   printf(1, "%d,", a[i])
end for
puts(1, "}\n")

b = x - y
puts(1, "Value of b = {")
for i = 1 to length(a) do
   printf(1, "%d,", b[i])
end for
puts(1, "}\n")

c = x * 3
puts(1, "Value of c = {")

for i = 1 to length(c) do
   printf(1, "%d,", c[i])
end for
puts(1, "}\n")
</pre>
<p>This produces the following result &minus;</p>
<pre class="result notranslate">
Value of a = {11,22,33,}
Value of b = {-9,-18,-27,}
Value of c = {3,6,9,}
</pre>
<h2>Command Line Options</h2>
<p>A user can pass command line options to a Euphoria script and it can be accessed as a sequence using <b>command_line()</b> function as follows &minus;</p>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui

sequence x

x = command_line()

printf(1, "Interpeter Name: %s\n", {x[1]} )
printf(1, "Script Name: %s\n", {x[2]} )
printf(1, "First Argument: %s\n", {x[3]})
printf(1, "Second Argument: %s\n", {x[4]})
</pre>
<p>Here <b>printf()</b> is Euphoria's built-in function. Now if you run this script as follows &minus;</p>
<pre class="result notranslate">
$eui test.ex "one" "two"
</pre>
<p>This produces the following result &minus;</p>
<pre class="result notranslate">
Interpeter Name: /home/euphoria-4.0b2/bin/eui
Script Name: test.ex
First Argument: one
Second Argument: two
</pre>
<h1>Euphoria - Date &amp; Time</h1>
<p>Euphoria has a library routine that returns the date and time to your program.</p>
<h2>The <i>date()</i> Method</h2>
<p>The date() method returns a sequence value composed of eight atom elements. The following example explains it in detail &minus;</p>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui
 
integer curr_year, curr_day, curr_day_of_year, curr_hour, curr_minute, curr_second
sequence system_date, word_week, word_month, notation, 
   curr_day_of_week, curr_month
   word_week = {"Sunday", 
      "Monday", 
      "Tuesday", 
      "Wednesday", 
      "Thursday", 
      "Friday", 
      "Saturday"}
   word_month = {"January", "February", 
      "March", 
      "April", 
      "May", 
      "June", 
      "July", 
      "August", 
      "September", 
      "October", 
      "November", 
      "December"}
-- Get current system date.
system_date = date()

-- Now take individual elements
curr_year = system_date[1] + 1900
curr_month = word_month[system_date[2]]
curr_day = system_date[3]
curr_hour = system_date[4]
curr_minute = system_date[5]
curr_second = system_date[6]
curr_day_of_week = word_week[system_date[7]]
curr_day_of_year = system_date[8]

if curr_hour &gt;= 12 then 
   notation = "p.m."
else 
   notation = "a.m."
end if

if curr_hour &gt; 12 then 
   curr_hour = curr_hour - 12
end if

if curr_hour = 0 then 
   curr_hour = 12
end if

puts(1, "\nHello Euphoria!\n\n")
printf(1, "Today is %s, %s %d, %d.\n", {curr_day_of_week, 
   curr_month, curr_day, curr_year})

printf(1, "The time is %.2d:%.2d:%.2d %s\n", {curr_hour, 
   curr_minute, curr_second, notation})

printf(1, "It is %3d days into the current year.\n", {curr_day_of_year})
</pre>
<p>This produces the following result on your standard screen &minus;</p>
<pre class="result notranslate">
Hello Euphoria!

Today is Friday, January 22, 2010.
The time is 02:54:58 p.m.
It is  22 days into the current year.
</pre>
<h2>The <i>time()</i> Method</h2>
<p>The time() method returns an atom value, representing the number of seconds elapsed since a fixed point in time. The following example explains it in detail &minus;</p>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui
 
constant ITERATIONS = 100000000
integer p
atom t0, t1, loop_overhead

t0 = time()
for i = 1 to ITERATIONS do
   -- time an empty loop
end for

loop_overhead = time() - t0

printf(1, "Loop overhead:%d\n", loop_overhead)

t0 = time()
for i = 1 to ITERATIONS do
    p = power(2, 20)
end for

t1 = (time() - (t0 + loop_overhead))/ITERATIONS

printf(1, "Time (in seconds) for one call to power:%d\n", t1)
</pre>
<p>This produces the following result &minus;</p>
<pre class="result notranslate">
Loop overhead:1
Time (in seconds) for one call to power:0
</pre>
<h2>Date &amp; Time Related Methods</h2>
<p>Euphoria provides a list of methods which helps you in manipulating date and time. These methods are listed in <a href="/euphoria/euphoria_library_routines.htm"> Euphoria Library Routines</a>.</p>
<h1>Euphoria - Procedures</h1>
<p>A procedure is a group of reusable code which can be called from anywhere in your program. This eliminates the need of writing same code again and again. This helps programmers to write modular code.</p>
<p>Like any other advance programming language, Euphoria also supports all the features necessary to write modular code using procedures.</p>
<p>You must have seen procedures like <i>printf()</i> and <i>length()</i> in previous chapters. We are using these procedure again and again but they have been written in core Euphoria only once.</p>
<p>Euphoria allows you to write your own procedures as well. This section explains how to write your own procedure in Euphoria.</p>
<h2>Procedure Definition</h2>
<p>Before you use a procedure, you need to define it. The most common way to define a procedure in Euphoria is by using the <b>procedure</b> keyword, followed by a unique procedure name, a list of parameters (that might be empty), and a statement block which ends with <b>end procedure</b> statement. The basic syntax is as shown below &minus;</p>
<pre class="result notranslate">
procedure procedurename(parameter-list)

   statements
   ..........

end procedure
</pre>
<h3>Example</h3>
<p>A simple procedure called sayHello that takes no parameters is defined here &minus;</p>
<pre class="prettyprint notranslate">
procedure  sayHello()
   puts(1, "Hello there")
end procedure
</pre>
<h2>Calling a Procedure</h2>
<p>To invoke a procedure somewhere later in the script, you simply need to write the name of that procedure as follows &minus;</p>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui

procedure  sayHello()
   puts(1, "Hello there")
end procedure 

-- Call above defined procedure.
sayHello()
</pre>
<p>This produces the following result &minus;</p>
<pre class="result notranslate">
Hello there
</pre>
<h2>Procedure Parameters</h2>
<p>Till now you have seen procedure without a parameter. But there is a facility to pass different parameters while calling a procedure. These passed parameters can be captured inside the procedure and any manipulation can be done over those parameters.</p>
<p>A procedure can take multiple parameters separated by comma.</p>
<h3>Example</h3>
<p>Let us do a bit modification in our <i>sayHello</i> procedure. This time it takes two parameters &minus;</p>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui

procedure sayHello(sequence name,atom  age)
   printf(1, "%s is %d years old.", {name, age})
end procedure

-- Call above defined procedure.
sayHello("zara", 8)
</pre>
<p>This produces the following result &minus;</p>
<pre class="result notranslate">
zara is 8 years old.
</pre>
<h1>Euphoria - Functions</h1>
<p>Euphoria functions are just like procedures, but they return a value, and can be used in an expression. This chapter explains how to write your own functions in Euphoria.</p>
<h2>Function Definition</h2>
<p>Before we use a function we need to define it. The most common way to define a function in Euphoria is by using the <b>function</b> keyword, followed by a unique function name, a list of parameters (that might be empty), and a statement block which ends with <b>end function</b> statement. The basic syntax is shown here &minus;</p>
<pre class="prettyprint notranslate">
function functionname(parameter-list)

   statements
   ..........
   return [Euphoria Object]

end function
</pre>
<h3>Example</h3>
<p>A simple function called sayHello that takes no parameters is defined here &minus;</p>
<pre class="prettyprint notranslate">
function sayHello()
   puts(1, "Hello there")
   return 1
end function
</pre>
<h2>Calling a Function</h2>
<p>To invoke a function somewhere later in the script, you would simple need to write the name of that function as follows &minus;</p>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui

function sayHello()
   puts(1, "Hello there")
   return 1
end function

-- Call above defined function.
sayHello()
</pre>
<p>This produces the following result &minus;</p>
<pre class="result notranslate">
Hello there
</pre>
<h2>Function Parameters</h2>
<p>Till now we have seen function without a parameters. But there is a facility to pass different parameters while calling a function. These passed parameters can be captured inside the function and any manipulation can be done over those parameters.</p>
<p>A function can take multiple parameters separated by comma.</p>
<h3>Example</h3>
<p>Let us do a bit modification in our <i>sayHello</i> function. This time it takes two parameters &minus;</p>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui

function sayHello(sequence name,atom  age)
   printf(1, "%s is %d years old.", {name, age})
   return 1
end function

-- Call above defined function.
sayHello("zara", 8)
</pre>
<p>This produces the following result &minus;</p>
<pre class="result notranslate">
zara is 8 years old.
</pre>
<h2>The <i>return</i> Statement</h2>
<p>A Euphoria function must have <i>return</i> statement before closing statement <b>end function</b>. Any Euphoria object can be returned. You can, in effect, have multiple return values, by returning a sequence of objects. For example</p>
<pre class="prettyprint notranslate">
return {x_pos, y_pos}
</pre>
<p>If you have nothing to return, then simply return 1 or 0. The return value 1 indicates success and 0 indicates failure</p>
<h1>Euphoria - Files I/O</h1>
<p>Using Euphoria programming language, you can write programs that read and change file data on your floppy drive or hard drive, or create new files as a form of output. You can even access devices on your computer such as the printer and modem.</p>
<p>This chapter described all the basic I/O functions available in Euphoria. For information on more functions, please refer to standard Euphoria documentation.</p>
<h2>Displaying on the Screen</h2>
<p>The simplest way to produce output is using the <i>puts()</i> statement where you can pass any string to be displayed on the screen. There is another method <i>printf()</i> which can also be used in case you have to format a string using dynamic values.</p>
<p>These methods convert the expressions you pass them to a string and write the result to standard output as follows &minus;</p>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui
 
puts(1, "Euphoria is really a great language, isn't it?" )
</pre>
<p>This produces the following result on your standard screen &minus;</p>
<pre class="result notranslate">
Euphoria is really a great language, isn't it?
</pre>
<h2>Opening and Closing Files</h2>
<p>Euphoria provides basic methods necessary to manipulate files by default. You can do your most of the file manipulation using the following methods &minus;</p>
<ul class="list">
<li>open()</li>
<li>close()</li>
<li>printf()</li>
<li>gets()</li>
<li>getc()</li>
</ul>
<h2>The <i>open</i> Method</h2>
<p>Before you can read or write a file, you have to open it using Euphoria's built-in <i>open()</i>method. This function creates a file descriptor which is utilized to call other supporting methods associated with it.</p>
<h3>Syntax</h3>
<pre class="result notranslate">
integer file_num = open(file_name, access_mode)
</pre>
<p>Above method returns -1 in case there is an error in opening the given file name. Here are the parameters &minus;</p>
<ul class="list">
<li><p><b>file_name</b> &minus; The file_name argument is a string value that contains the name of the file that you want to access.</p></li>
<li><p><b>access_mode</b> &minus; The access_mode determines the mode in which the file has to be opened. For example, read, write append, etc. A complete list of possible values for file opening modes is given in the following table &minus;</p></li>
</ul>
<table class="table table-bordered">
<tr>
<th>S.No</th>
<th style="text-align:center;">Modes &amp; Description</th>
</tr>
<tr>
<td>1</td>
<td><p><b>r</b></p>
<p>Opens a text file for reading only. The file pointer is placed at the beginning of the file.</p></td>
</tr>
<tr>
<td>2</td>
<td><p><b>rb</b></p>
<p>Opens a file for reading only in binary format. The file pointer is placed at the beginning of the file.</p></td>
</tr>
<tr>
<td>3</td>
<td><p><b>w</b></p>
<p>Opens a text file for writing only. Overwrites the file if the file exists. If the file does not exist, creates a new file for writing.</p></td>
</tr>
<tr>
<td>4</td>
<td><p><b>wb</b></p>
<p>Opens a file for writing only in binary format. Overwrites the file if the file exists. If the file does not exist, creates a new file for writing.</p></td>
</tr>
<tr>
<td>5</td>
<td><p><b>u</b></p>
<p>Opens a file for both reading and writing. The file pointer is set at the beginning of the file.</p></td>
</tr>
<tr>
<td>6</td>
<td><p><b>ub</b></p>
<p>Opens a file for both reading and writing in binary format. The file pointer is placed at the beginning of the file.</p></td>
</tr>
<tr>
<td>7</td>
<td><p><b>a</b></p>
<p>Opens a file for appending. The file pointer is at the end of the file if the file exists (append mode). If the file does not exist, it creates a new file for writing.</p></td>
</tr> 
<tr>
<td>8</td>
<td><p><b>ab</b></p>
<p>Opens a file for appending in binary format. The file pointer is at the end of the file if the file exists (append mode). If the file does not exist, it creates a new file for writing.</p></td>
</tr> 
</table>
<h3>Example</h3>
<p>The following example creates a new text file in the current directory on your Linux system &minus;</p>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui

integer file_num
constant ERROR = 2
constant STDOUT = 1

file_num = open("myfile,txt", "w")

if file_num = -1 then
   puts(ERROR, "couldn't open myfile\n")
else
   puts(STDOUT, "File opend successfully\n")
end if
</pre>
<p>If file opens successfully, then it "myfile.txt" is created in your current directory and produces the following result &minus;</p>
<pre class="result notranslate">
File opend successfully
</pre>
<h2>The <i>close()</i> Method</h2>
<p>The close() method flushes any unwritten information and closes the file, after which no more reading or writing can be done on the file.</p>
<p>Euphoria automatically closes a file when the reference object of a file is reassigned to another file. It is a good practice to use the close() method to close a file.</p>
<h3>Syntax</h3>
<pre class="result notranslate">
close( file_num );
</pre>
<p>Here the file descriptor received while opening a file is passed as a parameter.</p>
<h3>Example</h3>
<p>The following example creates a file as above and then closes it before existing the program &minus;</p>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui

integer file_num
constant ERROR = 2
constant STDOUT = 1

file_num = open("myfile.txt", "w")

if file_num = -1 then
   puts(ERROR, "couldn't open myfile\n")
else
   puts(STDOUT, "File opend successfully\n")
end if

if file_num = -1 then
   puts(ERROR, "No need to close the file\n")
else
   close( file_num )
   puts(STDOUT, "File closed successfully\n")
end if
</pre>
<p>This produces the following result &minus;</p>
<pre class="result notranslate">
File opend successfully
File closed successfully
</pre>
<h2>Reading and Writing Files</h2>
<p>Euphoria provides a set of access methods to make our lives easier while reading or writing a file either in text mode or binary mode. Let us see how to use <i>printf()</i> and <i>gets()</i> methods to read and write files.</p>
<h2>The <i>printf()</i> Method</h2>
<p>The <i>printf()</i> method writes any string to an open file.</p>
<h3>Syntax</h3>
<pre class="result notranslate">
printf(fn, st, x) 
</pre>
<p>Here are the parameters &minus;</p>
<ul class="list">
<li><p><b>fn</b> &minus; File descriptor received from open() method.</p></li>
<li><p><b>st</b> &minus; Format string where decimal or atom is formatted using %d and string or sequence is formatted using %s.</p></li>
<li><p><b>x</b> &minus; If x is a sequence, then format specifiers from st are matched with corresponding elements of x. If x is an atom, then normally st contains just one format specifier and it is applied to x. However; if st contains multiple format specifiers, then each one is applied to the same value x.</p></li>
</ul>
<h3>Example</h3>
<p>The following example opens a file and writes the name and age of a person in this file &minus;</p>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui

integer file_num
constant ERROR = 2
constant STDOUT = 1

file_num = open("myfile.txt", "w")

if file_num = -1 then
   puts(ERROR, "couldn't open myfile\n")
else
   puts(STDOUT, "File opend successfully\n")
end if

printf(file_num, "My name is %s and age is %d\n", {"Zara", 8})

if file_num = -1 then
   puts(ERROR, "No need to close the file\n")
else
   close( file_num )
   puts(STDOUT, "File closed successfully\n")
end if
</pre>
<p>The above example creates <i>myfile.txt</i> file. Is writes given content in that file and finally closes. If you open this file, it would have the following content &minus;</p>
<pre class="result notranslate">
My name is Zara and age is 8
</pre>
<h2>The <i>gets()</i> Method</h2>
<p>The <i>gets()</i> method reads a string from an open file.</p>
<h3>Syntax</h3>
<pre class="result notranslate">
gets(file_num)
</pre>
<p>Here passed parameter is file description return by the <i>opend()</i> method. This method starts reading from the beginning of the file line by line. The characters have values from 0 to 255. The atom -1 is returned on end of file.</p>
<h3>Example</h3>
<p>Let us take a file <i>myfile.txt</i> which is already created.</p>
<pre class="prettyprint notranslate">
#!/home/euphoria-4.0b2/bin/eui

integer file_num
object line

constant ERROR = 2
constant STDOUT = 1

file_num = open("myfile.txt", "r")
if file_num = -1 then
   puts(ERROR, "couldn't open myfile\n")
else
   puts(STDOUT, "File opend successfully\n")
end if

line = gets(file_num)
printf( STDOUT, "Read content : %s\n", {line})

if file_num = -1 then
   puts(ERROR, "No need to close the file\n")
else
   close( file_num )
   puts(STDOUT, "File closed successfully\n")
end if
</pre>
<p>This produces the following result &minus;</p>
<pre class="result notranslate">
File opend successfully
Read content : My name is Zara and age is 8

File closed successfully
</pre>

<title>Euphoria Library Routines</title>

<h1>Euphoria - Library Routines</h1>

<p>A large number of library routines are provided. Some are built right into the interpreter, <b>ex.exe, exw.exe or exu</b>. Others are written in Euphoria and you must include one of the .e files in <b>euphoria\include</b> directory to use them.</p>

<p>To indicate what kind of object may be passed in and returned, the following prefixes are used &minus;</p>

<p><b>x</b></p>

<p>a general object (atom or sequence)</p>

<p><b>s</b></p>

<p>a sequence</p>

<p><b>a</b></p>

<p>an atom</p>

<p><b>i</b></p>

<p>an integer</p>

<p><b>fn</b></p>

<p>an integer used as a file number</p>

<p><b>st</b></p>

<p>a string sequence, or single-character atom</p>

<h2>Predefined Types</h2>

<p>As well as declaring variables with these types, you can also call them just like ordinary functions, in order to test if a value is a certain type.</p>

<h2>Sequence Manipulation</h2>

<h2>Searching and Sorting</h2>

<h2>Pattern Matching</h2>

<h2>Math</h2>

<p>These routines can be applied to individual atoms or to sequences of values.</p>

<h2>Bitwise Logical Operations</h2>

<p>These routines treat numbers as collections of binary bits, and logical operations are performed on corresponding  bits in the binary representation of the numbers.</p>

<p>There are no routines for shifting bits left or right, but you can  achieve the same effect by multiplying or dividing by powers of 2.</p>

<h2>File and Device I/O</h2>

<p>To do input or output on a file or device you must first open the file or device, then use the routines below to read or write to it, then close the file or device. <a rel="nofollow" target="_blank" href="http://www.rapideuphoria.com/lib_h_o.htm#open">open()</a> will give you  a file number to use as the first argument of the other I/O routines. Certain files/devices are opened for you automatically (as text files) &minus;</p>

<h2>Mouse Support (DOS32 and Linux)</h2>

<p>On Windows XP, if you want the DOS mouse to work in a (non-full-screen) window, you must disable QuickEdit mode in the Properties for the DOS Window.</p>

<h2>Operating System</h2>

<h2>Special Machine-Dependent Routines</h2>

<h2>Debugging</h2>

<h2>Graphics &amp; Sound</h2>

<p>The following routines let you display information on the screen. In DOS, the PC screen can be placed into one of many graphics modes.</p>

<p>The following routines work in all text and pixel-graphics modes.</p>

<p>The following routines work in text in modes only</p>

<p>The following routines work in pixel-graphics modes only (DOS32)</p>

<h2>Multitasking</h2>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Euphoria Useful Resources</title>

<h1>Euphoria - Useful Resources</h1>

<p>The following resources contain additional information on Euphoria. Please use them to get more in-depth knowledge on this topic.</p>

<h2>Useful Links on Euphoria</h2>

<p><a target="_blank" rel="nofollow" href="http://www.rapideuphoria.com/index.html">Euphoria</a> &minus; Official website for Euphoria. Learn about the Euphoria language and discover the latest happenings in Euphoria arena.</p>

<p><a target="_blank" rel="nofollow" href="http://sourceforge.net/projects/rapideuphoria/files/">Euphoria Download page</a> &minus; Download latest version of Euphoria from sourceforge.</p>

<p><a target="_blank" rel="nofollow" href="http://en.wikipedia.org/wiki/Euphoria_(programming_language)">Euphoria @ Wiki</a> &minus; Euphoria at Wikipedia, the free encyclopedia</p>

<p><a target="_blank" rel="nofollow" href="http://openeuphoria.org/">OpenEuphoria.org</a> &minus; Latest news about Euphoria, Community and much more....</p>

<h2>Useful Books on Euphoria</h2>

<p>To enlist your site on this page, please drop an email to <b>contact@tutorialspoint.com</b></p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Discuss Euphoria</title>

<h1>Discuss Euphoria</h1>

<p>This tutorial gives you basic understanding of Euphoria programming language. Euphoria is simple, flexible, easy to learn, and interpreted high-level programming language for DOS, Windows, Linux, FreeBSD, and more. This tutorial describes everything a programmer needs to know such as its environment, data types, syntax and operators, file handling, and controlling the flow of program.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

</body></html>