<!DOCTYPE html><html><body><title>Data Structure and Algorithms (DSA) Tutorial</title>

<h1>Data Structure and Algorithms Tutorial</h1>

<p>Data Structures are the programmatic way of storing data so that data can be used efficiently. Almost every enterprise application uses various types of data structures in one or the other way. This tutorial will give you a great understanding on Data Structures needed to understand the complexity of enterprise level applications and need of algorithms, and data structures.</p>

<h1>Audience</h1>

<p>This tutorial is designed for Computer Science graduates as well as Software Professionals who are willing to learn data structures and algorithm programming in simple and easy steps.</p>

<p>After completing this tutorial you will be at intermediate level of expertise from where you can take yourself to higher level of expertise.</p>

<h1>Prerequisites</h1>

<p>Before proceeding with this tutorial, you should have a basic understanding of C programming language, text editor, and execution of programs, etc.</p>

<h1>Compile and Execute C Online</h1>

<p>For most of the examples given in this tutorial you will find <b>Try it</b> option, so just make use of this option to execute your programs on the spot and enjoy your learning.</p>

<p>Try the following example using the Try it option available at the top right corner of the following sample code box &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate tryit">
#include &lt;stdio.h&gt;

int main(){
   /* My first program in C */
   printf("Hello, World! \n");
   
   return 0;
}
</pre>

<title>Data Structures and Algorithms Overview</title>

<h1>Data Structures &amp; Algorithms - Overview</h1>

<p>Data Structure is a systematic way to organize data in order to use it efficiently. Following terms are the foundation terms of a data structure.</p>

<p><b>Interface</b> &minus; Each data structure has an interface. Interface represents the set of operations that a data structure supports. An interface only provides the list of supported operations, type of parameters they can accept and return type of these operations.</p>

<p><b>Implementation</b> &minus; Implementation provides the internal representation of a data structure. Implementation also provides the definition of the algorithms used in the operations of the data structure.</p>

<h2>Characteristics of a Data Structure</h2>

<p><b>Correctness</b> &minus; Data structure implementation should implement its interface correctly.</p>

<p><b>Time Complexity</b> &minus; Running time or the execution time of operations of data structure must be as small as possible.</p>

<p><b>Space Complexity</b> &minus; Memory usage of a data structure operation should be as little as possible.</p>

<h2>Need for Data Structure</h2>

<p>As applications are getting complex and data rich, there are three common problems that applications face now-a-days.</p>

<p><b>Data Search</b> &minus; Consider an inventory of 1 million(10<sup>6</sup>) items of a store. If the application is to search an item, it has to search an item in 1 million(10<sup>6</sup>) items every time slowing down the search. As data grows, search will become slower.</p>

<p><b>Processor speed</b> &minus; Processor speed although being very high, falls limited if the data grows to billion records.</p>

<p><b>Multiple requests</b> &minus; As thousands of users can search data simultaneously on a web server, even the fast server fails while searching the data.</p>

<p>To solve the above-mentioned problems, data structures come to rescue. Data can be organized in a data structure in such a way that all items may not be required to be searched, and the required data can be searched almost instantly.</p>

<h2>Execution Time Cases</h2>

<p>There are three cases which are usually used to compare various data structure's execution time in a relative manner.</p>

<p><b>Worst Case</b> &minus; This is the scenario where a particular data structure operation takes maximum time it can take. If an operation's worst case time is &#402;(n) then this operation will not take more than &#402;(n) time where &#402;(n) represents function of n.</p>

<p><b>Average Case</b> &minus; This is the scenario depicting the average execution time of an operation of a data structure. If an operation takes &#402;(n) time in execution, then m operations will take m&#402;(n) time.</p>

<p><b>Best Case</b> &minus; This is the scenario depicting the least possible execution time of an operation of a data structure. If an operation takes &#402;(n) time in execution, then the actual operation may take time as the random number which would be maximum as &#402;(n).</p>

<h2>Basic Terminology</h2>

<p><b>Data</b> &minus; Data are values or set of values.</p>

<p><b>Data Item</b> &minus; Data item refers to single unit of values.</p>

<p><b>Group Items</b> &minus; Data items that are divided into sub items are called as Group Items.</p>

<p><b>Elementary Items</b> &minus; Data items that cannot be divided are called as Elementary Items.</p>

<p><b>Attribute and Entity</b> &minus; An entity is that which contains certain attributes or properties, which may be assigned values.</p>

<p><b>Entity Set</b> &minus; Entities of similar attributes form an entity set.</p>

<p><b>Field</b> &minus; Field is a single elementary unit of information representing an attribute of an entity.</p>

<p><b>Record</b> &minus; Record is a collection of field values of a given entity.</p>

<p><b>File</b> &minus; File is a collection of records of the entities in a given entity set.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Data Structures Environment Setup</title>

<h1>Data Structures - Environment Setup</h1>

<h2>Try it Option Online</h2>

<p>You really do not need to set up your own environment to start learning C programming language. Reason is very simple, we already have set up C Programming environment online, so that you can compile and execute all the available examples online at the same time when you are doing your theory work. This gives you confidence in what you are reading and to check the result with different options. Feel free to modify any example and execute it online.</p>

<p>Try the following example using our online compiler available at <a href="http://www.tutorialspoint.com/codingground.htm">CodingGround</a></p>

<p>For most of the examples given in this tutorial, you will find a Try it option in our website code sections at the top right corner that will take you to the online compiler. So just make use of it and enjoy your learning.</p>

<h2>Local Environment Setup</h2>

<p>If you are still willing to set up your environment for C programming language, you need the following two tools available on your computer, (a) Text Editor and (b) The C Compiler.</p>

<h3>Text Editor</h3>

<p>This will be used to type your program. Examples of few editors include Windows Notepad, OS Edit command, Brief, Epsilon, EMACS, and vim or vi.</p>

<p>The name and the version of the text editor can vary on different operating systems. For example, Notepad will be used on Windows, and vim or vi can be used on Windows as well as Linux or UNIX.</p>

<p>The files you create with your editor are called source files and contain program source code. The source files for C programs are typically named with the extension "<b>.c</b>".</p>

<p>Before starting your programming, make sure you have one text editor in place and you have enough experience to write a computer program, save it in a file, compile it, and finally execute it.</p>

<h3>The C Compiler</h3>

<p>The source code written in the source file is the human readable source for your program. It needs to be "compiled", to turn into machine language so that your CPU can actually execute the program as per the given instructions.</p>

<p>This C programming language compiler will be used to compile your source code into a final executable program. We assume you have the basic knowledge about a programming language compiler.</p>

<p>Most frequently used and free available compiler is GNU C/C&plus;&plus; compiler. Otherwise, you can have compilers either from HP or Solaris if you have respective Operating Systems (OS).</p>

<p>The following section guides you on how to install GNU C/C&plus;&plus; compiler on various OS. We are mentioning C/C&plus;&plus; together because GNU GCC compiler works for both C and C&plus;&plus; programming languages.</p>

<h2>Installation on UNIX/Linux</h2>

<p>If you are using <b>Linux or UNIX</b>, then check whether GCC is installed on your system by entering the following command from the command line &minus;</p>

<p>If you have GNU compiler installed on your machine, then it should print a message such as the following &minus;</p>

<p>If GCC is not installed, then you will have to install it yourself using the detailed instructions available at <a href="https://gcc.gnu.org/install/" rel="nofollow" target="_blank">https://gcc.gnu.org/install/</a></p>

<p>This tutorial has been written based on Linux and all the given examples have been compiled on Cent OS flavor of Linux system.</p>

<h2>Installation on Mac OS</h2>

<p>If you use Mac OS X, the easiest way to obtain GCC is to download the Xcode development environment from Apple's website and follow the simple installation instructions. Once you have Xcode setup, you will be able to use GNU compiler for C/C&plus;&plus;.</p>

<p>Xcode is currently available at <a href="https://developer.apple.com/technologies/tools/" rel="nofollow" target="_blank">developer.apple.com/technologies/tools/</a></p>

<h2>Installation on Windows</h2>

<p>To install GCC on Windows, you need to install MinGW. To install MinGW, go to the MinGW homepage, <a href="http://www.mingw.org" rel="nofollow" target="_blank"> www.mingw.org</a>, and follow the link to the MinGW download page. Download the latest version of the MinGW installation program, which should be named MinGW-&lt;version&gt;.exe.</p>

<p>While installing MinWG, at a minimum, you must install gcc-core, gcc-g&plus;&plus;, binutils, and the MinGW runtime, but you may wish to install more.</p>

<p>Add the bin subdirectory of your MinGW installation to your <b>PATH</b> environment variable, so that you can specify these tools on the command line by their simple names.</p>

<p>When the installation is complete, you will be able to run gcc, g&plus;&plus;, ar, ranlib, dlltool, and several other GNU tools from the Windows command line.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate tryit">
#include &lt;stdio.h&gt;

int main(){
   /* My first program in C */
   printf("Hello, World! \n");
   
   return 0;
}
</pre>
<p>For most of the examples given in this tutorial, you will find a Try it option in our website code sections at the top right corner that will take you to the online compiler. So just make use of it and enjoy your learning.</p>
</blockquote>
<h2>Local Environment Setup</h2>
<p>If you are still willing to set up your environment for C programming language, you need the following two tools available on your computer, (a) Text Editor and (b) The C Compiler.</p>
<h3>Text Editor</h3>
<p>This will be used to type your program. Examples of few editors include Windows Notepad, OS Edit command, Brief, Epsilon, EMACS, and vim or vi.</p>
<p>The name and the version of the text editor can vary on different operating systems. For example, Notepad will be used on Windows, and vim or vi can be used on Windows as well as Linux or UNIX.</p>
<p>The files you create with your editor are called source files and contain program source code. The source files for C programs are typically named with the extension "<b>.c</b>".</p>
<p>Before starting your programming, make sure you have one text editor in place and you have enough experience to write a computer program, save it in a file, compile it, and finally execute it.</p>
<h3>The C Compiler</h3>
<p>The source code written in the source file is the human readable source for your program. It needs to be "compiled", to turn into machine language so that your CPU can actually execute the program as per the given instructions.</p>
<p>This C programming language compiler will be used to compile your source code into a final executable program. We assume you have the basic knowledge about a programming language compiler.</p>
<p>Most frequently used and free available compiler is GNU C/C&plus;&plus; compiler. Otherwise, you can have compilers either from HP or Solaris if you have respective Operating Systems (OS).</p>
<p>The following section guides you on how to install GNU C/C&plus;&plus; compiler on various OS. We are mentioning C/C&plus;&plus; together because GNU GCC compiler works for both C and C&plus;&plus; programming languages.</p>
<h2>Installation on UNIX/Linux</h2>
<p>If you are using <b>Linux or UNIX</b>, then check whether GCC is installed on your system by entering the following command from the command line &minus;</p>
<pre class="result notranslate">
$ gcc -v
</pre>
<p>If you have GNU compiler installed on your machine, then it should print a message such as the following &minus;</p>
<pre class="result notranslate">
Using built-in specs.
Target: i386-redhat-linux
Configured with: ../configure --prefix = /usr .......
Thread model: posix
gcc version 4.1.2 20080704 (Red Hat 4.1.2-46)
</pre>

<title>Data Structures Algorithms Basics</title>

<h1>Data Structures - Algorithms Basics</h1>

<p>Algorithm is a step-by-step procedure, which defines a set of instructions to be executed in a certain order to get the desired output. Algorithms are generally created independent of underlying languages, i.e. an algorithm can be implemented in more than one programming language.</p>

<p>From the data structure point of view, following are some important categories of algorithms &minus;</p>

<p><b>Search</b> &minus; Algorithm to search an item in a data structure.</p>

<p><b>Sort</b> &minus; Algorithm to sort items in a certain order.</p>

<p><b>Insert</b> &minus; Algorithm to insert item in a data structure.</p>

<p><b>Update</b> &minus;  Algorithm to update an existing item in a data structure.</p>

<p><b>Delete</b> &minus; Algorithm to delete an existing item from a data structure.</p>

<h2>Characteristics of an Algorithm</h2>

<p>Not all procedures can be called an algorithm. An algorithm should have the following characteristics &minus;</p>

<p><b>Unambiguous</b> &minus; Algorithm should be clear and unambiguous. Each of its steps (or phases), and their inputs/outputs should be clear and must lead to only one meaning.</p>

<p><b>Input</b> &minus; An algorithm should have 0 or more well-defined inputs.</p>

<p><b>Output</b> &minus; An algorithm should have 1 or more well-defined outputs, and should match the desired output.</p>

<p><b>Finiteness</b> &minus; Algorithms must terminate after a finite number of steps.</p>

<p><b>Feasibility</b> &minus; Should be feasible with the available resources.</p>

<p><b>Independent</b> &minus; An algorithm should have step-by-step directions, which should be independent of any programming code.</p>

<h2>How to Write an Algorithm?</h2>

<p>There are no well-defined standards for writing algorithms. Rather, it is problem and resource dependent. Algorithms are never written to support a particular programming code.</p>

<p>As we know that all programming languages share basic code constructs like loops (do, for, while), flow-control (if-else), etc. These common constructs can be used to write an algorithm.</p>

<p>We write algorithms in a step-by-step manner, but it is not always the case. Algorithm writing is a process and is executed after the problem domain is well-defined. That is, we should know the problem domain, for which we are designing a solution.</p>

<h3>Example</h3>

<p>Let's try to learn algorithm-writing by using an example.</p>

<p><b>Problem</b> &minus; Design an algorithm to add two numbers and display the result.</p>

<p>Algorithms tell the programmers how to code the program. Alternatively, the algorithm can be written as &minus;</p>

<p>In design and analysis of algorithms, usually the second method is used to describe an algorithm. It makes it easy for the analyst to analyze the algorithm ignoring all unwanted definitions. He can observe what operations are being used and how the process is flowing.</p>

<p>Writing <b>step numbers</b>, is optional.</p>

<p>We design an algorithm to get a solution of a given problem. A problem can be solved in more than one ways.</p>

<p>Hence, many solution algorithms can be derived for a given problem. The next step is to analyze those proposed solution algorithms and implement the best suitable solution.</p>

<h2>Algorithm Analysis</h2>

<p>Efficiency of an algorithm can be analyzed at two different stages, before implementation and after implementation. They are the following &minus;</p>

<p><b>A Priori Analysis</b> &minus; This is a theoretical analysis of an algorithm. Efficiency of an algorithm is measured by assuming that all other factors, for example, processor speed, are constant and have no effect on the implementation.</p>

<p><b>A Posterior Analysis</b> &minus; This is an empirical analysis of an algorithm. The selected algorithm is implemented using programming language. This is then executed on target computer machine. In this analysis, actual statistics like running time and space required, are collected.</p>

<p>We shall learn about a priori algorithm analysis. Algorithm analysis deals with the execution or running time of various operations involved. The running time of an operation can be defined as the number of computer instructions executed per operation.</p>

<h2>Algorithm Complexity</h2>

<p>Suppose <b>X</b> is an algorithm and <b>n</b> is the size of input data, the time and space used by the algorithm X are the two main factors, which decide the efficiency of X.</p>

<p><b>Time Factor</b> &minus; Time is measured by counting the number of key operations such as comparisons in the sorting algorithm.</p>

<p><b>Space Factor</b> &minus; Space is measured by counting the maximum memory space required by the algorithm.</p>

<p>The complexity of an algorithm <b>f(n)</b> gives the running time and/or the storage space required by the algorithm in terms of <b>n</b> as the size of input data.</p>

<h2>Space Complexity</h2>

<p>Space complexity of an algorithm represents the amount of memory space required by the algorithm in its life cycle. The space required by an algorithm is equal to the sum of the following two components &minus;</p>

<p>A fixed part that is a space required to store certain data and variables, that are independent of the size of the problem. For example, simple variables and constants used, program size, etc.</p>

<p>A variable part is a space required by variables, whose size depends on the size of the problem. For example, dynamic memory allocation, recursion stack space, etc.</p>

<p>Space complexity S(P) of any algorithm P is S(P) = C &plus; SP(I), where C is the fixed part and S(I) is the variable part of the algorithm, which depends on instance characteristic I. Following is a simple example that tries to explain the concept &minus;</p>

<p>Here we have three variables A, B, and C and one constant. Hence S(P) = 1 &plus; 3. Now, space depends on data types of given variables and constant types and it will be multiplied accordingly.</p>

<h2>Time Complexity</h2>

<p>Time complexity of an algorithm represents the amount of time required by the algorithm to run to completion. Time requirements can be defined as a numerical function T(n), where T(n) can be measured as the number of steps, provided each step consumes constant time.</p>

<p>For example, addition of two n-bit integers takes <b>n</b> steps. Consequently, the total computational time is T(n) = c &lowast; n, where c is the time taken for the addition of two bits. Here, we observe that T(n) grows linearly as the input size increases.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
<b>step 1</b> &minus; START
<b>step 2</b> &minus; declare three integers <b>a</b>, <b>b</b> &amp; <b>c</b>
<b>step 3</b> &minus; define values of <b>a</b> &amp; <b>b</b>
<b>step 4</b> &minus; add values of <b>a</b> &amp; <b>b</b>
<b>step 5</b> &minus; store output of <u>step 4</u> to <b>c</b>
<b>step 6</b> &minus; print <b>c</b>
<b>step 7</b> &minus; STOP
</pre>
<p>Algorithms tell the programmers how to code the program. Alternatively, the algorithm can be written as &minus;</p>
<pre class="result notranslate">
<b>step 1</b> &minus; START ADD
<b>step 2</b> &minus; get values of <b>a</b> &amp; <b>b</b>
<b>step 3</b> &minus; c &larr; a &plus; b
<b>step 4</b> &minus; display c
<b>step 5</b> &minus; STOP
</pre>
<p>In design and analysis of algorithms, usually the second method is used to describe an algorithm. It makes it easy for the analyst to analyze the algorithm ignoring all unwanted definitions. He can observe what operations are being used and how the process is flowing.</p>
<p>Writing <b>step numbers</b>, is optional.</p>
<p>We design an algorithm to get a solution of a given problem. A problem can be solved in more than one ways.</p>
<img src="/data_structures_algorithms/images/problem_solutions.jpg" alt="one problem many solutions" />
<p>Hence, many solution algorithms can be derived for a given problem. The next step is to analyze those proposed solution algorithms and implement the best suitable solution.</p>
<h2>Algorithm Analysis</h2>
<p>Efficiency of an algorithm can be analyzed at two different stages, before implementation and after implementation. They are the following &minus;</p>
<ul class="list">
<li><p><b>A Priori Analysis</b> &minus; This is a theoretical analysis of an algorithm. Efficiency of an algorithm is measured by assuming that all other factors, for example, processor speed, are constant and have no effect on the implementation.</p></li>
<li><p><b>A Posterior Analysis</b> &minus; This is an empirical analysis of an algorithm. The selected algorithm is implemented using programming language. This is then executed on target computer machine. In this analysis, actual statistics like running time and space required, are collected.</p></li>
</ul>
<p>We shall learn about a priori algorithm analysis. Algorithm analysis deals with the execution or running time of various operations involved. The running time of an operation can be defined as the number of computer instructions executed per operation.</p>
<h2>Algorithm Complexity</h2>
<p>Suppose <b>X</b> is an algorithm and <b>n</b> is the size of input data, the time and space used by the algorithm X are the two main factors, which decide the efficiency of X.</p>
<ul class="list">
<li><p><b>Time Factor</b> &minus; Time is measured by counting the number of key operations such as comparisons in the sorting algorithm.</p></li>
<li><p><b>Space Factor</b> &minus; Space is measured by counting the maximum memory space required by the algorithm.</p></li>
</ul>
<p>The complexity of an algorithm <b>f(n)</b> gives the running time and/or the storage space required by the algorithm in terms of <b>n</b> as the size of input data.</p>
<h2>Space Complexity</h2>
<p>Space complexity of an algorithm represents the amount of memory space required by the algorithm in its life cycle. The space required by an algorithm is equal to the sum of the following two components &minus;</p>
<ul class="list">
<li><p>A fixed part that is a space required to store certain data and variables, that are independent of the size of the problem. For example, simple variables and constants used, program size, etc.</p></li>
<li><p>A variable part is a space required by variables, whose size depends on the size of the problem. For example, dynamic memory allocation, recursion stack space, etc.</p></li>
</ul>
<p>Space complexity S(P) of any algorithm P is S(P) = C &plus; SP(I), where C is the fixed part and S(I) is the variable part of the algorithm, which depends on instance characteristic I. Following is a simple example that tries to explain the concept &minus;</p>
<pre class="result notranslate">
Algorithm: SUM(A, B)
Step 1 -  START
Step 2 -  C &larr; A &plus; B &plus; 10
Step 3 -  Stop
</pre>

<title>Data Structures Asymptotic Analysis</title>

<h1>Data Structures - Asymptotic Analysis</h1>

<p>Asymptotic analysis of an algorithm refers to defining the mathematical boundation/framing of its run-time performance. Using asymptotic analysis, we can very well conclude the best case, average case, and worst case scenario of an algorithm.</p>

<p>Asymptotic analysis is input bound i.e., if there's no input to the algorithm, it is concluded to work in a constant time. Other than the "input" all other factors are considered constant.</p>

<p>Asymptotic analysis refers to computing the running time of any operation in mathematical units of computation. For example, the running time of one operation is computed as <i>f</i>(n) and may be for another operation it is computed as <i>g</i>(n<sup>2</sup>). This means the first operation running time will increase linearly with the increase in <b>n</b> and the running time of the second operation will increase exponentially when <b>n</b> increases. Similarly, the running time of both operations will be nearly the same if <b>n</b> is significantly small.</p>

<p>Usually, the time required by an algorithm falls under three types &minus;</p>

<p><b>Best Case</b> &minus; Minimum time required for program execution.</p>

<p><b>Average Case</b> &minus; Average time required for program execution.</p>

<p><b>Worst Case</b> &minus; Maximum time required for program execution.</p>

<h2>Asymptotic Notations</h2>

<p>Following are the commonly used asymptotic notations to calculate the running time complexity of an algorithm.</p>

<h3>Big Oh Notation, &Omicron;</h3>

<p>The notation &Omicron;(n) is the formal way to express the upper bound of an algorithm's running time. It measures the worst case time complexity or the longest amount of time an algorithm can possibly take to complete.</p>

<p>For example, for a function <b><i>f</i>(n)</b></p>

<h3>Omega Notation, &Omega;</h3>

<p>The notation &Omega;(n) is the formal way to express the lower bound of an algorithm's running time. It measures the best case time complexity or the best amount of time an algorithm can possibly take to complete.</p>

<p>For example, for a function <b><i>f</i>(n)</b></p>

<h3>Theta Notation, &theta;</h3>

<p>The notation &theta;(n) is the formal way to express both the lower bound and the upper bound of an algorithm's running time. It is represented as follows &minus;</p>

<h2>Common Asymptotic Notations</h2>

<p>Following is a list of some common asymptotic notations &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
&Omicron;(<i>f</i>(n)) = { <i>g</i>(n) : there exists c &gt; 0 and n<sub>0</sub> such that <i>f</i>(n) &le; c.<i>g</i>(n) for all n &gt; n<sub>0</sub>. }
</pre>
<h3>Omega Notation, &Omega;</h3>
<p>The notation &Omega;(n) is the formal way to express the lower bound of an algorithm's running time. It measures the best case time complexity or the best amount of time an algorithm can possibly take to complete.</p>
<img src="/data_structures_algorithms/images/omega_notation.jpg" alt="Omega Notation" />
<p>For example, for a function <b><i>f</i>(n)</b></p>
<pre class="result notranslate">
&Omega;(<i>f</i>(n)) &ge; { <i>g</i>(n) : there exists c &gt; 0 and n<sub>0</sub> such that <i>g</i>(n) &le; c.<i>f</i>(n) for all n &gt; n<sub>0</sub>. }
</pre>
<h3>Theta Notation, &theta;</h3>
<p>The notation &theta;(n) is the formal way to express both the lower bound and the upper bound of an algorithm's running time. It is represented as follows &minus;</p>
<img src="/data_structures_algorithms/images/theta_notation.jpg" alt="Theta Notation" />
<pre class="result notranslate">
&theta;(<i>f</i>(n)) = { <i>g</i>(n) if and only if <i>g</i>(n) =  &Omicron;(<i>f</i>(n)) and <i>g</i>(n) = &Omega;(<i>f</i>(n)) for all n &gt; n<sub>0</sub>. }
</pre>

<title>Data Structures Greedy Algorithms</title>

<h1>Data Structures - Greedy Algorithms</h1>

<p>An algorithm is designed to achieve optimum solution for a given problem. In greedy algorithm approach, decisions are made from the given solution domain. As being greedy, the closest solution that seems to provide an optimum solution is chosen.</p>

<p>Greedy algorithms try to find a localized optimum solution, which may eventually lead to globally optimized solutions. However, generally greedy algorithms do not provide globally optimized solutions.</p>

<h2>Counting Coins</h2>

<p>This problem is to count to a desired value by choosing the least possible coins and the greedy approach forces the algorithm to pick the largest possible coin. If we are provided coins of &#8377; 1, 2, 5 and 10 and we are asked to count &#8377; 18 then the greedy procedure will be &minus;</p>

<p><b>1</b> &minus; Select one &#8377; 10 coin, the remaining count is 8</p>

<p><b>2</b> &minus; Then select one &#8377; 5 coin, the remaining count is 3</p>

<p><b>3</b> &minus; Then select one &#8377; 2 coin, the remaining count is 1</p>

<p><b>4</b> &minus; And finally, the selection of one &#8377; 1 coins solves the problem</p>

<p>Though, it seems to be working fine, for this count we need to pick only 4 coins. But if we slightly change the problem then the same approach may not be able to produce the same optimum result.</p>

<p>For the currency system, where we have coins of 1, 7, 10 value, counting coins for value 18 will be absolutely optimum but for count like 15, it may use more coins than necessary. For example, the greedy approach will use 10 &plus; 1 &plus; 1 &plus; 1 &plus; 1 &plus; 1, total 6 coins. Whereas the same problem could be solved by using only 3 coins (7 &plus; 7 &plus; 1)</p>

<p>Hence, we may conclude that the greedy approach picks an immediate optimized solution and may fail where global optimization is a major concern.</p>

<h3>Examples</h3>

<p>Most networking algorithms use the greedy approach. Here is a list of few of them &minus;</p>

<p>There are lots of similar problems that uses the greedy approach to find an optimum solution.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Data Structures Divide and Conquer</title>

<h1>Data Structures - Divide and Conquer</h1>

<p>In divide and conquer approach, the problem in hand, is divided into smaller sub-problems and then each problem is solved independently. When we keep on dividing the subproblems into even smaller sub-problems, we may eventually reach a stage where no more division is possible. Those "atomic" smallest possible sub-problem (fractions) are solved. The solution of all sub-problems is finally merged in order to obtain the solution of an original problem.</p>

<p>Broadly, we can understand <b>divide-and-conquer</b> approach in a three-step process.</p>

<h2>Divide/Break</h2>

<p>This step involves breaking the problem into smaller sub-problems. Sub-problems should represent a part of the original problem. This step generally takes a recursive approach to divide the problem until no sub-problem is further divisible. At this stage, sub-problems become atomic in nature but still represent some part of the actual problem.</p>

<h2>Conquer/Solve</h2>

<p>This step receives a lot of smaller sub-problems to be solved. Generally, at this level, the problems are considered 'solved' on their own.</p>

<h2>Merge/Combine</h2>

<p>When the smaller sub-problems are solved, this stage recursively combines them until they formulate a solution of the original problem. This algorithmic approach works recursively and conquer & merge steps works so close that they appear as one.</p>

<h3>Examples</h3>

<p>The following computer algorithms are based on <b>divide-and-conquer</b> programming approach &minus;</p>

<p>There are various ways available to solve any computer problem, but the mentioned are a good example of divide and conquer approach.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Data Structures Dynamic Programming</title>

<h1>Data Structures - Dynamic Programming</h1>

<p>Dynamic programming approach is similar to divide and conquer in breaking down the problem into smaller and yet smaller possible sub-problems. But unlike, divide and conquer, these sub-problems are not solved independently. Rather, results of these smaller sub-problems are remembered and used for similar or overlapping sub-problems.</p>

<p>Dynamic programming is used where we have problems, which can be divided into similar sub-problems, so that their results can be re-used. Mostly, these algorithms are used for optimization. Before solving the in-hand sub-problem, dynamic algorithm will try to examine the results of the previously solved sub-problems. The solutions of sub-problems are combined in order to achieve the best solution.</p>

<p>So we can say that &minus;</p>

<p>The problem should be able to be divided into smaller overlapping sub-problem.</p>

<p>An optimum solution can be achieved by using an optimum solution of smaller sub-problems.</p>

<p>Dynamic algorithms use memorization.</p>

<h2>Comparison</h2>

<p>In contrast to greedy algorithms, where local optimization is addressed, dynamic algorithms are motivated for an overall optimization of the problem.</p>

<p>In contrast to divide and conquer algorithms, where solutions are combined to achieve an overall solution, dynamic algorithms use the output of a smaller sub-problem and then try to optimize a bigger sub-problem. Dynamic algorithms use memorization to remember the output of already solved sub-problems.</p>

<h3>Example</h3>

<p>The following computer problems can be solved using dynamic programming approach &minus;</p>

<p>Dynamic programming can be used in both top-down and bottom-up manner. And of course, most of the times, referring to the previous solution output is cheaper than recomputing in terms of CPU cycles.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Data Structures and Algorithm Basic Concepts</title>

<h1>Data Structures &amp; Algorithm Basic Concepts</h1>

<p>This chapter explains the basic terms related to data structure.</p>

<h2>Data Definition</h2>

<p>Data Definition defines a particular data with the following characteristics.</p>

<p><b>Atomic</b> &minus; Definition should define a single concept.</p>

<p><b>Traceable</b> &minus; Definition should be able to be mapped to some data element.</p>

<p><b>Accurate</b> &minus; Definition should be unambiguous.</p>

<p><b>Clear and Concise</b> &minus; Definition should be understandable.</p>

<h2>Data Object</h2>

<p>Data Object represents an object having a data.</p>

<h2>Data Type</h2>

<p>Data type is a way to classify various types of data such as integer, string, etc. which determines the values that can be used with the corresponding type of data, the type of operations that can be performed on the corresponding type of data. There are two data types &minus;</p>

<h3>Built-in Data Type</h3>

<p>Those data types for which a language has built-in support are known as Built-in Data types. For example, most of the languages provide the following built-in data types.</p>

<h3>Derived Data Type</h3>

<p>Those data types which are implementation independent as they can be implemented in one or the other way are known as derived data types. These data types are normally built by the combination of primary or built-in data types and associated operations on them. For example &minus;</p>

<h2>Basic Operations</h2>

<p>The data in the data structures are processed by certain operations. The particular data structure chosen largely depends on the frequency of the operation that needs to be performed on the data structure.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Data Structures and Algorithms Arrays</title>

<h1>Data Structures and Algorithms - Arrays</h1>

<p>Array is a container which can hold a fix number of items and these items should be of the same type. Most of the data structures make use of arrays to implement their algorithms. Following are the important terms to understand the concept of Array.</p>

<p><b>Element</b> &minus; Each item stored in an array is called an element.</p>

<p><b>Index</b> &minus; Each location of an element in an array has a numerical index, which is used to identify the element.</p>

<h2>Array Representation</h2>

<p>Arrays can be declared in various ways in different languages. For illustration, let's take C array declaration.</p>

<p>As per the above illustration, following are the important points to be considered.</p>

<p>Index starts with 0.</p>

<p>Array length is 10 which means it can store 10 elements.</p>

<p>Each element can be accessed via its index. For example, we can fetch an element at index 6 as 9.</p>

<h2>Basic Operations</h2>

<p>Following are the basic operations supported by an array.</p>

<p><b>Traverse</b> &minus; print all the array elements one by one.</p>

<p><b>Insertion</b> &minus; Adds an element at the given index.</p>

<p><b>Deletion</b> &minus; Deletes an element at the given index.</p>

<p><b>Search</b> &minus; Searches an element using the given index or by the value.</p>

<p><b>Update</b> &minus; Updates an element at the given index.</p>

<p>In C, when an array is initialized with size, then it assigns defaults values to its elements in following order.</p>

<h2>Insertion Operation</h2>

<p>Insert operation is to insert one or more data elements into an array. Based on the requirement, a new element can be added at the beginning, end, or any given index of array.</p>

<p>Here, we see a practical implementation of insertion operation, where we add data at the end of the array &minus;</p>

<h3>Algorithm</h3>

<p>Let <b>Array</b> be a linear unordered array of <b>MAX</b> elements.</p>

<h3>Example</h3>

<p><b>Result</b></p>

<p>Let <b>LA</b> be a Linear Array (unordered) with <b>N</b> elements and <b>K</b> is a positive integer such that <b>K&lt;=N</b>. Following is the algorithm where ITEM is inserted into the K<sup>th</sup> position of LA &minus;</p>

<h3>Example</h3>

<p>Following is the implementation of the above algorithm &minus;</p>

<p>When we compile and execute the above program, it produces the following result &minus;</p>

<h3>Output</h3>

<p>For other variations of array insertion operation <a target="_blank" href="/data_structures_algorithms/array_insertion_algorithm.htm">click here</a></p>

<h2>Deletion Operation</h2>

<p>Deletion refers to removing an existing element from the array and re-organizing all elements of an array.</p>

<h3>Algorithm</h3>

<p>Consider <b>LA</b> is a linear array with <b>N</b> elements and <b>K</b> is a positive integer such that <b>K&lt;=N</b>. Following is the algorithm to delete an element available at the K<sup>th</sup> position of LA.</p>

<h3>Example</h3>

<p>Following is the implementation of the above algorithm &minus;</p>

<p>When we compile and execute the above program, it produces the following result &minus;</p>

<h3>Output</h3>

<h2>Search Operation</h2>

<p>You can perform a search for an array element based on its value or its index.</p>

<h3>Algorithm</h3>

<p>Consider <b>LA</b> is a linear array with <b>N</b> elements and <b>K</b> is a positive integer such that <b>K&lt;=N</b>. Following is the algorithm to find an element with a value of ITEM using sequential search.</p>

<h3>Example</h3>

<p>Following is the implementation of the above algorithm &minus;</p>

<p>When we compile and execute the above program, it produces the following result &minus;</p>

<h3>Output</h3>

<h2>Update Operation</h2>

<p>Update operation refers to updating an existing element from the array at a given index.</p>

<h3>Algorithm</h3>

<p>Consider <b>LA</b> is a linear array with <b>N</b> elements and <b>K</b> is a positive integer such that <b>K&lt;=N</b>. Following is the algorithm to update an element available at the K<sup>th</sup> position of LA.</p>

<h3>Example</h3>

<p>Following is the implementation of the above algorithm &minus;</p>

<p>When we compile and execute the above program, it produces the following result &minus;</p>

<h3>Output</h3>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
1. Start
2. Set J = N
3. Set N = N&plus;1
4. Repeat steps 5 and 6 while J &gt;= K
5. Set LA[J+1] = LA[J]
6. Set J = J-1
7. Set LA[K] = ITEM
8. Stop
</pre>
<h3>Example</h3>
<p>Following is the implementation of the above algorithm &minus;</p>
<pre class="prettyprint notranslate tryit">
#include &lt;stdio.h&gt;

main() {
   int LA[] = {1,3,5,7,8};
   int item = 10, k = 3, n = 5;
   int i = 0, j = n;
   
   printf("The original array elements are :\n");
	
   for(i = 0; i&lt;n; i++) {
      printf("LA[%d] = %d \n", i, LA[i]);
   }
    
   n = n &plus; 1;
	
   while( j &gt;= k) {
      LA[j&plus;1] = LA[j];
      j = j - 1;
   }
	
   LA[k] = item;
   
	printf("The array elements after insertion :\n");
	
   for(i = 0; i&lt;n; i++) {
      printf("LA[%d] = %d \n", i, LA[i]);
   }
}
</pre>
<p>When we compile and execute the above program, it produces the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
The original array elements are :
LA[0] = 1 
LA[1] = 3 
LA[2] = 5 
LA[3] = 7 
LA[4] = 8 
The array elements after insertion :
LA[0] = 1 
LA[1] = 3 
LA[2] = 5 
LA[3] = 10 
LA[4] = 7 
LA[5] = 8 
</pre>
<p>For other variations of array insertion operation <a target="_blank" href="/data_structures_algorithms/array_insertion_algorithm.htm">click here</a></p>
<h2>Deletion Operation</h2>
<p>Deletion refers to removing an existing element from the array and re-organizing all elements of an array.</p>
<h3>Algorithm</h3>
<p>Consider <b>LA</b> is a linear array with <b>N</b> elements and <b>K</b> is a positive integer such that <b>K&lt;=N</b>. Following is the algorithm to delete an element available at the K<sup>th</sup> position of LA.</p>
<pre class="result notranslate">
1. Start
2. Set J = K
3. Repeat steps 4 and 5 while J &lt; N
4. Set LA[J-1] = LA[J]
5. Set J = J&plus;1
6. Set N = N-1
7. Stop
</pre>
<h3>Example</h3>
<p>Following is the implementation of the above algorithm &minus;</p>
<pre class="prettyprint notranslate tryit">
#include &lt;stdio.h&gt;
main() {
   int LA[] = {1,3,5,7,8};
   int k = 3, n = 5;
   int i, j;
   
   printf("The original array elements are :\n");
	
   for(i = 0; i&lt;n; i++) {
      printf("LA[%d] = %d \n", i, LA[i]);
   }
    
   j = k;
	
   while( j &lt; n) {
      LA[j-1] = LA[j];
      j = j &plus; 1;
   }
	
   n = n -1;
   
   printf("The array elements after deletion :\n");
	
   for(i = 0; i&lt;n; i&plus;&plus;) {
      printf("LA[%d] = %d \n", i, LA[i]);
   }
}
</pre>
<p>When we compile and execute the above program, it produces the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
The original array elements are :
LA[0] = 1 
LA[1] = 3 
LA[2] = 5 
LA[3] = 7 
LA[4] = 8 
The array elements after deletion :
LA[0] = 1 
LA[1] = 3 
LA[2] = 7 
LA[3] = 8 
</pre>
<h2>Search Operation</h2>
<p>You can perform a search for an array element based on its value or its index.</p>
<h3>Algorithm</h3>
<p>Consider <b>LA</b> is a linear array with <b>N</b> elements and <b>K</b> is a positive integer such that <b>K&lt;=N</b>. Following is the algorithm to find an element with a value of ITEM using sequential search.</p>
<pre class="result notranslate">
1. Start
2. Set J = 0
3. Repeat steps 4 and 5 while J &lt; N
4. IF LA[J] is equal ITEM THEN GOTO STEP 6
5. Set J = J +1
6. PRINT J, ITEM
7. Stop
</pre>
<h3>Example</h3>
<p>Following is the implementation of the above algorithm &minus;</p>
<pre class="prettyprint notranslate tryit">
#include &lt;stdio.h&gt;
main() {
   int LA[] = {1,3,5,7,8};
   int item = 5, n = 5;
   int i = 0, j = 0;
   
   printf("The original array elements are :\n");
	
   for(i = 0; i&lt;n; i++) {
      printf("LA[%d] = %d \n", i, LA[i]);
   }
    
   while( j &lt; n){
      if( LA[j] == item ) {
         break;
      }
		
      j = j + 1;
   }
	
   printf("Found element %d at position %d\n", item, j+1);
}
</pre>
<p>When we compile and execute the above program, it produces the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
The original array elements are :
LA[0] = 1 
LA[1] = 3 
LA[2] = 5 
LA[3] = 7 
LA[4] = 8 
Found element 5 at position 3
</pre>
<h2>Update Operation</h2>
<p>Update operation refers to updating an existing element from the array at a given index.</p>
<h3>Algorithm</h3>
<p>Consider <b>LA</b> is a linear array with <b>N</b> elements and <b>K</b> is a positive integer such that <b>K&lt;=N</b>. Following is the algorithm to update an element available at the K<sup>th</sup> position of LA.</p>
<pre class="result notranslate">
1. Start
2. Set LA[K-1] = ITEM
3. Stop
</pre>
<h3>Example</h3>
<p>Following is the implementation of the above algorithm &minus;</p>
<pre class="prettyprint notranslate tryit">
#include &lt;stdio.h&gt;
main() {
   int LA[] = {1,3,5,7,8};
   int k = 3, n = 5, item = 10;
   int i, j;
   
   printf("The original array elements are :\n");
	
   for(i = 0; i&lt;n; i++) {
      printf("LA[%d] = %d \n", i, LA[i]);
   }
    
   LA[k-1] = item;

   printf("The array elements after updation :\n");
	
   for(i = 0; i&lt;n; i++) {
      printf("LA[%d] = %d \n", i, LA[i]);
   }
}
</pre>
<p>When we compile and execute the above program, it produces the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
The original array elements are :
LA[0] = 1 
LA[1] = 3 
LA[2] = 5 
LA[3] = 7 
LA[4] = 8 
The array elements after updation :
LA[0] = 1 
LA[1] = 3 
LA[2] = 10 
LA[3] = 7 
LA[4] = 8 
</pre>

<title>Data Structures and Algorithms Linked List</title>

<h1>Data Structure and Algorithms - Linked List</h1>

<p>A linked list is a sequence of data structures, which are connected together via links.</p>

<p>Linked List is a sequence of links which contains items. Each link contains a connection to another link. Linked list is the second most-used data structure after array. Following are the important terms to understand the concept of Linked List.</p>

<p><b>Link</b> &minus; Each link of a linked list can store a data called an element.</p>

<p><b>Next</b> &minus; Each link of a linked list contains a link to the next link called Next.</p>

<p><b>LinkedList</b> &minus; A Linked List contains the connection link to the first link called First.</p>

<h2>Linked List Representation</h2>

<p>Linked list can be visualized as a chain of nodes, where every node points to the next node.</p>

<p>As per the above illustration, following are the important points to be considered.</p>

<p>Linked List contains a link element called first.</p>

<p>Each link carries a data field(s) and a link field called next.</p>

<p>Each link is linked with its next link using its next link.</p>

<p>Last link carries a link as null to mark the end of the list.</p>

<h2>Types of Linked List</h2>

<p>Following are the various types of linked list.</p>

<p><b>Simple Linked List</b> &minus; Item navigation is forward only.</p>

<p><b>Doubly Linked List</b> &minus; Items can be navigated forward and backward.</p>

<p><b>Circular Linked List</b> &minus; Last item contains link of the first element as next and the first element has a link to the last element as previous.</p>

<h2>Basic Operations</h2>

<p>Following are the basic operations supported by a list.</p>

<p><b>Insertion</b> &minus; Adds an element at the beginning of the list.</p>

<p><b>Deletion</b> &minus; Deletes an element at the beginning of the list.</p>

<p><b>Display</b> &minus; Displays the complete list.</p>

<p><b>Search</b> &minus; Searches an element using the given key.</p>

<p><b>Delete</b> &minus; Deletes an element using the given key.</p>

<h2>Insertion Operation</h2>

<p>Adding a new node in linked list is a more than one step activity. We shall learn this with diagrams here. First, create a node using the same structure and find the location where it has to be inserted.</p>

<p>Imagine that we are inserting a node <b>B</b> (NewNode), between <b>A</b> (LeftNode) and <b>C</b> (RightNode). Then point B.next to C &minus;</p>

<p>It should look like this &minus;</p>

<p>Now, the next node at the left should point to the new node.</p>

<p>This will put the new node in the middle of the two. The new list should look like this &minus;</p>

<p>Similar steps should be taken if the node is being inserted at the beginning of the list. While inserting it at the end, the second last node of the list should point to the new node and the new node will point to NULL.</p>

<h2>Deletion Operation</h2>

<p>Deletion is also a more than one step process. We shall learn with pictorial representation. First, locate the target node to be removed, by using searching algorithms.</p>

<p>The left (previous) node of the target node now should point to the next node of the target node &minus;</p>

<p>This will remove the link that was pointing to the target node. Now, using the following code, we will remove what the target node is pointing at.</p>

<p>We need to use the deleted node. We can keep that in memory otherwise we can simply deallocate memory and wipe off the target node completely.</p>

<h2>Reverse Operation</h2>

<p>This operation is a thorough one. We need to make the last node to be pointed by the head node and reverse the whole linked list.</p>

<p>First, we traverse to the end of the list. It should be pointing to NULL. Now, we shall make it point to its previous node &minus;</p>

<p>We have to make sure that the last node is not the lost node. So we'll have some temp node, which looks like the head node pointing to the last node. Now, we shall make all left side nodes point to their previous nodes one by one.</p>

<p>Except the node (first node) pointed by the head node, all nodes should point to their predecessor, making them their new successor. The first node will point to NULL.</p>

<p>We'll make the head node point to the new first node by using the temp node.</p>

<p>The linked list is now reversed. To see linked list implementation in C programming language, please <a href="/data_structures_algorithms/linked_list_program_in_c.htm">click here</a>.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
NewNode.next −&gt; RightNode;
</pre>
<p>It should look like this &minus;</p>
<img src="/data_structures_algorithms/images/linked_list_insertion_1.jpg" alt="Linked List Insertion" /> 
<p>Now, the next node at the left should point to the new node.</p>
<pre class="result notranslate">
LeftNode.next −&gt; NewNode;
</pre>
<img src="/data_structures_algorithms/images/linked_list_insertion_2.jpg" alt="Linked List Insertion" /> 
<p>This will put the new node in the middle of the two. The new list should look like this &minus;</p>
<img src="/data_structures_algorithms/images/linked_list_insertion_3.jpg" alt="Linked List Insertion" /> 
<p>Similar steps should be taken if the node is being inserted at the beginning of the list. While inserting it at the end, the second last node of the list should point to the new node and the new node will point to NULL.</p>
<h2>Deletion Operation</h2>
<p>Deletion is also a more than one step process. We shall learn with pictorial representation. First, locate the target node to be removed, by using searching algorithms.</p>
<img src="/data_structures_algorithms/images/linked_list_deletion_0.jpg" alt="Linked List Deletion" /> 
<p>The left (previous) node of the target node now should point to the next node of the target node &minus;</p>
<pre class="result notranslate">
LeftNode.next −&gt; TargetNode.next;
</pre>
<img src="/data_structures_algorithms/images/linked_list_deletion_1.jpg" alt="Linked List Deletion" /> 
<p>This will remove the link that was pointing to the target node. Now, using the following code, we will remove what the target node is pointing at.</p>
<pre class="result notranslate">
TargetNode.next −&gt; NULL;
</pre>

<title>Data Structures &amp; Algorithms Doubly Linked List</title>

<h1>Data Structure - Doubly Linked List</h1>

<p>Doubly Linked List is a variation of Linked list in which navigation is possible in both ways, either forward and backward easily as compared to Single Linked List. Following are the important terms to understand the concept of doubly linked list.</p>

<p><b>Link</b> &minus; Each link of a linked list can store a data called an element.</p>

<p><b>Next</b> &minus; Each link of a linked list contains a link to the next link called Next.</p>

<p><b>Prev</b> &minus; Each link of a linked list contains a link to the previous link called Prev.</p>

<p><b>LinkedList</b> &minus; A Linked List contains the connection link to the first link called First and to the last link called Last.</p>

<h2>Doubly Linked List Representation</h2>

<p>As per the above illustration, following are the important points to be considered.</p>

<p>Doubly Linked List contains a link element called first and last.</p>

<p>Each link carries a data field(s) and two link fields called next and prev.</p>

<p>Each link is linked with its next link using its next link.</p>

<p>Each link is linked with its previous link using its previous link.</p>

<p>The last link carries a link as null to mark the end of the list.</p>

<h2>Basic Operations</h2>

<p>Following are the basic operations supported by a list.</p>

<p><b>Insertion</b> &minus; Adds an element at the beginning of the list.</p>

<p><b>Deletion</b> &minus; Deletes an element at the beginning of the list.</p>

<p><b>Insert Last</b> &minus; Adds an element at the end of the list.</p>

<p><b>Delete Last</b> &minus; Deletes an element from the end of the list.</p>

<p><b>Insert After</b> &minus; Adds an element after an item of the list.</p>

<p><b>Delete</b> &minus; Deletes an element from the list using the key.</p>

<p><b>Display forward</b> &minus; Displays the complete list in a forward manner.</p>

<p><b>Display backward</b> &minus; Displays the complete list in a backward manner.</p>

<h2>Insertion Operation</h2>

<p>Following code demonstrates the insertion operation at the beginning of a doubly linked list.</p>

<h3>Example</h3>

<h2>Deletion Operation</h2>

<p>Following code demonstrates the deletion operation at the beginning of a doubly linked list.</p>

<h3>Example</h3>

<h2>Insertion at the End of an Operation</h2>

<p>Following code demonstrates the insertion operation at the last position of a doubly linked list.</p>

<h3>Example</h3>

<p>To see the implementation in C programming language, please <a href="/data_structures_algorithms/doubly_linked_list_program_in_c.htm">click here</a>.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
//insert link at the first location
void insertFirst(int key, int data) {

   //create a link
   struct node *link = (struct node*) malloc(sizeof(struct node));
   link-&gt;key = key;
   link-&gt;data = data;
	
   if(isEmpty()) {
      //make it the last link
      last = link;
   } else {
      //update first prev link
      head-&gt;prev = link;
   }

   //point it to old first link
   link-&gt;next = head;
	
   //point first to new first link
   head = link;
}
</pre>
<h2>Deletion Operation</h2>
<p>Following code demonstrates the deletion operation at the beginning of a doubly linked list.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
//delete first item
struct node* deleteFirst() {

   //save reference to first link
   struct node *tempLink = head;
	
   //if only one link
   if(head-&gt;next == NULL) {
      last = NULL;
   } else {
      head-&gt;next-&gt;prev = NULL;
   }
	
   head = head-&gt;next;
	
   //return the deleted link
   return tempLink;
}
</pre>
<h2>Insertion at the End of an Operation</h2>
<p>Following code demonstrates the insertion operation at the last position of a doubly linked list.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
//insert link at the last location
void insertLast(int key, int data) {

   //create a link
   struct node *link = (struct node*) malloc(sizeof(struct node));
   link-&gt;key = key;
   link-&gt;data = data;
	
   if(isEmpty()) {
      //make it the last link
      last = link;
   } else {
      //make link a new last link
      last-&gt;next = link;     
      
      //mark old last node as prev of new link
      link-&gt;prev = last;
   }

   //point last to new last node
   last = link;
}
</pre>

<title>Data Structures and Algorithms Circular Linked List</title>

<h1>Data Structure - Circular Linked List</h1>

<p>Circular Linked List is a variation of Linked list in which the first element points to the last element and the last element points to the first element. Both Singly Linked List and Doubly Linked List can be made into a circular linked list.</p>

<h2>Singly Linked List as Circular</h2>

<p>In singly linked list, the next pointer of the last node points to the first node.</p>

<h2>Doubly Linked List as Circular</h2>

<p>In doubly linked list, the next pointer of the last node points to the first node and the previous pointer of the first node points to the last node making the circular in both directions.</p>

<p>As per the above illustration, following are the important points to be considered.</p>

<p>The last link's next points to the first link of the list in both cases of singly as well as doubly linked list.</p>

<p>The first link's previous points to the last of the list in case of doubly linked list.</p>

<h2>Basic Operations</h2>

<p>Following are the important operations supported by a circular list.</p>

<p><b>insert</b> &minus; Inserts an element at the start of the list.</p>

<p><b>delete</b> &minus; Deletes an element from the start of the list.</p>

<p><b>display</b> &minus; Displays the list.</p>

<h2>Insertion Operation</h2>

<p>Following code demonstrates the insertion operation in a circular linked list based on single linked list.</p>

<h3>Example</h3>

<h2>Deletion Operation</h2>

<p>Following code demonstrates the deletion operation in a circular linked list based on single linked list.</p>

<h2>Display List Operation</h2>

<p>Following code demonstrates the display list operation in a circular linked list.</p>

<p>To know about its implementation in C programming language, please <a href="/data_structures_algorithms/circular_linked_list_program_in_c.htm">click here</a>.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
//insert link at the first location
void insertFirst(int key, int data) {
   //create a link
   struct node *link = (struct node*) malloc(sizeof(struct node));
   link-&gt;key = key;
   link-&gt;data= data;
	
   if (isEmpty()) {
      head = link;
      head-&gt;next = head;
   } else {
      //point it to old first node
      link-&gt;next = head;
		
      //point first to new first node
      head = link;
   }   
}
</pre>
<h2>Deletion Operation</h2>
<p>Following code demonstrates the deletion operation in a circular linked list based on single linked list.</p>
<pre class="prettyprint notranslate">
//delete first item
struct node * deleteFirst() {
   //save reference to first link
   struct node *tempLink = head;
	
   if(head-&gt;next == head) {  
      head = NULL;
      return tempLink;
   }     

   //mark next to first link as first 
   head = head-&gt;next;
	
   //return the deleted link
   return tempLink;
}
</pre>
<h2>Display List Operation</h2>
<p>Following code demonstrates the display list operation in a circular linked list.</p>
<pre class="prettyprint notranslate">
//display the list
void printList() {
   struct node *ptr = head;
   printf("\n[ ");
	
   //start from the beginning
   if(head != NULL) {
      while(ptr-&gt;next != ptr) {     
         printf("(%d,%d) ",ptr-&gt;key,ptr-&gt;data);
         ptr = ptr-&gt;next;
      }
   }
	
   printf(" ]");
}
</pre>

<title>Data Structures and Algorithms Stack</title>

<h1>Data Structure and Algorithms - Stack</h1>

<p>A stack is an Abstract Data Type (ADT), commonly used in most programming languages. It is named stack as it behaves like a real-world stack, for example – a deck of cards or a pile of plates, etc.</p>

<p>A real-world stack allows operations at one end only. For example, we can place or remove a card or plate from the top of the stack only. Likewise, Stack ADT allows all data operations at one end only. At any given time, we can only access the top element of a stack.</p>

<p>This feature makes it LIFO data structure. LIFO stands for Last-in-first-out. Here, the element which is placed (inserted or added) last, is accessed first. In stack terminology, insertion operation is called <b>PUSH</b> operation and removal operation is called <b>POP</b> operation.</p>

<h2>Stack Representation</h2>

<p>The following diagram depicts a stack and its operations &minus;</p>

<p>A stack can be implemented by means of Array, Structure, Pointer, and Linked List. Stack can either be a fixed size one or it may have a sense of dynamic resizing. Here, we are going to implement stack using arrays, which makes it a fixed size stack implementation.</p>

<h2>Basic Operations</h2>

<p>Stack operations may involve initializing the stack, using it and then de-initializing it. Apart from these basic stuffs, a stack is used for the following two primary operations &minus;</p>

<p><b>push()</b> &minus; Pushing (storing) an element on the stack.</p>

<p><b>pop()</b> &minus; Removing (accessing) an element from the stack.</p>

<p>When data is PUSHed onto stack.</p>

<p>To use a stack efficiently, we need to check the status of stack as well. For the same purpose, the following functionality is added to stacks &minus;</p>

<p><b>peek()</b> &minus; get the top data element of the stack, without removing it.</p>

<p><b>isFull()</b> &minus; check if stack is full.</p>

<p><b>isEmpty()</b> &minus; check if stack is empty.</p>

<p>At all times, we maintain a pointer to the last PUSHed data on the stack. As this pointer always represents the top of the stack, hence named <b>top</b>. The <b>top</b> pointer provides top value of the stack without actually removing it.</p>

<p>First we should learn about procedures to support stack functions &minus;</p>

<h3>peek()</h3>

<p>Algorithm of peek() function &minus;</p>

<p>Implementation of peek() function in C programming language &minus;</p>

<p><b>Example</b></p>

<h3>isfull()</h3>

<p>Algorithm of isfull() function &minus;</p>

<p>Implementation of isfull() function in C programming language &minus;</p>

<p><b>Example</b></p>

<h3>isempty()</h3>

<p>Algorithm of isempty() function &minus;</p>

<p>Implementation of isempty() function in C programming language is slightly different. We initialize top at -1, as the index in array starts from 0. So we check if the top is below zero or -1 to determine if the stack is empty. Here's the code &minus;</p>

<p><b>Example</b></p>

<h2>Push Operation</h2>

<p>The process of putting a new data element onto stack is known as a Push Operation. Push operation involves a series of steps &minus;</p>

<p><b>Step 1</b> &minus; Checks if the stack is full.</p>

<p><b>Step 2</b> &minus; If the stack is full, produces an error and exit.</p>

<p><b>Step 3</b> &minus; If the stack is not full, increments <b>top</b> to point next empty space.</p>

<p><b>Step 4</b> &minus; Adds data element to the stack location, where top is pointing.</p>

<p><b>Step 5</b> &minus; Returns success.</p>

<p>If the linked list is used to implement the stack, then in step 3, we need to allocate space dynamically.</p>

<h3>Algorithm for PUSH Operation</h3>

<p>A simple algorithm for Push operation can be derived as follows &minus;</p>

<p>Implementation of this algorithm in C, is very easy. See the following code &minus;</p>

<p><b>Example</b></p>

<h2>Pop Operation</h2>

<p>Accessing the content while removing it from the stack, is known as a Pop Operation. In an array implementation of pop() operation, the data element is not actually removed, instead <b>top</b> is decremented to a lower position in the stack to point to the next value. But in linked-list implementation, pop() actually removes data element and deallocates memory space.</p>

<p>A Pop operation may involve the following steps &minus;</p>

<p><b>Step 1</b> &minus; Checks if the stack is empty.</p>

<p><b>Step 2</b> &minus; If the stack is empty, produces an error and exit.</p>

<p><b>Step 3</b> &minus; If the stack is not empty, accesses the data element at which <b>top</b> is pointing.</p>

<p><b>Step 4</b> &minus; Decreases the value of top by 1.</p>

<p><b>Step 5</b> &minus; Returns success.</p>

<h3>Algorithm for Pop Operation</h3>

<p>A simple algorithm for Pop operation can be derived as follows &minus;</p>

<p>Implementation of this algorithm in C, is as follows &minus;</p>

<p><b>Example</b></p>

<p>For a complete stack program in C programming language, please <a href="/data_structures_algorithms/stack_program_in_c.htm" alt="Stack Program in C">click here</a>.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
begin procedure peek

   return stack[top]
   
end procedure
</pre>
<p>Implementation of peek() function in C programming language &minus;</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate" id="peek">
int peek() {
   return stack[top];
}
</pre>
<h3>isfull()</h3>
<p>Algorithm of isfull() function &minus;</p>
<pre class="prettyprint notranslate">
begin procedure isfull

   if top equals to MAXSIZE
      return true
   else
      return false
   endif
   
end procedure
</pre>
<p>Implementation of isfull() function in C programming language &minus;</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate" id="isfull">
bool isfull() {
   if(top == MAXSIZE)
      return true;
   else
      return false;
}
</pre>
<h3>isempty()</h3>
<p>Algorithm of isempty() function &minus;</p>
<pre class="prettyprint notranslate">
begin procedure isempty

   if top less than 1
      return true
   else
      return false
   endif
   
end procedure
</pre>
<p>Implementation of isempty() function in C programming language is slightly different. We initialize top at -1, as the index in array starts from 0. So we check if the top is below zero or -1 to determine if the stack is empty. Here's the code &minus;</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate" id="isempty">
bool isempty() {
   if(top == -1)
      return true;
   else
      return false;
}
</pre>
<h2>Push Operation</h2>
<p>The process of putting a new data element onto stack is known as a Push Operation. Push operation involves a series of steps &minus;</p>
<ul class="list">
<li><p><b>Step 1</b> &minus; Checks if the stack is full.</p></li>
<li><p><b>Step 2</b> &minus; If the stack is full, produces an error and exit.</p></li>
<li><p><b>Step 3</b> &minus; If the stack is not full, increments <b>top</b> to point next empty space.</p></li>
<li><p><b>Step 4</b> &minus; Adds data element to the stack location, where top is pointing.</p></li>
<li><p><b>Step 5</b> &minus; Returns success.</p></li>
</ul>
<img src="/data_structures_algorithms/images/stack_push_operation.jpg" alt="Stack Push Operation" />
<p>If the linked list is used to implement the stack, then in step 3, we need to allocate space dynamically.</p>
<h3>Algorithm for PUSH Operation</h3>
<p>A simple algorithm for Push operation can be derived as follows &minus;</p>
<pre class="prettyprint notranslate">
begin procedure push: stack, data

   if stack is full
      return null
   endif
   
   top &larr; top + 1
   
   stack[top] &larr; data

end procedure
</pre>
<p>Implementation of this algorithm in C, is very easy. See the following code &minus;</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate" id="push">
void push(int data) {
   if(!isFull()) {
      top = top &plus; 1;   
      stack[top] = data;
   } else {
      printf("Could not insert data, Stack is full.\n");
   }
}
</pre>
<h2>Pop Operation</h2>
<p>Accessing the content while removing it from the stack, is known as a Pop Operation. In an array implementation of pop() operation, the data element is not actually removed, instead <b>top</b> is decremented to a lower position in the stack to point to the next value. But in linked-list implementation, pop() actually removes data element and deallocates memory space.</p>
<p>A Pop operation may involve the following steps &minus;</p>
<ul class="list">
<li><p><b>Step 1</b> &minus; Checks if the stack is empty.</p></li>
<li><p><b>Step 2</b> &minus; If the stack is empty, produces an error and exit.</p></li>
<li><p><b>Step 3</b> &minus; If the stack is not empty, accesses the data element at which <b>top</b> is pointing.</p></li>
<li><p><b>Step 4</b> &minus; Decreases the value of top by 1.</p></li>
<li><p><b>Step 5</b> &minus; Returns success.</p></li>
</ul>
<img src="/data_structures_algorithms/images/stack_pop_operation.jpg" alt="Stack Pop Operation" />
<h3>Algorithm for Pop Operation</h3>
<p>A simple algorithm for Pop operation can be derived as follows &minus;</p>
<pre class="prettyprint notranslate">
begin procedure pop: stack

   if stack is empty
      return null
   endif
   
   data &larr; stack[top]
   
   top &larr; top - 1
   
   return data

end procedure
</pre>
<p>Implementation of this algorithm in C, is as follows &minus;</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate" id="pop">
int pop(int data) {

   if(!isempty()) {
      data = stack[top];
      top = top - 1;   
      return data;
   } else {
      printf("Could not retrieve data, Stack is empty.\n");
   }
}
</pre>

<title>Data Structures and Algorithms Parsing Expressions</title>

<h1>Data Structure - Expression Parsing</h1>

<p>The way to write arithmetic expression is known as a <b>notation</b>. An arithmetic expression can be written in three different but equivalent notations, i.e., without changing the essence or output of an expression. These notations are &minus;</p>

<p>These notations are named as how they use operator in expression. We shall learn the same here in this chapter.</p>

<h2>Infix Notation</h2>

<p>We write expression in <b>infix</b> notation, e.g. a - b &plus; c, where operators are used <b>in</b>-between operands. It is easy for us humans to read, write, and speak in infix notation but the same does not go well with computing devices. An algorithm to process infix notation could be difficult and costly in terms of time and space consumption.</p>

<h2>Prefix Notation</h2>

<p>In this notation, operator is <b>prefix</b>ed to operands, i.e. operator is written ahead of operands. For example, <b>&plus;ab</b>. This is equivalent to its infix notation <b>a &plus; b</b>. Prefix notation is also known as <b>Polish Notation</b>.</p>

<h2>Postfix Notation</h2>

<p>This notation style is known as <b>Reversed Polish Notation</b>. In this notation style, the operator is <b>postfix</b>ed to the operands i.e., the operator is written after the operands. For example, <b>ab&plus;</b>. This is equivalent to its infix notation <b>a &plus; b</b>.</p>

<p>The following table briefly tries to show the difference in all three notations &minus;</p>

<h2>Parsing Expressions</h2>

<p>As we have discussed, it is not a very efficient way to design an algorithm or program to parse infix notations. Instead, these infix notations are first converted into either postfix or prefix notations and then computed.</p>

<p>To parse any arithmetic expression, we need to take care of operator precedence and associativity also.</p>

<h3>Precedence</h3>

<p>When an operand is in between two different operators, which operator will take the operand first, is decided by the precedence of an operator over others. For example &minus;</p>

<p>As multiplication operation has precedence over addition, b * c will be evaluated first. A table of operator precedence is provided later.</p>

<h3>Associativity</h3>

<p>Associativity describes the rule where operators with the same precedence appear in an expression. For example, in expression a &plus; b − c, both &plus; and – have the same precedence, then which part of the expression will be evaluated first, is determined by associativity of those operators. Here, both &plus; and − are left associative, so the expression will be evaluated as <b>(a &plus; b) − c</b>.</p>

<p>Precedence and associativity determines the order of evaluation of an expression. Following is an operator precedence and associativity table (highest to lowest) &minus;</p>

<p>The above table shows the default behavior of operators. At any point of time in expression evaluation, the order can be altered by using parenthesis. For example &minus;</p>

<p>In <b>a &plus; b*c</b>, the expression part <b>b</b>*<b>c</b> will be evaluated first, with multiplication as precedence over addition. We here use parenthesis for <b>a &plus; b</b> to be evaluated first, like <b>(a &plus; b)*c</b>.</p>

<h2>Postfix Evaluation Algorithm</h2>

<p>We shall now look at the algorithm on how to evaluate postfix notation &minus;</p>

<p>To see the implementation in C programming language, please <a href="/data_structures_algorithms/expression_parsing_using_statck.htm">click here</a>.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
Step 1 − scan the expression from left to right 
Step 2 − if it is an operand push it to stack 
Step 3 − if it is an operator pull operand from stack and perform operation 
Step 4 − store the output of step 3, back to stack 
Step 5 − scan the expression until all operands are consumed 
Step 6 − pop the stack and perform operation
</pre>

<title>Data Structures and Algorithms Queue</title>

<h1>Data Structure and Algorithms - Queue</h1>

<p>Queue is an abstract data structure, somewhat similar to Stacks. Unlike stacks, a queue is open at both its ends. One end is always used to insert data (enqueue) and the other is used to remove data (dequeue). Queue follows First-In-First-Out methodology, i.e., the data item stored first will be accessed first.</p>

<p>A real-world example of queue can be a single-lane one-way road, where the vehicle enters first, exits first. More real-world examples can be seen as queues at the ticket windows and bus-stops.</p>

<h2>Queue Representation</h2>

<p>As we now understand that in queue, we access both ends for different reasons. The following diagram given below tries to explain queue representation as data structure &minus;</p>

<p>As in stacks, a queue can also be implemented using Arrays, Linked-lists, Pointers and Structures. For the sake of simplicity, we shall implement queues using one-dimensional array.</p>

<h2>Basic Operations</h2>

<p>Queue operations may involve initializing or defining the queue, utilizing it, and then completely erasing it from the memory. Here we shall try to understand the basic operations associated with queues &minus;</p>

<p><b>enqueue()</b> &minus; add (store) an item to the queue.</p>

<p><b>dequeue()</b> &minus; remove (access) an item from the queue.</p>

<p>Few more functions are required to make the above-mentioned queue operation efficient. These are &minus;</p>

<p><b>peek()</b> &minus; Gets the element at the front of the queue without removing it.</p>

<p><b>isfull()</b> &minus; Checks if the queue is full.</p>

<p><b>isempty()</b> &minus; Checks if the queue is empty.</p>

<p>In queue, we always dequeue (or access) data, pointed by <b>front</b> pointer and while enqueing (or storing) data in the queue we take help of <b>rear</b> pointer.</p>

<p>Let's first learn about supportive functions of a queue &minus;</p>

<h3>peek()</h3>

<p>This function helps to see the data at the <b>front</b> of the queue. The algorithm of peek() function is as follows &minus;</p>

<p><b>Algorithm</b></p>

<p>Implementation of peek() function in C programming language &minus;</p>

<p><b>Example</b></p>

<h3>isfull()</h3>

<p>As we are using single dimension array to implement queue, we just check for the rear pointer to reach at MAXSIZE to determine that the queue is full. In case we maintain the queue in a circular linked-list, the algorithm will differ. Algorithm of isfull() function &minus;</p>

<p><b>Algorithm</b></p>

<p>Implementation of isfull() function in C programming language &minus;</p>

<p><b>Example</b></p>

<h3>isempty()</h3>

<p>Algorithm of isempty() function &minus;</p>

<p><b>Algorithm</b></p>

<p>If the value of <b>front</b> is less than MIN or 0, it tells that the queue is not yet initialized, hence empty.</p>

<p>Here's the C programming code &minus;</p>

<p><b>Example</b></p>

<h2>Enqueue Operation</h2>

<p>Queues maintain two data pointers, <b>front</b> and <b>rear</b>. Therefore, its operations are comparatively difficult to implement than that of stacks.</p>

<p>The following steps should be taken to enqueue (insert) data into a queue &minus;</p>

<p><b>Step 1</b> &minus; Check if the queue is full.</p>

<p><b>Step 2</b> &minus; If the queue is full, produce overflow error and exit.</p>

<p><b>Step 3</b> &minus; If the queue is not full, increment <b>rear</b> pointer to point the next empty space.</p>

<p><b>Step 4</b> &minus; Add data element to the queue location, where the rear is pointing.</p>

<p><b>Step 5</b> &minus; return success.</p>

<p>Sometimes, we also check to see if a queue is initialized or not, to handle any unforeseen situations.</p>

<p><b>Algorithm for enqueue operation</b></p>

<p>Implementation of enqueue() in C programming language &minus;</p>

<p><b>Example</b></p>

<h2>Dequeue Operation</h2>

<p>Accessing data from the queue is a process of two tasks − access the data where <b>front</b> is pointing and remove the data after access. The following steps are taken to perform <b>dequeue</b> operation &minus;</p>

<p><b>Step 1</b> &minus; Check if the queue is empty.</p>

<p><b>Step 2</b> &minus; If the queue is empty, produce underflow error and exit.</p>

<p><b>Step 3</b> &minus; If the queue is not empty, access the data where <b>front</b> is pointing.</p>

<p><b>Step 4</b> &minus; Increment <b>front</b> pointer to point to the next available data element.</p>

<p><b>Step 5</b> &minus; Return success.</p>

<p><b>Algorithm for dequeue operation</b></p>

<p>Implementation of dequeue() in C programming language &minus;</p>

<p><b>Example</b></p>

<p>For a complete Queue program in C programming language, please <a href="/data_structures_algorithms/queue_program_in_c.htm">click here</a>.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
begin procedure peek

   return queue[front]
   
end procedure
</pre>
<p>Implementation of peek() function in C programming language &minus;</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate" id="peek">
int peek() {
   return queue[front];
}
</pre>
<h3>isfull()</h3>
<p>As we are using single dimension array to implement queue, we just check for the rear pointer to reach at MAXSIZE to determine that the queue is full. In case we maintain the queue in a circular linked-list, the algorithm will differ. Algorithm of isfull() function &minus;</p>
<p><b>Algorithm</b></p>
<pre class="prettyprint notranslate">
begin procedure isfull

   if rear equals to MAXSIZE
      return true
   else
      return false
   endif
   
end procedure
</pre>
<p>Implementation of isfull() function in C programming language &minus;</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
bool isfull() {
   if(rear == MAXSIZE - 1)
      return true;
   else
      return false;
}
</pre>
<h3>isempty()</h3>
<p>Algorithm of isempty() function &minus;</p>
<p><b>Algorithm</b></p>
<pre class="prettyprint notranslate">
begin procedure isempty

   if front is less than MIN  OR front is greater than rear
      return true
   else
      return false
   endif
   
end procedure
</pre>
<p>If the value of <b>front</b> is less than MIN or 0, it tells that the queue is not yet initialized, hence empty.</p>
<p>Here's the C programming code &minus;</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
bool isempty() {
   if(front &lt; 0 || front &gt; rear) 
      return true;
   else
      return false;
}
</pre>
<h2>Enqueue Operation</h2>
<p>Queues maintain two data pointers, <b>front</b> and <b>rear</b>. Therefore, its operations are comparatively difficult to implement than that of stacks.</p>
<p>The following steps should be taken to enqueue (insert) data into a queue &minus;</p>
<ul class="list">
<li><p><b>Step 1</b> &minus; Check if the queue is full.</p></li>   
<li><p><b>Step 2</b> &minus; If the queue is full, produce overflow error and exit.</p></li>  
<li><p><b>Step 3</b> &minus; If the queue is not full, increment <b>rear</b> pointer to point the next empty space.</p></li>   
<li><p><b>Step 4</b> &minus; Add data element to the queue location, where the rear is pointing.</p></li>   
<li><p><b>Step 5</b> &minus; return success.</p></li>
</ul>
<img src="/data_structures_algorithms/images/queue_enqueue_diagram.jpg" alt="Insert Operation" />
<p>Sometimes, we also check to see if a queue is initialized or not, to handle any unforeseen situations.</p>
<p><b>Algorithm for enqueue operation</b></p>
<pre class="prettyprint notranslate">
procedure enqueue(data)      
   if queue is full
      return overflow
   endif
   
   rear &larr; rear + 1
   
   queue[rear] &larr; data
   
   return true
   
end procedure
</pre>
<p>Implementation of enqueue() in C programming language &minus;</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
int enqueue(int data)      
   if(isfull())
      return 0;
   
   rear = rear &plus; 1;
   queue[rear] = data;
   
   return 1;
end procedure
</pre>
<h2>Dequeue Operation</h2>
<p>Accessing data from the queue is a process of two tasks − access the data where <b>front</b> is pointing and remove the data after access. The following steps are taken to perform <b>dequeue</b> operation &minus;</p>
<ul class="list">
<li><p><b>Step 1</b> &minus; Check if the queue is empty.</p></li>   
<li><p><b>Step 2</b> &minus; If the queue is empty, produce underflow error and exit.</p></li>   
<li><p><b>Step 3</b> &minus; If the queue is not empty, access the data where <b>front</b> is pointing.</p></li>   
<li><p><b>Step 4</b> &minus; Increment <b>front</b> pointer to point to the next available data element.</p></li>   
<li><p><b>Step 5</b> &minus; Return success.</p></li>
</ul>
<img src="/data_structures_algorithms/images/queue_dequeue_diagram.jpg" alt="Remove Operation" />
<p><b>Algorithm for dequeue operation</b></p>
<pre class="prettyprint notranslate">
procedure dequeue
   if queue is empty
      return underflow
   end if

   data = queue[front]
   front &larr; front + 1
   
   return true
end procedure
</pre>
<p>Implementation of dequeue() in C programming language &minus;</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
int dequeue() {

   if(isempty())
      return 0;

   int data = queue[front];
   front = front + 1;

   return data;
}
</pre>

<title>Data Structures and Algorithms Linear Search</title>

<h1>Data Structure and Algorithms Linear Search</h1>

<p>Linear search is a very simple search algorithm. In this type of search, a sequential search is made over all items one by one. Every item is checked and if a match is found then that particular item is returned, otherwise the search continues till the end of the data collection.</p>

<h2>Algorithm</h2>

<h2>Pseudocode</h2>

<p>To know about linear search implementation in C programming language, please <a href="/data_structures_algorithms/linear_search_program_in_c.htm">click-here</a>.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
Linear Search ( Array A, Value x)

Step 1: Set i to 1
Step 2: if i &gt; n then go to step 7
Step 3: if A[i] = x then go to step 6
Step 4: Set i to i + 1
Step 5: Go to Step 2
Step 6: Print Element x Found at index i and go to step 8
Step 7: Print element not found
Step 8: Exit
</pre> 
<h2>Pseudocode</h2>
<pre class="prettyprint notranslate">
procedure linear_search (list, value)

   for each item in the list

      if match item == value

         return the item's location

      end if

   end for

end procedure
</pre>

<title>Data Structures and Algorithms Binary Search</title>

<h1>Data Structure and Algorithms Binary Search</h1>

<p>Binary search is a fast search algorithm with run-time complexity of &Omicron;(log n). This search algorithm works on the principle of divide and conquer. For this algorithm to work properly, the data collection should be in the sorted form.</p>

<p>Binary search looks for a particular item by comparing the middle most item of the collection. If a match occurs, then the index of item is returned. If the middle item is greater than the item, then the item is searched in the sub-array to the left of the middle item. Otherwise, the item is searched for in the sub-array to the right of the middle item. This process continues on the sub-array as well until the size of the subarray reduces to zero.</p>

<h2>How Binary Search Works?</h2>

<p>For a binary search to work, it is mandatory for the target array to be sorted. We shall learn the process of binary search with a pictorial example. The following is our sorted array and let us assume that we need to search the location of value 31 using binary search.</p>

<p>First, we shall determine half of the array by using this formula &minus;</p>

<p>Here it is, 0 &plus; (9 - 0 ) / 2 = 4 (integer value of 4.5). So, 4 is the mid of the array.</p>

<p>Now we compare the value stored at location 4, with the value being searched, i.e. 31. We find that the value at location 4 is 27, which is not a match. As the value is greater than 27 and we have a sorted array, so we also know that the target value must be in the upper portion of the array.</p>

<p>We change our low to mid &plus; 1 and find the new mid value again.</p>

<p>Our new mid is 7 now. We compare the value stored at location 7 with our target value 31.</p>

<p>The value stored at location 7 is not a match, rather it is more than what we are looking for. So, the value must be in the lower part from this location.</p>

<p>Hence, we calculate the mid again. This time it is 5.</p>

<p>We compare the value stored at location 5 with our target value. We find that it is a match.</p>

<p>We conclude that the target value 31 is stored at location 5.</p>

<p>Binary search halves the searchable items and thus reduces the count of comparisons to be made to very less numbers.</p>

<h2>Pseudocode</h2>

<p>The pseudocode of binary search algorithms should look like this &minus;</p>

<p>To know about binary search implementation using array in C programming language, please <a href="/data_structures_algorithms/binary_search_program_in_c.htm">click here</a>.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
mid = low &plus; (high - low) / 2
</pre>
<p>Here it is, 0 &plus; (9 - 0 ) / 2 = 4 (integer value of 4.5). So, 4 is the mid of the array.</p>
<img src="/data_structures_algorithms/images/binary_search_1.jpg" alt="Binary search" /> 
<p>Now we compare the value stored at location 4, with the value being searched, i.e. 31. We find that the value at location 4 is 27, which is not a match. As the value is greater than 27 and we have a sorted array, so we also know that the target value must be in the upper portion of the array.</p>
<img src="/data_structures_algorithms/images/binary_search_2.jpg" alt="Binary search" /> 
<p>We change our low to mid &plus; 1 and find the new mid value again.</p>
<pre class="result notranslate">
low = mid &plus; 1
mid = low &plus; (high - low) / 2
</pre>
<p>Our new mid is 7 now. We compare the value stored at location 7 with our target value 31.</p>
<img src="/data_structures_algorithms/images/binary_search_3.jpg" alt="Binary search" /> 
<p>The value stored at location 7 is not a match, rather it is more than what we are looking for. So, the value must be in the lower part from this location.</p>
<img src="/data_structures_algorithms/images/binary_search_4.jpg" alt="Binary search" /> 
<p>Hence, we calculate the mid again. This time it is 5.</p>
<img src="/data_structures_algorithms/images/binary_search_5.jpg" alt="Binary search" /> 
<p>We compare the value stored at location 5 with our target value. We find that it is a match.</p>
<img src="/data_structures_algorithms/images/binary_search_6.jpg" alt="Binary search" /> 
<p>We conclude that the target value 31 is stored at location 5.</p>
<p>Binary search halves the searchable items and thus reduces the count of comparisons to be made to very less numbers.</p>
<h2>Pseudocode</h2>
<p>The pseudocode of binary search algorithms should look like this &minus;</p>
<pre class="prettyprint notranslate">
Procedure binary_search
   A &larr; sorted array
   n &larr; size of array
   x &larr; value to be searched

   Set lowerBound = 1
   Set upperBound = n 

   while x not found
      if upperBound &lt; lowerBound 
         EXIT: x does not exists.
   
      set midPoint = lowerBound &plus; ( upperBound - lowerBound ) / 2
      
      if A[midPoint] &lt; x
         set lowerBound = midPoint &plus; 1
         
      if A[midPoint] &gt; x
         set upperBound = midPoint - 1 

      if A[midPoint] = x 
         EXIT: x found at location midPoint

   end while
   
end procedure
</pre>

<title>Data Structures and Algorithms Interpolation Search</title>

<h1>Data Structure - Interpolation Search</h1>

<p>Interpolation search is an improved variant of binary search. This search algorithm works on the probing position of the required value. For this algorithm to work properly, the data collection should be in a sorted form and equally distributed.</p>

<p>Binary search has a huge advantage of time complexity over linear search. Linear search has worst-case complexity of &Omicron;(n) whereas binary search has &Omicron;(log n).</p>

<p>There are cases where the location of target data may be known in advance. For example, in case of a telephone directory, if we want to search the telephone number of Morphius. Here, linear search and even binary search will seem slow as we can directly jump to memory space where the names start from 'M' are stored.</p>

<h2>Positioning in Binary Search</h2>

<p>In binary search, if the desired data is not found then the rest of the list is divided in two parts, lower and higher. The search is carried out in either of them.</p>

<p>Even when the data is sorted, binary search does not take advantage to probe the position of the desired data.</p>

<h2>Position Probing in Interpolation Search</h2>

<p>Interpolation search finds a particular item by computing the probe position. Initially, the probe position is the position of the middle most item of the collection.</p>

<p>If a match occurs, then the index of the item is returned. To split the list into two parts, we use the following method &minus;</p>

<p>If the middle item is greater than the item, then the probe position is again calculated in the sub-array to the right of the middle item. Otherwise, the item is searched in the subarray to the left of the middle item. This process continues on the sub-array as well until the size of subarray reduces to zero.</p>

<p>Runtime complexity of interpolation search algorithm is <b>&Omicron;(log (log n))</b> as compared to <b>&Omicron;(log n)</b> of BST in favorable situations.</p>

<h3>Algorithm</h3>

<p>As it is an improvisation of the existing BST algorithm, we are mentioning the steps to search the 'target' data value index, using position probing &minus;</p>

<h2>Pseudocode</h2>

<p>To know about the implementation of interpolation search in C programming language, <a href="/data_structures_algorithms/interpolation_search_in_c.htm" >click here</a>.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate" >
mid = Lo &plus; ((Hi - Lo) / (A[Hi] - A[Lo])) * (X - A[Lo])

where −
   A    = list
   Lo   = Lowest index of the list
   Hi   = Highest index of the list
   A[n] = Value stored at index n in the list
</pre>
<p>If the middle item is greater than the item, then the probe position is again calculated in the sub-array to the right of the middle item. Otherwise, the item is searched in the subarray to the left of the middle item. This process continues on the sub-array as well until the size of subarray reduces to zero.</p>
<p>Runtime complexity of interpolation search algorithm is <b>&Omicron;(log (log n))</b> as compared to <b>&Omicron;(log n)</b> of BST in favorable situations.</p>
<h3>Algorithm</h3>
<p>As it is an improvisation of the existing BST algorithm, we are mentioning the steps to search the 'target' data value index, using position probing &minus;</p>
<pre class="result notranslate">
Step 1 &minus; Start searching <b>data</b> from middle of the list.
Step 2 &minus; If it is a match, return the index of the item, and exit.
Step 3 &minus; If it is not a match, probe position.
Step 4 &minus; Divide the list using probing formula and find the new midle.
Step 5 &minus; If data is greater than middle, search in higher sub-list.
Step 6 &minus; If data is smaller than middle, search in lower sub-list.
Step 7 &minus; Repeat until match.
</pre>
<h2>Pseudocode</h2>
<pre class="prettyprint notranslate">
A &rarr; Array list
N &rarr; Size of A
X &rarr; Target Value

Procedure Interpolation_Search()

   Set Lo  &rarr;  0
   Set Mid &rarr; -1
   Set Hi  &rarr;  N-1

   While X does not match
   
      if Lo equals to Hi OR A[Lo] equals to A[Hi]
         EXIT: Failure, Target not found
      end if
      
      Set Mid = Lo + ((Hi - Lo) / (A[Hi] - A[Lo])) * (X - A[Lo]) 

      if A[Mid] = X
         EXIT: Success, Target found at Mid
      else 
         if A[Mid] &lt; X
            Set Lo to Mid+1
         else if A[Mid] &gt; X
            Set Hi to Mid-1
         end if
      end if
 
   End While

End Procedure
</pre>

<title>Data Structures and Algorithms Hash Table</title>

<h1>Data Structure and Algorithms - Hash Table</h1>

<p>Hash Table is a data structure which stores data in an associative manner. In a hash table, data is stored in an array format, where each data value has its own unique index value. Access of data becomes very fast if we know the index of the desired data.</p>

<p>Thus, it becomes a data structure in which insertion and search operations are very fast irrespective of the size of the data. Hash Table uses an array as a storage medium and uses hash technique to generate an index where an element is to be inserted or is to be located from.</p>

<h2>Hashing</h2>

<p>Hashing is a technique to convert a range of key values into a range of indexes of an array. We're going to use modulo operator to get a range of key values. Consider an example of hash table of size 20, and the following items are to be stored. Item are in the (key,value) format.</p>

<h2>Linear Probing</h2>

<p>As we can see, it may happen that the hashing technique is used to create an already used index of the array. In such a case, we can search the next empty location in the array by looking into the next cell until we find an empty cell. This technique is called linear probing.</p>

<h2>Basic Operations</h2>

<p>Following are the basic primary operations of a hash table.</p>

<p><b>Search</b> &minus; Searches an element in a hash table.</p>

<p><b>Insert</b> &minus; inserts an element in a hash table.</p>

<p><b>delete</b> &minus; Deletes an element from a hash table.</p>

<h2>DataItem</h2>

<p>Define a data item having some data and key, based on which the search is to be conducted in a hash table.</p>

<h2>Hash Method</h2>

<p>Define a hashing method to compute the hash code of the key of the data item.</p>

<h2>Search Operation</h2>

<p>Whenever an element is to be searched, compute the hash code of the key passed and locate the element using that hash code as index in the array. Use linear probing to get the element ahead if the element is not found at the computed hash code.</p>

<h3>Example</h3>

<h2>Insert Operation</h2>

<p>Whenever an element is to be inserted, compute the hash code of the key passed and locate the index using that hash code as an index in the array. Use linear probing for empty location, if an element is found at the computed hash code.</p>

<h3>Example</h3>

<h2>Delete Operation</h2>

<p>Whenever an element is to be deleted, compute the hash code of the key passed and locate the index using that hash code as an index in the array. Use linear probing to get the element ahead if an element is not found at the computed hash code. When found, store a dummy item there to keep the performance of the hash table intact.</p>

<h3>Example</h3>

<p>To know about hash implementation in C programming language, please <a href="/data_structures_algorithms/hash_table_program_in_c.htm">click here</a>.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
struct DataItem {
   int data;   
   int key;
};
</pre>
<h2>Hash Method</h2>
<p>Define a hashing method to compute the hash code of the key of the data item.</p>
<pre class="prettyprint notranslate">
int hashCode(int key){
   return key % SIZE;
}
</pre>
<h2>Search Operation</h2>
<p>Whenever an element is to be searched, compute the hash code of the key passed and locate the element using that hash code as index in the array. Use linear probing to get the element ahead if the element is not found at the computed hash code.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
struct DataItem *search(int key) {
   //get the hash 
   int hashIndex = hashCode(key);
	
   //move in array until an empty 
   while(hashArray[hashIndex] != NULL) {
	
      if(hashArray[hashIndex]-&gt;key == key)
         return hashArray[hashIndex];
			
      //go to next cell
      ++hashIndex;
		
      //wrap around the table
      hashIndex %= SIZE;
   }
	
   return NULL;        
}
</pre>
<h2>Insert Operation</h2>
<p>Whenever an element is to be inserted, compute the hash code of the key passed and locate the index using that hash code as an index in the array. Use linear probing for empty location, if an element is found at the computed hash code.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
void insert(int key,int data) {
   struct DataItem *item = (struct DataItem*) malloc(sizeof(struct DataItem));
   item-&gt;data = data;  
   item-&gt;key = key;     

   //get the hash 
   int hashIndex = hashCode(key);

   //move in array until an empty or deleted cell
   while(hashArray[hashIndex] != NULL &amp;&amp; hashArray[hashIndex]-&gt;key != -1) {
      //go to next cell
      ++hashIndex;
		
      //wrap around the table
      hashIndex %= SIZE;
   }
	
   hashArray[hashIndex] = item;        
}
</pre>
<h2>Delete Operation</h2>
<p>Whenever an element is to be deleted, compute the hash code of the key passed and locate the index using that hash code as an index in the array. Use linear probing to get the element ahead if an element is not found at the computed hash code. When found, store a dummy item there to keep the performance of the hash table intact.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
struct DataItem* delete(struct DataItem* item) {
   int key = item-&gt;key;

   //get the hash 
   int hashIndex = hashCode(key);

   //move in array until an empty 
   while(hashArray[hashIndex] !=NULL) {
	
      if(hashArray[hashIndex]-&gt;key == key) {
         struct DataItem* temp = hashArray[hashIndex]; 
			
         //assign a dummy item at deleted position
         hashArray[hashIndex] = dummyItem; 
         return temp;
      } 
		
      //go to next cell
      ++hashIndex;
		
      //wrap around the table
      hashIndex %= SIZE;
   }  
	
   return NULL;        
}
</pre>

<title>Data Structures and Algorithms Sorting Techniques</title>

<h1>Data Structure - Sorting Techniques</h1>

<p>Sorting refers to arranging data in a particular format. Sorting algorithm specifies the way to arrange data in a particular order. Most common orders are in numerical or lexicographical order.</p>

<p>The importance of sorting lies in the fact that data searching can be optimized to a very high level, if data is stored in a sorted manner. Sorting is also used to represent data in more readable formats. Following are some of the examples of sorting in real-life scenarios &minus;</p>

<p><b>Telephone Directory</b> &minus; The telephone directory stores the telephone numbers of people sorted by their names, so that the names can be searched easily.</p>

<p><b>Dictionary</b> &minus; The dictionary stores words in an alphabetical order so that searching of any word becomes easy.</p>

<h2>In-place Sorting and Not-in-place Sorting</h2>

<p>Sorting algorithms may require some extra space for comparison and temporary storage of few data elements. These algorithms do not require any extra space and sorting is said to happen in-place, or for example, within the array itself. This is called <b>in-place sorting</b>. Bubble sort is an example of in-place sorting.</p>

<p>However, in some sorting algorithms, the program requires space which is more than or equal to the elements being sorted. Sorting which uses equal or more space is called <b>not-in-place sorting</b>. Merge-sort is an example of not-in-place sorting.</p>

<h2>Stable and Not Stable Sorting</h2>

<p>If a sorting algorithm, after sorting the contents, does not change the sequence of similar content in which they appear, it is called <b>stable sorting</b>.</p>

<p>If a sorting algorithm, after sorting the contents, changes the sequence of similar content in which they appear, it is called <b>unstable sorting</b>.</p>

<p>Stability of an algorithm matters when we wish to maintain the sequence of original elements, like in a tuple for example.</p>

<h2>Adaptive and Non-Adaptive Sorting Algorithm</h2>

<p>A sorting algorithm is said to be adaptive, if it takes advantage of already 'sorted' elements in the list that is to be sorted. That is, while sorting if the source list has some element already sorted, adaptive algorithms will take this into account and will try not to re-order them.</p>

<p>A non-adaptive algorithm is one which does not take into account the elements which are already sorted. They try to force every single element to be re-ordered to confirm their sortedness.</p>

<h2>Important Terms</h2>

<p>Some terms are generally coined while discussing sorting techniques, here is a brief introduction to them &minus;</p>

<h3>Increasing Order</h3>

<p>A sequence of values is said to be in <b>increasing order</b>, if the successive element is greater than the previous one. For example, 1, 3, 4, 6, 8, 9 are in increasing order, as every next element is greater than the previous element.</p>

<h3>Decreasing Order</h3>

<p>A sequence of values is said to be in <b>decreasing order</b>, if the successive element is less than the current one. For example, 9, 8, 6, 4, 3, 1 are in decreasing order, as every next element is less than the previous element.</p>

<h3>Non-Increasing Order</h3>

<p>A sequence of values is said to be in <b>non-increasing order</b>, if the successive element is less than or equal to its previous element in the sequence. This order occurs when the sequence contains duplicate values. For example, 9, 8, 6, 3, 3, 1 are in non-increasing order, as every next element is less than or equal to (in case of 3) but not greater than any previous element.</p>

<h3>Non-Decreasing Order</h3>

<p>A sequence of values is said to be in <b>non-decreasing order</b>, if the successive element is greater than or equal to its previous element in the sequence. This order occurs when the sequence contains duplicate values. For example, 1, 3, 3, 6, 8, 9 are in non-decreasing order, as every next element is greater than or equal to (in case of 3) but not less than the previous one.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Data Structures and Algorithms Bubble Sort</title>

<h1>Data Structure - Bubble Sort Algorithm</h1>

<p>Bubble sort is a simple sorting algorithm. This sorting algorithm is comparison-based algorithm in which each pair of adjacent elements is compared and the elements are swapped if they are not in order. This algorithm is not suitable for large data sets as its average and worst case complexity are of &Omicron;(n<sup>2</sup>) where <b>n</b> is the number of items.</p>

<h2>How Bubble Sort Works?</h2>

<p>We take an unsorted array for our example. Bubble sort takes &Omicron;(n<sup>2</sup>) time so we're keeping it short and precise.</p>

<p>Bubble sort starts with very first two elements, comparing them to check which one is greater.</p>

<p>In this case, value 33 is greater than 14, so it is already in sorted locations. Next, we compare 33 with 27.</p>

<p>We find that 27 is smaller than 33 and these two values must be swapped.</p>

<p>The new array should look like this &minus;</p>

<p>Next we compare 33 and 35. We find that both are in already sorted positions.</p>

<p>Then we move to the next two values, 35 and 10.</p>

<p>We know then that 10 is smaller 35. Hence they are not sorted.</p>

<p>We swap these values. We find that we have reached the end of the array. After one iteration, the array should look like this &minus;</p>

<p>To be precise, we are now showing how an array should look like after each iteration. After the second iteration, it should look like this &minus;</p>

<p>Notice that after each iteration, at least one value moves at the end.</p>

<p>And when there's no swap required, bubble sorts learns that an array is completely sorted.</p>

<p>Now we should look into some practical aspects of bubble sort.</p>

<h2>Algorithm</h2>

<p>We assume <b>list</b> is an array of <b>n</b> elements. We further assume that <b>swap</b> function swaps the values of the given array elements.</p>

<h2>Pseudocode</h2>

<p>We observe in algorithm that Bubble Sort compares each pair of array element unless the whole array is completely sorted in an ascending order. This may cause a few complexity issues like what if the array needs no more swapping as all the elements are already ascending.</p>

<p>To ease-out the issue, we use one flag variable <b>swapped</b> which will help us see if any swap has happened or not. If no swap has occurred, i.e. the array requires no more processing to be sorted, it will come out of the loop.</p>

<p>Pseudocode of BubbleSort algorithm can be written as follows &minus;</p>

<h2>Implementation</h2>

<p>One more issue we did not address in our original algorithm and its improvised pseudocode, is that, after every iteration the highest values settles down at the end of the array. Hence, the next iteration need not include already sorted elements. For this purpose, in our implementation, we restrict the inner loop to avoid already sorted values.</p>

<p>To know about bubble sort implementation in C programming language, please <a href="/data_structures_algorithms/bubble_sort_program_in_c.htm">click here</a>.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
begin BubbleSort(list)

   for all elements of list
      if list[i] &gt; list[i+1]
         swap(list[i], list[i+1])
      end if
   end for
   
   return list
   
end BubbleSort
</pre> 
<h2>Pseudocode</h2>
<p>We observe in algorithm that Bubble Sort compares each pair of array element unless the whole array is completely sorted in an ascending order. This may cause a few complexity issues like what if the array needs no more swapping as all the elements are already ascending.</p>
<p>To ease-out the issue, we use one flag variable <b>swapped</b> which will help us see if any swap has happened or not. If no swap has occurred, i.e. the array requires no more processing to be sorted, it will come out of the loop.</p>
<p>Pseudocode of BubbleSort algorithm can be written as follows &minus;</p>
<pre class="prettyprint notranslate">
procedure bubbleSort( list : array of items )

   loop = list.count;
   
   for i = 0 to loop-1 do:
      swapped = false
		
      for j = 0 to loop-1 do:
      
         /* compare the adjacent elements */   
         if list[j] &gt; list[j+1] then
            /* swap them */
            swap( list[j], list[j+1] )		 
            swapped = true
         end if
         
      end for
      
      /*if no number was swapped that means 
      array is sorted now, break the loop.*/
      
      if(not swapped) then
         break
      end if
      
   end for
   
end procedure return list
</pre>

<title>Data Structures and Algorithms Insertion Sort</title>

<h1>Data Structure and Algorithms Insertion Sort</h1>

<p>This is an in-place comparison-based sorting algorithm. Here, a sub-list is maintained which is always sorted. For example, the lower part of an array is maintained to be sorted. An element which is to be 'insert'ed in this sorted sub-list, has to find its appropriate place and then it has to be inserted there. Hence the name, <b>insertion sort</b>.</p>

<p>The array is searched sequentially and unsorted items are moved and inserted into the sorted sub-list (in the same array). This algorithm is not suitable for large data sets as its average and worst case complexity are of &Omicron;(n<sup>2</sup>), where <b>n</b> is the number of items.</p>

<h2>How Insertion Sort Works?</h2>

<p>We take an unsorted array for our example.</p>

<p>Insertion sort compares the first two elements.</p>

<p>It finds that both 14 and 33 are already in ascending order. For now, 14 is in sorted sub-list.</p>

<p>Insertion sort moves ahead and compares 33 with 27.</p>

<p>And finds that 33 is not in the correct position.</p>

<p>It swaps 33 with 27. It also checks with all the elements of sorted sub-list. Here we see that the sorted sub-list has only one element 14, and 27 is greater than 14. Hence, the sorted sub-list remains sorted after swapping.</p>

<p>By now we have 14 and 27 in the sorted sub-list. Next, it compares 33 with 10.</p>

<p>These values are not in a sorted order.</p>

<p>So we swap them.</p>

<p>However, swapping makes 27 and 10 unsorted.</p>

<p>Hence, we swap them too.</p>

<p>Again we find 14 and 10 in an unsorted order.</p>

<p>We swap them again. By the end of third iteration, we have a sorted sub-list of 4 items.</p>

<p>This process goes on until all the unsorted values are covered in a sorted sub-list. Now we shall see some programming aspects of insertion sort.</p>

<h3>Algorithm</h3>

<p>Now we have a bigger picture of how this sorting technique works, so we can derive simple steps by which we can achieve insertion sort.</p>

<h2>Pseudocode</h2>

<p>To know about insertion sort implementation in C programming language, please <a href="/data_structures_algorithms/insertion_sort_program_in_c.htm">click here</a>.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
<b>Step 1</b> &minus; If it is the first element, it is already sorted. return 1;
<b>Step 2</b> &minus; Pick next element
<b>Step 3</b> &minus; Compare with all elements in the sorted sub-list
<b>Step 4</b> &minus; Shift all the elements in the sorted sub-list that is greater than the 
         value to be sorted
<b>Step 5</b> &minus; Insert the value
<b>Step 6</b> &minus; Repeat until list is sorted
</pre>    
<h2>Pseudocode</h2>
<pre class="prettyprint notranslate">
procedure insertionSort( A : array of items )
   int holePosition
   int valueToInsert
	
   for i = 1 to length(A) inclusive do:
	
      /* select value to be inserted */
      valueToInsert = A[i]
      holePosition = i
      
      /*locate hole position for the element to be inserted */
		
      while holePosition &gt; 0 and A[holePosition-1] &gt; valueToInsert do:
         A[holePosition] = A[holePosition-1]
         holePosition = holePosition -1
      end while
		
      /* insert the number at hole position */
      A[holePosition] = valueToInsert
      
   end for
	
end procedure
</pre>

<title>Data Structures and Algorithms Selection Sort</title>

<h1>Data Structure and Algorithms Selection Sort</h1>

<p>Selection sort is a simple sorting algorithm. This sorting algorithm is an in-place comparison-based algorithm in which the list is divided into two parts, the sorted part at the left end and the unsorted part at the right end. Initially, the sorted part is empty and the unsorted part is the entire list.</p>

<p>The smallest element is selected from the unsorted array and swapped with the leftmost element, and that element becomes a part of the sorted array. This process continues moving unsorted array boundary by one element to the right.</p>

<p>This algorithm is not suitable for large data sets as its average and worst case complexities are of &Omicron;(n<sup>2</sup>), where <b>n</b> is the number of items.</p>

<h2>How Selection Sort Works?</h2>

<p>Consider the following depicted array as an example.</p>

<p>For the first position in the sorted list, the whole list is scanned sequentially. The first position where 14 is stored presently, we search the whole list and find that 10 is the lowest value.</p>

<p>So we replace 14 with 10. After one iteration 10, which happens to be the minimum value in the list, appears in the first position of the sorted list.</p>

<p>For the second position, where 33 is residing, we start scanning the rest of the list in a linear manner.</p>

<p>We find that 14 is the second lowest value in the list and it should appear at the second place. We swap these values.</p>

<p>After two iterations, two least values are positioned at the beginning in a sorted manner.</p>

<p>The same process is applied to the rest of the items in the array.</p>

<p>Following is a pictorial depiction of the entire sorting process &minus;</p>

<p>Now, let us learn some programming aspects of selection sort.</p>

<h3>Algorithm</h3>

<h3>Pseudocode</h3>

<p>To know about selection sort implementation in C programming language, please <a href="/data_structures_algorithms/selection_sort_program_in_c.htm">click here</a>.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
<b>Step 1</b> &minus; Set MIN to location 0
<b>Step 2</b> &minus; Search the minimum element in the list
<b>Step 3</b> &minus; Swap with value at location MIN
<b>Step 4</b> &minus; Increment MIN to point to next element
<b>Step 5</b> &minus; Repeat until list is sorted
</pre>    
<h3>Pseudocode</h3>
<pre class="prettyprint notranslate">
procedure selection sort 
   list  : array of items
   n     : size of list

   for i = 1 to n - 1
   /* set current element as minimum*/
      min = i    
  
      /* check the element to be minimum */

      for j = i&plus;1 to n 
         if list[j] &lt; list[min] then
            min = j;
         end if
      end for

      /* swap the minimum element with the current element*/
      if indexMin != i  then
         swap list[min] and list[i]
      end if

   end for
	
end procedure
</pre>

<title>Data Structures and Merge Sort Algorithms</title>

<h1>Data Structures - Merge Sort Algorithm</h1>

<p>Merge sort is a sorting technique based on divide and conquer technique. With worst-case time complexity being &Omicron;(n log n), it is one of the most respected algorithms.</p>

<p>Merge sort first divides the array into equal halves and then combines them in a sorted manner.</p>

<h2>How Merge Sort Works?</h2>

<p>To understand merge sort, we take an unsorted array as the following &minus;</p>

<p>We know that merge sort first divides the whole array iteratively into equal halves unless the atomic values are achieved. We see here that an array of 8 items is divided into two arrays of size 4.</p>

<p>This does not change the sequence of appearance of items in the original. Now we divide these two arrays into halves.</p>

<p>We further divide these arrays and we achieve atomic value which can no more be divided.</p>

<p>Now, we combine them in exactly the same manner as they were broken down. Please note the color codes given to these lists.</p>

<p>We first compare the element for each list and then combine them into another list in a sorted manner. We see that 14 and 33 are in sorted positions. We compare 27 and 10 and in the target list of 2 values we put 10 first, followed by 27. We change the order of 19 and 35 whereas 42 and 44 are placed sequentially.</p>

<p>In the next iteration of the combining phase, we compare lists of two data values, and merge them into a list of found data values placing all in a sorted order.</p>

<p>After the final merging, the list should look like this &minus;</p>

<p>Now we should learn some programming aspects of merge sorting.</p>

<h3>Algorithm</h3>

<p>Merge sort keeps on dividing the list into equal halves until it can no more be divided. By definition, if it is only one element in the list, it is sorted. Then, merge sort combines the smaller sorted lists keeping the new list sorted too.</p>

<h3>Pseudocode</h3>

<p>We shall now see the pseudocodes for merge sort functions. As our algorithms point out two main functions − divide &amp; merge.</p>

<p>Merge sort works with recursion and we shall see our implementation in the same way.</p>

<p>To know about merge sort implementation in C programming language, please <a href="/data_structures_algorithms/merge_sort_program_in_c.htm">click here</a>.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
<b>Step 1</b> &minus; if it is only one element in the list it is already sorted, return.
<b>Step 2</b> &minus; divide the list recursively into two halves until it can no more be divided.
<b>Step 3</b> &minus; merge the smaller lists into new list in sorted order.
</pre>
<h3>Pseudocode</h3>
<p>We shall now see the pseudocodes for merge sort functions. As our algorithms point out two main functions − divide &amp; merge.</p>
<p>Merge sort works with recursion and we shall see our implementation in the same way.</p>
<pre class="prettyprint notranslate">
procedure mergesort( var a as array )
   if ( n == 1 ) return a

   var l1 as array = a[0] ... a[n/2]
   var l2 as array = a[n/2+1] ... a[n]

   l1 = mergesort( l1 )
   l2 = mergesort( l2 )

   return merge( l1, l2 )
end procedure

procedure merge( var a as array, var b as array )

   var c as array

   while ( a and b have elements )
      if ( a[0] &gt; b[0] )
         add b[0] to the end of c
         remove b[0] from b
      else
         add a[0] to the end of c
         remove a[0] from a
      end if
   end while
   
   while ( a has elements )
      add a[0] to the end of c
      remove a[0] from a
   end while
   
   while ( b has elements )
      add b[0] to the end of c
      remove b[0] from b
   end while
   
   return c
	
end procedure
</pre>

<title>Data Structures and Algorithms Shell Sort</title>

<h1>Data Structure and Algorithms - Shell Sort</h1>

<p>Shell sort is a highly efficient sorting algorithm and is based on insertion sort algorithm. This algorithm avoids large shifts as in case of insertion sort, if the smaller value is to the far right and has to be moved to the far left.</p>

<p>This algorithm uses insertion sort on a widely spread elements, first to sort them and then sorts the less widely spaced elements. This spacing is termed as <b>interval</b>. This interval is calculated based on Knuth's formula as &minus;</p>

<h3>Knuth's Formula</h3>

<p>This algorithm is quite efficient for medium-sized data sets as its average and worst case complexity are of &Omicron;(n), where <b>n</b> is the number of items.</p>

<h2>How Shell Sort Works?</h2>

<p>Let us consider the following example to have an idea of how shell sort works. We take the same array we have used in our previous examples. For our example and ease of understanding, we take the interval of 4. Make a virtual sub-list of all values located at the interval of 4 positions. Here these values are {35, 14}, {33, 19}, {42, 27} and {10, 44}</p>

<p>We compare values in each sub-list and swap them (if necessary) in the original array. After this step, the new array should look like this &minus;</p>

<p>Then, we take interval of 2 and this gap generates two sub-lists - {14, 27, 35, 42}, {19, 10, 33, 44}</p>

<p>We compare and swap the values, if required, in the original array. After this step, the array should look like this &minus;</p>

<p>Finally, we sort the rest of the array using interval of value 1. Shell sort uses insertion sort to sort the array.</p>

<p>Following is the step-by-step depiction &minus;</p>

<p>We see that it required only four swaps to sort the rest of the array.</p>

<h3>Algorithm</h3>

<p>Following is the algorithm for shell sort.</p>

<h2>Pseudocode</h2>

<p>Following is the pseudocode for shell sort.</p>

<p>To know about shell sort implementation in C programming language, please <a href="/data_structures_algorithms/shell_sort_program_in_c.htm">click here</a>.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
h = h * 3 &plus; 1

where &minus;
   h is interval with initial value 1
</pre>
<p>This algorithm is quite efficient for medium-sized data sets as its average and worst case complexity are of &Omicron;(n), where <b>n</b> is the number of items.</p>
<h2>How Shell Sort Works?</h2>
<p>Let us consider the following example to have an idea of how shell sort works. We take the same array we have used in our previous examples. For our example and ease of understanding, we take the interval of 4. Make a virtual sub-list of all values located at the interval of 4 positions. Here these values are {35, 14}, {33, 19}, {42, 27} and {10, 44}</p>
<img src="/data_structures_algorithms/images/shell_sort_gap_4.jpg" alt="Shell Sort" />   
<p>We compare values in each sub-list and swap them (if necessary) in the original array. After this step, the new array should look like this &minus;</p>
<img src="/data_structures_algorithms/images/shell_sort_step_1.jpg" alt="Shell Sort" />  
<p>Then, we take interval of 2 and this gap generates two sub-lists - {14, 27, 35, 42}, {19, 10, 33, 44}</p>
<img src="/data_structures_algorithms/images/shell_sort_gap_2.jpg" alt="Shell Sort" />   
<p>We compare and swap the values, if required, in the original array. After this step, the array should look like this &minus;</p>
<img src="/data_structures_algorithms/images/shell_sort_step_2.jpg" alt="Shell Sort" />  
<p>Finally, we sort the rest of the array using interval of value 1. Shell sort uses insertion sort to sort the array.</p>
<p>Following is the step-by-step depiction &minus;</p>
<img src="/data_structures_algorithms/images/shell_sort.jpg" alt="Shell Sort" />  
<p>We see that it required only four swaps to sort the rest of the array.</p>
<h3>Algorithm</h3>
<p>Following is the algorithm for shell sort.</p>
<pre class="result notranslate">
<b>Step 1</b> &minus; Initialize the value of <i>h</i>
<b>Step 2</b> &minus; Divide the list into smaller sub-list of equal interval <i>h</i>
<b>Step 3</b> &minus; Sort these sub-lists using <b>insertion sort</b>
<b>Step 3</b> &minus; Repeat until complete list is sorted
</pre>
<h2>Pseudocode</h2>
<p>Following is the pseudocode for shell sort.</p>
<pre class="prettyprint notranslate">
procedure shellSort()
   A : array of items 
	
   /* calculate interval*/
   while interval &lt; A.length /3 do:
      interval = interval * 3 + 1	    
   end while
   
   while interval &gt; 0 do:

      for outer = interval; outer &lt; A.length; outer ++ do:

      /* select value to be inserted */
      valueToInsert = A[outer]
      inner = outer;

         /*shift element towards right*/
         while inner &gt; interval -1 &amp;&amp; A[inner - interval] &gt;= valueToInsert do:
            A[inner] = A[inner - interval]
            inner = inner - interval
         end while

      /* insert the number at hole position */
      A[inner] = valueToInsert

      end for

   /* calculate interval*/
   interval = (interval -1) /3;	  

   end while
   
end procedure
</pre> 
<p>To know about shell sort implementation in C programming language, please <a href="/data_structures_algorithms/shell_sort_program_in_c.htm">click here</a>.</p>
</pre>

<title>Data Structures and Algorithms Quick Sort</title>

<h1>Data Structure and Algorithms - Quick Sort</h1>

<p>Quick sort is a highly efficient sorting algorithm and is based on partitioning of array of data into smaller arrays. A large array is partitioned into two arrays one of which holds values smaller than the specified value, say pivot, based on which the partition is made and another array holds values greater than the pivot value.</p>

<p>Quick sort partitions an array and then calls itself recursively twice to sort the two resulting subarrays. This algorithm is quite efficient for large-sized data sets as its average and worst case complexity are of &Omicron;(n<sup>2</sup>), where <b>n</b> is the number of items.</p>

<h2>Partition in Quick Sort</h2>

<p>Following animated representation explains how to find the pivot value in an array.</p>

<p>The pivot value divides the list into two parts. And recursively, we find the pivot for each sub-lists until all lists contains only one element.</p>

<h2>Quick Sort Pivot Algorithm</h2>

<p>Based on our understanding of partitioning in quick sort, we will now try to write an algorithm for it, which is as follows.</p>

<h2>Quick Sort Pivot Pseudocode</h2>

<p>The pseudocode for the above algorithm can be derived as &minus;</p>

<h2>Quick Sort Algorithm</h2>

<p>Using pivot algorithm recursively, we end up with smaller possible partitions. Each partition is then processed for quick sort. We define recursive algorithm for quicksort as follows &minus;</p>

<h2>Quick Sort Pseudocode</h2>

<p>To get more into it, let see the pseudocode for quick sort algorithm &minus;</p>

<p>To know about quick sort implementation in C programming language, please <a href="/data_structures_algorithms/quick_sort_program_in_c.htm">click here</a>.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
<b>Step 1</b> &minus; Choose the highest index value has pivot
<b>Step 2</b> &minus; Take two variables to point left and right of the list excluding pivot
<b>Step 3</b> &minus; left points to the low index
<b>Step 4</b> &minus; right points to the high
<b>Step 5</b> &minus; while value at left is less than pivot move right
<b>Step 6</b> &minus; while value at right is greater than pivot move left
<b>Step 7</b> &minus; if both step 5 and step 6 does not match swap left and right
<b>Step 8</b> &minus; if left &ge; right, the point where they met is new pivot
</pre>
<h2>Quick Sort Pivot Pseudocode</h2>
<p>The pseudocode for the above algorithm can be derived as &minus;</p>
<pre class="prettyprint notranslate">
function partitionFunc(left, right, pivot)
   leftPointer = left
   rightPointer = right - 1

   while True do
      while A[&plus;&plus;leftPointer] &lt; pivot do
         //do-nothing            
      end while
		
      while rightPointer &gt; 0 &amp;&amp; A[--rightPointer] &gt; pivot do
         //do-nothing         
      end while
		
      if leftPointer &gt;= rightPointer
         break
      else                
         swap leftPointer,rightPointer
      end if
		
   end while 
	
   swap leftPointer,right
   return leftPointer
	
end function
</pre>
<h2>Quick Sort Algorithm</h2>
<p>Using pivot algorithm recursively, we end up with smaller possible partitions. Each partition is then processed for quick sort. We define recursive algorithm for quicksort as follows &minus;</p>
<pre class="result notranslate">
<b>Step 1</b> &minus; Make the right-most index value pivot
<b>Step 2</b> &minus; partition the array using pivot value
<b>Step 3</b> &minus; quicksort left partition recursively
<b>Step 4</b> &minus; quicksort right partition recursively
</pre>
<h2>Quick Sort Pseudocode</h2>
<p>To get more into it, let see the pseudocode for quick sort algorithm &minus;</p>
<pre class="prettyprint notranslate">
procedure quickSort(left, right)

   if right-left &lt;= 0
      return
   else     
      pivot = A[right]
      partition = partitionFunc(left, right, pivot)
      quickSort(left,partition-1)
      quickSort(partition&plus;1,right)    
   end if		
   
end procedure
</pre>

<title>Data Structures and Algorithms Graph Data Structure</title>

<h1>Data Structure - Graph Data Structure</h1>

<p>A graph is a pictorial representation of a set of objects where some pairs of objects are connected by links. The interconnected objects are represented by points termed as <b>vertices</b>, and the links that connect the vertices are called <b>edges</b>.</p>

<p>Formally, a graph is a pair of sets <b>(V, E)</b>, where <b>V</b> is the set of vertices and <b>E</b> is the set of edges, connecting the pairs of vertices. Take a look at the following graph &minus;</p>

<p>In the above graph,</p>

<h2>Graph Data Structure</h2>

<p>Mathematical graphs can be represented in data structure. We can represent a graph using an array of vertices and a two-dimensional array of edges. Before we proceed further, let's familiarize ourselves with some important terms &minus;</p>

<p><b>Vertex</b> &minus; Each node of the graph is represented as a vertex. In the following example, the labeled circle represents vertices. Thus, A to G are vertices. We can represent them using an array as shown in the following image. Here A can be identified by index 0. B can be identified using index 1 and so on.</p>

<p><b>Edge</b> &minus; Edge represents a path between two vertices or a line between two vertices. In the following example, the lines from A to B, B to C, and so on represents edges. We can use a two-dimensional array to represent an array as shown in the following image. Here AB can be represented as 1 at row 0, column 1, BC as 1 at row 1, column 2 and so on, keeping other combinations as 0.</p>

<p><b>Adjacency</b> &minus; Two node or vertices are adjacent if they are connected to each other through an edge. In the following example, B is adjacent to A, C is adjacent to B, and so on.</p>

<p><b>Path</b> &minus; Path represents a sequence of edges between the two vertices. In the following example, ABCD represents a path from A to D.</p>

<h2>Basic Operations</h2>

<p>Following are basic primary operations of a Graph &minus;</p>

<p><b>Add Vertex</b> &minus; Adds a vertex to the graph.</p>

<p><b>Add Edge</b> &minus; Adds an edge between the two vertices of the graph.</p>

<p><b>Display Vertex</b> &minus; Displays a vertex of the graph.</p>

<p>To know more about Graph, please read <a href="/graph_theory/index.htm">Graph Theory Tutorial</a>. We shall learn about traversing a graph in the coming chapters.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Data Structures and Depth First Traversal</title>

<h1>Data Structure - Depth First Traversal</h1>

<p>Depth First Search (DFS) algorithm traverses a graph in a depthward motion and uses a stack to remember to get the next vertex to start a search, when a dead end occurs in any iteration.</p>

<p>As in the example given above, DFS algorithm traverses from A to B to C to D first then to E, then to F and lastly to G. It employs the following rules.</p>

<p><b>Rule 1</b> &minus; Visit the adjacent unvisited vertex. Mark it as visited. Display it. Push it in a stack.</p>

<p><b>Rule 2</b> &minus; If no adjacent vertex is found, pop up a vertex from the stack. (It will pop up all the vertices from the stack, which do not have adjacent vertices.)</p>

<p><b>Rule 3</b> &minus; Repeat Rule 1 and Rule 2 until the stack is empty.</p>

<p>As <b>C</b> does not have any unvisited adjacent node so we keep popping the stack until we find a node that has an unvisited adjacent node. In this case, there's none and we keep popping until the stack is empty.</p>

<p>To know about the implementation of this algorithm in C programming language, <a href="/data_structures_algorithms/depth_first_traversal_in_c.htm">click here</a>.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Data Structures and Breadth First Traversal</title>

<h1>Data Structure - Breadth First Traversal</h1>

<p>Breadth First Search (BFS) algorithm traverses a graph in a breadthward motion and uses a queue to remember to get the next vertex to start a search, when a dead end occurs in any iteration.</p>

<p>As in the example given above, BFS algorithm traverses from A to B to E to F first then to C and G lastly to D. It employs the following rules.</p>

<p><b>Rule 1</b> &minus; Visit the adjacent unvisited vertex. Mark it as visited. Display it. Insert it in a queue.</p>

<p><b>Rule 2</b> &minus; If no adjacent vertex is found, remove the first vertex from the queue.</p>

<p><b>Rule 3</b> &minus; Repeat Rule 1 and Rule 2 until the queue is empty.</p>

<p>At this stage, we are left with no unmarked (unvisited) nodes. But as per the algorithm we keep on dequeuing in order to get all unvisited nodes. When the queue gets emptied, the program is over.</p>

<p>The implementation of this algorithm in C programming language can be <a href="/data_structures_algorithms/breadth_first_traversal_in_c.htm">seen here</a>.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Data Structures and Algorithms Tree</title>

<h1>Data Structure and Algorithms - Tree</h1>

<p>Tree represents the nodes connected by edges. We will discuss binary tree or binary search tree specifically.</p>

<p>Binary Tree is a special datastructure used for data storage purposes. A binary tree has a special condition that each node can have a maximum of two children. A binary tree has the benefits of both an ordered array and a linked list as search is as quick as in a sorted array and insertion or deletion operation are as fast as in linked list.</p>

<h2>Important Terms</h2>

<p>Following are the important terms with respect to tree.</p>

<p><b>Path</b> &minus; Path refers to the sequence of nodes along the edges of a tree.</p>

<p><b>Root</b> &minus; The node at the top of the tree is called root. There is only one root per tree and one path from the root node to any node.</p>

<p><b>Parent</b> &minus; Any node except the root node has one edge upward to a node called parent.</p>

<p><b>Child</b> &minus; The node below a given node connected by its edge downward is called its child node.</p>

<p><b>Leaf</b> &minus; The node which does not have any child node is called the leaf node.</p>

<p><b>Subtree</b> &minus; Subtree represents the descendants of a node.</p>

<p><b>Visiting</b> &minus; Visiting refers to checking the value of a node when control is on the node.</p>

<p><b>Traversing</b> &minus; Traversing means passing through nodes in a specific order.</p>

<p><b>Levels</b> &minus; Level of a node represents the generation of a node. If the root node is at level 0, then its next child node is at level 1, its grandchild is at level 2, and so on.</p>

<p><b>keys</b> &minus; Key represents a value of a node based on which a search operation is to be carried out for a node.</p>

<h2>Binary Search Tree Representation</h2>

<p>Binary Search tree exhibits a special behavior. A node's left child must have a value less than its parent's value and the node's right child must have a value greater than its parent value.</p>

<p>We're going to implement tree using node object and connecting them through references.</p>

<h2>Tree Node</h2>

<p>The code to write a tree node would be similar to what is given below. It has a data part and references to its left and right child nodes.</p>

<p>In a tree, all nodes share common construct.</p>

<h2>BST Basic Operations</h2>

<p>The basic operations that can be performed on a binary search tree data structure, are the following &minus;</p>

<p><b>Insert</b> &minus; Inserts an element in a tree/create a tree.</p>

<p><b>Search</b> &minus; Searches an element in a tree.</p>

<p><b>Preorder Traversal</b> &minus; Traverses a tree in a pre-order manner.</p>

<p><b>Inorder Traversal</b> &minus; Traverses a tree in an in-order manner.</p>

<p><b>Postorder Traversal</b> &minus; Traverses a tree in a post-order manner.</p>

<p>We shall learn creating (inserting into) a tree structure and searching a data item in a tree in this chapter. We shall learn about tree traversing methods in the coming chapter.</p>

<h2>Insert Operation</h2>

<p>The very first insertion creates the tree. Afterwards, whenever an element is to be inserted, first locate its proper location. Start searching from the root node, then if the data is less than the key value, search for the empty location in the left subtree and insert the data. Otherwise, search for the empty location in the right subtree and insert the data.</p>

<h3>Algorithm</h3>

<h3>Implementation</h3>

<p>The implementation of insert function should look like this &minus;</p>

<h2>Search Operation</h2>

<p>Whenever an element is to be searched, start searching from the root node, then if the data is less than the key value, search for the element in the left subtree. Otherwise, search for the element in the right subtree. Follow the same algorithm for each node.</p>

<h3>Algorithm</h3>

<p>The implementation of this algorithm should look like this.</p>

<p>To know about the implementation of binary search tree data structure, please <a href="/data_structures_algorithms/tree_traversal_in_c.htm"> click here</a>.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
struct node {
   int data;   
   struct node *leftChild;
   struct node *rightChild;
};
</pre>
<p>In a tree, all nodes share common construct.</p>
<h2>BST Basic Operations</h2>
<p>The basic operations that can be performed on a binary search tree data structure, are the following &minus;</p>
<ul class="list">
<li><p><b>Insert</b> &minus; Inserts an element in a tree/create a tree.</p></li>
<li><p><b>Search</b> &minus; Searches an element in a tree.</p></li>
<li><p><b>Preorder Traversal</b> &minus; Traverses a tree in a pre-order manner.</p></li>
<li><p><b>Inorder Traversal</b> &minus; Traverses a tree in an in-order manner.</p></li>
<li><p><b>Postorder Traversal</b> &minus; Traverses a tree in a post-order manner.</p></li>
</ul>
<p>We shall learn creating (inserting into) a tree structure and searching a data item in a tree in this chapter. We shall learn about tree traversing methods in the coming chapter.</p>
<h2>Insert Operation</h2>
<p>The very first insertion creates the tree. Afterwards, whenever an element is to be inserted, first locate its proper location. Start searching from the root node, then if the data is less than the key value, search for the empty location in the left subtree and insert the data. Otherwise, search for the empty location in the right subtree and insert the data.</p>
<h3>Algorithm</h3>
<pre class="prettyprint notranslate">
If root is NULL 
   then create root node
return

If root exists then
   compare the data with node.data
   
   while until insertion position is located

      If data is greater than node.data
         goto right subtree
      else
         goto left subtree

   endwhile 
   
   insert data
	
end If      
</pre>
<h3>Implementation</h3>
<p>The implementation of insert function should look like this &minus;</p>
<pre class="prettyprint notranslate">
void insert(int data) {
   struct node *tempNode = (struct node*) malloc(sizeof(struct node));
   struct node *current;
   struct node *parent;

   tempNode-&gt;data = data;
   tempNode-&gt;leftChild = NULL;
   tempNode-&gt;rightChild = NULL;

   //if tree is empty, create root node
   if(root == NULL) {
      root = tempNode;
   } else {
      current = root;
      parent  = NULL;

      while(1) {                
         parent = current;

         //go to left of the tree
         if(data &lt; parent-&gt;data) {
            current = current-&gt;leftChild;                
            
            //insert to the left
            if(current == NULL) {
               parent-&gt;leftChild = tempNode;
               return;
            }
         }
			
         //go to right of the tree
         else {
            current = current-&gt;rightChild;
            
            //insert to the right
            if(current == NULL) {
               parent-&gt;rightChild = tempNode;
               return;
            }
         }
      }            
   }
}
</pre>
<h2>Search Operation</h2>
<p>Whenever an element is to be searched, start searching from the root node, then if the data is less than the key value, search for the element in the left subtree. Otherwise, search for the element in the right subtree. Follow the same algorithm for each node.</p>
<h3>Algorithm</h3>
<pre class="prettyprint notranslate">
If root.data is equal to search.data
   return root
else
   while data not found

      If data is greater than node.data
         goto right subtree
      else
         goto left subtree
         
      If data found
         return node

   endwhile 
   
   return data not found
   
end if      
</pre>
<p>The implementation of this algorithm should look like this.</p>
<pre class="prettyprint notranslate">
struct node* search(int data) {
   struct node *current = root;
   printf("Visiting elements: ");

   while(current-&gt;data != data) {
      if(current != NULL)
      printf("%d ",current-&gt;data); 
      
      //go to left tree

      if(current-&gt;data &gt; data) {
         current = current-&gt;leftChild;
      }
      //else go to right tree
      else {                
         current = current-&gt;rightChild;
      }

      //not found
      if(current == NULL) {
         return NULL;
      }

      return current;
   }  
}
</pre>

<title>Data Structures and Algorithms Tree Traversal</title>

<h1>Data Structure &amp; Algorithms - Tree Traversal</h1>

<p>Traversal is a process to visit all the nodes of a tree and may print their values too. Because, all nodes are connected via edges (links) we always start from the root (head) node. That is, we cannot randomly access a node in a tree. There are three ways which we use to traverse a tree &minus;</p>

<p>Generally, we traverse a tree to search or locate a given item or key in the tree or to print all the values it contains.</p>

<h2>In-order Traversal</h2>

<p>In this traversal method, the left subtree is visited first, then the root and later the right sub-tree. We should always remember that every node may represent a subtree itself.</p>

<p>If a binary tree is traversed <b>in-order</b>, the output will produce sorted key values in an ascending order.</p>

<p>We start from <b>A</b>, and following in-order traversal, we move to its left subtree <b>B</b>. <b>B</b> is also traversed in-order. The process goes on until all the nodes are visited. The output of inorder traversal of this tree will be &minus;</p>

<h3>Algorithm</h3>

<h2>Pre-order Traversal</h2>

<p>In this traversal method, the root node is visited first, then the left subtree and finally the right subtree.</p>

<p>We start from <b>A</b>, and following pre-order traversal, we first visit <b>A</b> itself and then move to its left subtree <b>B</b>. <b>B</b> is also traversed pre-order. The process goes on until all the nodes are visited. The output of pre-order traversal of this tree will be &minus;</p>

<h3>Algorithm</h3>

<h2>Post-order Traversal</h2>

<p>In this traversal method, the root node is visited last, hence the name. First we traverse the left subtree, then the right subtree and finally the root node.</p>

<p>We start from <b>A</b>, and following pre-order traversal, we first visit the left subtree <b>B</b>. <b>B</b> is also traversed post-order. The process goes on until all the nodes are visited. The output of post-order traversal of this tree will be &minus;</p>

<h3>Algorithm</h3>

<p>To check the C implementation of tree traversing, please <a href="/data_structures_algorithms/tree_traversal_in_c.htm">click here</a>.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
Until all nodes are traversed &minus;
<b>Step 1</b> &minus; Recursively traverse left subtree.
<b>Step 2</b> &minus; Visit root node.
<b>Step 3</b> &minus; Recursively traverse right subtree.
</pre>
<h2>Pre-order Traversal</h2>
<p>In this traversal method, the root node is visited first, then the left subtree and finally the right subtree.</p>
<img src="/data_structures_algorithms/images/preorder_traversal.jpg" alt="Pre Order Traversal" />
<p>We start from <b>A</b>, and following pre-order traversal, we first visit <b>A</b> itself and then move to its left subtree <b>B</b>. <b>B</b> is also traversed pre-order. The process goes on until all the nodes are visited. The output of pre-order traversal of this tree will be &minus;</p>
<p style="text-align:center;"><b><i>A &rarr; B &rarr; D &rarr; E &rarr; C &rarr; F &rarr; G</i></b></p>
<h3>Algorithm</h3>
<pre class="result notranslate">
Until all nodes are traversed &minus;
<b>Step 1</b> &minus; Visit root node.
<b>Step 2</b> &minus; Recursively traverse left subtree.
<b>Step 3</b> &minus; Recursively traverse right subtree.
</pre>
<h2>Post-order Traversal</h2>
<p>In this traversal method, the root node is visited last, hence the name. First we traverse the left subtree, then the right subtree and finally the root node.</p>
<img src="/data_structures_algorithms/images/postorder_traversal.jpg" alt="Post Order Traversal" />
<p>We start from <b>A</b>, and following pre-order traversal, we first visit the left subtree <b>B</b>. <b>B</b> is also traversed post-order. The process goes on until all the nodes are visited. The output of post-order traversal of this tree will be &minus;</p>
<p style="text-align:center;"><b><i>D &rarr; E &rarr; B &rarr; F &rarr; G &rarr; C &rarr; A</i></b></p>
<h3>Algorithm</h3>
<pre class="result notranslate">
Until all nodes are traversed &minus;
<b>Step 1</b> &minus; Recursively traverse left subtree.
<b>Step 2</b> &minus; Recursively traverse right subtree.
<b>Step 3</b> &minus; Visit root node.
</pre>

<title>Data Structures and Algorithms Binary Search Tree</title>

<h1>Data Structure - Binary Search Tree</h1>

<p>A Binary Search Tree (BST) is a tree in which all the nodes follow the below-mentioned properties &minus;</p>

<p>The left sub-tree of a node has a key less than or equal to its parent node's key.</p>

<p>The right sub-tree of a node has a key greater than to its parent node's key.</p>

<p>Thus, BST divides all its sub-trees into two segments; the left sub-tree and the right sub-tree and can be defined as &minus;</p>

<h2>Representation</h2>

<p>BST is a collection of nodes arranged in a way where they maintain BST properties. Each node has a key and an associated value. While searching, the desired key is compared to the keys in BST and if found, the associated value is retrieved.</p>

<p>Following is a pictorial representation of BST &minus;</p>

<p>We observe that the root node key (27) has all less-valued keys on the left sub-tree and the higher valued keys on the right sub-tree.</p>

<h2>Basic Operations</h2>

<p>Following are the basic operations of a tree &minus;</p>

<p><b>Search</b> &minus; Searches an element in a tree.</p>

<p><b>Insert</b> &minus; Inserts an element in a tree.</p>

<p><b>Pre-order Traversal</b> &minus; Traverses a tree in a pre-order manner.</p>

<p><b>In-order Traversal</b> &minus; Traverses a tree in an in-order manner.</p>

<p><b>Post-order Traversal</b> &minus; Traverses a tree in a post-order manner.</p>

<h2>Node</h2>

<p>Define a node having some data, references to its left and right child nodes.</p>

<h2>Search Operation</h2>

<p>Whenever an element is to be searched, start searching from the root node. Then if the data is less than the key value, search for the element in the left subtree. Otherwise, search for the element in the right subtree. Follow the same algorithm for each node.</p>

<h3>Algorithm</h3>

<h2>Insert Operation</h2>

<p>Whenever an element is to be inserted, first locate its proper location. Start searching from the root node, then if the data is less than the key value, search for the empty location in the left subtree and insert the data. Otherwise, search for the empty location in the right subtree and insert the data.</p>

<h3>Algorithm</h3>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
left_subtree (keys)  &le;  node (key)  &le;  right_subtree (keys)
</pre>
<h2>Representation</h2>
<p>BST is a collection of nodes arranged in a way where they maintain BST properties. Each node has a key and an associated value. While searching, the desired key is compared to the keys in BST and if found, the associated value is retrieved.</p>
<p>Following is a pictorial representation of BST &minus;</p>
<img src="/data_structures_algorithms/images/binary_search_tree.jpg" alt="Binary Search Tree" />
<p>We observe that the root node key (27) has all less-valued keys on the left sub-tree and the higher valued keys on the right sub-tree.</p>
<h2>Basic Operations</h2>
<p>Following are the basic operations of a tree &minus;</p>
<ul class="list">
<li><p><b>Search</b> &minus; Searches an element in a tree.</p></li>
<li><p><b>Insert</b> &minus; Inserts an element in a tree.</p></li>
<li><p><b>Pre-order Traversal</b> &minus; Traverses a tree in a pre-order manner.</p></li>
<li><p><b>In-order Traversal</b> &minus; Traverses a tree in an in-order manner.</p></li>
<li><p><b>Post-order Traversal</b> &minus; Traverses a tree in a post-order manner.</p></li>
</ul>
<h2>Node</h2>
<p>Define a node having some data, references to its left and right child nodes.</p>
<pre class="prettyprint notranslate">
struct node {
   int data;   
   struct node *leftChild;
   struct node *rightChild;
};
</pre>
<h2>Search Operation</h2>
<p>Whenever an element is to be searched, start searching from the root node. Then if the data is less than the key value, search for the element in the left subtree. Otherwise, search for the element in the right subtree. Follow the same algorithm for each node.</p>
<h3>Algorithm</h3>
<pre class="prettyprint notranslate">
struct node* search(int data){
   struct node *current = root;
   printf("Visiting elements: ");
	
   while(current-&gt;data != data){
	
      if(current != NULL) {
         printf("%d ",current-&gt;data);
			
         //go to left tree
         if(current-&gt;data &gt; data){
            current = current-&gt;leftChild;
         }//else go to right tree
         else {                
            current = current-&gt;rightChild;
         }
			
         //not found
         if(current == NULL){
            return NULL;
         }
      }			
   }
   return current;
}
</pre>
<h2>Insert Operation</h2>
<p>Whenever an element is to be inserted, first locate its proper location. Start searching from the root node, then if the data is less than the key value, search for the empty location in the left subtree and insert the data. Otherwise, search for the empty location in the right subtree and insert the data.</p>
<h3>Algorithm</h3>
<pre class="prettyprint notranslate">
void insert(int data) {
   struct node *tempNode = (struct node*) malloc(sizeof(struct node));
   struct node *current;
   struct node *parent;

   tempNode-&gt;data = data;
   tempNode-&gt;leftChild = NULL;
   tempNode-&gt;rightChild = NULL;

   //if tree is empty
   if(root == NULL) {
      root = tempNode;
   } else {
      current = root;
      parent = NULL;

      while(1) {                
         parent = current;
			
         //go to left of the tree
         if(data &lt; parent-&gt;data) {
            current = current-&gt;leftChild;                
            //insert to the left
				
            if(current == NULL) {
               parent-&gt;leftChild = tempNode;
               return;
            }
         }//go to right of the tree
         else {
            current = current-&gt;rightChild;
            
            //insert to the right
            if(current == NULL) {
               parent-&gt;rightChild = tempNode;
               return;
            }
         }
      }            
   }
}        
</pre>

<title>Data Structures and Algorithms AVL Trees</title>

<h1>Data Structure and Algorithms - AVL Trees</h1>

<p>What if the input to binary search tree comes in a sorted (ascending or descending) manner? It will then look like this &minus;</p>

<p>It is observed that BST's worst-case performance is closest to linear search algorithms, that is &Omicron;(n). In real-time data, we cannot predict data pattern and their frequencies. So, a need arises to balance out the existing BST.</p>

<p>Named after their inventor <b>Adelson</b>, <b>Velski</b> &amp; <b>Landis</b>, <b>AVL trees</b> are height balancing binary search tree. AVL tree checks the height of the left and the right sub-trees and assures that the difference is not more than 1. This difference is called the <b>Balance Factor</b>.</p>

<p>Here we see that the first tree is balanced and the next two trees are not balanced &minus;</p>

<p>In the second tree, the left subtree of <b>C</b> has height 2 and the right subtree has height 0, so the difference is 2. In the third tree, the right subtree of <b>A</b> has height 2 and the left is missing, so it is 0, and the difference is 2 again. AVL tree permits difference (balance factor) to be only 1.</p>

<p>If the difference in the height of left and right sub-trees is more than 1, the tree is balanced using some rotation techniques.</p>

<h2>AVL Rotations</h2>

<p>To balance itself, an AVL tree may perform the following four kinds of rotations &minus;</p>

<p>The first two rotations are single rotations and the next two rotations are double rotations. To have an unbalanced tree, we at least need a tree of height 2. With this simple tree, let's understand them one by one.</p>

<h3>Left Rotation</h3>

<p>If a tree becomes unbalanced, when a node is inserted into the right subtree of the right subtree, then we perform a single left rotation &minus;</p>

<p>In our example, node <b>A</b> has become unbalanced as a node is inserted in the right subtree of A's right subtree. We perform the left rotation by making <b>A</b> the left-subtree of B.</p>

<h2>Right Rotation</h2>

<p>AVL tree may become unbalanced, if a node is inserted in the left subtree of the left subtree. The tree then needs a right rotation.</p>

<p>As depicted, the unbalanced node becomes the right child of its left child by performing a right rotation.</p>

<h3>Left-Right Rotation</h3>

<p>Double rotations are slightly complex version of already explained versions of rotations. To understand them better, we should take note of each action performed while rotation. Let's first check how to perform Left-Right rotation. A left-right rotation is a combination of left rotation followed by right rotation.</p>

<h3>Right-Left Rotation</h3>

<p>The second type of double rotation is Right-Left Rotation. It is a combination of right rotation followed by left rotation.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
<i><b>BalanceFactor</b></i> = height(left-sutree) &minus; height(right-sutree)
</pre>

<title>Data Structures and Algorithms Spanning Tree</title>

<h1>Data Structure &amp; Algorithms - Spanning Tree</h1>

<p>A spanning tree is a subset of Graph G, which has all the vertices covered with minimum possible number of edges. Hence, a spanning tree does not have cycles and it cannot be disconnected..</p>

<p>By this definition, we can draw a conclusion that every connected and undirected Graph G has at least one spanning tree. A disconnected graph does not have any spanning tree, as it cannot be spanned to all its vertices.</p>

<p>We found three spanning trees off one complete graph. A complete undirected graph can have maximum <b>n<sup>n-2</sup></b> number of spanning trees, where <b>n</b> is the number of nodes. In the above addressed example, <b>3<sup>3&minus;2</sup> = 3</b> spanning trees are possible.</p>

<h2>General Properties of Spanning Tree</h2>

<p>We now understand that one graph can have more than one spanning tree. Following are a few properties of the spanning tree connected to graph G &minus;</p>

<p>A connected graph G can have more than one spanning tree.</p>

<p>All possible spanning trees of graph G, have the same number of edges and vertices.</p>

<p>The spanning tree does not have any cycle (loops).</p>

<p>Removing one edge from the spanning tree will make the graph disconnected, i.e. the spanning tree is <b>minimally connected</b>.</p>

<p>Adding one edge to the spanning tree will create a circuit or loop, i.e. the spanning tree is <b>maximally acyclic</b>.</p>

<h2>Mathematical Properties of Spanning Tree</h2>

<p>Spanning tree has <b>n-1</b> edges, where <b>n</b> is the number of nodes (vertices).</p>

<p>From a complete graph, by removing maximum <b>e - n &plus; 1</b> edges, we can construct a spanning tree.</p>

<p>A complete graph can have maximum <b>n<sup>n-2</sup></b> number of spanning trees.</p>

<p>Thus, we can conclude that spanning trees are a subset of connected Graph G and disconnected graphs do not have spanning tree.</p>

<h2>Application of Spanning Tree</h2>

<p>Spanning tree is basically used to find a minimum path to connect all nodes in a graph. Common application of spanning trees are &minus;</p>

<p><b>Civil Network Planning</b></p>

<p><b>Computer Network Routing Protocol</b></p>

<p><b>Cluster Analysis</b></p>

<p>Let us understand this through a small example. Consider, city network as a huge graph and now plans to deploy telephone lines in such a way that in minimum lines we can connect to all city nodes. This is where the spanning tree comes into picture.</p>

<h2>Minimum Spanning Tree (MST)</h2>

<p>In a weighted graph, a minimum spanning tree is a spanning tree that has minimum weight than all other spanning trees of the same graph. In real-world situations, this weight can be measured as distance, congestion, traffic load or any arbitrary value denoted to the edges.</p>

<h2>Minimum Spanning-Tree Algorithm</h2>

<p>We shall learn about two most important spanning tree algorithms here &minus;</p>

<p><a href="/data_structures_algorithms/kruskals_spanning_tree_algorithm.htm">Kruskal's Algorithm</a></p>

<p><a href="/data_structures_algorithms/prims_spanning_tree_algorithm.htm">Prim's Algorithm</a></p>

<p>Both are greedy algorithms.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Heap Data Structures</title>

<h1>Heap Data Structures</h1>

<p>Heap is a special case of balanced binary tree data structure where the root-node key is compared with its children and arranged accordingly. If <b>&alpha;</b> has child node <b>&beta;</b> then &minus;</p>

<p>As the value of parent is greater than that of child, this property generates <b>Max Heap</b>. Based on this criteria, a heap can be of two types &minus;</p>

<p><b>Min-Heap</b> &minus;  Where the value of the root node is less than or equal to either of its children.</p>

<p><b>Max-Heap</b> &minus; Where the value of the root node is greater than or equal to either of its children.</p>

<p>Both trees are constructed using the same input and order of arrival.</p>

<h2>Max Heap Construction Algorithm</h2>

<p>We shall use the same example to demonstrate how a Max Heap is created. The procedure to create Min Heap is similar but we go for min values instead of max values.</p>

<p>We are going to derive an algorithm for max heap by inserting one element at a time. At any point of time, heap must maintain its property. While insertion, we also assume that we are inserting a node in an already heapified tree.</p>

<p><b>Note</b> &minus; In Min Heap construction algorithm, we expect the value of the parent node to be less than that of the child node.</p>

<p>Let's understand Max Heap construction by an animated illustration. We consider the same input sample that we used earlier.</p>

<h2>Max Heap Deletion Algorithm</h2>

<p>Let us derive an algorithm to delete from max heap. Deletion in Max (or Min) Heap always happens at the root to remove the Maximum (or minimum) value.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
For Input &rarr; 35 33 42 10 14 19 27 44 26 31
</pre>
<p><b>Min-Heap</b> &minus;  Where the value of the root node is less than or equal to either of its children.</p>
<img src="/data_structures_algorithms/images/min_heap_example.jpg" alt="Max Heap Example" />
<p><b>Max-Heap</b> &minus; Where the value of the root node is greater than or equal to either of its children.</p>
<img src="/data_structures_algorithms/images/max_heap_example.jpg" alt="Max Heap Example" />
<p>Both trees are constructed using the same input and order of arrival.</p>
<h2>Max Heap Construction Algorithm</h2>
<p>We shall use the same example to demonstrate how a Max Heap is created. The procedure to create Min Heap is similar but we go for min values instead of max values.</p>
<p>We are going to derive an algorithm for max heap by inserting one element at a time. At any point of time, heap must maintain its property. While insertion, we also assume that we are inserting a node in an already heapified tree.</p>
<pre class="result notranslate">
<b>Step 1</b> &minus; Create a new node at the end of heap.
<b>Step 2</b> &minus; Assign new value to the node.
<b>Step 3</b> &minus; Compare the value of this child node with its parent.
<b>Step 4</b> &minus; If value of parent is less than child, then swap them.
<b>Step 5</b> &minus; Repeat step 3 &amp; 4 until Heap property holds.
</pre>
<p><b>Note</b> &minus; In Min Heap construction algorithm, we expect the value of the parent node to be less than that of the child node.</p>
<p>Let's understand Max Heap construction by an animated illustration. We consider the same input sample that we used earlier.</p>
<img src="/data_structures_algorithms/images/max_heap_animation.gif" alt="Max Heap Animated Example" />
<h2>Max Heap Deletion Algorithm</h2>
<p>Let us derive an algorithm to delete from max heap. Deletion in Max (or Min) Heap always happens at the root to remove the Maximum (or minimum) value.</p>
<pre class="result notranslate">
<b>Step 1</b> &minus; Remove root node.
<b>Step 2</b> &minus; Move the last element of last level to root.
<b>Step 3</b> &minus; Compare the value of this child node with its parent.
<b>Step 4</b> &minus; If value of parent is less than child, then swap them.
<b>Step 5</b> &minus; Repeat step 3 &amp; 4 until Heap property holds.
</pre>

<title>Data Structures and Algorithms Recursion Basics</title>

<h1>Data Structure - Recursion Basics</h1>

<p>Some computer programming languages allow a module or function to call itself. This technique is known as recursion. In recursion, a function <b>&alpha;</b> either calls itself directly or calls a function <b>&beta;</b> that in turn calls the original function <b>&alpha;</b>. The function <b>&alpha;</b> is called recursive function.</p>

<p><b>Example</b> &minus; a function calling itself.</p>

<p><b>Example</b> &minus; a function that calls another function which in turn calls it again.</p>

<h2>Properties</h2>

<p>A recursive function can go infinite like a loop. To avoid infinite running of recursive function, there are two properties that a recursive function must have &minus;</p>

<p><b>Base criteria</b> &minus; There must be at least one base criteria or condition, such that, when this condition is met the function stops calling itself recursively.</p>

<p><b>Progressive approach</b> &minus; The recursive calls should progress in such a way that each time a recursive call is made it comes closer to the base criteria.</p>

<h2>Implementation</h2>

<p>Many programming languages implement recursion by means of <b>stacks</b>. Generally, whenever a function (<b>caller</b>) calls another function (<b>callee</b>) or itself as callee, the caller function transfers execution control to the callee. This transfer process may also involve some data to be passed from the caller to the callee.</p>

<p>This implies, the caller function has to suspend its execution temporarily and resume later when the execution control returns from the callee function. Here, the caller function needs to start exactly from the point of execution where it puts itself on hold. It also needs the exact same data values it was working on. For this purpose, an activation record (or stack frame) is created for the caller function.</p>

<p>This activation record keeps the information about local variables, formal parameters, return address and all information passed to the caller function.</p>

<h2>Analysis of Recursion</h2>

<p>One may argue why to use recursion, as the same task can be done with iteration. The first reason is, recursion makes a program more readable and because of latest enhanced CPU systems, recursion is more efficient than iterations.</p>

<h2>Time Complexity</h2>

<p>In case of iterations, we take number of iterations to count the time complexity. Likewise, in case of recursion, assuming everything is constant, we try to figure out the number of times a recursive call is being made. A call made to a function is &Omicron;(1), hence the (n) number of times a recursive call is made makes the recursive function &Omicron;(n).</p>

<h2>Space Complexity</h2>

<p>Space complexity is counted as what amount of extra space is required for a module to execute. In case of iterations, the compiler hardly requires any extra space. The compiler keeps updating the values of variables used in the iterations. But in case of recursion, the system needs to store activation record each time a recursive call is made. Hence, it is considered that space complexity of recursive function may go higher than that of a function with iteration.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
int function(int value) {
   if(value &lt; 1)
      return;
   function(value - 1);
	
   printf("%d ",value);   
}
</pre>
<p><b>Example</b> &minus; a function that calls another function which in turn calls it again.</p>
<pre class="prettyprint notranslate">
int function(int value) {
   if(value &lt; 1)
      return;
   function(value - 1);
	
   printf("%d ",value);   
}
</pre>

<title>Data Structures and Algorithms Tower of Hanoi</title>

<h1>Data Structure &amp; Algorithms - Tower of Hanoi</h1>

<p>Tower of Hanoi, is a mathematical puzzle which consists of three towers (pegs) and more than one rings is as depicted &minus;</p>

<p>These rings are of different sizes and stacked upon in an ascending order, i.e. the smaller one sits over the larger one. There are other variations of the puzzle where the number of disks increase, but the tower count remains the same.</p>

<h2>Rules</h2>

<p>The mission is to move all the disks to some another tower without violating the sequence of arrangement. A few rules to be followed for Tower of Hanoi are &minus;</p>

<p>Following is an animated representation of solving a Tower of Hanoi puzzle with three disks.</p>

<p>Tower of Hanoi puzzle with n disks can be solved in minimum <b>2<sup>n</sup>&minus;1</b> steps. This presentation shows that a puzzle with 3 disks has taken <b>2<sup>3</sup> - 1 = 7</b> steps.</p>

<h2>Algorithm</h2>

<p>To write an algorithm for Tower of Hanoi, first we need to learn how to solve this problem with lesser amount of disks, say &rarr; 1 or 2. We mark three towers with name, <b>source</b>, <b>destination</b> and <b>aux</b> (only to help moving the disks). If we have only one disk, then it can easily be moved from source to destination peg.</p>

<p>If we have 2 disks &minus;</p>

<p>So now, we are in a position to design an algorithm for Tower of Hanoi with more than two disks. We divide the stack of disks in two parts. The largest disk (n<sup>th</sup> disk) is in one part and all other (n-1) disks are in the second part.</p>

<p>Our ultimate aim is to move disk <b>n</b> from source to destination and then put all other (n1) disks onto it. We can imagine to apply the same in a recursive way for all given set of disks.</p>

<p>The steps to follow are &minus;</p>

<p>A recursive algorithm for Tower of Hanoi can be driven as follows &minus;</p>

<p>To check the implementation in C programming, <a href="/data_structures_algorithms/tower_of_hanoi_in_c.htm">click here</a>.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
<b>Step 1</b> &minus; Move n-1 disks from <code><b>source</b></code> to <code><b>aux</b></code>
<b>Step 2</b> &minus; Move n<sup>th</sup> disk from <code><b>source</b></code> to <code><b>dest</b></code>
<b>Step 3</b> &minus; Move n-1 disks from <code><b>aux</b></code> to <code><b>dest</b></code>
</pre>
<p>A recursive algorithm for Tower of Hanoi can be driven as follows &minus;</p>
<pre class="prettyprint notranslate">
START
Procedure Hanoi(disk, source, dest, aux)

   IF disk == 0, THEN
      move disk from source to dest             
   ELSE
      Hanoi(disk - 1, source, aux, dest)     // Step 1
      move disk from source to dest          // Step 2
      Hanoi(disk - 1, aux, dest, source)     // Step 3
   END IF
   
END Procedure
STOP
</pre>

<title>Data Structures and Algorithms Fibonacci Series</title>

<h1>Data Structure &amp; Algorithms Fibonacci Series</h1>

<p>Fibonacci series generates the subsequent number by adding two previous numbers. Fibonacci series starts from two numbers − <b>F<sub>0</sub> &amp; F<sub>1</sub></b>. The initial values of F<sub>0</sub> &amp; F<sub>1</sub> can be taken 0, 1 or 1, 1 respectively.</p>

<p>Fibonacci series satisfies the following conditions &minus;</p>

<p>Hence, a Fibonacci series can look like this &minus;</p>

<p>F<sub>8</sub> = 0 1 1 2 3 5 8 13</p>

<p>or, this &minus;</p>

<p>F<sub>8</sub> = 1 1 2 3 5 8 13 21</p>

<p>For illustration purpose, Fibonacci of F<sub>8</sub> is displayed as &minus;</p>

<h2>Fibonacci Iterative Algorithm</h2>

<p>First we try to draft the iterative algorithm for Fibonacci series.</p>

<p>To know about the implementation of the above algorithm in C programming language, <a href="/data_structures_algorithms/fibonacci_iterative_program_in_c.htm">click here</a>.</p>

<h2>Fibonacci Recursive Algorithm</h2>

<p>Let us learn how to create a recursive algorithm Fibonacci series. The base criteria of recursion.</p>

<p>To see the implementation of above algorithm in c programming language, <a href="/data_structures_algorithms/fibonacci_recursive_program_in_c.htm">click here</a>.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
F<sub>n</sub> = F<sub>n-1</sub> + F<sub>n-2</sub>
</pre>
<p>Hence, a Fibonacci series can look like this &minus;</p>
<p>F<sub>8</sub> = 0 1 1 2 3 5 8 13</p>
<p>or, this &minus;</p>
<p>F<sub>8</sub> = 1 1 2 3 5 8 13 21</p>
<p>For illustration purpose, Fibonacci of F<sub>8</sub> is displayed as &minus;</p>
<img src="/data_structures_algorithms/images/fibonacci_animation.gif" alt="Fibonacci Animation" />
<h2>Fibonacci Iterative Algorithm</h2>
<p>First we try to draft the iterative algorithm for Fibonacci series.</p>
<pre class="prettyprint notranslate">
Procedure Fibonacci(n)
   declare f<sub>0</sub>, f<sub>1</sub>, fib, loop 
   
   set f<sub>0</sub> to 0
   set f<sub>1</sub> to 1
   
   <b>display f<sub>0</sub>, f<sub>1</sub></b>
   
   for loop &larr; 1 to n
   
      fib &larr; f<sub>0</sub> &plus; f<sub>1</sub>   
      f<sub>0</sub> &larr; f<sub>1</sub>
      f<sub>1</sub> &larr; fib

      <b>display fib</b>
   end for
	
end procedure
</pre>
<p>To know about the implementation of the above algorithm in C programming language, <a href="/data_structures_algorithms/fibonacci_iterative_program_in_c.htm">click here</a>.</p>
<h2>Fibonacci Recursive Algorithm</h2>
<p>Let us learn how to create a recursive algorithm Fibonacci series. The base criteria of recursion.</p>
<pre class="prettyprint notranslate">
START
Procedure Fibonacci(n)
   declare f<sub>0</sub>, f<sub>1</sub>, fib, loop 
   
   set f<sub>0</sub> to 0
   set f<sub>1</sub> to 1
   
   <b>display f<sub>0</sub>, f<sub>1</sub></b>
   
   for loop &larr; 1 to n
   
      fib &larr; f<sub>0</sub> &plus; f<sub>1</sub>   
      f<sub>0</sub> &larr; f<sub>1</sub>
      f<sub>1</sub> &larr; fib

      <b>display fib</b>
   end for

END
</pre>

<title>Data Structures Algorithms Questions and Answers - TutorialsPoint</title>

<h1>DSA Questions &amp; Answers</h1>

<p><b>Data Structures Algorithms Questions and Answers</b> has been designed with a special intention of helping students and professionals preparing for various <b>Certification Exams</b> and <b>Job Interviews</b>. This section provides a useful collection of sample Interview Questions and  Multiple Choice Questions (MCQs) and their answers with appropriate explanations.</p>

<p>This section provides a huge collection of Data Structures Algorithms Interview Questions with their answers hidden in a box to challenge you to have a go at them before discovering the correct answer.</p>

<p>This section provides a great collection of Data Structures Algorithms Multiple Choice Questions (MCQs) on a single page along with their correct answers and explanation. If you select the right option, it turns green; else red.</p>

<p>If you are preparing to appear for a Java and Data Structures Algorithms related certification exam, then this section is a must for you. This section simulates a real online test along with a given timer which challenges you to complete the test within a given time-frame. Finally you can check your overall test score and how you fared among millions of other candidates who attended this online test.</p>

<p>This section provides various mock tests that you can download at your local machine and solve offline. Every mock test is supplied with a mock test key to let you verify the final score and grade yourself.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Data Structures and Algorithms Quick Guide</title>

<h1>Data Structures &amp; Algorithms - Quick Guide</h1>

<h1>Data Structures &amp; Algorithms - Overview</h1>

<p>Data Structure is a systematic way to organize data in order to use it efficiently. Following terms are the foundation terms of a data structure.</p>

<p><b>Interface</b> &minus; Each data structure has an interface. Interface represents the set of operations that a data structure supports. An interface only provides the list of supported operations, type of parameters they can accept and return type of these operations.</p>

<p><b>Implementation</b> &minus; Implementation provides the internal representation of a data structure. Implementation also provides the definition of the algorithms used in the operations of the data structure.</p>

<h2>Characteristics of a Data Structure</h2>

<p><b>Correctness</b> &minus; Data structure implementation should implement its interface correctly.</p>

<p><b>Time Complexity</b> &minus; Running time or the execution time of operations of data structure must be as small as possible.</p>

<p><b>Space Complexity</b> &minus; Memory usage of a data structure operation should be as little as possible.</p>

<h2>Need for Data Structure</h2>

<p>As applications are getting complex and data rich, there are three common problems that applications face now-a-days.</p>

<p><b>Data Search</b> &minus; Consider an inventory of 1 million(10<sup>6</sup>) items of a store. If the application is to search an item, it has to search an item in 1 million(10<sup>6</sup>) items every time slowing down the search. As data grows, search will become slower.</p>

<p><b>Processor speed</b> &minus; Processor speed although being very high, falls limited if the data grows to billion records.</p>

<p><b>Multiple requests</b> &minus; As thousands of users can search data simultaneously on a web server, even the fast server fails while searching the data.</p>

<p>To solve the above-mentioned problems, data structures come to rescue. Data can be organized in a data structure in such a way that all items may not be required to be searched, and the required data can be searched almost instantly.</p>

<h2>Execution Time Cases</h2>

<p>There are three cases which are usually used to compare various data structure's execution time in a relative manner.</p>

<p><b>Worst Case</b> &minus; This is the scenario where a particular data structure operation takes maximum time it can take. If an operation's worst case time is &#402;(n) then this operation will not take more than &#402;(n) time where &#402;(n) represents function of n.</p>

<p><b>Average Case</b> &minus; This is the scenario depicting the average execution time of an operation of a data structure. If an operation takes &#402;(n) time in execution, then m operations will take m&#402;(n) time.</p>

<p><b>Best Case</b> &minus; This is the scenario depicting the least possible execution time of an operation of a data structure. If an operation takes &#402;(n) time in execution, then the actual operation may take time as the random number which would be maximum as &#402;(n).</p>

<h2>Basic Terminology</h2>

<p><b>Data</b> &minus; Data are values or set of values.</p>

<p><b>Data Item</b> &minus; Data item refers to single unit of values.</p>

<p><b>Group Items</b> &minus; Data items that are divided into sub items are called as Group Items.</p>

<p><b>Elementary Items</b> &minus; Data items that cannot be divided are called as Elementary Items.</p>

<p><b>Attribute and Entity</b> &minus; An entity is that which contains certain attributes or properties, which may be assigned values.</p>

<p><b>Entity Set</b> &minus; Entities of similar attributes form an entity set.</p>

<p><b>Field</b> &minus; Field is a single elementary unit of information representing an attribute of an entity.</p>

<p><b>Record</b> &minus; Record is a collection of field values of a given entity.</p>

<p><b>File</b> &minus; File is a collection of records of the entities in a given entity set.</p>

<h1>Data Structures - Environment Setup</h1>

<h2>Try it Option Online</h2>

<p>You really do not need to set up your own environment to start learning C programming language. Reason is very simple, we already have set up C Programming environment online, so that you can compile and execute all the available examples online at the same time when you are doing your theory work. This gives you confidence in what you are reading and to check the result with different options. Feel free to modify any example and execute it online.</p>

<p>Try the following example using our online compiler available at <a href="http://www.tutorialspoint.com/codingground.htm">CodingGround</a></p>

<p>For most of the examples given in this tutorial, you will find a Try it option in our website code sections at the top right corner that will take you to the online compiler. So just make use of it and enjoy your learning.</p>

<h2>Local Environment Setup</h2>

<p>If you are still willing to set up your environment for C programming language, you need the following two tools available on your computer, (a) Text Editor and (b) The C Compiler.</p>

<h3>Text Editor</h3>

<p>This will be used to type your program. Examples of few editors include Windows Notepad, OS Edit command, Brief, Epsilon, EMACS, and vim or vi.</p>

<p>The name and the version of the text editor can vary on different operating systems. For example, Notepad will be used on Windows, and vim or vi can be used on Windows as well as Linux or UNIX.</p>

<p>The files you create with your editor are called source files and contain program source code. The source files for C programs are typically named with the extension "<b>.c</b>".</p>

<p>Before starting your programming, make sure you have one text editor in place and you have enough experience to write a computer program, save it in a file, compile it, and finally execute it.</p>

<h3>The C Compiler</h3>

<p>The source code written in the source file is the human readable source for your program. It needs to be "compiled", to turn into machine language so that your CPU can actually execute the program as per the given instructions.</p>

<p>This C programming language compiler will be used to compile your source code into a final executable program. We assume you have the basic knowledge about a programming language compiler.</p>

<p>Most frequently used and free available compiler is GNU C/C&plus;&plus; compiler. Otherwise, you can have compilers either from HP or Solaris if you have respective Operating Systems (OS).</p>

<p>The following section guides you on how to install GNU C/C&plus;&plus; compiler on various OS. We are mentioning C/C&plus;&plus; together because GNU GCC compiler works for both C and C&plus;&plus; programming languages.</p>

<h2>Installation on UNIX/Linux</h2>

<p>If you are using <b>Linux or UNIX</b>, then check whether GCC is installed on your system by entering the following command from the command line &minus;</p>

<p>If you have GNU compiler installed on your machine, then it should print a message such as the following &minus;</p>

<p>If GCC is not installed, then you will have to install it yourself using the detailed instructions available at <a href="https://gcc.gnu.org/install/" rel="nofollow" target="_blank">https://gcc.gnu.org/install/</a></p>

<p>This tutorial has been written based on Linux and all the given examples have been compiled on Cent OS flavor of Linux system.</p>

<h2>Installation on Mac OS</h2>

<p>If you use Mac OS X, the easiest way to obtain GCC is to download the Xcode development environment from Apple's website and follow the simple installation instructions. Once you have Xcode setup, you will be able to use GNU compiler for C/C&plus;&plus;.</p>

<p>Xcode is currently available at <a href="https://developer.apple.com/technologies/tools/" rel="nofollow" target="_blank">developer.apple.com/technologies/tools/</a></p>

<h2>Installation on Windows</h2>

<p>To install GCC on Windows, you need to install MinGW. To install MinGW, go to the MinGW homepage, <a href="http://www.mingw.org" rel="nofollow" target="_blank"> www.mingw.org</a>, and follow the link to the MinGW download page. Download the latest version of the MinGW installation program, which should be named MinGW-&lt;version&gt;.exe.</p>

<p>While installing MinWG, at a minimum, you must install gcc-core, gcc-g&plus;&plus;, binutils, and the MinGW runtime, but you may wish to install more.</p>

<p>Add the bin subdirectory of your MinGW installation to your <b>PATH</b> environment variable, so that you can specify these tools on the command line by their simple names.</p>

<p>When the installation is complete, you will be able to run gcc, g&plus;&plus;, ar, ranlib, dlltool, and several other GNU tools from the Windows command line.</p>

<h1>Data Structures - Algorithms Basics</h1>

<p>Algorithm is a step-by-step procedure, which defines a set of instructions to be executed in a certain order to get the desired output. Algorithms are generally created independent of underlying languages, i.e. an algorithm can be implemented in more than one programming language.</p>

<p>From the data structure point of view, following are some important categories of algorithms &minus;</p>

<p><b>Search</b> &minus; Algorithm to search an item in a data structure.</p>

<p><b>Sort</b> &minus; Algorithm to sort items in a certain order.</p>

<p><b>Insert</b> &minus; Algorithm to insert item in a data structure.</p>

<p><b>Update</b> &minus;  Algorithm to update an existing item in a data structure.</p>

<p><b>Delete</b> &minus; Algorithm to delete an existing item from a data structure.</p>

<h2>Characteristics of an Algorithm</h2>

<p>Not all procedures can be called an algorithm. An algorithm should have the following characteristics &minus;</p>

<p><b>Unambiguous</b> &minus; Algorithm should be clear and unambiguous. Each of its steps (or phases), and their inputs/outputs should be clear and must lead to only one meaning.</p>

<p><b>Input</b> &minus; An algorithm should have 0 or more well-defined inputs.</p>

<p><b>Output</b> &minus; An algorithm should have 1 or more well-defined outputs, and should match the desired output.</p>

<p><b>Finiteness</b> &minus; Algorithms must terminate after a finite number of steps.</p>

<p><b>Feasibility</b> &minus; Should be feasible with the available resources.</p>

<p><b>Independent</b> &minus; An algorithm should have step-by-step directions, which should be independent of any programming code.</p>

<h2>How to Write an Algorithm?</h2>

<p>There are no well-defined standards for writing algorithms. Rather, it is problem and resource dependent. Algorithms are never written to support a particular programming code.</p>

<p>As we know that all programming languages share basic code constructs like loops (do, for, while), flow-control (if-else), etc. These common constructs can be used to write an algorithm.</p>

<p>We write algorithms in a step-by-step manner, but it is not always the case. Algorithm writing is a process and is executed after the problem domain is well-defined. That is, we should know the problem domain, for which we are designing a solution.</p>

<h3>Example</h3>

<p>Let's try to learn algorithm-writing by using an example.</p>

<p><b>Problem</b> &minus; Design an algorithm to add two numbers and display the result.</p>

<p>Algorithms tell the programmers how to code the program. Alternatively, the algorithm can be written as &minus;</p>

<p>In design and analysis of algorithms, usually the second method is used to describe an algorithm. It makes it easy for the analyst to analyze the algorithm ignoring all unwanted definitions. He can observe what operations are being used and how the process is flowing.</p>

<p>Writing <b>step numbers</b>, is optional.</p>

<p>We design an algorithm to get a solution of a given problem. A problem can be solved in more than one ways.</p>

<p>Hence, many solution algorithms can be derived for a given problem. The next step is to analyze those proposed solution algorithms and implement the best suitable solution.</p>

<h2>Algorithm Analysis</h2>

<p>Efficiency of an algorithm can be analyzed at two different stages, before implementation and after implementation. They are the following &minus;</p>

<p><b>A Priori Analysis</b> &minus; This is a theoretical analysis of an algorithm. Efficiency of an algorithm is measured by assuming that all other factors, for example, processor speed, are constant and have no effect on the implementation.</p>

<p><b>A Posterior Analysis</b> &minus; This is an empirical analysis of an algorithm. The selected algorithm is implemented using programming language. This is then executed on target computer machine. In this analysis, actual statistics like running time and space required, are collected.</p>

<p>We shall learn about a priori algorithm analysis. Algorithm analysis deals with the execution or running time of various operations involved. The running time of an operation can be defined as the number of computer instructions executed per operation.</p>

<h2>Algorithm Complexity</h2>

<p>Suppose <b>X</b> is an algorithm and <b>n</b> is the size of input data, the time and space used by the algorithm X are the two main factors, which decide the efficiency of X.</p>

<p><b>Time Factor</b> &minus; Time is measured by counting the number of key operations such as comparisons in the sorting algorithm.</p>

<p><b>Space Factor</b> &minus; Space is measured by counting the maximum memory space required by the algorithm.</p>

<p>The complexity of an algorithm <b>f(n)</b> gives the running time and/or the storage space required by the algorithm in terms of <b>n</b> as the size of input data.</p>

<h2>Space Complexity</h2>

<p>Space complexity of an algorithm represents the amount of memory space required by the algorithm in its life cycle. The space required by an algorithm is equal to the sum of the following two components &minus;</p>

<p>A fixed part that is a space required to store certain data and variables, that are independent of the size of the problem. For example, simple variables and constants used, program size, etc.</p>

<p>A variable part is a space required by variables, whose size depends on the size of the problem. For example, dynamic memory allocation, recursion stack space, etc.</p>

<p>Space complexity S(P) of any algorithm P is S(P) = C &plus; SP(I), where C is the fixed part and S(I) is the variable part of the algorithm, which depends on instance characteristic I. Following is a simple example that tries to explain the concept &minus;</p>

<p>Here we have three variables A, B, and C and one constant. Hence S(P) = 1 &plus; 3. Now, space depends on data types of given variables and constant types and it will be multiplied accordingly.</p>

<h2>Time Complexity</h2>

<p>Time complexity of an algorithm represents the amount of time required by the algorithm to run to completion. Time requirements can be defined as a numerical function T(n), where T(n) can be measured as the number of steps, provided each step consumes constant time.</p>

<p>For example, addition of two n-bit integers takes <b>n</b> steps. Consequently, the total computational time is T(n) = c &lowast; n, where c is the time taken for the addition of two bits. Here, we observe that T(n) grows linearly as the input size increases.</p>

<h1>Data Structures - Asymptotic Analysis</h1>

<p>Asymptotic analysis of an algorithm refers to defining the mathematical boundation/framing of its run-time performance. Using asymptotic analysis, we can very well conclude the best case, average case, and worst case scenario of an algorithm.</p>

<p>Asymptotic analysis is input bound i.e., if there's no input to the algorithm, it is concluded to work in a constant time. Other than the "input" all other factors are considered constant.</p>

<p>Asymptotic analysis refers to computing the running time of any operation in mathematical units of computation. For example, the running time of one operation is computed as <i>f</i>(n) and may be for another operation it is computed as <i>g</i>(n<sup>2</sup>). This means the first operation running time will increase linearly with the increase in <b>n</b> and the running time of the second operation will increase exponentially when <b>n</b> increases. Similarly, the running time of both operations will be nearly the same if <b>n</b> is significantly small.</p>

<p>Usually, the time required by an algorithm falls under three types &minus;</p>

<p><b>Best Case</b> &minus; Minimum time required for program execution.</p>

<p><b>Average Case</b> &minus; Average time required for program execution.</p>

<p><b>Worst Case</b> &minus; Maximum time required for program execution.</p>

<h2>Asymptotic Notations</h2>

<p>Following are the commonly used asymptotic notations to calculate the running time complexity of an algorithm.</p>

<h3>Big Oh Notation, &Omicron;</h3>

<p>The notation &Omicron;(n) is the formal way to express the upper bound of an algorithm's running time. It measures the worst case time complexity or the longest amount of time an algorithm can possibly take to complete.</p>

<p>For example, for a function <b><i>f</i>(n)</b></p>

<h3>Omega Notation, &Omega;</h3>

<p>The notation &Omega;(n) is the formal way to express the lower bound of an algorithm's running time. It measures the best case time complexity or the best amount of time an algorithm can possibly take to complete.</p>

<p>For example, for a function <b><i>f</i>(n)</b></p>

<h3>Theta Notation, &theta;</h3>

<p>The notation &theta;(n) is the formal way to express both the lower bound and the upper bound of an algorithm's running time. It is represented as follows &minus;</p>

<h2>Common Asymptotic Notations</h2>

<p>Following is a list of some common asymptotic notations &minus;</p>

<h1>Data Structures - Greedy Algorithms</h1>

<p>An algorithm is designed to achieve optimum solution for a given problem. In greedy algorithm approach, decisions are made from the given solution domain. As being greedy, the closest solution that seems to provide an optimum solution is chosen.</p>

<p>Greedy algorithms try to find a localized optimum solution, which may eventually lead to globally optimized solutions. However, generally greedy algorithms do not provide globally optimized solutions.</p>

<h2>Counting Coins</h2>

<p>This problem is to count to a desired value by choosing the least possible coins and the greedy approach forces the algorithm to pick the largest possible coin. If we are provided coins of &#8377; 1, 2, 5 and 10 and we are asked to count &#8377; 18 then the greedy procedure will be &minus;</p>

<p><b>1</b> &minus; Select one &#8377; 10 coin, the remaining count is 8</p>

<p><b>2</b> &minus; Then select one &#8377; 5 coin, the remaining count is 3</p>

<p><b>3</b> &minus; Then select one &#8377; 2 coin, the remaining count is 1</p>

<p><b>4</b> &minus; And finally, the selection of one &#8377; 1 coins solves the problem</p>

<p>Though, it seems to be working fine, for this count we need to pick only 4 coins. But if we slightly change the problem then the same approach may not be able to produce the same optimum result.</p>

<p>For the currency system, where we have coins of 1, 7, 10 value, counting coins for value 18 will be absolutely optimum but for count like 15, it may use more coins than necessary. For example, the greedy approach will use 10 &plus; 1 &plus; 1 &plus; 1 &plus; 1 &plus; 1, total 6 coins. Whereas the same problem could be solved by using only 3 coins (7 &plus; 7 &plus; 1)</p>

<p>Hence, we may conclude that the greedy approach picks an immediate optimized solution and may fail where global optimization is a major concern.</p>

<h3>Examples</h3>

<p>Most networking algorithms use the greedy approach. Here is a list of few of them &minus;</p>

<p>There are lots of similar problems that uses the greedy approach to find an optimum solution.</p>

<h1>Data Structures - Divide and Conquer</h1>

<p>In divide and conquer approach, the problem in hand, is divided into smaller sub-problems and then each problem is solved independently. When we keep on dividing the subproblems into even smaller sub-problems, we may eventually reach a stage where no more division is possible. Those "atomic" smallest possible sub-problem (fractions) are solved. The solution of all sub-problems is finally merged in order to obtain the solution of an original problem.</p>

<p>Broadly, we can understand <b>divide-and-conquer</b> approach in a three-step process.</p>

<h2>Divide/Break</h2>

<p>This step involves breaking the problem into smaller sub-problems. Sub-problems should represent a part of the original problem. This step generally takes a recursive approach to divide the problem until no sub-problem is further divisible. At this stage, sub-problems become atomic in nature but still represent some part of the actual problem.</p>

<h2>Conquer/Solve</h2>

<p>This step receives a lot of smaller sub-problems to be solved. Generally, at this level, the problems are considered 'solved' on their own.</p>

<h2>Merge/Combine</h2>

<p>When the smaller sub-problems are solved, this stage recursively combines them until they formulate a solution of the original problem. This algorithmic approach works recursively and conquer & merge steps works so close that they appear as one.</p>

<h3>Examples</h3>

<p>The following computer algorithms are based on <b>divide-and-conquer</b> programming approach &minus;</p>

<p>There are various ways available to solve any computer problem, but the mentioned are a good example of divide and conquer approach.</p>

<h1>Data Structures - Dynamic Programming</h1>

<p>Dynamic programming approach is similar to divide and conquer in breaking down the problem into smaller and yet smaller possible sub-problems. But unlike, divide and conquer, these sub-problems are not solved independently. Rather, results of these smaller sub-problems are remembered and used for similar or overlapping sub-problems.</p>

<p>Dynamic programming is used where we have problems, which can be divided into similar sub-problems, so that their results can be re-used. Mostly, these algorithms are used for optimization. Before solving the in-hand sub-problem, dynamic algorithm will try to examine the results of the previously solved sub-problems. The solutions of sub-problems are combined in order to achieve the best solution.</p>

<p>So we can say that &minus;</p>

<p>The problem should be able to be divided into smaller overlapping sub-problem.</p>

<p>An optimum solution can be achieved by using an optimum solution of smaller sub-problems.</p>

<p>Dynamic algorithms use memorization.</p>

<h2>Comparison</h2>

<p>In contrast to greedy algorithms, where local optimization is addressed, dynamic algorithms are motivated for an overall optimization of the problem.</p>

<p>In contrast to divide and conquer algorithms, where solutions are combined to achieve an overall solution, dynamic algorithms use the output of a smaller sub-problem and then try to optimize a bigger sub-problem. Dynamic algorithms use memorization to remember the output of already solved sub-problems.</p>

<h3>Example</h3>

<p>The following computer problems can be solved using dynamic programming approach &minus;</p>

<p>Dynamic programming can be used in both top-down and bottom-up manner. And of course, most of the times, referring to the previous solution output is cheaper than recomputing in terms of CPU cycles.</p>

<h1>Data Structures &amp; Algorithm Basic Concepts</h1>

<p>This chapter explains the basic terms related to data structure.</p>

<h2>Data Definition</h2>

<p>Data Definition defines a particular data with the following characteristics.</p>

<p><b>Atomic</b> &minus; Definition should define a single concept.</p>

<p><b>Traceable</b> &minus; Definition should be able to be mapped to some data element.</p>

<p><b>Accurate</b> &minus; Definition should be unambiguous.</p>

<p><b>Clear and Concise</b> &minus; Definition should be understandable.</p>

<h2>Data Object</h2>

<p>Data Object represents an object having a data.</p>

<h2>Data Type</h2>

<p>Data type is a way to classify various types of data such as integer, string, etc. which determines the values that can be used with the corresponding type of data, the type of operations that can be performed on the corresponding type of data. There are two data types &minus;</p>

<h3>Built-in Data Type</h3>

<p>Those data types for which a language has built-in support are known as Built-in Data types. For example, most of the languages provide the following built-in data types.</p>

<h3>Derived Data Type</h3>

<p>Those data types which are implementation independent as they can be implemented in one or the other way are known as derived data types. These data types are normally built by the combination of primary or built-in data types and associated operations on them. For example &minus;</p>

<h2>Basic Operations</h2>

<p>The data in the data structures are processed by certain operations. The particular data structure chosen largely depends on the frequency of the operation that needs to be performed on the data structure.</p>

<h1>Data Structures and Algorithms - Arrays</h1>

<p>Array is a container which can hold a fix number of items and these items should be of the same type. Most of the data structures make use of arrays to implement their algorithms. Following are the important terms to understand the concept of Array.</p>

<p><b>Element</b> &minus; Each item stored in an array is called an element.</p>

<p><b>Index</b> &minus; Each location of an element in an array has a numerical index, which is used to identify the element.</p>

<h2>Array Representation</h2>

<p>Arrays can be declared in various ways in different languages. For illustration, let's take C array declaration.</p>

<p>As per the above illustration, following are the important points to be considered.</p>

<p>Index starts with 0.</p>

<p>Array length is 10 which means it can store 10 elements.</p>

<p>Each element can be accessed via its index. For example, we can fetch an element at index 6 as 9.</p>

<h2>Basic Operations</h2>

<p>Following are the basic operations supported by an array.</p>

<p><b>Traverse</b> &minus; print all the array elements one by one.</p>

<p><b>Insertion</b> &minus; Adds an element at the given index.</p>

<p><b>Deletion</b> &minus; Deletes an element at the given index.</p>

<p><b>Search</b> &minus; Searches an element using the given index or by the value.</p>

<p><b>Update</b> &minus; Updates an element at the given index.</p>

<p>In C, when an array is initialized with size, then it assigns defaults values to its elements in following order.</p>

<h2>Insertion Operation</h2>

<p>Insert operation is to insert one or more data elements into an array. Based on the requirement, a new element can be added at the beginning, end, or any given index of array.</p>

<p>Here, we see a practical implementation of insertion operation, where we add data at the end of the array &minus;</p>

<h3>Algorithm</h3>

<p>Let <b>Array</b> be a linear unordered array of <b>MAX</b> elements.</p>

<h3>Example</h3>

<p><b>Result</b></p>

<p>Let <b>LA</b> be a Linear Array (unordered) with <b>N</b> elements and <b>K</b> is a positive integer such that <b>K&lt;=N</b>. Following is the algorithm where ITEM is inserted into the K<sup>th</sup> position of LA &minus;</p>

<h3>Example</h3>

<p>Following is the implementation of the above algorithm &minus;</p>

<p>When we compile and execute the above program, it produces the following result &minus;</p>

<h3>Output</h3>

<p>For other variations of array insertion operation <a target="_blank" href="/data_structures_algorithms/array_insertion_algorithm.htm">click here</a></p>

<h2>Deletion Operation</h2>

<p>Deletion refers to removing an existing element from the array and re-organizing all elements of an array.</p>

<h3>Algorithm</h3>

<p>Consider <b>LA</b> is a linear array with <b>N</b> elements and <b>K</b> is a positive integer such that <b>K&lt;=N</b>. Following is the algorithm to delete an element available at the K<sup>th</sup> position of LA.</p>

<h3>Example</h3>

<p>Following is the implementation of the above algorithm &minus;</p>

<p>When we compile and execute the above program, it produces the following result &minus;</p>

<h3>Output</h3>

<h2>Search Operation</h2>

<p>You can perform a search for an array element based on its value or its index.</p>

<h3>Algorithm</h3>

<p>Consider <b>LA</b> is a linear array with <b>N</b> elements and <b>K</b> is a positive integer such that <b>K&lt;=N</b>. Following is the algorithm to find an element with a value of ITEM using sequential search.</p>

<h3>Example</h3>

<p>Following is the implementation of the above algorithm &minus;</p>

<p>When we compile and execute the above program, it produces the following result &minus;</p>

<h3>Output</h3>

<h2>Update Operation</h2>

<p>Update operation refers to updating an existing element from the array at a given index.</p>

<h3>Algorithm</h3>

<p>Consider <b>LA</b> is a linear array with <b>N</b> elements and <b>K</b> is a positive integer such that <b>K&lt;=N</b>. Following is the algorithm to update an element available at the K<sup>th</sup> position of LA.</p>

<h3>Example</h3>

<p>Following is the implementation of the above algorithm &minus;</p>

<p>When we compile and execute the above program, it produces the following result &minus;</p>

<h3>Output</h3>

<h1>Data Structure and Algorithms - Linked List</h1>

<p>A linked list is a sequence of data structures, which are connected together via links.</p>

<p>Linked List is a sequence of links which contains items. Each link contains a connection to another link. Linked list is the second most-used data structure after array. Following are the important terms to understand the concept of Linked List.</p>

<p><b>Link</b> &minus; Each link of a linked list can store a data called an element.</p>

<p><b>Next</b> &minus; Each link of a linked list contains a link to the next link called Next.</p>

<p><b>LinkedList</b> &minus; A Linked List contains the connection link to the first link called First.</p>

<h2>Linked List Representation</h2>

<p>Linked list can be visualized as a chain of nodes, where every node points to the next node.</p>

<p>As per the above illustration, following are the important points to be considered.</p>

<p>Linked List contains a link element called first.</p>

<p>Each link carries a data field(s) and two link fields called next and prev.</p>

<p>Each link is linked with its next link using its next link.</p>

<p>Last link carries a link as null to mark the end of the list.</p>

<h2>Types of Linked List</h2>

<p>Following are the various types of linked list.</p>

<p><b>Simple Linked List</b> &minus; Item navigation is forward only.</p>

<p><b>Doubly Linked List</b> &minus; Items can be navigated forward and backward.</p>

<p><b>Circular Linked List</b> &minus; Last item contains link of the first element as next and the first element has a link to the last element as previous.</p>

<h2>Basic Operations</h2>

<p>Following are the basic operations supported by a list.</p>

<p><b>Insertion</b> &minus; Adds an element at the beginning of the list.</p>

<p><b>Deletion</b> &minus; Deletes an element at the beginning of the list.</p>

<p><b>Display</b> &minus; Displays the complete list.</p>

<p><b>Search</b> &minus; Searches an element using the given key.</p>

<p><b>Delete</b> &minus; Deletes an element using the given key.</p>

<h2>Insertion Operation</h2>

<p>Adding a new node in linked list is a more than one step activity. We shall learn this with diagrams here. First, create a node using the same structure and find the location where it has to be inserted.</p>

<p>Imagine that we are inserting a node <b>B</b> (NewNode), between <b>A</b> (LeftNode) and <b>C</b> (RightNode). Then point B.next to C &minus;</p>

<p>It should look like this &minus;</p>

<p>Now, the next node at the left should point to the new node.</p>

<p>This will put the new node in the middle of the two. The new list should look like this &minus;</p>

<p>Similar steps should be taken if the node is being inserted at the beginning of the list. While inserting it at the end, the second last node of the list should point to the new node and the new node will point to NULL.</p>

<h2>Deletion Operation</h2>

<p>Deletion is also a more than one step process. We shall learn with pictorial representation. First, locate the target node to be removed, by using searching algorithms.</p>

<p>The left (previous) node of the target node now should point to the next node of the target node &minus;</p>

<p>This will remove the link that was pointing to the target node. Now, using the following code, we will remove what the target node is pointing at.</p>

<p>We need to use the deleted node. We can keep that in memory otherwise we can simply deallocate memory and wipe off the target node completely.</p>

<h2>Reverse Operation</h2>

<p>This operation is a thorough one. We need to make the last node to be pointed by the head node and reverse the whole linked list.</p>

<p>First, we traverse to the end of the list. It should be pointing to NULL. Now, we shall make it point to its previous node &minus;</p>

<p>We have to make sure that the last node is not the lost node. So we'll have some temp node, which looks like the head node pointing to the last node. Now, we shall make all left side nodes point to their previous nodes one by one.</p>

<p>Except the node (first node) pointed by the head node, all nodes should point to their predecessor, making them their new successor. The first node will point to NULL.</p>

<p>We'll make the head node point to the new first node by using the temp node.</p>

<p>The linked list is now reversed. To see linked list implementation in C programming language, please <a href="/data_structures_algorithms/linked_list_program_in_c.htm">click here</a>.</p>

<h1>Data Structure - Doubly Linked List</h1>

<p>Doubly Linked List is a variation of Linked list in which navigation is possible in both ways, either forward and backward easily as compared to Single Linked List. Following are the important terms to understand the concept of doubly linked list.</p>

<p><b>Link</b> &minus; Each link of a linked list can store a data called an element.</p>

<p><b>Next</b> &minus; Each link of a linked list contains a link to the next link called Next.</p>

<p><b>Prev</b> &minus; Each link of a linked list contains a link to the previous link called Prev.</p>

<p><b>LinkedList</b> &minus; A Linked List contains the connection link to the first link called First and to the last link called Last.</p>

<h2>Doubly Linked List Representation</h2>

<p>As per the above illustration, following are the important points to be considered.</p>

<p>Doubly Linked List contains a link element called first and last.</p>

<p>Each link carries a data field(s) and two link fields called next and prev.</p>

<p>Each link is linked with its next link using its next link.</p>

<p>Each link is linked with its previous link using its previous link.</p>

<p>The last link carries a link as null to mark the end of the list.</p>

<h2>Basic Operations</h2>

<p>Following are the basic operations supported by a list.</p>

<p><b>Insertion</b> &minus; Adds an element at the beginning of the list.</p>

<p><b>Deletion</b> &minus; Deletes an element at the beginning of the list.</p>

<p><b>Insert Last</b> &minus; Adds an element at the end of the list.</p>

<p><b>Delete Last</b> &minus; Deletes an element from the end of the list.</p>

<p><b>Insert After</b> &minus; Adds an element after an item of the list.</p>

<p><b>Delete</b> &minus; Deletes an element from the list using the key.</p>

<p><b>Display forward</b> &minus; Displays the complete list in a forward manner.</p>

<p><b>Display backward</b> &minus; Displays the complete list in a backward manner.</p>

<h2>Insertion Operation</h2>

<p>Following code demonstrates the insertion operation at the beginning of a doubly linked list.</p>

<h3>Example</h3>

<h2>Deletion Operation</h2>

<p>Following code demonstrates the deletion operation at the beginning of a doubly linked list.</p>

<h3>Example</h3>

<h2>Insertion at the End of an Operation</h2>

<p>Following code demonstrates the insertion operation at the last position of a doubly linked list.</p>

<h3>Example</h3>

<p>To see the implementation in C programming language, please <a href="/data_structures_algorithms/doubly_linked_list_program_in_c.htm">click here</a>.</p>

<h1>Data Structure - Circular Linked List</h1>

<p>Circular Linked List is a variation of Linked list in which the first element points to the last element and the last element points to the first element. Both Singly Linked List and Doubly Linked List can be made into a circular linked list.</p>

<h2>Singly Linked List as Circular</h2>

<p>In singly linked list, the next pointer of the last node points to the first node.</p>

<h2>Doubly Linked List as Circular</h2>

<p>In doubly linked list, the next pointer of the last node points to the first node and the previous pointer of the first node points to the last node making the circular in both directions.</p>

<p>As per the above illustration, following are the important points to be considered.</p>

<p>The last link's next points to the first link of the list in both cases of singly as well as doubly linked list.</p>

<p>The first link's previous points to the last of the list in case of doubly linked list.</p>

<h2>Basic Operations</h2>

<p>Following are the important operations supported by a circular list.</p>

<p><b>insert</b> &minus; Inserts an element at the start of the list.</p>

<p><b>delete</b> &minus; Deletes an element from the start of the list.</p>

<p><b>display</b> &minus; Displays the list.</p>

<h2>Insertion Operation</h2>

<p>Following code demonstrates the insertion operation in a circular linked list based on single linked list.</p>

<h3>Example</h3>

<h2>Deletion Operation</h2>

<p>Following code demonstrates the deletion operation in a circular linked list based on single linked list.</p>

<h2>Display List Operation</h2>

<p>Following code demonstrates the display list operation in a circular linked list.</p>

<p>To know about its implementation in C programming language, please <a href="/data_structures_algorithms/circular_linked_list_program_in_c.htm">click here</a>.</p>

<h1>Data Structure and Algorithms - Stack</h1>

<p>A stack is an Abstract Data Type (ADT), commonly used in most programming languages. It is named stack as it behaves like a real-world stack, for example – a deck of cards or a pile of plates, etc.</p>

<p>A real-world stack allows operations at one end only. For example, we can place or remove a card or plate from the top of the stack only. Likewise, Stack ADT allows all data operations at one end only. At any given time, we can only access the top element of a stack.</p>

<p>This feature makes it LIFO data structure. LIFO stands for Last-in-first-out. Here, the element which is placed (inserted or added) last, is accessed first. In stack terminology, insertion operation is called <b>PUSH</b> operation and removal operation is called <b>POP</b> operation.</p>

<h2>Stack Representation</h2>

<p>The following diagram depicts a stack and its operations &minus;</p>

<p>A stack can be implemented by means of Array, Structure, Pointer, and Linked List. Stack can either be a fixed size one or it may have a sense of dynamic resizing. Here, we are going to implement stack using arrays, which makes it a fixed size stack implementation.</p>

<h2>Basic Operations</h2>

<p>Stack operations may involve initializing the stack, using it and then de-initializing it. Apart from these basic stuffs, a stack is used for the following two primary operations &minus;</p>

<p><b>push()</b> &minus; Pushing (storing) an element on the stack.</p>

<p><b>pop()</b> &minus; Removing (accessing) an element from the stack.</p>

<p>When data is PUSHed onto stack.</p>

<p>To use a stack efficiently, we need to check the status of stack as well. For the same purpose, the following functionality is added to stacks &minus;</p>

<p><b>peek()</b> &minus; get the top data element of the stack, without removing it.</p>

<p><b>isFull()</b> &minus; check if stack is full.</p>

<p><b>isEmpty()</b> &minus; check if stack is empty.</p>

<p>At all times, we maintain a pointer to the last PUSHed data on the stack. As this pointer always represents the top of the stack, hence named <b>top</b>. The <b>top</b> pointer provides top value of the stack without actually removing it.</p>

<p>First we should learn about procedures to support stack functions &minus;</p>

<h3>peek()</h3>

<p>Algorithm of peek() function &minus;</p>

<p>Implementation of peek() function in C programming language &minus;</p>

<p><b>Example</b></p>

<h3>isfull()</h3>

<p>Algorithm of isfull() function &minus;</p>

<p>Implementation of isfull() function in C programming language &minus;</p>

<p><b>Example</b></p>

<h3>isempty()</h3>

<p>Algorithm of isempty() function &minus;</p>

<p>Implementation of isempty() function in C programming language is slightly different. We initialize top at -1, as the index in array starts from 0. So we check if the top is below zero or -1 to determine if the stack is empty. Here's the code &minus;</p>

<p><b>Example</b></p>

<h2>Push Operation</h2>

<p>The process of putting a new data element onto stack is known as a Push Operation. Push operation involves a series of steps &minus;</p>

<p><b>Step 1</b> &minus; Checks if the stack is full.</p>

<p><b>Step 2</b> &minus; If the stack is full, produces an error and exit.</p>

<p><b>Step 3</b> &minus; If the stack is not full, increments <b>top</b> to point next empty space.</p>

<p><b>Step 4</b> &minus; Adds data element to the stack location, where top is pointing.</p>

<p><b>Step 5</b> &minus; Returns success.</p>

<p>If the linked list is used to implement the stack, then in step 3, we need to allocate space dynamically.</p>

<h3>Algorithm for PUSH Operation</h3>

<p>A simple algorithm for Push operation can be derived as follows &minus;</p>

<p>Implementation of this algorithm in C, is very easy. See the following code &minus;</p>

<p><b>Example</b></p>

<h2>Pop Operation</h2>

<p>Accessing the content while removing it from the stack, is known as a Pop Operation. In an array implementation of pop() operation, the data element is not actually removed, instead <b>top</b> is decremented to a lower position in the stack to point to the next value. But in linked-list implementation, pop() actually removes data element and deallocates memory space.</p>

<p>A Pop operation may involve the following steps &minus;</p>

<p><b>Step 1</b> &minus; Checks if the stack is empty.</p>

<p><b>Step 2</b> &minus; If the stack is empty, produces an error and exit.</p>

<p><b>Step 3</b> &minus; If the stack is not empty, accesses the data element at which <b>top</b> is pointing.</p>

<p><b>Step 4</b> &minus; Decreases the value of top by 1.</p>

<p><b>Step 5</b> &minus; Returns success.</p>

<h3>Algorithm for Pop Operation</h3>

<p>A simple algorithm for Pop operation can be derived as follows &minus;</p>

<p>Implementation of this algorithm in C, is as follows &minus;</p>

<p><b>Example</b></p>

<p>For a complete stack program in C programming language, please <a href="/data_structures_algorithms/stack_program_in_c.htm" alt="Stack Program in C">click here</a>.</p>

<h1>Data Structure - Expression Parsing</h1>

<p>The way to write arithmetic expression is known as a <b>notation</b>. An arithmetic expression can be written in three different but equivalent notations, i.e., without changing the essence or output of an expression. These notations are &minus;</p>

<p>These notations are named as how they use operator in expression. We shall learn the same here in this chapter.</p>

<h2>Infix Notation</h2>

<p>We write expression in <b>infix</b> notation, e.g. a - b &plus; c, where operators are used <b>in</b>-between operands. It is easy for us humans to read, write, and speak in infix notation but the same does not go well with computing devices. An algorithm to process infix notation could be difficult and costly in terms of time and space consumption.</p>

<h2>Prefix Notation</h2>

<p>In this notation, operator is <b>prefix</b>ed to operands, i.e. operator is written ahead of operands. For example, <b>&plus;ab</b>. This is equivalent to its infix notation <b>a &plus; b</b>. Prefix notation is also known as <b>Polish Notation</b>.</p>

<h2>Postfix Notation</h2>

<p>This notation style is known as <b>Reversed Polish Notation</b>. In this notation style, the operator is <b>postfix</b>ed to the operands i.e., the operator is written after the operands. For example, <b>ab&plus;</b>. This is equivalent to its infix notation <b>a &plus; b</b>.</p>

<p>The following table briefly tries to show the difference in all three notations &minus;</p>

<h2>Parsing Expressions</h2>

<p>As we have discussed, it is not a very efficient way to design an algorithm or program to parse infix notations. Instead, these infix notations are first converted into either postfix or prefix notations and then computed.</p>

<p>To parse any arithmetic expression, we need to take care of operator precedence and associativity also.</p>

<h3>Precedence</h3>

<p>When an operand is in between two different operators, which operator will take the operand first, is decided by the precedence of an operator over others. For example &minus;</p>

<p>As multiplication operation has precedence over addition, b * c will be evaluated first. A table of operator precedence is provided later.</p>

<h3>Associativity</h3>

<p>Associativity describes the rule where operators with the same precedence appear in an expression. For example, in expression a &plus; b − c, both &plus; and – have the same precedence, then which part of the expression will be evaluated first, is determined by associativity of those operators. Here, both &plus; and − are left associative, so the expression will be evaluated as <b>(a &plus; b) − c</b>.</p>

<p>Precedence and associativity determines the order of evaluation of an expression. Following is an operator precedence and associativity table (highest to lowest) &minus;</p>

<p>The above table shows the default behavior of operators. At any point of time in expression evaluation, the order can be altered by using parenthesis. For example &minus;</p>

<p>In <b>a &plus; b*c</b>, the expression part <b>b</b>*<b>c</b> will be evaluated first, with multiplication as precedence over addition. We here use parenthesis for <b>a &plus; b</b> to be evaluated first, like <b>(a &plus; b)*c</b>.</p>

<h2>Postfix Evaluation Algorithm</h2>

<p>We shall now look at the algorithm on how to evaluate postfix notation &minus;</p>

<p>To see the implementation in C programming language, please <a href="/data_structures_algorithms/expression_parsing_using_statck.htm">click here</a>.</p>

<h1>Data Structure and Algorithms - Queue</h1>

<p>Queue is an abstract data structure, somewhat similar to Stacks. Unlike stacks, a queue is open at both its ends. One end is always used to insert data (enqueue) and the other is used to remove data (dequeue). Queue follows First-In-First-Out methodology, i.e., the data item stored first will be accessed first.</p>

<p>A real-world example of queue can be a single-lane one-way road, where the vehicle enters first, exits first. More real-world examples can be seen as queues at the ticket windows and bus-stops.</p>

<h2>Queue Representation</h2>

<p>As we now understand that in queue, we access both ends for different reasons. The following diagram given below tries to explain queue representation as data structure &minus;</p>

<p>As in stacks, a queue can also be implemented using Arrays, Linked-lists, Pointers and Structures. For the sake of simplicity, we shall implement queues using one-dimensional array.</p>

<h2>Basic Operations</h2>

<p>Queue operations may involve initializing or defining the queue, utilizing it, and then completely erasing it from the memory. Here we shall try to understand the basic operations associated with queues &minus;</p>

<p><b>enqueue()</b> &minus; add (store) an item to the queue.</p>

<p><b>dequeue()</b> &minus; remove (access) an item from the queue.</p>

<p>Few more functions are required to make the above-mentioned queue operation efficient. These are &minus;</p>

<p><b>peek()</b> &minus; Gets the element at the front of the queue without removing it.</p>

<p><b>isfull()</b> &minus; Checks if the queue is full.</p>

<p><b>isempty()</b> &minus; Checks if the queue is empty.</p>

<p>In queue, we always dequeue (or access) data, pointed by <b>front</b> pointer and while enqueing (or storing) data in the queue we take help of <b>rear</b> pointer.</p>

<p>Let's first learn about supportive functions of a queue &minus;</p>

<h3>peek()</h3>

<p>This function helps to see the data at the <b>front</b> of the queue. The algorithm of peek() function is as follows &minus;</p>

<p><b>Algorithm</b></p>

<p>Implementation of peek() function in C programming language &minus;</p>

<p><b>Example</b></p>

<h3>isfull()</h3>

<p>As we are using single dimension array to implement queue, we just check for the rear pointer to reach at MAXSIZE to determine that the queue is full. In case we maintain the queue in a circular linked-list, the algorithm will differ. Algorithm of isfull() function &minus;</p>

<p><b>Algorithm</b></p>

<p>Implementation of isfull() function in C programming language &minus;</p>

<p><b>Example</b></p>

<h3>isempty()</h3>

<p>Algorithm of isempty() function &minus;</p>

<p><b>Algorithm</b></p>

<p>If the value of <b>front</b> is less than MIN or 0, it tells that the queue is not yet initialized, hence empty.</p>

<p>Here's the C programming code &minus;</p>

<p><b>Example</b></p>

<h2>Enqueue Operation</h2>

<p>Queues maintain two data pointers, <b>front</b> and <b>rear</b>. Therefore, its operations are comparatively difficult to implement than that of stacks.</p>

<p>The following steps should be taken to enqueue (insert) data into a queue &minus;</p>

<p><b>Step 1</b> &minus; Check if the queue is full.</p>

<p><b>Step 2</b> &minus; If the queue is full, produce overflow error and exit.</p>

<p><b>Step 3</b> &minus; If the queue is not full, increment <b>rear</b> pointer to point the next empty space.</p>

<p><b>Step 4</b> &minus; Add data element to the queue location, where the rear is pointing.</p>

<p><b>Step 5</b> &minus; return success.</p>

<p>Sometimes, we also check to see if a queue is initialized or not, to handle any unforeseen situations.</p>

<p><b>Algorithm for enqueue operation</b></p>

<p>Implementation of enqueue() in C programming language &minus;</p>

<p><b>Example</b></p>

<h2>Dequeue Operation</h2>

<p>Accessing data from the queue is a process of two tasks − access the data where <b>front</b> is pointing and remove the data after access. The following steps are taken to perform <b>dequeue</b> operation &minus;</p>

<p><b>Step 1</b> &minus; Check if the queue is empty.</p>

<p><b>Step 2</b> &minus; If the queue is empty, produce underflow error and exit.</p>

<p><b>Step 3</b> &minus; If the queue is not empty, access the data where <b>front</b> is pointing.</p>

<p><b>Step 4</b> &minus; Increment <b>front</b> pointer to point to the next available data element.</p>

<p><b>Step 5</b> &minus; Return success.</p>

<p><b>Algorithm for dequeue operation</b></p>

<p>Implementation of dequeue() in C programming language &minus;</p>

<p><b>Example</b></p>

<p>For a complete Queue program in C programming language, please <a href="/data_structures_algorithms/queue_program_in_c.htm">click here</a>.</p>

<h1>Data Structure and Algorithms Linear Search</h1>

<p>Linear search is a very simple search algorithm. In this type of search, a sequential search is made over all items one by one. Every item is checked and if a match is found then that particular item is returned, otherwise the search continues till the end of the data collection.</p>

<h2>Algorithm</h2>

<h2>Pseudocode</h2>

<p>To know about linear search implementation in C programming language, please <a href="/data_structures_algorithms/linear_search_program_in_c.htm">click-here</a>.</p>

<h1>Data Structure and Algorithms Binary Search</h1>

<p>Binary search is a fast search algorithm with run-time complexity of &Omicron;(log n). This search algorithm works on the principle of divide and conquer. For this algorithm to work properly, the data collection should be in the sorted form.</p>

<p>Binary search looks for a particular item by comparing the middle most item of the collection. If a match occurs, then the index of item is returned. If the middle item is greater than the item, then the item is searched in the sub-array to the left of the middle item. Otherwise, the item is searched for in the sub-array to the right of the middle item. This process continues on the sub-array as well until the size of the subarray reduces to zero.</p>

<h2>How Binary Search Works?</h2>

<p>For a binary search to work, it is mandatory for the target array to be sorted. We shall learn the process of binary search with a pictorial example. The following is our sorted array and let us assume that we need to search the location of value 31 using binary search.</p>

<p>First, we shall determine half of the array by using this formula &minus;</p>

<p>Here it is, 0 &plus; (9 - 0 ) / 2 = 4 (integer value of 4.5). So, 4 is the mid of the array.</p>

<p>Now we compare the value stored at location 4, with the value being searched, i.e. 31. We find that the value at location 4 is 27, which is not a match. As the value is greater than 27 and we have a sorted array, so we also know that the target value must be in the upper portion of the array.</p>

<p>We change our low to mid &plus; 1 and find the new mid value again.</p>

<p>Our new mid is 7 now. We compare the value stored at location 7 with our target value 31.</p>

<p>The value stored at location 7 is not a match, rather it is more than what we are looking for. So, the value must be in the lower part from this location.</p>

<p>Hence, we calculate the mid again. This time it is 5.</p>

<p>We compare the value stored at location 5 with our target value. We find that it is a match.</p>

<p>We conclude that the target value 31 is stored at location 5.</p>

<p>Binary search halves the searchable items and thus reduces the count of comparisons to be made to very less numbers.</p>

<h2>Pseudocode</h2>

<p>The pseudocode of binary search algorithms should look like this &minus;</p>

<p>To know about binary search implementation using array in C programming language, please <a href="/data_structures_algorithms/binary_search_program_in_c.htm">click here</a>.</p>

<h1>Data Structure - Interpolation Search</h1>

<p>Interpolation search is an improved variant of binary search. This search algorithm works on the probing position of the required value. For this algorithm to work properly, the data collection should be in a sorted form and equally distributed.</p>

<p>Binary search has a huge advantage of time complexity over linear search. Linear search has worst-case complexity of &Omicron;(n) whereas binary search has &Omicron;(log n).</p>

<p>There are cases where the location of target data may be known in advance. For example, in case of a telephone directory, if we want to search the telephone number of Morphius. Here, linear search and even binary search will seem slow as we can directly jump to memory space where the names start from 'M' are stored.</p>

<h2>Positioning in Binary Search</h2>

<p>In binary search, if the desired data is not found then the rest of the list is divided in two parts, lower and higher. The search is carried out in either of them.</p>

<p>Even when the data is sorted, binary search does not take advantage to probe the position of the desired data.</p>

<h2>Position Probing in Interpolation Search</h2>

<p>Interpolation search finds a particular item by computing the probe position. Initially, the probe position is the position of the middle most item of the collection.</p>

<p>If a match occurs, then the index of the item is returned. To split the list into two parts, we use the following method &minus;</p>

<p>If the middle item is greater than the item, then the probe position is again calculated in the sub-array to the right of the middle item. Otherwise, the item is searched in the subarray to the left of the middle item. This process continues on the sub-array as well until the size of subarray reduces to zero.</p>

<p>Runtime complexity of interpolation search algorithm is <b>&Omicron;(log (log n))</b> as compared to <b>&Omicron;(log n)</b> of BST in favorable situations.</p>

<h3>Algorithm</h3>

<p>As it is an improvisation of the existing BST algorithm, we are mentioning the steps to search the 'target' data value index, using position probing &minus;</p>

<h2>Pseudocode</h2>

<p>To know about the implementation of interpolation search in C programming language, <a href="/data_structures_algorithms/interpolation_search_in_c.htm" >click here</a>.</p>

<h1>Data Structure and Algorithms - Hash Table</h1>

<p>Hash Table is a data structure which stores data in an associative manner. In a hash table, data is stored in an array format, where each data value has its own unique index value. Access of data becomes very fast if we know the index of the desired data.</p>

<p>Thus, it becomes a data structure in which insertion and search operations are very fast irrespective of the size of the data. Hash Table uses an array as a storage medium and uses hash technique to generate an index where an element is to be inserted or is to be located from.</p>

<h2>Hashing</h2>

<p>Hashing is a technique to convert a range of key values into a range of indexes of an array. We're going to use modulo operator to get a range of key values. Consider an example of hash table of size 20, and the following items are to be stored. Item are in the (key,value) format.</p>

<h2>Linear Probing</h2>

<p>As we can see, it may happen that the hashing technique is used to create an already used index of the array. In such a case, we can search the next empty location in the array by looking into the next cell until we find an empty cell. This technique is called linear probing.</p>

<h2>Basic Operations</h2>

<p>Following are the basic primary operations of a hash table.</p>

<p><b>Search</b> &minus; Searches an element in a hash table.</p>

<p><b>Insert</b> &minus; inserts an element in a hash table.</p>

<p><b>delete</b> &minus; Deletes an element from a hash table.</p>

<h2>DataItem</h2>

<p>Define a data item having some data and key, based on which the search is to be conducted in a hash table.</p>

<h2>Hash Method</h2>

<p>Define a hashing method to compute the hash code of the key of the data item.</p>

<h2>Search Operation</h2>

<p>Whenever an element is to be searched, compute the hash code of the key passed and locate the element using that hash code as index in the array. Use linear probing to get the element ahead if the element is not found at the computed hash code.</p>

<h3>Example</h3>

<h2>Insert Operation</h2>

<p>Whenever an element is to be inserted, compute the hash code of the key passed and locate the index using that hash code as an index in the array. Use linear probing for empty location, if an element is found at the computed hash code.</p>

<h3>Example</h3>

<h2>Delete Operation</h2>

<p>Whenever an element is to be deleted, compute the hash code of the key passed and locate the index using that hash code as an index in the array. Use linear probing to get the element ahead if an element is not found at the computed hash code. When found, store a dummy item there to keep the performance of the hash table intact.</p>

<h3>Example</h3>

<p>To know about hash implementation in C programming language, please <a href="/data_structures_algorithms/hash_table_program_in_c.htm">click here</a>.</p>

<h1>Data Structure - Sorting Techniques</h1>

<p>Sorting refers to arranging data in a particular format. Sorting algorithm specifies the way to arrange data in a particular order. Most common orders are in numerical or lexicographical order.</p>

<p>The importance of sorting lies in the fact that data searching can be optimized to a very high level, if data is stored in a sorted manner. Sorting is also used to represent data in more readable formats. Following are some of the examples of sorting in real-life scenarios &minus;</p>

<p><b>Telephone Directory</b> &minus; The telephone directory stores the telephone numbers of people sorted by their names, so that the names can be searched easily.</p>

<p><b>Dictionary</b> &minus; The dictionary stores words in an alphabetical order so that searching of any word becomes easy.</p>

<h2>In-place Sorting and Not-in-place Sorting</h2>

<p>Sorting algorithms may require some extra space for comparison and temporary storage of few data elements. These algorithms do not require any extra space and sorting is said to happen in-place, or for example, within the array itself. This is called <b>in-place sorting</b>. Bubble sort is an example of in-place sorting.</p>

<p>However, in some sorting algorithms, the program requires space which is more than or equal to the elements being sorted. Sorting which uses equal or more space is called <b>not-in-place sorting</b>. Merge-sort is an example of not-in-place sorting.</p>

<h2>Stable and Not Stable Sorting</h2>

<p>If a sorting algorithm, after sorting the contents, does not change the sequence of similar content in which they appear, it is called <b>stable sorting</b>.</p>

<p>If a sorting algorithm, after sorting the contents, changes the sequence of similar content in which they appear, it is called <b>unstable sorting</b>.</p>

<p>Stability of an algorithm matters when we wish to maintain the sequence of original elements, like in a tuple for example.</p>

<h2>Adaptive and Non-Adaptive Sorting Algorithm</h2>

<p>A sorting algorithm is said to be adaptive, if it takes advantage of already 'sorted' elements in the list that is to be sorted. That is, while sorting if the source list has some element already sorted, adaptive algorithms will take this into account and will try not to re-order them.</p>

<p>A non-adaptive algorithm is one which does not take into account the elements which are already sorted. They try to force every single element to be re-ordered to confirm their sortedness.</p>

<h2>Important Terms</h2>

<p>Some terms are generally coined while discussing sorting techniques, here is a brief introduction to them &minus;</p>

<h3>Increasing Order</h3>

<p>A sequence of values is said to be in <b>increasing order</b>, if the successive element is greater than the previous one. For example, 1, 3, 4, 6, 8, 9 are in increasing order, as every next element is greater than the previous element.</p>

<h3>Decreasing Order</h3>

<p>A sequence of values is said to be in <b>decreasing order</b>, if the successive element is less than the current one. For example, 9, 8, 6, 4, 3, 1 are in decreasing order, as every next element is less than the previous element.</p>

<h3>Non-Increasing Order</h3>

<p>A sequence of values is said to be in <b>non-increasing order</b>, if the successive element is less than or equal to its previous element in the sequence. This order occurs when the sequence contains duplicate values. For example, 9, 8, 6, 3, 3, 1 are in non-increasing order, as every next element is less than or equal to (in case of 3) but not greater than any previous element.</p>

<h3>Non-Decreasing Order</h3>

<p>A sequence of values is said to be in <b>non-decreasing order</b>, if the successive element is greater than or equal to its previous element in the sequence. This order occurs when the sequence contains duplicate values. For example, 1, 3, 3, 6, 8, 9 are in non-decreasing order, as every next element is greater than or equal to (in case of 3) but not less than the previous one.</p>

<h1>Data Structure - Bubble Sort Algorithm</h1>

<p>Bubble sort is a simple sorting algorithm. This sorting algorithm is comparison-based algorithm in which each pair of adjacent elements is compared and the elements are swapped if they are not in order. This algorithm is not suitable for large data sets as its average and worst case complexity are of &Omicron;(n<sup>2</sup>) where <b>n</b> is the number of items.</p>

<h2>How Bubble Sort Works?</h2>

<p>We take an unsorted array for our example. Bubble sort takes &Omicron;(n<sup>2</sup>) time so we're keeping it short and precise.</p>

<p>Bubble sort starts with very first two elements, comparing them to check which one is greater.</p>

<p>In this case, value 33 is greater than 14, so it is already in sorted locations. Next, we compare 33 with 27.</p>

<p>We find that 27 is smaller than 33 and these two values must be swapped.</p>

<p>The new array should look like this &minus;</p>

<p>Next we compare 33 and 35. We find that both are in already sorted positions.</p>

<p>Then we move to the next two values, 35 and 10.</p>

<p>We know then that 10 is smaller 35. Hence they are not sorted.</p>

<p>We swap these values. We find that we have reached the end of the array. After one iteration, the array should look like this &minus;</p>

<p>To be precise, we are now showing how an array should look like after each iteration. After the second iteration, it should look like this &minus;</p>

<p>Notice that after each iteration, at least one value moves at the end.</p>

<p>And when there's no swap required, bubble sorts learns that an array is completely sorted.</p>

<p>Now we should look into some practical aspects of bubble sort.</p>

<h2>Algorithm</h2>

<p>We assume <b>list</b> is an array of <b>n</b> elements. We further assume that <b>swap</b> function swaps the values of the given array elements.</p>

<h2>Pseudocode</h2>

<p>We observe in algorithm that Bubble Sort compares each pair of array element unless the whole array is completely sorted in an ascending order. This may cause a few complexity issues like what if the array needs no more swapping as all the elements are already ascending.</p>

<p>To ease-out the issue, we use one flag variable <b>swapped</b> which will help us see if any swap has happened or not. If no swap has occurred, i.e. the array requires no more processing to be sorted, it will come out of the loop.</p>

<p>Pseudocode of BubbleSort algorithm can be written as follows &minus;</p>

<h2>Implementation</h2>

<p>One more issue we did not address in our original algorithm and its improvised pseudocode, is that, after every iteration the highest values settles down at the end of the array. Hence, the next iteration need not include already sorted elements. For this purpose, in our implementation, we restrict the inner loop to avoid already sorted values.</p>

<p>To know about bubble sort implementation in C programming language, please <a href="/data_structures_algorithms/bubble_sort_program_in_c.htm">click here</a>.</p>

<h1>Data Structure and Algorithms Insertion Sort</h1>

<p>This is an in-place comparison-based sorting algorithm. Here, a sub-list is maintained which is always sorted. For example, the lower part of an array is maintained to be sorted. An element which is to be 'insert'ed in this sorted sub-list, has to find its appropriate place and then it has to be inserted there. Hence the name, <b>insertion sort</b>.</p>

<p>The array is searched sequentially and unsorted items are moved and inserted into the sorted sub-list (in the same array). This algorithm is not suitable for large data sets as its average and worst case complexity are of &Omicron;(n<sup>2</sup>), where <b>n</b> is the number of items.</p>

<h2>How Insertion Sort Works?</h2>

<p>We take an unsorted array for our example.</p>

<p>Insertion sort compares the first two elements.</p>

<p>It finds that both 14 and 33 are already in ascending order. For now, 14 is in sorted sub-list.</p>

<p>Insertion sort moves ahead and compares 33 with 27.</p>

<p>And finds that 33 is not in the correct position.</p>

<p>It swaps 33 with 27. It also checks with all the elements of sorted sub-list. Here we see that the sorted sub-list has only one element 14, and 27 is greater than 14. Hence, the sorted sub-list remains sorted after swapping.</p>

<p>By now we have 14 and 27 in the sorted sub-list. Next, it compares 33 with 10.</p>

<p>These values are not in a sorted order.</p>

<p>So we swap them.</p>

<p>However, swapping makes 27 and 10 unsorted.</p>

<p>Hence, we swap them too.</p>

<p>Again we find 14 and 10 in an unsorted order.</p>

<p>We swap them again. By the end of third iteration, we have a sorted sub-list of 4 items.</p>

<p>This process goes on until all the unsorted values are covered in a sorted sub-list. Now we shall see some programming aspects of insertion sort.</p>

<h3>Algorithm</h3>

<p>Now we have a bigger picture of how this sorting technique works, so we can derive simple steps by which we can achieve insertion sort.</p>

<h2>Pseudocode</h2>

<p>To know about insertion sort implementation in C programming language, please <a href="/data_structures_algorithms/insertion_sort_program_in_c.htm">click here</a>.</p>

<h1>Data Structure and Algorithms Selection Sort</h1>

<p>Selection sort is a simple sorting algorithm. This sorting algorithm is an in-place comparison-based algorithm in which the list is divided into two parts, the sorted part at the left end and the unsorted part at the right end. Initially, the sorted part is empty and the unsorted part is the entire list.</p>

<p>The smallest element is selected from the unsorted array and swapped with the leftmost element, and that element becomes a part of the sorted array. This process continues moving unsorted array boundary by one element to the right.</p>

<p>This algorithm is not suitable for large data sets as its average and worst case complexities are of &Omicron;(n<sup>2</sup>), where <b>n</b> is the number of items.</p>

<h2>How Selection Sort Works?</h2>

<p>Consider the following depicted array as an example.</p>

<p>For the first position in the sorted list, the whole list is scanned sequentially. The first position where 14 is stored presently, we search the whole list and find that 10 is the lowest value.</p>

<p>So we replace 14 with 10. After one iteration 10, which happens to be the minimum value in the list, appears in the first position of the sorted list.</p>

<p>For the second position, where 33 is residing, we start scanning the rest of the list in a linear manner.</p>

<p>We find that 14 is the second lowest value in the list and it should appear at the second place. We swap these values.</p>

<p>After two iterations, two least values are positioned at the beginning in a sorted manner.</p>

<p>The same process is applied to the rest of the items in the array.</p>

<p>Following is a pictorial depiction of the entire sorting process &minus;</p>

<p>Now, let us learn some programming aspects of selection sort.</p>

<h3>Algorithm</h3>

<h3>Pseudocode</h3>

<p>To know about selection sort implementation in C programming language, please <a href="/data_structures_algorithms/selection_sort_program_in_c.htm">click here</a>.</p>

<h1>Data Structures - Merge Sort Algorithm</h1>

<p>Merge sort is a sorting technique based on divide and conquer technique. With worst-case time complexity being &Omicron;(n log n), it is one of the most respected algorithms.</p>

<p>Merge sort first divides the array into equal halves and then combines them in a sorted manner.</p>

<h2>How Merge Sort Works?</h2>

<p>To understand merge sort, we take an unsorted array as the following &minus;</p>

<p>We know that merge sort first divides the whole array iteratively into equal halves unless the atomic values are achieved. We see here that an array of 8 items is divided into two arrays of size 4.</p>

<p>This does not change the sequence of appearance of items in the original. Now we divide these two arrays into halves.</p>

<p>We further divide these arrays and we achieve atomic value which can no more be divided.</p>

<p>Now, we combine them in exactly the same manner as they were broken down. Please note the color codes given to these lists.</p>

<p>We first compare the element for each list and then combine them into another list in a sorted manner. We see that 14 and 33 are in sorted positions. We compare 27 and 10 and in the target list of 2 values we put 10 first, followed by 27. We change the order of 19 and 35 whereas 42 and 44 are placed sequentially.</p>

<p>In the next iteration of the combining phase, we compare lists of two data values, and merge them into a list of found data values placing all in a sorted order.</p>

<p>After the final merging, the list should look like this &minus;</p>

<p>Now we should learn some programming aspects of merge sorting.</p>

<h3>Algorithm</h3>

<p>Merge sort keeps on dividing the list into equal halves until it can no more be divided. By definition, if it is only one element in the list, it is sorted. Then, merge sort combines the smaller sorted lists keeping the new list sorted too.</p>

<h3>Pseudocode</h3>

<p>We shall now see the pseudocodes for merge sort functions. As our algorithms point out two main functions − divide &amp; merge.</p>

<p>Merge sort works with recursion and we shall see our implementation in the same way.</p>

<p>To know about merge sort implementation in C programming language, please <a href="/data_structures_algorithms/merge_sort_program_in_c.htm">click here</a>.</p>

<h1>Data Structure and Algorithms - Shell Sort</h1>

<p>Shell sort is a highly efficient sorting algorithm and is based on insertion sort algorithm. This algorithm avoids large shifts as in case of insertion sort, if the smaller value is to the far right and has to be moved to the far left.</p>

<p>This algorithm uses insertion sort on a widely spread elements, first to sort them and then sorts the less widely spaced elements. This spacing is termed as <b>interval</b>. This interval is calculated based on Knuth's formula as &minus;</p>

<h3>Knuth's Formula</h3>

<p>This algorithm is quite efficient for medium-sized data sets as its average and worst case complexity are of &Omicron;(n), where <b>n</b> is the number of items.</p>

<h2>How Shell Sort Works?</h2>

<p>Let us consider the following example to have an idea of how shell sort works. We take the same array we have used in our previous examples. For our example and ease of understanding, we take the interval of 4. Make a virtual sub-list of all values located at the interval of 4 positions. Here these values are {35, 14}, {33, 19}, {42, 27} and {10, 44}</p>

<p>We compare values in each sub-list and swap them (if necessary) in the original array. After this step, the new array should look like this &minus;</p>

<p>Then, we take interval of 2 and this gap generates two sub-lists - {14, 27, 35, 42}, {19, 10, 33, 44}</p>

<p>We compare and swap the values, if required, in the original array. After this step, the array should look like this &minus;</p>

<p>Finally, we sort the rest of the array using interval of value 1. Shell sort uses insertion sort to sort the array.</p>

<p>Following is the step-by-step depiction &minus;</p>

<p>We see that it required only four swaps to sort the rest of the array.</p>

<h3>Algorithm</h3>

<p>Following is the algorithm for shell sort.</p>

<h2>Pseudocode</h2>

<p>Following is the pseudocode for shell sort.</p>

<p>To know about shell sort implementation in C programming language, please <a href="/data_structures_algorithms/shell_sort_program_in_c.htm">click here</a>.</p>

<h1>Data Structure and Algorithms - Quick Sort</h1>

<p>Quick sort is a highly efficient sorting algorithm and is based on partitioning of array of data into smaller arrays. A large array is partitioned into two arrays one of which holds values smaller than the specified value, say pivot, based on which the partition is made and another array holds values greater than the pivot value.</p>

<p>Quick sort partitions an array and then calls itself recursively twice to sort the two resulting subarrays. This algorithm is quite efficient for large-sized data sets as its average and worst case complexity are of &Omicron;(nlogn), where <b>n</b> is the number of items.</p>

<h2>Partition in Quick Sort</h2>

<p>Following animated representation explains how to find the pivot value in an array.</p>

<p>The pivot value divides the list into two parts. And recursively, we find the pivot for each sub-lists until all lists contains only one element.</p>

<h2>Quick Sort Pivot Algorithm</h2>

<p>Based on our understanding of partitioning in quick sort, we will now try to write an algorithm for it, which is as follows.</p>

<h2>Quick Sort Pivot Pseudocode</h2>

<p>The pseudocode for the above algorithm can be derived as &minus;</p>

<h2>Quick Sort Algorithm</h2>

<p>Using pivot algorithm recursively, we end up with smaller possible partitions. Each partition is then processed for quick sort. We define recursive algorithm for quicksort as follows &minus;</p>

<h2>Quick Sort Pseudocode</h2>

<p>To get more into it, let see the pseudocode for quick sort algorithm &minus;</p>

<p>To know about quick sort implementation in C programming language, please <a href="/data_structures_algorithms/quick_sort_program_in_c.htm">click here</a>.</p>

<h1>Data Structure - Graph Data Structure</h1>

<p>A graph is a pictorial representation of a set of objects where some pairs of objects are connected by links. The interconnected objects are represented by points termed as <b>vertices</b>, and the links that connect the vertices are called <b>edges</b>.</p>

<p>Formally, a graph is a pair of sets <b>(V, E)</b>, where <b>V</b> is the set of vertices and <b>E</b> is the set of edges, connecting the pairs of vertices. Take a look at the following graph &minus;</p>

<p>In the above graph,</p>

<h2>Graph Data Structure</h2>

<p>Mathematical graphs can be represented in data structure. We can represent a graph using an array of vertices and a two-dimensional array of edges. Before we proceed further, let's familiarize ourselves with some important terms &minus;</p>

<p><b>Vertex</b> &minus; Each node of the graph is represented as a vertex. In the following example, the labeled circle represents vertices. Thus, A to G are vertices. We can represent them using an array as shown in the following image. Here A can be identified by index 0. B can be identified using index 1 and so on.</p>

<p><b>Edge</b> &minus; Edge represents a path between two vertices or a line between two vertices. In the following example, the lines from A to B, B to C, and so on represents edges. We can use a two-dimensional array to represent an array as shown in the following image. Here AB can be represented as 1 at row 0, column 1, BC as 1 at row 1, column 2 and so on, keeping other combinations as 0.</p>

<p><b>Adjacency</b> &minus; Two node or vertices are adjacent if they are connected to each other through an edge. In the following example, B is adjacent to A, C is adjacent to B, and so on.</p>

<p><b>Path</b> &minus; Path represents a sequence of edges between the two vertices. In the following example, ABCD represents a path from A to D.</p>

<h2>Basic Operations</h2>

<p>Following are basic primary operations of a Graph &minus;</p>

<p><b>Add Vertex</b> &minus; Adds a vertex to the graph.</p>

<p><b>Add Edge</b> &minus; Adds an edge between the two vertices of the graph.</p>

<p><b>Display Vertex</b> &minus; Displays a vertex of the graph.</p>

<p>To know more about Graph, please read <a href="/graph_theory/index.htm">Graph Theory Tutorial</a>. We shall learn about traversing a graph in the coming chapters.</p>

<h1>Data Structure - Depth First Traversal</h1>

<p>Depth First Search (DFS) algorithm traverses a graph in a depthward motion and uses a stack to remember to get the next vertex to start a search, when a dead end occurs in any iteration.</p>

<p>As in the example given above, DFS algorithm traverses from A to B to C to D first then to E, then to F and lastly to G. It employs the following rules.</p>

<p><b>Rule 1</b> &minus; Visit the adjacent unvisited vertex. Mark it as visited. Display it. Push it in a stack.</p>

<p><b>Rule 2</b> &minus; If no adjacent vertex is found, pop up a vertex from the stack. (It will pop up all the vertices from the stack, which do not have adjacent vertices.)</p>

<p><b>Rule 3</b> &minus; Repeat Rule 1 and Rule 2 until the stack is empty.</p>

<p>As <b>C</b> does not have any unvisited adjacent node so we keep popping the stack until we find a node that has an unvisited adjacent node. In this case, there's none and we keep popping until the stack is empty.</p>

<p>To know about the implementation of this algorithm in C programming language, <a href="/data_structures_algorithms/depth_first_traversal_in_c.htm">click here</a>.</p>

<h1>Data Structure - Breadth First Traversal</h1>

<p>Breadth First Search (BFS) algorithm traverses a graph in a breadthward motion and uses a queue to remember to get the next vertex to start a search, when a dead end occurs in any iteration.</p>

<p>As in the example given above, BFS algorithm traverses from A to B to E to F first then to C and G lastly to D. It employs the following rules.</p>

<p><b>Rule 1</b> &minus; Visit the adjacent unvisited vertex. Mark it as visited. Display it. Insert it in a queue.</p>

<p><b>Rule 2</b> &minus; If no adjacent vertex is found, remove the first vertex from the queue.</p>

<p><b>Rule 3</b> &minus; Repeat Rule 1 and Rule 2 until the queue is empty.</p>

<p>At this stage, we are left with no unmarked (unvisited) nodes. But as per the algorithm we keep on dequeuing in order to get all unvisited nodes. When the queue gets emptied, the program is over.</p>

<p>The implementation of this algorithm in C programming language can be <a href="/data_structures_algorithms/breadth_first_traversal_in_c.htm">seen here</a>.</p>

<h1>Data Structure and Algorithms - Tree</h1>

<p>Tree represents the nodes connected by edges. We will discuss binary tree or binary search tree specifically.</p>

<p>Binary Tree is a special datastructure used for data storage purposes. A binary tree has a special condition that each node can have a maximum of two children. A binary tree has the benefits of both an ordered array and a linked list as search is as quick as in a sorted array and insertion or deletion operation are as fast as in linked list.</p>

<h2>Important Terms</h2>

<p>Following are the important terms with respect to tree.</p>

<p><b>Path</b> &minus; Path refers to the sequence of nodes along the edges of a tree.</p>

<p><b>Root</b> &minus; The node at the top of the tree is called root. There is only one root per tree and one path from the root node to any node.</p>

<p><b>Parent</b> &minus; Any node except the root node has one edge upward to a node called parent.</p>

<p><b>Child</b> &minus; The node below a given node connected by its edge downward is called its child node.</p>

<p><b>Leaf</b> &minus; The node which does not have any child node is called the leaf node.</p>

<p><b>Subtree</b> &minus; Subtree represents the descendants of a node.</p>

<p><b>Visiting</b> &minus; Visiting refers to checking the value of a node when control is on the node.</p>

<p><b>Traversing</b> &minus; Traversing means passing through nodes in a specific order.</p>

<p><b>Levels</b> &minus; Level of a node represents the generation of a node. If the root node is at level 0, then its next child node is at level 1, its grandchild is at level 2, and so on.</p>

<p><b>keys</b> &minus; Key represents a value of a node based on which a search operation is to be carried out for a node.</p>

<h2>Binary Search Tree Representation</h2>

<p>Binary Search tree exhibits a special behavior. A node's left child must have a value less than its parent's value and the node's right child must have a value greater than its parent value.</p>

<p>We're going to implement tree using node object and connecting them through references.</p>

<h2>Tree Node</h2>

<p>The code to write a tree node would be similar to what is given below. It has a data part and references to its left and right child nodes.</p>

<p>In a tree, all nodes share common construct.</p>

<h2>BST Basic Operations</h2>

<p>The basic operations that can be performed on a binary search tree data structure, are the following &minus;</p>

<p><b>Insert</b> &minus; Inserts an element in a tree/create a tree.</p>

<p><b>Search</b> &minus; Searches an element in a tree.</p>

<p><b>Preorder Traversal</b> &minus; Traverses a tree in a pre-order manner.</p>

<p><b>Inorder Traversal</b> &minus; Traverses a tree in an in-order manner.</p>

<p><b>Postorder Traversal</b> &minus; Traverses a tree in a post-order manner.</p>

<p>We shall learn creating (inserting into) a tree structure and searching a data item in a tree in this chapter. We shall learn about tree traversing methods in the coming chapter.</p>

<h2>Insert Operation</h2>

<p>The very first insertion creates the tree. Afterwards, whenever an element is to be inserted, first locate its proper location. Start searching from the root node, then if the data is less than the key value, search for the empty location in the left subtree and insert the data. Otherwise, search for the empty location in the right subtree and insert the data.</p>

<h3>Algorithm</h3>

<h3>Implementation</h3>

<p>The implementation of insert function should look like this &minus;</p>

<h2>Search Operation</h2>

<p>Whenever an element is to be searched, start searching from the root node, then if the data is less than the key value, search for the element in the left subtree. Otherwise, search for the element in the right subtree. Follow the same algorithm for each node.</p>

<h3>Algorithm</h3>

<p>The implementation of this algorithm should look like this.</p>

<p>To know about the implementation of binary search tree data structure, please <a href="/data_structures_algorithms/tree_traversal_in_c.htm"> click here</a>.</p>

<h1>Data Structure &amp; Algorithms - Tree Traversal</h1>

<p>Traversal is a process to visit all the nodes of a tree and may print their values too. Because, all nodes are connected via edges (links) we always start from the root (head) node. That is, we cannot randomly access a node in a tree. There are three ways which we use to traverse a tree &minus;</p>

<p>Generally, we traverse a tree to search or locate a given item or key in the tree or to print all the values it contains.</p>

<h2>In-order Traversal</h2>

<p>In this traversal method, the left subtree is visited first, then the root and later the right sub-tree. We should always remember that every node may represent a subtree itself.</p>

<p>If a binary tree is traversed <b>in-order</b>, the output will produce sorted key values in an ascending order.</p>

<p>We start from <b>A</b>, and following in-order traversal, we move to its left subtree <b>B</b>. <b>B</b> is also traversed in-order. The process goes on until all the nodes are visited. The output of inorder traversal of this tree will be &minus;</p>

<h3>Algorithm</h3>

<h2>Pre-order Traversal</h2>

<p>In this traversal method, the root node is visited first, then the left subtree and finally the right subtree.</p>

<p>We start from <b>A</b>, and following pre-order traversal, we first visit <b>A</b> itself and then move to its left subtree <b>B</b>. <b>B</b> is also traversed pre-order. The process goes on until all the nodes are visited. The output of pre-order traversal of this tree will be &minus;</p>

<h3>Algorithm</h3>

<h2>Post-order Traversal</h2>

<p>In this traversal method, the root node is visited last, hence the name. First we traverse the left subtree, then the right subtree and finally the root node.</p>

<p>We start from <b>A</b>, and following pre-order traversal, we first visit the left subtree <b>B</b>. <b>B</b> is also traversed post-order. The process goes on until all the nodes are visited. The output of post-order traversal of this tree will be &minus;</p>

<h3>Algorithm</h3>

<p>To check the C implementation of tree traversing, please <a href="/data_structures_algorithms/tree_traversal_in_c.htm">click here</a>.</p>

<h1>Data Structure - Binary Search Tree</h1>

<p>A Binary Search Tree (BST) is a tree in which all the nodes follow the below-mentioned properties &minus;</p>

<p>The left sub-tree of a node has a key less than or equal to its parent node's key.</p>

<p>The right sub-tree of a node has a key greater than to its parent node's key.</p>

<p>Thus, BST divides all its sub-trees into two segments; the left sub-tree and the right sub-tree and can be defined as &minus;</p>

<h2>Representation</h2>

<p>BST is a collection of nodes arranged in a way where they maintain BST properties. Each node has a key and an associated value. While searching, the desired key is compared to the keys in BST and if found, the associated value is retrieved.</p>

<p>Following is a pictorial representation of BST &minus;</p>

<p>We observe that the root node key (27) has all less-valued keys on the left sub-tree and the higher valued keys on the right sub-tree.</p>

<h2>Basic Operations</h2>

<p>Following are the basic operations of a tree &minus;</p>

<p><b>Search</b> &minus; Searches an element in a tree.</p>

<p><b>Insert</b> &minus; Inserts an element in a tree.</p>

<p><b>Pre-order Traversal</b> &minus; Traverses a tree in a pre-order manner.</p>

<p><b>In-order Traversal</b> &minus; Traverses a tree in an in-order manner.</p>

<p><b>Post-order Traversal</b> &minus; Traverses a tree in a post-order manner.</p>

<h2>Node</h2>

<p>Define a node having some data, references to its left and right child nodes.</p>

<h2>Search Operation</h2>

<p>Whenever an element is to be searched, start searching from the root node. Then if the data is less than the key value, search for the element in the left subtree. Otherwise, search for the element in the right subtree. Follow the same algorithm for each node.</p>

<h3>Algorithm</h3>

<h2>Insert Operation</h2>

<p>Whenever an element is to be inserted, first locate its proper location. Start searching from the root node, then if the data is less than the key value, search for the empty location in the left subtree and insert the data. Otherwise, search for the empty location in the right subtree and insert the data.</p>

<h3>Algorithm</h3>

<h1>Data Structure and Algorithms - AVL Trees</h1>

<p>What if the input to binary search tree comes in a sorted (ascending or descending) manner? It will then look like this &minus;</p>

<p>It is observed that BST's worst-case performance is closest to linear search algorithms, that is &Omicron;(n). In real-time data, we cannot predict data pattern and their frequencies. So, a need arises to balance out the existing BST.</p>

<p>Named after their inventor <b>Adelson</b>, <b>Velski</b> &amp; <b>Landis</b>, <b>AVL trees</b> are height balancing binary search tree. AVL tree checks the height of the left and the right sub-trees and assures that the difference is not more than 1. This difference is called the <b>Balance Factor</b>.</p>

<p>Here we see that the first tree is balanced and the next two trees are not balanced &minus;</p>

<p>In the second tree, the left subtree of <b>C</b> has height 2 and the right subtree has height 0, so the difference is 2. In the third tree, the right subtree of <b>A</b> has height 2 and the left is missing, so it is 0, and the difference is 2 again. AVL tree permits difference (balance factor) to be only 1.</p>

<p>If the difference in the height of left and right sub-trees is more than 1, the tree is balanced using some rotation techniques.</p>

<h2>AVL Rotations</h2>

<p>To balance itself, an AVL tree may perform the following four kinds of rotations &minus;</p>

<p>The first two rotations are single rotations and the next two rotations are double rotations. To have an unbalanced tree, we at least need a tree of height 2. With this simple tree, let's understand them one by one.</p>

<h3>Left Rotation</h3>

<p>If a tree becomes unbalanced, when a node is inserted into the right subtree of the right subtree, then we perform a single left rotation &minus;</p>

<p>In our example, node <b>A</b> has become unbalanced as a node is inserted in the right subtree of A's right subtree. We perform the left rotation by making <b>A</b> the left-subtree of B.</p>

<h2>Right Rotation</h2>

<p>AVL tree may become unbalanced, if a node is inserted in the left subtree of the left subtree. The tree then needs a right rotation.</p>

<p>As depicted, the unbalanced node becomes the right child of its left child by performing a right rotation.</p>

<h3>Left-Right Rotation</h3>

<p>Double rotations are slightly complex version of already explained versions of rotations. To understand them better, we should take note of each action performed while rotation. Let's first check how to perform Left-Right rotation. A left-right rotation is a combination of left rotation followed by right rotation.</p>

<h3>Right-Left Rotation</h3>

<p>The second type of double rotation is Right-Left Rotation. It is a combination of right rotation followed by left rotation.</p>

<h1>Data Structure &amp; Algorithms - Spanning Tree</h1>

<p>A spanning tree is a subset of Graph G, which has all the vertices covered with minimum possible number of edges. Hence, a spanning tree does not have cycles and it cannot be disconnected..</p>

<p>By this definition, we can draw a conclusion that every connected and undirected Graph G has at least one spanning tree. A disconnected graph does not have any spanning tree, as it cannot be spanned to all its vertices.</p>

<p>We found three spanning trees off one complete graph. A complete undirected graph can have maximum <b>n<sup>n-2</sup></b> number of spanning trees, where <b>n</b> is the number of nodes. In the above addressed example, <b>3<sup>3&minus;2</sup> = 3</b> spanning trees are possible.</p>

<h2>General Properties of Spanning Tree</h2>

<p>We now understand that one graph can have more than one spanning tree. Following are a few properties of the spanning tree connected to graph G &minus;</p>

<p>A connected graph G can have more than one spanning tree.</p>

<p>All possible spanning trees of graph G, have the same number of edges and vertices.</p>

<p>The spanning tree does not have any cycle (loops).</p>

<p>Removing one edge from the spanning tree will make the graph disconnected, i.e. the spanning tree is <b>minimally connected</b>.</p>

<p>Adding one edge to the spanning tree will create a circuit or loop, i.e. the spanning tree is <b>maximally acyclic</b>.</p>

<h2>Mathematical Properties of Spanning Tree</h2>

<p>Spanning tree has <b>n-1</b> edges, where <b>n</b> is the number of nodes (vertices).</p>

<p>From a complete graph, by removing maximum <b>e - n &plus; 1</b> edges, we can construct a spanning tree.</p>

<p>A complete graph can have maximum <b>n<sup>n-2</sup></b> number of spanning trees.</p>

<p>Thus, we can conclude that spanning trees are a subset of connected Graph G and disconnected graphs do not have spanning tree.</p>

<h2>Application of Spanning Tree</h2>

<p>Spanning tree is basically used to find a minimum path to connect all nodes in a graph. Common application of spanning trees are &minus;</p>

<p><b>Civil Network Planning</b></p>

<p><b>Computer Network Routing Protocol</b></p>

<p><b>Cluster Analysis</b></p>

<p>Let us understand this through a small example. Consider, city network as a huge graph and now plans to deploy telephone lines in such a way that in minimum lines we can connect to all city nodes. This is where the spanning tree comes into picture.</p>

<h2>Minimum Spanning Tree (MST)</h2>

<p>In a weighted graph, a minimum spanning tree is a spanning tree that has minimum weight than all other spanning trees of the same graph. In real-world situations, this weight can be measured as distance, congestion, traffic load or any arbitrary value denoted to the edges.</p>

<h2>Minimum Spanning-Tree Algorithm</h2>

<p>We shall learn about two most important spanning tree algorithms here &minus;</p>

<p><a href="/data_structures_algorithms/kruskals_spanning_tree_algorithm.htm">Kruskal's Algorithm</a></p>

<p><a href="/data_structures_algorithms/prims_spanning_tree_algorithm.htm">Prim's Algorithm</a></p>

<p>Both are greedy algorithms.</p>

<h1>Heap Data Structures</h1>

<p>Heap is a special case of balanced binary tree data structure where the root-node key is compared with its children and arranged accordingly. If <b>&alpha;</b> has child node <b>&beta;</b> then &minus;</p>

<p>As the value of parent is greater than that of child, this property generates <b>Max Heap</b>. Based on this criteria, a heap can be of two types &minus;</p>

<p><b>Min-Heap</b> &minus;  Where the value of the root node is less than or equal to either of its children.</p>

<p><b>Max-Heap</b> &minus; Where the value of the root node is greater than or equal to either of its children.</p>

<p>Both trees are constructed using the same input and order of arrival.</p>

<h2>Max Heap Construction Algorithm</h2>

<p>We shall use the same example to demonstrate how a Max Heap is created. The procedure to create Min Heap is similar but we go for min values instead of max values.</p>

<p>We are going to derive an algorithm for max heap by inserting one element at a time. At any point of time, heap must maintain its property. While insertion, we also assume that we are inserting a node in an already heapified tree.</p>

<p><b>Note</b> &minus; In Min Heap construction algorithm, we expect the value of the parent node to be less than that of the child node.</p>

<p>Let's understand Max Heap construction by an animated illustration. We consider the same input sample that we used earlier.</p>

<h2>Max Heap Deletion Algorithm</h2>

<p>Let us derive an algorithm to delete from max heap. Deletion in Max (or Min) Heap always happens at the root to remove the Maximum (or minimum) value.</p>

<h1>Data Structure - Recursion Basics</h1>

<p>Some computer programming languages allow a module or function to call itself. This technique is known as recursion. In recursion, a function <b>&alpha;</b> either calls itself directly or calls a function <b>&beta;</b> that in turn calls the original function <b>&alpha;</b>. The function <b>&alpha;</b> is called recursive function.</p>

<p><b>Example</b> &minus; a function calling itself.</p>

<p><b>Example</b> &minus; a function that calls another function which in turn calls it again.</p>

<h2>Properties</h2>

<p>A recursive function can go infinite like a loop. To avoid infinite running of recursive function, there are two properties that a recursive function must have &minus;</p>

<p><b>Base criteria</b> &minus; There must be at least one base criteria or condition, such that, when this condition is met the function stops calling itself recursively.</p>

<p><b>Progressive approach</b> &minus; The recursive calls should progress in such a way that each time a recursive call is made it comes closer to the base criteria.</p>

<h2>Implementation</h2>

<p>Many programming languages implement recursion by means of <b>stacks</b>. Generally, whenever a function (<b>caller</b>) calls another function (<b>callee</b>) or itself as callee, the caller function transfers execution control to the callee. This transfer process may also involve some data to be passed from the caller to the callee.</p>

<p>This implies, the caller function has to suspend its execution temporarily and resume later when the execution control returns from the callee function. Here, the caller function needs to start exactly from the point of execution where it puts itself on hold. It also needs the exact same data values it was working on. For this purpose, an activation record (or stack frame) is created for the caller function.</p>

<p>This activation record keeps the information about local variables, formal parameters, return address and all information passed to the caller function.</p>

<h2>Analysis of Recursion</h2>

<p>One may argue why to use recursion, as the same task can be done with iteration. The first reason is, recursion makes a program more readable and because of latest enhanced CPU systems, recursion is more efficient than iterations.</p>

<h2>Time Complexity</h2>

<p>In case of iterations, we take number of iterations to count the time complexity. Likewise, in case of recursion, assuming everything is constant, we try to figure out the number of times a recursive call is being made. A call made to a function is &Omicron;(1), hence the (n) number of times a recursive call is made makes the recursive function &Omicron;(n).</p>

<h2>Space Complexity</h2>

<p>Space complexity is counted as what amount of extra space is required for a module to execute. In case of iterations, the compiler hardly requires any extra space. The compiler keeps updating the values of variables used in the iterations. But in case of recursion, the system needs to store activation record each time a recursive call is made. Hence, it is considered that space complexity of recursive function may go higher than that of a function with iteration.</p>

<h1>Data Structure &amp; Algorithms - Tower of Hanoi</h1>

<p>Tower of Hanoi, is a mathematical puzzle which consists of three towers (pegs) and more than one rings is as depicted &minus;</p>

<p>These rings are of different sizes and stacked upon in an ascending order, i.e. the smaller one sits over the larger one. There are other variations of the puzzle where the number of disks increase, but the tower count remains the same.</p>

<h2>Rules</h2>

<p>The mission is to move all the disks to some another tower without violating the sequence of arrangement. A few rules to be followed for Tower of Hanoi are &minus;</p>

<p>Following is an animated representation of solving a Tower of Hanoi puzzle with three disks.</p>

<p>Tower of Hanoi puzzle with n disks can be solved in minimum <b>2<sup>n</sup>&minus;1</b> steps. This presentation shows that a puzzle with 3 disks has taken <b>2<sup>3</sup> - 1 = 7</b> steps.</p>

<h2>Algorithm</h2>

<p>To write an algorithm for Tower of Hanoi, first we need to learn how to solve this problem with lesser amount of disks, say &rarr; 1 or 2. We mark three towers with name, <b>source</b>, <b>destination</b> and <b>aux</b> (only to help moving the disks). If we have only one disk, then it can easily be moved from source to destination peg.</p>

<p>If we have 2 disks &minus;</p>

<p>So now, we are in a position to design an algorithm for Tower of Hanoi with more than two disks. We divide the stack of disks in two parts. The largest disk (n<sup>th</sup> disk) is in one part and all other (n-1) disks are in the second part.</p>

<p>Our ultimate aim is to move disk <b>n</b> from source to destination and then put all other (n1) disks onto it. We can imagine to apply the same in a recursive way for all given set of disks.</p>

<p>The steps to follow are &minus;</p>

<p>A recursive algorithm for Tower of Hanoi can be driven as follows &minus;</p>

<p>To check the implementation in C programming, <a href="/data_structures_algorithms/tower_of_hanoi_in_c.htm">click here</a>.</p>

<h1>Data Structure &amp; Algorithms Fibonacci Series</h1>

<p>Fibonacci series generates the subsequent number by adding two previous numbers. Fibonacci series starts from two numbers − <b>F<sub>0</sub> &amp; F<sub>1</sub></b>. The initial values of F<sub>0</sub> &amp; F<sub>1</sub> can be taken 0, 1 or 1, 1 respectively.</p>

<p>Fibonacci series satisfies the following conditions &minus;</p>

<p>Hence, a Fibonacci series can look like this &minus;</p>

<p>F<sub>8</sub> = 0 1 1 2 3 5 8 13</p>

<p>or, this &minus;</p>

<p>F<sub>8</sub> = 1 1 2 3 5 8 13 21</p>

<p>For illustration purpose, Fibonacci of F<sub>8</sub> is displayed as &minus;</p>

<h2>Fibonacci Iterative Algorithm</h2>

<p>First we try to draft the iterative algorithm for Fibonacci series.</p>

<p>To know about the implementation of the above algorithm in C programming language, <a href="/data_structures_algorithms/fibonacci_iterative_program_in_c.htm">click here</a>.</p>

<h2>Fibonacci Recursive Algorithm</h2>

<p>Let us learn how to create a recursive algorithm Fibonacci series. The base criteria of recursion.</p>

<p>To see the implementation of above algorithm in c programming language, <a href="/data_structures_algorithms/fibonacci_recursive_program_in_c.htm">click here</a>.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate tryit">
#include &lt;stdio.h&gt;

int main(){
   /* My first program in C */
   printf("Hello, World! \n");
   
   return 0;
}
</pre>
<p>For most of the examples given in this tutorial, you will find a Try it option in our website code sections at the top right corner that will take you to the online compiler. So just make use of it and enjoy your learning.</p>
</blockquote>
<h2>Local Environment Setup</h2>
<p>If you are still willing to set up your environment for C programming language, you need the following two tools available on your computer, (a) Text Editor and (b) The C Compiler.</p>
<h3>Text Editor</h3>
<p>This will be used to type your program. Examples of few editors include Windows Notepad, OS Edit command, Brief, Epsilon, EMACS, and vim or vi.</p>
<p>The name and the version of the text editor can vary on different operating systems. For example, Notepad will be used on Windows, and vim or vi can be used on Windows as well as Linux or UNIX.</p>
<p>The files you create with your editor are called source files and contain program source code. The source files for C programs are typically named with the extension "<b>.c</b>".</p>
<p>Before starting your programming, make sure you have one text editor in place and you have enough experience to write a computer program, save it in a file, compile it, and finally execute it.</p>
<h3>The C Compiler</h3>
<p>The source code written in the source file is the human readable source for your program. It needs to be "compiled", to turn into machine language so that your CPU can actually execute the program as per the given instructions.</p>
<p>This C programming language compiler will be used to compile your source code into a final executable program. We assume you have the basic knowledge about a programming language compiler.</p>
<p>Most frequently used and free available compiler is GNU C/C&plus;&plus; compiler. Otherwise, you can have compilers either from HP or Solaris if you have respective Operating Systems (OS).</p>
<p>The following section guides you on how to install GNU C/C&plus;&plus; compiler on various OS. We are mentioning C/C&plus;&plus; together because GNU GCC compiler works for both C and C&plus;&plus; programming languages.</p>
<h2>Installation on UNIX/Linux</h2>
<p>If you are using <b>Linux or UNIX</b>, then check whether GCC is installed on your system by entering the following command from the command line &minus;</p>
<pre class="result notranslate">
$ gcc -v
</pre>
<p>If you have GNU compiler installed on your machine, then it should print a message such as the following &minus;</p>
<pre class="result notranslate">
Using built-in specs.
Target: i386-redhat-linux
Configured with: ../configure --prefix = /usr .......
Thread model: posix
gcc version 4.1.2 20080704 (Red Hat 4.1.2-46)
</pre>
<p>If GCC is not installed, then you will have to install it yourself using the detailed instructions available at <a href="https://gcc.gnu.org/install/" rel="nofollow" target="_blank">https://gcc.gnu.org/install/</a></p>
<p>This tutorial has been written based on Linux and all the given examples have been compiled on Cent OS flavor of Linux system.</p>
<h2>Installation on Mac OS</h2>
<p>If you use Mac OS X, the easiest way to obtain GCC is to download the Xcode development environment from Apple's website and follow the simple installation instructions. Once you have Xcode setup, you will be able to use GNU compiler for C/C&plus;&plus;.</p>
<p>Xcode is currently available at <a href="https://developer.apple.com/technologies/tools/" rel="nofollow" target="_blank">developer.apple.com/technologies/tools/</a></p>
<h2>Installation on Windows</h2>
<p>To install GCC on Windows, you need to install MinGW. To install MinGW, go to the MinGW homepage, <a href="http://www.mingw.org" rel="nofollow" target="_blank"> www.mingw.org</a>, and follow the link to the MinGW download page. Download the latest version of the MinGW installation program, which should be named MinGW-&lt;version&gt;.exe.</p>
<p>While installing MinWG, at a minimum, you must install gcc-core, gcc-g&plus;&plus;, binutils, and the MinGW runtime, but you may wish to install more.</p>
<p>Add the bin subdirectory of your MinGW installation to your <b>PATH</b> environment variable, so that you can specify these tools on the command line by their simple names.</p>
<p>When the installation is complete, you will be able to run gcc, g&plus;&plus;, ar, ranlib, dlltool, and several other GNU tools from the Windows command line.</p>
<h1>Data Structures - Algorithms Basics</h1>
<p>Algorithm is a step-by-step procedure, which defines a set of instructions to be executed in a certain order to get the desired output. Algorithms are generally created independent of underlying languages, i.e. an algorithm can be implemented in more than one programming language.</p>
<p>From the data structure point of view, following are some important categories of algorithms &minus;</p>
<ul class="list">
<li><p><b>Search</b> &minus; Algorithm to search an item in a data structure.</p></li>
<li><p><b>Sort</b> &minus; Algorithm to sort items in a certain order.</p></li>
<li><p><b>Insert</b> &minus; Algorithm to insert item in a data structure.</p></li>
<li><p><b>Update</b> &minus;  Algorithm to update an existing item in a data structure.</p></li>
<li><p><b>Delete</b> &minus; Algorithm to delete an existing item from a data structure.</p></li>
</ul>
<h2>Characteristics of an Algorithm</h2>
<p>Not all procedures can be called an algorithm. An algorithm should have the following characteristics &minus;</p>
<ul class="list">
<li><p><b>Unambiguous</b> &minus; Algorithm should be clear and unambiguous. Each of its steps (or phases), and their inputs/outputs should be clear and must lead to only one meaning.</p></li>
<li><p><b>Input</b> &minus; An algorithm should have 0 or more well-defined inputs.</p></li>
<li><p><b>Output</b> &minus; An algorithm should have 1 or more well-defined outputs, and should match the desired output.</p></li>
<li><p><b>Finiteness</b> &minus; Algorithms must terminate after a finite number of steps.</p></li>
<li><p><b>Feasibility</b> &minus; Should be feasible with the available resources.</p></li>
<li><p><b>Independent</b> &minus; An algorithm should have step-by-step directions, which should be independent of any programming code.</p></li>
</ul>
<h2>How to Write an Algorithm?</h2>
<p>There are no well-defined standards for writing algorithms. Rather, it is problem and resource dependent. Algorithms are never written to support a particular programming code.</p>
<p>As we know that all programming languages share basic code constructs like loops (do, for, while), flow-control (if-else), etc. These common constructs can be used to write an algorithm.</p>
<p>We write algorithms in a step-by-step manner, but it is not always the case. Algorithm writing is a process and is executed after the problem domain is well-defined. That is, we should know the problem domain, for which we are designing a solution.</p>
<h3>Example</h3>
<p>Let's try to learn algorithm-writing by using an example.</p>
<p><b>Problem</b> &minus; Design an algorithm to add two numbers and display the result.</p>
<pre class="result notranslate">
<b>step 1</b> &minus; START
<b>step 2</b> &minus; declare three integers <b>a</b>, <b>b</b> &amp; <b>c</b>
<b>step 3</b> &minus; define values of <b>a</b> &amp; <b>b</b>
<b>step 4</b> &minus; add values of <b>a</b> &amp; <b>b</b>
<b>step 5</b> &minus; store output of <u>step 4</u> to <b>c</b>
<b>step 6</b> &minus; print <b>c</b>
<b>step 7</b> &minus; STOP
</pre>
<p>Algorithms tell the programmers how to code the program. Alternatively, the algorithm can be written as &minus;</p>
<pre class="result notranslate">
<b>step 1</b> &minus; START ADD
<b>step 2</b> &minus; get values of <b>a</b> &amp; <b>b</b>
<b>step 3</b> &minus; c &larr; a &plus; b
<b>step 4</b> &minus; display c
<b>step 5</b> &minus; STOP
</pre>
<p>In design and analysis of algorithms, usually the second method is used to describe an algorithm. It makes it easy for the analyst to analyze the algorithm ignoring all unwanted definitions. He can observe what operations are being used and how the process is flowing.</p>
<p>Writing <b>step numbers</b>, is optional.</p>
<p>We design an algorithm to get a solution of a given problem. A problem can be solved in more than one ways.</p>
<img src="/data_structures_algorithms/images/problem_solutions.jpg" alt="one problem many solutions" />
<p>Hence, many solution algorithms can be derived for a given problem. The next step is to analyze those proposed solution algorithms and implement the best suitable solution.</p>
<h2>Algorithm Analysis</h2>
<p>Efficiency of an algorithm can be analyzed at two different stages, before implementation and after implementation. They are the following &minus;</p>
<ul class="list">
<li><p><b>A Priori Analysis</b> &minus; This is a theoretical analysis of an algorithm. Efficiency of an algorithm is measured by assuming that all other factors, for example, processor speed, are constant and have no effect on the implementation.</p></li>
<li><p><b>A Posterior Analysis</b> &minus; This is an empirical analysis of an algorithm. The selected algorithm is implemented using programming language. This is then executed on target computer machine. In this analysis, actual statistics like running time and space required, are collected.</p></li>
</ul>
<p>We shall learn about a priori algorithm analysis. Algorithm analysis deals with the execution or running time of various operations involved. The running time of an operation can be defined as the number of computer instructions executed per operation.</p>
<h2>Algorithm Complexity</h2>
<p>Suppose <b>X</b> is an algorithm and <b>n</b> is the size of input data, the time and space used by the algorithm X are the two main factors, which decide the efficiency of X.</p>
<ul class="list">
<li><p><b>Time Factor</b> &minus; Time is measured by counting the number of key operations such as comparisons in the sorting algorithm.</p></li>
<li><p><b>Space Factor</b> &minus; Space is measured by counting the maximum memory space required by the algorithm.</p></li>
</ul>
<p>The complexity of an algorithm <b>f(n)</b> gives the running time and/or the storage space required by the algorithm in terms of <b>n</b> as the size of input data.</p>
<h2>Space Complexity</h2>
<p>Space complexity of an algorithm represents the amount of memory space required by the algorithm in its life cycle. The space required by an algorithm is equal to the sum of the following two components &minus;</p>
<ul class="list">
<li><p>A fixed part that is a space required to store certain data and variables, that are independent of the size of the problem. For example, simple variables and constants used, program size, etc.</p></li>
<li><p>A variable part is a space required by variables, whose size depends on the size of the problem. For example, dynamic memory allocation, recursion stack space, etc.</p></li>
</ul>
<p>Space complexity S(P) of any algorithm P is S(P) = C &plus; SP(I), where C is the fixed part and S(I) is the variable part of the algorithm, which depends on instance characteristic I. Following is a simple example that tries to explain the concept &minus;</p>
<pre class="result notranslate">
Algorithm: SUM(A, B)
Step 1 -  START
Step 2 -  C &larr; A &plus; B &plus; 10
Step 3 -  Stop
</pre>
<p>Here we have three variables A, B, and C and one constant. Hence S(P) = 1 &plus; 3. Now, space depends on data types of given variables and constant types and it will be multiplied accordingly.</p>
<h2>Time Complexity</h2>
<p>Time complexity of an algorithm represents the amount of time required by the algorithm to run to completion. Time requirements can be defined as a numerical function T(n), where T(n) can be measured as the number of steps, provided each step consumes constant time.</p>
<p>For example, addition of two n-bit integers takes <b>n</b> steps. Consequently, the total computational time is T(n) = c &lowast; n, where c is the time taken for the addition of two bits. Here, we observe that T(n) grows linearly as the input size increases.</p>
<h1>Data Structures - Asymptotic Analysis</h1>
<p>Asymptotic analysis of an algorithm refers to defining the mathematical boundation/framing of its run-time performance. Using asymptotic analysis, we can very well conclude the best case, average case, and worst case scenario of an algorithm.</p>
<p>Asymptotic analysis is input bound i.e., if there's no input to the algorithm, it is concluded to work in a constant time. Other than the "input" all other factors are considered constant.</p>
<p>Asymptotic analysis refers to computing the running time of any operation in mathematical units of computation. For example, the running time of one operation is computed as <i>f</i>(n) and may be for another operation it is computed as <i>g</i>(n<sup>2</sup>). This means the first operation running time will increase linearly with the increase in <b>n</b> and the running time of the second operation will increase exponentially when <b>n</b> increases. Similarly, the running time of both operations will be nearly the same if <b>n</b> is significantly small.</p>
<p>Usually, the time required by an algorithm falls under three types &minus;</p>
<ul class="list">
<li><p><b>Best Case</b> &minus; Minimum time required for program execution.</p></li>
<li><p><b>Average Case</b> &minus; Average time required for program execution.</p></li>
<li><p><b>Worst Case</b> &minus; Maximum time required for program execution.</p></li>
</ul>
<h2>Asymptotic Notations</h2>
<p>Following are the commonly used asymptotic notations to calculate the running time complexity of an algorithm.</p>
<ul class="list">
<li>&Omicron; Notation</li>
<li>&Omega; Notation</li>
<li>&theta; Notation</li>
</ul>
<h3>Big Oh Notation, &Omicron;</h3>
<p>The notation &Omicron;(n) is the formal way to express the upper bound of an algorithm's running time. It measures the worst case time complexity or the longest amount of time an algorithm can possibly take to complete.</p>
<img src="/data_structures_algorithms/images/big_o_notation.jpg" alt="Big O Notation" />
<p>For example, for a function <b><i>f</i>(n)</b></p>
<pre class="result notranslate">
&Omicron;(<i>f</i>(n)) = { <i>g</i>(n) : there exists c &gt; 0 and n<sub>0</sub> such that <i>f</i>(n) &le; c.<i>g</i>(n) for all n &gt; n<sub>0</sub>. }
</pre>
<h3>Omega Notation, &Omega;</h3>
<p>The notation &Omega;(n) is the formal way to express the lower bound of an algorithm's running time. It measures the best case time complexity or the best amount of time an algorithm can possibly take to complete.</p>
<img src="/data_structures_algorithms/images/omega_notation.jpg" alt="Omega Notation" />
<p>For example, for a function <b><i>f</i>(n)</b></p>
<pre class="result notranslate">
&Omega;(<i>f</i>(n)) &ge; { <i>g</i>(n) : there exists c &gt; 0 and n<sub>0</sub> such that <i>g</i>(n) &le; c.<i>f</i>(n) for all n &gt; n<sub>0</sub>. }
</pre>
<h3>Theta Notation, &theta;</h3>
<p>The notation &theta;(n) is the formal way to express both the lower bound and the upper bound of an algorithm's running time. It is represented as follows &minus;</p>
<img src="/data_structures_algorithms/images/theta_notation.jpg" alt="Theta Notation" />
<pre class="result notranslate">
&theta;(<i>f</i>(n)) = { <i>g</i>(n) if and only if <i>g</i>(n) =  &Omicron;(<i>f</i>(n)) and <i>g</i>(n) = &Omega;(<i>f</i>(n)) for all n &gt; n<sub>0</sub>. }
</pre>
<h2>Common Asymptotic Notations</h2>
<p>Following is a list of some common asymptotic notations &minus;</p>
<table style="text-align:center;" class="table table-bordered">
<tr>
<td>constant</td>
<td>&minus;</td>
<td>&Omicron;(1)</td>
</tr>
<tr>
<td>logarithmic</td>
<td>&minus;</td>
<td>&Omicron;(log n)</td>
</tr>
<tr>
<td>linear</td>
<td>&minus;</td>
<td>&Omicron;(n)</td>
</tr>
<tr>
<td>n log n</td>
<td>&minus;</td>
<td>&Omicron;(n log n)</td>
</tr>
<tr>
<td>quadratic</td>
<td>&minus;</td>
<td>&Omicron;(n<sup>2</sup>)</td>
</tr>
<tr>
<td>cubic</td>
<td>&minus;</td>
<td>&Omicron;(n<sup>3</sup>)</td>
</tr>
<tr>
<td>polynomial</td>
<td>&minus;</td>
<td>n<sup>&Omicron;(1)</sup></td>
</tr>
<tr>
<td>exponential</td>
<td>&minus;</td>
<td>2<sup>&Omicron;(n)</sup></td>
</tr>
</table>
<h1>Data Structures - Greedy Algorithms</h1>
<p>An algorithm is designed to achieve optimum solution for a given problem. In greedy algorithm approach, decisions are made from the given solution domain. As being greedy, the closest solution that seems to provide an optimum solution is chosen.</p>
<p>Greedy algorithms try to find a localized optimum solution, which may eventually lead to globally optimized solutions. However, generally greedy algorithms do not provide globally optimized solutions.</p>
<h2>Counting Coins</h2>
<p>This problem is to count to a desired value by choosing the least possible coins and the greedy approach forces the algorithm to pick the largest possible coin. If we are provided coins of &#8377; 1, 2, 5 and 10 and we are asked to count &#8377; 18 then the greedy procedure will be &minus;</p>
<ul class="list">
<li><p><b>1</b> &minus; Select one &#8377; 10 coin, the remaining count is 8</p></li>   
<li><p><b>2</b> &minus; Then select one &#8377; 5 coin, the remaining count is 3</p></li>   
<li><p><b>3</b> &minus; Then select one &#8377; 2 coin, the remaining count is 1</p></li>   
<li><p><b>4</b> &minus; And finally, the selection of one &#8377; 1 coins solves the problem</p></li>
</ul>
<p>Though, it seems to be working fine, for this count we need to pick only 4 coins. But if we slightly change the problem then the same approach may not be able to produce the same optimum result.</p>
<p>For the currency system, where we have coins of 1, 7, 10 value, counting coins for value 18 will be absolutely optimum but for count like 15, it may use more coins than necessary. For example, the greedy approach will use 10 &plus; 1 &plus; 1 &plus; 1 &plus; 1 &plus; 1, total 6 coins. Whereas the same problem could be solved by using only 3 coins (7 &plus; 7 &plus; 1)</p>
<p>Hence, we may conclude that the greedy approach picks an immediate optimized solution and may fail where global optimization is a major concern.</p>
<h3>Examples</h3>
<p>Most networking algorithms use the greedy approach. Here is a list of few of them &minus;</p>
<ul class="list">
<li>Travelling Salesman Problem</li>   
<li>Prim's Minimal Spanning Tree Algorithm</li>   
<li>Kruskal's Minimal Spanning Tree Algorithm</li>   
<li>Dijkstra's Minimal Spanning Tree Algorithm</li>   
<li>Graph - Map Coloring</li>   
<li>Graph - Vertex Cover</li>   
<li>Knapsack Problem</li>   
<li>Job Scheduling Problem</li>   
</ul>
<p>There are lots of similar problems that uses the greedy approach to find an optimum solution.</p>
<h1>Data Structures - Divide and Conquer</h1>
<p>In divide and conquer approach, the problem in hand, is divided into smaller sub-problems and then each problem is solved independently. When we keep on dividing the subproblems into even smaller sub-problems, we may eventually reach a stage where no more division is possible. Those "atomic" smallest possible sub-problem (fractions) are solved. The solution of all sub-problems is finally merged in order to obtain the solution of an original problem.</p>
<img src="/data_structures_algorithms/images/divide_and_conquer.jpg" alt="Divide and Conquer" />
<p>Broadly, we can understand <b>divide-and-conquer</b> approach in a three-step process.</p>
<h2>Divide/Break</h2>
<p>This step involves breaking the problem into smaller sub-problems. Sub-problems should represent a part of the original problem. This step generally takes a recursive approach to divide the problem until no sub-problem is further divisible. At this stage, sub-problems become atomic in nature but still represent some part of the actual problem.</p>
<h2>Conquer/Solve</h2>
<p>This step receives a lot of smaller sub-problems to be solved. Generally, at this level, the problems are considered 'solved' on their own.</p>
<h2>Merge/Combine</h2>
<p>When the smaller sub-problems are solved, this stage recursively combines them until they formulate a solution of the original problem. This algorithmic approach works recursively and conquer & merge steps works so close that they appear as one.</p>
<h3>Examples</h3>   
<p>The following computer algorithms are based on <b>divide-and-conquer</b> programming approach &minus;</p>   
<ul class="list">
<li>Merge Sort</li>
<li>Quick Sort</li>
<li>Binary Search</li>
<li>Strassen's Matrix Multiplication</li>
<li>Closest pair (points)</li>
</ul>
<p>There are various ways available to solve any computer problem, but the mentioned are a good example of divide and conquer approach.</p>
<h1>Data Structures - Dynamic Programming</h1>
<p>Dynamic programming approach is similar to divide and conquer in breaking down the problem into smaller and yet smaller possible sub-problems. But unlike, divide and conquer, these sub-problems are not solved independently. Rather, results of these smaller sub-problems are remembered and used for similar or overlapping sub-problems.</p>
<p>Dynamic programming is used where we have problems, which can be divided into similar sub-problems, so that their results can be re-used. Mostly, these algorithms are used for optimization. Before solving the in-hand sub-problem, dynamic algorithm will try to examine the results of the previously solved sub-problems. The solutions of sub-problems are combined in order to achieve the best solution.</p>
<p>So we can say that &minus;</p>
<ul class="list">
<li><p>The problem should be able to be divided into smaller overlapping sub-problem.</p></li>
<li><p>An optimum solution can be achieved by using an optimum solution of smaller sub-problems.</p></li>
<li><p>Dynamic algorithms use memorization.</p></li>
</ul>
<h2>Comparison</h2>
<p>In contrast to greedy algorithms, where local optimization is addressed, dynamic algorithms are motivated for an overall optimization of the problem.</p>
<p>In contrast to divide and conquer algorithms, where solutions are combined to achieve an overall solution, dynamic algorithms use the output of a smaller sub-problem and then try to optimize a bigger sub-problem. Dynamic algorithms use memorization to remember the output of already solved sub-problems.</p>
<h3>Example</h3>
<p>The following computer problems can be solved using dynamic programming approach &minus;</p>
<ul class="list">
<li>Fibonacci number series</li>
<li>Knapsack problem</li>
<li>Tower of Hanoi</li>
<li>All pair shortest path by Floyd-Warshall</li>
<li>Shortest path by Dijkstra</li>
<li>Project scheduling</li>
</ul>
<p>Dynamic programming can be used in both top-down and bottom-up manner. And of course, most of the times, referring to the previous solution output is cheaper than recomputing in terms of CPU cycles.</p>
<h1>Data Structures &amp; Algorithm Basic Concepts</h1>
<p>This chapter explains the basic terms related to data structure.</p>
<h2>Data Definition</h2>
<p>Data Definition defines a particular data with the following characteristics.</p>
<ul class="list">
<li><p><b>Atomic</b> &minus; Definition should define a single concept.</p></li>
<li><p><b>Traceable</b> &minus; Definition should be able to be mapped to some data element.</p></li>
<li><p><b>Accurate</b> &minus; Definition should be unambiguous.</p></li>
<li><p><b>Clear and Concise</b> &minus; Definition should be understandable.</p></li>
</ul>
<h2>Data Object</h2>
<p>Data Object represents an object having a data.</p>
<h2>Data Type</h2>
<p>Data type is a way to classify various types of data such as integer, string, etc. which determines the values that can be used with the corresponding type of data, the type of operations that can be performed on the corresponding type of data. There are two data types &minus;</p>
<ul class="list">
<li>Built-in Data Type</li>
<li>Derived Data Type</li>
</ul>
<h3>Built-in Data Type</h3>
<p>Those data types for which a language has built-in support are known as Built-in Data types. For example, most of the languages provide the following built-in data types.</p>
<ul class="list">
<li>Integers</li>
<li>Boolean (true, false)</li>
<li>Floating (Decimal numbers)</li>
<li>Character and Strings</li>
</ul>
<h3>Derived Data Type</h3>
<p>Those data types which are implementation independent as they can be implemented in one or the other way are known as derived data types. These data types are normally built by the combination of primary or built-in data types and associated operations on them. For example &minus;</p>
<ul class="list">
<li>List</li>
<li>Array</li>
<li>Stack</li>
<li>Queue</li>
</ul>
<h2>Basic Operations</h2>
<p>The data in the data structures are processed by certain operations. The particular data structure chosen largely depends on the frequency of the operation that needs to be performed on the data structure.</p>
<ul class="list">
<li>Traversing</li>
<li>Searching</li>
<li>Insertion</li>
<li>Deletion</li>
<li>Sorting</li>
<li>Merging</li>
</ul>
<h1>Data Structures and Algorithms - Arrays</h1>
<p>Array is a container which can hold a fix number of items and these items should be of the same type. Most of the data structures make use of arrays to implement their algorithms. Following are the important terms to understand the concept of Array.</p>
<ul class="list">
<li><p><b>Element</b> &minus; Each item stored in an array is called an element.</p></li>
<li><p><b>Index</b> &minus; Each location of an element in an array has a numerical index, which is used to identify the element.</p></li>
</ul>
<h2>Array Representation</h2>
<p>Arrays can be declared in various ways in different languages. For illustration, let's take C array declaration.</p>
<img src="/data_structures_algorithms/images/array_declaration.jpg" alt="Array Declaration" /> 
<img src="/data_structures_algorithms/images/array_representation.jpg" alt="Array Representation" /> 
<p>As per the above illustration, following are the important points to be considered.</p>
<ul class="list">
<li><p>Index starts with 0.</p></li>
<li><p>Array length is 10 which means it can store 10 elements.</p></li>
<li><p>Each element can be accessed via its index. For example, we can fetch an element at index 6 as 9.</p></li>
</ul>
<h2>Basic Operations</h2>
<p>Following are the basic operations supported by an array.</p>
<ul class="list">
<li><p><b>Traverse</b> &minus; print all the array elements one by one.</p></li>
<li><p><b>Insertion</b> &minus; Adds an element at the given index.</p></li>
<li><p><b>Deletion</b> &minus; Deletes an element at the given index.</p></li>
<li><p><b>Search</b> &minus; Searches an element using the given index or by the value.</p></li>
<li><p><b>Update</b> &minus; Updates an element at the given index.</p></li>
</ul>
<p>In C, when an array is initialized with size, then it assigns defaults values to its elements in following order.</p>
<table style="text-align:center;" class="table table-bordered">
<tr>
<th style="text-align:center;">Data Type</th>
<th style="text-align:center;">Default Value</th>
</tr>
<tr>
<td>bool</td>
<td>false</td>
</tr>
<tr>
<td>char</td>
<td>0</td>
</tr>
<tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>float</td>
<td>0.0</td>
</tr>
<tr>
<td>double</td>
<td>0.0f</td>
</tr>
<tr>
<td>void</td>
<td></td>
</tr>
<tr>
<td>wchar_t</td>
<td>0</td>
</tr>
</table>
<h2>Insertion Operation</h2>
<p>Insert operation is to insert one or more data elements into an array. Based on the requirement, a new element can be added at the beginning, end, or any given index of array.</p>
<p>Here, we see a practical implementation of insertion operation, where we add data at the end of the array &minus;</p>
<h3>Algorithm</h3>
<p>Let <b>Array</b> be a linear unordered array of <b>MAX</b> elements.</p>      
<h3>Example</h3>     
<p><b>Result</b></p>     
<p>Let <b>LA</b> be a Linear Array (unordered) with <b>N</b> elements and <b>K</b> is a positive integer such that <b>K&lt;=N</b>. Following is the algorithm where ITEM is inserted into the K<sup>th</sup> position of LA &minus;</p>
<pre class="result notranslate">
1. Start
2. Set J = N
3. Set N = N&plus;1
4. Repeat steps 5 and 6 while J &gt;= K
5. Set LA[J+1] = LA[J]
6. Set J = J-1
7. Set LA[K] = ITEM
8. Stop
</pre>
<h3>Example</h3>
<p>Following is the implementation of the above algorithm &minus;</p>
<pre class="prettyprint notranslate tryit">
#include &lt;stdio.h&gt;

main() {
   int LA[] = {1,3,5,7,8};
   int item = 10, k = 3, n = 5;
   int i = 0, j = n;
   
   printf("The original array elements are :\n");
	
   for(i = 0; i&lt;n; i++) {
      printf("LA[%d] = %d \n", i, LA[i]);
   }
    
   n = n &plus; 1;
	
   while( j &gt;= k) {
      LA[j&plus;1] = LA[j];
      j = j - 1;
   }
	
   LA[k] = item;
   
	printf("The array elements after insertion :\n");
	
   for(i = 0; i&lt;n; i++) {
      printf("LA[%d] = %d \n", i, LA[i]);
   }
}
</pre>
<p>When we compile and execute the above program, it produces the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
The original array elements are :
LA[0] = 1 
LA[1] = 3 
LA[2] = 5 
LA[3] = 7 
LA[4] = 8 
The array elements after insertion :
LA[0] = 1 
LA[1] = 3 
LA[2] = 5 
LA[3] = 10 
LA[4] = 7 
LA[5] = 8 
</pre>
<p>For other variations of array insertion operation <a target="_blank" href="/data_structures_algorithms/array_insertion_algorithm.htm">click here</a></p>
<h2>Deletion Operation</h2>
<p>Deletion refers to removing an existing element from the array and re-organizing all elements of an array.</p>
<h3>Algorithm</h3>
<p>Consider <b>LA</b> is a linear array with <b>N</b> elements and <b>K</b> is a positive integer such that <b>K&lt;=N</b>. Following is the algorithm to delete an element available at the K<sup>th</sup> position of LA.</p>
<pre class="result notranslate">
1. Start
2. Set J = K
3. Repeat steps 4 and 5 while J &lt; N
4. Set LA[J-1] = LA[J]
5. Set J = J&plus;1
6. Set N = N-1
7. Stop
</pre>
<h3>Example</h3>
<p>Following is the implementation of the above algorithm &minus;</p>
<pre class="prettyprint notranslate tryit">
#include &lt;stdio.h&gt;
main() {
   int LA[] = {1,3,5,7,8};
   int k = 3, n = 5;
   int i, j;
   
   printf("The original array elements are :\n");
	
   for(i = 0; i&lt;n; i++) {
      printf("LA[%d] = %d \n", i, LA[i]);
   }
    
   j = k;
	
   while( j &lt; n) {
      LA[j-1] = LA[j];
      j = j &plus; 1;
   }
	
   n = n -1;
   
   printf("The array elements after deletion :\n");
	
   for(i = 0; i&lt;n; i&plus;&plus;) {
      printf("LA[%d] = %d \n", i, LA[i]);
   }
}
</pre>
<p>When we compile and execute the above program, it produces the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
The original array elements are :
LA[0] = 1 
LA[1] = 3 
LA[2] = 5 
LA[3] = 7 
LA[4] = 8 
The array elements after deletion :
LA[0] = 1 
LA[1] = 3 
LA[2] = 7 
LA[3] = 8 
</pre>
<h2>Search Operation</h2>
<p>You can perform a search for an array element based on its value or its index.</p>
<h3>Algorithm</h3>
<p>Consider <b>LA</b> is a linear array with <b>N</b> elements and <b>K</b> is a positive integer such that <b>K&lt;=N</b>. Following is the algorithm to find an element with a value of ITEM using sequential search.</p>
<pre class="result notranslate">
1. Start
2. Set J = 0
3. Repeat steps 4 and 5 while J &lt; N
4. IF LA[J] is equal ITEM THEN GOTO STEP 6
5. Set J = J +1
6. PRINT J, ITEM
7. Stop
</pre>
<h3>Example</h3>
<p>Following is the implementation of the above algorithm &minus;</p>
<pre class="prettyprint notranslate tryit">
#include &lt;stdio.h&gt;
main() {
   int LA[] = {1,3,5,7,8};
   int item = 5, n = 5;
   int i = 0, j = 0;
   
   printf("The original array elements are :\n");
	
   for(i = 0; i&lt;n; i++) {
      printf("LA[%d] = %d \n", i, LA[i]);
   }
    
   while( j &lt; n){
	   if( LA[j] == item ) {
         break;
      }
		
      j = j + 1;
   }
	
   printf("Found element %d at position %d\n", item, j+1);
}
</pre>
<p>When we compile and execute the above program, it produces the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
The original array elements are :
LA[0] = 1 
LA[1] = 3 
LA[2] = 5 
LA[3] = 7 
LA[4] = 8 
Found element 5 at position 3
</pre>
<h2>Update Operation</h2>
<p>Update operation refers to updating an existing element from the array at a given index.</p>
<h3>Algorithm</h3>
<p>Consider <b>LA</b> is a linear array with <b>N</b> elements and <b>K</b> is a positive integer such that <b>K&lt;=N</b>. Following is the algorithm to update an element available at the K<sup>th</sup> position of LA.</p>
<pre class="result notranslate">
1. Start
2. Set LA[K-1] = ITEM
3. Stop
</pre>
<h3>Example</h3>
<p>Following is the implementation of the above algorithm &minus;</p>
<pre class="prettyprint notranslate tryit">
#include &lt;stdio.h&gt;
main() {
   int LA[] = {1,3,5,7,8};
   int k = 3, n = 5, item = 10;
   int i, j;
   
   printf("The original array elements are :\n");
	
   for(i = 0; i&lt;n; i++) {
      printf("LA[%d] = %d \n", i, LA[i]);
   }
    
   LA[k-1] = item;

   printf("The array elements after updation :\n");
	
   for(i = 0; i&lt;n; i++) {
      printf("LA[%d] = %d \n", i, LA[i]);
   }
}
</pre>
<p>When we compile and execute the above program, it produces the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
The original array elements are :
LA[0] = 1 
LA[1] = 3 
LA[2] = 5 
LA[3] = 7 
LA[4] = 8 
The array elements after updation :
LA[0] = 1 
LA[1] = 3 
LA[2] = 10 
LA[3] = 7 
LA[4] = 8 
</pre>
<h1>Data Structure and Algorithms - Linked List</h1>
<p>A linked list is a sequence of data structures, which are connected together via links.</p>
<p>Linked List is a sequence of links which contains items. Each link contains a connection to another link. Linked list is the second most-used data structure after array. Following are the important terms to understand the concept of Linked List.</p>
<ul class="list">
<li><p><b>Link</b> &minus; Each link of a linked list can store a data called an element.</p></li>
<li><p><b>Next</b> &minus; Each link of a linked list contains a link to the next link called Next.</p></li>
<li><p><b>LinkedList</b> &minus; A Linked List contains the connection link to the first link called First.</p></li>
</ul>
<h2>Linked List Representation</h2>
<p>Linked list can be visualized as a chain of nodes, where every node points to the next node.</p>
<img src="/data_structures_algorithms/images/linked_list.jpg" alt="Linked List" /> 
<p>As per the above illustration, following are the important points to be considered.</p>
<ul class="list">
<li><p>Linked List contains a link element called first.</p></li>
<li><p>Each link carries a data field(s) and two link fields called next and prev.</p></li>
<li><p>Each link is linked with its next link using its next link.</p></li>
<li><p>Last link carries a link as null to mark the end of the list.</p></li>
</ul>
<h2>Types of Linked List</h2>
<p>Following are the various types of linked list.</p>
<ul class="list">
<li><p><b>Simple Linked List</b> &minus; Item navigation is forward only.</p></li>
<li><p><b>Doubly Linked List</b> &minus; Items can be navigated forward and backward.</p></li>
<li><p><b>Circular Linked List</b> &minus; Last item contains link of the first element as next and the first element has a link to the last element as previous.</p></li>
</ul>
<h2>Basic Operations</h2>
<p>Following are the basic operations supported by a list.</p>
<ul class="list">
<li><p><b>Insertion</b> &minus; Adds an element at the beginning of the list.</p></li>
<li><p><b>Deletion</b> &minus; Deletes an element at the beginning of the list.</p></li>
<li><p><b>Display</b> &minus; Displays the complete list.</p></li>
<li><p><b>Search</b> &minus; Searches an element using the given key.</p></li>
<li><p><b>Delete</b> &minus; Deletes an element using the given key.</p></li>
</ul>
<h2>Insertion Operation</h2>
<p>Adding a new node in linked list is a more than one step activity. We shall learn this with diagrams here. First, create a node using the same structure and find the location where it has to be inserted.</p>
<img src="/data_structures_algorithms/images/linked_list_insertion_0.jpg" alt="Linked List Insertion" /> 
<p>Imagine that we are inserting a node <b>B</b> (NewNode), between <b>A</b> (LeftNode) and <b>C</b> (RightNode). Then point B.next to C &minus;</p>
<pre class="result notranslate">
NewNode.next −&gt; RightNode;
</pre>
<p>It should look like this &minus;</p>
<img src="/data_structures_algorithms/images/linked_list_insertion_1.jpg" alt="Linked List Insertion" /> 
<p>Now, the next node at the left should point to the new node.</p>
<pre class="result notranslate">
LeftNode.next −&gt; NewNode;
</pre>
<img src="/data_structures_algorithms/images/linked_list_insertion_2.jpg" alt="Linked List Insertion" /> 
<p>This will put the new node in the middle of the two. The new list should look like this &minus;</p>
<img src="/data_structures_algorithms/images/linked_list_insertion_3.jpg" alt="Linked List Insertion" /> 
<p>Similar steps should be taken if the node is being inserted at the beginning of the list. While inserting it at the end, the second last node of the list should point to the new node and the new node will point to NULL.</p>
<h2>Deletion Operation</h2>
<p>Deletion is also a more than one step process. We shall learn with pictorial representation. First, locate the target node to be removed, by using searching algorithms.</p>
<img src="/data_structures_algorithms/images/linked_list_deletion_0.jpg" alt="Linked List Deletion" /> 
<p>The left (previous) node of the target node now should point to the next node of the target node &minus;</p>
<pre class="result notranslate">
LeftNode.next −&gt; TargetNode.next;
</pre>
<img src="/data_structures_algorithms/images/linked_list_deletion_1.jpg" alt="Linked List Deletion" /> 
<p>This will remove the link that was pointing to the target node. Now, using the following code, we will remove what the target node is pointing at.</p>
<pre class="result notranslate">
TargetNode.next −&gt; NULL;
</pre>
<img src="/data_structures_algorithms/images/linked_list_deletion_2.jpg" alt="Linked List Deletion" /> 
<p>We need to use the deleted node. We can keep that in memory otherwise we can simply deallocate memory and wipe off the target node completely.</p>
<img src="/data_structures_algorithms/images/linked_list_deletion_3.jpg" alt="Linked List Deletion" /> 
<h2>Reverse Operation</h2>
<p>This operation is a thorough one. We need to make the last node to be pointed by the head node and reverse the whole linked list.</p>
<img src="/data_structures_algorithms/images/linked_list_reverse_0.jpg" alt="Linked List Reverse Operation" /> 
<p>First, we traverse to the end of the list. It should be pointing to NULL. Now, we shall make it point to its previous node &minus;</p>
<img src="/data_structures_algorithms/images/linked_list_reverse_1.jpg" alt="Linked List Reverse Operation" />
<p>We have to make sure that the last node is not the lost node. So we'll have some temp node, which looks like the head node pointing to the last node. Now, we shall make all left side nodes point to their previous nodes one by one.</p>
<img src="/data_structures_algorithms/images/linked_list_reverse_2.jpg" alt="Linked List Reverse Operation" /> 
<p>Except the node (first node) pointed by the head node, all nodes should point to their predecessor, making them their new successor. The first node will point to NULL.</p>
<img src="/data_structures_algorithms/images/linked_list_reverse_3.jpg" alt="Linked List Reverse Operation" /> 
<p>We'll make the head node point to the new first node by using the temp node.</p>
<img src="/data_structures_algorithms/images/linked_list_reverse_4.jpg" alt="Linked List Reverse Operation" /> 
<p>The linked list is now reversed. To see linked list implementation in C programming language, please <a href="/data_structures_algorithms/linked_list_program_in_c.htm">click here</a>.</p>
<h1>Data Structure - Doubly Linked List</h1>
<p>Doubly Linked List is a variation of Linked list in which navigation is possible in both ways, either forward and backward easily as compared to Single Linked List. Following are the important terms to understand the concept of doubly linked list.</p>
<ul class="list">
<li><p><b>Link</b> &minus; Each link of a linked list can store a data called an element.</p></li>
<li><p><b>Next</b> &minus; Each link of a linked list contains a link to the next link called Next.</p></li>
<li><p><b>Prev</b> &minus; Each link of a linked list contains a link to the previous link called Prev.</p></li>
<li><p><b>LinkedList</b> &minus; A Linked List contains the connection link to the first link called First and to the last link called Last.</p></li>
</ul>
<h2>Doubly Linked List Representation</h2>
<img src="/data_structures_algorithms/images/doubly_linked_list.jpg" alt="Doubly Linked List" /> 
<p>As per the above illustration, following are the important points to be considered.</p>
<ul class="list">
<li><p>Doubly Linked List contains a link element called first and last.</p></li>
<li><p>Each link carries a data field(s) and two link fields called next and prev.</p></li>
<li><p>Each link is linked with its next link using its next link.</p></li>
<li><p>Each link is linked with its previous link using its previous link.</p></li>
<li><p>The last link carries a link as null to mark the end of the list.</p></li>
</ul>
<h2>Basic Operations</h2>
<p>Following are the basic operations supported by a list.</p>
<ul class="list">
<li><p><b>Insertion</b> &minus; Adds an element at the beginning of the list.</p></li>
<li><p><b>Deletion</b> &minus; Deletes an element at the beginning of the list.</p></li>
<li><p><b>Insert Last</b> &minus; Adds an element at the end of the list.</p></li>
<li><p><b>Delete Last</b> &minus; Deletes an element from the end of the list.</p></li>
<li><p><b>Insert After</b> &minus; Adds an element after an item of the list.</p></li>
<li><p><b>Delete</b> &minus; Deletes an element from the list using the key.</p></li>
<li><p><b>Display forward</b> &minus; Displays the complete list in a forward manner.</p></li>
<li><p><b>Display backward</b> &minus; Displays the complete list in a backward manner.</p></li>
</ul>
<h2>Insertion Operation</h2>   
<p>Following code demonstrates the insertion operation at the beginning of a doubly linked list.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
//insert link at the first location
void insertFirst(int key, int data) {

   //create a link
   struct node *link = (struct node*) malloc(sizeof(struct node));
   link-&gt;key = key;
   link-&gt;data = data;
	
   if(isEmpty()) {
      //make it the last link
      last = link;
   } else {
      //update first prev link
      head-&gt;prev = link;
   }

   //point it to old first link
   link-&gt;next = head;
	
   //point first to new first link
   head = link;
}
</pre>
<h2>Deletion Operation</h2>
<p>Following code demonstrates the deletion operation at the beginning of a doubly linked list.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
//delete first item
struct node* deleteFirst() {

   //save reference to first link
   struct node *tempLink = head;
	
   //if only one link
   if(head-&gt;next == NULL) {
      last = NULL;
   } else {
      head-&gt;next-&gt;prev = NULL;
   }
	
   head = head-&gt;next;
	
   //return the deleted link
   return tempLink;
}
</pre>
<h2>Insertion at the End of an Operation</h2>
<p>Following code demonstrates the insertion operation at the last position of a doubly linked list.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
//insert link at the last location
void insertLast(int key, int data) {

   //create a link
   struct node *link = (struct node*) malloc(sizeof(struct node));
   link-&gt;key = key;
   link-&gt;data = data;
	
   if(isEmpty()) {
      //make it the last link
      last = link;
   } else {
      //make link a new last link
      last-&gt;next = link;     
      
      //mark old last node as prev of new link
      link-&gt;prev = last;
   }

   //point last to new last node
   last = link;
}
</pre>
<p>To see the implementation in C programming language, please <a href="/data_structures_algorithms/doubly_linked_list_program_in_c.htm">click here</a>.</p>
<h1>Data Structure - Circular Linked List</h1>
<p>Circular Linked List is a variation of Linked list in which the first element points to the last element and the last element points to the first element. Both Singly Linked List and Doubly Linked List can be made into a circular linked list.</p>
<h2>Singly Linked List as Circular</h2>
<p>In singly linked list, the next pointer of the last node points to the first node.</p>
<img src="/data_structures_algorithms/images/singly_circular_linked_list.jpg" alt="Singly Linked List as Circular Linked List" /> 
<h2>Doubly Linked List as Circular</h2>
<p>In doubly linked list, the next pointer of the last node points to the first node and the previous pointer of the first node points to the last node making the circular in both directions.</p>
<img src="/data_structures_algorithms/images/doubly_circular_linked_list.jpg" alt="Doubly Linked List as Circular Linked List" /> 
<p>As per the above illustration, following are the important points to be considered.</p>
<ul class="list">
<li><p>The last link's next points to the first link of the list in both cases of singly as well as doubly linked list.</p></li>
<li><p>The first link's previous points to the last of the list in case of doubly linked list.</p></li>
</ul>
<h2>Basic Operations</h2>
<p>Following are the important operations supported by a circular list.</p>
<ul class="list">
<li><p><b>insert</b> &minus; Inserts an element at the start of the list.</p></li>
<li><p><b>delete</b> &minus; Deletes an element from the start of the list.</p></li>
<li><p><b>display</b> &minus; Displays the list.</p></li>
</ul>
<h2>Insertion Operation</h2>
<p>Following code demonstrates the insertion operation in a circular linked list based on single linked list.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
//insert link at the first location
void insertFirst(int key, int data) {
   //create a link
   struct node *link = (struct node*) malloc(sizeof(struct node));
   link-&gt;key = key;
   link-&gt;data= data;
	
   if (isEmpty()) {
      head = link;
      head-&gt;next = head;
   } else {
      //point it to old first node
      link-&gt;next = head;
		
      //point first to new first node
      head = link;
   }   
}
</pre>
<h2>Deletion Operation</h2>
<p>Following code demonstrates the deletion operation in a circular linked list based on single linked list.</p>
<pre class="prettyprint notranslate">
//delete first item
struct node * deleteFirst() {
   //save reference to first link
   struct node *tempLink = head;
	
   if(head-&gt;next == head) {  
      head = NULL;
      return tempLink;
   }     

   //mark next to first link as first 
   head = head-&gt;next;
	
   //return the deleted link
   return tempLink;
}
</pre>
<h2>Display List Operation</h2>
<p>Following code demonstrates the display list operation in a circular linked list.</p>
<pre class="prettyprint notranslate">
//display the list
void printList() {
   struct node *ptr = head;
   printf("\n[ ");
	
   //start from the beginning
   if(head != NULL) {
      while(ptr-&gt;next != ptr) {     
         printf("(%d,%d) ",ptr-&gt;key,ptr-&gt;data);
         ptr = ptr-&gt;next;
      }
   }
	
   printf(" ]");
}
</pre>
<p>To know about its implementation in C programming language, please <a href="/data_structures_algorithms/circular_linked_list_program_in_c.htm">click here</a>.</p>
<h1>Data Structure and Algorithms - Stack</h1>
<p>A stack is an Abstract Data Type (ADT), commonly used in most programming languages. It is named stack as it behaves like a real-world stack, for example – a deck of cards or a pile of plates, etc.</p>
<img src="/data_structures_algorithms/images/stack_example.jpg" alt="Stack Example" />
<p>A real-world stack allows operations at one end only. For example, we can place or remove a card or plate from the top of the stack only. Likewise, Stack ADT allows all data operations at one end only. At any given time, we can only access the top element of a stack.</p>
<p>This feature makes it LIFO data structure. LIFO stands for Last-in-first-out. Here, the element which is placed (inserted or added) last, is accessed first. In stack terminology, insertion operation is called <b>PUSH</b> operation and removal operation is called <b>POP</b> operation.</p>
<h2>Stack Representation</h2>
<p>The following diagram depicts a stack and its operations &minus;</p>
<img src="/data_structures_algorithms/images/stack_representation.jpg" alt="Stack Representation" />
<p>A stack can be implemented by means of Array, Structure, Pointer, and Linked List. Stack can either be a fixed size one or it may have a sense of dynamic resizing. Here, we are going to implement stack using arrays, which makes it a fixed size stack implementation.</p>
<h2>Basic Operations</h2>
<p>Stack operations may involve initializing the stack, using it and then de-initializing it. Apart from these basic stuffs, a stack is used for the following two primary operations &minus;</p>
<ul class="list">
<li><p><b>push()</b> &minus; Pushing (storing) an element on the stack.</p></li>
<li><p><b>pop()</b> &minus; Removing (accessing) an element from the stack.</p></li>
</ul>
<p>When data is PUSHed onto stack.</p>
<p>To use a stack efficiently, we need to check the status of stack as well. For the same purpose, the following functionality is added to stacks &minus;</p>
<ul class="list">
<li><p><b>peek()</b> &minus; get the top data element of the stack, without removing it.</p></li>
<li><p><b>isFull()</b> &minus; check if stack is full.</p></li>
<li><p><b>isEmpty()</b> &minus; check if stack is empty.</p></li>
</ul>
<p>At all times, we maintain a pointer to the last PUSHed data on the stack. As this pointer always represents the top of the stack, hence named <b>top</b>. The <b>top</b> pointer provides top value of the stack without actually removing it.</p>
<p>First we should learn about procedures to support stack functions &minus;</p>
<h3>peek()</h3>
<p>Algorithm of peek() function &minus;</p>
<pre class="result notranslate">
begin procedure peek

   return stack[top]
   
end procedure
</pre>
<p>Implementation of peek() function in C programming language &minus;</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate" id="peek">
int peek() {
   return stack[top];
}
</pre>
<h3>isfull()</h3>
<p>Algorithm of isfull() function &minus;</p>
<pre class="prettyprint notranslate">
begin procedure isfull

   if top equals to MAXSIZE
      return true
   else
      return false
   endif
   
end procedure
</pre>
<p>Implementation of isfull() function in C programming language &minus;</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate" id="isfull">
bool isfull() {
   if(top == MAXSIZE)
      return true;
   else
      return false;
}
</pre>
<h3>isempty()</h3>
<p>Algorithm of isempty() function &minus;</p>
<pre class="prettyprint notranslate">
begin procedure isempty

   if top less than 1
      return true
   else
      return false
   endif
   
end procedure
</pre>
<p>Implementation of isempty() function in C programming language is slightly different. We initialize top at -1, as the index in array starts from 0. So we check if the top is below zero or -1 to determine if the stack is empty. Here's the code &minus;</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate" id="isempty">
bool isempty() {
   if(top == -1)
      return true;
   else
      return false;
}
</pre>
<h2>Push Operation</h2>
<p>The process of putting a new data element onto stack is known as a Push Operation. Push operation involves a series of steps &minus;</p>
<ul class="list">
<li><p><b>Step 1</b> &minus; Checks if the stack is full.</p></li>
<li><p><b>Step 2</b> &minus; If the stack is full, produces an error and exit.</p></li>
<li><p><b>Step 3</b> &minus; If the stack is not full, increments <b>top</b> to point next empty space.</p></li>
<li><p><b>Step 4</b> &minus; Adds data element to the stack location, where top is pointing.</p></li>
<li><p><b>Step 5</b> &minus; Returns success.</p></li>
</ul>
<img src="/data_structures_algorithms/images/stack_push_operation.jpg" alt="Stack Push Operation" />
<p>If the linked list is used to implement the stack, then in step 3, we need to allocate space dynamically.</p>
<h3>Algorithm for PUSH Operation</h3>
<p>A simple algorithm for Push operation can be derived as follows &minus;</p>
<pre class="prettyprint notranslate">
begin procedure push: stack, data

   if stack is full
      return null
   endif
   
   top &larr; top + 1
   
   stack[top] &larr; data

end procedure
</pre>
<p>Implementation of this algorithm in C, is very easy. See the following code &minus;</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate" id="push">
void push(int data) {
   if(!isFull()) {
      top = top &plus; 1;   
      stack[top] = data;
   } else {
      printf("Could not insert data, Stack is full.\n");
   }
}
</pre>
<h2>Pop Operation</h2>
<p>Accessing the content while removing it from the stack, is known as a Pop Operation. In an array implementation of pop() operation, the data element is not actually removed, instead <b>top</b> is decremented to a lower position in the stack to point to the next value. But in linked-list implementation, pop() actually removes data element and deallocates memory space.</p>
<p>A Pop operation may involve the following steps &minus;</p>
<ul class="list">
<li><p><b>Step 1</b> &minus; Checks if the stack is empty.</p></li>
<li><p><b>Step 2</b> &minus; If the stack is empty, produces an error and exit.</p></li>
<li><p><b>Step 3</b> &minus; If the stack is not empty, accesses the data element at which <b>top</b> is pointing.</p></li>
<li><p><b>Step 4</b> &minus; Decreases the value of top by 1.</p></li>
<li><p><b>Step 5</b> &minus; Returns success.</p></li>
</ul>
<img src="/data_structures_algorithms/images/stack_pop_operation.jpg" alt="Stack Pop Operation" />
<h3>Algorithm for Pop Operation</h3>
<p>A simple algorithm for Pop operation can be derived as follows &minus;</p>
<pre class="prettyprint notranslate">
begin procedure pop: stack

   if stack is empty
      return null
   endif
   
   data &larr; stack[top]
   
   top &larr; top - 1
   
   return data

end procedure
</pre>
<p>Implementation of this algorithm in C, is as follows &minus;</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate" id="pop">
int pop(int data) {

   if(!isempty()) {
      data = stack[top];
      top = top - 1;   
      return data;
   } else {
      printf("Could not retrieve data, Stack is empty.\n");
   }
}
</pre>
<p>For a complete stack program in C programming language, please <a href="/data_structures_algorithms/stack_program_in_c.htm" alt="Stack Program in C">click here</a>.</p>
<h1>Data Structure - Expression Parsing</h1>
<p>The way to write arithmetic expression is known as a <b>notation</b>. An arithmetic expression can be written in three different but equivalent notations, i.e., without changing the essence or output of an expression. These notations are &minus;</p>
<ul class="list">
<li>Infix Notation</li>
<li>Prefix (Polish) Notation</li>
<li>Postfix (Reverse-Polish) Notation</li>
</ul>
<p>These notations are named as how they use operator in expression. We shall learn the same here in this chapter.</p>  
<h2>Infix Notation</h2>   
<p>We write expression in <b>infix</b> notation, e.g. a - b &plus; c, where operators are used <b>in</b>-between operands. It is easy for us humans to read, write, and speak in infix notation but the same does not go well with computing devices. An algorithm to process infix notation could be difficult and costly in terms of time and space consumption.</p>
<h2>Prefix Notation</h2>
<p>In this notation, operator is <b>prefix</b>ed to operands, i.e. operator is written ahead of operands. For example, <b>&plus;ab</b>. This is equivalent to its infix notation <b>a &plus; b</b>. Prefix notation is also known as <b>Polish Notation</b>.</p>
<h2>Postfix Notation</h2>
<p>This notation style is known as <b>Reversed Polish Notation</b>. In this notation style, the operator is <b>postfix</b>ed to the operands i.e., the operator is written after the operands. For example, <b>ab&plus;</b>. This is equivalent to its infix notation <b>a &plus; b</b>.</p>
<p>The following table briefly tries to show the difference in all three notations &minus;</p>
<table style="text-align:center;" class="table table-bordered">
<tr>
<th style="text-align:center;">Sr. No.</th>
<th style="text-align:center;">Infix Notation</th>
<th style="text-align:center;">Prefix Notation</th>
<th style="text-align:center;">Postfix Notation</th>
</tr>
<tr>
<td>1</td>
<td>a &plus; b</td>
<td>&plus; a b</td>
<td>a b &plus;</td>
</tr>
<tr>
<td>2</td>
<td>(a &plus; b) &lowast; c</td>
<td>&lowast; &plus; a b c</td>
<td>a b &plus; c &lowast;</td>
</tr>
<tr>
<td>3</td>
<td>a &lowast; (b &plus; c)</td>
<td>&lowast; a &plus; b c</td>
<td>a b c &plus; &lowast;</td>
</tr>
<tr>
<td>4</td>
<td>a / b &plus; c / d</td>
<td>&plus; / a b / c d</td>
<td>a b / c d / &plus;</td>
</tr>
<tr>
<td>5</td>
<td>(a &plus; b) &lowast; (c &plus; d)</td>
<td>&lowast; &plus; a b &plus; c d</td>
<td>a b &plus; c d &plus; &lowast;</td>
</tr>
<tr>
<td>6</td>
<td>((a &plus; b) &lowast; c) - d</td>
<td>- &lowast; &plus;  a b c d</td>
<td>a b &plus; c &lowast; d -</td>
</tr>
</table>
<h2>Parsing Expressions</h2>
<p>As we have discussed, it is not a very efficient way to design an algorithm or program to parse infix notations. Instead, these infix notations are first converted into either postfix or prefix notations and then computed.</p>
<p>To parse any arithmetic expression, we need to take care of operator precedence and associativity also.</p>
<h3>Precedence</h3>
<p>When an operand is in between two different operators, which operator will take the operand first, is decided by the precedence of an operator over others. For example &minus;</p>
<img src="/data_structures_algorithms/images/operator_precedence.jpg" alt="Operator Precendence" />
<p>As multiplication operation has precedence over addition, b * c will be evaluated first. A table of operator precedence is provided later.</p>
<h3>Associativity</h3>
<p>Associativity describes the rule where operators with the same precedence appear in an expression. For example, in expression a &plus; b − c, both &plus; and – have the same precedence, then which part of the expression will be evaluated first, is determined by associativity of those operators. Here, both &plus; and − are left associative, so the expression will be evaluated as <b>(a &plus; b) − c</b>.</p>
<p>Precedence and associativity determines the order of evaluation of an expression. Following is an operator precedence and associativity table (highest to lowest) &minus;</p>
<table style="text-align:center;" class="table table-bordered">
<tr>
<th style="text-align:center;">Sr. No.</th>
<th style="text-align:center;">Operator</th>
<th style="text-align:center;">Precedence</th>
<th style="text-align:center;">Associativity</th>
</tr>
<tr>
<td>1</td>
<td>Exponentiation &#94;</td>
<td>Highest</td>
<td>Right Associative</td>
</tr>
<tr>
<td>2</td>
<td>Multiplication ( &lowast; ) &amp; Division ( / )</td>
<td>Second Highest</td>
<td>Left Associative</td>
</tr>
<tr>
<td>3</td>
<td>Addition ( &plus; ) &amp; Subtraction ( &minus; )</td>
<td>Lowest</td>
<td>Left Associative</td>
</tr>
</table>
<p>The above table shows the default behavior of operators. At any point of time in expression evaluation, the order can be altered by using parenthesis. For example &minus;</p>
<p>In <b>a &plus; b*c</b>, the expression part <b>b</b>*<b>c</b> will be evaluated first, with multiplication as precedence over addition. We here use parenthesis for <b>a &plus; b</b> to be evaluated first, like <b>(a &plus; b)*c</b>.</p>
<h2>Postfix Evaluation Algorithm</h2>
<p>We shall now look at the algorithm on how to evaluate postfix notation &minus;</p>
<pre class="result notranslate">
Step 1 − scan the expression from left to right 
Step 2 − if it is an operand push it to stack 
Step 3 − if it is an operator pull operand from stack and perform operation 
Step 4 − store the output of step 3, back to stack 
Step 5 − scan the expression until all operands are consumed 
Step 6 − pop the stack and perform operation
</pre>
<p>To see the implementation in C programming language, please <a href="/data_structures_algorithms/expression_parsing_using_statck.htm">click here</a>.</p>
<h1>Data Structure and Algorithms - Queue</h1>
<p>Queue is an abstract data structure, somewhat similar to Stacks. Unlike stacks, a queue is open at both its ends. One end is always used to insert data (enqueue) and the other is used to remove data (dequeue). Queue follows First-In-First-Out methodology, i.e., the data item stored first will be accessed first.</p>
<img src="/data_structures_algorithms/images/queue_example.jpg" alt="Queue Example" />
<p>A real-world example of queue can be a single-lane one-way road, where the vehicle enters first, exits first. More real-world examples can be seen as queues at the ticket windows and bus-stops.</p>
<h2>Queue Representation</h2>
<p>As we now understand that in queue, we access both ends for different reasons. The following diagram given below tries to explain queue representation as data structure &minus;</p>
<img src="/data_structures_algorithms/images/queue_diagram.jpg" alt="Queue Example" />
<p>As in stacks, a queue can also be implemented using Arrays, Linked-lists, Pointers and Structures. For the sake of simplicity, we shall implement queues using one-dimensional array.</p>
<h2>Basic Operations</h2>
<p>Queue operations may involve initializing or defining the queue, utilizing it, and then completely erasing it from the memory. Here we shall try to understand the basic operations associated with queues &minus;</p>
<ul class="list">
<li><p><b>enqueue()</b> &minus; add (store) an item to the queue.</p></li>
<li><p><b>dequeue()</b> &minus; remove (access) an item from the queue.</p></li>
</ul>
<p>Few more functions are required to make the above-mentioned queue operation efficient. These are &minus;</p>
<ul class="list">
<li><p><b>peek()</b> &minus; Gets the element at the front of the queue without removing it.</p></li>
<li><p><b>isfull()</b> &minus; Checks if the queue is full.</p></li>
<li><p><b>isempty()</b> &minus; Checks if the queue is empty.</p></li>
</ul>
<p>In queue, we always dequeue (or access) data, pointed by <b>front</b> pointer and while enqueing (or storing) data in the queue we take help of <b>rear</b> pointer.</p>
<p>Let's first learn about supportive functions of a queue &minus;</p>
<h3>peek()</h3>
<p>This function helps to see the data at the <b>front</b> of the queue. The algorithm of peek() function is as follows &minus;</p>
<p><b>Algorithm</b></p>
<pre class="result notranslate">
begin procedure peek

   return queue[front]
   
end procedure
</pre>
<p>Implementation of peek() function in C programming language &minus;</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate" id="peek">
int peek() {
   return queue[front];
}
</pre>
<h3>isfull()</h3>
<p>As we are using single dimension array to implement queue, we just check for the rear pointer to reach at MAXSIZE to determine that the queue is full. In case we maintain the queue in a circular linked-list, the algorithm will differ. Algorithm of isfull() function &minus;</p>
<p><b>Algorithm</b></p>
<pre class="prettyprint notranslate">
begin procedure isfull

   if rear equals to MAXSIZE
      return true
   else
      return false
   endif
   
end procedure
</pre>
<p>Implementation of isfull() function in C programming language &minus;</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
bool isfull() {
   if(rear == MAXSIZE - 1)
      return true;
   else
      return false;
}
</pre>
<h3>isempty()</h3>
<p>Algorithm of isempty() function &minus;</p>
<p><b>Algorithm</b></p>
<pre class="prettyprint notranslate">
begin procedure isempty

   if front is less than MIN  OR front is greater than rear
      return true
   else
      return false
   endif
   
end procedure
</pre>
<p>If the value of <b>front</b> is less than MIN or 0, it tells that the queue is not yet initialized, hence empty.</p>
<p>Here's the C programming code &minus;</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
bool isempty() {
   if(front &lt; 0 || front &gt; rear) 
      return true;
   else
      return false;
}
</pre>
<h2>Enqueue Operation</h2>
<p>Queues maintain two data pointers, <b>front</b> and <b>rear</b>. Therefore, its operations are comparatively difficult to implement than that of stacks.</p>
<p>The following steps should be taken to enqueue (insert) data into a queue &minus;</p>
<ul class="list">
<li><p><b>Step 1</b> &minus; Check if the queue is full.</p></li>   
<li><p><b>Step 2</b> &minus; If the queue is full, produce overflow error and exit.</p></li>  
<li><p><b>Step 3</b> &minus; If the queue is not full, increment <b>rear</b> pointer to point the next empty space.</p></li>   
<li><p><b>Step 4</b> &minus; Add data element to the queue location, where the rear is pointing.</p></li>   
<li><p><b>Step 5</b> &minus; return success.</p></li>
</ul>
<img src="/data_structures_algorithms/images/queue_enqueue_diagram.jpg" alt="Insert Operation" />
<p>Sometimes, we also check to see if a queue is initialized or not, to handle any unforeseen situations.</p>
<p><b>Algorithm for enqueue operation</b></p>
<pre class="prettyprint notranslate">
procedure enqueue(data)      
   if queue is full
      return overflow
   endif
   
   rear &larr; rear + 1
   
   queue[rear] &larr; data
   
   return true
   
end procedure
</pre>
<p>Implementation of enqueue() in C programming language &minus;</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
int enqueue(int data)      
   if(isfull())
      return 0;
   
   rear = rear &plus; 1;
   queue[rear] = data;
   
   return 1;
end procedure
</pre>
<h2>Dequeue Operation</h2>
<p>Accessing data from the queue is a process of two tasks − access the data where <b>front</b> is pointing and remove the data after access. The following steps are taken to perform <b>dequeue</b> operation &minus;</p>
<ul class="list">
<li><p><b>Step 1</b> &minus; Check if the queue is empty.</p></li>   
<li><p><b>Step 2</b> &minus; If the queue is empty, produce underflow error and exit.</p></li>   
<li><p><b>Step 3</b> &minus; If the queue is not empty, access the data where <b>front</b> is pointing.</p></li>   
<li><p><b>Step 4</b> &minus; Increment <b>front</b> pointer to point to the next available data element.</p></li>   
<li><p><b>Step 5</b> &minus; Return success.</p></li>
</ul>
<img src="/data_structures_algorithms/images/queue_dequeue_diagram.jpg" alt="Remove Operation" />
<p><b>Algorithm for dequeue operation</b></p>
<pre class="prettyprint notranslate">
procedure dequeue
   if queue is empty
      return underflow
   end if

   data = queue[front]
   front &larr; front + 1
   
   return true
end procedure
</pre>
<p>Implementation of dequeue() in C programming language &minus;</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
int dequeue() {

   if(isempty())
      return 0;

   int data = queue[front];
   front = front + 1;

   return data;
}
</pre>
<p>For a complete Queue program in C programming language, please <a href="/data_structures_algorithms/queue_program_in_c.htm">click here</a>.</p>
<h1>Data Structure and Algorithms Linear Search</h1>
<p>Linear search is a very simple search algorithm. In this type of search, a sequential search is made over all items one by one. Every item is checked and if a match is found then that particular item is returned, otherwise the search continues till the end of the data collection.</p>
<img src="/data_structures_algorithms/images/linear_search.gif" alt="Linear Search Animation" />
<h2>Algorithm</h2>
<pre class="result notranslate">
Linear Search ( Array A, Value x)

Step 1: Set i to 1
Step 2: if i &gt; n then go to step 7
Step 3: if A[i] = x then go to step 6
Step 4: Set i to i + 1
Step 5: Go to Step 2
Step 6: Print Element x Found at index i and go to step 8
Step 7: Print element not found
Step 8: Exit
</pre> 
<h2>Pseudocode</h2>
<pre class="prettyprint notranslate">
procedure linear_search (list, value)

   for each item in the list

      if match item == value

         return the item's location

      end if

   end for

end procedure
</pre> 
<p>To know about linear search implementation in C programming language, please <a href="/data_structures_algorithms/linear_search_program_in_c.htm">click-here</a>.</p>
<h1>Data Structure and Algorithms Binary Search</h1>
<p>Binary search is a fast search algorithm with run-time complexity of &Omicron;(log n). This search algorithm works on the principle of divide and conquer. For this algorithm to work properly, the data collection should be in the sorted form.</p>
<p>Binary search looks for a particular item by comparing the middle most item of the collection. If a match occurs, then the index of item is returned. If the middle item is greater than the item, then the item is searched in the sub-array to the left of the middle item. Otherwise, the item is searched for in the sub-array to the right of the middle item. This process continues on the sub-array as well until the size of the subarray reduces to zero.</p>
<h2>How Binary Search Works?</h2>
<p>For a binary search to work, it is mandatory for the target array to be sorted. We shall learn the process of binary search with a pictorial example. The following is our sorted array and let us assume that we need to search the location of value 31 using binary search.</p>
<img src="/data_structures_algorithms/images/binary_search_0.jpg" alt="Binary search" /> 
<p>First, we shall determine half of the array by using this formula &minus;</p>
<pre class="result notranslate">
mid = low &plus; (high - low) / 2
</pre>
<p>Here it is, 0 &plus; (9 - 0 ) / 2 = 4 (integer value of 4.5). So, 4 is the mid of the array.</p>
<img src="/data_structures_algorithms/images/binary_search_1.jpg" alt="Binary search" /> 
<p>Now we compare the value stored at location 4, with the value being searched, i.e. 31. We find that the value at location 4 is 27, which is not a match. As the value is greater than 27 and we have a sorted array, so we also know that the target value must be in the upper portion of the array.</p>
<img src="/data_structures_algorithms/images/binary_search_2.jpg" alt="Binary search" /> 
<p>We change our low to mid &plus; 1 and find the new mid value again.</p>
<pre class="result notranslate">
low = mid &plus; 1
mid = low &plus; (high - low) / 2
</pre>
<p>Our new mid is 7 now. We compare the value stored at location 7 with our target value 31.</p>
<img src="/data_structures_algorithms/images/binary_search_3.jpg" alt="Binary search" /> 
<p>The value stored at location 7 is not a match, rather it is more than what we are looking for. So, the value must be in the lower part from this location.</p>
<img src="/data_structures_algorithms/images/binary_search_4.jpg" alt="Binary search" /> 
<p>Hence, we calculate the mid again. This time it is 5.</p>
<img src="/data_structures_algorithms/images/binary_search_5.jpg" alt="Binary search" /> 
<p>We compare the value stored at location 5 with our target value. We find that it is a match.</p>
<img src="/data_structures_algorithms/images/binary_search_6.jpg" alt="Binary search" /> 
<p>We conclude that the target value 31 is stored at location 5.</p>
<p>Binary search halves the searchable items and thus reduces the count of comparisons to be made to very less numbers.</p>
<h2>Pseudocode</h2>
<p>The pseudocode of binary search algorithms should look like this &minus;</p>
<pre class="prettyprint notranslate">
Procedure binary_search
   A &larr; sorted array
   n &larr; size of array
   x &larr; value to be searched

   Set lowerBound = 1
   Set upperBound = n 

   while x not found
      if upperBound &lt; lowerBound 
         EXIT: x does not exists.
   
      set midPoint = lowerBound &plus; ( upperBound - lowerBound ) / 2
      
      if A[midPoint] &lt; x
         set lowerBound = midPoint &plus; 1
         
      if A[midPoint] &gt; x
         set upperBound = midPoint - 1 

      if A[midPoint] = x 
         EXIT: x found at location midPoint

   end while
   
end procedure
</pre>
<p>To know about binary search implementation using array in C programming language, please <a href="/data_structures_algorithms/binary_search_program_in_c.htm">click here</a>.</p>
<h1>Data Structure - Interpolation Search</h1>
<p>Interpolation search is an improved variant of binary search. This search algorithm works on the probing position of the required value. For this algorithm to work properly, the data collection should be in a sorted form and equally distributed.</p>
<p>Binary search has a huge advantage of time complexity over linear search. Linear search has worst-case complexity of &Omicron;(n) whereas binary search has &Omicron;(log n).</p>
<p>There are cases where the location of target data may be known in advance. For example, in case of a telephone directory, if we want to search the telephone number of Morphius. Here, linear search and even binary search will seem slow as we can directly jump to memory space where the names start from 'M' are stored.</p>
<h2>Positioning in Binary Search</h2>
<p>In binary search, if the desired data is not found then the rest of the list is divided in two parts, lower and higher. The search is carried out in either of them.</p>
<img src="/data_structures_algorithms/images/bst_step_one.jpg" alt="BST Step One" />
<img src="/data_structures_algorithms/images/bst_step_two.jpg" alt="BST Step Two" />
<img src="/data_structures_algorithms/images/bst_step_three.jpg" alt="BST Step Three" />
<img src="/data_structures_algorithms/images/bst_step_four.jpg" alt="BST Step Four" />
<p>Even when the data is sorted, binary search does not take advantage to probe the position of the desired data.</p>
<h2>Position Probing in Interpolation Search</h2>
<p>Interpolation search finds a particular item by computing the probe position. Initially, the probe position is the position of the middle most item of the collection.</p>
<img src="/data_structures_algorithms/images/interpolation_step_one.jpg" alt="Interpolation Step One" />
<img src="/data_structures_algorithms/images/interpolation_step_two.jpg" alt="Interpolation Step Two" />   
<p>If a match occurs, then the index of the item is returned. To split the list into two parts, we use the following method &minus;</p>
<pre class="result notranslate" >
mid = Lo &plus; ((Hi - Lo) / (A[Hi] - A[Lo])) * (X - A[Lo])

where −
   A    = list
   Lo   = Lowest index of the list
   Hi   = Highest index of the list
   A[n] = Value stored at index n in the list
</pre>
<p>If the middle item is greater than the item, then the probe position is again calculated in the sub-array to the right of the middle item. Otherwise, the item is searched in the subarray to the left of the middle item. This process continues on the sub-array as well until the size of subarray reduces to zero.</p>
<p>Runtime complexity of interpolation search algorithm is <b>&Omicron;(log (log n))</b> as compared to <b>&Omicron;(log n)</b> of BST in favorable situations.</p>
<h3>Algorithm</h3>
<p>As it is an improvisation of the existing BST algorithm, we are mentioning the steps to search the 'target' data value index, using position probing &minus;</p>
<pre class="result notranslate">
Step 1 &minus; Start searching <b>data</b> from middle of the list.
Step 2 &minus; If it is a match, return the index of the item, and exit.
Step 3 &minus; If it is not a match, probe position.
Step 4 &minus; Divide the list using probing formula and find the new midle.
Step 5 &minus; If data is greater than middle, search in higher sub-list.
Step 6 &minus; If data is smaller than middle, search in lower sub-list.
Step 7 &minus; Repeat until match.
</pre>
<h2>Pseudocode</h2>
<pre class="prettyprint notranslate">
A &rarr; Array list
N &rarr; Size of A
X &rarr; Target Value

Procedure Interpolation_Search()

   Set Lo  &rarr;  0
   Set Mid &rarr; -1
   Set Hi  &rarr;  N-1

   While X does not match
   
      if Lo equals to Hi OR A[Lo] equals to A[Hi]
         EXIT: Failure, Target not found
      end if
      
      Set Mid = Lo + ((Hi - Lo) / (A[Hi] - A[Lo])) * (X - A[Lo]) 

      if A[Mid] = X
         EXIT: Success, Target found at Mid
      else 
         if A[Mid] &lt; X
            Set Lo to Mid+1
         else if A[Mid] &gt; X
            Set Hi to Mid-1
         end if
      end if
 
   End While

End Procedure
</pre>
<p>To know about the implementation of interpolation search in C programming language, <a href="/data_structures_algorithms/interpolation_search_in_c.htm" >click here</a>.</p>
<h1>Data Structure and Algorithms - Hash Table</h1>
<p>Hash Table is a data structure which stores data in an associative manner. In a hash table, data is stored in an array format, where each data value has its own unique index value. Access of data becomes very fast if we know the index of the desired data.</p> 
<p>Thus, it becomes a data structure in which insertion and search operations are very fast irrespective of the size of the data. Hash Table uses an array as a storage medium and uses hash technique to generate an index where an element is to be inserted or is to be located from.</p>
<h2>Hashing</h2>
<p>Hashing is a technique to convert a range of key values into a range of indexes of an array. We're going to use modulo operator to get a range of key values. Consider an example of hash table of size 20, and the following items are to be stored. Item are in the (key,value) format.</p>   
<img src="/data_structures_algorithms/images/hash_function.jpg" alt="Hash Function" /> 
<ul class="list">
<li>(1,20)</li>
<li>(2,70)</li>
<li>(42,80)</li>
<li>(4,25)</li>
<li>(12,44)</li>
<li>(14,32)</li>
<li>(17,11)</li>
<li>(13,78)</li>
<li>(37,98)</li>
</ul>
<table style="text-align:center;" class="table table-bordered">
<tr>
<th style="text-align:center;">Sr. No.</th>
<th style="text-align:center;">Key</th>
<th style="text-align:center;">Hash</th>
<th style="text-align:center;">Array Index</th>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1 % 20 = 1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>2 % 20 = 2</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>42</td>
<td>42 % 20 = 2</td>
<td>2</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td>4 % 20 = 4</td>
<td>4</td>
</tr>
<tr>
<td>5</td>
<td>12</td>
<td>12 % 20 = 12</td>
<td>12</td>
</tr>
<tr>
<td>6</td>
<td>14</td>
<td>14 % 20 = 14</td>
<td>14</td>
</tr>
<tr>
<td>7</td>
<td>17</td>
<td>17 % 20 = 17</td>
<td>17</td>
</tr>
<tr>
<td>8</td>
<td>13</td>
<td>13 % 20 = 13</td>
<td>13</td>
</tr>
<tr>
<td>9</td>
<td>37</td>
<td>37 % 20 = 17</td>
<td>17</td>
</tr>
</table>
<h2>Linear Probing</h2>
<p>As we can see, it may happen that the hashing technique is used to create an already used index of the array. In such a case, we can search the next empty location in the array by looking into the next cell until we find an empty cell. This technique is called linear probing.</p>
<table style="text-align:center;" class="table table-bordered">
<tr>
<th style="text-align:center;width:12%">Sr. No.</th>
<th style="text-align:center;width:8%">Key</th>
<th style="text-align:center;width:20%">Hash</th>
<th style="text-align:center;width:20%">Array Index</th>
<th style="text-align:center;width:40%">After Linear Probing, Array Index</th>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1 % 20 = 1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>2 % 20 = 2</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>42</td>
<td>42 % 20 = 2</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td>4 % 20 = 4</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>5</td>
<td>12</td>
<td>12 % 20 = 12</td>
<td>12</td>
<td>12</td>
</tr>
<tr>
<td>6</td>
<td>14</td>
<td>14 % 20 = 14</td>
<td>14</td>
<td>14</td>
</tr>
<tr>
<td>7</td>
<td>17</td>
<td>17 % 20 = 17</td>
<td>17</td>
<td>17</td>
</tr>
<tr>
<td>8</td>
<td>13</td>
<td>13 % 20 = 13</td>
<td>13</td>
<td>13</td>
</tr>
<tr>
<td>9</td>
<td>37</td>
<td>37 % 20 = 17</td>
<td>17</td>
<td>18</td>
</tr>
</table>
<h2>Basic Operations</h2>
<p>Following are the basic primary operations of a hash table.</p>
<ul class="list">
<li><p><b>Search</b> &minus; Searches an element in a hash table.</p></li>
<li><p><b>Insert</b> &minus; inserts an element in a hash table.</p></li>
<li><p><b>delete</b> &minus; Deletes an element from a hash table.</p></li>
</ul>
<h2>DataItem</h2>
<p>Define a data item having some data and key, based on which the search is to be conducted in a hash table.</p>
<pre class="result notranslate">
struct DataItem {
   int data;   
   int key;
};
</pre>
<h2>Hash Method</h2>
<p>Define a hashing method to compute the hash code of the key of the data item.</p>
<pre class="prettyprint notranslate">
int hashCode(int key){
   return key % SIZE;
}
</pre>
<h2>Search Operation</h2>
<p>Whenever an element is to be searched, compute the hash code of the key passed and locate the element using that hash code as index in the array. Use linear probing to get the element ahead if the element is not found at the computed hash code.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
struct DataItem *search(int key) {
   //get the hash 
   int hashIndex = hashCode(key);
	
   //move in array until an empty 
   while(hashArray[hashIndex] != NULL) {
	
      if(hashArray[hashIndex]-&gt;key == key)
         return hashArray[hashIndex];
			
      //go to next cell
      ++hashIndex;
		
      //wrap around the table
      hashIndex %= SIZE;
   }
	
   return NULL;        
}
</pre>
<h2>Insert Operation</h2>
<p>Whenever an element is to be inserted, compute the hash code of the key passed and locate the index using that hash code as an index in the array. Use linear probing for empty location, if an element is found at the computed hash code.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
void insert(int key,int data) {
   struct DataItem *item = (struct DataItem*) malloc(sizeof(struct DataItem));
   item-&gt;data = data;  
   item-&gt;key = key;     

   //get the hash 
   int hashIndex = hashCode(key);

   //move in array until an empty or deleted cell
   while(hashArray[hashIndex] != NULL &amp;&amp; hashArray[hashIndex]-&gt;key != -1) {
      //go to next cell
      ++hashIndex;
		
      //wrap around the table
      hashIndex %= SIZE;
   }
	
   hashArray[hashIndex] = item;        
}
</pre>
<h2>Delete Operation</h2>
<p>Whenever an element is to be deleted, compute the hash code of the key passed and locate the index using that hash code as an index in the array. Use linear probing to get the element ahead if an element is not found at the computed hash code. When found, store a dummy item there to keep the performance of the hash table intact.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
struct DataItem* delete(struct DataItem* item) {
   int key = item-&gt;key;

   //get the hash 
   int hashIndex = hashCode(key);

   //move in array until an empty 
   while(hashArray[hashIndex] !=NULL) {
	
      if(hashArray[hashIndex]-&gt;key == key) {
         struct DataItem* temp = hashArray[hashIndex]; 
			
         //assign a dummy item at deleted position
         hashArray[hashIndex] = dummyItem; 
         return temp;
      } 
		
      //go to next cell
      ++hashIndex;
		
      //wrap around the table
      hashIndex %= SIZE;
   }  
	
   return NULL;        
}
</pre>
<p>To know about hash implementation in C programming language, please <a href="/data_structures_algorithms/hash_table_program_in_c.htm">click here</a>.</p>
<h1>Data Structure - Sorting Techniques</h1>
<p>Sorting refers to arranging data in a particular format. Sorting algorithm specifies the way to arrange data in a particular order. Most common orders are in numerical or lexicographical order.</p>
<p>The importance of sorting lies in the fact that data searching can be optimized to a very high level, if data is stored in a sorted manner. Sorting is also used to represent data in more readable formats. Following are some of the examples of sorting in real-life scenarios &minus;</p>
<ul class="list">
<li><p><b>Telephone Directory</b> &minus; The telephone directory stores the telephone numbers of people sorted by their names, so that the names can be searched easily.</p></li>
<li><p><b>Dictionary</b> &minus; The dictionary stores words in an alphabetical order so that searching of any word becomes easy.</p></li>
</ul>
<h2>In-place Sorting and Not-in-place Sorting</h2>
<p>Sorting algorithms may require some extra space for comparison and temporary storage of few data elements. These algorithms do not require any extra space and sorting is said to happen in-place, or for example, within the array itself. This is called <b>in-place sorting</b>. Bubble sort is an example of in-place sorting.</p>
<p>However, in some sorting algorithms, the program requires space which is more than or equal to the elements being sorted. Sorting which uses equal or more space is called <b>not-in-place sorting</b>. Merge-sort is an example of not-in-place sorting.</p>
<h2>Stable and Not Stable Sorting</h2>
<p>If a sorting algorithm, after sorting the contents, does not change the sequence of similar content in which they appear, it is called <b>stable sorting</b>.</p>
<img src="/data_structures_algorithms/images/stable_sort.jpg" alt="Stable Sorting" />
<p>If a sorting algorithm, after sorting the contents, changes the sequence of similar content in which they appear, it is called <b>unstable sorting</b>.</p>
<img src="/data_structures_algorithms/images/unstable_sort.jpg" alt="Unstable Sorting" />
<p>Stability of an algorithm matters when we wish to maintain the sequence of original elements, like in a tuple for example.</p>
<h2>Adaptive and Non-Adaptive Sorting Algorithm</h2>
<p>A sorting algorithm is said to be adaptive, if it takes advantage of already 'sorted' elements in the list that is to be sorted. That is, while sorting if the source list has some element already sorted, adaptive algorithms will take this into account and will try not to re-order them.</p>
<p>A non-adaptive algorithm is one which does not take into account the elements which are already sorted. They try to force every single element to be re-ordered to confirm their sortedness.</p>
<h2>Important Terms</h2>   
<p>Some terms are generally coined while discussing sorting techniques, here is a brief introduction to them &minus;</p>
<h3>Increasing Order</h3>
<p>A sequence of values is said to be in <b>increasing order</b>, if the successive element is greater than the previous one. For example, 1, 3, 4, 6, 8, 9 are in increasing order, as every next element is greater than the previous element.</p>
<h3>Decreasing Order</h3>
<p>A sequence of values is said to be in <b>decreasing order</b>, if the successive element is less than the current one. For example, 9, 8, 6, 4, 3, 1 are in decreasing order, as every next element is less than the previous element.</p>
<h3>Non-Increasing Order</h3>
<p>A sequence of values is said to be in <b>non-increasing order</b>, if the successive element is less than or equal to its previous element in the sequence. This order occurs when the sequence contains duplicate values. For example, 9, 8, 6, 3, 3, 1 are in non-increasing order, as every next element is less than or equal to (in case of 3) but not greater than any previous element.</p>
<h3>Non-Decreasing Order</h3>
<p>A sequence of values is said to be in <b>non-decreasing order</b>, if the successive element is greater than or equal to its previous element in the sequence. This order occurs when the sequence contains duplicate values. For example, 1, 3, 3, 6, 8, 9 are in non-decreasing order, as every next element is greater than or equal to (in case of 3) but not less than the previous one.</p>
<h1>Data Structure - Bubble Sort Algorithm</h1>
<p>Bubble sort is a simple sorting algorithm. This sorting algorithm is comparison-based algorithm in which each pair of adjacent elements is compared and the elements are swapped if they are not in order. This algorithm is not suitable for large data sets as its average and worst case complexity are of &Omicron;(n<sup>2</sup>) where <b>n</b> is the number of items.</p>
<h2>How Bubble Sort Works?</h2>
<p>We take an unsorted array for our example. Bubble sort takes &Omicron;(n<sup>2</sup>) time so we're keeping it short and precise.</p>
<img src="/data_structures_algorithms/images/bubble_sort_0.jpg" alt="Bubble Sort" />  
<p>Bubble sort starts with very first two elements, comparing them to check which one is greater.</p>
<img src="/data_structures_algorithms/images/bubble_sort_1.jpg" alt="Bubble Sort" />  
<p>In this case, value 33 is greater than 14, so it is already in sorted locations. Next, we compare 33 with 27.</p>
<img src="/data_structures_algorithms/images/bubble_sort_2.jpg" alt="Bubble Sort" />  
<p>We find that 27 is smaller than 33 and these two values must be swapped.</p>
<img src="/data_structures_algorithms/images/bubble_sort_3.jpg" alt="Bubble Sort" />  
<p>The new array should look like this &minus;</p>
<img src="/data_structures_algorithms/images/bubble_sort_4.jpg" alt="Bubble Sort" />  
<p>Next we compare 33 and 35. We find that both are in already sorted positions.</p>
<img src="/data_structures_algorithms/images/bubble_sort_5.jpg" alt="Bubble Sort" />  
<p>Then we move to the next two values, 35 and 10.</p>
<img src="/data_structures_algorithms/images/bubble_sort_6.jpg" alt="Bubble Sort" />  
<p>We know then that 10 is smaller 35. Hence they are not sorted.</p>
<img src="/data_structures_algorithms/images/bubble_sort_7.jpg" alt="Bubble Sort" />  
<p>We swap these values. We find that we have reached the end of the array. After one iteration, the array should look like this &minus;</p>
<img src="/data_structures_algorithms/images/bubble_sort_8.jpg" alt="Bubble Sort" />  
<p>To be precise, we are now showing how an array should look like after each iteration. After the second iteration, it should look like this &minus;</p>
<img src="/data_structures_algorithms/images/bubble_sort_9.jpg" alt="Bubble Sort" />  
<p>Notice that after each iteration, at least one value moves at the end.</p>
<img src="/data_structures_algorithms/images/bubble_sort_10.jpg" alt="Bubble Sort" />  
<p>And when there's no swap required, bubble sorts learns that an array is completely sorted.</p>
<img src="/data_structures_algorithms/images/bubble_sort_11.jpg" alt="Bubble Sort" />  
<p>Now we should look into some practical aspects of bubble sort.</p>
<h2>Algorithm</h2>
<p>We assume <b>list</b> is an array of <b>n</b> elements. We further assume that <b>swap</b> function swaps the values of the given array elements.</p>
<pre class="prettyprint notranslate">
begin BubbleSort(list)

   for all elements of list
      if list[i] &gt; list[i+1]
         swap(list[i], list[i+1])
      end if
   end for
   
   return list
   
end BubbleSort
</pre> 
<h2>Pseudocode</h2>
<p>We observe in algorithm that Bubble Sort compares each pair of array element unless the whole array is completely sorted in an ascending order. This may cause a few complexity issues like what if the array needs no more swapping as all the elements are already ascending.</p>
<p>To ease-out the issue, we use one flag variable <b>swapped</b> which will help us see if any swap has happened or not. If no swap has occurred, i.e. the array requires no more processing to be sorted, it will come out of the loop.</p>
<p>Pseudocode of BubbleSort algorithm can be written as follows &minus;</p>
<pre class="prettyprint notranslate">
procedure bubbleSort( list : array of items )

   loop = list.count;
   
   for i = 0 to loop-1 do:
      swapped = false
		
      for j = 0 to loop-1 do:
      
         /* compare the adjacent elements */   
         if list[j] &gt; list[j+1] then
            /* swap them */
            swap( list[j], list[j+1] )		 
            swapped = true
         end if
         
      end for
      
      /*if no number was swapped that means 
      array is sorted now, break the loop.*/
      
      if(not swapped) then
         break
      end if
      
   end for
   
end procedure return list
</pre> 
<h2>Implementation</h2>
<p>One more issue we did not address in our original algorithm and its improvised pseudocode, is that, after every iteration the highest values settles down at the end of the array. Hence, the next iteration need not include already sorted elements. For this purpose, in our implementation, we restrict the inner loop to avoid already sorted values.</p>
<p>To know about bubble sort implementation in C programming language, please <a href="/data_structures_algorithms/bubble_sort_program_in_c.htm">click here</a>.</p>
<h1>Data Structure and Algorithms Insertion Sort</h1>
<p>This is an in-place comparison-based sorting algorithm. Here, a sub-list is maintained which is always sorted. For example, the lower part of an array is maintained to be sorted. An element which is to be 'insert'ed in this sorted sub-list, has to find its appropriate place and then it has to be inserted there. Hence the name, <b>insertion sort</b>.</p>
<p>The array is searched sequentially and unsorted items are moved and inserted into the sorted sub-list (in the same array). This algorithm is not suitable for large data sets as its average and worst case complexity are of &Omicron;(n<sup>2</sup>), where <b>n</b> is the number of items.</p>
<h2>How Insertion Sort Works?</h2>
<p>We take an unsorted array for our example.</p>
<img src="/data_structures_algorithms/images/unsorted_array.jpg" alt="Unsorted Array" />  
<p>Insertion sort compares the first two elements.</p>
<img src="/data_structures_algorithms/images/insertion_sort_1.jpg" alt="Insertion Sort" />  
<p>It finds that both 14 and 33 are already in ascending order. For now, 14 is in sorted sub-list.</p>
<img src="/data_structures_algorithms/images/insertion_sort_2.jpg" alt="Insertion Sort" />  
<p>Insertion sort moves ahead and compares 33 with 27.</p>
<img src="/data_structures_algorithms/images/insertion_sort_3.jpg" alt="Insertion Sort" />  
<p>And finds that 33 is not in the correct position.</p>
<img src="/data_structures_algorithms/images/insertion_sort_4.jpg" alt="Insertion Sort" /> 
<p>It swaps 33 with 27. It also checks with all the elements of sorted sub-list. Here we see that the sorted sub-list has only one element 14, and 27 is greater than 14. Hence, the sorted sub-list remains sorted after swapping.</p>
<img src="/data_structures_algorithms/images/insertion_sort_5.jpg" alt="Insertion Sort" />  
<p>By now we have 14 and 27 in the sorted sub-list. Next, it compares 33 with 10.</p>
<img src="/data_structures_algorithms/images/insertion_sort_6.jpg" alt="Insertion Sort" />  
<p>These values are not in a sorted order.</p>
<img src="/data_structures_algorithms/images/insertion_sort_7.jpg" alt="Insertion Sort" /> 
<p>So we swap them.</p>
<img src="/data_structures_algorithms/images/insertion_sort_8.jpg" alt="Insertion Sort" />  
<p>However, swapping makes 27 and 10 unsorted.</p>
<img src="/data_structures_algorithms/images/insertion_sort_9.jpg" alt="Insertion Sort" />  
<p>Hence, we swap them too.</p>
<img src="/data_structures_algorithms/images/insertion_sort_10.jpg" alt="Insertion Sort" />  
<p>Again we find 14 and 10 in an unsorted order.</p>
<img src="/data_structures_algorithms/images/insertion_sort_11.jpg" alt="Insertion Sort" />  
<p>We swap them again. By the end of third iteration, we have a sorted sub-list of 4 items.</p>
<img src="/data_structures_algorithms/images/insertion_sort_12.jpg" alt="Insertion Sort" />  
<p>This process goes on until all the unsorted values are covered in a sorted sub-list. Now we shall see some programming aspects of insertion sort.</p>   
<h3>Algorithm</h3>
<p>Now we have a bigger picture of how this sorting technique works, so we can derive simple steps by which we can achieve insertion sort.</p>
<pre class="result notranslate">
<b>Step 1</b> &minus; If it is the first element, it is already sorted. return 1;
<b>Step 2</b> &minus; Pick next element
<b>Step 3</b> &minus; Compare with all elements in the sorted sub-list
<b>Step 4</b> &minus; Shift all the elements in the sorted sub-list that is greater than the 
         value to be sorted
<b>Step 5</b> &minus; Insert the value
<b>Step 6</b> &minus; Repeat until list is sorted
</pre>    
<h2>Pseudocode</h2>
<pre class="prettyprint notranslate">
procedure insertionSort( A : array of items )
   int holePosition
   int valueToInsert
	
   for i = 1 to length(A) inclusive do:
	
      /* select value to be inserted */
      valueToInsert = A[i]
      holePosition = i
      
      /*locate hole position for the element to be inserted */
		
      while holePosition &gt; 0 and A[holePosition-1] &gt; valueToInsert do:
         A[holePosition] = A[holePosition-1]
         holePosition = holePosition -1
      end while
		
      /* insert the number at hole position */
      A[holePosition] = valueToInsert
      
   end for
	
end procedure
</pre> 
<p>To know about insertion sort implementation in C programming language, please <a href="/data_structures_algorithms/insertion_sort_program_in_c.htm">click here</a>.</p>
<h1>Data Structure and Algorithms Selection Sort</h1>
<p>Selection sort is a simple sorting algorithm. This sorting algorithm is an in-place comparison-based algorithm in which the list is divided into two parts, the sorted part at the left end and the unsorted part at the right end. Initially, the sorted part is empty and the unsorted part is the entire list.</p>
<p>The smallest element is selected from the unsorted array and swapped with the leftmost element, and that element becomes a part of the sorted array. This process continues moving unsorted array boundary by one element to the right.</p>
<p>This algorithm is not suitable for large data sets as its average and worst case complexities are of &Omicron;(n<sup>2</sup>), where <b>n</b> is the number of items.</p>
<h2>How Selection Sort Works?</h2>
<p>Consider the following depicted array as an example.</p>
<img src="/data_structures_algorithms/images/unsorted_array.jpg" alt="Unsorted Array" />  
<p>For the first position in the sorted list, the whole list is scanned sequentially. The first position where 14 is stored presently, we search the whole list and find that 10 is the lowest value.</p>
<img src="/data_structures_algorithms/images/selection_sort_1.jpg" alt="Selection Sort" />  
<p>So we replace 14 with 10. After one iteration 10, which happens to be the minimum value in the list, appears in the first position of the sorted list.</p>
<img src="/data_structures_algorithms/images/selection_sort_2.jpg" alt="Selection Sort" />  
<p>For the second position, where 33 is residing, we start scanning the rest of the list in a linear manner.</p>
<img src="/data_structures_algorithms/images/selection_sort_3.jpg" alt="Selection Sort" />  
<p>We find that 14 is the second lowest value in the list and it should appear at the second place. We swap these values.</p>
<img src="/data_structures_algorithms/images/selection_sort_4.jpg" alt="Selection Sort" />  
<p>After two iterations, two least values are positioned at the beginning in a sorted manner.</p>
<img src="/data_structures_algorithms/images/selection_sort_5.jpg" alt="Selection Sort" />  
<p>The same process is applied to the rest of the items in the array.</p>
<p>Following is a pictorial depiction of the entire sorting process &minus;</p>
<img src="/data_structures_algorithms/images/selection_sort.jpg" alt="Selection Sort" />  
<p>Now, let us learn some programming aspects of selection sort.</p>
<h3>Algorithm</h3>
<pre class="result notranslate">
<b>Step 1</b> &minus; Set MIN to location 0
<b>Step 2</b> &minus; Search the minimum element in the list
<b>Step 3</b> &minus; Swap with value at location MIN
<b>Step 4</b> &minus; Increment MIN to point to next element
<b>Step 5</b> &minus; Repeat until list is sorted
</pre>    
<h3>Pseudocode</h3>
<pre class="prettyprint notranslate">
procedure selection sort 
   list  : array of items
   n     : size of list

   for i = 1 to n - 1
   /* set current element as minimum*/
      min = i    
  
      /* check the element to be minimum */

      for j = i&plus;1 to n 
         if list[j] &lt; list[min] then
            min = j;
         end if
      end for

      /* swap the minimum element with the current element*/
      if indexMin != i  then
         swap list[min] and list[i]
      end if

   end for
	
end procedure
</pre> 
<p>To know about selection sort implementation in C programming language, please <a href="/data_structures_algorithms/selection_sort_program_in_c.htm">click here</a>.</p>
<h1>Data Structures - Merge Sort Algorithm</h1>
<p>Merge sort is a sorting technique based on divide and conquer technique. With worst-case time complexity being &Omicron;(n log n), it is one of the most respected algorithms.</p>
<p>Merge sort first divides the array into equal halves and then combines them in a sorted manner.</p>
<h2>How Merge Sort Works?</h2>
<p>To understand merge sort, we take an unsorted array as the following &minus;</p>
<img src="/data_structures_algorithms/images/unsorted_array.jpg" alt="Unsorted Array" />  
<p>We know that merge sort first divides the whole array iteratively into equal halves unless the atomic values are achieved. We see here that an array of 8 items is divided into two arrays of size 4.</p>
<img src="/data_structures_algorithms/images/merge_sort_divide_1.jpg" alt="Merge Sort Division" />  
<p>This does not change the sequence of appearance of items in the original. Now we divide these two arrays into halves.</p>
<img src="/data_structures_algorithms/images/merge_sort_divide_2.jpg" alt="Merge Sort Division" />  
<p>We further divide these arrays and we achieve atomic value which can no more be divided.</p>
<img src="/data_structures_algorithms/images/merge_sort_divide_3.jpg" alt="Merge Sort Division" />  
<p>Now, we combine them in exactly the same manner as they were broken down. Please note the color codes given to these lists.</p>
<p>We first compare the element for each list and then combine them into another list in a sorted manner. We see that 14 and 33 are in sorted positions. We compare 27 and 10 and in the target list of 2 values we put 10 first, followed by 27. We change the order of 19 and 35 whereas 42 and 44 are placed sequentially.</p>
<img src="/data_structures_algorithms/images/merge_sort_combine_1.jpg" alt="Merge Sort Combine" />  
<p>In the next iteration of the combining phase, we compare lists of two data values, and merge them into a list of found data values placing all in a sorted order.</p>
<img src="/data_structures_algorithms/images/merge_sort_combine_2.jpg" alt="Merge Sort Combine" />  
<p>After the final merging, the list should look like this &minus;</p>
<img src="/data_structures_algorithms/images/merge_sort.jpg" alt="Merge Sort" />  
<p>Now we should learn some programming aspects of merge sorting.</p>
<h3>Algorithm</h3>
<p>Merge sort keeps on dividing the list into equal halves until it can no more be divided. By definition, if it is only one element in the list, it is sorted. Then, merge sort combines the smaller sorted lists keeping the new list sorted too.</p>
<pre class="result notranslate">
<b>Step 1</b> &minus; if it is only one element in the list it is already sorted, return.
<b>Step 2</b> &minus; divide the list recursively into two halves until it can no more be divided.
<b>Step 3</b> &minus; merge the smaller lists into new list in sorted order.
</pre>
<h3>Pseudocode</h3>
<p>We shall now see the pseudocodes for merge sort functions. As our algorithms point out two main functions − divide &amp; merge.</p>
<p>Merge sort works with recursion and we shall see our implementation in the same way.</p>
<pre class="prettyprint notranslate">
procedure mergesort( var a as array )
   if ( n == 1 ) return a

   var l1 as array = a[0] ... a[n/2]
   var l2 as array = a[n/2+1] ... a[n]

   l1 = mergesort( l1 )
   l2 = mergesort( l2 )

   return merge( l1, l2 )
end procedure

procedure merge( var a as array, var b as array )

   var c as array

   while ( a and b have elements )
      if ( a[0] &gt; b[0] )
         add b[0] to the end of c
         remove b[0] from b
      else
         add a[0] to the end of c
         remove a[0] from a
      end if
   end while
   
   while ( a has elements )
      add a[0] to the end of c
      remove a[0] from a
   end while
   
   while ( b has elements )
      add b[0] to the end of c
      remove b[0] from b
   end while
   
   return c
	
end procedure
</pre>
<p>To know about merge sort implementation in C programming language, please <a href="/data_structures_algorithms/merge_sort_program_in_c.htm">click here</a>.</p>
<h1>Data Structure and Algorithms - Shell Sort</h1>
<p>Shell sort is a highly efficient sorting algorithm and is based on insertion sort algorithm. This algorithm avoids large shifts as in case of insertion sort, if the smaller value is to the far right and has to be moved to the far left.</p>
<p>This algorithm uses insertion sort on a widely spread elements, first to sort them and then sorts the less widely spaced elements. This spacing is termed as <b>interval</b>. This interval is calculated based on Knuth's formula as &minus;</p>
<h3>Knuth's Formula</h3>
<pre class="result notranslate">
h = h * 3 &plus; 1

where &minus;
   h is interval with initial value 1
</pre>
<p>This algorithm is quite efficient for medium-sized data sets as its average and worst case complexity are of &Omicron;(n), where <b>n</b> is the number of items.</p>
<h2>How Shell Sort Works?</h2>
<p>Let us consider the following example to have an idea of how shell sort works. We take the same array we have used in our previous examples. For our example and ease of understanding, we take the interval of 4. Make a virtual sub-list of all values located at the interval of 4 positions. Here these values are {35, 14}, {33, 19}, {42, 27} and {10, 44}</p>
<img src="/data_structures_algorithms/images/shell_sort_gap_4.jpg" alt="Shell Sort" />   
<p>We compare values in each sub-list and swap them (if necessary) in the original array. After this step, the new array should look like this &minus;</p>
<img src="/data_structures_algorithms/images/shell_sort_step_1.jpg" alt="Shell Sort" />  
<p>Then, we take interval of 2 and this gap generates two sub-lists - {14, 27, 35, 42}, {19, 10, 33, 44}</p>
<img src="/data_structures_algorithms/images/shell_sort_gap_2.jpg" alt="Shell Sort" />   
<p>We compare and swap the values, if required, in the original array. After this step, the array should look like this &minus;</p>
<img src="/data_structures_algorithms/images/shell_sort_step_2.jpg" alt="Shell Sort" />  
<p>Finally, we sort the rest of the array using interval of value 1. Shell sort uses insertion sort to sort the array.</p>
<p>Following is the step-by-step depiction &minus;</p>
<img src="/data_structures_algorithms/images/shell_sort.jpg" alt="Shell Sort" />  
<p>We see that it required only four swaps to sort the rest of the array.</p>
<h3>Algorithm</h3>
<p>Following is the algorithm for shell sort.</p>
<pre class="result notranslate">
<b>Step 1</b> &minus; Initialize the value of <i>h</i>
<b>Step 2</b> &minus; Divide the list into smaller sub-list of equal interval <i>h</i>
<b>Step 3</b> &minus; Sort these sub-lists using <b>insertion sort</b>
<b>Step 3</b> &minus; Repeat until complete list is sorted
</pre>
<h2>Pseudocode</h2>
<p>Following is the pseudocode for shell sort.</p>
<pre class="prettyprint notranslate">
procedure shellSort()
   A : array of items 
	
   /* calculate interval*/
   while interval &lt; A.length /3 do:
      interval = interval * 3 + 1	    
   end while
   
   while interval &gt; 0 do:

      for outer = interval; outer &lt; A.length; outer ++ do:

      /* select value to be inserted */
      valueToInsert = A[outer]
      inner = outer;

         /*shift element towards right*/
         while inner &gt; interval -1 &amp;&amp; A[inner - interval] &gt;= valueToInsert do:
            A[inner] = A[inner - interval]
            inner = inner - interval
         end while

      /* insert the number at hole position */
      A[inner] = valueToInsert

      end for

   /* calculate interval*/
   interval = (interval -1) /3;	  

   end while
   
end procedure
</pre> 
<p>To know about shell sort implementation in C programming language, please <a href="/data_structures_algorithms/shell_sort_program_in_c.htm">click here</a>.</p>
<h1>Data Structure and Algorithms - Quick Sort</h1>
<p>Quick sort is a highly efficient sorting algorithm and is based on partitioning of array of data into smaller arrays. A large array is partitioned into two arrays one of which holds values smaller than the specified value, say pivot, based on which the partition is made and another array holds values greater than the pivot value.</p> 
<p>Quick sort partitions an array and then calls itself recursively twice to sort the two resulting subarrays. This algorithm is quite efficient for large-sized data sets as its average and worst case complexity are of &Omicron;(nlogn), where <b>n</b> is the number of items.</p>
<h2>Partition in Quick Sort</h2>
<p>Following animated representation explains how to find the pivot value in an array.</p>
<img src="/data_structures_algorithms/images/quick_sort_partition_animation.gif" alt="Quick Sort Partition Animation" />
<p>The pivot value divides the list into two parts. And recursively, we find the pivot for each sub-lists until all lists contains only one element.</p>
<h2>Quick Sort Pivot Algorithm</h2>
<p>Based on our understanding of partitioning in quick sort, we will now try to write an algorithm for it, which is as follows.</p>
<pre class="result notranslate">
<b>Step 1</b> &minus; Choose the highest index value has pivot
<b>Step 2</b> &minus; Take two variables to point left and right of the list excluding pivot
<b>Step 3</b> &minus; left points to the low index
<b>Step 4</b> &minus; right points to the high
<b>Step 5</b> &minus; while value at left is less than pivot move right
<b>Step 6</b> &minus; while value at right is greater than pivot move left
<b>Step 7</b> &minus; if both step 5 and step 6 does not match swap left and right
<b>Step 8</b> &minus; if left &ge; right, the point where they met is new pivot
</pre>
<h2>Quick Sort Pivot Pseudocode</h2>
<p>The pseudocode for the above algorithm can be derived as &minus;</p>
<pre class="prettyprint notranslate">
function partitionFunc(left, right, pivot)
   leftPointer = left
   rightPointer = right - 1

   while True do
      while A[&plus;&plus;leftPointer] &lt; pivot do
         //do-nothing            
      end while
		
      while rightPointer &gt; 0 &amp;&amp; A[--rightPointer] &gt; pivot do
         //do-nothing         
      end while
		
      if leftPointer &gt;= rightPointer
         break
      else                
         swap leftPointer,rightPointer
      end if
		
   end while 
	
   swap leftPointer,right
   return leftPointer
	
end function
</pre>
<h2>Quick Sort Algorithm</h2>
<p>Using pivot algorithm recursively, we end up with smaller possible partitions. Each partition is then processed for quick sort. We define recursive algorithm for quicksort as follows &minus;</p>
<pre class="result notranslate">
<b>Step 1</b> &minus; Make the right-most index value pivot
<b>Step 2</b> &minus; partition the array using pivot value
<b>Step 3</b> &minus; quicksort left partition recursively
<b>Step 4</b> &minus; quicksort right partition recursively
</pre>
<h2>Quick Sort Pseudocode</h2>
<p>To get more into it, let see the pseudocode for quick sort algorithm &minus;</p>
<pre class="prettyprint notranslate">
procedure quickSort(left, right)

   if right-left &lt;= 0
      return
   else     
      pivot = A[right]
      partition = partitionFunc(left, right, pivot)
      quickSort(left,partition-1)
      quickSort(partition&plus;1,right)    
   end if		
   
end procedure
</pre>
<p>To know about quick sort implementation in C programming language, please <a href="/data_structures_algorithms/quick_sort_program_in_c.htm">click here</a>.</p>
<h1>Data Structure - Graph Data Structure</h1>
<p>A graph is a pictorial representation of a set of objects where some pairs of objects are connected by links. The interconnected objects are represented by points termed as <b>vertices</b>, and the links that connect the vertices are called <b>edges</b>.</p>
<p>Formally, a graph is a pair of sets <b>(V, E)</b>, where <b>V</b> is the set of vertices and <b>E</b> is the set of edges, connecting the pairs of vertices. Take a look at the following graph &minus;</p>
<img src="/data_structures_algorithms/images/graph_basics.jpg" alt="Graph Basics" />
<p>In the above graph,</p>
<p style="padding-left:8%;">V = {a, b, c, d, e}</p>
<p style="padding-left:8%;">E = {ab, ac, bd, cd, de}</p>
<h2>Graph Data Structure</h2>
<p>Mathematical graphs can be represented in data structure. We can represent a graph using an array of vertices and a two-dimensional array of edges. Before we proceed further, let's familiarize ourselves with some important terms &minus;</p>
<ul class="list">
<li><p><b>Vertex</b> &minus; Each node of the graph is represented as a vertex. In the following example, the labeled circle represents vertices. Thus, A to G are vertices. We can represent them using an array as shown in the following image. Here A can be identified by index 0. B can be identified using index 1 and so on.</p></li>
<li><p><b>Edge</b> &minus; Edge represents a path between two vertices or a line between two vertices. In the following example, the lines from A to B, B to C, and so on represents edges. We can use a two-dimensional array to represent an array as shown in the following image. Here AB can be represented as 1 at row 0, column 1, BC as 1 at row 1, column 2 and so on, keeping other combinations as 0.</p></li>
<li><p><b>Adjacency</b> &minus; Two node or vertices are adjacent if they are connected to each other through an edge. In the following example, B is adjacent to A, C is adjacent to B, and so on.</p></li>
<li><p><b>Path</b> &minus; Path represents a sequence of edges between the two vertices. In the following example, ABCD represents a path from A to D.</p></li>
</ul>
<img src="/data_structures_algorithms/images/graph.jpg" alt="graph" />
<h2>Basic Operations</h2>
<p>Following are basic primary operations of a Graph &minus;</p>
<ul class="list">
<li><p><b>Add Vertex</b> &minus; Adds a vertex to the graph.</p></li>
<li><p><b>Add Edge</b> &minus; Adds an edge between the two vertices of the graph.</p></li>
<li><p><b>Display Vertex</b> &minus; Displays a vertex of the graph.</p></li>
</ul>
<p>To know more about Graph, please read <a href="/graph_theory/index.htm">Graph Theory Tutorial</a>. We shall learn about traversing a graph in the coming chapters.</p>
<h1>Data Structure - Depth First Traversal</h1>
<p>Depth First Search (DFS) algorithm traverses a graph in a depthward motion and uses a stack to remember to get the next vertex to start a search, when a dead end occurs in any iteration.</p>
<img src="/data_structures_algorithms/images/depth_first_traversal.jpg" alt="Depth First Travesal" />
<p>As in the example given above, DFS algorithm traverses from A to B to C to D first then to E, then to F and lastly to G. It employs the following rules.</p>
<ul class="list">
<li><p><b>Rule 1</b> &minus; Visit the adjacent unvisited vertex. Mark it as visited. Display it. Push it in a stack.</p></li>
<li><p><b>Rule 2</b> &minus; If no adjacent vertex is found, pop up a vertex from the stack. (It will pop up all the vertices from the stack, which do not have adjacent vertices.)</p></li>
<li><p><b>Rule 3</b> &minus; Repeat Rule 1 and Rule 2 until the stack is empty.</p></li>
</ul>
<table class="table table-bordered">
<tr>
<th style="text-align:center;">Step</th>
<th style="text-align:center;">Traversal</th>
<th style="text-align:center;">Description</th>
</tr>
<tr>
<td style="width:5%; text-align:center; vertical-align:middle;">1.</td>
<td style="width:50%"><img src="/data_structures_algorithms/images/dfs_one.jpg" alt="Depth First Search Step One" /></td>
<td>Initialize the stack.</td>
</tr>
<tr>
<td style="width:5%; text-align:center; vertical-align:middle;">2.</td>
<td style="width:50%"><img src="/data_structures_algorithms/images/dfs_two.jpg" alt="Depth First Search Step Two" /></td>
<td>Mark <b>S</b> as visited and put it onto the stack. Explore any unvisited adjacent node from <b>S</b>. We have three nodes and we can pick any of them. For this example, we shall take the node in an alphabetical order.</td>
</tr>
<tr>
<td style="width:5%; text-align:center; vertical-align:middle;">3.</td>
<td style="width:50%"><img src="/data_structures_algorithms/images/dfs_three.jpg" alt="Depth First Search Step Three" /></td>
<td>Mark <b>A</b> as visited and put it onto the stack. Explore any unvisited adjacent node from A. Both <b>S</b> and <b>D</b> are adjacent to <b>A</b> but we are concerned for unvisited nodes only.</td>
</tr>
<tr>
<td style="width:5%; text-align:center; vertical-align:middle;">4.</td>
<td style="width:50%"><img src="/data_structures_algorithms/images/dfs_four.jpg" alt="Depth First Search Step Four" /></td>
<td>Visit <b>D</b> and mark it as visited and put onto the stack. Here, we have <b>B</b> and <b>C</b> nodes, which are adjacent to <b>D</b> and both are unvisited. However, we shall again choose in an alphabetical order.</td>
</tr>
<tr>
<td style="width:5%; text-align:center; vertical-align:middle;">5.</td>
<td style="width:50%"><img src="/data_structures_algorithms/images/dfs_five.jpg" alt="Depth First Search Step Five" /></td>
<td>We choose <b>B</b>, mark it as visited and put onto the stack. Here <b>B</b> does not have any unvisited adjacent node. So, we pop <b>B</b> from the stack.</td>
</tr>
<tr>
<td style="width:5%; text-align:center; vertical-align:middle;">6.</td>
<td style="width:50%"><img src="/data_structures_algorithms/images/dfs_six.jpg" alt="Depth First Search Step Six" /></td>
<td>We check the stack top for return to the previous node and check if it has any unvisited nodes. Here, we find <b>D</b> to be on the top of the stack.</td>
</tr>
<tr>
<td style="width:5%; text-align:center; vertical-align:middle;">7.</td>
<td style="width:50%"><img src="/data_structures_algorithms/images/dfs_seven.jpg" alt="Depth First Search Step Seven" /></td>
<td>Only unvisited adjacent node is from <b>D</b> is <b>C</b> now. So we visit <b>C</b>, mark it as visited and put it onto the stack.</td>
</tr>
</table>
<p>As <b>C</b> does not have any unvisited adjacent node so we keep popping the stack until we find a node that has an unvisited adjacent node. In this case, there's none and we keep popping until the stack is empty.</p>
<p>To know about the implementation of this algorithm in C programming language, <a href="/data_structures_algorithms/depth_first_traversal_in_c.htm">click here</a>.</p>
<h1>Data Structure - Breadth First Traversal</h1>
<p>Breadth First Search (BFS) algorithm traverses a graph in a breadthward motion and uses a queue to remember to get the next vertex to start a search, when a dead end occurs in any iteration.</p>
<img src="/data_structures_algorithms/images/breadth_first_traversal.jpg" alt="Breadth First Traversal" />
<p>As in the example given above, BFS algorithm traverses from A to B to E to F first then to C and G lastly to D. It employs the following rules.</p>
<ul class="list">
<li><p><b>Rule 1</b> &minus; Visit the adjacent unvisited vertex. Mark it as visited. Display it. Insert it in a queue.</p></li>
<li><p><b>Rule 2</b> &minus; If no adjacent vertex is found, remove the first vertex from the queue.</p></li>
<li><p><b>Rule 3</b> &minus; Repeat Rule 1 and Rule 2 until the queue is empty.</p></li>
</ul>
<table class="table table-bordered">
<tr>
<th style="text-align:center;">Step</th>
<th style="text-align:center;">Traversal</th>
<th style="text-align:center;">Description</th>
</tr>
<tr>
<td style="width:5%; text-align:center; vertical-align:middle;">1.</td>
<td style="width:50%"><img src="/data_structures_algorithms/images/bfs_one.jpg" alt="Breadth First Search Step One" /></td>
<td>Initialize the queue.</td>
</tr>
<tr>
<td style="width:5%; text-align:center; vertical-align:middle;">2.</td>
<td style="width:50%"><img src="/data_structures_algorithms/images/bfs_two.jpg" alt="Breadth First Search Step Two" /></td>
<td>We start from visiting <b>S</b> (starting node), and mark it as visited.</td>
</tr>
<tr>
<td style="width:5%; text-align:center; vertical-align:middle;">3.</td>
<td style="width:50%"><img src="/data_structures_algorithms/images/bfs_three.jpg" alt="Breadth First Search Step Three" /></td>
<td>We then see an unvisited adjacent node from <b>S</b>. In this example, we have three nodes but alphabetically we choose <b>A</b>, mark it as visited and enqueue it.</td>
</tr>
<tr>
<td style="width:5%; text-align:center; vertical-align:middle;">4.</td>
<td style="width:50%"><img src="/data_structures_algorithms/images/bfs_four.jpg" alt="Breadth First Search Step Four" /></td>
<td>Next, the unvisited adjacent node from <b>S</b> is <b>B</b>. We mark it as visited and enqueue it.</td>
</tr>
<tr>
<td style="width:5%; text-align:center; vertical-align:middle;">5.</td>
<td style="width:50%"><img src="/data_structures_algorithms/images/bfs_five.jpg" alt="Breadth First Search Step Five" /></td>
<td>Next, the unvisited adjacent node from <b>S</b> is <b>C</b>. We mark it as visited and enqueue it.</td>
</tr>
<tr>
<td style="width:5%; text-align:center; vertical-align:middle;">6.</td>
<td style="width:50%"><img src="/data_structures_algorithms/images/bfs_six.jpg" alt="Breadth First Search Step Six" /></td>
<td>Now, <b>S</b> is left with no unvisited adjacent nodes. So, we dequeue and find <b>A</b>.</td>
</tr>
<tr>
<td style="width:5%; text-align:center; vertical-align:middle;">7.</td>
<td style="width:50%"><img src="/data_structures_algorithms/images/bfs_seven.jpg" alt="Breadth First Search Step Seven" /></td>
<td>From <b>A</b> we have <b>D</b> as unvisited adjacent node. We mark it as visited and enqueue it.</td>
</tr>
</table>
<p>At this stage, we are left with no unmarked (unvisited) nodes. But as per the algorithm we keep on dequeuing in order to get all unvisited nodes. When the queue gets emptied, the program is over.</p>
<p>The implementation of this algorithm in C programming language can be <a href="/data_structures_algorithms/breadth_first_traversal_in_c.htm">seen here</a>.</p>
<h1>Data Structure and Algorithms - Tree</h1>
<p>Tree represents the nodes connected by edges. We will discuss binary tree or binary search tree specifically.</p>
<p>Binary Tree is a special datastructure used for data storage purposes. A binary tree has a special condition that each node can have a maximum of two children. A binary tree has the benefits of both an ordered array and a linked list as search is as quick as in a sorted array and insertion or deletion operation are as fast as in linked list.</p>
<img src="/data_structures_algorithms/images/binary_tree.jpg" alt="Binary Tree" />
<h2>Important Terms</h2>
<p>Following are the important terms with respect to tree.</p>
<ul class="list">
<li><p><b>Path</b> &minus; Path refers to the sequence of nodes along the edges of a tree.</p></li>
<li><p><b>Root</b> &minus; The node at the top of the tree is called root. There is only one root per tree and one path from the root node to any node.</p></li>
<li><p><b>Parent</b> &minus; Any node except the root node has one edge upward to a node called parent.</p></li>
<li><p><b>Child</b> &minus; The node below a given node connected by its edge downward is called its child node.</p></li>
<li><p><b>Leaf</b> &minus; The node which does not have any child node is called the leaf node.</p></li>
<li><p><b>Subtree</b> &minus; Subtree represents the descendants of a node.</p></li>
<li><p><b>Visiting</b> &minus; Visiting refers to checking the value of a node when control is on the node.</p></li>
<li><p><b>Traversing</b> &minus; Traversing means passing through nodes in a specific order.</p></li>
<li><p><b>Levels</b> &minus; Level of a node represents the generation of a node. If the root node is at level 0, then its next child node is at level 1, its grandchild is at level 2, and so on.</p></li>
<li><p><b>keys</b> &minus; Key represents a value of a node based on which a search operation is to be carried out for a node.</p></li>
</ul>
<h2>Binary Search Tree Representation</h2>
<p>Binary Search tree exhibits a special behavior. A node's left child must have a value less than its parent's value and the node's right child must have a value greater than its parent value.</p>
<img src="/data_structures_algorithms/images/binary_search_tree.jpg" alt="Binary Search Tree" />
<p>We're going to implement tree using node object and connecting them through references.</p>
<h2>Tree Node</h2>
<p>The code to write a tree node would be similar to what is given below. It has a data part and references to its left and right child nodes.</p>
<pre class="prettyprint notranslate">
struct node {
   int data;   
   struct node *leftChild;
   struct node *rightChild;
};
</pre>
<p>In a tree, all nodes share common construct.</p>
<h2>BST Basic Operations</h2>
<p>The basic operations that can be performed on a binary search tree data structure, are the following &minus;</p>
<ul class="list">
<li><p><b>Insert</b> &minus; Inserts an element in a tree/create a tree.</p></li>
<li><p><b>Search</b> &minus; Searches an element in a tree.</p></li>
<li><p><b>Preorder Traversal</b> &minus; Traverses a tree in a pre-order manner.</p></li>
<li><p><b>Inorder Traversal</b> &minus; Traverses a tree in an in-order manner.</p></li>
<li><p><b>Postorder Traversal</b> &minus; Traverses a tree in a post-order manner.</p></li>
</ul>
<p>We shall learn creating (inserting into) a tree structure and searching a data item in a tree in this chapter. We shall learn about tree traversing methods in the coming chapter.</p>
<h2>Insert Operation</h2>
<p>The very first insertion creates the tree. Afterwards, whenever an element is to be inserted, first locate its proper location. Start searching from the root node, then if the data is less than the key value, search for the empty location in the left subtree and insert the data. Otherwise, search for the empty location in the right subtree and insert the data.</p>
<h3>Algorithm</h3>
<pre class="prettyprint notranslate">
If root is NULL 
   then create root node
return

If root exists then
   compare the data with node.data
   
   while until insertion position is located

      If data is greater than node.data
         goto right subtree
      else
         goto left subtree

   endwhile 
   
   insert data
	
end If      
</pre>
<h3>Implementation</h3>
<p>The implementation of insert function should look like this &minus;</p>
<pre class="prettyprint notranslate">
void insert(int data) {
   struct node *tempNode = (struct node*) malloc(sizeof(struct node));
   struct node *current;
   struct node *parent;

   tempNode-&gt;data = data;
   tempNode-&gt;leftChild = NULL;
   tempNode-&gt;rightChild = NULL;

   //if tree is empty, create root node
   if(root == NULL) {
      root = tempNode;
   } else {
      current = root;
      parent  = NULL;

      while(1) {                
         parent = current;

         //go to left of the tree
         if(data &lt; parent-&gt;data) {
            current = current-&gt;leftChild;                
            
            //insert to the left
            if(current == NULL) {
               parent-&gt;leftChild = tempNode;
               return;
            }
         }
			
         //go to right of the tree
         else {
            current = current-&gt;rightChild;
            
            //insert to the right
            if(current == NULL) {
               parent-&gt;rightChild = tempNode;
               return;
            }
         }
      }            
   }
}
</pre>
<h2>Search Operation</h2>
<p>Whenever an element is to be searched, start searching from the root node, then if the data is less than the key value, search for the element in the left subtree. Otherwise, search for the element in the right subtree. Follow the same algorithm for each node.</p>
<h3>Algorithm</h3>
<pre class="prettyprint notranslate">
If root.data is equal to search.data
   return root
else
   while data not found

      If data is greater than node.data
         goto right subtree
      else
         goto left subtree
         
      If data found
         return node

   endwhile 
   
   return data not found
   
end if      
</pre>
<p>The implementation of this algorithm should look like this.</p>
<pre class="prettyprint notranslate">
struct node* search(int data) {
   struct node *current = root;
   printf("Visiting elements: ");

   while(current-&gt;data != data) {
      if(current != NULL)
      printf("%d ",current-&gt;data); 
      
      //go to left tree

      if(current-&gt;data &gt; data) {
         current = current-&gt;leftChild;
      }
      //else go to right tree
      else {                
         current = current-&gt;rightChild;
      }

      //not found
      if(current == NULL) {
         return NULL;
      }

      return current;
   }  
}
</pre>
<p>To know about the implementation of binary search tree data structure, please <a href="/data_structures_algorithms/tree_traversal_in_c.htm"> click here</a>.</p>
<h1>Data Structure &amp; Algorithms - Tree Traversal</h1>
<p>Traversal is a process to visit all the nodes of a tree and may print their values too. Because, all nodes are connected via edges (links) we always start from the root (head) node. That is, we cannot randomly access a node in a tree. There are three ways which we use to traverse a tree &minus;</p>
<ul class="list">
<li>In-order Traversal</li>
<li>Pre-order Traversal</li>
<li>Post-order Traversal</li>
</ul>
<p>Generally, we traverse a tree to search or locate a given item or key in the tree or to print all the values it contains.</p>
<h2>In-order Traversal</h2>
<p>In this traversal method, the left subtree is visited first, then the root and later the right sub-tree. We should always remember that every node may represent a subtree itself.</p>
<p>If a binary tree is traversed <b>in-order</b>, the output will produce sorted key values in an ascending order.</p>
<img src="/data_structures_algorithms/images/inorder_traversal.jpg" alt="In Order Traversal" />
<p>We start from <b>A</b>, and following in-order traversal, we move to its left subtree <b>B</b>. <b>B</b> is also traversed in-order. The process goes on until all the nodes are visited. The output of inorder traversal of this tree will be &minus;</p>
<p style="text-align:center;"><b><i>D &rarr; B &rarr; E &rarr; A &rarr; F &rarr; C &rarr; G</i></b></p>
<h3>Algorithm</h3>
<pre class="result notranslate">
Until all nodes are traversed &minus;
<b>Step 1</b> &minus; Recursively traverse left subtree.
<b>Step 2</b> &minus; Visit root node.
<b>Step 3</b> &minus; Recursively traverse right subtree.
</pre>
<h2>Pre-order Traversal</h2>
<p>In this traversal method, the root node is visited first, then the left subtree and finally the right subtree.</p>
<img src="/data_structures_algorithms/images/preorder_traversal.jpg" alt="Pre Order Traversal" />
<p>We start from <b>A</b>, and following pre-order traversal, we first visit <b>A</b> itself and then move to its left subtree <b>B</b>. <b>B</b> is also traversed pre-order. The process goes on until all the nodes are visited. The output of pre-order traversal of this tree will be &minus;</p>
<p style="text-align:center;"><b><i>A &rarr; B &rarr; D &rarr; E &rarr; C &rarr; F &rarr; G</i></b></p>
<h3>Algorithm</h3>
<pre class="result notranslate">
Until all nodes are traversed &minus;
<b>Step 1</b> &minus; Visit root node.
<b>Step 2</b> &minus; Recursively traverse left subtree.
<b>Step 3</b> &minus; Recursively traverse right subtree.
</pre>
<h2>Post-order Traversal</h2>
<p>In this traversal method, the root node is visited last, hence the name. First we traverse the left subtree, then the right subtree and finally the root node.</p>
<img src="/data_structures_algorithms/images/postorder_traversal.jpg" alt="Post Order Traversal" />
<p>We start from <b>A</b>, and following pre-order traversal, we first visit the left subtree <b>B</b>. <b>B</b> is also traversed post-order. The process goes on until all the nodes are visited. The output of post-order traversal of this tree will be &minus;</p>
<p style="text-align:center;"><b><i>D &rarr; E &rarr; B &rarr; F &rarr; G &rarr; C &rarr; A</i></b></p>
<h3>Algorithm</h3>
<pre class="result notranslate">
Until all nodes are traversed &minus;
<b>Step 1</b> &minus; Recursively traverse left subtree.
<b>Step 2</b> &minus; Recursively traverse right subtree.
<b>Step 3</b> &minus; Visit root node.
</pre>
<p>To check the C implementation of tree traversing, please <a href="/data_structures_algorithms/tree_traversal_in_c.htm">click here</a>.</p>
<h1>Data Structure - Binary Search Tree</h1>
<p>A Binary Search Tree (BST) is a tree in which all the nodes follow the below-mentioned properties &minus;</p>
<ul class="list">
<li><p>The left sub-tree of a node has a key less than or equal to its parent node's key.</p></li>   
<li><p>The right sub-tree of a node has a key greater than to its parent node's key.</p></li>   
</ul>
<p>Thus, BST divides all its sub-trees into two segments; the left sub-tree and the right sub-tree and can be defined as &minus;</p>
<pre class="result notranslate">
left_subtree (keys)  &le;  node (key)  &le;  right_subtree (keys)
</pre>
<h2>Representation</h2>
<p>BST is a collection of nodes arranged in a way where they maintain BST properties. Each node has a key and an associated value. While searching, the desired key is compared to the keys in BST and if found, the associated value is retrieved.</p>
<p>Following is a pictorial representation of BST &minus;</p>
<img src="/data_structures_algorithms/images/binary_search_tree.jpg" alt="Binary Search Tree" />
<p>We observe that the root node key (27) has all less-valued keys on the left sub-tree and the higher valued keys on the right sub-tree.</p>
<h2>Basic Operations</h2>
<p>Following are the basic operations of a tree &minus;</p>
<ul class="list">
<li><p><b>Search</b> &minus; Searches an element in a tree.</p></li>
<li><p><b>Insert</b> &minus; Inserts an element in a tree.</p></li>
<li><p><b>Pre-order Traversal</b> &minus; Traverses a tree in a pre-order manner.</p></li>
<li><p><b>In-order Traversal</b> &minus; Traverses a tree in an in-order manner.</p></li>
<li><p><b>Post-order Traversal</b> &minus; Traverses a tree in a post-order manner.</p></li>
</ul>
<h2>Node</h2>
<p>Define a node having some data, references to its left and right child nodes.</p>
<pre class="prettyprint notranslate">
struct node {
   int data;   
   struct node *leftChild;
   struct node *rightChild;
};
</pre>
<h2>Search Operation</h2>
<p>Whenever an element is to be searched, start searching from the root node. Then if the data is less than the key value, search for the element in the left subtree. Otherwise, search for the element in the right subtree. Follow the same algorithm for each node.</p>
<h3>Algorithm</h3>
<pre class="prettyprint notranslate">
struct node* search(int data){
   struct node *current = root;
   printf("Visiting elements: ");
	
   while(current-&gt;data != data){
	
      if(current != NULL) {
         printf("%d ",current-&gt;data);
			
         //go to left tree
         if(current-&gt;data &gt; data){
            current = current-&gt;leftChild;
         }//else go to right tree
         else {                
            current = current-&gt;rightChild;
         }
			
         //not found
         if(current == NULL){
            return NULL;
         }
      }			
   }
   return current;
}
</pre>
<h2>Insert Operation</h2>
<p>Whenever an element is to be inserted, first locate its proper location. Start searching from the root node, then if the data is less than the key value, search for the empty location in the left subtree and insert the data. Otherwise, search for the empty location in the right subtree and insert the data.</p>
<h3>Algorithm</h3>
<pre class="prettyprint notranslate">
void insert(int data) {
   struct node *tempNode = (struct node*) malloc(sizeof(struct node));
   struct node *current;
   struct node *parent;

   tempNode-&gt;data = data;
   tempNode-&gt;leftChild = NULL;
   tempNode-&gt;rightChild = NULL;

   //if tree is empty
   if(root == NULL) {
      root = tempNode;
   } else {
      current = root;
      parent = NULL;

      while(1) {                
         parent = current;
			
         //go to left of the tree
         if(data &lt; parent-&gt;data) {
            current = current-&gt;leftChild;                
            //insert to the left
				
            if(current == NULL) {
               parent-&gt;leftChild = tempNode;
               return;
            }
         }//go to right of the tree
         else {
            current = current-&gt;rightChild;
            
            //insert to the right
            if(current == NULL) {
               parent-&gt;rightChild = tempNode;
               return;
            }
         }
      }            
   }
}        
</pre>
<h1>Data Structure and Algorithms - AVL Trees</h1>
<p>What if the input to binary search tree comes in a sorted (ascending or descending) manner? It will then look like this &minus;</p>   
<img src="/data_structures_algorithms/images/unbalanced_bst.jpg" alt="Unbalanced BST" /> 
<p>It is observed that BST's worst-case performance is closest to linear search algorithms, that is &Omicron;(n). In real-time data, we cannot predict data pattern and their frequencies. So, a need arises to balance out the existing BST.</p>
<p>Named after their inventor <b>Adelson</b>, <b>Velski</b> &amp; <b>Landis</b>, <b>AVL trees</b> are height balancing binary search tree. AVL tree checks the height of the left and the right sub-trees and assures that the difference is not more than 1. This difference is called the <b>Balance Factor</b>.</p>
<p>Here we see that the first tree is balanced and the next two trees are not balanced &minus;</p>
<img src="/data_structures_algorithms/images/unbalanced_avl_trees.jpg" alt="Unbalanced AVL Trees" /> 
<p>In the second tree, the left subtree of <b>C</b> has height 2 and the right subtree has height 0, so the difference is 2. In the third tree, the right subtree of <b>A</b> has height 2 and the left is missing, so it is 0, and the difference is 2 again. AVL tree permits difference (balance factor) to be only 1.</p>
<pre class="result notranslate">
<i><b>BalanceFactor</b></i> = height(left-sutree) &minus; height(right-sutree)
</pre>
<p>If the difference in the height of left and right sub-trees is more than 1, the tree is balanced using some rotation techniques.</p>
<h2>AVL Rotations</h2>
<p>To balance itself, an AVL tree may perform the following four kinds of rotations &minus;</p>
<ul class="list">
<li>Left rotation</li>
<li>Right rotation</li>
<li>Left-Right rotation</li>
<li>Right-Left rotation</li>
</ul>
<p>The first two rotations are single rotations and the next two rotations are double rotations. To have an unbalanced tree, we at least need a tree of height 2. With this simple tree, let's understand them one by one.</p>
<h3>Left Rotation</h3>
<p>If a tree becomes unbalanced, when a node is inserted into the right subtree of the right subtree, then we perform a single left rotation &minus;</p>
<img src="/data_structures_algorithms/images/avl_left_rotation.jpg" alt="Left Rotation" /> 
<p>In our example, node <b>A</b> has become unbalanced as a node is inserted in the right subtree of A's right subtree. We perform the left rotation by making <b>A</b> the left-subtree of B.</p>
<h2>Right Rotation</h2>
<p>AVL tree may become unbalanced, if a node is inserted in the left subtree of the left subtree. The tree then needs a right rotation.</p>
<img src="/data_structures_algorithms/images/avl_right_rotation.jpg" alt="Right Rotation" /> 
<p>As depicted, the unbalanced node becomes the right child of its left child by performing a right rotation.</p>
<h3>Left-Right Rotation</h3>
<p>Double rotations are slightly complex version of already explained versions of rotations. To understand them better, we should take note of each action performed while rotation. Let's first check how to perform Left-Right rotation. A left-right rotation is a combination of left rotation followed by right rotation.</p>
<table class="table table-bordered">
<tr>
<th style="width:30%; text-align:center;">State</th>
<th style="text-align:center;">Action</th>
</tr>   
<tr>
<td><img src="/data_structures_algorithms/images/right_subtree_of_left_subtree.jpg" alt="Right Rotation" /></td>
<td style="vertical-align:middle">A node has been inserted into the right subtree of the left subtree. This makes <b>C</b> an unbalanced node. These scenarios cause AVL tree to perform left-right rotation.</td>
</tr>
<tr>
<td><img src="/data_structures_algorithms/images/subtree_left_rotation.jpg" alt="Left Rotation" /></td>
<td style="vertical-align:middle">We first perform the left rotation on the left subtree of <b>C</b>. This makes <b>A</b>, the left subtree of <b>B</b>.</td>
</tr>
<tr>
<td><img src="/data_structures_algorithms/images/left_unbalanced_tree.jpg" alt="Left Rotation" /></td>
<td style="vertical-align:middle">Node <b>C</b> is still unbalanced, however now, it is because of the left-subtree of the left-subtree.</td>
</tr>
<tr>
<td><img src="/data_structures_algorithms/images/right_rotation.jpg" alt="Right Rotation" /></td>
<td style="vertical-align:middle">We shall now right-rotate the tree, making <b>B</b> the new root node of this subtree. <b>C</b> now becomes the right subtree of its own left subtree.</td>
</tr>
<tr>
<td><img src="/data_structures_algorithms/images/balanced_avl_tree.jpg" alt="Balanced Avl Tree" /></td>
<td style="vertical-align:middle">The tree is now balanced.</td>
</tr>
</table>
<h3>Right-Left Rotation</h3>
<p>The second type of double rotation is Right-Left Rotation. It is a combination of right rotation followed by left rotation.</p>
<table class="table table-bordered">
<tr>
<th style="text-align:center; width:30%;">State</th>
<th style="text-align:center;">Action</th>
</tr>   
<tr>
<td><img src="/data_structures_algorithms/images/left_subtree_of_right_subtree.jpg" alt="Left Subtree of Right Subtree" /></td>
<td style="vertical-align:middle">A node has been inserted into the left subtree of the right subtree. This makes <b>A</b>, an unbalanced node with balance factor 2.</td>
</tr>
<tr>
<td><img src="/data_structures_algorithms/images/subtree_right_rotation.jpg" alt="Subtree Right Rotation" /></td>
<td style="vertical-align:middle">First, we perform the right rotation along <b>C</b> node, making <b>C</b> the right subtree of its own left subtree <b>B</b>. Now, <b>B</b> becomes the right subtree of <b>A</b>.</td>
</tr>
<tr>
<td><img src="/data_structures_algorithms/images/right_unbalanced_tree.jpg" alt="Right Unbalanced Tree" /></td>
<td style="vertical-align:middle">Node <b>A</b> is still unbalanced because of the right subtree of its right subtree and requires a left rotation.</td>
</tr>
<tr>
<td><img src="/data_structures_algorithms/images/left_rotation.jpg" alt="Left Rotation" /></td>
<td style="vertical-align:middle">A left rotation is performed by making <b>B</b> the new root node of the subtree. <b>A</b> becomes the left subtree of its right subtree <b>B</b>.</td>
</tr>
<tr>
<td><img src="/data_structures_algorithms/images/balanced_avl_tree.jpg" alt="Balanced AVL Tree" /></td>
<td style="vertical-align:middle">The tree is now balanced.</td>
</tr>
</table>
<h1>Data Structure &amp; Algorithms - Spanning Tree</h1>
<p>A spanning tree is a subset of Graph G, which has all the vertices covered with minimum possible number of edges. Hence, a spanning tree does not have cycles and it cannot be disconnected..</p>
<p>By this definition, we can draw a conclusion that every connected and undirected Graph G has at least one spanning tree. A disconnected graph does not have any spanning tree, as it cannot be spanned to all its vertices.</p>
<img src="/data_structures_algorithms/images/spanning_trees.jpg" alt="Spanning Trees" />
<p>We found three spanning trees off one complete graph. A complete undirected graph can have maximum <b>n<sup>n-2</sup></b> number of spanning trees, where <b>n</b> is the number of nodes. In the above addressed example, <b>3<sup>3&minus;2</sup> = 3</b> spanning trees are possible.</p>
<h2>General Properties of Spanning Tree</h2>
<p>We now understand that one graph can have more than one spanning tree. Following are a few properties of the spanning tree connected to graph G &minus;</p>
<ul class="list">
<li><p>A connected graph G can have more than one spanning tree.</p></li>   
<li><p>All possible spanning trees of graph G, have the same number of edges and vertices.</p></li>   
<li><p>The spanning tree does not have any cycle (loops).</p></li>   
<li><p>Removing one edge from the spanning tree will make the graph disconnected, i.e. the spanning tree is <b>minimally connected</b>.</p></li>   
<li><p>Adding one edge to the spanning tree will create a circuit or loop, i.e. the spanning tree is <b>maximally acyclic</b>.</p></li>   
</ul>
<h2>Mathematical Properties of Spanning Tree</h2>
<ul class="list">
<li><p>Spanning tree has <b>n-1</b> edges, where <b>n</b> is the number of nodes (vertices).</p></li>   
<li><p>From a complete graph, by removing maximum <b>e - n &plus; 1</b> edges, we can construct a spanning tree.</p></li>   
<li><p>A complete graph can have maximum <b>n<sup>n-2</sup></b> number of spanning trees.</p></li>   
</ul>
<p>Thus, we can conclude that spanning trees are a subset of connected Graph G and disconnected graphs do not have spanning tree.</p>
<h2>Application of Spanning Tree</h2>
<p>Spanning tree is basically used to find a minimum path to connect all nodes in a graph. Common application of spanning trees are &minus;</p>
<ul class="list">
<li><p><b>Civil Network Planning</b></p></li>   
<li><p><b>Computer Network Routing Protocol</b></p></li>   
<li><p><b>Cluster Analysis</b></p></li>   
</ul>
<p>Let us understand this through a small example. Consider, city network as a huge graph and now plans to deploy telephone lines in such a way that in minimum lines we can connect to all city nodes. This is where the spanning tree comes into picture.</p>
<h2>Minimum Spanning Tree (MST)</h2>
<p>In a weighted graph, a minimum spanning tree is a spanning tree that has minimum weight than all other spanning trees of the same graph. In real-world situations, this weight can be measured as distance, congestion, traffic load or any arbitrary value denoted to the edges.</p>
<h2>Minimum Spanning-Tree Algorithm</h2>
<p>We shall learn about two most important spanning tree algorithms here &minus;</p>
<ul class="list">
<li><p><a href="/data_structures_algorithms/kruskals_spanning_tree_algorithm.htm">Kruskal's Algorithm</a></p></li>   
<li><p><a href="/data_structures_algorithms/prims_spanning_tree_algorithm.htm">Prim's Algorithm</a></p></li>   
</ul>
<p>Both are greedy algorithms.</p>
<h1>Heap Data Structures</h1>
<p>Heap is a special case of balanced binary tree data structure where the root-node key is compared with its children and arranged accordingly. If <b>&alpha;</b> has child node <b>&beta;</b> then &minus;</p>
<p style="text-align:center; font-weight:bold;">key(&alpha;) &ge; key(&beta;)</p>
<p>As the value of parent is greater than that of child, this property generates <b>Max Heap</b>. Based on this criteria, a heap can be of two types &minus;</p>
<pre class="result notranslate">
For Input &rarr; 35 33 42 10 14 19 27 44 26 31
</pre>
<p><b>Min-Heap</b> &minus;  Where the value of the root node is less than or equal to either of its children.</p>
<img src="/data_structures_algorithms/images/min_heap_example.jpg" alt="Max Heap Example" />
<p><b>Max-Heap</b> &minus; Where the value of the root node is greater than or equal to either of its children.</p>
<img src="/data_structures_algorithms/images/max_heap_example.jpg" alt="Max Heap Example" />
<p>Both trees are constructed using the same input and order of arrival.</p>
<h2>Max Heap Construction Algorithm</h2>
<p>We shall use the same example to demonstrate how a Max Heap is created. The procedure to create Min Heap is similar but we go for min values instead of max values.</p>
<p>We are going to derive an algorithm for max heap by inserting one element at a time. At any point of time, heap must maintain its property. While insertion, we also assume that we are inserting a node in an already heapified tree.</p>
<pre class="result notranslate">
<b>Step 1</b> &minus; Create a new node at the end of heap.
<b>Step 2</b> &minus; Assign new value to the node.
<b>Step 3</b> &minus; Compare the value of this child node with its parent.
<b>Step 4</b> &minus; If value of parent is less than child, then swap them.
<b>Step 5</b> &minus; Repeat step 3 &amp; 4 until Heap property holds.
</pre>
<p><b>Note</b> &minus; In Min Heap construction algorithm, we expect the value of the parent node to be less than that of the child node.</p>
<p>Let's understand Max Heap construction by an animated illustration. We consider the same input sample that we used earlier.</p>
<img src="/data_structures_algorithms/images/max_heap_animation.gif" alt="Max Heap Animated Example" />
<h2>Max Heap Deletion Algorithm</h2>
<p>Let us derive an algorithm to delete from max heap. Deletion in Max (or Min) Heap always happens at the root to remove the Maximum (or minimum) value.</p>
<pre class="result notranslate">
<b>Step 1</b> &minus; Remove root node.
<b>Step 2</b> &minus; Move the last element of last level to root.
<b>Step 3</b> &minus; Compare the value of this child node with its parent.
<b>Step 4</b> &minus; If value of parent is less than child, then swap them.
<b>Step 5</b> &minus; Repeat step 3 &amp; 4 until Heap property holds.
</pre>
<img src="/data_structures_algorithms/images/max_heap_deletion_animation.gif" alt="Max Heap Deletion Animated Example" />
<h1>Data Structure - Recursion Basics</h1>
<p>Some computer programming languages allow a module or function to call itself. This technique is known as recursion. In recursion, a function <b>&alpha;</b> either calls itself directly or calls a function <b>&beta;</b> that in turn calls the original function <b>&alpha;</b>. The function <b>&alpha;</b> is called recursive function.</p>
<p><b>Example</b> &minus; a function calling itself.</p>
<pre class="prettyprint notranslate">
int function(int value) {
   if(value &lt; 1)
      return;
   function(value - 1);
	
   printf("%d ",value);   
}
</pre>
<p><b>Example</b> &minus; a function that calls another function which in turn calls it again.</p>
<pre class="prettyprint notranslate">
int function(int value) {
   if(value &lt; 1)
      return;
   function(value - 1);
	
   printf("%d ",value);   
}
</pre>
<h2>Properties</h2> 
<p>A recursive function can go infinite like a loop. To avoid infinite running of recursive function, there are two properties that a recursive function must have &minus;</p>
<ul class="list">
<li><p><b>Base criteria</b> &minus; There must be at least one base criteria or condition, such that, when this condition is met the function stops calling itself recursively.</p></li>
<li><p><b>Progressive approach</b> &minus; The recursive calls should progress in such a way that each time a recursive call is made it comes closer to the base criteria.</p></li>
</ul>
<h2>Implementation</h2>
<p>Many programming languages implement recursion by means of <b>stacks</b>. Generally, whenever a function (<b>caller</b>) calls another function (<b>callee</b>) or itself as callee, the caller function transfers execution control to the callee. This transfer process may also involve some data to be passed from the caller to the callee.</p>
<p>This implies, the caller function has to suspend its execution temporarily and resume later when the execution control returns from the callee function. Here, the caller function needs to start exactly from the point of execution where it puts itself on hold. It also needs the exact same data values it was working on. For this purpose, an activation record (or stack frame) is created for the caller function.</p>
<img src="/data_structures_algorithms/images/activation_records.jpg" alt="Activation Records" />
<p>This activation record keeps the information about local variables, formal parameters, return address and all information passed to the caller function.</p>
<h2>Analysis of Recursion</h2>
<p>One may argue why to use recursion, as the same task can be done with iteration. The first reason is, recursion makes a program more readable and because of latest enhanced CPU systems, recursion is more efficient than iterations.</p>
<h2>Time Complexity</h2>
<p>In case of iterations, we take number of iterations to count the time complexity. Likewise, in case of recursion, assuming everything is constant, we try to figure out the number of times a recursive call is being made. A call made to a function is &Omicron;(1), hence the (n) number of times a recursive call is made makes the recursive function &Omicron;(n).</p>
<h2>Space Complexity</h2>
<p>Space complexity is counted as what amount of extra space is required for a module to execute. In case of iterations, the compiler hardly requires any extra space. The compiler keeps updating the values of variables used in the iterations. But in case of recursion, the system needs to store activation record each time a recursive call is made. Hence, it is considered that space complexity of recursive function may go higher than that of a function with iteration.</p>
<h1>Data Structure &amp; Algorithms - Tower of Hanoi</h1>
<p>Tower of Hanoi, is a mathematical puzzle which consists of three towers (pegs) and more than one rings is as depicted &minus;</p>
<img src="/data_structures_algorithms/images/tower_of_hanoi.jpg" alt="Tower Of Hanoi" />
<p>These rings are of different sizes and stacked upon in an ascending order, i.e. the smaller one sits over the larger one. There are other variations of the puzzle where the number of disks increase, but the tower count remains the same.</p>
<h2>Rules</h2>
<p>The mission is to move all the disks to some another tower without violating the sequence of arrangement. A few rules to be followed for Tower of Hanoi are &minus;</p>
<ul class="list">
<li>Only one disk can be moved among the towers at any given time.</li>   
<li>Only the "top" disk can be removed.</li>   
<li>No large disk can sit over a small disk.</li>   
</ul>
<p>Following is an animated representation of solving a Tower of Hanoi puzzle with three disks.</p>
<img src="/data_structures_algorithms/images/tower_of_hanoi.gif" alt="Tower Of Hanoi" />  
<p>Tower of Hanoi puzzle with n disks can be solved in minimum <b>2<sup>n</sup>&minus;1</b> steps. This presentation shows that a puzzle with 3 disks has taken <b>2<sup>3</sup> - 1 = 7</b> steps.</p>
<h2>Algorithm</h2>
<p>To write an algorithm for Tower of Hanoi, first we need to learn how to solve this problem with lesser amount of disks, say &rarr; 1 or 2. We mark three towers with name, <b>source</b>, <b>destination</b> and <b>aux</b> (only to help moving the disks). If we have only one disk, then it can easily be moved from source to destination peg.</p>
<p>If we have 2 disks &minus;</p>
<ul class="list">
<li>First, we move the smaller (top) disk to aux peg.</li>   
<li>Then, we move the larger (bottom) disk to destination peg.</li>
<li>And finally, we move the smaller disk from aux to destination peg.</li>
</ul>
<img src="/data_structures_algorithms/images/tower_of_hanoi_two_disks.gif" alt="Tower Of Hanoi with Two Disks" />   
<p>So now, we are in a position to design an algorithm for Tower of Hanoi with more than two disks. We divide the stack of disks in two parts. The largest disk (n<sup>th</sup> disk) is in one part and all other (n-1) disks are in the second part.</p>
<p>Our ultimate aim is to move disk <b>n</b> from source to destination and then put all other (n1) disks onto it. We can imagine to apply the same in a recursive way for all given set of disks.</p>
<p>The steps to follow are &minus;</p>
<pre class="result notranslate">
<b>Step 1</b> &minus; Move n-1 disks from <code><b>source</b></code> to <code><b>aux</b></code>
<b>Step 2</b> &minus; Move n<sup>th</sup> disk from <code><b>source</b></code> to <code><b>dest</b></code>
<b>Step 3</b> &minus; Move n-1 disks from <code><b>aux</b></code> to <code><b>dest</b></code>
</pre>
<p>A recursive algorithm for Tower of Hanoi can be driven as follows &minus;</p>
<pre class="prettyprint notranslate">
START
Procedure Hanoi(disk, source, dest, aux)

   IF disk == 0, THEN
      move disk from source to dest             
   ELSE
      Hanoi(disk - 1, source, aux, dest)     // Step 1
      move disk from source to dest          // Step 2
      Hanoi(disk - 1, aux, dest, source)     // Step 3
   END IF
   
END Procedure
STOP
</pre>
<p>To check the implementation in C programming, <a href="/data_structures_algorithms/tower_of_hanoi_in_c.htm">click here</a>.</p>
<h1>Data Structure &amp; Algorithms Fibonacci Series</h1>
<p>Fibonacci series generates the subsequent number by adding two previous numbers. Fibonacci series starts from two numbers − <b>F<sub>0</sub> &amp; F<sub>1</sub></b>. The initial values of F<sub>0</sub> &amp; F<sub>1</sub> can be taken 0, 1 or 1, 1 respectively.</p>
<p>Fibonacci series satisfies the following conditions &minus;</p>
<pre class="result notranslate">
F<sub>n</sub> = F<sub>n-1</sub> + F<sub>n-2</sub>
</pre>
<p>Hence, a Fibonacci series can look like this &minus;</p>
<p>F<sub>8</sub> = 0 1 1 2 3 5 8 13</p>
<p>or, this &minus;</p>
<p>F<sub>8</sub> = 1 1 2 3 5 8 13 21</p>
<p>For illustration purpose, Fibonacci of F<sub>8</sub> is displayed as &minus;</p>
<img src="/data_structures_algorithms/images/fibonacci_animation.gif" alt="Fibonacci Animation" />
<h2>Fibonacci Iterative Algorithm</h2>
<p>First we try to draft the iterative algorithm for Fibonacci series.</p>
<pre class="prettyprint notranslate">
Procedure Fibonacci(n)
   declare f<sub>0</sub>, f<sub>1</sub>, fib, loop 
   
   set f<sub>0</sub> to 0
   set f<sub>1</sub> to 1
   
   <b>display f<sub>0</sub>, f<sub>1</sub></b>
   
   for loop &larr; 1 to n
   
      fib &larr; f<sub>0</sub> &plus; f<sub>1</sub>   
      f<sub>0</sub> &larr; f<sub>1</sub>
      f<sub>1</sub> &larr; fib

      <b>display fib</b>
   end for
	
end procedure
</pre>
<p>To know about the implementation of the above algorithm in C programming language, <a href="/data_structures_algorithms/fibonacci_iterative_program_in_c.htm">click here</a>.</p>
<h2>Fibonacci Recursive Algorithm</h2>
<p>Let us learn how to create a recursive algorithm Fibonacci series. The base criteria of recursion.</p>
<pre class="prettyprint notranslate">
START
Procedure Fibonacci(n)
   declare f<sub>0</sub>, f<sub>1</sub>, fib, loop 
   
   set f<sub>0</sub> to 0
   set f<sub>1</sub> to 1
   
   <b>display f<sub>0</sub>, f<sub>1</sub></b>
   
   for loop &larr; 1 to n
   
      fib &larr; f<sub>0</sub> &plus; f<sub>1</sub>   
      f<sub>0</sub> &larr; f<sub>1</sub>
      f<sub>1</sub> &larr; fib

      <b>display fib</b>
   end for

END
</pre>

<title>Data Structures and Algorithms Useful Resources</title>

<h1>Data Structure - Useful Resources</h1>

<p>The following resources contain additional information on Data Structures and Algorithms. Please use them to get more in-depth knowledge on this topic.</p>

<h2>Useful Links on Data Structures and Algorithms</h2>

<p><a target="_blank" rel="nofollow" href="https://en.wikipedia.org/wiki/Data_structures">Wiki Page for Data Structures</a> &minus; Check out data structures in a very generic way</p>

<p><a target="_blank" rel="nofollow" href="https://en.wikibooks.org/wiki/Data_structures">Data Structures</a> &minus; A very good article on Data Structures</p>

<p><a target="_blank" rel="nofollow" href="http://www.compileonline.com/compile_c_online.php">Compile and Execute C Online</a> &minus; High end server giving opportunity to compile and execute C progams online.</p>

<p><a target="_blank" rel="nofollow" href="https://www.eskimo.com/~scs/cclass/cclass.html">Notes on K&amp;R2</a> &minus; A great companion to K&amp;R2</p>

<p><a target="_blank" rel="nofollow" href="http://www.quut.com/c/">Programming in C</a> &minus; Literature, History and Culture of C Programming Language.</p>

<p><a href="https://www.tutorialspoint.com/gnu_debugger/index.htm">Learn GNU Debugger - GDB</a> &minus; A debugging tool to debug errors in C and C++ programs.</p>

<h2>Useful Books on Data Structures &amp; Algorithms</h2>

<p>To enlist your site on this page, please drop an email to <b>contact@tutorialspoint.com</b></p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Discuss Data Structures and Algorithms</title>

<h1>Discuss Data Structures &amp; Algorithms</h1>

<p>Data Structures are the programmatic way of storing data so that data can be used efficiently. Almost every enterprise application uses various types of data structures in one or the other way. This tutorial will give you a great understanding on Data Structures needed to understand the complexity of enterprise level applications and need of algorithms, and data structures.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

</body></html>