<!DOCTYPE html><html><body><title>Objective-C Tutorial</title>

<h1>Objective-C Tutorial</h1>

<p>Objective-C is a general-purpose, object-oriented programming language that adds Smalltalk-style messaging to the C programming language. This is the main programming language used by Apple for the OS X and iOS operating systems and their respective APIs, Cocoa and Cocoa Touch.</p>

<p>This reference will take you through simple and practical approach while learning Objective-C Programming language.</p>

<h1>Audience</h1>

<p>This reference has been prepared for the beginners to help them understand the basic to advanced concepts related to Objective-C Programming languages.</p>

<h1>Prerequisites</h1>

<p>Before you start doing practice with various types of examples given in this reference, I'm making an assumption that you are already aware about what is a computer program and what is a computer programming language?</p>

<h1>Compile/Execute Objective-C Programs</h1>

<p>For most of the examples given in this tutorial, you will find <b>Try it</b> option to compile and execute Objective-C programs online, so just make use of it and enjoy your learning.</p>

<p>Try the following example using <b>Try it</b> option available at the top right corner of the below sample code box &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Objective-C Overview</title>

<h1>Objective-C Overview</h1>

<p>Objective-C is general-purpose language that is developed on top of C Programming language by adding features of Small Talk programming language making it an object-oriented language. It is primarily used in developing iOS and Mac OS X operating systems as well as its applications.</p>

<p>Initially, Objective-C was developed by NeXT for its NeXTSTEP OS from whom it was taken over by Apple for its iOS and Mac OS X.</p>

<h2>Object-Oriented Programming</h2>

<p>Fully supports object-oriented programming, including the four pillars of object-oriented development:</p>

<p>Encapsulation</p>

<p>Data hiding</p>

<p>Inheritance</p>

<p>Polymorphism</p>

<h2>Example Code</h2>

<h2>Foundation Framework</h2>

<p>Foundation Framework provides large set of features and they are listed below.</p>

<p>It includes a list of extended datatypes like NSArray, NSDictionary, NSSet and so on. </p>

<p>It consists of a rich set of functions manipulating files, strings, etc.</p>

<p>It provides features for URL handling, utilities like date formatting, data handling, error handling, etc.</p>

<h2>Learning Objective-C</h2>

<p>The most important thing to do when learning Objective-C is to focus on concepts and not get lost in language technical details.</p>

<p>The purpose of learning a programming language is to become a better programmer; that is, to become more effective at designing and implementing new systems and at maintaining old ones.</p>

<h2>Use of Objective-C</h2>

<p>Objective-C, as mentioned earlier, is used in iOS and Mac OS X. It has large base of iOS users and largely increasing Mac OS X users. And since Apple focuses on quality first and its wonderful for those who started learning Objective-C. </p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

int main (int argc, const char * argv[])
{
   NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];

   NSLog (@"hello world");
   [pool drain];
   return 0;
}
</pre>

<title>Objective-C Environment Setup</title>

<h1>Objective-C Environment Setup</h1>

<h2>Try it Option Online</h2>

<p>You really do not need to set up your own environment to start learning Objective-C programming language. Reason is very simple, we already have set up Objective-C Programming environment online, so that you can compile and execute all the available examples online at the same time when you are doing your theory work. This gives you confidence in what you are reading and to check the result with different options. Feel free to modify any example and execute it online.</p>

<p>Try the following example using <b>Try it</b> option available at the top right corner of the below sample code box:</p>

<p>For most of the examples given in this tutorial, you will find <b>Try it</b> option, so just make use of it and enjoy your learning.</p>

<h2>Local Environment Setup</h2>

<p>If you are still willing to set up your environment for Objective-C programming language, you need the following two softwares available on your computer, (a) Text Editor and (b) The GCC Compiler.</p>

<h2>Text Editor</h2>

<p>This will be used to type your program. Examples of few editors include Windows Notepad, OS Edit command, Brief, Epsilon, EMACS, and vim or vi.</p>

<p>Name and version of text editor can vary on different operating systems. For example, Notepad will be used on Windows, and vim or vi can be used on windows as well as Linux or UNIX.</p>

<p>The files you create with your editor are called source files and contain program source code. The source files for Objective-C programs are typically named with the extension "<b>.m</b>".</p>

<p>Before starting your programming, make sure you have one text editor in place and you have enough experience to write a computer program, save it in a file, compile it and finally execute it.</p>

<h2>The GCC Compiler</h2>

<p>The source code written in source file is the human readable source for your program. It needs to be "compiled" to turn into machine language, so that your CPU can actually execute the program as per instructions given.</p>

<p>This GCC compiler will be used to compile your source code into final executable program. I assume you have basic knowledge about a programming language compiler.</p>

<p>GCC compiler is available for free on various platforms and the procedure to set up on various platforms is explained below.</p>

<h2>Installation on UNIX/Linux</h2>

<p>The initial step is install gcc along with gcc Objective-C package. This is done by:</p>

<p>The next step is to set up package dependencies using following command:</p>

<p>In order to get full features of Objective-C, download and install GNUStep. This can be done by downloading the package from <a href="http://wwwmain.gnustep.org/resources/downloads.php?site=ftp%3A%2F%2Fftp.gnustep.org%2Fpub%2Fgnustep%2F#core/" rel="nofollow" target="_blank">http://main.gnustep.org/resources/downloads.php</a>.</p>

<p>Now, we need to switch to the downloaded folder and unpack the file by:</p>

<p>Now, we need to switch to the folder gnustep-startup that gets created using:</p>

<p>Next, we need to configure the build process:</p>

<p>Then, we can build by:</p>

<p>We need to finally set up the environment by:</p>

<p>We have a helloWorld.m Objective-C as follows:</p>

<p>Now, we can compile and run a Objective-C file say helloWorld.m by switching to folder containing the file using cd and then using the following steps:</p>

<p>We can see the following output:</p>

<h2>Installation on Mac OS</h2>

<p>If you use Mac OS X, the easiest way to obtain GCC is to download the Xcode development environment from Apple's web site and follow the simple installation instructions. Once you have Xcode set up, you will be able to use GNU compiler for C/C++.</p>

<p>Xcode is currently available at <a href="http://developer.apple.com/technologies/tools/" rel="nofollow" target="_blank">developer.apple.com/technologies/tools/</a>.</p>

<h2>Installation on Windows</h2>

<p>In order to run Objective-C program on windows, we need to install MinGW and GNUStep Core. Both are available at <a href="http://www.gnu.org/software/gnustep/windows/installer.html" rel="nofollow" target="_blank">http://www.gnu.org/software/gnustep/windows/installer.html</a>.</p>

<p>First, we need to install the MSYS/MinGW System package. Then, we need to install the GNUstep Core package. Both of which provide a windows installer, which is self-explanatory.</p>

<p>Then to use Objective-C and GNUstep by selecting  Start -&gt; All Programs -&gt; GNUstep -&gt; Shell</p>

<p>Switch to the folder containing helloWorld.m</p>

<p>We can compile the program by using:</p>

<p>We can run the program by using:</p>

<p>We get the following output:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

int main()
{
   /* my first program in Objective-C */
   NSLog(@"Hello, World! \n");
   
   return 0;
}
</pre>
<p>For most of the examples given in this tutorial, you will find <b>Try it</b> option, so just make use of it and enjoy your learning.</p>
</blockquote>
<h2>Local Environment Setup</h2>
<p>If you are still willing to set up your environment for Objective-C programming language, you need the following two softwares available on your computer, (a) Text Editor and (b) The GCC Compiler.</p>
<h2>Text Editor</h2>
<p>This will be used to type your program. Examples of few editors include Windows Notepad, OS Edit command, Brief, Epsilon, EMACS, and vim or vi.</p>
<p>Name and version of text editor can vary on different operating systems. For example, Notepad will be used on Windows, and vim or vi can be used on windows as well as Linux or UNIX.</p>
<p>The files you create with your editor are called source files and contain program source code. The source files for Objective-C programs are typically named with the extension "<b>.m</b>".</p>
<p>Before starting your programming, make sure you have one text editor in place and you have enough experience to write a computer program, save it in a file, compile it and finally execute it.</p>
<h2>The GCC Compiler</h2>
<p>The source code written in source file is the human readable source for your program. It needs to be "compiled" to turn into machine language, so that your CPU can actually execute the program as per instructions given.</p>
<p>This GCC compiler will be used to compile your source code into final executable program. I assume you have basic knowledge about a programming language compiler.</p>
<p>GCC compiler is available for free on various platforms and the procedure to set up on various platforms is explained below.</p>
<h2>Installation on UNIX/Linux</h2>
<p>The initial step is install gcc along with gcc Objective-C package. This is done by:</p>
<pre class="prettyprint notranslate">
$ su - 
$ yum install gcc
$ yum install gcc-objc
</pre>
<p>The next step is to set up package dependencies using following command:</p>
<pre class="prettyprint notranslate">
$ yum install make libpng libpng-devel libtiff libtiff-devel libobjc libxml2 libxml2-devel libX11-devel libXt-devel libjpeg libjpeg-devel
</pre>
<p>In order to get full features of Objective-C, download and install GNUStep. This can be done by downloading the package from <a href="http://wwwmain.gnustep.org/resources/downloads.php?site=ftp%3A%2F%2Fftp.gnustep.org%2Fpub%2Fgnustep%2F#core/" rel="nofollow" target="_blank">http://main.gnustep.org/resources/downloads.php</a>.</p>
<p>Now, we need to switch to the downloaded folder and unpack the file by:</p>
<pre class="prettyprint notranslate">
$ tar xvfz gnustep-startup-<version>.tar.gz
</pre>
<p>Now, we need to switch to the folder gnustep-startup that gets created using:</p>
<pre class="prettyprint notranslate">
$ cd gnustep-startup-<version>
</pre>
<p>Next, we need to configure the build process:</p>
<pre class="prettyprint notranslate">
$ ./configure
</pre>
<p>Then, we can build by:</p>
<pre class="prettyprint notranslate">
$ make
</pre>
<p>We need to finally set up the environment by:</p>
<pre class="prettyprint notranslate">
$ . /usr/GNUstep/System/Library/Makefiles/GNUstep.sh
</pre>
<p>We have a helloWorld.m Objective-C as follows:</p>
<pre class="prettyprint notranslate">
#import &lt;Foundation/Foundation.h&gt;

int main (int argc, const char * argv[])
{
    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
    NSLog (@"hello world");
    [pool drain];
    return 0;
}
</pre>
<p>Now, we can compile and run a Objective-C file say helloWorld.m by switching to folder containing the file using cd and then using the following steps:</p>
<pre class="prettyprint notranslate">
$ gcc `gnustep-config --objc-flags` -L/usr/GNUstep/Local/Library/Libraries -lgnustep-base helloWorld.m -o helloWorld
$ ./helloWorld
</pre>
<p>We can see the following output:</p>
<pre class="prettyprint notranslate">
2013-09-07 10:48:39.772 tutorialsPoint[12906] hello world
</pre>
<h2>Installation on Mac OS</h2>
<p>If you use Mac OS X, the easiest way to obtain GCC is to download the Xcode development environment from Apple's web site and follow the simple installation instructions. Once you have Xcode set up, you will be able to use GNU compiler for C/C++.</p>
<p>Xcode is currently available at <a href="http://developer.apple.com/technologies/tools/" rel="nofollow" target="_blank">developer.apple.com/technologies/tools/</a>.</p>
<h2>Installation on Windows</h2>
<p>In order to run Objective-C program on windows, we need to install MinGW and GNUStep Core. Both are available at <a href="http://www.gnu.org/software/gnustep/windows/installer.html" rel="nofollow" target="_blank">http://www.gnu.org/software/gnustep/windows/installer.html</a>.</p>
<p>First, we need to install the MSYS/MinGW System package. Then, we need to install the GNUstep Core package. Both of which provide a windows installer, which is self-explanatory.</p>
<p>Then to use Objective-C and GNUstep by selecting  Start -&gt; All Programs -&gt; GNUstep -&gt; Shell</p>
<p>Switch to the folder containing helloWorld.m</p>
<p>We can compile the program by using:</p>
<pre class="prettyprint notranslate">
$ gcc `gnustep-config --objc-flags` -L /GNUstep/System/Library/Libraries hello.m -o hello -lgnustep-base -lobjc
</pre>
<p>We can run the program by using:</p>
<pre class="prettyprint notranslate">
./hello.exe
</pre>
<p>We get the following output:</p>
<pre class="prettyprint notranslate">
2013-09-07 10:48:39.772 tutorialsPoint[1200] hello world
</pre>

<title>Objective-C Program Structure</title>

<h1>Objective-C Program Structure</h1>

<p>Before we study basic building blocks of the Objective-C programming language, let us look a bare minimum Objective-C program structure so that we can take it as a reference in upcoming chapters.</p>

<h2>Objective-C Hello World Example</h2>

<p>A Objective-C program basically consists of the following parts:</p>

<p>Preprocessor Commands</p>

<p>Interface</p>

<p>Implementation</p>

<p>Method</p>

<p>Variables</p>

<p>Statements &amp; Expressions</p>

<p>Comments</p>

<p>Let us look at a simple code that would print the words "Hello World":</p>

<p>Let us look various parts of the above program:</p>

<p>The first line of the program <i>#import &lt;Foundation/Foundation.h&gt;</i> is a preprocessor command, which tells a Objective-C compiler to include Foundation.h file before going to actual compilation.</p>

<p>The next line <i>@interface SampleClass:NSObject</i> shows how to create an interface. It inherits NSObject, which is the base class of all objects.</p>

<p>The next line <i>- (void)sampleMethod;</i> shows how to declare a method.</p>

<p>The next line <i>@end</i> marks the end of an interface.</p>

<p>The next line <i>@implementation SampleClass</i> shows how to implement the interface SampleClass.</p>

<p>The next line <i>- (void)sampleMethod{}</i> shows the implementation of the sampleMethod.</p>

<p>The next line <i>@end</i> marks the end of an implementation.</p>

<p>The next line <i>int main()</i> is the main function where program execution begins.</p>

<p>The next line /*...*/ will be ignored by the compiler and it has been put to add additional comments in the program. So such lines are called comments in the program.</p>

<p>The next line <i>NSLog(...)</i> is another function available in Objective-C which causes the message "Hello, World!" to be displayed on the screen.</p>

<p>The next line <b>return 0;</b> terminates main()function and returns the value 0.</p>

<h2>Compile &amp; Execute Objective-C Program:</h2>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

@interface SampleClass:NSObject
- (void)sampleMethod;
@end

@implementation SampleClass

- (void)sampleMethod{
   NSLog(@"Hello, World! \n");
}

@end

int main()
{
   /* my first program in Objective-C */
   SampleClass *sampleClass = [[SampleClass alloc]init];
   [sampleClass sampleMethod];
   return 0;
}
</pre>
<p>Let us look various parts of the above program:</p>
<ol class="list">
<li><p>The first line of the program <i>#import &lt;Foundation/Foundation.h&gt;</i> is a preprocessor command, which tells a Objective-C compiler to include Foundation.h file before going to actual compilation.</p></li>
<li><p>The next line <i>@interface SampleClass:NSObject</i> shows how to create an interface. It inherits NSObject, which is the base class of all objects.</p></li>
<li><p>The next line <i>- (void)sampleMethod;</i> shows how to declare a method.</p></li>
<li><p>The next line <i>@end</i> marks the end of an interface.</p></li>

<li><p>The next line <i>@implementation SampleClass</i> shows how to implement the interface SampleClass.</p></li>
<li><p>The next line <i>- (void)sampleMethod{}</i> shows the implementation of the sampleMethod.</p></li>
<li><p>The next line <i>@end</i> marks the end of an implementation.</p></li>

<li><p>The next line <i>int main()</i> is the main function where program execution begins.</p></li>
<li><p>The next line /*...*/ will be ignored by the compiler and it has been put to add additional comments in the program. So such lines are called comments in the program.</p></li>
<li><p>The next line <i>NSLog(...)</i> is another function available in Objective-C which causes the message "Hello, World!" to be displayed on the screen.</p></li>
<li><p>The next line <b>return 0;</b> terminates main()function and returns the value 0.</p></li>
</ol>
<h2>Compile &amp; Execute Objective-C Program:</h2>
<p>Now when we compile and run the program, we will get the following result.</p
<pre class="prettyprint notranslate">
2013-09-07 22:38:27.932 demo[28001] Hello, World! 
</pre>

<title>Objective-C Basic Syntax</title>

<h1>Objective-C Basic Syntax</h1>

<p>You have seen a basic structure of Objective-C program, so it will be easy to understand other basic building blocks of the Objective-C programming language.</p>

<h2>Tokens  in Objective-C</h2>

<p>A Objective-C program consists of various tokens and a token is either a keyword, an identifier, a constant, a string literal, or a symbol. For example, the following Objective-C statement consists of six tokens:</p>

<p>The individual tokens are:</p>

<h2>Semicolons ;</h2>

<p>In Objective-C program, the semicolon is a statement terminator. That is, each individual statement must be ended with a semicolon. It indicates the end of one logical entity.</p>

<p>For example, following are two different statements:</p>

<h2>Comments</h2>

<p>Comments are like helping text in your Objective-C program and they are ignored by the compiler. They start with /* and terminate with the characters */ as shown below:</p>

<p>You can not have comments with in comments and they do not occur within a string or character literals.</p>

<h2>Identifiers</h2>

<p>An Objective-C identifier is a name used to identify a variable, function, or any other user-defined item. An identifier starts with a letter A to Z or a to z or an underscore _ followed by zero or more letters, underscores, and digits (0 to 9).</p>

<p>Objective-C does not allow punctuation characters such as @, $, and % within identifiers. Objective-C is a <b>case-sensitive</b> programming language. Thus, <i>Manpower</i> and <i>manpower</i> are two different identifiers in Objective-C. Here are some examples of acceptable identifiers:</p>

<h2>Keywords</h2>

<p>The following list shows few of the reserved words in Objective-C. These reserved words may not be used as constant or variable or any other identifier names.</p>

<h2>Whitespace in Objective-C</h2>

<p>A line containing only whitespace, possibly with a comment, is known as a blank line, and an Objective-C compiler totally ignores it.</p>

<p>Whitespace is the term used in Objective-C to describe blanks, tabs, newline characters and comments. Whitespace separates one part of a statement from another and enables the compiler to identify where one element in a statement, such as int, ends and the next element begins. Therefore, in the following statement:</p>

<p>There must be at least one whitespace character (usually a space) between int and age for the compiler to be able to distinguish them. On the other hand, in the following statement,</p>

<p>no whitespace characters are necessary between fruit and =, or between = and apples, although you are free to include some if you wish for readability purpose.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
NSLog(@"Hello, World! \n");
</pre>
<p>The individual tokens are:</p>
<pre class="prettyprint notranslate">
NSLog
@
(
"Hello, World! \n"
)
;
</pre>
<h2>Semicolons ;</h2>
<p>In Objective-C program, the semicolon is a statement terminator. That is, each individual statement must be ended with a semicolon. It indicates the end of one logical entity.</p>
<p>For example, following are two different statements:</p>
<pre class="prettyprint notranslate">
NSLog(@"Hello, World! \n");
return 0;
</pre>
<h2>Comments</h2>
<p>Comments are like helping text in your Objective-C program and they are ignored by the compiler. They start with /* and terminate with the characters */ as shown below:</p>
<pre class="prettyprint notranslate">
/* my first program in Objective-C */
</pre>
<p>You can not have comments with in comments and they do not occur within a string or character literals.</p>
<h2>Identifiers</h2>
<p>An Objective-C identifier is a name used to identify a variable, function, or any other user-defined item. An identifier starts with a letter A to Z or a to z or an underscore _ followed by zero or more letters, underscores, and digits (0 to 9).</p>
<p>Objective-C does not allow punctuation characters such as @, $, and % within identifiers. Objective-C is a <b>case-sensitive</b> programming language. Thus, <i>Manpower</i> and <i>manpower</i> are two different identifiers in Objective-C. Here are some examples of acceptable identifiers:</p>
<pre class="prettyprint notranslate">
mohd       zara    abc   move_name  a_123
myname50   _temp   j     a23b9      retVal
</pre>
<h2>Keywords</h2>
<p>The following list shows few of the reserved words in Objective-C. These reserved words may not be used as constant or variable or any other identifier names.</p>
<table class="table table-bordered">
<tr>
<td style="width:25%">auto</td>
<td style="width:25%">else</td>
<td style="width:25%">long</td>
<td style="width:25%">switch</td>
</tr>
<tr>
<td>break</td>
<td>enum</td>
<td>register</td>
<td>typedef</td>
</tr>
<tr>
<td>case</td>
<td>extern</td>
<td>return</td>
<td>union</td>
</tr>
<tr>
<td>char</td>
<td>float</td>
<td>short</td>
<td>unsigned</td>
</tr>
<tr>
<td>const</td>
<td>for</td>
<td>signed</td>
<td>void</td>
</tr>
<tr>
<td>continue</td>
<td>goto</td>
<td>sizeof</td>
<td>volatile</td>
</tr>
<tr>
<td>default</td>
<td>if</td>
<td>static</td>
<td>while</td>
</tr>
<tr>
<td>do</td>
<td>int</td>
<td>struct</td>
<td>_Packed</td>
</tr>
<tr>
<td>double</td>
<td>protocol</td>
<td>interface</td>
<td>implementation</td>
</tr>
<tr>
<td>NSObject</td>
<td>NSInteger</td>
<td>NSNumber</td>
<td>CGFloat</td>
</tr>
<tr>
<td>property</td>
<td>nonatomic;</td>
<td>retain</td>
<td>strong</td>
</tr>
<tr>
<td>weak</td>
<td>unsafe_unretained;</td>
<td>readwrite</td>
<td>readonly</td>
</tr>
</table>
<h2>Whitespace in Objective-C</h2>
<p>A line containing only whitespace, possibly with a comment, is known as a blank line, and an Objective-C compiler totally ignores it.</p>
<p>Whitespace is the term used in Objective-C to describe blanks, tabs, newline characters and comments. Whitespace separates one part of a statement from another and enables the compiler to identify where one element in a statement, such as int, ends and the next element begins. Therefore, in the following statement:</p>
<pre class="prettyprint notranslate">
int age;
</pre>
<p>There must be at least one whitespace character (usually a space) between int and age for the compiler to be able to distinguish them. On the other hand, in the following statement,</p>
<pre class="prettyprint notranslate">
fruit = apples + oranges;   // get the total fruit
</pre>

<title>Objective-C Data Types</title>

<h1>Objective-C Data Types</h1>

<p>In the Objective-C programming language, data types refer to an extensive system used for declaring variables or functions of different types. The type of a variable determines how much space it occupies in storage and how the bit pattern stored is interpreted.</p>

<p>The types in Objective-C can be classified as follows:</p>

<p>They are arithmetic types and consist of the two types: (a) integer types and (b) floating-point types.</p>

<p>They are again arithmetic types and they are used to define variables that can only be assigned certain discrete integer values throughout the program.</p>

<p>The type specifier <i>void</i> indicates that no value is available.</p>

<p>They include (a) Pointer types, (b) Array types, (c) Structure types, (d) Union types and (e) Function types.</p>

<p>The array types and structure types are referred to collectively as the aggregate types. The type of a function specifies the type of the function's return value. We will see basic types in the following section whereas other types will be covered in the upcoming chapters.</p>

<h2>Integer Types</h2>

<p>Following table gives you details about standard integer types with its storage sizes and value ranges:</p>

<p>To get the exact size of a type or a variable on a particular platform, you can use the <b>sizeof</b> operator. The expression <i>sizeof(type)</i> yields the storage size of the object or type in bytes. Following is an example to get the size of int type on any machine:</p>

<p>When you compile and execute the above program, it produces the following result on Linux:</p>

<h2>Floating-Point Types</h2>

<p>Following table gives you details about standard float-point types with storage sizes and value ranges and their precision:</p>

<p>The header file float.h defines macros that allow you to use these values and other details about the binary representation of real numbers in your programs. Following example will print storage space taken by a float type and its range values:</p>

<p>When you compile and execute the above program, it produces the following result on Linux:</p>

<h2>The void Type</h2>

<p>The void type specifies that no value is available. It is used in three kinds of situations:</p>

<p>There are various functions in Objective-C which do not return value  or you can say they return void. A function with no return value has the return type as void. For example, <b>void exit (int status);</b></p>

<p>There are various functions in Objective-C which do not accept any parameter. A function with no parameter can accept as a void. For example, <b>int rand(void);</b></p>

<p>The void type may not be understood to you at this point, so let us proceed and we will cover  these concepts in upcoming chapters.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

int main()
{
   NSLog(@"Storage size for int : %d \n", sizeof(int));
   
   return 0;
}
</pre>
<p>When you compile and execute the above program, it produces the following result on Linux:</p>
<pre class="prettyprint notranslate">
2013-09-07 22:21:39.155 demo[1340] Storage size for int : 4 
</pre>
<h2>Floating-Point Types</h2>
<p>Following table gives you details about standard float-point types with storage sizes and value ranges and their precision:</p>
<table class="table table-bordered">
<tr>
<th>Type</th>
<th>Storage size</th>
<th>Value range</th>
<th>Precision</th>
</tr>
<tr>
<td>float</td>
<td>4 byte</td>
<td>1.2E-38 to 3.4E+38</td>
<td>6 decimal places</td>
</tr>
<tr>
<td>double</td>
<td>8 byte</td>
<td>2.3E-308 to 1.7E+308</td>
<td>15 decimal places</td>
</tr>
<tr>
<td>long double</td>
<td>10 byte</td>
<td>3.4E-4932 to 1.1E+4932</td>
<td>19 decimal places</td>
</tr>
</table>
<p>The header file float.h defines macros that allow you to use these values and other details about the binary representation of real numbers in your programs. Following example will print storage space taken by a float type and its range values:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

int main()
{
   NSLog(@"Storage size for float : %d \n", sizeof(float));
   
   return 0;
}
</pre>
<p>When you compile and execute the above program, it produces the following result on Linux:</p>
<pre class="prettyprint notranslate">
2013-09-07 22:22:21.729 demo[3927] Storage size for float : 4 
</pre>

<title>Objective-C Variables</title>

<h1>Objective-C Variables</h1>

<p>A variable is nothing but a name given to a storage area that our programs can manipulate. Each variable in Objective-C has a specific type, which determines the size and layout of the variable's memory; the range of values that can be stored within that memory; and the set of operations that can be applied to the variable.</p>

<p>The name of a variable can be composed of letters, digits, and the underscore character. It must begin with either a letter or an underscore. Upper and lowercase letters are distinct because Objective-C is case-sensitive. Based on the basic types explained in previous chapter, there will be the following basic variable types:</p>

<p>Objective-C programming language also allows to define various other types of variables, which we will cover in subsequent chapters like Enumeration, Pointer, Array, Structure, Union, etc. For this chapter, let us study only basic variable types.</p>

<h2>Variable Definition in Objective-C:</h2>

<p>A variable definition means to tell the compiler where and how much to create the storage for the variable. A variable definition specifies a data type and contains a list of one or more variables of that type as follows:</p>

<p>Here, <b>type</b> must be a valid Objective-C data type including char, w_char, int, float, double, bool or any user-defined object, etc., and <b>variable_list</b> may consist of one or more identifier names separated by commas. Some valid declarations are shown here:</p>

<p>The line <b>int    i, j, k;</b> both declares and defines the variables i, j and k;  which instructs the compiler to create variables named i, j and k of type int.</p>

<p>Variables can be initialized (assigned an initial value) in their declaration. The initializer consists of an equal sign followed by a constant expression as follows:</p>

<p>Some examples are:</p>

<p>For definition without an initializer: variables with static storage duration are implicitly initialized with NULL (all bytes have the value 0); the initial value of all other variables is undefined.</p>

<h2>Variable Declaration in Objective-C:</h2>

<p>A variable declaration provides assurance to the compiler that there is one variable existing with the given type and name so that compiler proceed for further compilation without needing complete detail about the variable. A variable declaration has its meaning at the time of compilation only, compiler needs actual variable declaration at the time of linking of the program.</p>

<p>A variable declaration is useful when you are using multiple files and you define your variable in one of the files, which will be available at the time of linking of the program. You will use <b>extern</b> keyword to declare a variable at any place. Though you can declare a variable multiple times in your Objective-C program but it can be defined only once in a file, a function or a block of code.</p>

<h2>Example</h2>

<p>Try the following example, where variables have been declared at the top, but they have been defined and initialized inside the main function:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>Same concept applies on function declaration where you provide a function name at the time of its declaration and its actual definition can be given anywhere else. In the following example, it's explained using C function and as you know Objective-C supports C style functions also:</p>

<h2>Lvalues and Rvalues in Objective-C:</h2>

<p>There are two kinds of expressions in Objective-C:</p>

<p><b>lvalue :</b> Expressions that refer to a memory location is  called "lvalue" expression. An lvalue may appear as either the left-hand or right-hand side of an assignment.</p>

<p><b>rvalue :</b> The term rvalue refers to a data value that is stored at some address in memory. An rvalue is an expression that cannot have a value assigned to it which means an rvalue may appear on the right- but not left-hand side of an assignment.</p>

<p>Variables are lvalues and so may appear on the left-hand side of an assignment. Numeric literals are rvalues and so may not be assigned and can not appear on the left-hand side. Following is a valid statement:</p>

<p>But following is not a valid statement and would generate compile-time error:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
type variable_list;
</pre>
<p>Here, <b>type</b> must be a valid Objective-C data type including char, w_char, int, float, double, bool or any user-defined object, etc., and <b>variable_list</b> may consist of one or more identifier names separated by commas. Some valid declarations are shown here:</p>
<pre class="prettyprint notranslate">
int    i, j, k;
char   c, ch;
float  f, salary;
double d;
</pre>
<p>The line <b>int    i, j, k;</b> both declares and defines the variables i, j and k;  which instructs the compiler to create variables named i, j and k of type int.</p>
<p>Variables can be initialized (assigned an initial value) in their declaration. The initializer consists of an equal sign followed by a constant expression as follows:</p>
<pre class="prettyprint notranslate">
type variable_name = value;
</pre>
<p>Some examples are:</p>
<pre class="prettyprint notranslate">
extern int d = 3, f = 5;    // declaration of d and f. 
int d = 3, f = 5;           // definition and initializing d and f. 
byte z = 22;                // definition and initializes z. 
char x = 'x';               // the variable x has the value 'x'.
</pre>
<p>For definition without an initializer: variables with static storage duration are implicitly initialized with NULL (all bytes have the value 0); the initial value of all other variables is undefined.</p>
<h2>Variable Declaration in Objective-C:</h2>
<p>A variable declaration provides assurance to the compiler that there is one variable existing with the given type and name so that compiler proceed for further compilation without needing complete detail about the variable. A variable declaration has its meaning at the time of compilation only, compiler needs actual variable declaration at the time of linking of the program.</p>
<p>A variable declaration is useful when you are using multiple files and you define your variable in one of the files, which will be available at the time of linking of the program. You will use <b>extern</b> keyword to declare a variable at any place. Though you can declare a variable multiple times in your Objective-C program but it can be defined only once in a file, a function or a block of code.</p>
<h2>Example</h2>
<p>Try the following example, where variables have been declared at the top, but they have been defined and initialized inside the main function:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

// Variable declaration:
extern int a, b;
extern int c;
extern float f;

int main ()
{
  /* variable definition: */
  int a, b;
  int c;
  float f;
 
  /* actual initialization */
  a = 10;
  b = 20;
  
  c = a + b;
  NSLog(@"value of c : %d \n", c);

  f = 70.0/3.0;
  NSLog(@"value of f : %f \n", f);
 
  return 0;
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
2013-09-07 22:43:31.695 demo[14019] value of c : 30 
2013-09-07 22:43:31.695 demo[14019] value of f : 23.333334 
</pre>
<p>Same concept applies on function declaration where you provide a function name at the time of its declaration and its actual definition can be given anywhere else. In the following example, it's explained using C function and as you know Objective-C supports C style functions also:</p>
<pre class="prettyprint notranslate">
// function declaration
int func();

int main()
{
    // function call
    int i = func();
}

// function definition
int func()
{
    return 0;
}
</pre>
<h2>Lvalues and Rvalues in Objective-C:</h2>
<p>There are two kinds of expressions in Objective-C:</p>
<ol class="list">
<li><p><b>lvalue :</b> Expressions that refer to a memory location is  called "lvalue" expression. An lvalue may appear as either the left-hand or right-hand side of an assignment.</p></li>
<li><p><b>rvalue :</b> The term rvalue refers to a data value that is stored at some address in memory. An rvalue is an expression that cannot have a value assigned to it which means an rvalue may appear on the right- but not left-hand side of an assignment.</p></li>
</ol>
<p>Variables are lvalues and so may appear on the left-hand side of an assignment. Numeric literals are rvalues and so may not be assigned and can not appear on the left-hand side. Following is a valid statement:</p>
<pre class="prettyprint notranslate">
int g = 20;
</pre>
<p>But following is not a valid statement and would generate compile-time error:</p>
<pre class="prettyprint notranslate">
10 = 20;
</pre>

<title>Objective-C Constants</title>

<h1>Objective-C Constants</h1>

<p>The constants refer to fixed values that the program may not alter during its execution. These fixed values are also called <b>literals</b>.</p>

<p>Constants can be of any of the basic data types like <i>an integer constant, a floating constant, a character constant, or a string literal</i>. There are also enumeration constants as well.</p>

<p>The <b>constants</b> are treated just like regular variables except that their values cannot be modified after their definition.</p>

<h2>Integer literals</h2>

<p>An integer literal can be a decimal, octal, or hexadecimal constant. A prefix specifies the base or radix: 0x or 0X for hexadecimal, 0 for octal, and nothing for decimal.</p>

<p>An integer literal can also have a suffix that is a combination of U and L, for unsigned and long, respectively. The suffix can be uppercase or lowercase and can be in any order.</p>

<p>Here are some examples of integer literals:</p>

<p>Following are other examples of various types of Integer literals:</p>

<h2>Floating-point literals</h2>

<p>A floating-point literal has an integer part, a decimal point, a fractional part, and an exponent part. You can represent floating point literals either in decimal form or exponential form.</p>

<p>While representing using decimal form, you must include the decimal point, the exponent, or both and while representing using exponential form, you must include the integer part, the fractional part, or both. The signed exponent is introduced by e or E.</p>

<p>Here are some examples of floating-point literals:</p>

<h2>Character constants</h2>

<p>Character literals are enclosed in single quotes e.g., 'x' and can be stored in a simple variable of <b>char</b> type.</p>

<p>A character literal can be a plain character (e.g., 'x'), an escape sequence (e.g., '\t'), or a universal character (e.g., '\u02C0'). </p>

<p>There are certain characters in C when they are proceeded by a backslash they will have special meaning and they are used to represent like newline (\n) or tab (\t). Here, you have a list of some of such escape sequence codes:</p>

<p>Following is the example to show few escape sequence characters:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>String literals</h2>

<p>String literals or constants are enclosed in double quotes "". A string contains characters that are similar to character literals: plain characters, escape sequences, and universal characters.</p>

<p>You can break a long line into multiple lines using string literals and separating them using whitespaces.</p>

<p>Here are some examples of string literals. All the three forms are identical strings.</p>

<h2>Defining Constants</h2>

<p>There are two simple ways in C to define constants:</p>

<p>Using <b>#define</b> preprocessor.</p>

<p>Using <b>const</b> keyword.</p>

<h2>The #define Preprocessor</h2>

<p>Following is the form to use #define preprocessor to define a constant:</p>

<p>Following example explains it in detail:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>The const Keyword</h2>

<p>You can use <b>const</b> prefix to declare constants with a specific type as follows:</p>

<p>Following example explains it in detail:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>Note that it is a good programming practice to define constants in CAPITALS.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
212         /* Legal */
215u        /* Legal */
0xFeeL      /* Legal */
078         /* Illegal: 8 is not an octal digit */
032UU       /* Illegal: cannot repeat a suffix */
</pre>
<p>Following are other examples of various types of Integer literals:</p>
<pre class="prettyprint notranslate">
85         /* decimal */
0213       /* octal */
0x4b       /* hexadecimal */
30         /* int */
30u        /* unsigned int */
30l        /* long */
30ul       /* unsigned long */
</pre>
<h2>Floating-point literals</h2>
<p>A floating-point literal has an integer part, a decimal point, a fractional part, and an exponent part. You can represent floating point literals either in decimal form or exponential form.</p>
<p>While representing using decimal form, you must include the decimal point, the exponent, or both and while representing using exponential form, you must include the integer part, the fractional part, or both. The signed exponent is introduced by e or E.</p>
<p>Here are some examples of floating-point literals:</p>
<pre class="prettyprint notranslate">
3.14159       /* Legal */
314159E-5L    /* Legal */
510E          /* Illegal: incomplete exponent */
210f          /* Illegal: no decimal or exponent */
.e55          /* Illegal: missing integer or fraction */
</pre>
<h2>Character constants</h2>
<p>Character literals are enclosed in single quotes e.g., 'x' and can be stored in a simple variable of <b>char</b> type.</p>
<p>A character literal can be a plain character (e.g., 'x'), an escape sequence (e.g., '\t'), or a universal character (e.g., '\u02C0'). </p>
<p>There are certain characters in C when they are proceeded by a backslash they will have special meaning and they are used to represent like newline (\n) or tab (\t). Here, you have a list of some of such escape sequence codes:</p>
<table class="table table-bordered">
<tr><th style="width:20%">Escape sequence</th>
<th>Meaning</th>
</tr>
<tr><td>\\</td><td>\ character</td></tr>
<tr><td>\'</td><td> ' character</td></tr>
<tr><td>\"</td><td>" character</td></tr>
<tr><td>\?</td><td>? character</td></tr>
<tr><td>\a</td><td>Alert or bell</td></tr>
<tr><td>\b</td><td>Backspace</td></tr>
<tr><td>\f</td><td>Form feed</td></tr>
<tr><td>\n</td><td>Newline</td></tr>
<tr><td>\r</td><td>Carriage return</td></tr>
<tr><td>\t</td><td>Horizontal tab</td></tr>
<tr><td>\v</td><td>Vertical tab</td></tr>
<tr><td>\ooo</td><td>Octal number of one to three digits</td></tr>
<tr><td>\xhh . . .</td><td>Hexadecimal number of one or more digits</td></tr>
</table>
<p>Following is the example to show few escape sequence characters:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

int main()
{
   NSLog(@"Hello\tWorld\n\n");

   return 0;
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
2013-09-07 22:17:17.923 demo[17871] Hello	World

</pre>
<h2>String literals</h2>
<p>String literals or constants are enclosed in double quotes "". A string contains characters that are similar to character literals: plain characters, escape sequences, and universal characters.</p>
<p>You can break a long line into multiple lines using string literals and separating them using whitespaces.</p>
<p>Here are some examples of string literals. All the three forms are identical strings.</p>
<pre class="prettyprint notranslate">
"hello, dear"

"hello, \

dear"

"hello, " "d" "ear"
</pre>
<h2>Defining Constants</h2>
<p>There are two simple ways in C to define constants:</p>
<ol class="list">
<li><p>Using <b>#define</b> preprocessor.</p></li>
<li><p>Using <b>const</b> keyword.</p></li>
</ol>
<h2>The #define Preprocessor</h2>
<p>Following is the form to use #define preprocessor to define a constant:</p>
<pre class="prettyprint notranslate">
#define identifier value
</pre>
<p>Following example explains it in detail:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

#define LENGTH 10   
#define WIDTH  5
#define NEWLINE '\n'

int main()
{

   int area;  
  
   area = LENGTH * WIDTH;
   NSLog(@"value of area : %d", area);
   NSLog(@"%c", NEWLINE);

   return 0;
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
2013-09-07 22:18:16.637 demo[21460] value of area : 50
2013-09-07 22:18:16.638 demo[21460] 
</pre>
<h2>The const Keyword</h2>
<p>You can use <b>const</b> prefix to declare constants with a specific type as follows:</p>
<pre class="prettyprint notranslate">
const type variable = value;
</pre>
<p>Following example explains it in detail:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

int main()
{
   const int  LENGTH = 10;
   const int  WIDTH  = 5;
   const char NEWLINE = '\n';
   int area;  
   
   area = LENGTH * WIDTH;
   NSLog(@"value of area : %d", area);
   NSLog(@"%c", NEWLINE);

   return 0;
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
2013-09-07 22:19:24.780 demo[25621] value of area : 50
2013-09-07 22:19:24.781 demo[25621] 
</pre>

<title>Objective-C Operators</title>

<h1>Objective-C Operators</h1>

<p>An operator is a symbol that tells the compiler to perform specific mathematical or logical manipulations. Objective-C language is rich in built-in operators and provides following types of operators:</p>

<p>Arithmetic Operators</p>

<p>Relational Operators</p>

<p>Logical Operators</p>

<p>Bitwise Operators</p>

<p>Assignment Operators</p>

<p>Misc Operators</p>

<p>This tutorial will explain the arithmetic, relational, logical, bitwise, assignment and other operators one by one.</p>

<h2>Arithmetic Operators</h2>

<p>Following table shows all the arithmetic operators supported by Objective-C language. Assume variable <b>A</b> holds 10 and variable <b>B</b> holds 20, then:</p>

<p><a href="/objective_c/objective_c_arithmetic_operators.htm" title="Arithmetic Operators in Objective-C">Show Examples</a></p>

<h2>Relational Operators</h2>

<p>Following table shows all the relational operators supported by Objective-C language. Assume variable <b>A</b> holds 10 and variable <b>B</b> holds 20, then:</p>

<p><a href="/objective_c/objective_c_relational_operators.htm" title="Relational Operators in Objective-C">Show Examples</a></p>

<h2>Logical Operators</h2>

<p>Following table shows all the logical operators supported by Objective-C language. Assume variable <b>A</b> holds 1 and variable <b>B</b> holds 0, then:</p>

<p><a href="/objective_c/objective_c_logical_operators.htm" title="Logical Operators in Objective-C">Show Examples</a></p>

<h2>Bitwise Operators</h2>

<p>Bitwise operator works on bits and perform bit by bit operation. The truth tables for &amp;, |, and ^ are as follows:</p>

<p>Assume if A = 60; and B = 13; now in binary format they will be as follows:</p>

<p>A = 0011 1100</p>

<p>B = 0000 1101</p>

<p>-----------------</p>

<p>A&amp;B = 0000 1100</p>

<p>A|B = 0011 1101</p>

<p>A^B = 0011 0001</p>

<p>~A&nbsp; = 1100 0011</p>

<p>The Bitwise operators supported by Objective-C language are listed in the following table. Assume variable A holds 60 and variable B holds 13 then:</p>

<p><a href="/objective_c/objective_c_bitwise_operators.htm" title="Bitwise Operators in Objective-C">Show Examples</a></p>

<h2>Assignment Operators</h2>

<p>There are following assignment operators supported by Objective-C language:</p>

<p><a href="/objective_c/objective_c_assignment_operators.htm" title="Assignment Operators in Objective-C">Show Examples</a></p>

<h2> Misc Operators &map; sizeof &amp; ternary</h2>

<p>There are few other important operators including <b>sizeof</b> and <b>? :</b>  supported by Objective-C Language.</p>

<p><a href="/objective_c/objective_c_sizeof_operator.htm" title="sizeof operator in C">Show Examples</a></p>

<h2>Operators Precedence in Objective-C</h2>

<p>Operator precedence determines the grouping of terms in an expression. This affects how an expression is evaluated. Certain operators have higher precedence than others; for example, the multiplication operator has higher precedence than the addition operator:</p>

<p>For example, x = 7 + 3 * 2; here, x is assigned 13, not 20 because operator * has higher precedence than +, so it first gets multiplied with 3*2 and then adds into 7.</p>

<p>Here, operators with the highest precedence appear at the top of the table, those with the lowest appear at the bottom. Within an expression, higher precedence operators will be evaluated first.</p>

<p><a href="/objective_c/objective_c_operators_precedence.htm" title="Operators Precedence in Objective-C">Show Examples</a></p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Objective-C Loops</title>

<h1>Objective-C Loops</h1>

<p>There may be a situation, when you need to execute a block of code several number of times. In general, statements are executed sequentially: The first statement in a function is executed first, followed by the second, and so on.</p>

<p>Programming languages provide various control structures that allow for more complicated execution paths.</p>

<p>A loop statement allows us to execute a statement or group of statements multiple times and following is the general form of a loop statement in most of the programming languages:</p>

<p>Objective-C programming language provides the following types of loop to handle looping requirements. Click the following links to check their details.</p>

<h2>Loop Control Statements:</h2>

<p>Loop control statements change execution from its normal sequence. When execution leaves a scope, all automatic objects that were created in that scope are destroyed.</p>

<p>Objective-C supports the following control statements. Click the following links to check their details.</p>

<h2>The Infinite Loop:</h2>

<p>A loop becomes infinite loop if a condition never becomes false. The <b>for</b> loop is traditionally used for this purpose. Since none of the three expressions that form the for loop are required, you can make an endless loop by leaving the conditional expression empty.</p>

<p>When the conditional expression is absent, it is assumed to be true. You may have an initialization and increment expression, but Objective-C programmers more commonly use the for(;;) construct to signify an infinite loop.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
#import &lt;Foundation/Foundation.h&gt;
 
int main ()
{

   for( ; ; )
   {
      NSLog(@"This loop will run forever.\n");
   }

   return 0;
}
</pre>

<title>Objective-C Decision Making</title>

<h1>Objective-C Decision Making</h1>

<p>Decision making structures require that the programmer specify one or more conditions to be evaluated or tested by the program, along with a statement or statements to be executed if the condition is determined to be true, and optionally, other statements to be executed if the condition is determined to be false.</p>

<p>Following is the general form of a typical decision making structure found in most of the programming languages:</p>

<p>Objective-C programming language assumes any <b>non-zero</b> and <b>non-null</b> values as <b>true</b>, and if it is either <b>zero</b> or <b>null</b>, then it is assumed as <b>false</b> value.</p>

<p>Objective-C programming language provides following types of decision making statements. Click the following links to check their details:</p>

<h2>The ? : Operator:</h2>

<p>We have covered <b>conditional operator ? :</b> in previous chapter which can be used to replace <b>if...else</b> statements. It has the following general form:</p>

<p>Where Exp1, Exp2, and Exp3 are expressions. Notice the use and placement of the colon.</p>

<p>The value of a ? expression is determined like this: Exp1 is evaluated. If it is true, then Exp2 is evaluated and becomes the value of the entire ? expression. If Exp1 is false, then Exp3 is evaluated and its value becomes the value of the expression.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
Exp1 ? Exp2 : Exp3;
</pre>

<title>Objective-C Functions</title>

<h1>Objective-C Functions</h1>

<p>A function is a group of statements that together perform a task. Every Objective-C program has one C function, which is <b>main()</b>, and all of the most trivial programs can define additional functions.</p>

<p>You can divide up your code into separate functions. How you divide up your code among different functions is up to you, but logically the division usually is so each function performs a specific task.</p>

<p>A function <b>declaration</b> tells the compiler about a function's name, return type, and parameters. A function <b>definition</b> provides the actual body of the function.</p>

<p>Basically in Objective-C, we call the function as method.</p>

<p>The Objective-C foundation framework provides numerous built-in methods that your program can call. For example, method <b>appendString()</b> to append string to another string.</p>

<p>A method is known with various names like a function  or a sub-routine or a procedure, etc.</p>

<h2>Defining a Method</h2>

<p>The general form of a method definition in Objective-C programming language is as follows:</p>

<p>A method definition in Objective-C programming language consists of a <i>method header</i> and a <i>method body</i>. Here are all the parts of a method:</p>

<p><b>Return Type:</b> A method may return a value. The <b>return_type</b> is the data type of the value the function returns. Some methods perform the desired operations without returning a value. In this case, the return_type is the keyword <b>void</b>.</p>

<p><b>Method Name:</b> This is the actual name of the method. The method name and the parameter list together constitute the method signature.</p>

<p><b>Arguments:</b> A argument is like a placeholder. When a function is invoked, you pass a value to the argument. This value is referred to as actual parameter or argument. The parameter list refers to the type, order, and number of the arguments of a method. Arguments are optional; that is, a method may contain no argument.</p>

<p><b>Joining Argument:</b> A joining argument is to make it easier to read and to make it clear while calling it.</p>

<p><b>Method Body:</b> The method body contains a collection of statements that define what the method does.</p>

<h2>Example:</h2>

<p>Following is the source code for a method called <b>max()</b>. This method takes two parameters num1 and num2 and returns the maximum between the two:</p>

<h2>Method Declarations:</h2>

<p>A method <b>declaration</b> tells the compiler about a function name and how to call the method. The actual body of the function can be defined separately.</p>

<p>A method declaration has the following parts:</p>

<p>For the above-defined function max(), following is the method declaration:</p>

<p>Method declaration is required when you define a method in one source file and you call that method in another file. In such case you should declare the function at the top of the file calling the function.</p>

<h2>Calling a method:</h2>

<p>While creating a Objective-C method, you give a definition of what the function has to do. To use a method, you will have to call that function to perform the defined task.</p>

<p>When a program calls a function, program control is transferred to the called method. A called method performs defined task, and when its return statement is executed or when its function-ending closing brace is reached, it returns program control back to the main program.</p>

<p>To call a method, you simply need to pass the required parameters along with method name, and if method returns a value, then you can store returned value. For example:</p>

<p>I kept max() function along with main() function and complied the source code. While running final executable, it would produce the following result:</p>

<h2>Function Arguments:</h2>

<p>If a function is to use arguments, it must declare variables that accept the values of the arguments. These variables are called the <b>formal parameters</b> of the function.</p>

<p>The formal parameters behave like other local variables inside the function and are created upon entry into the function and destroyed upon exit.</p>

<p>While calling a function, there are two ways that arguments can be passed to a function:</p>

<p>By default, Objective-C uses <b>call by value</b> to pass arguments. In general, this means that code within a function cannot alter the arguments used to call the function, and above-mentioned example while calling max() function used the same method.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
- (return_type) method_name:( argumentType1 )argumentName1 
joiningArgument2:( argumentType2 )argumentName2 ... 
joiningArgumentn:( argumentTypen )argumentNamen 
{
   body of the function
}
</pre>
<p>A method definition in Objective-C programming language consists of a <i>method header</i> and a <i>method body</i>. Here are all the parts of a method:</p>
<ul class="list">
<li><p><b>Return Type:</b> A method may return a value. The <b>return_type</b> is the data type of the value the function returns. Some methods perform the desired operations without returning a value. In this case, the return_type is the keyword <b>void</b>.</p></li>
<li><p><b>Method Name:</b> This is the actual name of the method. The method name and the parameter list together constitute the method signature.</p></li>
<li><p><b>Arguments:</b> A argument is like a placeholder. When a function is invoked, you pass a value to the argument. This value is referred to as actual parameter or argument. The parameter list refers to the type, order, and number of the arguments of a method. Arguments are optional; that is, a method may contain no argument.</p></li>
<li><p><b>Joining Argument:</b> A joining argument is to make it easier to read and to make it clear while calling it.</p></li>
<li><p><b>Method Body:</b> The method body contains a collection of statements that define what the method does.</p></li>
</ul>
<h2>Example:</h2>
<p>Following is the source code for a method called <b>max()</b>. This method takes two parameters num1 and num2 and returns the maximum between the two:</p>
<pre class="prettyprint notranslate">
/* function returning the max between two numbers */
- (int) max:(int) num1 secondNumber:(int) num2 
{
   /* local variable declaration */
   int result;
 
   if (num1 &gt; num2)
   {
      result = num1;
   }
   else
   {
      result = num2;
   }
 
   return result; 
}
</pre>
<h2>Method Declarations:</h2>
<p>A method <b>declaration</b> tells the compiler about a function name and how to call the method. The actual body of the function can be defined separately.</p>
<p>A method declaration has the following parts:</p>
<pre class="prettyprint notranslate">
- (return_type) function_name:( argumentType1 )argumentName1 
joiningArgument2:( argumentType2 )argumentName2 ... 
joiningArgumentn:( argumentTypen )argumentNamen;
</pre>
<p>For the above-defined function max(), following is the method declaration:</p>
<pre class="prettyprint notranslate">
-(int) max:(int)num1 andNum2:(int)num2;
</pre>

<p>Method declaration is required when you define a method in one source file and you call that method in another file. In such case you should declare the function at the top of the file calling the function.</p>
<h2>Calling a method:</h2>
<p>While creating a Objective-C method, you give a definition of what the function has to do. To use a method, you will have to call that function to perform the defined task.</p>
<p>When a program calls a function, program control is transferred to the called method. A called method performs defined task, and when its return statement is executed or when its function-ending closing brace is reached, it returns program control back to the main program.</p>
<p>To call a method, you simply need to pass the required parameters along with method name, and if method returns a value, then you can store returned value. For example:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

@interface SampleClass:NSObject
/* method declaration */
- (int)max:(int)num1 andNum2:(int)num2;
@end

@implementation SampleClass

/* method returning the max between two numbers */
- (int)max:(int)num1 andNum2:(int)num2{
/* local variable declaration */
   int result;
 
   if (num1 > num2)
   {
      result = num1;
   }
   else
   {
      result = num2;
   }
 
   return result; 
}

@end

int main ()
{
   /* local variable definition */
   int a = 100;
   int b = 200;
   int ret;
   
   SampleClass *sampleClass = [[SampleClass alloc]init];

   /* calling a method to get max value */
   ret = [sampleClass max:a andNum2:b];
 
   NSLog(@"Max value is : %d\n", ret );
 
   return 0;
}
</pre>
<p>I kept max() function along with main() function and complied the source code. While running final executable, it would produce the following result:</p>
<pre class="prettyprint notranslate">
2013-09-07 22:28:45.912 demo[26080] Max value is : 200
</pre>

<title>Objective-C Blocks</title>

<h1>Objective-C Blocks</h1>

<p>An Objective-C class defines an object that combines data with related behavior. Sometimes, it makes sense just to represent a single task or unit of behavior, rather than a collection of methods.</p>

<p>Blocks are a language-level feature added to C, Objective-C and C++ which allow you to create distinct segments of code that can be passed around to methods or functions as if they were values. Blocks are Objective-C objects which means they can be added to collections like NSArray or NSDictionary. They also have the ability to capture values from the enclosing scope, making them similar to closures or lambdas in other programming languages </p>

<h2>Simple Block declaration syntax</h2>

<p>Simple block implementation</p>

<h2>Here is a simple example</h2>

<h2>We can invoke the block using</h2>

<h2>Blocks Take Arguments and Return Values</h2>

<p>Blocks can also take arguments and return values just like methods and functions.</p>

<p>Here is a simple example to implement and invoke a block with arguments and return values.</p>

<h2>Blocks using type definitions</h2>

<p>Here is a simple example using typedef in block. Please note this sample <b>doesn't work</b> on the <b>online compiler</b> for now. Use <b>XCode</b> to run the same.</p>

<p>Let us compile and execute it, it will produce the following result:</p>

<p>Blocks are used more in iOS applications and Mac OS X. So its more important to understand the usage of blocks.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
returntype (^blockName)(argumentType);
</pre>
<p>Simple block implementation</p>
<pre class="prettyprint notranslate">
returntype (^blockName)(argumentType)= ^{
};
</pre>
<h2>Here is a simple example</h2>
<pre class="prettyprint notranslate">
void (^simpleBlock)(void) = ^{
    NSLog(@"This is a block");
};
</pre>
<h2>We can invoke the block using</h2>
<pre class="prettyprint notranslate">
simpleBlock();
</pre>
<h2>Blocks Take Arguments and Return Values</h2>
<p>Blocks can also take arguments and return values just like methods and functions.</p>
<p>Here is a simple example to implement and invoke a block with arguments and return values.</p>
<pre class="prettyprint notranslate">
double (^multiplyTwoValues)(double, double) = 
    ^(double firstValue, double secondValue) {
	    return firstValue * secondValue;
    };
double result = multiplyTwoValues(2,4); 
NSLog(@"The result is %f", result);
</pre>
<h2>Blocks using type definitions</h2>
<p>Here is a simple example using typedef in block. Please note this sample <b>doesn't work</b> on the <b>online compiler</b> for now. Use <b>XCode</b> to run the same.</p>
<pre class="prettyprint notranslate">
#import &lt;Foundation/Foundation.h&gt;

typedef void (^CompletionBlock)();
@interface SampleClass:NSObject
- (void)performActionWithCompletion:(CompletionBlock)completionBlock;
@end

@implementation SampleClass

- (void)performActionWithCompletion:(CompletionBlock)completionBlock{

    NSLog(@"Action Performed");
    completionBlock();
}

@end

int main()
{
    /* my first program in Objective-C */
    SampleClass *sampleClass = [[SampleClass alloc]init];
    [sampleClass performActionWithCompletion:^{
        NSLog(@"Completion is called to intimate action is performed.");
    }];
    
    return 0;
}
</pre>
<p>Let us compile and execute it, it will produce the following result:</p>
<pre class="prettyprint notranslate">
2013-09-10 08:13:57.155 demo[284:303] Action Performed
2013-09-10 08:13:57.157 demo[284:303] Completion is called to intimate action is performed.
</pre>

<title>Objective-C Numbers</title>

<h1>Objective-C Numbers</h1>

<p>In Objective-C programming language, in order to save the basic data types like int, float, bool in object form,</p>

<p>Objective-C provides a range of methods to work with NSNumber and important ones are listed in following table.</p>

<p>Creates and returns an NSNumber object containing a given value, treating it as a BOOL.</p>

<p>Creates and returns an NSNumber object containing a given value, treating it as a signed char.</p>

<p>Creates and returns an NSNumber object containing a given value, treating it as a double.</p>

<p>Creates and returns an NSNumber object containing a given value, treating it as a float.</p>

<p>Creates and returns an NSNumber object containing a given value, treating it as a signed int.</p>

<p>Creates and returns an NSNumber object containing a given value, treating it as an NSInteger.</p>

<p>Returns the receiver's value as a BOOL.</p>

<p>Returns the receiver's value as a char.</p>

<p>Returns the receiver's value as a double. </p>

<p>Returns the receiver's value as a float.</p>

<p>Returns the receiver's value as an NSInteger.</p>

<p>Returns the receiver's value as an int.</p>

<p>Returns the receiver's value as a human-readable string.</p>

<p>Here is a simple example for using NSNumber which multiplies two numbers and returns the product.</p>

<p>Now when we compile and run the program, we will get the following result.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

@interface SampleClass:NSObject

- (NSNumber *)multiplyA:(NSNumber *)a withB:(NSNumber *)b;

@end

@implementation SampleClass

- (NSNumber *)multiplyA:(NSNumber *)a withB:(NSNumber *)b
{
   float number1 = [a floatValue];
   float number2 = [b floatValue];
   float product = number1 * number2;
   NSNumber *result = [NSNumber numberWithFloat:product];
   return result;
}

@end

int main()
{
   NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];

   SampleClass *sampleClass = [[SampleClass alloc]init];
   NSNumber *a = [NSNumber numberWithFloat:10.5];
   NSNumber *b = [NSNumber numberWithFloat:10.0];   
   NSNumber *result = [sampleClass multiplyA:a withB:b];
   NSString *resultString = [result stringValue];
   NSLog(@"The product is %@",resultString);

   [pool drain];
   return 0;
}
</pre>

<p>Now when we compile and run the program, we will get the following result.</p>
<pre class="prettyprint notranslate">
2013-09-14 18:53:40.575 demo[16787] The product is 105
</pre>

<title>Objective-C Arrays</title>

<h1>Objective-C Arrays</h1>

<p>Objective-C programming language provides a data structure called <b>the array</b>, which can store a fixed-size sequential collection of elements of the same type. An array is used to store a collection of data, but it is often more useful to think of an array as a collection of variables of the same type.</p>

<p>Instead of declaring individual variables, such as number0, number1, ..., and number99, you declare one array variable such as numbers and use numbers[0], numbers[1], and ..., numbers[99] to represent individual variables. A specific element in an array is accessed by an index. </p>

<p>All arrays consist of contiguous memory locations. The lowest address corresponds to the first element and the highest address to the last element.</p>

<h2>Declaring Arrays</h2>

<p>To declare an array in Objective-C, a programmer specifies the type of the elements and the number of elements required by an array as follows:</p>

<p>This is called a <i>single-dimensional</i> array. The <b>arraySize</b> must be an integer constant greater than zero and <b>type</b> can be any valid Objective-C data type. For example, to declare a 10-element array called <b>balance</b> of type double, use this statement:</p>

<p>Now, <i>balance</i> is a variable array, which is sufficient to hold up to 10 double numbers.</p>

<h2>Initializing Arrays</h2>

<p>You can initialize an array in Objective-C either one by one or using a single statement as follows:</p>

<p>The number of values between braces { } can not be larger than the number of elements that we declare for the array between square brackets [ ]. Following is an example to assign a single element of the array:</p>

<p>If you omit the size of the array, an array just big enough to hold the initialization is created.  Therefore, if you write:</p>

<p>You will create exactly the same array as you did in the previous example.</p>

<p>The above statement assigns element number 5th in the array a value of 50.0. Array with 4th index will be 5th, i.e., last element because all arrays have 0 as the index of their first element which is also called base index. Following is the pictorial representation  of the same array we discussed above:</p>

<h2>Accessing Array Elements</h2>

<p>An element is accessed by indexing the array name. This is done by placing the index of the element within square brackets after the name of the array. For example:</p>

<p>The above statement will take 10th element from the array and assign the value to salary variable. Following is an example, which will use all the above mentioned three concepts viz. declaration, assignment and accessing arrays:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Objective-C Arrays in Detail</h2>

<p>Arrays are important to Objective-C and need lots of more details. There are following few important concepts related to array which should be clear to a Objective-C programmer:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
type arrayName [ arraySize ];
</pre>
<p>This is called a <i>single-dimensional</i> array. The <b>arraySize</b> must be an integer constant greater than zero and <b>type</b> can be any valid Objective-C data type. For example, to declare a 10-element array called <b>balance</b> of type double, use this statement:</p>
<pre class="prettyprint notranslate">
double balance[10];
</pre>
<p>Now, <i>balance</i> is a variable array, which is sufficient to hold up to 10 double numbers.</p>
<h2>Initializing Arrays</h2>
<p>You can initialize an array in Objective-C either one by one or using a single statement as follows:</p>
<pre class="prettyprint notranslate">
double balance[5] = {1000.0, 2.0, 3.4, 17.0, 50.0};
</pre>
<p>The number of values between braces { } can not be larger than the number of elements that we declare for the array between square brackets [ ]. Following is an example to assign a single element of the array:</p>
<p>If you omit the size of the array, an array just big enough to hold the initialization is created.  Therefore, if you write:</p>
<pre class="prettyprint notranslate">
double balance[] = {1000.0, 2.0, 3.4, 17.0, 50.0};
</pre>
<p>You will create exactly the same array as you did in the previous example.</p>
<pre class="prettyprint notranslate">
balance[4] = 50.0;
</pre>
<p>The above statement assigns element number 5th in the array a value of 50.0. Array with 4th index will be 5th, i.e., last element because all arrays have 0 as the index of their first element which is also called base index. Following is the pictorial representation  of the same array we discussed above:</p>
<img src="/objective_c/images/array_presentation.jpg" alt="Array Presentation" />
<h2>Accessing Array Elements</h2>
<p>An element is accessed by indexing the array name. This is done by placing the index of the element within square brackets after the name of the array. For example:</p>
<pre class="prettyprint notranslate">
double salary = balance[9];
</pre>
<p>The above statement will take 10th element from the array and assign the value to salary variable. Following is an example, which will use all the above mentioned three concepts viz. declaration, assignment and accessing arrays:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;
 
int main ()
{
   int n[ 10 ]; /* n is an array of 10 integers */
   int i,j;
 
   /* initialize elements of array n to 0 */         
   for ( i = 0; i &lt; 10; i++ )
   {
      n[ i ] = i + 100; /* set element at location i to i + 100 */
   }
   
   /* output each array element's value */
   for (j = 0; j &lt; 10; j++ )
   {
      NSLog(@"Element[%d] = %d\n", j, n[j] );
   }
 
   return 0;
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
2013-09-14 01:24:06.669 demo[16508] Element[0] = 100
2013-09-14 01:24:06.669 demo[16508] Element[1] = 101
2013-09-14 01:24:06.669 demo[16508] Element[2] = 102
2013-09-14 01:24:06.669 demo[16508] Element[3] = 103
2013-09-14 01:24:06.669 demo[16508] Element[4] = 104
2013-09-14 01:24:06.669 demo[16508] Element[5] = 105
2013-09-14 01:24:06.669 demo[16508] Element[6] = 106
2013-09-14 01:24:06.669 demo[16508] Element[7] = 107
2013-09-14 01:24:06.669 demo[16508] Element[8] = 108
2013-09-14 01:24:06.669 demo[16508] Element[9] = 109
</pre>

<title>Objective-C Pointers</title>

<h1>Objective-C Pointers</h1>

<p>Pointers in Objective-C are easy and fun to learn. Some Objective-C programming tasks are performed more easily with pointers, and other tasks, such as dynamic memory allocation, cannot be performed without using pointers. So it becomes necessary to learn pointers to become a perfect Objective-C programmer. Let's start learning them in simple and easy steps.</p>

<p>As you know, every variable is a memory location and every memory location has its address defined which can be accessed using ampersand (&amp;) operator, which denotes an address in memory. Consider the following example, which will print the address of the variables defined:</p>

<p>When the above code is compiled and executed, it produces the result something as follows:</p>

<p>So, you understood what is memory address and how to access it, so base of the concept is over. Now let us see what is a pointer.</p>

<h2>What Are Pointers?</h2>

<p>A <b>pointer</b> is a variable whose value is the address of another variable, i.e., direct address of the memory location. Like any variable or constant, you must declare a pointer before you can use it to store any variable address. The general form of a pointer variable declaration is:</p>

<p>Here, <b>type</b> is the pointer's base type; it must be a valid Objective-C data type and <b>var-name</b> is the name of the pointer variable. The asterisk * you used to declare a pointer is the same asterisk that you use for multiplication. However, in this statement the asterisk is being used to designate a variable as a pointer. Following are the valid pointer declaration:</p>

<p>The actual data type of the value of all pointers, whether integer, float, character, or otherwise, is the same, a long hexadecimal number that represents a memory address. The only difference between pointers of different data types is the data type of the variable or constant that the pointer points to.</p>

<h2>How to use Pointers?</h2>

<p>There are few important operations, which we will do with the help of pointers very frequently. <b>(a)</b> we define a pointer variable, <b>(b)</b> assign the address of a variable to a pointer, and <b>(c)</b> finally access the value at the address available in the pointer variable. This is done by using unary operator <b>*</b> that returns the value of the variable located at the address specified by its operand. Following example makes use of these operations:</p>

<p>When the above code is compiled and executed, it produces the result something as follows:</p>

<h2>NULL Pointers in Objective-C</h2>

<p>It is always a good practice to assign a NULL value to a pointer variable in case you do not have exact address to be assigned. This is done at the time of variable declaration. A pointer that is assigned NULL is called a <b>null</b> pointer.</p>

<p>The NULL pointer is a constant with a value of zero defined in several standard libraries. Consider the following program:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>On most of the operating systems, programs are not permitted to access memory at address 0 because that memory is reserved by the operating system. However, the memory address 0 has special significance; it signals that the pointer is not intended to point to an accessible memory location. But by convention, if a pointer contains the null (zero) value, it is assumed to point to nothing.</p>

<p>To check for a null pointer, you can use an if statement as follows:</p>

<h2>Objective-C Pointers in Detail:</h2>

<p>Pointers have many but easy concepts and they are very important to Objective-C programming. There are following few important pointer concepts, which should be clear to a Objective-C programmer:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

int main ()
{
   int  var1;
   char var2[10];

   NSLog(@"Address of var1 variable: %x\n", &amp;var1  );
   NSLog(@"Address of var2 variable: %x\n", &amp;var2  );

   return 0;
}
</pre>
<p>When the above code is compiled and executed, it produces the result something as follows:</p>
<pre class="prettyprint notranslate">
2013-09-13 03:18:45.727 demo[17552] Address of var1 variable: 1c0843fc
2013-09-13 03:18:45.728 demo[17552] Address of var2 variable: 1c0843f0
</pre>
<p>So, you understood what is memory address and how to access it, so base of the concept is over. Now let us see what is a pointer.</p>
<h2>What Are Pointers?</h2>
<p>A <b>pointer</b> is a variable whose value is the address of another variable, i.e., direct address of the memory location. Like any variable or constant, you must declare a pointer before you can use it to store any variable address. The general form of a pointer variable declaration is:</p>
<pre class="prettyprint notranslate">
type *var-name;
</pre>
<p>Here, <b>type</b> is the pointer's base type; it must be a valid Objective-C data type and <b>var-name</b> is the name of the pointer variable. The asterisk * you used to declare a pointer is the same asterisk that you use for multiplication. However, in this statement the asterisk is being used to designate a variable as a pointer. Following are the valid pointer declaration:</p>
<pre class="prettyprint notranslate">
int    *ip;    /* pointer to an integer */
double *dp;    /* pointer to a double */
float  *fp;    /* pointer to a float */
char   *ch     /* pointer to a character */
</pre>
<p>The actual data type of the value of all pointers, whether integer, float, character, or otherwise, is the same, a long hexadecimal number that represents a memory address. The only difference between pointers of different data types is the data type of the variable or constant that the pointer points to.</p>
<h2>How to use Pointers?</h2>
<p>There are few important operations, which we will do with the help of pointers very frequently. <b>(a)</b> we define a pointer variable, <b>(b)</b> assign the address of a variable to a pointer, and <b>(c)</b> finally access the value at the address available in the pointer variable. This is done by using unary operator <b>*</b> that returns the value of the variable located at the address specified by its operand. Following example makes use of these operations:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

int main ()
{
   int  var = 20;   /* actual variable declaration */
   int  *ip;        /* pointer variable declaration */

   ip = &amp;var;  /* store address of var in pointer variable*/

   NSLog(@"Address of var variable: %x\n", &amp;var  );

   /* address stored in pointer variable */
   NSLog(@"Address stored in ip variable: %x\n", ip );

   /* access the value using the pointer */
   NSLog(@"Value of *ip variable: %d\n", *ip );

   return 0;
}
</pre>
<p>When the above code is compiled and executed, it produces the result something as follows:</p>
<pre class="prettyprint notranslate">
2013-09-13 03:20:21.873 demo[24179] Address of var variable: 337ed41c
2013-09-13 03:20:21.873 demo[24179] Address stored in ip variable: 337ed41c
2013-09-13 03:20:21.874 demo[24179] Value of *ip variable: 20
</pre>
<h2>NULL Pointers in Objective-C</h2>
<p>It is always a good practice to assign a NULL value to a pointer variable in case you do not have exact address to be assigned. This is done at the time of variable declaration. A pointer that is assigned NULL is called a <b>null</b> pointer.</p>
<p>The NULL pointer is a constant with a value of zero defined in several standard libraries. Consider the following program:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

int main ()
{
   int  *ptr = NULL;

   NSLog(@"The value of ptr is : %x\n", ptr  );
 
   return 0;
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
2013-09-13 03:21:19.447 demo[28027] The value of ptr is : 0
</pre>
<p>On most of the operating systems, programs are not permitted to access memory at address 0 because that memory is reserved by the operating system. However, the memory address 0 has special significance; it signals that the pointer is not intended to point to an accessible memory location. But by convention, if a pointer contains the null (zero) value, it is assumed to point to nothing.</p>
<p>To check for a null pointer, you can use an if statement as follows:</p>
<pre class="prettyprint notranslate">
if(ptr)     /* succeeds if p is not null */
if(!ptr)    /* succeeds if p is null */
</pre>

<title>Objective-C Strings</title>

<h1>Objective-C Strings</h1>

<p>The string in Objective-C programming language is represented using NSString and its subclass NSMutableString provides several ways for creating string objects. The simplest way to create a string object is to use the Objective-C  @"..." construct: </p>

<p>A simple example for creating and printing a string is shown below.</p>

<p>When the above code is compiled and executed, it produces result something as follows:</p>

<p>Objective-C supports a wide range of methods for manipulate strings:</p>

<p>Returns a capitalized representation of the receiver.</p>

<p>Returns the character at a given array position.</p>

<p>Returns the floating-point value of the receiver&rsquo;s text as a double.</p>

<p>Returns the floating-point value of the receiver&rsquo;s text as a float.</p>

<p>Returns a Boolean value that indicates whether a given string matches the beginning characters of the receiver.</p>

<p>Returns a Boolean value that indicates whether a given string matches the ending characters of the receiver.</p>

<p>Returns an NSString object initialized by using a given format string as a template into which the remaining argument values are substituted.</p>

<p>Returns the NSInteger value of the receiver&rsquo;s text.</p>

<p>Returns a Boolean value that indicates whether a given string is equal to the receiver using a literal Unicode-based comparison.</p>

<p>Returns the number of Unicode characters in the receiver.</p>

<p>Returns lowercased representation of the receiver.</p>

<p>Finds and returns the range of the first occurrence of a given string within the receiver.</p>

<p>Returns a string made by appending to the receiver a string constructed from a given format string and the following arguments.</p>

<p>Returns a new string made by removing from both ends of the receiver characters contained in a given character set.</p>

<p>Returns a new string containing the characters of the receiver from the one at a given index to the end.</p>

<p>Following example makes use of few of the above-mentioned functions:</p>

<p>When the above code is compiled and executed, it produces result something as follows:</p>

<p>You can find a complete list of Objective-C NSString related methods in <a rel="nofollow" href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSString_Class/Reference/NSString.html" target="_blank" title="NSString Class Reference">NSString Class Reference.</a></p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
NSString *greeting = @"Hello";
</pre>
<p>A simple example for creating and printing a string is shown below.</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

int main ()
{
   NSString *greeting = @"Hello";

   NSLog(@"Greeting message: %@\n", greeting );

   return 0;
}
</pre>
<p>When the above code is compiled and executed, it produces result something as follows:</p>
<pre class="prettyprint notranslate">
2013-09-11 01:21:39.922 demo[23926] Greeting message: Hello
</pre>
<p>Objective-C supports a wide range of methods for manipulate strings:</p>
<table class="table table-bordered">
<tr>
<th style="width:5%">S.N.</th>
<th>Method &amp; Purpose</th>
</tr>
<tr>
<td>1</td>
<td><b>- (NSString *)capitalizedString;</b>
<p>Returns a capitalized representation of the receiver.</p></td>
</tr>
<tr>
<td>2</td>
<td><b>- (unichar)characterAtIndex:(NSUInteger)index;</b>
<p>Returns the character at a given array position.</p></td>
</tr>
<tr>
<td>3</td>
<td><b>- (double)doubleValue;</b>
<p>Returns the floating-point value of the receiver&rsquo;s text as a double.</p></td>
</tr>
<tr>
<td>4</td>
<td><b>- (float)floatValue;</b>
<p>Returns the floating-point value of the receiver&rsquo;s text as a float.</p></td>
</tr>
<tr>
<td>5</td>
<td><b>- (BOOL)hasPrefix:(NSString *)aString;</b>
<p>Returns a Boolean value that indicates whether a given string matches the beginning characters of the receiver.</p></td>
</tr>
<tr>
<td>6</td>
<td><b>- (BOOL)hasSuffix:(NSString *)aString;</b>
<p>Returns a Boolean value that indicates whether a given string matches the ending characters of the receiver.</p></td>
</tr>
<tr>
<td>7</td>
<td><b>- (id)initWithFormat:(NSString *)format ...;</b>
<p>Returns an NSString object initialized by using a given format string as a template into which the remaining argument values are substituted.</p></td>
</tr>
<tr>
<td>8</td>
<td><b>- (NSInteger)integerValue;</b>
<p>Returns the NSInteger value of the receiver&rsquo;s text.</p></td>
</tr>
<tr>
<td>9</td>
<td><b>- (BOOL)isEqualToString:(NSString *)aString;</b>
<p>Returns a Boolean value that indicates whether a given string is equal to the receiver using a literal Unicode-based comparison.</p></td>
</tr>
<tr>
<td>10</td>
<td><b>- (NSUInteger)length;</b>
<p>Returns the number of Unicode characters in the receiver.</p></td>
</tr>
<tr>
<td>11</td>
<td><b>- (NSString *)lowercaseString;</b>
<p>Returns lowercased representation of the receiver.</p></td>
</tr>
<tr>
<td>12</td>
<td><b>- (NSRange)rangeOfString:(NSString *)aString;</b>
<p>Finds and returns the range of the first occurrence of a given string within the receiver.</p></td>
</tr>
<tr>
<td>13</td>
<td><b>- (NSString *)stringByAppendingFormat:(NSString *)format ...;</b>
<p>Returns a string made by appending to the receiver a string constructed from a given format string and the following arguments.</p></td>
</tr>
<tr>
<td>14</td>
<td><b>- (NSString *)stringByTrimmingCharactersInSet:(NSCharacterSet *)set;</b>
<p>Returns a new string made by removing from both ends of the receiver characters contained in a given character set.</p></td>
</tr>
<tr>
<td>15</td>
<td><b>- (NSString *)substringFromIndex:(NSUInteger)anIndex;</b>
<p>Returns a new string containing the characters of the receiver from the one at a given index to the end.</p></td>
</tr>
</table>
<p>Following example makes use of few of the above-mentioned functions:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

int main ()
{
   NSString *str1 = @"Hello";
   NSString *str2 = @"World";
   NSString *str3;
   int  len ;

   NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];

   /* uppercase string */
   str3 = [str2 uppercaseString];
   NSLog(@"Uppercase String :  %@\n", str3 );

   /* concatenates str1 and str2 */
   str3 = [str1 stringByAppendingFormat:@"World"];
   NSLog(@"Concatenated string:   %@\n", str3 );

   /* total length of str3 after concatenation */
   len = [str3 length];
   NSLog(@"Length of Str3 :  %d\n", len );
    
   /* InitWithFormat */
    str3 = [[NSString alloc] initWithFormat:@"%@ %@",str1,str2];	
    NSLog(@"Using initWithFormat:   %@\n", str3 );
    [pool drain];

   return 0;
}
</pre>
<p>When the above code is compiled and executed, it produces result something as follows:</p>
<pre class="prettyprint notranslate">
2013-09-11 01:15:45.069 demo[30378] Uppercase String :  WORLD
2013-09-11 01:15:45.070 demo[30378] Concatenated string:   HelloWorld
2013-09-11 01:15:45.070 demo[30378] Length of Str3 :  10
2013-09-11 01:15:45.070 demo[30378] Using initWithFormat:   Hello World
</pre>

<title>Objective-C Structures</title>

<h1>Objective-C Structures</h1>

<p>Objective-C arrays allow you to define type of variables that can hold several data items of the same kind but <b>structure</b> is another user-defined data type available in Objective-C programming which allows you to combine data items of different kinds.</p>

<p>Structures are used to represent a record, Suppose you want to keep track of your books in a library. You might want to track the following attributes about each book:</p>

<p>Title</p>

<p>Author</p>

<p>Subject</p>

<p>Book ID</p>

<h2>Defining a Structure</h2>

<p>To define a structure, you must use the <b>struct</b> statement. The struct statement defines a new data type, with more than one member for your program. The format of the struct statement is this:</p>

<p>The <b>structure tag</b> is optional and each member definition is a normal variable definition, such as int i; or float f; or any other valid variable definition. At the end of the structure's definition, before the final semicolon, you can specify one or more structure variables but it is optional. Here is the way you would declare the Book structure:</p>

<h2>Accessing Structure Members</h2>

<p>To access any member of a structure, we use the <b>member access operator (.)</b>. The member access operator is coded as a period between the structure variable name and the structure member that we wish to access. You would use <b>struct</b> keyword to define variables of structure type. Following is the example to explain usage of structure:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Structures as Function Arguments</h2>

<p>You can pass a structure as a function argument in very similar way as you pass any other variable or pointer. You would access structure variables in the similar way as you have accessed in the above example:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Pointers to Structures</h2>

<p>You can define pointers to structures in very similar way as you define pointer to any other variable as follows:</p>

<p>Now, you can store the address of a structure variable in the above-defined pointer variable. To find the address of a structure variable, place the &amp; operator before the structure's name as follows:</p>

<p>To access the members of a structure using a pointer to that structure, you must use the -&gt; operator as follows:</p>

<p>Let us re-write above example using structure pointer, hope this will be easy for you to understand the concept:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Bit Fields</h2>

<p>Bit Fields allow the packing of data in a structure. This is especially useful when memory or data storage is at a premium. Typical examples:</p>

<p>Packing several objects into a machine word. e.g. 1 bit flags can be compacted.</p>

<p>Reading external file formats -- non-standard file formats could be read in. E.g. 9 bit integers.</p>

<p>Objective-C allows us do this in a structure definition by putting :bit length after the variable. For example:</p>

<p>Here, the packed_struct contains 6 members: Four 1 bit flags f1..f3, a 4 bit type and a 9 bit my_int.</p>

<p>Objective-C automatically packs the above bit fields as compactly as possible, provided that the maximum length of the field is less than or equal to the integer word length of the computer. If this is not the case, then some compilers may allow memory overlap for the fields whilst other would store the next field in the next word.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
struct [structure tag]
{
   member definition;
   member definition;
   ...
   member definition;
} [one or more structure variables];  
</pre>
<p>The <b>structure tag</b> is optional and each member definition is a normal variable definition, such as int i; or float f; or any other valid variable definition. At the end of the structure's definition, before the final semicolon, you can specify one or more structure variables but it is optional. Here is the way you would declare the Book structure:</p>
<pre class="prettyprint notranslate">
struct Books
{
   NSString *title;
   NSString *author;
   NSString *subject;
   int   book_id;
} book;  
</pre>
<h2>Accessing Structure Members</h2>
<p>To access any member of a structure, we use the <b>member access operator (.)</b>. The member access operator is coded as a period between the structure variable name and the structure member that we wish to access. You would use <b>struct</b> keyword to define variables of structure type. Following is the example to explain usage of structure:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

struct Books
{
   NSString *title;
   NSString *author;
   NSString *subject;
   int   book_id;
};
 
int main( )
{
   struct Books Book1;        /* Declare Book1 of type Book */
   struct Books Book2;        /* Declare Book2 of type Book */
 
   /* book 1 specification */
   Book1.title = @"Objective-C Programming";
   Book1.author = @"Nuha Ali"; 
   Book1.subject = @"Objective-C Programming Tutorial";
   Book1.book_id = 6495407;

   /* book 2 specification */
   Book2.title = @"Telecom Billing";
   Book2.author = @"Zara Ali";
   Book2.subject = @"Telecom Billing Tutorial";
   Book2.book_id = 6495700;
 
   /* print Book1 info */
   NSLog(@"Book 1 title : %@\n", Book1.title);
   NSLog(@"Book 1 author : %@\n", Book1.author);
   NSLog(@"Book 1 subject : %@\n", Book1.subject);
   NSLog(@"Book 1 book_id : %d\n", Book1.book_id);

   /* print Book2 info */
   NSLog(@"Book 2 title : %@\n", Book2.title);
   NSLog(@"Book 2 author : %@\n", Book2.author);
   NSLog(@"Book 2 subject : %@\n", Book2.subject);
   NSLog(@"Book 2 book_id : %d\n", Book2.book_id);

   return 0;
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
2013-09-14 04:20:07.947 demo[20591] Book 1 title : Objective-C Programming
2013-09-14 04:20:07.947 demo[20591] Book 1 author : Nuha Ali
2013-09-14 04:20:07.947 demo[20591] Book 1 subject : Objective-C Programming Tutorial
2013-09-14 04:20:07.947 demo[20591] Book 1 book_id : 6495407
2013-09-14 04:20:07.947 demo[20591] Book 2 title : Telecom Billing
2013-09-14 04:20:07.947 demo[20591] Book 2 author : Zara Ali
2013-09-14 04:20:07.947 demo[20591] Book 2 subject : Telecom Billing Tutorial
2013-09-14 04:20:07.947 demo[20591] Book 2 book_id : 6495700
</pre>
<h2>Structures as Function Arguments</h2>
<p>You can pass a structure as a function argument in very similar way as you pass any other variable or pointer. You would access structure variables in the similar way as you have accessed in the above example:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

struct Books
{
   NSString *title;
   NSString *author;
   NSString *subject;
   int   book_id;
};

@interface SampleClass:NSObject

/* function declaration */
- (void) printBook:( struct Books) book ;

@end

@implementation SampleClass 

- (void) printBook:( struct Books) book
{
   NSLog(@"Book title : %@\n", book.title);
   NSLog(@"Book author : %@\n", book.author);
   NSLog(@"Book subject : %@\n", book.subject);
   NSLog(@"Book book_id : %d\n", book.book_id);
}
@end

int main( )
{
   struct Books Book1;        /* Declare Book1 of type Book */
   struct Books Book2;        /* Declare Book2 of type Book */
 
   /* book 1 specification */
   Book1.title = @"Objective-C Programming";
   Book1.author = @"Nuha Ali"; 
   Book1.subject = @"Objective-C Programming Tutorial";
   Book1.book_id = 6495407;

   /* book 2 specification */
   Book2.title = @"Telecom Billing";
   Book2.author = @"Zara Ali";
   Book2.subject = @"Telecom Billing Tutorial";
   Book2.book_id = 6495700;
 
   SampleClass *sampleClass = [[SampleClass alloc]init];
   /* print Book1 info */
   [sampleClass printBook: Book1];

   /* Print Book2 info */
   [sampleClass printBook: Book2];

   return 0;
}

</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
2013-09-14 04:34:45.725 demo[8060] Book title : Objective-C Programming
2013-09-14 04:34:45.725 demo[8060] Book author : Nuha Ali
2013-09-14 04:34:45.725 demo[8060] Book subject : Objective-C Programming Tutorial
2013-09-14 04:34:45.725 demo[8060] Book book_id : 6495407
2013-09-14 04:34:45.725 demo[8060] Book title : Telecom Billing
2013-09-14 04:34:45.725 demo[8060] Book author : Zara Ali
2013-09-14 04:34:45.725 demo[8060] Book subject : Telecom Billing Tutorial
2013-09-14 04:34:45.725 demo[8060] Book book_id : 6495700
</pre>
<h2>Pointers to Structures</h2>
<p>You can define pointers to structures in very similar way as you define pointer to any other variable as follows:</p>
<pre class="prettyprint notranslate">
struct Books *struct_pointer;
</pre>
<p>Now, you can store the address of a structure variable in the above-defined pointer variable. To find the address of a structure variable, place the &amp; operator before the structure's name as follows:</p>
<pre class="prettyprint notranslate">
struct_pointer = &amp;Book1;
</pre>
<p>To access the members of a structure using a pointer to that structure, you must use the -&gt; operator as follows:</p>
<pre class="prettyprint notranslate">
struct_pointer-&gt;title;
</pre>
<p>Let us re-write above example using structure pointer, hope this will be easy for you to understand the concept:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

struct Books
{
   NSString *title;
   NSString *author;
   NSString *subject;
   int   book_id;
};

@interface SampleClass:NSObject

/* function declaration */
- (void) printBook:( struct Books *) book ;

@end

@implementation SampleClass 

- (void) printBook:( struct Books *) book
{
   NSLog(@"Book title : %@\n", book-&gt;title);
   NSLog(@"Book author : %@\n", book-&gt;author);
   NSLog(@"Book subject : %@\n", book-&gt;subject);
   NSLog(@"Book book_id : %d\n", book-&gt;book_id);
}
@end

int main( )
{
   struct Books Book1;        /* Declare Book1 of type Book */
   struct Books Book2;        /* Declare Book2 of type Book */
 
   /* book 1 specification */
   Book1.title = @"Objective-C Programming";
   Book1.author = @"Nuha Ali"; 
   Book1.subject = @"Objective-C Programming Tutorial";
   Book1.book_id = 6495407;

   /* book 2 specification */
   Book2.title = @"Telecom Billing";
   Book2.author = @"Zara Ali";
   Book2.subject = @"Telecom Billing Tutorial";
   Book2.book_id = 6495700;
 
   SampleClass *sampleClass = [[SampleClass alloc]init];
   /* print Book1 info by passing address of Book1 */
   [sampleClass printBook:&amp;Book1];

   /* print Book2 info by passing address of Book2 */
   [sampleClass printBook:&amp;Book2];

   return 0;
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
2013-09-14 04:38:13.942 demo[20745] Book title : Objective-C Programming
2013-09-14 04:38:13.942 demo[20745] Book author : Nuha Ali
2013-09-14 04:38:13.942 demo[20745] Book subject : Objective-C Programming Tutorial
2013-09-14 04:38:13.942 demo[20745] Book book_id : 6495407
2013-09-14 04:38:13.942 demo[20745] Book title : Telecom Billing
2013-09-14 04:38:13.942 demo[20745] Book author : Zara Ali
2013-09-14 04:38:13.942 demo[20745] Book subject : Telecom Billing Tutorial
2013-09-14 04:38:13.942 demo[20745] Book book_id : 6495700
</pre>
<h2>Bit Fields</h2>
<p>Bit Fields allow the packing of data in a structure. This is especially useful when memory or data storage is at a premium. Typical examples:</p>
<ul class="list">
<li><p>Packing several objects into a machine word. e.g. 1 bit flags can be compacted.</p></li>
<li><p>Reading external file formats -- non-standard file formats could be read in. E.g. 9 bit integers.</p></li>
</ul>
<p>Objective-C allows us do this in a structure definition by putting :bit length after the variable. For example:</p>
<pre class="prettyprint notranslate">
struct packed_struct {
  unsigned int f1:1;
  unsigned int f2:1;
  unsigned int f3:1;
  unsigned int f4:1;
  unsigned int type:4;
  unsigned int my_int:9;
} pack;
</pre>

<title>Objective-C Preprocessors</title>

<h1>Objective-C Preprocessors</h1>

<p>The <b>Objective-C Preprocessor</b> is not part of the compiler, but is a separate step in the compilation process. In simplistic terms, an Objective-C Preprocessor is just a text substitution tool and it instructs compiler to do required pre-processing before actual compilation. We'll refer to the Objective-C Preprocessor as the OCPP.</p>

<p>All preprocessor commands begin with a pound symbol (#). It must be the first nonblank character, and for readability, a preprocessor directive should begin in first column. Following section lists down all important preprocessor directives:</p>

<h2>Preprocessors Examples</h2>

<p>Analyze the following examples to understand various directives.</p>

<p>This directive tells the OCPP to replace instances of MAX_ARRAY_LENGTH with 20. Use <i>#define</i> for constants to increase readability.</p>

<p>These directives tell the OCPP to get foundation.h from <b>Foundation Framework</b> and add the text to the current source file. The next line tells OCPP to get <b>myheader.h</b> from the local directory and add the content to the current source file.</p>

<p>This tells the OCPP to undefine existing FILE_SIZE and define it as 42.</p>

<p>This tells the OCPP to define MESSAGE only if MESSAGE isn't already defined.</p>

<p>This tells the OCPP to do the process the statements enclosed if DEBUG is defined. This is useful if you pass the <i>-DDEBUG</i> flag to gcc compiler at the time of compilation. This will define DEBUG, so you can turn debugging on and off on the fly during compilation.</p>

<h2>Predefined Macros</h2>

<p>ANSI C defines a number of macros. Although each one is available for your use in programming, the predefined macros should not be directly modified.</p>

<p>Let's try the following example:</p>

<p>When the above code in a file <b>main.m</b> is compiled and executed, it produces the following result:</p>

<h2>Preprocessor Operators</h2>

<p>The Objective-C preprocessor offers following operators to help you in creating macros:</p>

<h3>Macro Continuation (\)</h3>

<p>A macro usually must be contained on a single line. The macro continuation operator is used to continue a macro that is too long for a single line. For example:</p>

<h3> Stringize (#)</h3>

<p>The stringize or number-sign operator ('#'), when used within a macro definition, converts a macro parameter into a string constant. This operator may be used only in a macro that has a specified argument or parameter list. For example:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h3>Token Pasting (##)</h3>

<p>The token-pasting operator (##) within a macro definition combines two arguments. It permits two separate tokens in the macro definition to be joined into a single token. For example:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>How it happened, because this example results in the following actual output from the preprocessor:</p>

<p>This example shows the concatenation of token##n into token34 and here we have used both <b>stringize</b> and <b>token-pasting</b>.</p>

<h3>The defined() Operator</h3>

<p>The preprocessor <b>defined</b> operator is used in constant expressions to determine if an identifier is defined using #define. If the specified identifier is defined, the value is true (non-zero). If the symbol is not defined, the value is false (zero). The defined operator is specified as follows:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Parameterized Macros</h2>

<p>One of the powerful functions of the OCPP is the ability to simulate functions using parameterized macros. For example, we might have some code to square a number as follows:</p>

<p>We can rewrite above code using a macro as follows:</p>

<p>Macros with arguments must be defined using the <b>#define</b> directive before they can be used. The argument list is enclosed in parentheses and must immediately follow the macro name. Spaces are not allowed between macro name and open parenthesis. For example:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
#define MAX_ARRAY_LENGTH 20
</pre>
<p>This directive tells the OCPP to replace instances of MAX_ARRAY_LENGTH with 20. Use <i>#define</i> for constants to increase readability.</p>
<pre class="prettyprint notranslate">
#import &lt;Foundation/Foundation.h&gt;
#include "myheader.h"
</pre>
<p>These directives tell the OCPP to get foundation.h from <b>Foundation Framework</b> and add the text to the current source file. The next line tells OCPP to get <b>myheader.h</b> from the local directory and add the content to the current source file.</p>
<pre class="prettyprint notranslate">
#undef  FILE_SIZE
#define FILE_SIZE 42
</pre>
<p>This tells the OCPP to undefine existing FILE_SIZE and define it as 42.</p>
<pre class="prettyprint notranslate">
#ifndef MESSAGE
   #define MESSAGE "You wish!"
#endif
</pre>
<p>This tells the OCPP to define MESSAGE only if MESSAGE isn't already defined.</p>
<pre class="prettyprint notranslate">
#ifdef DEBUG
   /* Your debugging statements here */
#endif
</pre>
<p>This tells the OCPP to do the process the statements enclosed if DEBUG is defined. This is useful if you pass the <i>-DDEBUG</i> flag to gcc compiler at the time of compilation. This will define DEBUG, so you can turn debugging on and off on the fly during compilation.</p>
<h2>Predefined Macros</h2>
<p>ANSI C defines a number of macros. Although each one is available for your use in programming, the predefined macros should not be directly modified.</p>
<table class="table table-bordered">
<tr><th style="width:20%">Macro</th><th>Description</th></tr>
<tr><td>__DATE__</td><td>The current date as a character literal in "MMM DD YYYY" format</td></tr>
<tr><td>__TIME__</td><td>The current time as a character literal in "HH:MM:SS" format</td></tr>
<tr><td>__FILE__</td><td>This contains the current filename as a string literal.</td></tr>
<tr><td>__LINE__</td><td>This contains the current line number as a decimal constant.</td></tr>
<tr><td>__STDC__</td><td>Defined as 1 when the compiler complies with the ANSI standard.</td></tr>
</table>
<p>Let's try the following example:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

int main()
{
   NSLog(@"File :%s\n", __FILE__ );
   NSLog(@"Date :%s\n", __DATE__ );
   NSLog(@"Time :%s\n", __TIME__ );
   NSLog(@"Line :%d\n", __LINE__ );
   NSLog(@"ANSI :%d\n", __STDC__ );
   
   return 0;
}
</pre>
<p>When the above code in a file <b>main.m</b> is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
2013-09-14 04:46:14.859 demo[20683] File :main.m
2013-09-14 04:46:14.859 demo[20683] Date :Sep 14 2013
2013-09-14 04:46:14.859 demo[20683] Time :04:46:14
2013-09-14 04:46:14.859 demo[20683] Line :8
2013-09-14 04:46:14.859 demo[20683] ANSI :1
</pre>
<h2>Preprocessor Operators</h2>
<p>The Objective-C preprocessor offers following operators to help you in creating macros:</p>
<h3>Macro Continuation (\)</h3>
<p>A macro usually must be contained on a single line. The macro continuation operator is used to continue a macro that is too long for a single line. For example:</p>
<pre class="prettyprint notranslate">
#define  message_for(a, b)  \
    NSLog(@#a " and " #b ": We love you!\n")

</pre>
<h3> Stringize (#)</h3>
<p>The stringize or number-sign operator ('#'), when used within a macro definition, converts a macro parameter into a string constant. This operator may be used only in a macro that has a specified argument or parameter list. For example:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

#define  message_for(a, b)  \
    NSLog(@#a " and " #b ": We love you!\n")

int main(void)
{
   message_for(Carole, Debra);
   return 0;
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
2013-09-14 05:46:14.859 demo[20683] Carole and Debra: We love you!
</pre>
<h3>Token Pasting (##)</h3>
<p>The token-pasting operator (##) within a macro definition combines two arguments. It permits two separate tokens in the macro definition to be joined into a single token. For example:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

#define tokenpaster(n) NSLog (@"token" #n " = %d", token##n)

int main(void)
{
   int token34 = 40;
   
   tokenpaster(34);
   return 0;
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
2013-09-14 05:48:14.859 demo[20683] token34 = 40
</pre>
<p>How it happened, because this example results in the following actual output from the preprocessor:</p>
<pre class="prettyprint notranslate">
NSLog (@"token34 = %d", token34);
</pre>
<p>This example shows the concatenation of token##n into token34 and here we have used both <b>stringize</b> and <b>token-pasting</b>.</p>
<h3>The defined() Operator</h3>
<p>The preprocessor <b>defined</b> operator is used in constant expressions to determine if an identifier is defined using #define. If the specified identifier is defined, the value is true (non-zero). If the symbol is not defined, the value is false (zero). The defined operator is specified as follows:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

#if !defined (MESSAGE)
   #define MESSAGE "You wish!"
#endif

int main(void)
{
   NSLog(@"Here is the message: %s\n", MESSAGE);  
   return 0;
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
2013-09-14 05:48:19.859 demo[20683] Here is the message: You wish!
</pre>
<h2>Parameterized Macros</h2>
<p>One of the powerful functions of the OCPP is the ability to simulate functions using parameterized macros. For example, we might have some code to square a number as follows:</p>
<pre class="prettyprint notranslate">
int square(int x) {
   return x * x;
}
</pre>
<p>We can rewrite above code using a macro as follows:</p>
<pre class="prettyprint notranslate">
#define square(x) ((x) * (x))
</pre>
<p>Macros with arguments must be defined using the <b>#define</b> directive before they can be used. The argument list is enclosed in parentheses and must immediately follow the macro name. Spaces are not allowed between macro name and open parenthesis. For example:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

#define MAX(x,y) ((x) &gt; (y) ? (x) : (y))

int main(void)
{
   NSLog(@"Max between 20 and 10 is %d\n", MAX(10, 20));  
   return 0;
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
2013-09-14 05:52:15.859 demo[20683] Max between 20 and 10 is 20
</pre>

<title>Objective-C Typedef</title>

<h1>Objective-C Typedef</h1>

<p>The Objective-C programming language provides a keyword called <b>typedef</b>, which you can use to give a type a new name. Following is an example to define a term <b>BYTE</b> for one-byte numbers:</p>

<p>By convention, uppercase letters are used for these definitions to remind the user that the type name is really a symbolic abbreviation, but you can use lowercase, as follows:</p>

<p>You can use <b>typedef</b> to give a name to user-defined data type as well. For example, you can use typedef with structure to define a new data type and then use that data type to define structure variables directly as follows:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>typedef vs #define</h2>

<p>The <b>#define</b> is a Objective-C directive, which is also used to define the aliases for various data types similar to <b> typedef</b> but with following differences:</p>

<p>The <b>typedef</b> is limited to giving symbolic names to types only whereas <b>#define</b> can be used to define alias for values as well, like you can define 1 as ONE, etc.</p>

<p>The <b>typedef</b> interpretation is performed by the compiler where as <b>#define</b> statements are processed by the pre-processor.</p>

<p>Following is a simplest usage of #define:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
typedef unsigned char BYTE;
</pre>
<p>After this type definition, the identifier BYTE can be used as an abbreviation for the type <b>unsigned char, for example:</b>.
<pre class="prettyprint notranslate">
BYTE  b1, b2;
</pre>
<p>By convention, uppercase letters are used for these definitions to remind the user that the type name is really a symbolic abbreviation, but you can use lowercase, as follows:</p>
<pre class="prettyprint notranslate">
typedef unsigned char byte;
</pre>
<p>You can use <b>typedef</b> to give a name to user-defined data type as well. For example, you can use typedef with structure to define a new data type and then use that data type to define structure variables directly as follows:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

typedef struct Books
{
   NSString *title;
   NSString *author;
   NSString *subject;
   int book_id;

} Book;
 
int main( )
{

   Book book;
   book.title = @"Objective-C Programming";
   book.author = @"TutorialsPoint";
   book.subject = @"Programming tutorial";
   book.book_id = 100;
   NSLog( @"Book title : %@\n", book.title);
   NSLog( @"Book author : %@\n", book.author);
   NSLog( @"Book subject : %@\n", book.subject);
   NSLog( @"Book Id : %d\n", book.book_id);

   return 0;
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
2013-09-12 12:21:53.745 demo[31183] Book title : Objective-C Programming
2013-09-12 12:21:53.745 demo[31183] Book author : TutorialsPoint
2013-09-12 12:21:53.745 demo[31183] Book subject : Programming tutorial
2013-09-12 12:21:53.745 demo[31183] Book Id : 100
</pre>
<h2>typedef vs #define</h2>
<p>The <b>#define</b> is a Objective-C directive, which is also used to define the aliases for various data types similar to <b> typedef</b> but with following differences:</p>
<ul class="list">
<li><p>The <b>typedef</b> is limited to giving symbolic names to types only whereas <b>#define</b> can be used to define alias for values as well, like you can define 1 as ONE, etc.</p></li>
<li><p>The <b>typedef</b> interpretation is performed by the compiler where as <b>#define</b> statements are processed by the pre-processor.</p></li>
</ul>
<p>Following is a simplest usage of #define:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;
 
#define TRUE  1
#define FALSE 0
 
int main( )
{
   NSLog( @"Value of TRUE : %d\n", TRUE);
   NSLog( @"Value of FALSE : %d\n", FALSE);

   return 0;
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
2013-09-12 12:23:37.993 demo[5160] Value of TRUE : 1
2013-09-12 12:23:37.994 demo[5160] Value of FALSE : 0
</pre>

<title>Objective-C Type Casting</title>

<h1>Objective-C Type Casting</h1>

<p>Type casting is a way to convert a variable from one data type  to another data type. For example, if you want to store a long value into a simple integer then you can type cast long to int. You can  convert values from one type to another explicitly using the <b>cast operator</b> as follows:</p>

<p>In Objective-C, we generally use CGFloat for doing floating point operation, which is derived from basic type of float in case of 32-bit and double in case of 64-bit. Consider the following example where the cast operator causes the division of one integer variable by another to be performed as a floating-point operation:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>It should be noted here that the cast operator has precedence over division, so the value of <b>sum</b> is first converted to type <b>double</b> and finally it gets divided by count yielding a double value.</p>

<p>Type conversions can be implicit which is performed by the compiler automatically or it can be specified explicitly through the use of the <b>cast operator</b>. It is considered good programming practice to use the cast operator whenever type conversions are necessary.</p>

<h2>Integer Promotion</h2>

<p>Integer promotion is the process by which values of integer type "smaller" than <b>int</b> or <b>unsigned int</b> are converted either to <b>int</b> or <b>unsigned int</b>. Consider an example of adding a character in an int:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>Here, value of sum is coming as 116 because compiler is doing integer promotion and converting the value of 'c' to ascii before performing  actual addition operation.</p>

<h2>Usual Arithmetic Conversion</h2>

<p>The <b>usual arithmetic conversions</b> are implicitly performed to cast their values in a common type. Compiler first performs <i>integer promotion</i>, if operands still have different types then they are converted to the type that appears highest in the following hierarchy:</p>

<p>The usual arithmetic conversions are not performed for the assignment operators, nor for the logical operators &amp;&amp; and ||. Let us take following example to understand the concept:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>Here, it is simple to understand that first c gets converted to integer but because final value is float, so usual arithmetic conversion applies and compiler converts i and c into float and add them yielding a float result.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
(type_name) expression
</pre>
<p>In Objective-C, we generally use CGFloat for doing floating point operation, which is derived from basic type of float in case of 32-bit and double in case of 64-bit. Consider the following example where the cast operator causes the division of one integer variable by another to be performed as a floating-point operation:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

int main()
{
   int sum = 17, count = 5;
   CGFloat mean;

   mean = (CGFloat) sum / count;
   NSLog(@"Value of mean : %f\n", mean );

   return 0;
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
2013-09-11 01:35:40.047 demo[20634] Value of mean : 3.400000
</pre>
<p>It should be noted here that the cast operator has precedence over division, so the value of <b>sum</b> is first converted to type <b>double</b> and finally it gets divided by count yielding a double value.</p>
<p>Type conversions can be implicit which is performed by the compiler automatically or it can be specified explicitly through the use of the <b>cast operator</b>. It is considered good programming practice to use the cast operator whenever type conversions are necessary.</p>
<h2>Integer Promotion</h2>
<p>Integer promotion is the process by which values of integer type "smaller" than <b>int</b> or <b>unsigned int</b> are converted either to <b>int</b> or <b>unsigned int</b>. Consider an example of adding a character in an int:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

int main()
{
   int  i = 17;
   char c = 'c'; /* ascii value is 99 */
   int sum;

   sum = i + c;
   NSLog(@"Value of sum : %d\n", sum );

   return 0;
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
2013-09-11 01:38:28.492 demo[980] Value of sum : 116
</pre>
<p>Here, value of sum is coming as 116 because compiler is doing integer promotion and converting the value of 'c' to ascii before performing  actual addition operation.</p>
<h2>Usual Arithmetic Conversion</h2>
<p>The <b>usual arithmetic conversions</b> are implicitly performed to cast their values in a common type. Compiler first performs <i>integer promotion</i>, if operands still have different types then they are converted to the type that appears highest in the following hierarchy:</p>
<img src="/objective_c/images/usual_arithmetic_conversion.png" alt="Usual Arithmetic Conversion" />
<p>The usual arithmetic conversions are not performed for the assignment operators, nor for the logical operators &amp;&amp; and ||. Let us take following example to understand the concept:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

int main()
{
   int  i = 17;
   char c = 'c'; /* ascii value is 99 */
   CGFloat sum;

   sum = i + c;
   NSLog(@"Value of sum : %f\n", sum );
   return 0;
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
2013-09-11 01:41:39.192 demo[15351] Value of sum : 116.000000
</pre>

<title>Objective-C Log Handling</title>

<h1>Objective-C Log Handling</h1>

<h2>NSLog method</h2>

<p>In order to print logs, we use the NSLog method in Objective-C programming language which we have used right from the Hello World example.</p>

<p>Let us look at a simple code that would print the words "Hello World":</p>

<p>Now, when we compile and run the program, we will get the following result.</p>

<h2>Disabling logs in Live apps</h2>

<p>Since the NSLogs we use in our application, it will be printed in logs of device and it is not good to print logs in a live build. Hence, we use a type definition for printing logs and we can use them as shown below.</p>

<p>Now, when we compile and run the program in debug mode, we will get the following result.</p>

<p>Now, when we compile and run the program in release mode, we will get the following result.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

int main()
{
   NSLog(@"Hello, World! \n");
   return 0;
}
</pre>
<p>Now, when we compile and run the program, we will get the following result.</p>
<pre class="prettyprint notranslate">
2013-09-16 00:32:50.888 demo[16669] Hello, World! 
</pre>

<h2>Disabling logs in Live apps</h2>
<p>Since the NSLogs we use in our application, it will be printed in logs of device and it is not good to print logs in a live build. Hence, we use a type definition for printing logs and we can use them as shown below.</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

#if DEBUG == 0
#define DebugLog(...)
#elif DEBUG == 1
#define DebugLog(...) NSLog(__VA_ARGS__)
#endif

int main()
{
   DebugLog(@"Debug log, our custom addition gets \
   printed during debug only" );
   NSLog(@"NSLog gets printed always" );     
   return 0;
}
</pre>
<p>Now, when we compile and run the program in debug mode, we will get the following result.</p>
<pre class="prettyprint notranslate">
2013-09-11 02:47:07.723 demo[618] Debug log, our custom addition gets printed during debug only
2013-09-11 02:47:07.723 demo[618] NSLog gets printed always
</pre>
<p>Now, when we compile and run the program in release mode, we will get the following result.</p>
<pre class="prettyprint notranslate">
2013-09-11 02:47:45.248 demo[3158] NSLog gets printed always
</pre>

<title>Objective-C Error Handling</title>

<h1>Objective-C Error Handling</h1>

<p>In Objective-C programming, error handling is provided with NSError class available in <b>Foundation framework.</b></p>

<p>An NSError object encapsulates richer and more extensible error information than is possible using only an error code or error string. The core attributes of an NSError object are an error domain (represented by a string), a domain-specific error code and a user info dictionary containing application specific information.</p>

<h2>NSError</h2>

<p>NSError Object consists of:</p>

<p>Domain: The error domain can be one of the predefined NSError domains or an arbitrary string describing a custom domain and domain must not be nil.</p>

<p>Code: The error code for the error.</p>

<p>User Info: The userInfo dictionary for the error and userInfo may be nil.</p>

<p>The following example shows how to create a custom error</p>

<p>Here is complete code of the above error sample passed as reference to an pointer</p>

<p>In the above example, we return a name if the id is 1, otherwise we set the user-defined error object.</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
NSString *domain = @"com.MyCompany.MyApplication.ErrorDomain";
NSString *desc = NSLocalizedString(@"Unable to complete the process", @"");
NSDictionary *userInfo = @{ NSLocalizedDescriptionKey : desc };
NSError *error = [NSError errorWithDomain:domain code:-101 userInfo:userInfo];
</pre>

<p>Here is complete code of the above error sample passed as reference to an pointer</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

@interface SampleClass:NSObject

-(NSString *) getEmployeeNameForID:(int) id withError:(NSError **)errorPtr;

@end

@implementation SampleClass

-(NSString *) getEmployeeNameForID:(int) id withError:(NSError **)errorPtr{
    if(id == 1)
    {
       return @"Employee Test Name";
    }
    else
    {
       NSString *domain = @"com.MyCompany.MyApplication.ErrorDomain";
       NSString *desc =@"Unable to complete the process";
       NSDictionary *userInfo = [[NSDictionary alloc] 
       initWithObjectsAndKeys:desc,
       @"NSLocalizedDescriptionKey",NULL];  
       *errorPtr = [NSError errorWithDomain:domain code:-101 
       userInfo:userInfo];
       return @"";
    }
}

@end


int main()
{
   NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
   SampleClass *sampleClass = [[SampleClass alloc]init];
   NSError *error = nil;
   NSString *name1 = [sampleClass getEmployeeNameForID:1 withError:&error];
  
   if(error)
   {
      NSLog(@"Error finding Name1: %@",error);
   }
   else
   {
      NSLog(@"Name1: %@",name1);
   }

   error = nil;

   NSString *name2 = [sampleClass getEmployeeNameForID:2 withError:&error];

   if(error)
   {
      NSLog(@"Error finding Name2: %@",error);
   }
   else
   {
      NSLog(@"Name2: %@",name2);
   }

   [pool drain];
   return 0;
   
}
</pre>
<p>In the above example, we return a name if the id is 1, otherwise we set the user-defined error object.</p>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
2013-09-14 18:01:00.809 demo[27632] Name1: Employee Test Name
2013-09-14 18:01:00.809 demo[27632] Error finding Name2: Unable to complete the process
</pre>

<title>Command-Line Arguments</title>

<h1>Command-Line Arguments</h1>

<p>It is possible to pass some values from the command line to your Objective-C programs when they are executed. These values are called <b>command line arguments</b> and many times they are important for your program, especially when you want to control your program from outside instead of hard coding those values inside the code.</p>

<p>The command line arguments are handled using main() function arguments where <b>argc</b> refers to the number of arguments passed, and <b>argv[]</b> is a pointer array, which points to each argument passed to the program. Following is a simple example, which checks if there is any argument supplied from the command line and take action accordingly:</p>

<p>When the above code is compiled and executed with a single argument, say "testing", it produces the following result.</p>

<p>When the above code is compiled and executed with two arguments, say testing1 and testing2, it produces the following result.</p>

<p>When the above code is compiled and executed without passing any argument, it produces the following result.</p>

<p>It should be noted that <b>argv[0]</b> holds the name of the program itself and <b>argv[1]</b> is a pointer to the first command-line argument supplied, and *argv[n] is the last argument. If no arguments are supplied, argc will be one, otherwise if you pass one argument, then <b>argc</b> is set at 2.</p>

<p>You pass all the command line arguments  separated by a space, but if argument itself has a space, then you can pass such arguments by putting them inside double quotes "" or single quotes ''. Let us re-write above example once again where we will print program name and we also pass a command-line argument by putting inside double quotes:</p>

<p>When the above code is compiled and executed with a single argument separated by space but inside double quotes say "Testing1 Testing2", it produces the following result.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
#import &lt;Foundation/Foundation.h&gt;

int main( int argc, char *argv[] )  
{
   if( argc == 2 )
   {
      NSLog(@"The argument supplied is %s\n", argv[1]);
   }
   else if( argc > 2 )
   {
      NSLog(@"Too many arguments supplied.\n");
   }
   else
   {
      NSLog(@"One argument expected.\n");
   }
}
</pre>
<p>When the above code is compiled and executed with a single argument, say "testing", it produces the following result.</p>

<pre class="prettyprint notranslate">
2013-09-13 03:01:17.333 demo[7640] The argument supplied is testing
</pre>


<p>When the above code is compiled and executed with two arguments, say testing1 and testing2, it produces the following result.</p>
<pre class="prettyprint notranslate">
2013-09-13 03:01:18.333 demo[7640] Too many arguments supplied.
</pre>
<p>When the above code is compiled and executed without passing any argument, it produces the following result.</p>
<pre class="prettyprint notranslate">
2013-09-13 03:01:18.333 demo[7640] One argument expected
</pre>
<p>It should be noted that <b>argv[0]</b> holds the name of the program itself and <b>argv[1]</b> is a pointer to the first command-line argument supplied, and *argv[n] is the last argument. If no arguments are supplied, argc will be one, otherwise if you pass one argument, then <b>argc</b> is set at 2.</p>
<p>You pass all the command line arguments  separated by a space, but if argument itself has a space, then you can pass such arguments by putting them inside double quotes "" or single quotes ''. Let us re-write above example once again where we will print program name and we also pass a command-line argument by putting inside double quotes:</p>
<pre class="prettyprint notranslate">
#import &lt;Foundation/Foundation.h&gt;

int main( int argc, char *argv[] )  
{
   NSLog(@"Program name %s\n", argv[0]);
 
   if( argc == 2 )
   {
      NSLog(@"The argument supplied is %s\n", argv[1]);
   }
   else if( argc &gt; 2 )
   {
      NSLog(@"Too many arguments supplied.\n");
   }
   else
   {
      NSLog(@"One argument expected.\n");
   }
   return 0;
}
</pre>
<p>When the above code is compiled and executed with a single argument separated by space but inside double quotes say "Testing1 Testing2", it produces the following result.</p>
<pre class="prettyprint notranslate">
2013-09-14 04:07:57.305 demo[8534] Program name demo
2013-09-14 04:07:57.305 demo[8534] The argument supplied is Testing1 Testing 2</pre>

<title>Objective-C Classes & Objects</title>

<h1>Objective-C Classes & Objects</h1>

<p>The main purpose of Objective-C programming language is to add object orientation to the C programming language and classes are the central feature of Objective-C that support object-oriented programming and are often called user-defined types.</p>

<p>A class is used to specify the form of an object and it combines data representation and methods for manipulating that data into one neat package. The data and methods within a class are called members of the class.</p>

<h2>Objective-C characteristics</h2>

<p>The class is defined in two different sections namely <b>@interface</b> and <b>@implementation</b>.</p>

<p>Almost everything is in form of objects.</p>

<p>Objects receive messages and objects are often referred as receivers.</p>

<p>Objects contain instance variables.</p>

<p>Objects and instance variables have scope.</p>

<p>Classes hide an object's implementation.</p>

<p>Properties are used to provide access to class instance variables in other classes.</p>

<h2>Objective-C Class Definitions:</h2>

<p>When you define a class, you define a blueprint for a data type. This doesn't actually define any data, but it does define what the class name means, that is, what an object of the class will consist of and what operations can be performed on such an object.</p>

<p>A class definition starts with the keyword <b>@interface</b> followed by the interface(class) name; and the class body, enclosed by a pair of curly braces. In Objective-C, all classes are derived from the base class called <b>NSObject</b>. It is the superclass of all Objective-C classes. It provides basic methods like memory allocation and initialization. For example, we defined the Box data type using the keyword <b>class</b> as follows:</p>

<p>The instance variables are private and are only accessible inside the class implementation.</p>

<h2>Allocating and initializing Objective-C Objects:</h2>

<p>A class provides the blueprints for objects, so basically an object is created from a class. We declare objects of a class with exactly the same sort of declaration that we declare variables of basic types. Following statements declare two objects of class Box:</p>

<p>Both of the objects box1 and box2 will have their own copy of data members.</p>

<h2>Accessing the Data Members:</h2>

<p>The properties of objects of a class can be accessed using the direct member access operator (.). Let us try the following example to make things clear:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Properties:</h2>

<p>Properties are introduced in Objective-C to ensure that the instance variable of the class can be accessed outside the class.</p>

<p>It is only possible with the properties we can access the instance variables of the class. Actually, internally getter and setter methods are created for the properties.</p>

<p>For example, let's assume we have a property <b>@property (nonatomic ,readonly ) BOOL isDone</b>. Under the hood, there are setters and getters created as shown below.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
@interface Box:NSObject
{
    //Instance variables
    double length;   // Length of a box
    double breadth;  // Breadth of a box
}
@property(nonatomic, readwrite) double height; // Property

@end
</pre>
<p>The instance variables are private and are only accessible inside the class implementation.</p>
<h2>Allocating and initializing Objective-C Objects:</h2>
<p>A class provides the blueprints for objects, so basically an object is created from a class. We declare objects of a class with exactly the same sort of declaration that we declare variables of basic types. Following statements declare two objects of class Box:</p>
<pre class="prettyprint notranslate">
Box box1 = [[Box alloc]init];     // Create box1 object of type Box
Box box2 = [[Box alloc]init];     // Create box2 object of type Box
</pre>
<p>Both of the objects box1 and box2 will have their own copy of data members.</p>
<h2>Accessing the Data Members:</h2>
<p>The properties of objects of a class can be accessed using the direct member access operator (.). Let us try the following example to make things clear:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

@interface Box:NSObject
{
    double length;   // Length of a box
    double breadth;  // Breadth of a box
    double height;   // Height of a box
}
@property(nonatomic, readwrite) double height; // Property

-(double) volume;

@end

@implementation Box

@synthesize height; 

-(id)init
{
   self = [super init];
   length = 1.0;
   breadth = 1.0;
   return self;
}

-(double) volume
{
   return length*breadth*height;
}

@end

int main( )
{
   NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];    
   Box *box1 = [[Box alloc]init];    // Create box1 object of type Box
   Box *box2 = [[Box alloc]init];    // Create box2 object of type Box

   double volume = 0.0;     // Store the volume of a box here
 
   // box 1 specification
   box1.height = 5.0; 

   // box 2 specification
   box2.height = 10.0;
  
   // volume of box 1
   volume = [box1 volume];
   NSLog(@"Volume of Box1 : %f", volume);
   // volume of box 2
   volume = [box2 volume];
   NSLog(@"Volume of Box2 : %f", volume);
   [pool drain];
   return 0;
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
2013-09-22 21:25:33.314 ClassAndObjects[387:303] Volume of Box1 : 5.000000
2013-09-22 21:25:33.316 ClassAndObjects[387:303] Volume of Box2 : 10.000000
</pre>
<h2>Properties:</h2>
<p>Properties are introduced in Objective-C to ensure that the instance variable of the class can be accessed outside the class.</p>
The various parts are the property declaration are as follows.
<ul class="list">
<p><li>Properties begin with <b>@property</b>, which is a keyword</li><p>
<p><li>It is followed with access specifiers, which are nonatomic or atomic, readwrite or readonly and strong, unsafe_unretained or weak. This varies based on the type of the variable. For any pointer type, we can use strong, unsafe_unretained or weak. Similarly for other types we can use readwrite or readonly.</li><p>
<p><li>This is followed by the datatype of the variable.</li><p>
<p><li>Finally, we have the property name terminated by a semicolon.</li><p>
<p><li>We can add synthesize statement in the implementation class. But in the latest XCode, the synthesis part is taken care by the XCode and you need not include synthesize statement.</li><p>
</ul>
<p>It is only possible with the properties we can access the instance variables of the class. Actually, internally getter and setter methods are created for the properties.</p>
<p>For example, let's assume we have a property <b>@property (nonatomic ,readonly ) BOOL isDone</b>. Under the hood, there are setters and getters created as shown below.</p>
<pre class="prettyprint notranslate">
-(void)setIsDone(BOOL)isDone;
-(BOOL)isDone;
</pre>

<title>Objective-C Inheritance</title>

<h1>Objective-C Inheritance</h1>

<p>One of the most important concepts in object-oriented programming is that of inheritance. Inheritance allows us to define a class in terms of another class which makes it easier to create and maintain an application. This also provides an opportunity to reuse the code functionality and fast implementation time.</p>

<p>When creating a class, instead of writing completely new data members and member functions, the programmer can designate that the new class should inherit the members of an existing class. This existing class is called the <b>base</b> class, and the new class is referred to as the <b>derived</b> class.</p>

<p>The idea of inheritance implements the <b>is a</b> relationship. For example, mammal IS-A animal, dog IS-A mammal, hence dog IS-A animal as well and so on.</p>

<h2>Base &amp; Derived Classes:</h2>

<p>Objective-C allows only multilevel inheritance, i.e., it can have only one base class but allows multilevel inheritance. All classes in Objective-C is derived from the superclass <b>NSObject</b>.</p>

<p>Consider a base class <b>Person</b> and its derived class <b>Employee</b> as follows:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Access Control and Inheritance:</h2>

<p>A derived class can access all the private members of its base class if it's defined in the interface class, but it cannot access private members that are defined in the implementation file.</p>

<p>We can summarize the different access types according to who can access them in the following way: </p>

<p>A derived class inherits all base class methods and variables with the following exceptions:</p>

<p>Variables declared in implementation file with the help of extensions is not accessible.</p>

<p>Methods declared in implementation file with the help of extensions is not accessible.</p>

<p>In case the inherited class implements the method in base class, then the method in derived class is executed.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
@interface derived-class: base-class
</pre>
<p>Consider a base class <b>Person</b> and its derived class <b>Employee</b> as follows:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;
 
@interface Person : NSObject

{
    NSString *personName;
    NSInteger personAge;
}

- (id)initWithName:(NSString *)name andAge:(NSInteger)age;
- (void)print;
@end

@implementation Person

- (id)initWithName:(NSString *)name andAge:(NSInteger)age{
    personName = name;
    personAge = age;
    return self;
}

- (void)print{
    NSLog(@"Name: %@", personName);
    NSLog(@"Age: %ld", personAge);
}

@end

@interface Employee : Person

{
    NSString *employeeEducation;
}

- (id)initWithName:(NSString *)name andAge:(NSInteger)age 
  andEducation:(NSString *)education;
- (void)print;

@end


@implementation Employee

- (id)initWithName:(NSString *)name andAge:(NSInteger)age 
  andEducation: (NSString *)education
  {
    personName = name;
    personAge = age;
    employeeEducation = education;
    return self;
}

- (void)print
{
    NSLog(@"Name: %@", personName);
    NSLog(@"Age: %ld", personAge);
    NSLog(@"Education: %@", employeeEducation);
}

@end


int main(int argc, const char * argv[])
{
    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];        
    NSLog(@"Base class Person Object");
    Person *person = [[Person alloc]initWithName:@"Raj" andAge:5];
    [person print];
    NSLog(@"Inherited Class Employee Object");
    Employee *employee = [[Employee alloc]initWithName:@"Raj" 
    andAge:5 andEducation:@"MBA"];
    [employee print];        
    [pool drain];
    return 0;
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
2013-09-22 21:20:09.842 Inheritance[349:303] Base class Person Object
2013-09-22 21:20:09.844 Inheritance[349:303] Name: Raj
2013-09-22 21:20:09.844 Inheritance[349:303] Age: 5
2013-09-22 21:20:09.845 Inheritance[349:303] Inherited Class Employee Object
2013-09-22 21:20:09.845 Inheritance[349:303] Name: Raj
2013-09-22 21:20:09.846 Inheritance[349:303] Age: 5
2013-09-22 21:20:09.846 Inheritance[349:303] Education: MBA
</pre>

<title>Objective-C Polymorphism</title>

<h1>Objective-C Polymorphism</h1>

<p>The word <b>polymorphism</b> means having many forms. Typically, polymorphism occurs when there is a hierarchy of classes and they are related by inheritance.</p>

<p>Objective-C polymorphism means that a call to a member function will cause a different function to be executed depending on the type of object that invokes the function.</p>

<p>Consider the example, we have a class Shape that provides the basic interface for all the shapes. Square and Rectangle are derived from the base class Shape.</p>

<p>We have the method printArea that is going to show about the OOP feature <b>polymorphism</b>.</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>In the above example based on the availability of the method calculateArea and printArea, either the method in the base class or the derived class executed.</p>

<p>Polymorphism handles the switching of methods between the base class and derived class based on the method implementation of the two classes.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

@interface Shape : NSObject

{
    CGFloat area;
}

- (void)printArea;
- (void)calculateArea;
@end

@implementation Shape

- (void)printArea{
    NSLog(@"The area is %f", area);
}

- (void)calculateArea{

}

@end


@interface Square : Shape
{
    CGFloat length;
}

- (id)initWithSide:(CGFloat)side;

- (void)calculateArea;

@end

@implementation Square

- (id)initWithSide:(CGFloat)side{
    length = side;
    return self;
}

- (void)calculateArea{
    area = length * length;
}

- (void)printArea{
    NSLog(@"The area of square is %f", area);
}

@end

@interface Rectangle : Shape
{
    CGFloat length;
    CGFloat breadth;
}

- (id)initWithLength:(CGFloat)rLength andBreadth:(CGFloat)rBreadth;


@end

@implementation Rectangle

- (id)initWithLength:(CGFloat)rLength andBreadth:(CGFloat)rBreadth{
    length = rLength;
    breadth = rBreadth;
    return self;
}

- (void)calculateArea{
    area = length * breadth;
}

@end


int main(int argc, const char * argv[])
{
    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
    Shape *square = [[Square alloc]initWithSide:10.0];
    [square calculateArea];
    [square printArea];
    Shape *rect = [[Rectangle alloc]
    initWithLength:10.0 andBreadth:5.0];
    [rect calculateArea];
    [rect printArea];        
    [pool drain];
    return 0;
}

</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
2013-09-22 21:21:50.785 Polymorphism[358:303] The area of square is 100.000000
2013-09-22 21:21:50.786 Polymorphism[358:303] The area is 50.000000
</pre>

<title>Objective-C Data Encapsulation</title>

<h1>Objective-C Data Encapsulation</h1>

<p>All Objective-C programs are composed of the following two fundamental elements: </p>

<p><b>Program statements (code):</b> This is the part of a program that performs actions and they are called methods.</p>

<p><b>Program data:</b> The data is the information of the program which is affected by the program functions.</p>

<p>Encapsulation is an Object-Oriented Programming concept that binds together the data and functions that manipulate the data and that keeps both safe from outside interference and misuse. Data encapsulation led to the important OOP concept of <b>data hiding</b>.</p>

<p><b>Data encapsulation</b> is a mechanism of bundling the data and the functions that use them, and <b>data abstraction</b> is a mechanism of exposing only the interfaces and hiding the implementation details from the user.</p>

<p>Objective-C supports the properties of encapsulation and data hiding through the creation of user-defined types, called <b>classes</b>. For example:</p>

<p>The variable total is private and we cannot access from outside the class. This means that they can be accessed only by other members of the Adder class and not by any other part of your program. This is one way encapsulation is achieved.</p>

<p>Methods inside the interface file are accessible and are public in scope.</p>

<p>There are private methods, which are written with the help of <b>extensions</b>, which we will learn in upcoming chapters.</p>

<h2>Data Encapsulation Example:</h2>

<p>Any Objective-C program where you implement a class with public and private members variables is an example of data encapsulation and data abstraction. Consider the following example:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>Above class adds numbers together and returns the sum. The public members <b>addNum</b> and <b>getTotal </b> are the interfaces to the outside world and a user needs to know them to use the class. The private member <b>total</b> is something that is hidden from the outside world, but is needed for the class to operate properly.</p>

<h2>Designing Strategy:</h2>

<p>Most of us have learned through bitter experience to make class members private by default unless we really need to expose them. That's just good <b>encapsulation</b>.</p>

<p>It's important to understand data encapsulation since it's one of the core features of all Object-Oriented Programming (OOP) languages including Objective-C.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
@interface Adder : NSObject
{
    NSInteger total;
}

- (id)initWithInitialNumber:(NSInteger)initialNumber;

- (void)addNumber:(NSInteger)newNumber;

- (NSInteger)getTotal;

@end
</pre>
<p>The variable total is private and we cannot access from outside the class. This means that they can be accessed only by other members of the Adder class and not by any other part of your program. This is one way encapsulation is achieved.</p>
<p>Methods inside the interface file are accessible and are public in scope.</p>
<p>There are private methods, which are written with the help of <b>extensions</b>, which we will learn in upcoming chapters.</p>
<h2>Data Encapsulation Example:</h2>
<p>Any Objective-C program where you implement a class with public and private members variables is an example of data encapsulation and data abstraction. Consider the following example:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

@interface Adder : NSObject
{
    NSInteger total;
}

- (id)initWithInitialNumber:(NSInteger)initialNumber;

- (void)addNumber:(NSInteger)newNumber;

- (NSInteger)getTotal;

@end

@implementation Adder

-(id)initWithInitialNumber:(NSInteger)initialNumber{
    total = initialNumber;
    return self;
}

- (void)addNumber:(NSInteger)newNumber{
    total = total + newNumber;
}

- (NSInteger)getTotal{
    return total;
}

@end

int main(int argc, const char * argv[])
{
    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];        
    Adder *adder = [[Adder alloc]initWithInitialNumber:10];
    [adder addNumber:5];
    [adder addNumber:4];
    NSLog(@"The total is %ld",[adder getTotal]);
    [pool drain];
    return 0;
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
2013-09-22 21:17:30.485 DataEncapsulation[317:303] The total is 19
</pre>

<title>Objective-C Categories</title>

<h1>Objective-C Categories</h1>

<p>Sometimes, you may find that you wish to extend an existing class by adding behavior that is useful only in certain situations. In order add such extension to existing classes, Objective-C provides <b>categories</b> and <b>extensions</b>.</p>

<p>If you need to add a method to an existing class, perhaps, to add functionality to make it easier to do something in your own application, the easiest way is to use a category.</p>

<p>The syntax to declare a category uses the @interface keyword, just like a standard Objective-C class description, but does not indicate any inheritance from a subclass. Instead, it specifies the name of the category in parentheses, like this:</p>

<h2>Characteristics of category</h2>

<p>A category can be declared for any class, even if you don't have the original implementation source code.</p>

<p>Any methods that you declare in a category will be available to all instances of the original class, as well as any subclasses of the original class.</p>

<p>At runtime, there's no difference between a method added by a category and one that is implemented by the original class.</p>

<p>Now, let's look at a sample category implementation. Let's add a category to the Cocoa class NSString. This category will make it possible for us to add a new method getCopyRightString which helps us in returning the copyright string. It is shown below.</p>

<p>Now when we compile and run the program, we will get the following result.</p>

<p>Even though any methods added by a category are available to all instances of the class and its subclasses, you'll need to import the category header file in any source code file where you wish to use the additional methods, otherwise you'll run into compiler warnings and errors.</p>

<p>In our example, since we just have a single class, we have not included any header files, in such a case we should include the header files as said above.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
@interface ClassName (CategoryName)

@end
</pre>

<h2>Characteristics of category</h2>
<ul class="list">
<li><p>A category can be declared for any class, even if you don't have the original implementation source code.</p></li>
<li><p>Any methods that you declare in a category will be available to all instances of the original class, as well as any subclasses of the original class.</p></li>
<li><p>At runtime, there's no difference between a method added by a category and one that is implemented by the original class.</p></li>
</ul>
<p>Now, let's look at a sample category implementation. Let's add a category to the Cocoa class NSString. This category will make it possible for us to add a new method getCopyRightString which helps us in returning the copyright string. It is shown below.</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

@interface NSString(MyAdditions)

+(NSString *)getCopyRightString;

@end

@implementation NSString(MyAdditions)

+(NSString *)getCopyRightString{
    return @"Copyright TutorialsPoint.com 2013";
}

@end


int main(int argc, const char * argv[])
{
    
   NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
   NSString *copyrightString = [NSString getCopyRightString];
   NSLog(@"Accessing Category: %@",copyrightString);
   [pool drain];
    return 0;
}
</pre>

<p>Now when we compile and run the program, we will get the following result.</p>
<pre class="prettyprint notranslate">
2013-09-22 21:19:12.125 Categories[340:303] Accessing Category: Copyright TutorialsPoint.com 2013
</pre>

<title>Objective-C Posing</title>

<h1>Objective-C Posing</h1>

<p>Before starting about Posing in Objective-C, I would like to bring to your notice that Posing was declared deprecated in Mac OS X 10.5 and it's not available for use thereafter. So for those who are not concerned about these deprecated methods can skip this chapter.</p>

<p>Objective-C permits a class to wholly replace another class within a program. The replacing class is said to "pose as" the target class.</p>

<p>For the versions that supported posing, all messages sent to the target class are instead received by the posing class.</p>

<p>NSObject contains the poseAsClass: method that enables us to replace the existing class as said above.</p>

<h2>Restrictions in Posing</h2>

<p>A class may only pose as one of its direct or indirect superclasses.</p>

<p>The posing class must not define any new instance variables that are absent from the target class (though it may define or override methods).</p>

<p>The target class may not have received any messages prior to the posing.</p>

<p>A posing class can call overridden methods through super, thus incorporating the implementation of the target class.</p>

<p>A posing class can override methods defined in categories.</p>

<p>Now when we compile and run the program in a older Mac OS X (V_10.5 or earlier), we will get the following result.</p>

<p>In the above example, we just polluted the original method with our implementation and this will get affected throughout all the NSString operations with the above method.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
#import &lt;Foundation/Foundation.h&gt;

@interface MyString : NSString

@end

@implementation MyString

- (NSString *)stringByReplacingOccurrencesOfString:(NSString *)target
withString:(NSString *)replacement
{
   NSLog(@"The Target string is %@",target);
   NSLog(@"The Replacement string is %@",replacement);
}

@end

int main()
{
   NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
   [MyString poseAsClass:[NSString class]];
   NSString *string = @"Test";
   [string stringByReplacingOccurrencesOfString:@"a" withString:@"c"];
   [pool drain];
   return 0;
}
</pre>

<p>Now when we compile and run the program in a older Mac OS X (V_10.5 or earlier), we will get the following result.</p>
<pre class="prettyprint notranslate">
2013-09-22 21:23:46.829 Posing[372:303] The Target string is a
2013-09-22 21:23:46.830 Posing[372:303] The Replacement string is c
</pre>

<title>Objective-C Extensions</title>

<h1>Objective-C Extensions</h1>

<p>A class extension bears some similarity to a category, but it can only be added to a class for which you have the source code at compile time (the class is compiled at the same time as the class extension). </p>

<p>The methods declared by a class extension are implemented in the implementation block for the original class, so you can't, for example, declare a class extension on a framework class, such as a Cocoa or Cocoa Touch class like NSString..</p>

<p>Extensions are actually categories without the category name. It's often referred as <b>anonymous categories</b>.</p>

<p>The syntax to declare a extension uses the @interface keyword, just like a standard Objective-C class description, but does not indicate any inheritance from a subclass. Instead, it just adds parentheses, as shown below</p>

<h2>Characteristics of extensions</h2>

<p>An extension cannot be declared for any class, only for the classes that we have original implementation of source code.</p>

<p>An extension is adding private methods and private variables that are only specific to the class.</p>

<p>Any method or variable declared inside the extensions is not accessible even to the inherited classes.</p>

<h2>Extensions Example</h2>

<p>Let's create a class SampleClass that has an extension. In the extension, let's have a private variable internalID.</p>

<p>Then, let's have a method getExternalID that returns the externalID after processing the internalID.</p>

<p>The example is shown below and this wont work on online compiler.</p>

<p>Now when we compile and run the program, we will get the following result.</p>

<p>In the above example, we can see that the internalID is not returned directly. We here remove the UNIQUEINTERNALKEY and only make the remaining value available to the method getExternalID.</p>

<p>The above example just uses a string operation, but it can have many features like encryption/decryption and so on.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
@interface ClassName ()

@end
</pre>

<h2>Characteristics of extensions</h2>
<ul class="list">
<li><p>An extension cannot be declared for any class, only for the classes that we have original implementation of source code.</p></li>
<li><p>An extension is adding private methods and private variables that are only specific to the class.</p></li>
<li><p>Any method or variable declared inside the extensions is not accessible even to the inherited classes.</p></li>
</ul>
<h2>Extensions Example</h2>
<p>Let's create a class SampleClass that has an extension. In the extension, let's have a private variable internalID.</p>
<p>Then, let's have a method getExternalID that returns the externalID after processing the internalID.</p>
<p>The example is shown below and this wont work on online compiler.</p>
<pre class="prettyprint notranslate">
#import &lt;Foundation/Foundation.h&gt;

@interface SampleClass : NSObject
{
    NSString *name;
}

- (void)setInternalID;
- (NSString *)getExternalID;

@end


@interface SampleClass()
{
    NSString *internalID;
}

@end

@implementation SampleClass

- (void)setInternalID{
    internalID = [NSString stringWithFormat: 
    @"UNIQUEINTERNALKEY%dUNIQUEINTERNALKEY",arc4random()%100];
}

- (NSString *)getExternalID{
    return [internalID stringByReplacingOccurrencesOfString: 
    @"UNIQUEINTERNALKEY" withString:@""];
}

@end

int main(int argc, const char * argv[])
{
    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
    SampleClass *sampleClass = [[SampleClass alloc]init];
    [sampleClass setInternalID];
    NSLog(@"ExternalID: %@",[sampleClass getExternalID]);        
    [pool drain];
    return 0;
}
</pre>
<p>Now when we compile and run the program, we will get the following result.</p>
<pre class="prettyprint notranslate">
2013-09-22 21:18:31.754 Extensions[331:303] ExternalID: 51
</pre>

<title>Objective-C Protocols</title>

<h1>Objective-C Protocols</h1>

<p>Objective-C allows you to define protocols, which declare the methods expected to be used for a particular situation. Protocols are implemented in the classes conforming to the protocol.</p>

<p>A simple example would be a network URL handling class, it will have a protocol with methods like processCompleted delegate method that intimates the calling class once the network URL fetching operation is over.</p>

<p>A syntax of protocol is shown below.</p>

<p>The methods under keyword <b>@required</b> must be implemented in the classes that conforms to the protocol and the methods under <b>@optional</b> keyword are optional to implement.</p>

<p>Here is the syntax for class conforming to protocol</p>

<p>This means that any instance of MyClass will respond not only to the methods declared specifically in the interface, but that MyClass also provides implementations for the required methods in MyProtocol. There's no need to redeclare the protocol methods in the class interface - the adoption of the protocol is sufficient.</p>

<p>If you need a class to adopt multiple protocols, you can specify them as a comma-separated list. We have a delegate object that holds the reference of the calling object that implements the protocol.</p>

<p>An example is shown below.</p>

<p>Now when we compile and run the program, we will get the following result.</p>

<p>In the above example we have seen how the delgate methods are called and executed. Its starts with startAction, once the process is completed, the delegate method processCompleted is called to intimate the operation is completed.</p>

<p>In any iOS or Mac app, we will never have a program implemented without a delegate. So its important we understand the usage of delegates. Delegates objects should use unsafe_unretained property type to avoid memory leaks.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
@protocol ProtocolName
@required
// list of required methods
@optional
// list of optional methods
@end
</pre>
<p>The methods under keyword <b>@required</b> must be implemented in the classes that conforms to the protocol and the methods under <b>@optional</b> keyword are optional to implement.</p>

<p>Here is the syntax for class conforming to protocol</p>
<pre class="prettyprint notranslate">
@interface MyClass : NSObject &lt;MyProtocol&gt;
...
@end
</pre>
<p>This means that any instance of MyClass will respond not only to the methods declared specifically in the interface, but that MyClass also provides implementations for the required methods in MyProtocol. There's no need to redeclare the protocol methods in the class interface - the adoption of the protocol is sufficient.</p>
<p>If you need a class to adopt multiple protocols, you can specify them as a comma-separated list. We have a delegate object that holds the reference of the calling object that implements the protocol.</p>
<p>An example is shown below.</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

@protocol PrintProtocolDelegate

- (void)processCompleted;

@end

@interface PrintClass :NSObject
{
    id delegate;
}

- (void) printDetails;
- (void) setDelegate:(id)newDelegate;
@end

@implementation PrintClass

- (void)printDetails{
    NSLog(@"Printing Details");
    [delegate processCompleted];
}

- (void) setDelegate:(id)newDelegate{
    delegate = newDelegate;
}

@end


@interface SampleClass:NSObject&lt;PrintProtocolDelegate&gt;

- (void)startAction;

@end

@implementation SampleClass

- (void)startAction{
    PrintClass *printClass = [[PrintClass alloc]init];
    [printClass setDelegate:self];
    [printClass printDetails];
}

-(void)processCompleted{
    NSLog(@"Printing Process Completed");
}

@end


int main(int argc, const char * argv[])
{
    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
    SampleClass *sampleClass = [[SampleClass alloc]init];
    [sampleClass startAction];
    [pool drain];
    return 0;
}
</pre>
<p>Now when we compile and run the program, we will get the following result.</p>
<pre class="prettyprint notranslate">
2013-09-22 21:15:50.362 Protocols[275:303] Printing Details
2013-09-22 21:15:50.364 Protocols[275:303] Printing Process Completed
</pre>

<title>Objective-C Dynamic Binding</title>

<h1>Objective-C Dynamic Binding</h1>

<p>Dynamic binding is determining the method to invoke at runtime instead of at compile time. Dynamic binding is also referred to as late binding.</p>

<p>In Objective-C, all methods are resolved dynamically at runtime. The exact code executed is determined by both the method name (the selector) and the receiving object.</p>

<p>Dynamic binding enables polymorphism. For example, consider a collection of objects including Rectangle and Square. Each object has its own implementation of a printArea  method.</p>

<p>In the following code fragment, the actual code that should be executed by the expression [anObject printArea] is determined at runtime. The runtime system uses the selector for the method run to identify the appropriate method in whatever class of anObject turns out to be.</p>

<p>Let us look at a simple code that would explain dynamic binding.</p>

<p>Now when we compile and run the program, we will get the following result.</p>

<p>As you can see in the above example, printArea method is dynamically selected in runtime. It is an example for dynamic binding and is quite useful in many situations when dealing with similar kind of objects.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

@interface Square:NSObject
{
   float area;
}
- (void)calculateAreaOfSide:(CGFloat)side;
- (void)printArea;
@end

@implementation Square

- (void)calculateAreaOfSide:(CGFloat)side
{
    area = side * side;
}
- (void)printArea
{
    NSLog(@"The area of square is %f",area);
}

@end

@interface Rectangle:NSObject
{
   float area;
}
- (void)calculateAreaOfLength:(CGFloat)length andBreadth:(CGFloat)breadth;
- (void)printArea;
@end

@implementation  Rectangle

- (void)calculateAreaOfLength:(CGFloat)length andBreadth:(CGFloat)breadth
{
    area = length * breadth;
}
- (void)printArea
{
    NSLog(@"The area of Rectangle is %f",area);
}

@end

int main()
{
   Square *square = [[Square alloc]init];
   [square calculateAreaOfSide:10.0];
   Rectangle *rectangle = [[Rectangle alloc]init];
   [rectangle calculateAreaOfLength:10.0 andBreadth:5.0];
   NSArray *shapes = [[NSArray alloc]initWithObjects: square, rectangle,nil];
   id object1 = [shapes objectAtIndex:0];
   [object1 printArea];
   id object2 = [shapes objectAtIndex:1];
   [object2 printArea];
   return 0;
}
</pre>
<p>Now when we compile and run the program, we will get the following result.</p>
<pre class="prettyprint notranslate">
2013-09-28 07:42:29.821 demo[4916] The area of square is 100.000000
2013-09-28 07:42:29.821 demo[4916] The area of Rectangle is 50.000000</pre>

<title>Objective-C Composite Objects</title>

<h1>Objective-C Composite Objects</h1>

<p>We can create subclass within a class cluster that defines a class that embeds within it an object. These class objects are composite objects.</p>

<p>So you might be wondering what's a class cluster. So we will first see what's a class cluster.</p>

<h2>Class Clusters</h2>

<p>Class clusters are a design pattern that the Foundation framework makes extensive use of. Class clusters group a number of private concrete subclasses under a public abstract superclass. The grouping of classes in this way simplifies the publicly visible architecture of an object-oriented framework without reducing its functional richness. Class clusters are based on the Abstract Factory design pattern.</p>

<p>To make it simple, instead of creating multiple classes for similar functions, we create a single class that will take care of its handling based on the value of input.</p>

<p>For example, in NSNumber we have many clusters of classes like char, int, bool and so on. We group all of them to a single class that takes care of handling the similar operations in a single class. NSNumber actually wraps the value of these primitive types into objects.</p>

<h2>So what's exactly composite object?</h2>

<p>By embedding a private cluster object in an object of our own design, we create a composite object. This composite object can rely on the cluster object for its basic functionality, only intercepting messages that the composite object wants to handle in some particular way. This architecture reduces the amount of code we must write and lets you take advantage of the tested code provided by the Foundation Framework.</p>

<p>This is explained in the following figure.</p>

<p>The composite object must declare itself to be a subclass of the cluster's abstract superclass. As a subclass, it must override the superclass' primitive methods. It can also override derived methods, but this isn't necessary because the derived methods work through the primitive ones.</p>

<p>The count method of the NSArray class is an example; the intervening object's implementation of a method it overrides can be as simple as:</p>

<p>In the above example, embedded object is actually of type NSArray.</p>

<h2>A Composite Object example</h2>

<p>Now in order to see a complete example, let's look at the example from the Apple documentation which is given below.</p>

<p>Now when we compile and run the program, we will get the following result.</p>

<p>In the above example, we can see that validating array's one function would not allow adding null objects that will lead to crash in the normal scenario. But our validating array takes care of it. Similarly, each of the method in validating array adds validating processes apart from the normal sequence of operations.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
- (unsigned)count 
{
return [embeddedObject count];
}
</pre>
<p>In the above example, embedded object is actually of type NSArray.</p>
<h2>A Composite Object example</h2>
<p>Now in order to see a complete example, let's look at the example from the Apple documentation which is given below.</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

@interface ValidatingArray : NSMutableArray
{
    NSMutableArray *embeddedArray;
}

+ validatingArray;
- init;
- (unsigned)count;
- objectAtIndex:(unsigned)index;
- (void)addObject:object;
- (void)replaceObjectAtIndex:(unsigned)index withObject:object;
- (void)removeLastObject;
- (void)insertObject:object atIndex:(unsigned)index;
- (void)removeObjectAtIndex:(unsigned)index;

@end

@implementation ValidatingArray
- init
{
   self = [super init];
   if (self) {
      embeddedArray = [[NSMutableArray allocWithZone:[self zone]] init];
   }
   return self;
}

+ validatingArray
{
   return [[self alloc] init] ;
}
- (unsigned)count
{
   return [embeddedArray count];
}
- objectAtIndex:(unsigned)index
{
    return [embeddedArray objectAtIndex:index];
}
- (void)addObject:(id)object
{
   if (object != nil) {
      [embeddedArray addObject:object];
   }
}
- (void)replaceObjectAtIndex:(unsigned)index withObject:(id)object;
{
   if (index &lt;[embeddedArray count] && object != nil) {
       [embeddedArray replaceObjectAtIndex:index withObject:object];
   }
}
- (void)removeLastObject;
{
   if ([embeddedArray count] > 0) {
       [embeddedArray removeLastObject];
   }
}
- (void)insertObject:(id)object atIndex:(unsigned)index;
{
   if (object != nil) {
       [embeddedArray insertObject:object atIndex:index];
   }
}
- (void)removeObjectAtIndex:(unsigned)index;
{
   if (index &lt;[embeddedArray count]) {
       [embeddedArray removeObjectAtIndex:index];
   }
}

@end

int main()
{
   NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
   ValidatingArray *validatingArray = [ValidatingArray validatingArray];
   [validatingArray addObject:@"Object1"];
   [validatingArray addObject:@"Object2"];
   [validatingArray addObject:[NSNull null]];
   [validatingArray removeObjectAtIndex:2];
   NSString *aString = [validatingArray objectAtIndex:1];
   NSLog(@"The value at Index 1 is %@",aString);
   [pool drain];
   return 0;
}
</pre>
<p>Now when we compile and run the program, we will get the following result.</p>
<pre class="prettyprint notranslate">
2013-09-28 22:03:54.294 demo[6247] The value at Index 1 is Object2</pre>

<title>Obj-C Foundation Framework</title>

<h1>Obj-C Foundation Framework</h1>

<p>If you refer Apple documentation, you can see the details of Foundation framework as given below.</p>

<p>The Foundation framework defines a base layer of Objective-C classes. In addition to providing a set of useful primitive object classes, it introduces several paradigms that define functionality not covered by the Objective-C language. The Foundation framework is designed with these goals in mind:</p>

<p>The framework was developed by NeXTStep, which was acquired by Apple and these foundation classes became part of Mac OS X and iOS.</p>

<p>Since it was developed by NeXTStep, it has class prefix of "NS".</p>

<p>We have used Foundation Framework in all our sample programs. It is almost a must to use Foundation Framework.</p>

<p>Generally, we use something like <b>#import &lt;Foundation/NSString.h&gt;</b> to import a Objective-C class, but in order avoid importing too many classes, it's all imported in <b>#import &lt;Foundation/Foundation.h&gt</b>.</p>

<p>NSObject is the base class of all objects including the foundation kit classes. It provides the methods for memory management. It also provides basic interface to the runtime system and ability to behave as Objective-C objects. It doesn't have any base class and is the root for all classes.</p>

<h2>Foundation Classes based on functionality</h2>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Objective-C Fast Enumeration</title>

<h1>Objective-C Fast Enumeration</h1>

<p>Fast enumeration is an Objective-C's feature that helps in enumerating through a collection. So in order to know about fast enumeration, we need know about collection first which will be explained in the following section.</p>

<h2>Collections in Objective-C</h2>

<p>Collections are fundamental constructs. It is used to hold and manage other objects. The whole purpose of a collection is that it provides a common way to store and retrieve objects efficiently.</p>

<p>There are several different types of collections. While they all fulfil the same purpose of being able to hold other objects, they differ mostly in the way objects are retrieved. The most common collections used in Objective-C are:</p>

<p>NSSet</p>

<p>NSArray</p>

<p>NSDictionary</p>

<p>NSMutableSet</p>

<p>NSMutableArray</p>

<p>NSMutableDictionary</p>

<p>If you want to know more about these structures, please refer data storage in <a href="/objective_c/objective_c_foundation_framework.htm">Foundation Framework</a>.</p>

<h2>Fast enumeration Syntax</h2>

<p>Here is an example for fast enumeration.</p>

<p>Now when we compile and run the program, we will get the following result.</p>

<p>As you can see in the output, each of the objects in the array is printed in an order.</p>

<h2>Fast Enumeration Backwards</h2>

<p>Here is an example for reverseObjectEnumerator in fast enumeration.</p>

<p>Now when we compile and run the program, we will get the following result.</p>

<p>As you can see in the output, each of the objects in the array is printed but in the reverse order as compared to normal fast enumeration.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
for (classType variable in collectionObject )
{ 
  statements 
}
</pre>
<p>Here is an example for fast enumeration.</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

int main()
{
   NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
   NSArray *array = [[NSArray alloc]
   initWithObjects:@"string1", @"string2",@"string3",nil];
   for(NSString *aString in array)
   {
      NSLog(@"Value: %@",aString);
   }
   [pool drain];
   return 0;
}
</pre>
<p>Now when we compile and run the program, we will get the following result.</p>
<pre class="prettyprint notranslate">
2013-09-28 06:26:22.835 demo[7426] Value: string1
2013-09-28 06:26:22.836 demo[7426] Value: string2
2013-09-28 06:26:22.836 demo[7426] Value: string3
</pre>
<p>As you can see in the output, each of the objects in the array is printed in an order.</p>
<h2>Fast Enumeration Backwards</h2>
<pre class="prettyprint notranslate">
for (classType variable in [collectionObject reverseObjectEnumerator] )
{ 
  statements 
}
</pre>
<p>Here is an example for reverseObjectEnumerator in fast enumeration.</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

int main()
{
   NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
   NSArray *array = [[NSArray alloc]
   initWithObjects:@"string1", @"string2",@"string3",nil];
   for(NSString *aString in [array reverseObjectEnumerator])
   {
      NSLog(@"Value: %@",aString);
   }
   [pool drain];
   return 0;
}
</pre>
<p>Now when we compile and run the program, we will get the following result.</p>
<pre class="prettyprint notranslate">
2013-09-28 06:27:51.025 demo[12742] Value: string3
2013-09-28 06:27:51.025 demo[12742] Value: string2
2013-09-28 06:27:51.025 demo[12742] Value: string1
</pre>

<title>Obj-C Memory Management</title>

<h1>Obj-C Memory Management</h1>

<p>Memory management is one of the most important process in any programming language. It is the process by which the memory of objects are allocated when they are required and deallocated when they are no longer required.</p>

<p>Managing object memory is a matter of performance; if an application doesn't free unneeded objects, its memory footprint grows and performance suffers.</p>

<p>Objective-C Memory management techniques can be broadly classified into two types.</p>

<p>"Manual Retain-Release" or MRR</p>

<p>"Automatic Reference Counting" or ARC</p>

<h2>"Manual Retain-Release" or MRR</h2>

<p>In MRR, we explicitly manage memory by keeping track of objects on our own. This is implemented using a model, known as reference counting, that the Foundation class NSObject provides in conjunction with the runtime environment.</p>

<p>The only difference between MRR and ARC is that the retain and release is handled by us manually in former while its automatically taken care of in the latter.</p>

<p>The following figure represents an example of how memory management work in Objective-C.</p>

<p>The memory life cycle of the Class A object is shown in the above figure. As you can see, the retain count is shown below the object, when the retain count of an object becomes 0, the object is freed completely and its memory is deallocated for other objects to use.</p>

<p>Class A object is first created using alloc/init method available in NSObject. Now, the retain count becomes 1.</p>

<p>Now, class B retains the Class A's Object and the retain count of Class A's object becomes 2.</p>

<p>Then, Class C makes a copy of the object. Now, it is created as another instance of Class A with same values for the instance variables. Here, the retain count is 1 and not the retain count of the original object. This is represented by the dotted line in the figure.</p>

<p>The copied object is released by Class C using the release method and the retain count becomes 0 and hence the object is destroyed.</p>

<p>In case of the initial Class A Object, the retain count is 2 and it has to be released twice in order for it to be destroyed. This is done by release statements of Class A and Class B which decrements the retain count to 1 and 0, respectively. Finally, the object is destroyed.</p>

<h2>MRR Basic Rules</h2>

<p>We own any object we create: We create an object using a method whose name begins with "alloc", "new", "copy", or "mutableCopy"</p>

<p>In the implementation of an accessor method or an init method, to take ownership of an object we want to store as a property value.</p>

<p> To prevent an object from being invalidated as a side-effect of some other operation.</p>

<p>When we no longer need it, we must relinquish ownership of an object we own: We relinquish ownership of an object by sending it a release message or an autorelease message. In Cocoa terminology, relinquishing ownership of an object is therefore typically referred to as "releasing" an object.</p>

<p>You must not relinquish ownership of an object you do not own: This is just corollary of the previous policy rules stated explicitly.</p>

<p>When we compile the above program, we will get the following output.</p>

<h2>"Automatic Reference Counting" or ARC</h2>

<p>In Automatic Reference Counting or ARC, the system uses the same reference counting system as MRR, but it inserts the appropriate memory management method calls for us at compile-time. We are strongly encouraged to use ARC for new projects. If we use ARC, there is typically no need to understand the underlying implementation described in this document, although it may in some situations be helpful. For more about ARC, see <a target="_blank" rel="nofollow" href="https://developer.apple.com/library/ios/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html">Transitioning to ARC Release Notes.</a></p>

<p>As mentioned above, in ARC, we need not add release and retain methods since that will be taken care by the compiler. Actually, the underlying process of Objective-C is still the same. It uses the retain and release operations internally making it easier for the developer to code without worrying about these operations, which will reduce both the amount of code written and the possibility of memory leaks.</p>

<p>There was another principle called garbage collection, which is used in Mac OS-X along with MRR, but since its deprecation in OS-X Mountain Lion, it has not been discussed along with MRR. Also, iOS objects never had garbage collection feature. And with ARC, there is no use of garbage collection in OS-X too.</p>

<p>Here is a simple ARC example. Note this won't work on online compiler since it does not support ARC.</p>

<p>When we compile the above program, we will get the following output.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

@interface SampleClass:NSObject
- (void)sampleMethod;
@end

@implementation SampleClass

- (void)sampleMethod
{
   NSLog(@"Hello, World! \n");
}

- (void)dealloc 
{
  NSLog(@"Object deallocated");
  [super dealloc];
}

@end

int main()
{
   /* my first program in Objective-C */
   SampleClass *sampleClass = [[SampleClass alloc]init];
   [sampleClass sampleMethod];
   NSLog(@"Retain Count after initial allocation: %d", 
   [sampleClass retainCount]);
   [sampleClass retain];
   NSLog(@"Retain Count after retain: %d", [sampleClass retainCount]);
   [sampleClass release];
   NSLog(@"Retain Count after release: %d", [sampleClass retainCount]);
   [sampleClass release];
   NSLog(@"SampleClass dealloc will be called before this");
   // Should set the object to nil
   sampleClass = nil;
   return 0;
}
</pre>
<p>When we compile the above program, we will get the following output.</p>
<pre class="prettyprint notranslate">
2013-09-28 04:39:52.310 demo[8385] Hello, World!
2013-09-28 04:39:52.311 demo[8385] Retain Count after initial allocation: 1
2013-09-28 04:39:52.311 demo[8385] Retain Count after retain: 2
2013-09-28 04:39:52.311 demo[8385] Retain Count after release: 1
2013-09-28 04:39:52.311 demo[8385] Object deallocated
2013-09-28 04:39:52.311 demo[8385] SampleClass dealloc will be called before this
</pre>
<h2>"Automatic Reference Counting" or ARC</h2>
<p>In Automatic Reference Counting or ARC, the system uses the same reference counting system as MRR, but it inserts the appropriate memory management method calls for us at compile-time. We are strongly encouraged to use ARC for new projects. If we use ARC, there is typically no need to understand the underlying implementation described in this document, although it may in some situations be helpful. For more about ARC, see <a target="_blank" rel="nofollow" href="https://developer.apple.com/library/ios/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html">Transitioning to ARC Release Notes.</a></p>
<p>As mentioned above, in ARC, we need not add release and retain methods since that will be taken care by the compiler. Actually, the underlying process of Objective-C is still the same. It uses the retain and release operations internally making it easier for the developer to code without worrying about these operations, which will reduce both the amount of code written and the possibility of memory leaks.</p>
<p>There was another principle called garbage collection, which is used in Mac OS-X along with MRR, but since its deprecation in OS-X Mountain Lion, it has not been discussed along with MRR. Also, iOS objects never had garbage collection feature. And with ARC, there is no use of garbage collection in OS-X too.</p>
<p>Here is a simple ARC example. Note this won't work on online compiler since it does not support ARC.</p>
<pre class="prettyprint notranslate">
#import &lt;Foundation/Foundation.h&gt;

@interface SampleClass:NSObject
- (void)sampleMethod;
@end

@implementation SampleClass

- (void)sampleMethod
{
   NSLog(@"Hello, World! \n");
}

- (void)dealloc 
{
  NSLog(@"Object deallocated");
}

@end

int main()
{
   /* my first program in Objective-C */
   @autoreleasepool{
       SampleClass *sampleClass = [[SampleClass alloc]init];
       [sampleClass sampleMethod];
	   sampleClass = nil;
   }
   return 0;
}
</pre>
<p>When we compile the above program, we will get the following output.</p>
<pre class="prettyprint notranslate">
2013-09-28 04:45:47.310 demo[8385] Hello, World!
2013-09-28 04:45:47.311 demo[8385] Object deallocated
</pre>

<title>Objective-C Quick Guide</title>

<h1>Objective-C Quick Guide</h1>

<h1>Objective-C Overview</h1>

<p>Objective-C is general-purpose language that is developed on top of C Programming language by adding features of Small Talk programming language making it an object-oriented language. It is primarily used in developing iOS and Mac OS X operating systems as well as its applications.</p>

<p>Initially, Objective-C was developed by NeXT for its NeXTSTEP OS from whom it was taken over by Apple for its iOS and Mac OS X.</p>

<h2>Object-Oriented Programming</h2>

<p>Fully supports object-oriented programming, including the four pillars of object-oriented development:</p>

<p>Encapsulation</p>

<p>Data hiding</p>

<p>Inheritance</p>

<p>Polymorphism</p>

<h2>Example Code</h2>

<h2>Foundation Framework</h2>

<p>Foundation Framework provides large set of features and they are listed below.</p>

<p>It includes a list of extended datatypes like NSArray, NSDictionary, NSSet and so on. </p>

<p>It consists of a rich set of functions manipulating files, strings, etc.</p>

<p>It provides features for URL handling, utilities like date formatting, data handling, error handling, etc.</p>

<h2>Learning Objective-C</h2>

<p>The most important thing to do when learning Objective-C is to focus on concepts and not get lost in language technical details.</p>

<p>The purpose of learning a programming language is to become a better programmer; that is, to become more effective at designing and implementing new systems and at maintaining old ones.</p>

<h2>Use of Objective-C</h2>

<p>Objective-C, as mentioned earlier, is used in iOS and Mac OS X. It has large base of iOS users and largely increasing Mac OS X users. And since Apple focuses on quality first and its wonderful for those who started learning Objective-C. </p>

<h1>Objective-C Environment Setup</h1>

<h2>Try it Option Online</h2>

<p>You really do not need to set up your own environment to start learning Objective-C programming language. Reason is very simple, we already have set up Objective-C Programming environment online, so that you can compile and execute all the available examples online at the same time when you are doing your theory work. This gives you confidence in what you are reading and to check the result with different options. Feel free to modify any example and execute it online.</p>

<p>Try the following example using <b>Try it</b> option available at the top right corner of the below sample code box:</p>

<p>For most of the examples given in this tutorial, you will find <b>Try it</b> option, so just make use of it and enjoy your learning.</p>

<h2>Local Environment Setup</h2>

<p>If you are still willing to set up your environment for Objective-C programming language, you need the following two softwares available on your computer, (a) Text Editor and (b) The GCC Compiler.</p>

<h2>Text Editor</h2>

<p>This will be used to type your program. Examples of few editors include Windows Notepad, OS Edit command, Brief, Epsilon, EMACS, and vim or vi.</p>

<p>Name and version of text editor can vary on different operating systems. For example, Notepad will be used on Windows, and vim or vi can be used on windows as well as Linux or UNIX.</p>

<p>The files you create with your editor are called source files and contain program source code. The source files for Objective-C programs are typically named with the extension "<b>.m</b>".</p>

<p>Before starting your programming, make sure you have one text editor in place and you have enough experience to write a computer program, save it in a file, compile it and finally execute it.</p>

<h2>The GCC Compiler</h2>

<p>The source code written in source file is the human readable source for your program. It needs to be "compiled" to turn into machine language, so that your CPU can actually execute the program as per instructions given.</p>

<p>This GCC compiler will be used to compile your source code into final executable program. I assume you have basic knowledge about a programming language compiler.</p>

<p>GCC compiler is available for free on various platforms and the procedure to set up on various platforms is explained below.</p>

<h2>Installation on UNIX/Linux</h2>

<p>The initial step is install gcc along with gcc Objective-C package. This is done by:</p>

<p>The next step is to set up package dependencies using following command:</p>

<p>In order to get full features of Objective-C, download and install GNUStep. This can be done by downloading the package from <a href="http://wwwmain.gnustep.org/resources/downloads.php?site=ftp%3A%2F%2Fftp.gnustep.org%2Fpub%2Fgnustep%2F#core/" rel="nofollow" target="_blank">http://main.gnustep.org/resources/downloads.php</a>.</p>

<p>Now, we need to switch to the downloaded folder and unpack the file by:</p>

<p>Now, we need to switch to the folder gnustep-startup that gets created using:</p>

<p>Next, we need to configure the build process:</p>

<p>Then, we can build by:</p>

<p>We need to finally set up the environment by:</p>

<p>We have a helloWorld.m Objective-C as follows:</p>

<p>Now, we can compile and run a Objective-C file say helloWorld.m by switching to folder containing the file using cd and then using the following steps:</p>

<p>We can see the following output:</p>

<h2>Installation on Mac OS</h2>

<p>If you use Mac OS X, the easiest way to obtain GCC is to download the Xcode development environment from Apple's web site and follow the simple installation instructions. Once you have Xcode set up, you will be able to use GNU compiler for C/C++.</p>

<p>Xcode is currently available at <a href="http://developer.apple.com/technologies/tools/" rel="nofollow" target="_blank">developer.apple.com/technologies/tools/</a>.</p>

<h2>Installation on Windows</h2>

<p>In order to run Objective-C program on windows, we need to install MinGW and GNUStep Core. Both are available at <a href="http://www.gnustep.org/experience/Windows.html" rel="nofollow" target="_blank">gnustep.org/experience/Windows.html</a>.</p>

<p>First, we need to install the MSYS/MinGW System package. Then, we need to install the GNUstep Core package. Both of which provide a windows installer, which is self-explanatory.</p>

<p>Then to use Objective-C and GNUstep by selecting  Start -&gt; All Programs -&gt; GNUstep -&gt; Shell</p>

<p>Switch to the folder containing helloWorld.m</p>

<p>We can compile the program by using:</p>

<p>We can run the program by using:</p>

<p>We get the following output:</p>

<h1>Objective-C Program Structure</h1>

<p>Before we study basic building blocks of the Objective-C programming language, let us look a bare minimum Objective-C program structure so that we can take it as a reference in upcoming chapters.</p>

<h2>Objective-C Hello World Example</h2>

<p>A Objective-C program basically consists of the following parts:</p>

<p>Preprocessor Commands</p>

<p>Interface</p>

<p>Implementation</p>

<p>Method</p>

<p>Variables</p>

<p>Statements &amp; Expressions</p>

<p>Comments</p>

<p>Let us look at a simple code that would print the words "Hello World":</p>

<p>Let us look various parts of the above program:</p>

<p>The first line of the program <i>#import &lt;Foundation/Foundation.h&gt;</i> is a preprocessor command, which tells a Objective-C compiler to include Foundation.h file before going to actual compilation.</p>

<p>The next line <i>@interface SampleClass:NSObject</i> shows how to create an interface. It inherits NSObject, which is the base class of all objects.</p>

<p>The next line <i>- (void)sampleMethod;</i> shows how to declare a method.</p>

<p>The next line <i>@end</i> marks the end of an interface.</p>

<p>The next line <i>@implementation SampleClass</i> shows how to implement the interface SampleClass.</p>

<p>The next line <i>- (void)sampleMethod{}</i> shows the implementation of the sampleMethod.</p>

<p>The next line <i>@end</i> marks the end of an implementation.</p>

<p>The next line <i>int main()</i> is the main function where program execution begins.</p>

<p>The next line /*...*/ will be ignored by the compiler and it has been put to add additional comments in the program. So such lines are called comments in the program.</p>

<p>The next line <i>NSLog(...)</i> is another function available in Objective-C which causes the message "Hello, World!" to be displayed on the screen.</p>

<p>The next line <b>return 0;</b> terminates main()function and returns the value 0.</p>

<h2>Compile &amp; Execute Objective-C Program:</h2>

<h1>Objective-C Basic Syntax</h1>

<p>You have seen a basic structure of Objective-C program, so it will be easy to understand other basic building blocks of the Objective-C programming language.</p>

<h2>Tokens  in Objective-C</h2>

<p>A Objective-C program consists of various tokens and a token is either a keyword, an identifier, a constant, a string literal, or a symbol. For example, the following Objective-C statement consists of six tokens:</p>

<p>The individual tokens are:</p>

<h2>Semicolons ;</h2>

<p>In Objective-C program, the semicolon is a statement terminator. That is, each individual statement must be ended with a semicolon. It indicates the end of one logical entity.</p>

<p>For example, following are two different statements:</p>

<h2>Comments</h2>

<p>Comments are like helping text in your Objective-C program and they are ignored by the compiler. They start with /* and terminate with the characters */ as shown below:</p>

<p>You can not have comments with in comments and they do not occur within a string or character literals.</p>

<h2>Identifiers</h2>

<p>An Objective-C identifier is a name used to identify a variable, function, or any other user-defined item. An identifier starts with a letter A to Z or a to z or an underscore _ followed by zero or more letters, underscores, and digits (0 to 9).</p>

<p>Objective-C does not allow punctuation characters such as @, $, and % within identifiers. Objective-C is a <b>case-sensitive</b> programming language. Thus, <i>Manpower</i> and <i>manpower</i> are two different identifiers in Objective-C. Here are some examples of acceptable identifiers:</p>

<h2>Keywords</h2>

<p>The following list shows few of the reserved words in Objective-C. These reserved words may not be used as constant or variable or any other identifier names.</p>

<h2>Whitespace in Objective-C</h2>

<p>A line containing only whitespace, possibly with a comment, is known as a blank line, and an Objective-C compiler totally ignores it.</p>

<p>Whitespace is the term used in Objective-C to describe blanks, tabs, newline characters and comments. Whitespace separates one part of a statement from another and enables the compiler to identify where one element in a statement, such as int, ends and the next element begins. Therefore, in the following statement:</p>

<p>There must be at least one whitespace character (usually a space) between int and age for the compiler to be able to distinguish them. On the other hand, in the following statement,</p>

<p>no whitespace characters are necessary between fruit and =, or between = and apples, although you are free to include some if you wish for readability purpose.</p>

<h1>Objecive-C Data Types</h1>

<p>In the Objective-C programming language, data types refer to an extensive system used for declaring variables or functions of different types. The type of a variable determines how much space it occupies in storage and how the bit pattern stored is interpreted.</p>

<p>The types in Objective-C can be classified as follows:</p>

<p>They are arithmetic types and consist of the two types: (a) integer types and (b) floating-point types.</p>

<p>They are again arithmetic types and they are used to define variables that can only be assigned certain discrete integer values throughout the program.</p>

<p>The type specifier <i>void</i> indicates that no value is available.</p>

<p>They include (a) Pointer types, (b) Array types, (c) Structure types, (d) Union types and (e) Function types.</p>

<p>The array types and structure types are referred to collectively as the aggregate types. The type of a function specifies the type of the function's return value. We will see basic types in the following section whereas other types will be covered in the upcoming chapters.</p>

<h2>Integer Types</h2>

<p>Following table gives you details about standard integer types with its storage sizes and value ranges:</p>

<p>To get the exact size of a type or a variable on a particular platform, you can use the <b>sizeof</b> operator. The expression <i>sizeof(type)</i> yields the storage size of the object or type in bytes. Following is an example to get the size of int type on any machine:</p>

<p>When you compile and execute the above program, it produces the following result on Linux:</p>

<h2>Floating-Point Types</h2>

<p>Following table gives you details about standard float-point types with storage sizes and value ranges and their precision:</p>

<p>The header file float.h defines macros that allow you to use these values and other details about the binary representation of real numbers in your programs. Following example will print storage space taken by a float type and its range values:</p>

<p>When you compile and execute the above program, it produces the following result on Linux:</p>

<h2>The void Type</h2>

<p>The void type specifies that no value is available. It is used in three kinds of situations:</p>

<p>There are various functions in Objective-C which do not return value  or you can say they return void. A function with no return value has the return type as void. For example, <b>void exit (int status);</b></p>

<p>There are various functions in Objective-C which do not accept any parameter. A function with no parameter can accept as a void. For example, <b>int rand(void);</b></p>

<p>The void type may not be understood to you at this point, so let us proceed and we will cover  these concepts in upcoming chapters.</p>

<h1>Objective-C Variables</h1>

<p>A variable is nothing but a name given to a storage area that our programs can manipulate. Each variable in Objective-C has a specific type, which determines the size and layout of the variable's memory; the range of values that can be stored within that memory; and the set of operations that can be applied to the variable.</p>

<p>The name of a variable can be composed of letters, digits, and the underscore character. It must begin with either a letter or an underscore. Upper and lowercase letters are distinct because Objective-C is case-sensitive. Based on the basic types explained in previous chapter, there will be the following basic variable types:</p>

<p>Objective-C programming language also allows to define various other types of variables, which we will cover in subsequent chapters like Enumeration, Pointer, Array, Structure, Union, etc. For this chapter, let us study only basic variable types.</p>

<h2>Variable Definition in Objective-C:</h2>

<p>A variable definition means to tell the compiler where and how much to create the storage for the variable. A variable definition specifies a data type and contains a list of one or more variables of that type as follows:</p>

<p>Here, <b>type</b> must be a valid Objective-C data type including char, w_char, int, float, double, bool or any user-defined object, etc., and <b>variable_list</b> may consist of one or more identifier names separated by commas. Some valid declarations are shown here:</p>

<p>The line <b>int    i, j, k;</b> both declares and defines the variables i, j and k;  which instructs the compiler to create variables named i, j and k of type int.</p>

<p>Variables can be initialized (assigned an initial value) in their declaration. The initializer consists of an equal sign followed by a constant expression as follows:</p>

<p>Some examples are:</p>

<p>For definition without an initializer: variables with static storage duration are implicitly initialized with NULL (all bytes have the value 0); the initial value of all other variables is undefined.</p>

<h2>Variable Declaration in Objective-C:</h2>

<p>A variable declaration provides assurance to the compiler that there is one variable existing with the given type and name so that compiler proceed for further compilation without needing complete detail about the variable. A variable declaration has its meaning at the time of compilation only, compiler needs actual variable declaration at the time of linking of the program.</p>

<p>A variable declaration is useful when you are using multiple files and you define your variable in one of the files, which will be available at the time of linking of the program. You will use <b>extern</b> keyword to declare a variable at any place. Though you can declare a variable multiple times in your Objective-C program but it can be defined only once in a file, a function or a block of code.</p>

<h2>Example</h2>

<p>Try the following example, where variables have been declared at the top, but they have been defined and initialized inside the main function:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>Same concept applies on function declaration where you provide a function name at the time of its declaration and its actual definition can be given anywhere else. In the following example, it's explained using C function and as you know Objective-C supports C style functions also:</p>

<h2>Lvalues and Rvalues in Objective-C:</h2>

<p>There are two kinds of expressions in Objective-C:</p>

<p><b>lvalue :</b> An expression that is an lvalue may appear as either the left-hand or right-hand side of an assignment.</p>

<p><b>rvalue :</b> An expression that is a rvalue may appear on the right- but not left-hand side of an assignment.</p>

<p>Variables are lvalues and so may appear on the left-hand side of an assignment. Numeric literals are rvalues and so may not be assigned and can not appear on the left-hand side. Following is a valid statement:</p>

<p>But following is not a valid statement and would generate compile-time error:</p>

<h1>Objective-C Constants</h1>

<p>The constants refer to fixed values that the program may not alter during its execution. These fixed values are also called <b>literals</b>.</p>

<p>Constants can be of any of the basic data types like <i>an integer constant, a floating constant, a character constant, or a string literal</i>. There are also enumeration constants as well.</p>

<p>The <b>constants</b> are treated just like regular variables except that their values cannot be modified after their definition.</p>

<h2>Integer literals</h2>

<p>An integer literal can be a decimal, octal, or hexadecimal constant. A prefix specifies the base or radix: 0x or 0X for hexadecimal, 0 for octal, and nothing for decimal.</p>

<p>An integer literal can also have a suffix that is a combination of U and L, for unsigned and long, respectively. The suffix can be uppercase or lowercase and can be in any order.</p>

<p>Here are some examples of integer literals:</p>

<p>Following are other examples of various types of Integer literals:</p>

<h2>Floating-point literals</h2>

<p>A floating-point literal has an integer part, a decimal point, a fractional part, and an exponent part. You can represent floating point literals either in decimal form or exponential form.</p>

<p>While representing using decimal form, you must include the decimal point, the exponent, or both and while representing using exponential form, you must include the integer part, the fractional part, or both. The signed exponent is introduced by e or E.</p>

<p>Here are some examples of floating-point literals:</p>

<h2>Character constants</h2>

<p>Character literals are enclosed in single quotes e.g., 'x' and can be stored in a simple variable of <b>char</b> type.</p>

<p>A character literal can be a plain character (e.g., 'x'), an escape sequence (e.g., '\t'), or a universal character (e.g., '\u02C0'). </p>

<p>There are certain characters in C when they are proceeded by a backslash they will have special meaning and they are used to represent like newline (\n) or tab (\t). Here, you have a list of some of such escape sequence codes:</p>

<p>Following is the example to show few escape sequence characters:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>String literals</h2>

<p>String literals or constants are enclosed in double quotes "". A string contains characters that are similar to character literals: plain characters, escape sequences, and universal characters.</p>

<p>You can break a long line into multiple lines using string literals and separating them using whitespaces.</p>

<p>Here are some examples of string literals. All the three forms are identical strings.</p>

<h2>Defining Constants</h2>

<p>There are two simple ways in C to define constants:</p>

<p>Using <b>#define</b> preprocessor.</p>

<p>Using <b>const</b> keyword.</p>

<h2>The #define Preprocessor</h2>

<p>Following is the form to use #define preprocessor to define a constant:</p>

<p>Following example explains it in detail:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>The const Keyword</h2>

<p>You can use <b>const</b> prefix to declare constants with a specific type as follows:</p>

<p>Following example explains it in detail:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>Note that it is a good programming practice to define constants in CAPITALS.</p>

<h1>Objective-C Operators</h1>

<p>An operator is a symbol that tells the compiler to perform specific mathematical or logical manipulations. Objective-C language is rich in built-in operators and provides following types of operators:</p>

<p>Arithmetic Operators</p>

<p>Relational Operators</p>

<p>Logical Operators</p>

<p>Bitwise Operators</p>

<p>Assignment Operators</p>

<p>Misc Operators</p>

<p>This tutorial will explain the arithmetic, relational, logical, bitwise, assignment and other operators one by one.</p>

<h2>Arithmetic Operators</h2>

<p>Following table shows all the arithmetic operators supported by Objective-C language. Assume variable <b>A</b> holds 10 and variable <b>B</b> holds 20, then:</p>

<p><a href="/objective_c/objective_c_arithmetic_operators.htm" title="Arithmetic Operators in Objective-C">Show Examples</a></p>

<h2>Relational Operators</h2>

<p>Following table shows all the relational operators supported by Objective-C language. Assume variable <b>A</b> holds 10 and variable <b>B</b> holds 20, then:</p>

<p><a href="/objective_c/objective_c_relational_operators.htm" title="Relational Operators in Objective-C">Show Examples</a></p>

<h2>Logical Operators</h2>

<p>Following table shows all the logical operators supported by Objective-C language. Assume variable <b>A</b> holds 1 and variable <b>B</b> holds 0, then:</p>

<p><a href="/objective_c/objective_c_logical_operators.htm" title="Logical Operators in Objective-C">Show Examples</a></p>

<h2>Bitwise Operators</h2>

<p>Bitwise operator works on bits and perform bit by bit operation. The truth tables for &amp;, |, and ^ are as follows:</p>

<p>Assume if A = 60; and B = 13; now in binary format they will be as follows:</p>

<p>A = 0011 1100</p>

<p>B = 0000 1101</p>

<p>-----------------</p>

<p>A&amp;B = 0000 1100</p>

<p>A|B = 0011 1101</p>

<p>A^B = 0011 0001</p>

<p>~A&nbsp; = 1100 0011</p>

<p>The Bitwise operators supported by Objective-C language are listed in the following table. Assume variable A holds 60 and variable B holds 13 then:</p>

<p><a href="/objective_c/objective_c_bitwise_operators.htm" title="Bitwise Operators in Objective-C">Show Examples</a></p>

<h2>Assignment Operators</h2>

<p>There are following assignment operators supported by Objective-C language:</p>

<p><a href="/objective_c/objective_c_assignment_operators.htm" title="Assignment Operators in Objective-C">Show Examples</a></p>

<h2> Misc Operators &map; sizeof &amp; ternary</h2>

<p>There are few other important operators including <b>sizeof</b> and <b>? :</b>  supported by Objective-C Language.</p>

<p><a href="/objective_c/objective_c_sizeof_operator.htm" title="sizeof operator in C">Show Examples</a></p>

<h2>Operators Precedence in Objective-C</h2>

<p>Operator precedence determines the grouping of terms in an expression. This affects how an expression is evaluated. Certain operators have higher precedence than others; for example, the multiplication operator has higher precedence than the addition operator:</p>

<p>For example, x = 7 + 3 * 2; here, x is assigned 13, not 20 because operator * has higher precedence than +, so it first gets multiplied with 3*2 and then adds into 7.</p>

<p>Here, operators with the highest precedence appear at the top of the table, those with the lowest appear at the bottom. Within an expression, higher precedence operators will be evaluated first.</p>

<p><a href="/objective_c/objective_c_operators_precedence.htm" title="Operators Precedence in Objective-C">Show Examples</a></p>

<h1>Objective-C Loops</h1>

<p>There may be a situation, when you need to execute a block of code several number of times. In general, statements are executed sequentially: The first statement in a function is executed first, followed by the second, and so on.</p>

<p>Programming languages provide various control structures that allow for more complicated execution paths.</p>

<p>A loop statement allows us to execute a statement or group of statements multiple times and following is the general form of a loop statement in most of the programming languages:</p>

<p>Objective-C programming language provides the following types of loop to handle looping requirements. Click the following links to check their details.</p>

<h2>Loop Control Statements:</h2>

<p>Loop control statements change execution from its normal sequence. When execution leaves a scope, all automatic objects that were created in that scope are destroyed.</p>

<p>Objective-C supports the following control statements. Click the following links to check their details.</p>

<h2>The Infinite Loop:</h2>

<p>A loop becomes infinite loop if a condition never becomes false. The <b>for</b> loop is traditionally used for this purpose. Since none of the three expressions that form the for loop are required, you can make an endless loop by leaving the conditional expression empty.</p>

<p>When the conditional expression is absent, it is assumed to be true. You may have an initialization and increment expression, but Objective-C programmers more commonly use the for(;;) construct to signify an infinite loop.</p>

<h1>Objective-C Decision Making</h1>

<p>Decision making structures require that the programmer specify one or more conditions to be evaluated or tested by the program, along with a statement or statements to be executed if the condition is determined to be true, and optionally, other statements to be executed if the condition is determined to be false.</p>

<p>Following is the general form of a typical decision making structure found in most of the programming languages:</p>

<p>Objective-C programming language assumes any <b>non-zero</b> and <b>non-null</b> values as <b>true</b>, and if it is either <b>zero</b> or <b>null</b>, then it is assumed as <b>false</b> value.</p>

<p>Objective-C programming language provides following types of decision making statements. Click the following links to check their details:</p>

<h2>The ? : Operator:</h2>

<p>We have covered <b>conditional operator ? :</b> in previous chapter which can be used to replace <b>if...else</b> statements. It has the following general form:</p>

<p>Where Exp1, Exp2, and Exp3 are expressions. Notice the use and placement of the colon.</p>

<p>The value of a ? expression is determined like this: Exp1 is evaluated. If it is true, then Exp2 is evaluated and becomes the value of the entire ? expression. If Exp1 is false, then Exp3 is evaluated and its value becomes the value of the expression.</p>

<h1>Objective-C Functions</h1>

<p>A function is a group of statements that together perform a task. Every Objective-C program has one C function, which is <b>main()</b>, and all of the most trivial programs can define additional functions.</p>

<p>You can divide up your code into separate functions. How you divide up your code among different functions is up to you, but logically the division usually is so each function performs a specific task.</p>

<p>A function <b>declaration</b> tells the compiler about a function's name, return type, and parameters. A function <b>definition</b> provides the actual body of the function.</p>

<p>Basically in Objective-C, we call the function as method.</p>

<p>The Objective-C foundation framework provides numerous built-in methods that your program can call. For example, method <b>appendString()</b> to append string to another string.</p>

<p>A method is known with various names like a function  or a sub-routine or a procedure, etc.</p>

<h2>Defining a Method</h2>

<p>The general form of a method definition in Objective-C programming language is as follows:</p>

<p>A method definition in Objective-C programming language consists of a <i>method header</i> and a <i>method body</i>. Here are all the parts of a method:</p>

<p><b>Return Type:</b> A method may return a value. The <b>return_type</b> is the data type of the value the function returns. Some methods perform the desired operations without returning a value. In this case, the return_type is the keyword <b>void</b>.</p>

<p><b>Method Name:</b> This is the actual name of the method. The method name and the parameter list together constitute the method signature.</p>

<p><b>Arguments:</b> A argument is like a placeholder. When a function is invoked, you pass a value to the argument. This value is referred to as actual parameter or argument. The parameter list refers to the type, order, and number of the arguments of a method. Arguments are optional; that is, a method may contain no argument.</p>

<p><b>Joining Argument:</b> A joining argument is to make it easier to read and to make it clear while calling it.</p>

<p><b>Method Body:</b> The method body contains a collection of statements that define what the method does.</p>

<h2>Example:</h2>

<p>Following is the source code for a method called <b>max()</b>. This method takes two parameters num1 and num2 and returns the maximum between the two:</p>

<h2>Method Declarations:</h2>

<p>A method <b>declaration</b> tells the compiler about a function name and how to call the method. The actual body of the function can be defined separately.</p>

<p>A method declaration has the following parts:</p>

<p>For the above-defined function max(), following is the method declaration:</p>

<p>Method declaration is required when you define a method in one source file and you call that method in another file. In such case you should declare the function at the top of the file calling the function.</p>

<h2>Calling a method:</h2>

<p>While creating a Objective-C method, you give a definition of what the function has to do. To use a method, you will have to call that function to perform the defined task.</p>

<p>When a program calls a function, program control is transferred to the called method. A called method performs defined task, and when its return statement is executed or when its function-ending closing brace is reached, it returns program control back to the main program.</p>

<p>To call a method, you simply need to pass the required parameters along with method name, and if method returns a value, then you can store returned value. For example:</p>

<p>I kept max() function along with main() function and complied the source code. While running final executable, it would produce the following result:</p>

<h2>Function Arguments:</h2>

<p>If a function is to use arguments, it must declare variables that accept the values of the arguments. These variables are called the <b>formal parameters</b> of the function.</p>

<p>The formal parameters behave like other local variables inside the function and are created upon entry into the function and destroyed upon exit.</p>

<p>While calling a function, there are two ways that arguments can be passed to a function:</p>

<p>By default, Objective-C uses <b>call by value</b> to pass arguments. In general, this means that code within a function cannot alter the arguments used to call the function, and above-mentioned example while calling max() function used the same method.</p>

<h1>Objective-C Blocks</h1>

<p>An Objective-C class defines an object that combines data with related behavior. Sometimes, it makes sense just to represent a single task or unit of behavior, rather than a collection of methods.</p>

<p>Blocks are a language-level feature added to C, Objective-C and C++ which allow you to create distinct segments of code that can be passed around to methods or functions as if they were values. Blocks are Objective-C objects which means they can be added to collections like NSArray or NSDictionary. They also have the ability to capture values from the enclosing scope, making them similar to closures or lambdas in other programming languages </p>

<h2>Simple Block declaration syntax</h2>

<p>Simple block implementation</p>

<h2>Here is a simple example</h2>

<h2>We can invoke the block using</h2>

<h2>Blocks Take Arguments and Return Values</h2>

<p>Blocks can also take arguments and return values just like methods and functions.</p>

<p>Here is a simple example to implement and invoke a block with arguments and return values.</p>

<h2>Blocks using type definitions</h2>

<p>Here is a simple example using typedef in block. Please note this sample <b>doesn't work</b> on the <b>online compiler</b> for now. Use <b>XCode</b> to run the same.</p>

<p>Let us compile and execute it, it will produce the following result:</p>

<p>Blocks are used more in iOS applications and Mac OS X. So its more important to understand the usage of blocks.</p>

<h1>Objective-C Numbers</h1>

<p>In Objective-C programming language, in order to save the basic data types like int, float, bool in object form,</p>

<p>Objective-C provides a range of methods to work with NSNumber and important ones are listed in following table.</p>

<p>Creates and returns an NSNumber object containing a given value, treating it as a BOOL.</p>

<p>Creates and returns an NSNumber object containing a given value, treating it as a signed char.</p>

<p>Creates and returns an NSNumber object containing a given value, treating it as a double.</p>

<p>Creates and returns an NSNumber object containing a given value, treating it as a float.</p>

<p>Creates and returns an NSNumber object containing a given value, treating it as a signed int.</p>

<p>Creates and returns an NSNumber object containing a given value, treating it as an NSInteger.</p>

<p>Returns the receiver's value as a BOOL.</p>

<p>Returns the receiver's value as a char.</p>

<p>Returns the receiver's value as a double. </p>

<p>Returns the receiver's value as a float.</p>

<p>Returns the receiver's value as an NSInteger. </p>

<p>Returns the receiver's value as an int.</p>

<p>Returns the receiver's value as a human-readable string.</p>

<p>Here is a simple example for using NSNumber which multiplies two numbers and returns the product.</p>

<p>Now when we compile and run the program, we will get the following result.</p>

<h1>Objective-C Arrays</h1>

<p>Objective-C programming language provides a data structure called <b>the array</b>, which can store a fixed-size sequential collection of elements of the same type. An array is used to store a collection of data, but it is often more useful to think of an array as a collection of variables of the same type.</p>

<p>Instead of declaring individual variables, such as number0, number1, ..., and number99, you declare one array variable such as numbers and use numbers[0], numbers[1], and ..., numbers[99] to represent individual variables. A specific element in an array is accessed by an index. </p>

<p>All arrays consist of contiguous memory locations. The lowest address corresponds to the first element and the highest address to the last element.</p>

<h2>Declaring Arrays</h2>

<p>To declare an array in Objective-C, a programmer specifies the type of the elements and the number of elements required by an array as follows:</p>

<p>This is called a <i>single-dimensional</i> array. The <b>arraySize</b> must be an integer constant greater than zero and <b>type</b> can be any valid Objective-C data type. For example, to declare a 10-element array called <b>balance</b> of type double, use this statement:</p>

<p>Now, <i>balance</i> is a variable array, which is sufficient to hold up to 10 double numbers.</p>

<h2>Initializing Arrays</h2>

<p>You can initialize an array in Objective-C either one by one or using a single statement as follows:</p>

<p>The number of values between braces { } can not be larger than the number of elements that we declare for the array between square brackets [ ]. Following is an example to assign a single element of the array:</p>

<p>If you omit the size of the array, an array just big enough to hold the initialization is created.  Therefore, if you write:</p>

<p>You will create exactly the same array as you did in the previous example.</p>

<p>The above statement assigns element number 5th in the array a value of 50.0. Array with 4th index will be 5th, i.e., last element because all arrays have 0 as the index of their first element which is also called base index. Following is the pictorial representation  of the same array we discussed above:</p>

<h2>Accessing Array Elements</h2>

<p>An element is accessed by indexing the array name. This is done by placing the index of the element within square brackets after the name of the array. For example:</p>

<p>The above statement will take 10th element from the array and assign the value to salary variable. Following is an example, which will use all the above mentioned three concepts viz. declaration, assignment and accessing arrays:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Objective-C Arrays in Detail</h2>

<p>Arrays are important to Objective-C and need lots of more details. There are following few important concepts related to array which should be clear to a Objective-C programmer:</p>

<h1>Objective-C Pointers</h1>

<p>Pointers in Objective-C are easy and fun to learn. Some Objective-C programming tasks are performed more easily with pointers, and other tasks, such as dynamic memory allocation, cannot be performed without using pointers. So it becomes necessary to learn pointers to become a perfect Objective-C programmer. Let's start learning them in simple and easy steps.</p>

<p>As you know, every variable is a memory location and every memory location has its address defined which can be accessed using ampersand (&amp;) operator, which denotes an address in memory. Consider the following example, which will print the address of the variables defined:</p>

<p>When the above code is compiled and executed, it produces the result something as follows:</p>

<p>So, you understood what is memory address and how to access it, so base of the concept is over. Now let us see what is a pointer.</p>

<h2>What Are Pointers?</h2>

<p>A <b>pointer</b> is a variable whose value is the address of another variable, i.e., direct address of the memory location. Like any variable or constant, you must declare a pointer before you can use it to store any variable address. The general form of a pointer variable declaration is:</p>

<p>Here, <b>type</b> is the pointer's base type; it must be a valid Objective-C data type and <b>var-name</b> is the name of the pointer variable. The asterisk * you used to declare a pointer is the same asterisk that you use for multiplication. However, in this statement the asterisk is being used to designate a variable as a pointer. Following are the valid pointer declaration:</p>

<p>The actual data type of the value of all pointers, whether integer, float, character, or otherwise, is the same, a long hexadecimal number that represents a memory address. The only difference between pointers of different data types is the data type of the variable or constant that the pointer points to.</p>

<h2>How to use Pointers?</h2>

<p>There are few important operations, which we will do with the help of pointers very frequently. <b>(a)</b> we define a pointer variable, <b>(b)</b> assign the address of a variable to a pointer, and <b>(c)</b> finally access the value at the address available in the pointer variable. This is done by using unary operator <b>*</b> that returns the value of the variable located at the address specified by its operand. Following example makes use of these operations:</p>

<p>When the above code is compiled and executed, it produces the result something as follows:</p>

<h2>NULL Pointers in Objective-C</h2>

<p>It is always a good practice to assign a NULL value to a pointer variable in case you do not have exact address to be assigned. This is done at the time of variable declaration. A pointer that is assigned NULL is called a <b>null</b> pointer.</p>

<p>The NULL pointer is a constant with a value of zero defined in several standard libraries. Consider the following program:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>On most of the operating systems, programs are not permitted to access memory at address 0 because that memory is reserved by the operating system. However, the memory address 0 has special significance; it signals that the pointer is not intended to point to an accessible memory location. But by convention, if a pointer contains the null (zero) value, it is assumed to point to nothing.</p>

<p>To check for a null pointer, you can use an if statement as follows:</p>

<h2>Objective-C Pointers in Detail:</h2>

<p>Pointers have many but easy concepts and they are very important to Objective-C programming. There are following few important pointer concepts, which should be clear to a Objective-C programmer:</p>

<h1>Objective-C Strings</h1>

<p>The string in Objective-C programming language is represented using NSString and its subclass NSMutableString provides several ways for creating string objects. The simplest way to create a string object is to use the Objective-C  @"..." construct: </p>

<p>A simple example for creating and printing a string is shown below.</p>

<p>When the above code is compiled and executed, it produces result something as follows:</p>

<p>Objective-C supports a wide range of methods for manipulate strings:</p>

<p>Returns a capitalized representation of the receiver.</p>

<p>Returns the character at a given array position.</p>

<p>Returns the floating-point value of the receiver&rsquo;s text as a double.</p>

<p>Returns the floating-point value of the receiver&rsquo;s text as a float.</p>

<p>Returns a Boolean value that indicates whether a given string matches the beginning characters of the receiver.</p>

<p>Returns a Boolean value that indicates whether a given string matches the ending characters of the receiver.</p>

<p>Returns an NSString object initialized by using a given format string as a template into which the remaining argument values are substituted.</p>

<p>Returns the NSInteger value of the receiver&rsquo;s text.</p>

<p>Returns a Boolean value that indicates whether a given string is equal to the receiver using a literal Unicode-based comparison.</p>

<p>Returns the number of Unicode characters in the receiver.</p>

<p>Returns lowercased representation of the receiver.</p>

<p>Finds and returns the range of the first occurrence of a given string within the receiver.</p>

<p>Returns a string made by appending to the receiver a string constructed from a given format string and the following arguments.</p>

<p>Returns a new string made by removing from both ends of the receiver characters contained in a given character set.</p>

<p>Returns a new string containing the characters of the receiver from the one at a given index to the end.</p>

<p>Following example makes use of few of the above-mentioned functions:</p>

<p>When the above code is compiled and executed, it produces result something as follows:</p>

<p>You can find a complete list of Objective-C NSString related methods in <a rel="nofollow" href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSString_Class/Reference/NSString.html" target="_blank" title="NSString Class Reference">NSString Class Reference.</a></p>

<h1>Objective-C Structures</h1>

<p>Objective-C arrays allow you to define type of variables that can hold several data items of the same kind but <b>structure</b> is another user-defined data type available in Objective-C programming which allows you to combine data items of different kinds.</p>

<p>Structures are used to represent a record, Suppose you want to keep track of your books in a library. You might want to track the following attributes about each book:</p>

<p>Title</p>

<p>Author</p>

<p>Subject</p>

<p>Book ID</p>

<h2>Defining a Structure</h2>

<p>To define a structure, you must use the <b>struct</b> statement. The struct statement defines a new data type, with more than one member for your program. The format of the struct statement is this:</p>

<p>The <b>structure tag</b> is optional and each member definition is a normal variable definition, such as int i; or float f; or any other valid variable definition. At the end of the structure's definition, before the final semicolon, you can specify one or more structure variables but it is optional. Here is the way you would declare the Book structure:</p>

<h2>Accessing Structure Members</h2>

<p>To access any member of a structure, we use the <b>member access operator (.)</b>. The member access operator is coded as a period between the structure variable name and the structure member that we wish to access. You would use <b>struct</b> keyword to define variables of structure type. Following is the example to explain usage of structure:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Structures as Function Arguments</h2>

<p>You can pass a structure as a function argument in very similar way as you pass any other variable or pointer. You would access structure variables in the similar way as you have accessed in the above example:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Pointers to Structures</h2>

<p>You can define pointers to structures in very similar way as you define pointer to any other variable as follows:</p>

<p>Now, you can store the address of a structure variable in the above-defined pointer variable. To find the address of a structure variable, place the &amp; operator before the structure's name as follows:</p>

<p>To access the members of a structure using a pointer to that structure, you must use the -&gt; operator as follows:</p>

<p>Let us re-write above example using structure pointer, hope this will be easy for you to understand the concept:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Bit Fields</h2>

<p>Bit Fields allow the packing of data in a structure. This is especially useful when memory or data storage is at a premium. Typical examples:</p>

<p>Packing several objects into a machine word. e.g. 1 bit flags can be compacted.</p>

<p>Reading external file formats -- non-standard file formats could be read in. E.g. 9 bit integers.</p>

<p>Objective-C allows us do this in a structure definition by putting :bit length after the variable. For example:</p>

<p>Here, the packed_struct contains 6 members: Four 1 bit flags f1..f3, a 4 bit type and a 9 bit my_int.</p>

<p>Objective-C automatically packs the above bit fields as compactly as possible, provided that the maximum length of the field is less than or equal to the integer word length of the computer. If this is not the case, then some compilers may allow memory overlap for the fields whilst other would store the next field in the next word.</p>

<h1>Objective-C Preprocessors</h1>

<p>The <b>Objective-C Preprocessor</b> is not part of the compiler, but is a separate step in the compilation process. In simplistic terms, an Objective-C Preprocessor is just a text substitution tool and it instructs compiler to do required pre-processing before actual compilation. We'll refer to the Objective-C Preprocessor as the OCPP.</p>

<p>All preprocessor commands begin with a pound symbol (#). It must be the first nonblank character, and for readability, a preprocessor directive should begin in first column. Following section lists down all important preprocessor directives:</p>

<h2>Preprocessors Examples</h2>

<p>Analyze the following examples to understand various directives.</p>

<p>This directive tells the OCPP to replace instances of MAX_ARRAY_LENGTH with 20. Use <i>#define</i> for constants to increase readability.</p>

<p>These directives tell the OCPP to get foundation.h from <b>Foundation Framework</b> and add the text to the current source file. The next line tells OCPP to get <b>myheader.h</b> from the local directory and add the content to the current source file.</p>

<p>This tells the OCPP to undefine existing FILE_SIZE and define it as 42.</p>

<p>This tells the OCPP to define MESSAGE only if MESSAGE isn't already defined.</p>

<p>This tells the OCPP to do the process the statements enclosed if DEBUG is defined. This is useful if you pass the <i>-DDEBUG</i> flag to gcc compiler at the time of compilation. This will define DEBUG, so you can turn debugging on and off on the fly during compilation.</p>

<h2>Predefined Macros</h2>

<p>ANSI C defines a number of macros. Although each one is available for your use in programming, the predefined macros should not be directly modified.</p>

<p>Let's try the following example:</p>

<p>When the above code in a file <b>main.m</b> is compiled and executed, it produces the following result:</p>

<h2>Preprocessor Operators</h2>

<p>The Objective-C preprocessor offers following operators to help you in creating macros:</p>

<h5>Macro Continuation (\)</h5>

<p>A macro usually must be contained on a single line. The macro continuation operator is used to continue a macro that is too long for a single line. For example:</p>

<h5> Stringize (#)</h5>

<p>The stringize or number-sign operator ('#'), when used within a macro definition, converts a macro parameter into a string constant. This operator may be used only in a macro that has a specified argument or parameter list. For example:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h5>Token Pasting (##)</h5>

<p>The token-pasting operator (##) within a macro definition combines two arguments. It permits two separate tokens in the macro definition to be joined into a single token. For example:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>How it happened, because this example results in the following actual output from the preprocessor:</p>

<p>This example shows the concatenation of token##n into token34 and here we have used both <b>stringize</b> and <b>token-pasting</b>.</p>

<h5>The defined() Operator</h5>

<p>The preprocessor <b>defined</b> operator is used in constant expressions to determine if an identifier is defined using #define. If the specified identifier is defined, the value is true (non-zero). If the symbol is not defined, the value is false (zero). The defined operator is specified as follows:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Parameterized Macros</h2>

<p>One of the powerful functions of the OCPP is the ability to simulate functions using parameterized macros. For example, we might have some code to square a number as follows:</p>

<p>We can rewrite above code using a macro as follows:</p>

<p>Macros with arguments must be defined using the <b>#define</b> directive before they can be used. The argument list is enclosed in parentheses and must immediately follow the macro name. Spaces are not allowed between macro name and open parenthesis. For example:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>Objective-C Typedef</h1>

<p>The Objective-C programming language provides a keyword called <b>typedef</b>, which you can use to give a type a new name. Following is an example to define a term <b>BYTE</b> for one-byte numbers:</p>

<p>By convention, uppercase letters are used for these definitions to remind the user that the type name is really a symbolic abbreviation, but you can use lowercase, as follows:</p>

<p>You can use <b>typedef</b> to give a name to user-defined data type as well. For example, you can use typedef with structure to define a new data type and then use that data type to define structure variables directly as follows:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>typedef vs #define</h2>

<p>The <b>#define</b> is a Objective-C directive, which is also used to define the aliases for various data types similar to <b> typedef</b> but with following differences:</p>

<p>The <b>typedef</b> is limited to giving symbolic names to types only whereas <b>#define</b> can be used to define alias for values as well, like you can define 1 as ONE, etc.</p>

<p>The <b>typedef</b> interpretation is performed by the compiler where as <b>#define</b> statements are processed by the pre-processor.</p>

<p>Following is a simplest usage of #define:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>Objective-C Type Casting</h1>

<p>Type casting is a way to convert a variable from one data type  to another data type. For example, if you want to store a long value into a simple integer then you can type cast long to int. You can  convert values from one type to another explicitly using the <b>cast operator</b> as follows:</p>

<p>In Objective-C, we generally use CGFloat for doing floating point operation, which is derived from basic type of float in case of 32-bit and double in case of 64-bit. Consider the following example where the cast operator causes the division of one integer variable by another to be performed as a floating-point operation:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>It should be noted here that the cast operator has precedence over division, so the value of <b>sum</b> is first converted to type <b>double</b> and finally it gets divided by count yielding a double value.</p>

<p>Type conversions can be implicit which is performed by the compiler automatically or it can be specified explicitly through the use of the <b>cast operator</b>. It is considered good programming practice to use the cast operator whenever type conversions are necessary.</p>

<h2>Integer Promotion</h2>

<p>Integer promotion is the process by which values of integer type "smaller" than <b>int</b> or <b>unsigned int</b> are converted either to <b>int</b> or <b>unsigned int</b>. Consider an example of adding a character in an int:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>Here, value of sum is coming as 116 because compiler is doing integer promotion and converting the value of 'c' to ascii before performing  actual addition operation.</p>

<h2>Usual Arithmetic Conversion</h2>

<p>The <b>usual arithmetic conversions</b> are implicitly performed to cast their values in a common type. Compiler first performs <i>integer promotion</i>, if operands still have different types then they are converted to the type that appears highest in the following hierarchy:</p>

<p>The usual arithmetic conversions are not performed for the assignment operators, nor for the logical operators &amp;&amp; and ||. Let us take following example to understand the concept:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>Here, it is simple to understand that first c gets converted to integer but because final value is float, so usual arithmetic conversion applies and compiler converts i and c into float and add them yielding a float result.</p>

<h1>Objective-C Log Handling</h1>

<h2>NSLog method</h2>

<p>In order to print logs, we use the NSLog method in Objective-C programming language which we have used right from the Hello World example.</p>

<p>Let us look at a simple code that would print the words "Hello World":</p>

<p>Now, when we compile and run the program, we will get the following result.</p>

<h2>Disabling logs in Live apps</h2>

<p>Since the NSLogs we use in our application, it will be printed in logs of device and it is not good to print logs in a live build. Hence, we use a type definition for printing logs and we can use them as shown below.</p>

<p>Now, when we compile and run the program in debug mode, we will get the following result.</p>

<p>Now, when we compile and run the program in release mode, we will get the following result.</p>

<h1>Objective-C Error Handling</h1>

<p>In Objective-C programming, error handling is provided with NSError class available in <b>Foundation framework.</b></p>

<p>An NSError object encapsulates richer and more extensible error information than is possible using only an error code or error string. The core attributes of an NSError object are an error domain (represented by a string), a domain-specific error code and a user info dictionary containing application specific information.</p>

<h2>NSError</h2>

<p>NSError Object consists of:</p>

<p>Domain: The error domain can be one of the predefined NSError domains or an arbitrary string describing a custom domain and domain must not be nil.</p>

<p>Code: The error code for the error.</p>

<p>User Info: The userInfo dictionary for the error and userInfo may be nil.</p>

<p>The following example shows how to create a custom error</p>

<p>Here is complete code of the above error sample passed as reference to an pointer</p>

<p>In the above example, we return a name if the id is 1, otherwise we set the user-defined error object.</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>Command-Line Arguments</h1>

<p>It is possible to pass some values from the command line to your Objective-C programs when they are executed. These values are called <b>command line arguments</b> and many times they are important for your program, especially when you want to control your program from outside instead of hard coding those values inside the code.</p>

<p>The command line arguments are handled using main() function arguments where <b>argc</b> refers to the number of arguments passed, and <b>argv[]</b> is a pointer array, which points to each argument passed to the program. Following is a simple example, which checks if there is any argument supplied from the command line and take action accordingly:</p>

<p>When the above code is compiled and executed with a single argument, say "testing", it produces the following result.</p>

<p>When the above code is compiled and executed with two arguments, say testing1 and testing2, it produces the following result.</p>

<p>When the above code is compiled and executed without passing any argument, it produces the following result.</p>

<p>It should be noted that <b>argv[0]</b> holds the name of the program itself and <b>argv[1]</b> is a pointer to the first command-line argument supplied, and *argv[n] is the last argument. If no arguments are supplied, argc will be one, otherwise if you pass one argument, then <b>argc</b> is set at 2.</p>

<p>You pass all the command line arguments  separated by a space, but if argument itself has a space, then you can pass such arguments by putting them inside double quotes "" or single quotes ''. Let us re-write above example once again where we will print program name and we also pass a command-line argument by putting inside double quotes:</p>

<p>When the above code is compiled and executed with a single argument separated by space but inside double quotes say "Testing1 Testing2", it produces the following result.</p>

<h1>Objective-C Classes & Objects</h1>

<p>The main purpose of Objective-C programming language is to add object orientation to the C programming language and classes are the central feature of Objective-C that support object-oriented programming and are often called user-defined types.</p>

<p>A class is used to specify the form of an object and it combines data representation and methods for manipulating that data into one neat package. The data and methods within a class are called members of the class.</p>

<h2>Objective-C characteristics</h2>

<p>The class is defined in two different sections namely <b>@interface</b> and <b>@implementation</b>.</p>

<p>Almost everything is in form of objects.</p>

<p>Objects receive messages and objects are often referred as receivers.</p>

<p>Objects contain instance variables.</p>

<p>Objects and instance variables have scope.</p>

<p>Classes hide an object's implementation.</p>

<p>Properties are used to provide access to class instance variables in other classes.</p>

<h2>Objective-C Class Definitions:</h2>

<p>When you define a class, you define a blueprint for a data type. This doesn't actually define any data, but it does define what the class name means, that is, what an object of the class will consist of and what operations can be performed on such an object.</p>

<p>A class definition starts with the keyword <b>@interface</b> followed by the interface(class) name; and the class body, enclosed by a pair of curly braces. In Objective-C, all classes are derived from the base class called <b>NSObject</b>. It is the superclass of all Objective-C classes. It provides basic methods like memory allocation and initialization. For example, we defined the Box data type using the keyword <b>class</b> as follows:</p>

<p>The instance variables are private and are only accessible inside the class implementation.</p>

<h2>Allocating and initializing Objective-C Objects:</h2>

<p>A class provides the blueprints for objects, so basically an object is created from a class. We declare objects of a class with exactly the same sort of declaration that we declare variables of basic types. Following statements declare two objects of class Box:</p>

<p>Both of the objects box1 and box2 will have their own copy of data members.</p>

<h2>Accessing the Data Members:</h2>

<p>The properties of objects of a class can be accessed using the direct member access operator (.). Let us try the following example to make things clear:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Properties:</h2>

<p>Properties are introduced in Objective-C to ensure that the instance variable of the class can be accessed outside the class.</p>

<p>It is only possible with the properties we can access the instance variables of the class. Actually, internally getter and setter methods are created for the properties.</p>

<p>For example, let's assume we have a property <b>@property (nonatomic ,readonly ) BOOL isDone</b>. Under the hood, there are setters and getters created as shown below.</p>

<h1>Objective-C Inheritance</h1>

<p>One of the most important concepts in object-oriented programming is that of inheritance. Inheritance allows us to define a class in terms of another class which makes it easier to create and maintain an application. This also provides an opportunity to reuse the code functionality and fast implementation time.</p>

<p>When creating a class, instead of writing completely new data members and member functions, the programmer can designate that the new class should inherit the members of an existing class. This existing class is called the <b>base</b> class, and the new class is referred to as the <b>derived</b> class.</p>

<p>The idea of inheritance implements the <b>is a</b> relationship. For example, mammal IS-A animal, dog IS-A mammal, hence dog IS-A animal as well and so on.</p>

<h2>Base &amp; Derived Classes:</h2>

<p>Objective-C allows only multilevel inheritance, i.e., it can have only one base class but allows multilevel inheritance. All classes in Objective-C is derived from the superclass <b>NSObject</b>.</p>

<p>Consider a base class <b>Shape</b> and its derived class <b>Rectangle</b> as follows:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Access Control and Inheritance:</h2>

<p>A derived class can access all the private members of its base class if it's defined in the interface class, but it cannot access private members that are defined in the implementation file.</p>

<p>We can summarize the different access types according to who can access them in the following way: </p>

<p>A derived class inherits all base class methods and variables with the following exceptions:</p>

<p>Variables declared in implementation file with the help of extensions is not accessible.</p>

<p>Methods declared in implementation file with the help of extensions is not accessible.</p>

<p>In case the inherited class implements the method in base class, then the method in derived class is executed.</p>

<h1>Objective-C Polymorphism</h1>

<p>The word <b>polymorphism</b> means having many forms. Typically, polymorphism occurs when there is a hierarchy of classes and they are related by inheritance.</p>

<p>Objective-C polymorphism means that a call to a member function will cause a different function to be executed depending on the type of object that invokes the function.</p>

<p>Consider the example, we have a class Shape that provides the basic interface for all the shapes. Square and Rectangle are derived from the base class Shape.</p>

<p>We have the method printArea that is going to show about the OOP feature <b>polymorphism</b>.</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>In the above example based on the availability of the method calculateArea and printArea, either the method in the base class or the derived class executed.</p>

<p>Polymorphism handles the switching of methods between the base class and derived class based on the method implementation of the two classes.</p>

<h1>Objective-C Data Encapsulation</h1>

<p>All Objective-C programs are composed of the following two fundamental elements: </p>

<p><b>Program statements (code):</b> This is the part of a program that performs actions and they are called methods.</p>

<p><b>Program data:</b> The data is the information of the program which is affected by the program functions.</p>

<p>Encapsulation is an Object-Oriented Programming concept that binds together the data and functions that manipulate the data and that keeps both safe from outside interference and misuse. Data encapsulation led to the important OOP concept of <b>data hiding</b>.</p>

<p><b>Data encapsulation</b> is a mechanism of bundling the data and the functions that use them, and <b>data abstraction</b> is a mechanism of exposing only the interfaces and hiding the implementation details from the user.</p>

<p>Objective-C supports the properties of encapsulation and data hiding through the creation of user-defined types, called <b>classes</b>. For example:</p>

<p>The variable total is private and we cannot access from outside the class. This means that they can be accessed only by other members of the Adder class and not by any other part of your program. This is one way encapsulation is achieved.</p>

<p>Methods inside the interface file are accessible and are public in scope.</p>

<p>There are private methods, which are written with the help of <b>extensions</b>, which we will learn in upcoming chapters.</p>

<h2>Data Encapsulation Example:</h2>

<p>Any Objective-C program where you implement a class with public and private members variables is an example of data encapsulation and data abstraction. Consider the following example:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>Above class adds numbers together and returns the sum. The public members <b>addNum</b> and <b>getTotal </b> are the interfaces to the outside world and a user needs to know them to use the class. The private member <b>total</b> is something that is hidden from the outside world, but is needed for the class to operate properly.</p>

<h2>Designing Strategy:</h2>

<p>Most of us have learned through bitter experience to make class members private by default unless we really need to expose them. That's just good <b>encapsulation</b>.</p>

<p>It's important to understand data encapsulation since it's one of the core features of all Object-Oriented Programming (OOP) languages including Objective-C.</p>

<h1>Objective-C Category</h1>

<p>Sometimes, you may find that you wish to extend an existing class by adding behavior that is useful only in certain situations. In order add such extension to existing classes, Objective-C provides <b>categories</b> and <b>extensions</b>.</p>

<p>If you need to add a method to an existing class, perhaps, to add functionality to make it easier to do something in your own application, the easiest way is to use a category.</p>

<p>The syntax to declare a category uses the @interface keyword, just like a standard Objective-C class description, but does not indicate any inheritance from a subclass. Instead, it specifies the name of the category in parentheses, like this:</p>

<h2>Characteristics of category</h2>

<p>A category can be declared for any class, even if you don't have the original implementation source code.</p>

<p>Any methods that you declare in a category will be available to all instances of the original class, as well as any subclasses of the original class.</p>

<p>At runtime, there's no difference between a method added by a category and one that is implemented by the original class.</p>

<p>Now, let's look at a sample category implementation. Let's add a category to the Cocoa class NSString. This category will make it possible for us to add a new method getCopyRightString which helps us in returning the copyright string. It is shown below.</p>

<p>Now when we compile and run the program, we will get the following result.</p>

<p>Even though any methods added by a category are available to all instances of the class and its subclasses, you'll need to import the category header file in any source code file where you wish to use the additional methods, otherwise you'll run into compiler warnings and errors.</p>

<p>In our example, since we just have a single class, we have not included any header files, in such a case we should include the header files as said above.</p>

<h1>Objective-C Posing</h1>

<p>Before starting about Posing in Objective-C, I would like to bring to your notice that Posing was declared deprecated in Mac OS X 10.5 and it's not available for use thereafter. So for those who are not concerned about these deprecated methods can skip this chapter.</p>

<p>Objective-C permits a class to wholly replace another class within a program. The replacing class is said to "pose as" the target class.</p>

<p>For the versions that supported posing, all messages sent to the target class are instead received by the posing class.</p>

<p>NSObject contains the poseAsClass: method that enables us to replace the existing class as said above.</p>

<h2>Restrictions in Posing</h2>

<p>A class may only pose as one of its direct or indirect superclasses.</p>

<p>The posing class must not define any new instance variables that are absent from the target class (though it may define or override methods).</p>

<p>The target class may not have received any messages prior to the posing.</p>

<p>A posing class can call overridden methods through super, thus incorporating the implementation of the target class.</p>

<p>A posing class can override methods defined in categories.</p>

<p>Now when we compile and run the program in a older Mac OS X (V_10.5 or earlier), we will get the following result.</p>

<p>In the above example, we just polluted the original method with our implementation and this will get affected throughout all the NSString operations with the above method.</p>

<h1>Objective-C Extensions</h1>

<p>A class extension bears some similarity to a category, but it can only be added to a class for which you have the source code at compile time (the class is compiled at the same time as the class extension). </p>

<p>The methods declared by a class extension are implemented in the implementation block for the original class, so you can't, for example, declare a class extension on a framework class, such as a Cocoa or Cocoa Touch class like NSString..</p>

<p>Extensions are actually categories without the category name. It's often referred as <b>anonymous categories</b>.</p>

<p>The syntax to declare a extension uses the @interface keyword, just like a standard Objective-C class description, but does not indicate any inheritance from a subclass. Instead, it just adds parentheses, as shown below</p>

<h2>Characteristics of extensions</h2>

<p>An extension cannot be declared for any class, only for the classes that we have original implementation of source code.</p>

<p>An extension is adding private methods and private variables that are only specific to the class.</p>

<p>Any method or variable declared inside the extensions is not accessible even to the inherited classes.</p>

<h2>Extensions Example</h2>

<p>Let's create a class SampleClass that has an extension. In the extension, let's have a private variable internalID.</p>

<p>Then, let's have a method getExternalID that returns the externalID after processing the internalID.</p>

<p>The example is shown below and this wont work on online compiler.</p>

<p>Now when we compile and run the program, we will get the following result.</p>

<p>In the above example, we can see that the internalID is not returned directly. We here remove the UNIQUEINTERNALKEY and only make the remaining value available to the method getExternalID.</p>

<p>The above example just uses a string operation, but it can have many features like encryption/decryption and so on.</p>

<h1>Objective-C Protocols</h1>

<p>Objective-C allows you to define protocols, which declare the methods expected to be used for a particular situation. Protocols are implemented in the classes conforming to the protocol.</p>

<p>A simple example would be a network URL handling class, it will have a protocol with methods like processCompleted delegate method that intimates the calling class once the network URL fetching operation is over.</p>

<p>A syntax of protocol is shown below.</p>

<p>The methods under keyword <b>@required</b> must be implemented in the classes that conforms to the protocol and the methods under <b>@optional</b> keyword are optional to implement.</p>

<p>Here is the syntax for class conforming to protocol</p>

<p>This means that any instance of MyClass will respond not only to the methods declared specifically in the interface, but that MyClass also provides implementations for the required methods in MyProtocol. There's no need to redeclare the protocol methods in the class interface - the adoption of the protocol is sufficient.</p>

<p>If you need a class to adopt multiple protocols, you can specify them as a comma-separated list. We have a delegate object that holds the reference of the calling object that implements the protocol.</p>

<p>An example is shown below.</p>

<p>Now when we compile and run the program, we will get the following result.</p>

<p>In the above example we have seen how the delgate methods are called and executed. Its starts with startAction, once the process is completed, the delegate method processCompleted is called to intimate the operation is completed.</p>

<p>In any iOS or Mac app, we will never have a program implemented without a delegate. So its important we understand the usage of delegates. Delegates objects should use unsafe_unretained property type to avoid memory leaks.</p>

<h1>Objective-C Dynamic Binding</h1>

<p>Dynamic binding is determining the method to invoke at runtime instead of at compile time. Dynamic binding is also referred to as late binding.</p>

<p>In Objective-C, all methods are resolved dynamically at runtime. The exact code executed is determined by both the method name (the selector) and the receiving object.</p>

<p>Dynamic binding enables polymorphism. For example, consider a collection of objects including Rectangle and Square. Each object has its own implementation of a printArea  method.</p>

<p>In the following code fragment, the actual code that should be executed by the expression [anObject printArea] is determined at runtime. The runtime system uses the selector for the method run to identify the appropriate method in whatever class of anObject turns out to be.</p>

<p>Let us look at a simple code that would explain dynamic binding.</p>

<p>Now when we compile and run the program, we will get the following result.</p>

<p>As you can see in the above example, printArea method is dynamically selected in runtime. It is an example for dynamic binding and is quite useful in many situations when dealing with similar kind of objects.</p>

<h1>Objective-C Composite Objects</h1>

<p>We can create subclass within a class cluster that defines a class that embeds within it an object. These class objects are composite objects.</p>

<p>So you might be wondering what's a class cluster. So we will first see what's a class cluster.</p>

<h2>Class Clusters</h2>

<p>Class clusters are a design pattern that the Foundation framework makes extensive use of. Class clusters group a number of private concrete subclasses under a public abstract superclass. The grouping of classes in this way simplifies the publicly visible architecture of an object-oriented framework without reducing its functional richness. Class clusters are based on the Abstract Factory design pattern.</p>

<p>To make it simple, instead of creating multiple classes for similar functions, we create a single class that will take care of its handling based on the value of input.</p>

<p>For example, in NSNumber we have many clusters of classes like char, int, bool and so on. We group all of them to a single class that takes care of handling the similar operations in a single class. NSNumber actually wraps the value of these primitive types into objects.</p>

<h2>So what's exactly composite object?</h2>

<p>By embedding a private cluster object in an object of our own design, we create a composite object. This composite object can rely on the cluster object for its basic functionality, only intercepting messages that the composite object wants to handle in some particular way. This architecture reduces the amount of code we must write and lets you take advantage of the tested code provided by the Foundation Framework.</p>

<p>This is explained in the following figure.</p>

<p>The composite object must declare itself to be a subclass of the cluster's abstract superclass. As a subclass, it must override the superclass' primitive methods. It can also override derived methods, but this isn't necessary because the derived methods work through the primitive ones.</p>

<p>The count method of the NSArray class is an example; the intervening object's implementation of a method it overrides can be as simple as:</p>

<p>In the above example, embedded object is actually of type NSArray.</p>

<h2>A Composite Object example</h2>

<p>Now in order to see a complete example, let's look at the example from the Apple documentation which is given below.</p>

<p>Now when we compile and run the program, we will get the following result.</p>

<p>In the above example, we can see that validating array's one function would not allow adding null objects that will lead to crash in the normal scenario. But our validating array takes care of it. Similarly, each of the method in validating array adds validating processes apart from the normal sequence of operations.</p>

<h1>Obj-C Foundation Framework</h1>

<p>If you refer Apple documentation, you can see the details of Foundation framework as given below.</p>

<p>The Foundation framework defines a base layer of Objective-C classes. In addition to providing a set of useful primitive object classes, it introduces several paradigms that define functionality not covered by the Objective-C language. The Foundation framework is designed with these goals in mind:</p>

<p>The framework was developed by NeXTStep, which was acquired by Apple and these foundation classes became part of Mac OS X and iOS.</p>

<p>Since it was developed by NeXTStep, it has class prefix of "NS".</p>

<p>We have used Foundation Framework in all our sample programs. It is almost a must to use Foundation Framework.</p>

<p>Generally, we use something like <b>#import &lt;Foundation/NSString.h&gt;</b> to import a Objective-C class, but in order avoid importing too many classes, it's all imported in <b>#import &lt;Foundation/Foundation.h&gt</b>.</p>

<p>NSObject is the base class of all objects including the foundation kit classes. It provides the methods for memory management. It also provides basic interface to the runtime system and ability to behave as Objective-C objects. It doesn't have any base class and is the root for all classes.</p>

<h2>Foundation Classes based on functionality</h2>

<h1>Objective-C Fast Enumeration</h1>

<p>Fast enumeration is an Objective-C's feature that helps in enumerating through a collection. So in order to know about fast enumeration, we need know about collection first which will be explained in the following section.</p>

<h2>Collections in Objective-C</h2>

<p>Collections are fundamental constructs. It is used to hold and manage other objects. The whole purpose of a collection is that it provides a common way to store and retrieve objects efficiently.</p>

<p>There are several different types of collections. While they all fulfil the same purpose of being able to hold other objects, they differ mostly in the way objects are retrieved. The most common collections used in Objective-C are:</p>

<p>NSSet</p>

<p>NSArray</p>

<p>NSDictionary</p>

<p>NSMutableSet</p>

<p>NSMutableArray</p>

<p>NSMutableDictionary</p>

<p>If you want to know more about these structures, please refer data storage in <a href="/objective_c/objective_c_foundation_framework.htm">Foundation Framework</a>.</p>

<h2>Fast enumeration Syntax</h2>

<p>Here is an example for fast enumeration.</p>

<p>Now when we compile and run the program, we will get the following result.</p>

<p>As you can see in the output, each of the objects in the array is printed in an order.</p>

<h2>Fast Enumeration Backwards</h2>

<p>Here is an example for reverseObjectEnumerator in fast enumeration.</p>

<p>Now when we compile and run the program, we will get the following result.</p>

<p>As you can see in the output, each of the objects in the array is printed but in the reverse order as compared to normal fast enumeration.</p>

<h1>Obj-C Memory Management</h1>

<p>Memory management is one of the most important process in any programming language. It is the process by which the memory of objects are allocated when they are required and deallocated when they are no longer required.</p>

<p>Managing object memory is a matter of performance; if an application doesn't free unneeded objects, its memory footprint grows and performance suffers.</p>

<p>Objective-C Memory management techniques can be broadly classified into two types.</p>

<p>"Manual Retain-Release" or MRR</p>

<p>"Automatic Reference Counting" or ARC</p>

<h2>"Manual Retain-Release" or MRR</h2>

<p>In MRR, we explicitly manage memory by keeping track of objects on our own. This is implemented using a model, known as reference counting, that the Foundation class NSObject provides in conjunction with the runtime environment.</p>

<p>The only difference between MRR and ARC is that the retain and release is handled by us manually in former while its automatically taken care of in the latter.</p>

<p>The following figure represents an example of how memory management work in Objective-C.</p>

<p>The memory life cycle of the Class A object is shown in the above figure. As you can see, the retain count is shown below the object, when the retain count of an object becomes 0, the object is freed completely and its memory is deallocated for other objects to use.</p>

<p>Class A object is first created using alloc/init method available in NSObject. Now, the retain count becomes 1.</p>

<p>Now, class B retains the Class A's Object and the retain count of Class A's object becomes 2.</p>

<p>Then, Class C makes a copy of the object. Now, it is created as another instance of Class A with same values for the instance variables. Here, the retain count is 1 and not the retain count of the original object. This is represented by the dotted line in the figure.</p>

<p>The copied object is released by Class C using the release method and the retain count becomes 0 and hence the object is destroyed.</p>

<p>In case of the initial Class A Object, the retain count is 2 and it has to be released twice in order for it to be destroyed. This is done by release statements of Class A and Class B which decrements the retain count to 1 and 0, respectively. Finally, the object is destroyed.</p>

<h2>MRR Basic Rules</h2>

<p>We own any object we create: We create an object using a method whose name begins with "alloc", "new", "copy", or "mutableCopy"</p>

<p>In the implementation of an accessor method or an init method, to take ownership of an object we want to store as a property value.</p>

<p> To prevent an object from being invalidated as a side-effect of some other operation.</p>

<p>When we no longer need it, we must relinquish ownership of an object we own: We relinquish ownership of an object by sending it a release message or an autorelease message. In Cocoa terminology, relinquishing ownership of an object is therefore typically referred to as "releasing" an object.</p>

<p>You must not relinquish ownership of an object you do not own: This is just corollary of the previous policy rules stated explicitly.</p>

<p>When we compile the above program, we will get the following output.</p>

<h2>"Automatic Reference Counting" or ARC</h2>

<p>In Automatic Reference Counting or ARC, the system uses the same reference counting system as MRR, but it inserts the appropriate memory management method calls for us at compile-time. We are strongly encouraged to use ARC for new projects. If we use ARC, there is typically no need to understand the underlying implementation described in this document, although it may in some situations be helpful. For more about ARC, see <a target="_blank" rel="nofollow" href="https://developer.apple.com/library/ios/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html">Transitioning to ARC Release Notes.</a></p>

<p>As mentioned above, in ARC, we need not add release and retain methods since that will be taken care by the compiler. Actually, the underlying process of Objective-C is still the same. It uses the retain and release operations internally making it easier for the developer to code without worrying about these operations, which will reduce both the amount of code written and the possibility of memory leaks.</p>

<p>There was another principle called garbage collection, which is used in Mac OS-X along with MRR, but since its deprecation in OS-X Mountain Lion, it has not been discussed along with MRR. Also, iOS objects never had garbage collection feature. And with ARC, there is no use of garbage collection in OS-X too.</p>

<p>Here is a simple ARC example. Note this won't work on online compiler since it does not support ARC.</p>

<p>When we compile the above program, we will get the following output.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

int main (int argc, const char * argv[])
{
   NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];

   NSLog (@"hello world");
   [pool drain];
   return 0;
}
</pre>
<h2>Foundation Framework</h2>
<p>Foundation Framework provides large set of features and they are listed below.</p>
<ul class="list">
<li><p>It includes a list of extended datatypes like NSArray, NSDictionary, NSSet and so on. </p></li>
<li><p>It consists of a rich set of functions manipulating files, strings, etc.</p></li>
<li><p>It provides features for URL handling, utilities like date formatting, data handling, error handling, etc.</p></li>
</ul>
<h2>Learning Objective-C</h2>
<p>The most important thing to do when learning Objective-C is to focus on concepts and not get lost in language technical details.</p>
<p>The purpose of learning a programming language is to become a better programmer; that is, to become more effective at designing and implementing new systems and at maintaining old ones.</p>

<h2>Use of Objective-C</h2>
<p>Objective-C, as mentioned earlier, is used in iOS and Mac OS X. It has large base of iOS users and largely increasing Mac OS X users. And since Apple focuses on quality first and its wonderful for those who started learning Objective-C. </p>
<h1>Objective-C Environment Setup</h1>
<blockquote>
<h2>Try it Option Online</h2>
<p>You really do not need to set up your own environment to start learning Objective-C programming language. Reason is very simple, we already have set up Objective-C Programming environment online, so that you can compile and execute all the available examples online at the same time when you are doing your theory work. This gives you confidence in what you are reading and to check the result with different options. Feel free to modify any example and execute it online.</p>
<p>Try the following example using <b>Try it</b> option available at the top right corner of the below sample code box:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

int main()
{
   /* my first program in Objective-C */
   NSLog(@"Hello, World! \n");
   
   return 0;
}
</pre>
<p>For most of the examples given in this tutorial, you will find <b>Try it</b> option, so just make use of it and enjoy your learning.</p>
</blockquote>
<h2>Local Environment Setup</h2>
<p>If you are still willing to set up your environment for Objective-C programming language, you need the following two softwares available on your computer, (a) Text Editor and (b) The GCC Compiler.</p>
<h2>Text Editor</h2>
<p>This will be used to type your program. Examples of few editors include Windows Notepad, OS Edit command, Brief, Epsilon, EMACS, and vim or vi.</p>
<p>Name and version of text editor can vary on different operating systems. For example, Notepad will be used on Windows, and vim or vi can be used on windows as well as Linux or UNIX.</p>
<p>The files you create with your editor are called source files and contain program source code. The source files for Objective-C programs are typically named with the extension "<b>.m</b>".</p>
<p>Before starting your programming, make sure you have one text editor in place and you have enough experience to write a computer program, save it in a file, compile it and finally execute it.</p>
<h2>The GCC Compiler</h2>
<p>The source code written in source file is the human readable source for your program. It needs to be "compiled" to turn into machine language, so that your CPU can actually execute the program as per instructions given.</p>
<p>This GCC compiler will be used to compile your source code into final executable program. I assume you have basic knowledge about a programming language compiler.</p>
<p>GCC compiler is available for free on various platforms and the procedure to set up on various platforms is explained below.</p>
<h2>Installation on UNIX/Linux</h2>
<p>The initial step is install gcc along with gcc Objective-C package. This is done by:</p>
<pre class="prettyprint notranslate">
$ su - 
$ yum install gcc
$ yum install gcc-objc
</pre>
<p>The next step is to set up package dependencies using following command:</p>
<pre class="prettyprint notranslate">
$ yum install make libpng libpng-devel libtiff libtiff-devel libobjc libxml2 libxml2-devel libX11-devel libXt-devel libjpeg libjpeg-devel
</pre>
<p>In order to get full features of Objective-C, download and install GNUStep. This can be done by downloading the package from <a href="http://wwwmain.gnustep.org/resources/downloads.php?site=ftp%3A%2F%2Fftp.gnustep.org%2Fpub%2Fgnustep%2F#core/" rel="nofollow" target="_blank">http://main.gnustep.org/resources/downloads.php</a>.</p>
<p>Now, we need to switch to the downloaded folder and unpack the file by:</p>
<pre class="prettyprint notranslate">
$ tar xvfz gnustep-startup-<version>.tar.gz
</pre>
<p>Now, we need to switch to the folder gnustep-startup that gets created using:</p>
<pre class="prettyprint notranslate">
$ cd gnustep-startup-<version>
</pre>
<p>Next, we need to configure the build process:</p>
<pre class="prettyprint notranslate">
$ ./configure
</pre>
<p>Then, we can build by:</p>
<pre class="prettyprint notranslate">
$ make
</pre>
<p>We need to finally set up the environment by:</p>
<pre class="prettyprint notranslate">
$ . /usr/GNUstep/System/Library/Makefiles/GNUstep.sh
</pre>
<p>We have a helloWorld.m Objective-C as follows:</p>
<pre class="prettyprint notranslate">
#import &lt;Foundation/Foundation.h&gt;

int main (int argc, const char * argv[])
{
    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
    NSLog (@"hello world");
    [pool drain];
    return 0;
}
</pre>
<p>Now, we can compile and run a Objective-C file say helloWorld.m by switching to folder containing the file using cd and then using the following steps:</p>
<pre class="prettyprint notranslate">
$ gcc `gnustep-config --objc-flags` -L/usr/GNUstep/Local/Library/Libraries -lgnustep-base helloWorld.m -o helloWorld
$ ./helloWorld
</pre>
<p>We can see the following output:</p>
<pre class="prettyprint notranslate">
2013-09-07 10:48:39.772 tutorialsPoint[12906] hello world
</pre>

<h2>Installation on Mac OS</h2>
<p>If you use Mac OS X, the easiest way to obtain GCC is to download the Xcode development environment from Apple's web site and follow the simple installation instructions. Once you have Xcode set up, you will be able to use GNU compiler for C/C++.</p>
<p>Xcode is currently available at <a href="http://developer.apple.com/technologies/tools/" rel="nofollow" target="_blank">developer.apple.com/technologies/tools/</a>.</p>
<h2>Installation on Windows</h2>
<p>In order to run Objective-C program on windows, we need to install MinGW and GNUStep Core. Both are available at <a href="http://www.gnustep.org/experience/Windows.html" rel="nofollow" target="_blank">gnustep.org/experience/Windows.html</a>.</p>
<p>First, we need to install the MSYS/MinGW System package. Then, we need to install the GNUstep Core package. Both of which provide a windows installer, which is self-explanatory.</p>
<p>Then to use Objective-C and GNUstep by selecting  Start -&gt; All Programs -&gt; GNUstep -&gt; Shell</p>
<p>Switch to the folder containing helloWorld.m</p>
<p>We can compile the program by using:</p>
<pre class="prettyprint notranslate">
$ gcc `gnustep-config --objc-flags` -L /GNUstep/System/Library/Libraries hello.m -o hello -lgnustep-base -lobjc
</pre>
<p>We can run the program by using:</p>
<pre class="prettyprint notranslate">
./hello.exe
</pre>
<p>We get the following output:</p>
<pre class="prettyprint notranslate">
2013-09-07 10:48:39.772 tutorialsPoint[1200] hello world
</pre>
<h1>Objective-C Program Structure</h1>
<p>Before we study basic building blocks of the Objective-C programming language, let us look a bare minimum Objective-C program structure so that we can take it as a reference in upcoming chapters.</p>
<h2>Objective-C Hello World Example</h2>
<p>A Objective-C program basically consists of the following parts:</p>
<ul class="list">
<li><p>Preprocessor Commands</p></li>
<li><p>Interface</p></li>
<li><p>Implementation</p></li>
<li><p>Method</p></li>
<li><p>Variables</p></li>
<li><p>Statements &amp; Expressions</p></li>
<li><p>Comments</p></li>
</ul>
<p>Let us look at a simple code that would print the words "Hello World":</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

@interface SampleClass:NSObject
- (void)sampleMethod;
@end

@implementation SampleClass

- (void)sampleMethod{
   NSLog(@"Hello, World! \n");
}

@end

int main()
{
   /* my first program in Objective-C */
   SampleClass *sampleClass = [[SampleClass alloc]init];
   [sampleClass sampleMethod];
   return 0;
}
</pre>
<p>Let us look various parts of the above program:</p>
<ul class="list">
<li><p>The first line of the program <i>#import &lt;Foundation/Foundation.h&gt;</i> is a preprocessor command, which tells a Objective-C compiler to include Foundation.h file before going to actual compilation.</p></li>
<li><p>The next line <i>@interface SampleClass:NSObject</i> shows how to create an interface. It inherits NSObject, which is the base class of all objects.</p></li>
<li><p>The next line <i>- (void)sampleMethod;</i> shows how to declare a method.</p></li>
<li><p>The next line <i>@end</i> marks the end of an interface.</p></li>
<li><p>The next line <i>@implementation SampleClass</i> shows how to implement the interface SampleClass.</p></li>
<li><p>The next line <i>- (void)sampleMethod{}</i> shows the implementation of the sampleMethod.</p></li>
<li><p>The next line <i>@end</i> marks the end of an implementation.</p></li>
<li><p>The next line <i>int main()</i> is the main function where program execution begins.</p></li>
<li><p>The next line /*...*/ will be ignored by the compiler and it has been put to add additional comments in the program. So such lines are called comments in the program.</p></li>
<li><p>The next line <i>NSLog(...)</i> is another function available in Objective-C which causes the message "Hello, World!" to be displayed on the screen.</p></li>
<li><p>The next line <b>return 0;</b> terminates main()function and returns the value 0.</p></li>
</ul>
<h2>Compile &amp; Execute Objective-C Program:</h2>
<p>Now when we compile and run the program, we will get the following result.</p
<pre class="prettyprint notranslate">
2013-09-07 22:38:27.932 demo[28001] Hello, World! 
</pre>
<h1>Objective-C Basic Syntax</h1>
<p>You have seen a basic structure of Objective-C program, so it will be easy to understand other basic building blocks of the Objective-C programming language.</p>
<h2>Tokens  in Objective-C</h2>
<p>A Objective-C program consists of various tokens and a token is either a keyword, an identifier, a constant, a string literal, or a symbol. For example, the following Objective-C statement consists of six tokens:</p>
<pre class="prettyprint notranslate">
NSLog(@"Hello, World! \n");
</pre>
<p>The individual tokens are:</p>
<pre class="prettyprint notranslate">
NSLog
@
(
"Hello, World! \n"
)
;
</pre>
<h2>Semicolons ;</h2>
<p>In Objective-C program, the semicolon is a statement terminator. That is, each individual statement must be ended with a semicolon. It indicates the end of one logical entity.</p>
<p>For example, following are two different statements:</p>
<pre class="prettyprint notranslate">
NSLog(@"Hello, World! \n");
return 0;
</pre>
<h2>Comments</h2>
<p>Comments are like helping text in your Objective-C program and they are ignored by the compiler. They start with /* and terminate with the characters */ as shown below:</p>
<pre class="prettyprint notranslate">
/* my first program in Objective-C */
</pre>
<p>You can not have comments with in comments and they do not occur within a string or character literals.</p>
<h2>Identifiers</h2>
<p>An Objective-C identifier is a name used to identify a variable, function, or any other user-defined item. An identifier starts with a letter A to Z or a to z or an underscore _ followed by zero or more letters, underscores, and digits (0 to 9).</p>
<p>Objective-C does not allow punctuation characters such as @, $, and % within identifiers. Objective-C is a <b>case-sensitive</b> programming language. Thus, <i>Manpower</i> and <i>manpower</i> are two different identifiers in Objective-C. Here are some examples of acceptable identifiers:</p>
<pre class="prettyprint notranslate">
mohd       zara    abc   move_name  a_123
myname50   _temp   j     a23b9      retVal
</pre>
<h2>Keywords</h2>
<p>The following list shows few of the reserved words in Objective-C. These reserved words may not be used as constant or variable or any other identifier names.</p>
<table class="table table-bordered">
<tr>
<td style="width:25%">auto</td>
<td style="width:25%">else</td>
<td style="width:25%">long</td>
<td style="width:25%">switch</td>
</tr>
<tr>
<td>break</td>
<td>enum</td>
<td>register</td>
<td>typedef</td>
</tr>
<tr>
<td>case</td>
<td>extern</td>
<td>return</td>
<td>union</td>
</tr>
<tr>
<td>char</td>
<td>float</td>
<td>short</td>
<td>unsigned</td>
</tr>
<tr>
<td>const</td>
<td>for</td>
<td>signed</td>
<td>void</td>
</tr>
<tr>
<td>continue</td>
<td>goto</td>
<td>sizeof</td>
<td>volatile</td>
</tr>
<tr>
<td>default</td>
<td>if</td>
<td>static</td>
<td>while</td>
</tr>
<tr>
<td>do</td>
<td>int</td>
<td>struct</td>
<td>_Packed</td>
</tr>
<tr>
<td>double</td>
<td>protocol</td>
<td>interface</td>
<td>implementation</td>
</tr>
<tr>
<td>NSObject</td>
<td>NSInteger</td>
<td>NSNumber</td>
<td>CGFloat</td>
</tr>
<tr>
<td>property</td>
<td>nonatomic;</td>
<td>retain</td>
<td>strong</td>
</tr>
<tr>
<td>weak</td>
<td>unsafe_unretained;</td>
<td>readwrite</td>
<td>readonly</td>
</tr>
</table>
<h2>Whitespace in Objective-C</h2>
<p>A line containing only whitespace, possibly with a comment, is known as a blank line, and an Objective-C compiler totally ignores it.</p>
<p>Whitespace is the term used in Objective-C to describe blanks, tabs, newline characters and comments. Whitespace separates one part of a statement from another and enables the compiler to identify where one element in a statement, such as int, ends and the next element begins. Therefore, in the following statement:</p>
<pre class="prettyprint notranslate">
int age;
</pre>
<p>There must be at least one whitespace character (usually a space) between int and age for the compiler to be able to distinguish them. On the other hand, in the following statement,</p>
<pre class="prettyprint notranslate">
fruit = apples + oranges;   // get the total fruit
</pre>
<p>no whitespace characters are necessary between fruit and =, or between = and apples, although you are free to include some if you wish for readability purpose.</p>
<h1>Objecive-C Data Types</h1>
<p>In the Objective-C programming language, data types refer to an extensive system used for declaring variables or functions of different types. The type of a variable determines how much space it occupies in storage and how the bit pattern stored is interpreted.</p>
<p>The types in Objective-C can be classified as follows:</p>
<table class="table table-bordered">
<tr>
<th>S.N.</th>
<th>Types and Description</th>
</tr>
<tr>
<td>1</td>
<td><b>Basic Types:</b>
<p>They are arithmetic types and consist of the two types: (a) integer types and (b) floating-point types.</p></td>
</tr>
<tr>
<td>2</td>
<td><b>Enumerated types:</b>
<p>They are again arithmetic types and they are used to define variables that can only be assigned certain discrete integer values throughout the program.</p></td>
</tr>
<tr>
<td>3</td>
<td><b>The type void:</b>
<p>The type specifier <i>void</i> indicates that no value is available.</p></td>
</tr>
<tr>
<td>4</td>
<td><b>Derived types:</b>
<p>They include (a) Pointer types, (b) Array types, (c) Structure types, (d) Union types and (e) Function types.</p></td>
</tr>
</table>
<p>The array types and structure types are referred to collectively as the aggregate types. The type of a function specifies the type of the function's return value. We will see basic types in the following section whereas other types will be covered in the upcoming chapters.</p>
<h2>Integer Types</h2>
<p>Following table gives you details about standard integer types with its storage sizes and value ranges:</p>
<table class="table table-bordered">
<tr>
<th>Type</th>
<th>Storage size</th>
<th>Value range</th>
</tr>
<tr>
<td>char</td>
<td>1 byte</td>
<td>-128 to 127 or 0 to 255</td>
</tr>
<tr>
<td>unsigned char</td>
<td>1 byte</td>
<td>0 to 255</td>
</tr>
<tr>
<td>signed char</td>
<td>1 byte</td>
<td>-128 to 127</td>
</tr>
<tr>
<td>int</td>
<td>2 or 4 bytes</td>
<td>-32,768 to 32,767 or -2,147,483,648 to 2,147,483,647</td>
</tr>
<tr>
<td>unsigned int</td>
<td>2 or 4 bytes</td>
<td>0 to 65,535 or 0 to 4,294,967,295</td>
</tr>
<tr>
<td>short</td>
<td>2 bytes</td>
<td>-32,768 to 32,767</td>
</tr>
<tr>
<td>unsigned short</td>
<td>2 bytes</td>
<td>0 to 65,535</td>
</tr>
<tr>
<td>long</td>
<td>4 bytes</td>
<td>-2,147,483,648 to 2,147,483,647</td>
</tr>
<tr>
<td>unsigned long</td>
<td>4 bytes</td>
<td>0 to 4,294,967,295</td>
</tr>
</table>
<p>To get the exact size of a type or a variable on a particular platform, you can use the <b>sizeof</b> operator. The expression <i>sizeof(type)</i> yields the storage size of the object or type in bytes. Following is an example to get the size of int type on any machine:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

int main()
{
   NSLog(@"Storage size for int : %d \n", sizeof(int));
   
   return 0;
}
</pre>
<p>When you compile and execute the above program, it produces the following result on Linux:</p>
<pre class="prettyprint notranslate">
2013-09-07 22:21:39.155 demo[1340] Storage size for int : 4 
</pre>
<h2>Floating-Point Types</h2>
<p>Following table gives you details about standard float-point types with storage sizes and value ranges and their precision:</p>
<table class="table table-bordered">
<tr>
<th>Type</th>
<th>Storage size</th>
<th>Value range</th>
<th>Precision</th>
</tr>
<tr>
<td>float</td>
<td>4 byte</td>
<td>1.2E-38 to 3.4E+38</td>
<td>6 decimal places</td>
</tr>
<tr>
<td>double</td>
<td>8 byte</td>
<td>2.3E-308 to 1.7E+308</td>
<td>15 decimal places</td>
</tr>
<tr>
<td>long double</td>
<td>10 byte</td>
<td>3.4E-4932 to 1.1E+4932</td>
<td>19 decimal places</td>
</tr>
</table>
<p>The header file float.h defines macros that allow you to use these values and other details about the binary representation of real numbers in your programs. Following example will print storage space taken by a float type and its range values:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

int main()
{
   NSLog(@"Storage size for float : %d \n", sizeof(float));
   
   return 0;
}
</pre>
<p>When you compile and execute the above program, it produces the following result on Linux:</p>
<pre class="prettyprint notranslate">
2013-09-07 22:22:21.729 demo[3927] Storage size for float : 4 
</pre>
<h2>The void Type</h2>
<p>The void type specifies that no value is available. It is used in three kinds of situations:</p>
<table class="table table-bordered">
<tr>
<th>S.N.</th>
<th>Types and Description</th>
</tr>
<tr>
<td>1</td>
<td><b>Function returns as void</b>
<p>There are various functions in Objective-C which do not return value  or you can say they return void. A function with no return value has the return type as void. For example, <b>void exit (int status);</b></p></td>
</tr>
<tr>
<td>2</td>
<td><b>Function arguments as void</b>
<p>There are various functions in Objective-C which do not accept any parameter. A function with no parameter can accept as a void. For example, <b>int rand(void);</b></p></td>
</tr>
</table>
<p>The void type may not be understood to you at this point, so let us proceed and we will cover  these concepts in upcoming chapters.</p>
<h1>Objective-C Variables</h1>
<p>A variable is nothing but a name given to a storage area that our programs can manipulate. Each variable in Objective-C has a specific type, which determines the size and layout of the variable's memory; the range of values that can be stored within that memory; and the set of operations that can be applied to the variable.</p>
<p>The name of a variable can be composed of letters, digits, and the underscore character. It must begin with either a letter or an underscore. Upper and lowercase letters are distinct because Objective-C is case-sensitive. Based on the basic types explained in previous chapter, there will be the following basic variable types:</p>
<table class="table table-bordered">
<tr>
<th style="width:20%">Type</th>
<th>Description</th>
</tr>
<tr>
<td>char</td>
<td>Typically a single octet (one byte). This is an integer type.</td>
</tr>
<tr>
<td>int</td>
<td>The most natural size of integer for the machine.</td>
</tr>
<tr>
<td>float</td>
<td>A single-precision floating point value.</td>
</tr>
<tr>
<td>double</td>
<td>A double-precision floating point value.</td>
</tr>
<tr>
<td>void</td>
<td>Represents the absence of type.</td>
</tr>
</table>
<p>Objective-C programming language also allows to define various other types of variables, which we will cover in subsequent chapters like Enumeration, Pointer, Array, Structure, Union, etc. For this chapter, let us study only basic variable types.</p>
<h2>Variable Definition in Objective-C:</h2>
<p>A variable definition means to tell the compiler where and how much to create the storage for the variable. A variable definition specifies a data type and contains a list of one or more variables of that type as follows:</p>
<pre class="prettyprint notranslate">
type variable_list;
</pre>
<p>Here, <b>type</b> must be a valid Objective-C data type including char, w_char, int, float, double, bool or any user-defined object, etc., and <b>variable_list</b> may consist of one or more identifier names separated by commas. Some valid declarations are shown here:</p>
<pre class="prettyprint notranslate">
int    i, j, k;
char   c, ch;
float  f, salary;
double d;
</pre>
<p>The line <b>int    i, j, k;</b> both declares and defines the variables i, j and k;  which instructs the compiler to create variables named i, j and k of type int.</p>
<p>Variables can be initialized (assigned an initial value) in their declaration. The initializer consists of an equal sign followed by a constant expression as follows:</p>
<pre class="prettyprint notranslate">
type variable_name = value;
</pre>
<p>Some examples are:</p>
<pre class="prettyprint notranslate">
extern int d = 3, f = 5;    // declaration of d and f. 
int d = 3, f = 5;           // definition and initializing d and f. 
byte z = 22;                // definition and initializes z. 
char x = 'x';               // the variable x has the value 'x'.
</pre>
<p>For definition without an initializer: variables with static storage duration are implicitly initialized with NULL (all bytes have the value 0); the initial value of all other variables is undefined.</p>
<h2>Variable Declaration in Objective-C:</h2>
<p>A variable declaration provides assurance to the compiler that there is one variable existing with the given type and name so that compiler proceed for further compilation without needing complete detail about the variable. A variable declaration has its meaning at the time of compilation only, compiler needs actual variable declaration at the time of linking of the program.</p>
<p>A variable declaration is useful when you are using multiple files and you define your variable in one of the files, which will be available at the time of linking of the program. You will use <b>extern</b> keyword to declare a variable at any place. Though you can declare a variable multiple times in your Objective-C program but it can be defined only once in a file, a function or a block of code.</p>
<h2>Example</h2>
<p>Try the following example, where variables have been declared at the top, but they have been defined and initialized inside the main function:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

// Variable declaration:
extern int a, b;
extern int c;
extern float f;

int main ()
{
  /* variable definition: */
  int a, b;
  int c;
  float f;
 
  /* actual initialization */
  a = 10;
  b = 20;
  
  c = a + b;
  NSLog(@"value of c : %d \n", c);

  f = 70.0/3.0;
  NSLog(@"value of f : %f \n", f);
 
  return 0;
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
2013-09-07 22:43:31.695 demo[14019] value of c : 30 
2013-09-07 22:43:31.695 demo[14019] value of f : 23.333334 
</pre>
<p>Same concept applies on function declaration where you provide a function name at the time of its declaration and its actual definition can be given anywhere else. In the following example, it's explained using C function and as you know Objective-C supports C style functions also:</p>
<pre class="prettyprint notranslate">
// function declaration
int func();

int main()
{
    // function call
    int i = func();
}

// function definition
int func()
{
    return 0;
}
</pre>
<h2>Lvalues and Rvalues in Objective-C:</h2>
<p>There are two kinds of expressions in Objective-C:</p>
<ul class="list">
<li><p><b>lvalue :</b> An expression that is an lvalue may appear as either the left-hand or right-hand side of an assignment.</p></li>
<li><p><b>rvalue :</b> An expression that is a rvalue may appear on the right- but not left-hand side of an assignment.</p></li>
</ul>
<p>Variables are lvalues and so may appear on the left-hand side of an assignment. Numeric literals are rvalues and so may not be assigned and can not appear on the left-hand side. Following is a valid statement:</p>
<pre class="prettyprint notranslate">
int g = 20;
</pre>
<p>But following is not a valid statement and would generate compile-time error:</p>
<pre class="prettyprint notranslate">
10 = 20;
</pre>
<h1>Objective-C Constants</h1>
<p>The constants refer to fixed values that the program may not alter during its execution. These fixed values are also called <b>literals</b>.</p>
<p>Constants can be of any of the basic data types like <i>an integer constant, a floating constant, a character constant, or a string literal</i>. There are also enumeration constants as well.</p>
<p>The <b>constants</b> are treated just like regular variables except that their values cannot be modified after their definition.</p>
<h2>Integer literals</h2>
<p>An integer literal can be a decimal, octal, or hexadecimal constant. A prefix specifies the base or radix: 0x or 0X for hexadecimal, 0 for octal, and nothing for decimal.</p>
<p>An integer literal can also have a suffix that is a combination of U and L, for unsigned and long, respectively. The suffix can be uppercase or lowercase and can be in any order.</p>
<p>Here are some examples of integer literals:</p>
<pre class="prettyprint notranslate">
212         /* Legal */
215u        /* Legal */
0xFeeL      /* Legal */
078         /* Illegal: 8 is not an octal digit */
032UU       /* Illegal: cannot repeat a suffix */
</pre>
<p>Following are other examples of various types of Integer literals:</p>
<pre class="prettyprint notranslate">
85         /* decimal */
0213       /* octal */
0x4b       /* hexadecimal */
30         /* int */
30u        /* unsigned int */
30l        /* long */
30ul       /* unsigned long */
</pre>
<h2>Floating-point literals</h2>
<p>A floating-point literal has an integer part, a decimal point, a fractional part, and an exponent part. You can represent floating point literals either in decimal form or exponential form.</p>
<p>While representing using decimal form, you must include the decimal point, the exponent, or both and while representing using exponential form, you must include the integer part, the fractional part, or both. The signed exponent is introduced by e or E.</p>
<p>Here are some examples of floating-point literals:</p>
<pre class="prettyprint notranslate">
3.14159       /* Legal */
314159E-5L    /* Legal */
510E          /* Illegal: incomplete exponent */
210f          /* Illegal: no decimal or exponent */
.e55          /* Illegal: missing integer or fraction */
</pre>
<h2>Character constants</h2>
<p>Character literals are enclosed in single quotes e.g., 'x' and can be stored in a simple variable of <b>char</b> type.</p>
<p>A character literal can be a plain character (e.g., 'x'), an escape sequence (e.g., '\t'), or a universal character (e.g., '\u02C0'). </p>
<p>There are certain characters in C when they are proceeded by a backslash they will have special meaning and they are used to represent like newline (\n) or tab (\t). Here, you have a list of some of such escape sequence codes:</p>
<table class="table table-bordered">
<tr>
<th style="width:20%">Escape sequence</th>
<th>Meaning</th>
</tr>
<tr><td>\\</td><td>\ character</td></tr>
<tr><td>\'</td><td> ' character</td></tr>
<tr><td>\"</td><td>" character</td></tr>
<tr><td>\?</td><td>? character</td></tr>
<tr><td>\a</td><td>Alert or bell</td></tr>
<tr><td>\b</td><td>Backspace</td></tr>
<tr><td>\f</td><td>Form feed</td></tr>
<tr><td>\n</td><td>Newline</td></tr>
<tr><td>\r</td><td>Carriage return</td></tr>
<tr><td>\t</td><td>Horizontal tab</td></tr>
<tr><td>\v</td><td>Vertical tab</td></tr>
<tr><td>\ooo</td><td>Octal number of one to three digits</td></tr>
<tr><td>\xhh . . .</td><td>Hexadecimal number of one or more digits</td></tr>
</table>
<p>Following is the example to show few escape sequence characters:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

int main()
{
   NSLog(@"Hello\tWorld\n\n");

   return 0;
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
2013-09-07 22:17:17.923 demo[17871] Hello	World

</pre>
<h2>String literals</h2>
<p>String literals or constants are enclosed in double quotes "". A string contains characters that are similar to character literals: plain characters, escape sequences, and universal characters.</p>
<p>You can break a long line into multiple lines using string literals and separating them using whitespaces.</p>
<p>Here are some examples of string literals. All the three forms are identical strings.</p>
<pre class="prettyprint notranslate">
"hello, dear"

"hello, \

dear"

"hello, " "d" "ear"
</pre>
<h2>Defining Constants</h2>
<p>There are two simple ways in C to define constants:</p>
<ul class="list">
<li><p>Using <b>#define</b> preprocessor.</p></li>
<li><p>Using <b>const</b> keyword.</p></li>
</ul>
<h2>The #define Preprocessor</h2>
<p>Following is the form to use #define preprocessor to define a constant:</p>
<pre class="prettyprint notranslate">
#define identifier value
</pre>
<p>Following example explains it in detail:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

#define LENGTH 10   
#define WIDTH  5
#define NEWLINE '\n'

int main()
{

   int area;  
  
   area = LENGTH * WIDTH;
   NSLog(@"value of area : %d", area);
   NSLog(@"%c", NEWLINE);

   return 0;
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
2013-09-07 22:18:16.637 demo[21460] value of area : 50
2013-09-07 22:18:16.638 demo[21460] 
</pre>
<h2>The const Keyword</h2>
<p>You can use <b>const</b> prefix to declare constants with a specific type as follows:</p>
<pre class="prettyprint notranslate">
const type variable = value;
</pre>
<p>Following example explains it in detail:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

int main()
{
   const int  LENGTH = 10;
   const int  WIDTH  = 5;
   const char NEWLINE = '\n';
   int area;  
   
   area = LENGTH * WIDTH;
   NSLog(@"value of area : %d", area);
   NSLog(@"%c", NEWLINE);

   return 0;
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
2013-09-07 22:19:24.780 demo[25621] value of area : 50
2013-09-07 22:19:24.781 demo[25621] 
</pre>
<p>Note that it is a good programming practice to define constants in CAPITALS.</p>
<h1>Objective-C Operators</h1>
<p>An operator is a symbol that tells the compiler to perform specific mathematical or logical manipulations. Objective-C language is rich in built-in operators and provides following types of operators:</p>
<ul class="list">
<li><p>Arithmetic Operators</p></li>
<li><p>Relational Operators</p></li>
<li><p>Logical Operators</p></li>
<li><p>Bitwise Operators</p></li>
<li><p>Assignment Operators</p></li>
<li><p>Misc Operators</p></li>
</ul>
<p>This tutorial will explain the arithmetic, relational, logical, bitwise, assignment and other operators one by one.</p>
<h2>Arithmetic Operators</h2>
<p>Following table shows all the arithmetic operators supported by Objective-C language. Assume variable <b>A</b> holds 10 and variable <b>B</b> holds 20, then:</p>
<p><a href="/objective_c/objective_c_arithmetic_operators.htm" title="Arithmetic Operators in Objective-C">Show Examples</a></p>
<table class="table table-bordered">
<tr>
<th style="width:10%">Operator</th>
<th style="width:55%;">Description</th>
<th>Example</th>
</tr>
<tr>
<td>+</td>
<td>Adds two operands</td>
<td> A + B will give 30</td>
</tr>
<tr>
<td>-</td>
<td>Subtracts second operand from the first</td>
<td> A - B will give -10</td>
</tr>
<tr>
<td>*</td>
<td>Multiplies both operands</td>
<td> A * B will give 200</td>
</tr>
<tr>
<td>/</td>
<td>Divides numerator by denominator</td>
<td> B / A will give 2</td>
</tr>
<tr>
<td>%</td>
<td>Modulus Operator and remainder of after an integer division</td>
<td> B % A will give 0</td>
</tr>
<tr>
<td>++</td>
<td>Increment operator increases integer value by one</td>
<td> A++ will give 11</td>
</tr>
<tr>
<td>--</td>
<td>Decrement operator decreases integer value by one</td>
<td> A-- will give 9</td>
</tr>
</table>
<h2>Relational Operators</h2>
<p>Following table shows all the relational operators supported by Objective-C language. Assume variable <b>A</b> holds 10 and variable <b>B</b> holds 20, then:</p>
<p><a href="/objective_c/objective_c_relational_operators.htm" title="Relational Operators in Objective-C">Show Examples</a></p>
<table class="table table-bordered">
<tr>
<th style="width:10%">Operator</th>
<th style="width:55%;">Description</th>
<th>Example</th>
</tr>
<tr>
<td>==</td>
<td> Checks if the values of two operands are equal or not; if yes, then condition becomes true.</td>
<td> (A == B) is not true. </td>
</tr>
<tr>
<td>!=</td>
<td> Checks if the values of two operands are equal or not; if values are not equal, then condition becomes true.</td>
<td> (A != B) is true. </td>
</tr>
<tr>
<td>&gt;</td>
<td> Checks if the value of left  operand is greater than the value of right operand; if yes, then condition becomes true.</td>
<td> (A &gt; B) is not true. </td>
</tr>
<tr>
<td>&lt;</td>
<td> Checks if the value of left  operand is less than the value of right operand; if yes, then condition becomes true.</td>
<td> (A &lt; B) is true. </td>
</tr>
<tr>
<td>&gt;=</td>
<td> Checks if the value of left  operand is greater than or equal to the value of right operand; if yes, then condition becomes true.</td>
<td> (A &gt;= B) is not true. </td>
</tr>
<tr>
<td>&lt;=</td>
<td> Checks if the value of left  operand is less than or equal to the value of right operand; if yes, then condition becomes true.</td>
<td> (A &lt;= B) is true. </td>
</tr>
</table>
<h2>Logical Operators</h2>
<p>Following table shows all the logical operators supported by Objective-C language. Assume variable <b>A</b> holds 1 and variable <b>B</b> holds 0, then:</p>
<p><a href="/objective_c/objective_c_logical_operators.htm" title="Logical Operators in Objective-C">Show Examples</a></p>
<table class="table table-bordered">
<tr>
<th style="width:10%">Operator</th>
<th style="width:55%;">Description</th>
<th>Example</th>
</tr>
<tr>
<td>&amp;&amp;</td>
<td> Called Logical AND  operator. If both the operands are non zero then condition becomes true.</td>
<td> (A &amp;&amp; B) is false. </td>
</tr>
<tr>
<td>||</td>
<td>Called Logical OR Operator.  If any of the two operands is non zero then condition becomes true.</td>
<td> (A || B) is true. </td>
</tr>
<tr>
<td>!</td>
<td>Called Logical NOT Operator.  Use to reverses the logical state of its operand. If a condition is true, then Logical NOT operator will make false.</td>
<td> !(A &amp;&amp; B) is true. </td>
</tr>
</table>
<h2>Bitwise Operators</h2>
<p>Bitwise operator works on bits and perform bit by bit operation. The truth tables for &amp;, |, and ^ are as follows:</p>
<table class="table table-bordered">
<tr>
<th style="width:20%">p</th>
<th style="width:20%">q</th>
<th style="width:20%">p &amp; q</th>
<th style="width:20%">p | q</th>
<th style="width:20%">p ^ q</th>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
</table>
<p>Assume if A = 60; and B = 13; now in binary format they will be as follows:</p>
<p>A = 0011 1100</p>
<p>B = 0000 1101</p>
<p>-----------------</p>
<p>A&amp;B = 0000 1100</p>
<p>A|B = 0011 1101</p>
<p>A^B = 0011 0001</p>
<p>~A&nbsp; = 1100 0011</p>
<p>The Bitwise operators supported by Objective-C language are listed in the following table. Assume variable A holds 60 and variable B holds 13 then:</p>
<p><a href="/objective_c/objective_c_bitwise_operators.htm" title="Bitwise Operators in Objective-C">Show Examples</a></p>
<table class="table table-bordered">
<tr>
<th style="width:10%">Operator</th>
<th style="width:55%;">Description</th>
<th>Example</th>
</tr>
<tr>
<td>&amp;</td>
<td> Binary AND Operator copies a bit to the result if it exists in both operands. </td>
<td> (A &amp; B) will give 12, which is 0000 1100</td>
</tr>
<tr>
<td>|</td>
<td> Binary OR Operator copies a bit if it exists in either operand. </td>
<td> (A | B) will give 61, which is 0011 1101</td>
</tr>
<tr>
<td>^</td>
<td> Binary XOR Operator copies the bit if it is set in one operand but not both. </td>
<td> (A ^ B) will give 49, which is 0011 0001</td>
</tr>
<tr>
<td>~</td>
<td> Binary Ones Complement Operator is unary and has the effect of 'flipping' bits. </td>
<td> (~A ) will give -61, which is 1100 0011 in 2's complement form.</td>
</tr>
<tr><td>&lt;&lt;</td>
<td> Binary Left Shift Operator. The left operands value is moved left by the number of bits specified by the right operand. </td>
<td> A &lt;&lt; 2 will give 240, which is 1111 0000</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td> Binary Right Shift Operator. The left operands value is moved right by the number of bits specified by the right operand. </td>
<td> A &gt;&gt; 2 will give 15, which is 0000 1111</td>
</tr>
</table>
<h2>Assignment Operators</h2>
<p>There are following assignment operators supported by Objective-C language:</p>
<p><a href="/objective_c/objective_c_assignment_operators.htm" title="Assignment Operators in Objective-C">Show Examples</a></p>
<table class="table table-bordered">
<tr>
<th style="width:10%">Operator</th>
<th style="width:55%;">Description</th>
<th>Example</th>
</tr>
<tr>
<td>=</td>
<td>Simple assignment operator, Assigns values from right side operands to left side operand</td>
<td> C = A + B will assign value of A + B into C</td>
</tr>
<tr>
<td>+=</td>
<td>Add AND assignment operator, It adds right operand to the left operand and assigns the result to left operand</td>
<td> C += A is equivalent to C = C + A</td>
</tr>
<tr>
<td>-=</td>
<td>Subtract AND assignment operator, It subtracts right operand from the left operand and assigns the result to left operand</td>
<td> C -= A is equivalent to C = C - A</td>
</tr>
<tr>
<td>*=</td>
<td>Multiply AND assignment operator, It multiplies right operand with the left operand and assigns the result to left operand</td>
<td> C *= A is equivalent to C = C * A</td>
</tr>
<tr>
<td>/=</td>
<td>Divide AND assignment operator, It divides left operand with the right operand and assigns the result to left operand</td>
<td> C /= A is equivalent to C = C / A</td>
</tr>
<tr>
<td>%=</td>
<td>Modulus AND assignment operator, It takes modulus using two operands and assigns the result to  left operand</td><td> C %= A is equivalent to C = C % A</td>
</tr>
<tr>
<td>&lt;&lt;=</td>
<td>Left shift AND assignment operator </td>
<td> C &lt;&lt;= 2 is same as  C = C &lt;&lt; 2</td>
</tr>
<tr>
<td>&gt;&gt;=</td>
<td>Right shift AND assignment operator </td>
<td> C &gt;&gt;= 2 is same as  C = C &gt;&gt; 2</td>
</tr>
<tr>
<td>&amp;=</td>
<td>Bitwise AND assignment operator</td>
<td> C &amp;= 2 is same as  C = C &amp; 2</td>
</tr>
<tr>
<td>^=</td>
<td>bitwise exclusive OR and assignment operator</td>
<td> C ^= 2 is same as  C = C ^ 2</td>
</tr>
<tr>
<td>|=</td>
<td>bitwise inclusive OR and assignment operator</td>
<td> C |= 2 is same as  C = C | 2</td>
</tr>
</table>
<h2> Misc Operators &map; sizeof &amp; ternary</h2>
<p>There are few other important operators including <b>sizeof</b> and <b>? :</b>  supported by Objective-C Language.</p>
<p><a href="/objective_c/objective_c_sizeof_operator.htm" title="sizeof operator in C">Show Examples</a></p>
<table class="table table-bordered">
<tr>
<th style="width:10%">Operator</th>
<th style="width:55%;">Description</th>
<th>Example</th>
</tr>
<tr>
<td>sizeof()</td>
<td>Returns the size of an variable.</td>
<td> sizeof(a), where a is integer, will return 4.</td>
</tr>
<tr>
<td>&amp;</td>
<td>Returns the address of an variable.</td>
<td>&amp;a; will give actual address of the variable.</td>
</tr>
<tr>
<td>*</td>
<td>Pointer to a variable.</td>
<td>*a; will pointer to a variable.</td>
</tr>
<tr>
<td>? :</td><td>Conditional Expression</td>
<td> If Condition is true ? Then value X : Otherwise value Y</td>
</tr>
</table>
<h2>Operators Precedence in Objective-C</h2>
<p>Operator precedence determines the grouping of terms in an expression. This affects how an expression is evaluated. Certain operators have higher precedence than others; for example, the multiplication operator has higher precedence than the addition operator:</p>
<p>For example, x = 7 + 3 * 2; here, x is assigned 13, not 20 because operator * has higher precedence than +, so it first gets multiplied with 3*2 and then adds into 7.</p>
 <p>Here, operators with the highest precedence appear at the top of the table, those with the lowest appear at the bottom. Within an expression, higher precedence operators will be evaluated first.</p>
<p><a href="/objective_c/objective_c_operators_precedence.htm" title="Operators Precedence in Objective-C">Show Examples</a></p>
<table class="table table-bordered">
<tr> 
<th>Category&nbsp;</th> 
<th>Operator&nbsp;</th>
<th>Associativity&nbsp;</th> 
</tr> 
<tr> 
<td>Postfix&nbsp;</td>
<td>() [] -&gt; .  ++   - - &nbsp;</td> 
<td>Left to right&nbsp;</td> 
</tr>
<tr> 
<td>Unary&nbsp;</td> 
<td>+  -   !  ~  ++  - -   (type)*  &amp;  sizeof&nbsp;</td> 
<td>Right to left&nbsp;</td>
</tr> 
<tr> 
<td>Multiplicative &nbsp;</td> 
<td>*  /  %&nbsp;</td>
<td>Left to right&nbsp;</td> 
</tr> 
<tr> 
<td>Additive &nbsp;</td>
<td>+  -&nbsp;</td> 
<td>Left to right&nbsp;</td> 
</tr>
<tr> 
<td>Shift &nbsp;</td> 
<td>&lt;&lt; &gt;&gt;&nbsp;</td> 
<td>Left to right&nbsp;</td> 
</tr> 
<tr> 
<td>Relational &nbsp;</td>
<td>&lt; &lt;=  &gt; &gt;=&nbsp;</td> 
<td>Left to right&nbsp;</td> 
</tr>
<tr> 
<td>Equality &nbsp;</td> 
<td>==  !=&nbsp;</td> 
<td>Left to right&nbsp;</td> 
</tr> 
<tr> 
<td>Bitwise AND&nbsp;</td>
<td>&amp;&nbsp;</td> 
<td>Left to right&nbsp;</td> 
</tr> 
<tr> 
<td>Bitwise XOR&nbsp;</td> 
<td>^&nbsp;</td> 
<td>Left to right&nbsp;</td>
</tr> 
<tr> 
<td>Bitwise OR&nbsp;</td> 
<td>|&nbsp;</td> 
<td>Left to right&nbsp;</td>
</tr> 
<tr> 
<td>Logical AND&nbsp;</td>
<td>&amp;&amp;&nbsp;</td> 
<td>Left to right&nbsp;</td>
</tr>
<tr>
<td>Logical OR&nbsp;</td> 
<td>||&nbsp;</td> 
<td>Left to right&nbsp;</td>
</tr> 
<tr> 
<td>Conditional&nbsp;</td>
<td>?:&nbsp;</td> 
<td>Right to left&nbsp;</td> 
</tr>
<tr>
<td>Assignment&nbsp;</td> 
<td>=  +=  -=  *=  /=  %=&gt;&gt;=  &lt;&lt;=  &amp;=  ^=   |=&nbsp;</td>
<td>Right to left&nbsp;</td>
</tr>
<tr> 
<td>Comma&nbsp;</td> 
<td>,&nbsp;</td> 
<td>Left to right&nbsp;</td>
</tr> 
</table>
<h1>Objective-C Loops</h1>
<p>There may be a situation, when you need to execute a block of code several number of times. In general, statements are executed sequentially: The first statement in a function is executed first, followed by the second, and so on.</p>
<p>Programming languages provide various control structures that allow for more complicated execution paths.</p>
<p>A loop statement allows us to execute a statement or group of statements multiple times and following is the general form of a loop statement in most of the programming languages:</p>
<img src="/objective_c/images/loop_architecture.jpg" alt="Loop Architecture" />
<p>Objective-C programming language provides the following types of loop to handle looping requirements. Click the following links to check their details.</p>
<table class="table table-bordered">
<tr>
<th style="width:30%">Loop Type</th>
<th>Description</th>
</tr>
<tr>
<td><a href="/objective_c/objective_c_while_loop.htm" title="while loop in Objective-C">while loop</a></td>
<td>Repeats a statement or group of statements while a given condition is true. It tests the condition before executing the loop body.</td>
</tr>
<tr>
<td><a href="/objective_c/objective_c_for_loop.htm" title="for loop in Objective-C">for loop</a></td>
<td>Execute a sequence of statements multiple times and abbreviates the code that manages the loop variable.</td>
</tr>
<tr>
<td><a href="/objective_c/objective_c_do_while_loop.htm" title="do...while loop in Objective-C">do...while loop</a></td><td>Like a while statement, except that it tests the condition at the end of the loop body.</td>
</tr>
<tr>
<td><a href="/objective_c/objective_c_nested_loops.htm" title="nested loops in Objective-C">nested loops</a></td>
<td>You can use one or more loops inside any another while, for or do..while loop.</td>
</tr>
</table>
<h2>Loop Control Statements:</h2>
<p>Loop control statements change execution from its normal sequence. When execution leaves a scope, all automatic objects that were created in that scope are destroyed.</p>
<p>Objective-C supports the following control statements. Click the following links to check their details.</p>
<table class="table table-bordered">
<tr>
<th style="width:30%">Control Statement</th>
<th>Description</th>
</tr>
<tr>
<td><a href="/objective_c/objective_c_break_statement.htm" title="break statement in Objective-C">break statement</a></td>
<td>Terminates the <b>loop</b> or <b>switch</b> statement and transfers execution to the statement immediately following the loop or switch.</td>
</tr>
<tr>
<td><a href="/objective_c/objective_c_continue_statement.htm" title="continue statement in Objective-C">continue statement</a></td>
<td>Causes the loop to skip the remainder of its body and immediately retest its condition prior to reiterating.</td>
</tr>
</table>
<h2>The Infinite Loop:</h2>
<p>A loop becomes infinite loop if a condition never becomes false. The <b>for</b> loop is traditionally used for this purpose. Since none of the three expressions that form the for loop are required, you can make an endless loop by leaving the conditional expression empty.</p>
<pre class="prettyprint notranslate">
#import &lt;Foundation/Foundation.h&gt;
 
int main ()
{

   for( ; ; )
   {
      NSLog(@"This loop will run forever.\n");
   }

   return 0;
}
</pre>
<p>When the conditional expression is absent, it is assumed to be true. You may have an initialization and increment expression, but Objective-C programmers more commonly use the for(;;) construct to signify an infinite loop.</p>
<h1>Objective-C Decision Making</h1>
<p>Decision making structures require that the programmer specify one or more conditions to be evaluated or tested by the program, along with a statement or statements to be executed if the condition is determined to be true, and optionally, other statements to be executed if the condition is determined to be false.</p>
<p>Following is the general form of a typical decision making structure found in most of the programming languages:</p>
<img src="/objective_c/images/decision_making.jpg" alt="Decision making statements in Objective-C" />
<p>Objective-C programming language assumes any <b>non-zero</b> and <b>non-null</b> values as <b>true</b>, and if it is either <b>zero</b> or <b>null</b>, then it is assumed as <b>false</b> value.</p>
<p>Objective-C programming language provides following types of decision making statements. Click the following links to check their details:</p>
<table class="table table-bordered">
<tr>
<th style="width:35%">Statement</th>
<th>Description</th>
</tr>
<tr>
<td><a href="/objective_c/if_statement_in_objective_c.htm" title="if statement in Objective-C">if statement</a></td>
<td>An <b>if statement</b> consists of a boolean expression followed by one or more statements.</td>
</tr>
<tr>
<td><a href="/objective_c/if_else_statement_in_objective_c.htm" title="if...else statement in Objective-C">if...else statement</a></td>
<td>An <b>if statement</b> can be followed by an optional <b>else statement</b>, which executes when the boolean expression is false.</td>
</tr>
<tr>
<td><a href="/objective_c/nested_if_statements_in_objective_c.htm" title="nested if statements in Objective-C">nested if statements</a></td>
<td>You can use one <b>if</b> or <b>else if</b> statement inside another <b>if</b> or <b>else if</b> statement(s).</td>
</tr>
<tr>
<td><a href="/objective_c/switch_statement_in_objective_c.htm" title="switch statement in Objective-C">switch statement</a></td>
<td>A <b>switch</b> statement allows a variable to be tested for equality against a list of values.</td>
</tr>
<tr>
<td><a href="/objective_c/nested_switch_statements_in_objective_c.htm" title="nested switch statements in Objective-C">nested switch statements</a></td>
<td>You can use one <b>switch</b> statement inside another <b>switch</b> statement(s).</td>
</tr>
</table>
<h2>The ? : Operator:</h2>
<p>We have covered <b>conditional operator ? :</b> in previous chapter which can be used to replace <b>if...else</b> statements. It has the following general form:</p>
<pre class="prettyprint notranslate">
Exp1 ? Exp2 : Exp3;
</pre>
<p>Where Exp1, Exp2, and Exp3 are expressions. Notice the use and placement of the colon.</p>
<p>The value of a ? expression is determined like this: Exp1 is evaluated. If it is true, then Exp2 is evaluated and becomes the value of the entire ? expression. If Exp1 is false, then Exp3 is evaluated and its value becomes the value of the expression.</p>
<h1>Objective-C Functions</h1>
<p>A function is a group of statements that together perform a task. Every Objective-C program has one C function, which is <b>main()</b>, and all of the most trivial programs can define additional functions.</p>
<p>You can divide up your code into separate functions. How you divide up your code among different functions is up to you, but logically the division usually is so each function performs a specific task.</p>
<p>A function <b>declaration</b> tells the compiler about a function's name, return type, and parameters. A function <b>definition</b> provides the actual body of the function.</p>
<p>Basically in Objective-C, we call the function as method.</p>
<p>The Objective-C foundation framework provides numerous built-in methods that your program can call. For example, method <b>appendString()</b> to append string to another string.</p>
<p>A method is known with various names like a function  or a sub-routine or a procedure, etc.</p>
<h2>Defining a Method</h2>
<p>The general form of a method definition in Objective-C programming language is as follows:</p>
<pre class="prettyprint notranslate">
- (return_type) method_name:( argumentType1 )argumentName1 
joiningArgument2:( argumentType2 )argumentName2 ... 
joiningArgumentn:( argumentTypen )argumentNamen 
{
   body of the function
}
</pre>
<p>A method definition in Objective-C programming language consists of a <i>method header</i> and a <i>method body</i>. Here are all the parts of a method:</p>
<ul class="list">
<li><p><b>Return Type:</b> A method may return a value. The <b>return_type</b> is the data type of the value the function returns. Some methods perform the desired operations without returning a value. In this case, the return_type is the keyword <b>void</b>.</p></li>
<li><p><b>Method Name:</b> This is the actual name of the method. The method name and the parameter list together constitute the method signature.</p></li>
<li><p><b>Arguments:</b> A argument is like a placeholder. When a function is invoked, you pass a value to the argument. This value is referred to as actual parameter or argument. The parameter list refers to the type, order, and number of the arguments of a method. Arguments are optional; that is, a method may contain no argument.</p></li>
<li><p><b>Joining Argument:</b> A joining argument is to make it easier to read and to make it clear while calling it.</p></li>
<li><p><b>Method Body:</b> The method body contains a collection of statements that define what the method does.</p></li>
</ul>
<h2>Example:</h2>
<p>Following is the source code for a method called <b>max()</b>. This method takes two parameters num1 and num2 and returns the maximum between the two:</p>
<pre class="prettyprint notranslate">
/* function returning the max between two numbers */
- (int) max:(int) num1 secondNumber:(int) num2 
{
   /* local variable declaration */
   int result;
 
   if (num1 &gt; num2)
   {
      result = num1;
   }
   else
   {
      result = num2;
   }
 
   return result; 
}
</pre>
<h2>Method Declarations:</h2>
<p>A method <b>declaration</b> tells the compiler about a function name and how to call the method. The actual body of the function can be defined separately.</p>
<p>A method declaration has the following parts:</p>
<pre class="prettyprint notranslate">
- (return_type) function_name:( argumentType1 )argumentName1 
joiningArgument2:( argumentType2 )argumentName2 ... 
joiningArgumentn:( argumentTypen )argumentNamen;
</pre>
<p>For the above-defined function max(), following is the method declaration:</p>
<pre class="prettyprint notranslate">
-(int) max:(int)num1 andNum2:(int)num2;
</pre>

<p>Method declaration is required when you define a method in one source file and you call that method in another file. In such case you should declare the function at the top of the file calling the function.</p>
<h2>Calling a method:</h2>
<p>While creating a Objective-C method, you give a definition of what the function has to do. To use a method, you will have to call that function to perform the defined task.</p>
<p>When a program calls a function, program control is transferred to the called method. A called method performs defined task, and when its return statement is executed or when its function-ending closing brace is reached, it returns program control back to the main program.</p>
<p>To call a method, you simply need to pass the required parameters along with method name, and if method returns a value, then you can store returned value. For example:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

@interface SampleClass:NSObject
/* method declaration */
- (int)max:(int)num1 andNum2:(int)num2;
@end

@implementation SampleClass

/* method returning the max between two numbers */
- (int)max:(int)num1 andNum2:(int)num2{
/* local variable declaration */
   int result;
 
   if (num1 > num2)
   {
      result = num1;
   }
   else
   {
      result = num2;
   }
 
   return result; 
}

@end

int main ()
{
   /* local variable definition */
   int a = 100;
   int b = 200;
   int ret;
   
   SampleClass *sampleClass = [[SampleClass alloc]init];

   /* calling a method to get max value */
   ret = [sampleClass max:a andNum2:b];
 
   NSLog(@"Max value is : %d\n", ret );
 
   return 0;
}
</pre>
<p>I kept max() function along with main() function and complied the source code. While running final executable, it would produce the following result:</p>
<pre class="prettyprint notranslate">
2013-09-07 22:28:45.912 demo[26080] Max value is : 200
</pre>
<h2>Function Arguments:</h2>
<p>If a function is to use arguments, it must declare variables that accept the values of the arguments. These variables are called the <b>formal parameters</b> of the function.</p>
<p>The formal parameters behave like other local variables inside the function and are created upon entry into the function and destroyed upon exit.</p>
<p>While calling a function, there are two ways that arguments can be passed to a function:</p>
<table class="table table-bordered">
<tr>
<th style = "width:30%">Call Type</th>
<th>Description</th>
</tr>
<tr>
<td><a href="/objective_c/objective_c_function_call_by_value.htm" title="Function call by value in Objective-C">Call by value</a></td>
<td>This method copies the actual value of an argument into the formal parameter of the function. In this case, changes made to the parameter inside the function have no effect on the argument. </td> 
</tr>
<tr>
<td> <a href="/objective_c/objective_c_function_call_by_reference.htm" title="Function call by reference in Objective-C">Call by reference</a></td>
<td>This method copies the address of an argument into the formal parameter. Inside the function, the address is used to access the actual argument used in the call. This means that changes made to the parameter affect the argument.</td> 
</tr>
</table>
<p>By default, Objective-C uses <b>call by value</b> to pass arguments. In general, this means that code within a function cannot alter the arguments used to call the function, and above-mentioned example while calling max() function used the same method.</p>
<h1>Objective-C Blocks</h1>
<p>An Objective-C class defines an object that combines data with related behavior. Sometimes, it makes sense just to represent a single task or unit of behavior, rather than a collection of methods.</p>
<p>Blocks are a language-level feature added to C, Objective-C and C++ which allow you to create distinct segments of code that can be passed around to methods or functions as if they were values. Blocks are Objective-C objects which means they can be added to collections like NSArray or NSDictionary. They also have the ability to capture values from the enclosing scope, making them similar to closures or lambdas in other programming languages </p>
<h2>Simple Block declaration syntax</h2>
<pre class="prettyprint notranslate">
returntype (^blockName)(argumentType);
</pre>
<p>Simple block implementation</p>
<pre class="prettyprint notranslate">
returntype (^blockName)(argumentType)= ^{
};
</pre>
<h2>Here is a simple example</h2>
<pre class="prettyprint notranslate">
void (^simpleBlock)(void) = ^{
    NSLog(@"This is a block");
};
</pre>
<h2>We can invoke the block using</h2>
<pre class="prettyprint notranslate">
simpleBlock();
</pre>
<h2>Blocks Take Arguments and Return Values</h2>
<p>Blocks can also take arguments and return values just like methods and functions.</p>
<p>Here is a simple example to implement and invoke a block with arguments and return values.</p>
<pre class="prettyprint notranslate">
double (^multiplyTwoValues)(double, double) = 
    ^(double firstValue, double secondValue) {
	    return firstValue * secondValue;
    };
double result = multiplyTwoValues(2,4); 
NSLog(@"The result is %f", result);
</pre>
<h2>Blocks using type definitions</h2>
<p>Here is a simple example using typedef in block. Please note this sample <b>doesn't work</b> on the <b>online compiler</b> for now. Use <b>XCode</b> to run the same.</p>
<pre class="prettyprint notranslate">
#import &lt;Foundation/Foundation.h&gt;

typedef void (^CompletionBlock)();
@interface SampleClass:NSObject
- (void)performActionWithCompletion:(CompletionBlock)completionBlock;
@end

@implementation SampleClass

- (void)performActionWithCompletion:(CompletionBlock)completionBlock{

    NSLog(@"Action Performed");
    completionBlock();
}

@end

int main()
{
    /* my first program in Objective-C */
    SampleClass *sampleClass = [[SampleClass alloc]init];
    [sampleClass performActionWithCompletion:^{
        NSLog(@"Completion is called to intimate action is performed.");
    }];
    
    return 0;
}
</pre>
<p>Let us compile and execute it, it will produce the following result:</p>
<pre class="prettyprint notranslate">
2013-09-10 08:13:57.155 demo[284:303] Action Performed
2013-09-10 08:13:57.157 demo[284:303] Completion is called to intimate action is performed.
</pre>
<p>Blocks are used more in iOS applications and Mac OS X. So its more important to understand the usage of blocks.</p>
<h1>Objective-C Numbers</h1>
<p>In Objective-C programming language, in order to save the basic data types like int, float, bool in object form,</p>
<p>Objective-C provides a range of methods to work with NSNumber and important ones are listed in following table.</p>
<table class="table table-bordered">
<tr>
<th>S.N.</th>
<th>Method and Description</th>
</tr>
<tr>
<td>1</td>
<td><b>+ (NSNumber *)numberWithBool:(BOOL)value</b>
<p>Creates and returns an NSNumber object containing a given value, treating it as a BOOL.</p></td> 
</tr>
<tr>
<td>2</td>
<td><b>+ (NSNumber *)numberWithChar:(char)value</b>
<p>Creates and returns an NSNumber object containing a given value, treating it as a signed char.</p></td> 
</tr>
<tr>
<td>3</td>
<td><b>+ (NSNumber *)numberWithDouble:(double)value</b>
<p>Creates and returns an NSNumber object containing a given value, treating it as a double.</p></td> 
</tr>
<tr>
<td>4</td>
<td><b>+ (NSNumber *)numberWithFloat:(float)value</b>
<p>Creates and returns an NSNumber object containing a given value, treating it as a float.</p></td> 
</tr>
<tr>
<td>5</td>
<td><b>+ (NSNumber *)numberWithInt:(int)value</b>
<p>Creates and returns an NSNumber object containing a given value, treating it as a signed int.</p></td> 
</tr>
<tr>
<td>6</td>
<td><b>+ (NSNumber *)numberWithInteger:(NSInteger)value</b>
<p>Creates and returns an NSNumber object containing a given value, treating it as an NSInteger.</p></td> 
</tr>
<tr>
<td>7</td>
<td><b>- (BOOL)boolValue</b>
<p>Returns the receiver's value as a BOOL.</p></td> 
</tr>
<tr>
<td>8</td>
<td><b>- (char)charValue</b>
<p>Returns the receiver's value as a char.</p></td>
</tr>
<tr>
<td>9</td>
<td><b>- (double)doubleValue</b>
<p>Returns the receiver's value as a double. </p></td> 
</tr>
<tr>
<td>10</td>
<td><b>- (float)floatValue</b>
<p>Returns the receiver's value as a float.</p></td> 
</tr>
<tr>
<td>11</td>
<td><b>- (NSInteger)integerValue</b>
<p>Returns the receiver's value as an NSInteger. </p></td> 
</tr>
<tr>
<td>12</td>
<td><b>- (int)intValue</b>
<p>Returns the receiver's value as an int.</p></td> 
</tr>
<tr>
<td>13</td>
<td><b>- (NSString *)stringValue</b>
<p>Returns the receiver's value as a human-readable string.</p></td> 
</tr>
</table>
<p>Here is a simple example for using NSNumber which multiplies two numbers and returns the product.</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

@interface SampleClass:NSObject

- (NSNumber *)multiplyA:(NSNumber *)a withB:(NSNumber *)b;

@end

@implementation SampleClass

- (NSNumber *)multiplyA:(NSNumber *)a withB:(NSNumber *)b
{
   float number1 = [a floatValue];
   float number2 = [b floatValue];
   float product = number1 * number2;
   NSNumber *result = [NSNumber numberWithFloat:product];
   return result;
}

@end

int main()
{
   NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];

   SampleClass *sampleClass = [[SampleClass alloc]init];
   NSNumber *a = [NSNumber numberWithFloat:10.5];
   NSNumber *b = [NSNumber numberWithFloat:10.0];   
   NSNumber *result = [sampleClass multiplyA:a withB:b];
   NSString *resultString = [result stringValue];
   NSLog(@"The product is %@",resultString);

   [pool drain];
   return 0;
}
</pre>

<p>Now when we compile and run the program, we will get the following result.</p>
<pre class="prettyprint notranslate">
2013-09-14 18:53:40.575 demo[16787] The product is 105
</pre>
<h1>Objective-C Arrays</h1>
<p>Objective-C programming language provides a data structure called <b>the array</b>, which can store a fixed-size sequential collection of elements of the same type. An array is used to store a collection of data, but it is often more useful to think of an array as a collection of variables of the same type.</p>
<p>Instead of declaring individual variables, such as number0, number1, ..., and number99, you declare one array variable such as numbers and use numbers[0], numbers[1], and ..., numbers[99] to represent individual variables. A specific element in an array is accessed by an index. </p>
<p>All arrays consist of contiguous memory locations. The lowest address corresponds to the first element and the highest address to the last element.</p>
<img src="/objective_c/images/arrays.jpg" alt="Arrays in Objective-C" />
<h2>Declaring Arrays</h2>
<p>To declare an array in Objective-C, a programmer specifies the type of the elements and the number of elements required by an array as follows:</p>
<pre class="prettyprint notranslate">
type arrayName [ arraySize ];
</pre>
<p>This is called a <i>single-dimensional</i> array. The <b>arraySize</b> must be an integer constant greater than zero and <b>type</b> can be any valid Objective-C data type. For example, to declare a 10-element array called <b>balance</b> of type double, use this statement:</p>
<pre class="prettyprint notranslate">
double balance[10];
</pre>
<p>Now, <i>balance</i> is a variable array, which is sufficient to hold up to 10 double numbers.</p>
<h2>Initializing Arrays</h2>
<p>You can initialize an array in Objective-C either one by one or using a single statement as follows:</p>
<pre class="prettyprint notranslate">
double balance[5] = {1000.0, 2.0, 3.4, 17.0, 50.0};
</pre>
<p>The number of values between braces { } can not be larger than the number of elements that we declare for the array between square brackets [ ]. Following is an example to assign a single element of the array:</p>
<p>If you omit the size of the array, an array just big enough to hold the initialization is created.  Therefore, if you write:</p>
<pre class="prettyprint notranslate">
double balance[] = {1000.0, 2.0, 3.4, 17.0, 50.0};
</pre>
<p>You will create exactly the same array as you did in the previous example.</p>
<pre class="prettyprint notranslate">
balance[4] = 50.0;
</pre>
<p>The above statement assigns element number 5th in the array a value of 50.0. Array with 4th index will be 5th, i.e., last element because all arrays have 0 as the index of their first element which is also called base index. Following is the pictorial representation  of the same array we discussed above:</p>
<img src="/objective_c/images/array_presentation.jpg" alt="Array Presentation" />
<h2>Accessing Array Elements</h2>
<p>An element is accessed by indexing the array name. This is done by placing the index of the element within square brackets after the name of the array. For example:</p>
<pre class="prettyprint notranslate">
double salary = balance[9];
</pre>
<p>The above statement will take 10th element from the array and assign the value to salary variable. Following is an example, which will use all the above mentioned three concepts viz. declaration, assignment and accessing arrays:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;
 
int main ()
{
   int n[ 10 ]; /* n is an array of 10 integers */
   int i,j;
 
   /* initialize elements of array n to 0 */         
   for ( i = 0; i &lt; 10; i++ )
   {
      n[ i ] = i + 100; /* set element at location i to i + 100 */
   }
   
   /* output each array element's value */
   for (j = 0; j &lt; 10; j++ )
   {
      NSLog(@"Element[%d] = %d\n", j, n[j] );
   }
 
   return 0;
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
2013-09-14 01:24:06.669 demo[16508] Element[0] = 100
2013-09-14 01:24:06.669 demo[16508] Element[1] = 101
2013-09-14 01:24:06.669 demo[16508] Element[2] = 102
2013-09-14 01:24:06.669 demo[16508] Element[3] = 103
2013-09-14 01:24:06.669 demo[16508] Element[4] = 104
2013-09-14 01:24:06.669 demo[16508] Element[5] = 105
2013-09-14 01:24:06.669 demo[16508] Element[6] = 106
2013-09-14 01:24:06.669 demo[16508] Element[7] = 107
2013-09-14 01:24:06.669 demo[16508] Element[8] = 108
2013-09-14 01:24:06.669 demo[16508] Element[9] = 109
</pre>
<h2>Objective-C Arrays in Detail</h2>
<p>Arrays are important to Objective-C and need lots of more details. There are following few important concepts related to array which should be clear to a Objective-C programmer:</p>
<table class="table table-bordered">
<tr>
<th style="width:30%">Concept</th>
<th>Description</th>
</tr>
<tr>
<td><a href="/objective_c/objective_c_multi_dimensional_arrays.htm" title="Multi-dimensional arrays in Objective-C">Multi-dimensional arrays</a></td>
<td>Objective-C supports multidimensional arrays. The simplest form of the multidimensional array is the two-dimensional array.</td> 
</tr>
<tr>
<td><a href="/objective_c/objective_c_passing_arrays_to_functions.htm" title="Passing arrays to functions as arguments in Objective-C">Passing arrays to functions</a></td>
<td>You can pass to the function a pointer to an array by specifying the array's name without an index.</td> 
</tr>
<tr>
<td> <a href="/objective_c/objective_c_return_arrays_from_function.htm" title="Return array from function in Objective-C">Return array from a function</a></td>
<td>Objective-C allows a function to return an array.</td> 
</tr>
<tr>
<td><a href="/objective_c/objective_c_pointer_to_an_array.htm" title="Pointer to an array in Objective-C">Pointer to an array</a></td>
<td>You can generate a pointer to the first element of an array by simply specifying the array name, without any index.</td> </tr>
</table>
<h1>Objective-C Pointers</h1>
<p>Pointers in Objective-C are easy and fun to learn. Some Objective-C programming tasks are performed more easily with pointers, and other tasks, such as dynamic memory allocation, cannot be performed without using pointers. So it becomes necessary to learn pointers to become a perfect Objective-C programmer. Let's start learning them in simple and easy steps.</p>
<p>As you know, every variable is a memory location and every memory location has its address defined which can be accessed using ampersand (&amp;) operator, which denotes an address in memory. Consider the following example, which will print the address of the variables defined:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

int main ()
{
   int  var1;
   char var2[10];

   NSLog(@"Address of var1 variable: %x\n", &amp;var1  );
   NSLog(@"Address of var2 variable: %x\n", &amp;var2  );

   return 0;
}
</pre>
<p>When the above code is compiled and executed, it produces the result something as follows:</p>
<pre class="prettyprint notranslate">
2013-09-13 03:18:45.727 demo[17552] Address of var1 variable: 1c0843fc
2013-09-13 03:18:45.728 demo[17552] Address of var2 variable: 1c0843f0
</pre>
<p>So, you understood what is memory address and how to access it, so base of the concept is over. Now let us see what is a pointer.</p>
<h2>What Are Pointers?</h2>
<p>A <b>pointer</b> is a variable whose value is the address of another variable, i.e., direct address of the memory location. Like any variable or constant, you must declare a pointer before you can use it to store any variable address. The general form of a pointer variable declaration is:</p>
<pre class="prettyprint notranslate">
type *var-name;
</pre>
<p>Here, <b>type</b> is the pointer's base type; it must be a valid Objective-C data type and <b>var-name</b> is the name of the pointer variable. The asterisk * you used to declare a pointer is the same asterisk that you use for multiplication. However, in this statement the asterisk is being used to designate a variable as a pointer. Following are the valid pointer declaration:</p>
<pre class="prettyprint notranslate">
int    *ip;    /* pointer to an integer */
double *dp;    /* pointer to a double */
float  *fp;    /* pointer to a float */
char   *ch     /* pointer to a character */
</pre>
<p>The actual data type of the value of all pointers, whether integer, float, character, or otherwise, is the same, a long hexadecimal number that represents a memory address. The only difference between pointers of different data types is the data type of the variable or constant that the pointer points to.</p>
<h2>How to use Pointers?</h2>
<p>There are few important operations, which we will do with the help of pointers very frequently. <b>(a)</b> we define a pointer variable, <b>(b)</b> assign the address of a variable to a pointer, and <b>(c)</b> finally access the value at the address available in the pointer variable. This is done by using unary operator <b>*</b> that returns the value of the variable located at the address specified by its operand. Following example makes use of these operations:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

int main ()
{
   int  var = 20;   /* actual variable declaration */
   int  *ip;        /* pointer variable declaration */

   ip = &amp;var;  /* store address of var in pointer variable*/

   NSLog(@"Address of var variable: %x\n", &amp;var  );

   /* address stored in pointer variable */
   NSLog(@"Address stored in ip variable: %x\n", ip );

   /* access the value using the pointer */
   NSLog(@"Value of *ip variable: %d\n", *ip );

   return 0;
}
</pre>
<p>When the above code is compiled and executed, it produces the result something as follows:</p>
<pre class="prettyprint notranslate">
2013-09-13 03:20:21.873 demo[24179] Address of var variable: 337ed41c
2013-09-13 03:20:21.873 demo[24179] Address stored in ip variable: 337ed41c
2013-09-13 03:20:21.874 demo[24179] Value of *ip variable: 20
</pre>
<h2>NULL Pointers in Objective-C</h2>
<p>It is always a good practice to assign a NULL value to a pointer variable in case you do not have exact address to be assigned. This is done at the time of variable declaration. A pointer that is assigned NULL is called a <b>null</b> pointer.</p>
<p>The NULL pointer is a constant with a value of zero defined in several standard libraries. Consider the following program:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

int main ()
{
   int  *ptr = NULL;

   NSLog(@"The value of ptr is : %x\n", ptr  );
 
   return 0;
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
2013-09-13 03:21:19.447 demo[28027] The value of ptr is : 0
</pre>
<p>On most of the operating systems, programs are not permitted to access memory at address 0 because that memory is reserved by the operating system. However, the memory address 0 has special significance; it signals that the pointer is not intended to point to an accessible memory location. But by convention, if a pointer contains the null (zero) value, it is assumed to point to nothing.</p>
<p>To check for a null pointer, you can use an if statement as follows:</p>
<pre class="prettyprint notranslate">
if(ptr)     /* succeeds if p is not null */
if(!ptr)    /* succeeds if p is null */
</pre>
<h2>Objective-C Pointers in Detail:</h2>
<p>Pointers have many but easy concepts and they are very important to Objective-C programming. There are following few important pointer concepts, which should be clear to a Objective-C programmer:</p>
<table class="table table-bordered">
<tr>
<th style="width:35%">Concept</th>
<th>Description</th>
</tr>
<tr>
<td> <a href="/objective_c/objective_c_pointer_arithmetic.htm" title="Objective-C - Pointer Arithmetic">Objective-C - Pointer arithmetic</a></td>
<td>There are four arithmetic operators that can be used on pointers: ++, --, +, -</td> 
</tr>
<tr>
<td> <a href="/objective_c/objective_c_array_of_pointers.htm" title="Objective-C - Array of Pointers">Objective-C  - Array of pointers</a></td>
<td>You can define arrays to hold a number of pointers.</td> 
</tr>
<tr>
<td> <a href="/objective_c/objective_c_pointer_to_pointer.htm" title="Objective-C - Pointer to Pointer Operators">Objective-C - Pointer to pointer</a></td>
<td>Objective-C allows you to have pointer on a pointer and so on.</td> 
</tr>
<tr>
<td> <a href="/objective_c/objective_c_passing_pointers_to_functions.htm" title="Passing pointers to functions in Objective-C">Passing pointers to functions in Objective-C</a></td>
<td>Passing an argument by reference or by address both enable the passed argument to be changed in the calling function by the called function.</td> 
</tr>
<tr>
<td> <a href="/objective_c/objective_c_return_pointer_from_functions.htm" title="Return pointer from functions in Objective-C">Return pointer from functions in Objective-C</a></td>
<td>Objective-C allows a function to return a pointer to local variable, static variable and dynamically allocated memory as well.</td> 
</tr>
</table>
<h1>Objective-C Strings</h1>
<p>The string in Objective-C programming language is represented using NSString and its subclass NSMutableString provides several ways for creating string objects. The simplest way to create a string object is to use the Objective-C  @"..." construct: </p>
<pre class="prettyprint notranslate">
NSString *greeting = @"Hello";
</pre>
<p>A simple example for creating and printing a string is shown below.</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

int main ()
{
   NSString *greeting = @"Hello";

   NSLog(@"Greeting message: %@\n", greeting );

   return 0;
}
</pre>
<p>When the above code is compiled and executed, it produces result something as follows:</p>
<pre class="prettyprint notranslate">
2013-09-11 01:21:39.922 demo[23926] Greeting message: Hello
</pre>
<p>Objective-C supports a wide range of methods for manipulate strings:</p>
<table class="table table-bordered">
<tr>
<th style="width:5%">S.N.</th>
<th>Method &amp; Purpose</th>
</tr>
<tr>
<td>1</td>
<td><b>- (NSString *)capitalizedString;</b>
<p>Returns a capitalized representation of the receiver.</p></td>
</tr>
<tr>
<td>2</td>
<td><b>- (unichar)characterAtIndex:(NSUInteger)index;</b>
<p>Returns the character at a given array position.</p></td>
</tr>
<tr><td>3</td>
<td><b>- (double)doubleValue;</b>
<p>Returns the floating-point value of the receiver&rsquo;s text as a double.</p></td>
</tr>
<tr>
<td>4</td>
<td><b>- (float)floatValue;</b>
<p>Returns the floating-point value of the receiver&rsquo;s text as a float.</p></td>
</tr>
<tr>
<td>5</td>
<td><b>- (BOOL)hasPrefix:(NSString *)aString;</b>
<p>Returns a Boolean value that indicates whether a given string matches the beginning characters of the receiver.</p></td>
</tr>
<tr>
<td>6</td>
<td><b>- (BOOL)hasSuffix:(NSString *)aString;</b>
<p>Returns a Boolean value that indicates whether a given string matches the ending characters of the receiver.</p></td>
</tr>
<tr>
<td>7</td>
<td><b>- (id)initWithFormat:(NSString *)format ...;</b>
<p>Returns an NSString object initialized by using a given format string as a template into which the remaining argument values are substituted.</p></td>
</tr>
<tr>
<td>8</td>
<td><b>- (NSInteger)integerValue;</b>
<p>Returns the NSInteger value of the receiver&rsquo;s text.</p></td>
</tr>
<tr>
<td>9</td>
<td><b>- (BOOL)isEqualToString:(NSString *)aString;</b>
<p>Returns a Boolean value that indicates whether a given string is equal to the receiver using a literal Unicode-based comparison.</p></td>
</tr>
<tr>
<td>10</td>
<td><b>- (NSUInteger)length;</b>
<p>Returns the number of Unicode characters in the receiver.</p></td>
</tr>
<tr>
<td>11</td>
<td><b>- (NSString *)lowercaseString;</b>
<p>Returns lowercased representation of the receiver.</p></td>
</tr>
<tr>
<td>12</td>
<td><b>- (NSRange)rangeOfString:(NSString *)aString;</b>
<p>Finds and returns the range of the first occurrence of a given string within the receiver.</p></td>
</tr>
<tr>
<td>13</td>
<td><b>- (NSString *)stringByAppendingFormat:(NSString *)format ...;</b>
<p>Returns a string made by appending to the receiver a string constructed from a given format string and the following arguments.</p></td>
</tr>
<tr>
<td>14</td>
<td><b>- (NSString *)stringByTrimmingCharactersInSet:(NSCharacterSet *)set;</b>
<p>Returns a new string made by removing from both ends of the receiver characters contained in a given character set.</p></td>
</tr>
<tr>
<td>15</td>
<td><b>- (NSString *)substringFromIndex:(NSUInteger)anIndex;</b>
<p>Returns a new string containing the characters of the receiver from the one at a given index to the end.</p></td>
</tr>
</table>
<p>Following example makes use of few of the above-mentioned functions:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

int main ()
{
   NSString *str1 = @"Hello";
   NSString *str2 = @"World";
   NSString *str3;
   int  len ;

   NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];

   /* uppercase string */
   str3 = [str2 uppercaseString];
   NSLog(@"Uppercase String :  %@\n", str3 );

   /* concatenates str1 and str2 */
   str3 = [str1 stringByAppendingFormat:@"World"];
   NSLog(@"Concatenated string:   %@\n", str3 );

   /* total length of str3 after concatenation */
   len = [str3 length];
   NSLog(@"Length of Str3 :  %d\n", len );
    
   /* InitWithFormat */
    str3 = [[NSString alloc] initWithFormat:@"%@ %@",str1,str2];	
    NSLog(@"Using initWithFormat:   %@\n", str3 );
    [pool drain];

   return 0;
}
</pre>
<p>When the above code is compiled and executed, it produces result something as follows:</p>
<pre class="prettyprint notranslate">
2013-09-11 01:15:45.069 demo[30378] Uppercase String :  WORLD
2013-09-11 01:15:45.070 demo[30378] Concatenated string:   HelloWorld
2013-09-11 01:15:45.070 demo[30378] Length of Str3 :  10
2013-09-11 01:15:45.070 demo[30378] Using initWithFormat:   Hello World
</pre>
<p>You can find a complete list of Objective-C NSString related methods in <a rel="nofollow" href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSString_Class/Reference/NSString.html" target="_blank" title="NSString Class Reference">NSString Class Reference.</a></p>
<h1>Objective-C Structures</h1>
<p>Objective-C arrays allow you to define type of variables that can hold several data items of the same kind but <b>structure</b> is another user-defined data type available in Objective-C programming which allows you to combine data items of different kinds.</p>
<p>Structures are used to represent a record, Suppose you want to keep track of your books in a library. You might want to track the following attributes about each book:</p>
<ul class="list">
<li><p>Title</p> </li>
<li><p>Author</p></li>
<li><p>Subject</p> </li>
<li><p>Book ID</p></li>
</ul>
<h2>Defining a Structure</h2>
<p>To define a structure, you must use the <b>struct</b> statement. The struct statement defines a new data type, with more than one member for your program. The format of the struct statement is this:</p>
<pre class="prettyprint notranslate">
struct [structure tag]
{
   member definition;
   member definition;
   ...
   member definition;
} [one or more structure variables];  
</pre>
<p>The <b>structure tag</b> is optional and each member definition is a normal variable definition, such as int i; or float f; or any other valid variable definition. At the end of the structure's definition, before the final semicolon, you can specify one or more structure variables but it is optional. Here is the way you would declare the Book structure:</p>
<pre class="prettyprint notranslate">
struct Books
{
   NSString *title;
   NSString *author;
   NSString *subject;
   int   book_id;
} book;  
</pre>
<h2>Accessing Structure Members</h2>
<p>To access any member of a structure, we use the <b>member access operator (.)</b>. The member access operator is coded as a period between the structure variable name and the structure member that we wish to access. You would use <b>struct</b> keyword to define variables of structure type. Following is the example to explain usage of structure:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

struct Books
{
   NSString *title;
   NSString *author;
   NSString *subject;
   int   book_id;
};
 
int main( )
{
   struct Books Book1;        /* Declare Book1 of type Book */
   struct Books Book2;        /* Declare Book2 of type Book */
 
   /* book 1 specification */
   Book1.title = @"Objective-C Programming";
   Book1.author = @"Nuha Ali"; 
   Book1.subject = @"Objective-C Programming Tutorial";
   Book1.book_id = 6495407;

   /* book 2 specification */
   Book2.title = @"Telecom Billing";
   Book2.author = @"Zara Ali";
   Book2.subject = @"Telecom Billing Tutorial";
   Book2.book_id = 6495700;
 
   /* print Book1 info */
   NSLog(@"Book 1 title : %@\n", Book1.title);
   NSLog(@"Book 1 author : %@\n", Book1.author);
   NSLog(@"Book 1 subject : %@\n", Book1.subject);
   NSLog(@"Book 1 book_id : %d\n", Book1.book_id);

   /* print Book2 info */
   NSLog(@"Book 2 title : %@\n", Book2.title);
   NSLog(@"Book 2 author : %@\n", Book2.author);
   NSLog(@"Book 2 subject : %@\n", Book2.subject);
   NSLog(@"Book 2 book_id : %d\n", Book2.book_id);

   return 0;
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
2013-09-14 04:20:07.947 demo[20591] Book 1 title : Objective-C Programming
2013-09-14 04:20:07.947 demo[20591] Book 1 author : Nuha Ali
2013-09-14 04:20:07.947 demo[20591] Book 1 subject : Objective-C Programming Tutorial
2013-09-14 04:20:07.947 demo[20591] Book 1 book_id : 6495407
2013-09-14 04:20:07.947 demo[20591] Book 2 title : Telecom Billing
2013-09-14 04:20:07.947 demo[20591] Book 2 author : Zara Ali
2013-09-14 04:20:07.947 demo[20591] Book 2 subject : Telecom Billing Tutorial
2013-09-14 04:20:07.947 demo[20591] Book 2 book_id : 6495700
</pre>
<h2>Structures as Function Arguments</h2>
<p>You can pass a structure as a function argument in very similar way as you pass any other variable or pointer. You would access structure variables in the similar way as you have accessed in the above example:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

struct Books
{
   NSString *title;
   NSString *author;
   NSString *subject;
   int   book_id;
};

@interface SampleClass:NSObject

/* function declaration */
- (void) printBook:( struct Books) book ;

@end

@implementation SampleClass 

- (void) printBook:( struct Books) book
{
   NSLog(@"Book title : %@\n", book.title);
   NSLog(@"Book author : %@\n", book.author);
   NSLog(@"Book subject : %@\n", book.subject);
   NSLog(@"Book book_id : %d\n", book.book_id);
}
@end

int main( )
{
   struct Books Book1;        /* Declare Book1 of type Book */
   struct Books Book2;        /* Declare Book2 of type Book */
 
   /* book 1 specification */
   Book1.title = @"Objective-C Programming";
   Book1.author = @"Nuha Ali"; 
   Book1.subject = @"Objective-C Programming Tutorial";
   Book1.book_id = 6495407;

   /* book 2 specification */
   Book2.title = @"Telecom Billing";
   Book2.author = @"Zara Ali";
   Book2.subject = @"Telecom Billing Tutorial";
   Book2.book_id = 6495700;
 
   SampleClass *sampleClass = [[SampleClass alloc]init];
   /* print Book1 info */
   [sampleClass printBook: Book1];

   /* Print Book2 info */
   [sampleClass printBook: Book2];

   return 0;
}

</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
2013-09-14 04:34:45.725 demo[8060] Book title : Objective-C Programming
2013-09-14 04:34:45.725 demo[8060] Book author : Nuha Ali
2013-09-14 04:34:45.725 demo[8060] Book subject : Objective-C Programming Tutorial
2013-09-14 04:34:45.725 demo[8060] Book book_id : 6495407
2013-09-14 04:34:45.725 demo[8060] Book title : Telecom Billing
2013-09-14 04:34:45.725 demo[8060] Book author : Zara Ali
2013-09-14 04:34:45.725 demo[8060] Book subject : Telecom Billing Tutorial
2013-09-14 04:34:45.725 demo[8060] Book book_id : 6495700
</pre>
<h2>Pointers to Structures</h2>
<p>You can define pointers to structures in very similar way as you define pointer to any other variable as follows:</p>
<pre class="prettyprint notranslate">
struct Books *struct_pointer;
</pre>
<p>Now, you can store the address of a structure variable in the above-defined pointer variable. To find the address of a structure variable, place the &amp; operator before the structure's name as follows:</p>
<pre class="prettyprint notranslate">
struct_pointer = &amp;Book1;
</pre>
<p>To access the members of a structure using a pointer to that structure, you must use the -&gt; operator as follows:</p>
<pre class="prettyprint notranslate">
struct_pointer-&gt;title;
</pre>
<p>Let us re-write above example using structure pointer, hope this will be easy for you to understand the concept:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

struct Books
{
   NSString *title;
   NSString *author;
   NSString *subject;
   int   book_id;
};

@interface SampleClass:NSObject

/* function declaration */
- (void) printBook:( struct Books *) book ;

@end

@implementation SampleClass 

- (void) printBook:( struct Books *) book
{
   NSLog(@"Book title : %@\n", book-&gt;title);
   NSLog(@"Book author : %@\n", book-&gt;author);
   NSLog(@"Book subject : %@\n", book-&gt;subject);
   NSLog(@"Book book_id : %d\n", book-&gt;book_id);
}
@end

int main( )
{
   struct Books Book1;        /* Declare Book1 of type Book */
   struct Books Book2;        /* Declare Book2 of type Book */
 
   /* book 1 specification */
   Book1.title = @"Objective-C Programming";
   Book1.author = @"Nuha Ali"; 
   Book1.subject = @"Objective-C Programming Tutorial";
   Book1.book_id = 6495407;

   /* book 2 specification */
   Book2.title = @"Telecom Billing";
   Book2.author = @"Zara Ali";
   Book2.subject = @"Telecom Billing Tutorial";
   Book2.book_id = 6495700;
 
   SampleClass *sampleClass = [[SampleClass alloc]init];
   /* print Book1 info by passing address of Book1 */
   [sampleClass printBook:&amp;Book1];

   /* print Book2 info by passing address of Book2 */
   [sampleClass printBook:&amp;Book2];

   return 0;
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
2013-09-14 04:38:13.942 demo[20745] Book title : Objective-C Programming
2013-09-14 04:38:13.942 demo[20745] Book author : Nuha Ali
2013-09-14 04:38:13.942 demo[20745] Book subject : Objective-C Programming Tutorial
2013-09-14 04:38:13.942 demo[20745] Book book_id : 6495407
2013-09-14 04:38:13.942 demo[20745] Book title : Telecom Billing
2013-09-14 04:38:13.942 demo[20745] Book author : Zara Ali
2013-09-14 04:38:13.942 demo[20745] Book subject : Telecom Billing Tutorial
2013-09-14 04:38:13.942 demo[20745] Book book_id : 6495700
</pre>
<h2>Bit Fields</h2>
<p>Bit Fields allow the packing of data in a structure. This is especially useful when memory or data storage is at a premium. Typical examples:</p>
<ul class="list">
<li><p>Packing several objects into a machine word. e.g. 1 bit flags can be compacted.</p></li>
<li><p>Reading external file formats -- non-standard file formats could be read in. E.g. 9 bit integers.</p></li>
</ul>
<p>Objective-C allows us do this in a structure definition by putting :bit length after the variable. For example:</p>
<pre class="prettyprint notranslate">
struct packed_struct {
  unsigned int f1:1;
  unsigned int f2:1;
  unsigned int f3:1;
  unsigned int f4:1;
  unsigned int type:4;
  unsigned int my_int:9;
} pack;
</pre>
<p>Here, the packed_struct contains 6 members: Four 1 bit flags f1..f3, a 4 bit type and a 9 bit my_int.</p>
<p>Objective-C automatically packs the above bit fields as compactly as possible, provided that the maximum length of the field is less than or equal to the integer word length of the computer. If this is not the case, then some compilers may allow memory overlap for the fields whilst other would store the next field in the next word.</p>
<h1>Objective-C Preprocessors</h1>
<p>The <b>Objective-C Preprocessor</b> is not part of the compiler, but is a separate step in the compilation process. In simplistic terms, an Objective-C Preprocessor is just a text substitution tool and it instructs compiler to do required pre-processing before actual compilation. We'll refer to the Objective-C Preprocessor as the OCPP.</p>
<p>All preprocessor commands begin with a pound symbol (#). It must be the first nonblank character, and for readability, a preprocessor directive should begin in first column. Following section lists down all important preprocessor directives:</p>
<table class="table table-bordered">
<tr>
<th style="width:20%">Directive</th>
<th>Description</th>
</tr>
<tr><td>#define</td>
<td>Substitutes a preprocessor macro</td>
</tr>
<tr>
<td>#include</td>
<td>Inserts a particular header from another file</td>
</tr>
<tr>
<td>#undef</td>
<td>Undefines a preprocessor macro</td>
</tr>
<tr>
<td>#ifdef</td>
<td>Returns true if this macro is defined</td>
</tr>
<tr>
<td>#ifndef</td>
<td>Returns true if this macro is not defined</td>
</tr>
<tr>
<td>#if</td>
<td>Tests if a compile time condition is true</td>
</tr>
<tr>
<td>#else</td>
<td>The alternative for #if</td>
</tr>
<tr>
<td>#elif</td>
<td>#else an #if in one statement</td>
</tr>
<tr>
<td>#endif</td>
<td>Ends preprocessor conditional</td>
</tr>
<tr>
<td>#error</td>
<td>Prints error message on stderr</td>
</tr>
<tr>
<td>#pragma</td>
<td>Issues special commands to the compiler using a standardized method</td>
</tr>
</table>
<h2>Preprocessors Examples</h2>
<p>Analyze the following examples to understand various directives.</p>
<pre class="prettyprint notranslate">
#define MAX_ARRAY_LENGTH 20
</pre>
<p>This directive tells the OCPP to replace instances of MAX_ARRAY_LENGTH with 20. Use <i>#define</i> for constants to increase readability.</p>
<pre class="prettyprint notranslate">
#import &lt;Foundation/Foundation.h&gt;
#include "myheader.h"
</pre>
<p>These directives tell the OCPP to get foundation.h from <b>Foundation Framework</b> and add the text to the current source file. The next line tells OCPP to get <b>myheader.h</b> from the local directory and add the content to the current source file.</p>
<pre class="prettyprint notranslate">
#undef  FILE_SIZE
#define FILE_SIZE 42
</pre>
<p>This tells the OCPP to undefine existing FILE_SIZE and define it as 42.</p>
<pre class="prettyprint notranslate">
#ifndef MESSAGE
   #define MESSAGE "You wish!"
#endif
</pre>
<p>This tells the OCPP to define MESSAGE only if MESSAGE isn't already defined.</p>
<pre class="prettyprint notranslate">
#ifdef DEBUG
   /* Your debugging statements here */
#endif
</pre>
<p>This tells the OCPP to do the process the statements enclosed if DEBUG is defined. This is useful if you pass the <i>-DDEBUG</i> flag to gcc compiler at the time of compilation. This will define DEBUG, so you can turn debugging on and off on the fly during compilation.</p>
<h2>Predefined Macros</h2>
<p>ANSI C defines a number of macros. Although each one is available for your use in programming, the predefined macros should not be directly modified.</p>
<table class="table table-bordered">
<tr><th style="width:20%">Macro</th><th>Description</th></tr>
<tr><td>__DATE__</td><td>The current date as a character literal in "MMM DD YYYY" format</td></tr>
<tr><td>__TIME__</td><td>The current time as a character literal in "HH:MM:SS" format</td></tr>
<tr><td>__FILE__</td><td>This contains the current filename as a string literal.</td></tr>
<tr><td>__LINE__</td><td>This contains the current line number as a decimal constant.</td></tr>
<tr><td>__STDC__</td><td>Defined as 1 when the compiler complies with the ANSI standard.</td></tr>
</table>
<p>Let's try the following example:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

int main()
{
   NSLog(@"File :%s\n", __FILE__ );
   NSLog(@"Date :%s\n", __DATE__ );
   NSLog(@"Time :%s\n", __TIME__ );
   NSLog(@"Line :%d\n", __LINE__ );
   NSLog(@"ANSI :%d\n", __STDC__ );
   
   return 0;
}
</pre>
<p>When the above code in a file <b>main.m</b> is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
2013-09-14 04:46:14.859 demo[20683] File :main.m
2013-09-14 04:46:14.859 demo[20683] Date :Sep 14 2013
2013-09-14 04:46:14.859 demo[20683] Time :04:46:14
2013-09-14 04:46:14.859 demo[20683] Line :8
2013-09-14 04:46:14.859 demo[20683] ANSI :1
</pre>
<h2>Preprocessor Operators</h2>
<p>The Objective-C preprocessor offers following operators to help you in creating macros:</p>
<h5>Macro Continuation (\)</h5>
<p>A macro usually must be contained on a single line. The macro continuation operator is used to continue a macro that is too long for a single line. For example:</p>
<pre class="prettyprint notranslate">
#define  message_for(a, b)  \
    NSLog(@#a " and " #b ": We love you!\n")

</pre>
<h5> Stringize (#)</h5>
<p>The stringize or number-sign operator ('#'), when used within a macro definition, converts a macro parameter into a string constant. This operator may be used only in a macro that has a specified argument or parameter list. For example:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

#define  message_for(a, b)  \
    NSLog(@#a " and " #b ": We love you!\n")

int main(void)
{
   message_for(Carole, Debra);
   return 0;
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
2013-09-14 05:46:14.859 demo[20683] Carole and Debra: We love you!
</pre>
<h5>Token Pasting (##)</h5>
<p>The token-pasting operator (##) within a macro definition combines two arguments. It permits two separate tokens in the macro definition to be joined into a single token. For example:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

#define tokenpaster(n) NSLog (@"token" #n " = %d", token##n)

int main(void)
{
   int token34 = 40;
   
   tokenpaster(34);
   return 0;
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
2013-09-14 05:48:14.859 demo[20683] token34 = 40
</pre>
<p>How it happened, because this example results in the following actual output from the preprocessor:</p>
<pre class="prettyprint notranslate">
NSLog (@"token34 = %d", token34);
</pre>
<p>This example shows the concatenation of token##n into token34 and here we have used both <b>stringize</b> and <b>token-pasting</b>.</p>
<h5>The defined() Operator</h5>
<p>The preprocessor <b>defined</b> operator is used in constant expressions to determine if an identifier is defined using #define. If the specified identifier is defined, the value is true (non-zero). If the symbol is not defined, the value is false (zero). The defined operator is specified as follows:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

#if !defined (MESSAGE)
   #define MESSAGE "You wish!"
#endif

int main(void)
{
   NSLog(@"Here is the message: %s\n", MESSAGE);  
   return 0;
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
2013-09-14 05:48:19.859 demo[20683] Here is the message: You wish!
</pre>
<h2>Parameterized Macros</h2>
<p>One of the powerful functions of the OCPP is the ability to simulate functions using parameterized macros. For example, we might have some code to square a number as follows:</p>
<pre class="prettyprint notranslate">
int square(int x) {
   return x * x;
}
</pre>
<p>We can rewrite above code using a macro as follows:</p>
<pre class="prettyprint notranslate">
#define square(x) ((x) * (x))
</pre>
<p>Macros with arguments must be defined using the <b>#define</b> directive before they can be used. The argument list is enclosed in parentheses and must immediately follow the macro name. Spaces are not allowed between macro name and open parenthesis. For example:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

#define MAX(x,y) ((x) &gt; (y) ? (x) : (y))

int main(void)
{
   NSLog(@"Max between 20 and 10 is %d\n", MAX(10, 20));  
   return 0;
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
2013-09-14 05:52:15.859 demo[20683] Max between 20 and 10 is 20
</pre>
<h1>Objective-C Typedef</h1>
<p>The Objective-C programming language provides a keyword called <b>typedef</b>, which you can use to give a type a new name. Following is an example to define a term <b>BYTE</b> for one-byte numbers:</p>
<pre class="prettyprint notranslate">
typedef unsigned char BYTE;
</pre>
<p>After this type definition, the identifier BYTE can be used as an abbreviation for the type <b>unsigned char, for example:</b>.
<pre class="prettyprint notranslate">
BYTE  b1, b2;
</pre>
<p>By convention, uppercase letters are used for these definitions to remind the user that the type name is really a symbolic abbreviation, but you can use lowercase, as follows:</p>
<pre class="prettyprint notranslate">
typedef unsigned char byte;
</pre>
<p>You can use <b>typedef</b> to give a name to user-defined data type as well. For example, you can use typedef with structure to define a new data type and then use that data type to define structure variables directly as follows:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

typedef struct Books
{
   NSString *title;
   NSString *author;
   NSString *subject;
   int book_id;

} Book;
 
int main( )
{

   Book book;
   book.title = @"Objective-C Programming";
   book.author = @"TutorialsPoint";
   book.subject = @"Programming tutorial";
   book.book_id = 100;
   NSLog( @"Book title : %@\n", book.title);
   NSLog( @"Book author : %@\n", book.author);
   NSLog( @"Book subject : %@\n", book.subject);
   NSLog( @"Book Id : %d\n", book.book_id);

   return 0;
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
2013-09-12 12:21:53.745 demo[31183] Book title : Objective-C Programming
2013-09-12 12:21:53.745 demo[31183] Book author : TutorialsPoint
2013-09-12 12:21:53.745 demo[31183] Book subject : Programming tutorial
2013-09-12 12:21:53.745 demo[31183] Book Id : 100
</pre>
<h2>typedef vs #define</h2>
<p>The <b>#define</b> is a Objective-C directive, which is also used to define the aliases for various data types similar to <b> typedef</b> but with following differences:</p>
<ul class="list">
<li><p>The <b>typedef</b> is limited to giving symbolic names to types only whereas <b>#define</b> can be used to define alias for values as well, like you can define 1 as ONE, etc.</p></li>
<li><p>The <b>typedef</b> interpretation is performed by the compiler where as <b>#define</b> statements are processed by the pre-processor.</p></li>
</ul>
<p>Following is a simplest usage of #define:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;
 
#define TRUE  1
#define FALSE 0
 
int main( )
{
   NSLog( @"Value of TRUE : %d\n", TRUE);
   NSLog( @"Value of FALSE : %d\n", FALSE);

   return 0;
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
2013-09-12 12:23:37.993 demo[5160] Value of TRUE : 1
2013-09-12 12:23:37.994 demo[5160] Value of FALSE : 0
</pre>
<h1>Objective-C Type Casting</h1>
<p>Type casting is a way to convert a variable from one data type  to another data type. For example, if you want to store a long value into a simple integer then you can type cast long to int. You can  convert values from one type to another explicitly using the <b>cast operator</b> as follows:</p>
<pre class="prettyprint notranslate">
(type_name) expression
</pre>
<p>In Objective-C, we generally use CGFloat for doing floating point operation, which is derived from basic type of float in case of 32-bit and double in case of 64-bit. Consider the following example where the cast operator causes the division of one integer variable by another to be performed as a floating-point operation:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

int main()
{
   int sum = 17, count = 5;
   CGFloat mean;

   mean = (CGFloat) sum / count;
   NSLog(@"Value of mean : %f\n", mean );

   return 0;
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
2013-09-11 01:35:40.047 demo[20634] Value of mean : 3.400000
</pre>
<p>It should be noted here that the cast operator has precedence over division, so the value of <b>sum</b> is first converted to type <b>double</b> and finally it gets divided by count yielding a double value.</p>
<p>Type conversions can be implicit which is performed by the compiler automatically or it can be specified explicitly through the use of the <b>cast operator</b>. It is considered good programming practice to use the cast operator whenever type conversions are necessary.</p>
<h2>Integer Promotion</h2>
<p>Integer promotion is the process by which values of integer type "smaller" than <b>int</b> or <b>unsigned int</b> are converted either to <b>int</b> or <b>unsigned int</b>. Consider an example of adding a character in an int:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

int main()
{
   int  i = 17;
   char c = 'c'; /* ascii value is 99 */
   int sum;

   sum = i + c;
   NSLog(@"Value of sum : %d\n", sum );

   return 0;
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
2013-09-11 01:38:28.492 demo[980] Value of sum : 116
</pre>
<p>Here, value of sum is coming as 116 because compiler is doing integer promotion and converting the value of 'c' to ascii before performing  actual addition operation.</p>
<h2>Usual Arithmetic Conversion</h2>
<p>The <b>usual arithmetic conversions</b> are implicitly performed to cast their values in a common type. Compiler first performs <i>integer promotion</i>, if operands still have different types then they are converted to the type that appears highest in the following hierarchy:</p>
<img src="/objective_c/images/usual_arithmetic_conversion.png" alt="Usual Arithmetic Conversion" />
<p>The usual arithmetic conversions are not performed for the assignment operators, nor for the logical operators &amp;&amp; and ||. Let us take following example to understand the concept:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

int main()
{
   int  i = 17;
   char c = 'c'; /* ascii value is 99 */
   CGFloat sum;

   sum = i + c;
   NSLog(@"Value of sum : %f\n", sum );
   return 0;
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
2013-09-11 01:41:39.192 demo[15351] Value of sum : 116.000000
</pre>
<p>Here, it is simple to understand that first c gets converted to integer but because final value is float, so usual arithmetic conversion applies and compiler converts i and c into float and add them yielding a float result.</p>
<h1>Objective-C Log Handling</h1>
<h2>NSLog method</h2>
<p>In order to print logs, we use the NSLog method in Objective-C programming language which we have used right from the Hello World example.</p>

<p>Let us look at a simple code that would print the words "Hello World":</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

int main()
{
   NSLog(@"Hello, World! \n");
   return 0;
}
</pre>
<p>Now, when we compile and run the program, we will get the following result.</p>
<pre class="prettyprint notranslate">
2013-09-16 00:32:50.888 demo[16669] Hello, World! 
</pre>

<h2>Disabling logs in Live apps</h2>
<p>Since the NSLogs we use in our application, it will be printed in logs of device and it is not good to print logs in a live build. Hence, we use a type definition for printing logs and we can use them as shown below.</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

#if DEBUG == 0
#define DebugLog(...)
#elif DEBUG == 1
#define DebugLog(...) NSLog(__VA_ARGS__)
#endif

int main()
{
   DebugLog(@"Debug log, our custom addition gets \
   printed during debug only" );
   NSLog(@"NSLog gets printed always" );     
   return 0;
}
</pre>
<p>Now, when we compile and run the program in debug mode, we will get the following result.</p>
<pre class="prettyprint notranslate">
2013-09-11 02:47:07.723 demo[618] Debug log, our custom addition gets printed during debug only
2013-09-11 02:47:07.723 demo[618] NSLog gets printed always
</pre>
<p>Now, when we compile and run the program in release mode, we will get the following result.</p>
<pre class="prettyprint notranslate">
2013-09-11 02:47:45.248 demo[3158] NSLog gets printed always
</pre>
<h1>Objective-C Error Handling</h1>
<p>In Objective-C programming, error handling is provided with NSError class available in <b>Foundation framework.</b></p>
<p>An NSError object encapsulates richer and more extensible error information than is possible using only an error code or error string. The core attributes of an NSError object are an error domain (represented by a string), a domain-specific error code and a user info dictionary containing application specific information.</p>
<h2>NSError</h2>
<p>Objective-C programs use NSError objects to convey information about runtime errors that users need to be
informed about. In most cases, a program displays this error information in a dialog or sheet. But it may also
interpret the information and either ask the user to attempt to recover from the error or attempt to correct
the error on its own</p>
<p>NSError Object consists of:</p>
<ul class="list">
<li><p>Domain: The error domain can be one of the predefined NSError domains or an arbitrary string describing a custom domain and domain must not be nil.</p></li>
<li><p>Code: The error code for the error.</p></li>
<li><p>User Info: The userInfo dictionary for the error and userInfo may be nil.</p></li>
</ul>
<p>The following example shows how to create a custom error</p>
<pre class="prettyprint notranslate">
NSString *domain = @"com.MyCompany.MyApplication.ErrorDomain";
NSString *desc = NSLocalizedString(@"Unable to complete the process", @"");
NSDictionary *userInfo = @{ NSLocalizedDescriptionKey : desc };
NSError *error = [NSError errorWithDomain:domain code:-101 userInfo:userInfo];
</pre>

<p>Here is complete code of the above error sample passed as reference to an pointer</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

@interface SampleClass:NSObject

-(NSString *) getEmployeeNameForID:(int) id withError:(NSError **)errorPtr;

@end

@implementation SampleClass

-(NSString *) getEmployeeNameForID:(int) id withError:(NSError **)errorPtr{
    if(id == 1)
    {
       return @"Employee Test Name";
    }
    else
    {
       NSString *domain = @"com.MyCompany.MyApplication.ErrorDomain";
       NSString *desc =@"Unable to complete the process";
       NSDictionary *userInfo = [[NSDictionary alloc] 
       initWithObjectsAndKeys:desc,
       @"NSLocalizedDescriptionKey",NULL];  
       *errorPtr = [NSError errorWithDomain:domain code:-101 
       userInfo:userInfo];
       return @"";
    }
}

@end


int main()
{
   NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
   SampleClass *sampleClass = [[SampleClass alloc]init];
   NSError *error = nil;
   NSString *name1 = [sampleClass getEmployeeNameForID:1 withError:&error];
  
   if(error)
   {
      NSLog(@"Error finding Name1: %@",error);
   }
   else
   {
      NSLog(@"Name1: %@",name1);
   }

   error = nil;

   NSString *name2 = [sampleClass getEmployeeNameForID:2 withError:&error];

   if(error)
   {
      NSLog(@"Error finding Name2: %@",error);
   }
   else
   {
      NSLog(@"Name2: %@",name2);
   }

   [pool drain];
   return 0;
   
}
</pre>
<p>In the above example, we return a name if the id is 1, otherwise we set the user-defined error object.</p>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
2013-09-14 18:01:00.809 demo[27632] Name1: Employee Test Name
2013-09-14 18:01:00.809 demo[27632] Error finding Name2: Unable to complete the process
</pre>
<h1>Command-Line Arguments</h1>
<p>It is possible to pass some values from the command line to your Objective-C programs when they are executed. These values are called <b>command line arguments</b> and many times they are important for your program, especially when you want to control your program from outside instead of hard coding those values inside the code.</p>
<p>The command line arguments are handled using main() function arguments where <b>argc</b> refers to the number of arguments passed, and <b>argv[]</b> is a pointer array, which points to each argument passed to the program. Following is a simple example, which checks if there is any argument supplied from the command line and take action accordingly:</p>
<pre class="prettyprint notranslate">
#import &lt;Foundation/Foundation.h&gt;

int main( int argc, char *argv[] )  
{
   if( argc == 2 )
   {
      NSLog(@"The argument supplied is %s\n", argv[1]);
   }
   else if( argc > 2 )
   {
      NSLog(@"Too many arguments supplied.\n");
   }
   else
   {
      NSLog(@"One argument expected.\n");
   }
}
</pre>
<p>When the above code is compiled and executed with a single argument, say "testing", it produces the following result.</p>

<pre class="prettyprint notranslate">
2013-09-13 03:01:17.333 demo[7640] The argument supplied is testing
</pre>


<p>When the above code is compiled and executed with two arguments, say testing1 and testing2, it produces the following result.</p>
<pre class="prettyprint notranslate">
2013-09-13 03:01:18.333 demo[7640] Too many arguments supplied.
</pre>
<p>When the above code is compiled and executed without passing any argument, it produces the following result.</p>
<pre class="prettyprint notranslate">
2013-09-13 03:01:18.333 demo[7640] One argument expected
</pre>
<p>It should be noted that <b>argv[0]</b> holds the name of the program itself and <b>argv[1]</b> is a pointer to the first command-line argument supplied, and *argv[n] is the last argument. If no arguments are supplied, argc will be one, otherwise if you pass one argument, then <b>argc</b> is set at 2.</p>
<p>You pass all the command line arguments  separated by a space, but if argument itself has a space, then you can pass such arguments by putting them inside double quotes "" or single quotes ''. Let us re-write above example once again where we will print program name and we also pass a command-line argument by putting inside double quotes:</p>
<pre class="prettyprint notranslate">
#import &lt;Foundation/Foundation.h&gt;

int main( int argc, char *argv[] )  
{
   NSLog(@"Program name %s\n", argv[0]);
 
   if( argc == 2 )
   {
      NSLog(@"The argument supplied is %s\n", argv[1]);
   }
   else if( argc &gt; 2 )
   {
      NSLog(@"Too many arguments supplied.\n");
   }
   else
   {
      NSLog(@"One argument expected.\n");
   }
   return 0;
}
</pre>
<p>When the above code is compiled and executed with a single argument separated by space but inside double quotes say "Testing1 Testing2", it produces the following result.</p>
<pre class="prettyprint notranslate">
2013-09-14 04:07:57.305 demo[8534] Program name demo
2013-09-14 04:07:57.305 demo[8534] The argument supplied is Testing1 Testing 2</pre>
<h1>Objective-C Classes & Objects</h1>
<p>The main purpose of Objective-C programming language is to add object orientation to the C programming language and classes are the central feature of Objective-C that support object-oriented programming and are often called user-defined types.</p>
<p>A class is used to specify the form of an object and it combines data representation and methods for manipulating that data into one neat package. The data and methods within a class are called members of the class.</p>
<h2>Objective-C characteristics</h2>
<ul class="list">
<li><p>The class is defined in two different sections namely <b>@interface</b> and <b>@implementation</b>.</p></li>
<li><p>Almost everything is in form of objects.</p></li>
<li><p>Objects receive messages and objects are often referred as receivers.</p></li>
<li><p>Objects contain instance variables.</p></li>
<li><p>Objects and instance variables have scope.</p></li>
<li><p>Classes hide an object's implementation.</p></li>
<li><p>Properties are used to provide access to class instance variables in other classes.</p></li>
</ul>

<h2>Objective-C Class Definitions:</h2>
<p>When you define a class, you define a blueprint for a data type. This doesn't actually define any data, but it does define what the class name means, that is, what an object of the class will consist of and what operations can be performed on such an object.</p>
<p>A class definition starts with the keyword <b>@interface</b> followed by the interface(class) name; and the class body, enclosed by a pair of curly braces. In Objective-C, all classes are derived from the base class called <b>NSObject</b>. It is the superclass of all Objective-C classes. It provides basic methods like memory allocation and initialization. For example, we defined the Box data type using the keyword <b>class</b> as follows:</p>
<pre class="prettyprint notranslate">
@interface Box:NSObject
{
    //Instance variables
    double length;   // Length of a box
    double breadth;  // Breadth of a box
}
@property(nonatomic, readwrite) double height; // Property

@end
</pre>
<p>The instance variables are private and are only accessible inside the class implementation.</p>
<h2>Allocating and initializing Objective-C Objects:</h2>
<p>A class provides the blueprints for objects, so basically an object is created from a class. We declare objects of a class with exactly the same sort of declaration that we declare variables of basic types. Following statements declare two objects of class Box:</p>
<pre class="prettyprint notranslate">
Box box1 = [[Box alloc]init];     // Create box1 object of type Box
Box box2 = [[Box alloc]init];     // Create box2 object of type Box
</pre>
<p>Both of the objects box1 and box2 will have their own copy of data members.</p>
<h2>Accessing the Data Members:</h2>
<p>The properties of objects of a class can be accessed using the direct member access operator (.). Let us try the following example to make things clear:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

@interface Box:NSObject
{
    double length;   // Length of a box
    double breadth;  // Breadth of a box
    double height;   // Height of a box
}
@property(nonatomic, readwrite) double height; // Property

-(double) volume;

@end

@implementation Box

@synthesize height; 

-(id)init
{
   self = [super init];
   length = 1.0;
   breadth = 1.0;
   return self;
}

-(double) volume
{
   return length*breadth*height;
}

@end

int main( )
{
   NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];    
   Box *box1 = [[Box alloc]init];    // Create box1 object of type Box
   Box *box2 = [[Box alloc]init];    // Create box2 object of type Box

   double volume = 0.0;     // Store the volume of a box here
 
   // box 1 specification
   box1.height = 5.0; 

   // box 2 specification
   box2.height = 10.0;
  
   // volume of box 1
   volume = [box1 volume];
   NSLog(@"Volume of Box1 : %f", volume);
   // volume of box 2
   volume = [box2 volume];
   NSLog(@"Volume of Box2 : %f", volume);
   [pool drain];
   return 0;
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
2013-09-22 21:25:33.314 ClassAndObjects[387:303] Volume of Box1 : 5.000000
2013-09-22 21:25:33.316 ClassAndObjects[387:303] Volume of Box2 : 10.000000
</pre>
<h2>Properties:</h2>
<p>Properties are introduced in Objective-C to ensure that the instance variable of the class can be accessed outside the class.</p>
The various parts are the property declaration are as follows.
<ul class="list">
<p><li>Properties begin with <b>@property</b>, which is a keyword</li><p>
<p><li>It is followed with access specifiers, which are nonatomic or atomic, readwrite or readonly and strong, unsafe_unretained or weak. This varies based on the type of the variable. For any pointer type, we can use strong, unsafe_unretained or weak. Similarly for other types we can use readwrite or readonly.</li><p>
<p><li>This is followed by the datatype of the variable.</li><p>
<p><li>Finally, we have the property name terminated by a semicolon.</li><p>
<p><li>We can add synthesize statement in the implementation class. But in the latest XCode, the synthesis part is taken care by the XCode and you need not include synthesize statement.</li><p>
</ul>
<p>It is only possible with the properties we can access the instance variables of the class. Actually, internally getter and setter methods are created for the properties.</p>
<p>For example, let's assume we have a property <b>@property (nonatomic ,readonly ) BOOL isDone</b>. Under the hood, there are setters and getters created as shown below.</p>
<pre class="prettyprint notranslate">
-(void)setIsDone(BOOL)isDone;
-(BOOL)isDone;
</pre>
<h1>Objective-C Inheritance</h1>
<p>One of the most important concepts in object-oriented programming is that of inheritance. Inheritance allows us to define a class in terms of another class which makes it easier to create and maintain an application. This also provides an opportunity to reuse the code functionality and fast implementation time.</p>
<p>When creating a class, instead of writing completely new data members and member functions, the programmer can designate that the new class should inherit the members of an existing class. This existing class is called the <b>base</b> class, and the new class is referred to as the <b>derived</b> class.</p>
<p>The idea of inheritance implements the <b>is a</b> relationship. For example, mammal IS-A animal, dog IS-A mammal, hence dog IS-A animal as well and so on.</p>
<h2>Base &amp; Derived Classes:</h2>
<p>Objective-C allows only multilevel inheritance, i.e., it can have only one base class but allows multilevel inheritance. All classes in Objective-C is derived from the superclass <b>NSObject</b>.</p>
<pre class="prettyprint notranslate">
@interface derived-class: base-class
</pre>
<p>Consider a base class <b>Shape</b> and its derived class <b>Rectangle</b> as follows:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;
 
@interface Person : NSObject

{
    NSString *personName;
    NSInteger personAge;
}

- (id)initWithName:(NSString *)name andAge:(NSInteger)age;
- (void)print;
@end

@implementation Person

- (id)initWithName:(NSString *)name andAge:(NSInteger)age{
    personName = name;
    personAge = age;
    return self;
}

- (void)print{
    NSLog(@"Name: %@", personName);
    NSLog(@"Age: %ld", personAge);
}

@end

@interface Employee : Person

{
    NSString *employeeEducation;
}

- (id)initWithName:(NSString *)name andAge:(NSInteger)age 
  andEducation:(NSString *)education;
- (void)print;

@end


@implementation Employee

- (id)initWithName:(NSString *)name andAge:(NSInteger)age 
  andEducation: (NSString *)education
  {
    personName = name;
    personAge = age;
    employeeEducation = education;
    return self;
}

- (void)print
{
    NSLog(@"Name: %@", personName);
    NSLog(@"Age: %ld", personAge);
    NSLog(@"Education: %@", employeeEducation);
}

@end


int main(int argc, const char * argv[])
{
    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];        
    NSLog(@"Base class Person Object");
    Person *person = [[Person alloc]initWithName:@"Raj" andAge:5];
    [person print];
    NSLog(@"Inherited Class Employee Object");
    Employee *employee = [[Employee alloc]initWithName:@"Raj" 
    andAge:5 andEducation:@"MBA"];
    [employee print];        
    [pool drain];
    return 0;
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
2013-09-22 21:20:09.842 Inheritance[349:303] Base class Person Object
2013-09-22 21:20:09.844 Inheritance[349:303] Name: Raj
2013-09-22 21:20:09.844 Inheritance[349:303] Age: 5
2013-09-22 21:20:09.845 Inheritance[349:303] Inherited Class Employee Object
2013-09-22 21:20:09.845 Inheritance[349:303] Name: Raj
2013-09-22 21:20:09.846 Inheritance[349:303] Age: 5
2013-09-22 21:20:09.846 Inheritance[349:303] Education: MBA
</pre>
<h2>Access Control and Inheritance:</h2>
<p>A derived class can access all the private members of its base class if it's defined in the interface class, but it cannot access private members that are defined in the implementation file.</p>
<p>We can summarize the different access types according to who can access them in the following way: </p>
<p>A derived class inherits all base class methods and variables with the following exceptions:</p>
<ul class="list">
<li><p>Variables declared in implementation file with the help of extensions is not accessible.</p></li>
<li><p>Methods declared in implementation file with the help of extensions is not accessible.</p></li>
<li><p>In case the inherited class implements the method in base class, then the method in derived class is executed.</p></li>
</ul>
<br />
<h1>Objective-C Polymorphism</h1>
<p>The word <b>polymorphism</b> means having many forms. Typically, polymorphism occurs when there is a hierarchy of classes and they are related by inheritance.</p>
<p>Objective-C polymorphism means that a call to a member function will cause a different function to be executed depending on the type of object that invokes the function.</p>
<p>Consider the example, we have a class Shape that provides the basic interface for all the shapes. Square and Rectangle are derived from the base class Shape.</p>
<p>We have the method printArea that is going to show about the OOP feature <b>polymorphism</b>.</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

@interface Shape : NSObject

{
    CGFloat area;
}

- (void)printArea;
- (void)calculateArea;
@end

@implementation Shape

- (void)printArea{
    NSLog(@"The area is %f", area);
}

- (void)calculateArea{

}

@end


@interface Square : Shape
{
    CGFloat length;
}

- (id)initWithSide:(CGFloat)side;

- (void)calculateArea;

@end

@implementation Square

- (id)initWithSide:(CGFloat)side{
    length = side;
    return self;
}

- (void)calculateArea{
    area = length * length;
}

- (void)printArea{
    NSLog(@"The area of square is %f", area);
}

@end

@interface Rectangle : Shape
{
    CGFloat length;
    CGFloat breadth;
}

- (id)initWithLength:(CGFloat)rLength andBreadth:(CGFloat)rBreadth;


@end

@implementation Rectangle

- (id)initWithLength:(CGFloat)rLength andBreadth:(CGFloat)rBreadth{
    length = rLength;
    breadth = rBreadth;
    return self;
}

- (void)calculateArea{
    area = length * breadth;
}

@end


int main(int argc, const char * argv[])
{
    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
    Shape *square = [[Square alloc]initWithSide:10.0];
    [square calculateArea];
    [square printArea];
    Shape *rect = [[Rectangle alloc]
    initWithLength:10.0 andBreadth:5.0];
    [rect calculateArea];
    [rect printArea];        
    [pool drain];
    return 0;
}

</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
2013-09-22 21:21:50.785 Polymorphism[358:303] The area of square is 100.000000
2013-09-22 21:21:50.786 Polymorphism[358:303] The area is 50.000000
</pre>
<p>In the above example based on the availability of the method calculateArea and printArea, either the method in the base class or the derived class executed.</p>
<p>Polymorphism handles the switching of methods between the base class and derived class based on the method implementation of the two classes.</p>
<br />
<h1>Objective-C Data Encapsulation</h1>
<p>All Objective-C programs are composed of the following two fundamental elements: </p>
<ul class="list">
<li><p><b>Program statements (code):</b> This is the part of a program that performs actions and they are called methods.</p></li>
<li><p><b>Program data:</b> The data is the information of the program which is affected by the program functions.</p></li>
</ul>
<p>Encapsulation is an Object-Oriented Programming concept that binds together the data and functions that manipulate the data and that keeps both safe from outside interference and misuse. Data encapsulation led to the important OOP concept of <b>data hiding</b>.</p>
<p><b>Data encapsulation</b> is a mechanism of bundling the data and the functions that use them, and <b>data abstraction</b> is a mechanism of exposing only the interfaces and hiding the implementation details from the user.</p>
<p>Objective-C supports the properties of encapsulation and data hiding through the creation of user-defined types, called <b>classes</b>. For example:</p>
<pre class="prettyprint notranslate">
@interface Adder : NSObject
{
    NSInteger total;
}

- (id)initWithInitialNumber:(NSInteger)initialNumber;

- (void)addNumber:(NSInteger)newNumber;

- (NSInteger)getTotal;

@end
</pre>
<p>The variable total is private and we cannot access from outside the class. This means that they can be accessed only by other members of the Adder class and not by any other part of your program. This is one way encapsulation is achieved.</p>
<p>Methods inside the interface file are accessible and are public in scope.</p>
<p>There are private methods, which are written with the help of <b>extensions</b>, which we will learn in upcoming chapters.</p>
<h2>Data Encapsulation Example:</h2>
<p>Any Objective-C program where you implement a class with public and private members variables is an example of data encapsulation and data abstraction. Consider the following example:</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

@interface Adder : NSObject
{
    NSInteger total;
}

- (id)initWithInitialNumber:(NSInteger)initialNumber;

- (void)addNumber:(NSInteger)newNumber;

- (NSInteger)getTotal;

@end

@implementation Adder

-(id)initWithInitialNumber:(NSInteger)initialNumber{
    total = initialNumber;
    return self;
}

- (void)addNumber:(NSInteger)newNumber{
    total = total + newNumber;
}

- (NSInteger)getTotal{
    return total;
}

@end

int main(int argc, const char * argv[])
{
    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];        
    Adder *adder = [[Adder alloc]initWithInitialNumber:10];
    [adder addNumber:5];
    [adder addNumber:4];
    NSLog(@"The total is %ld",[adder getTotal]);
    [pool drain];
    return 0;
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="prettyprint notranslate">
2013-09-22 21:17:30.485 DataEncapsulation[317:303] The total is 19
</pre>
<p>Above class adds numbers together and returns the sum. The public members <b>addNum</b> and <b>getTotal </b> are the interfaces to the outside world and a user needs to know them to use the class. The private member <b>total</b> is something that is hidden from the outside world, but is needed for the class to operate properly.</p>
<h2>Designing Strategy:</h2>
<p>Most of us have learned through bitter experience to make class members private by default unless we really need to expose them. That's just good <b>encapsulation</b>.</p>
<p>It's important to understand data encapsulation since it's one of the core features of all Object-Oriented Programming (OOP) languages including Objective-C.</p>
<h1>Objective-C Category</h1>
<p>Sometimes, you may find that you wish to extend an existing class by adding behavior that is useful only in certain situations. In order add such extension to existing classes, Objective-C provides <b>categories</b> and <b>extensions</b>.</p>
<p>If you need to add a method to an existing class, perhaps, to add functionality to make it easier to do something in your own application, the easiest way is to use a category.</p>
<p>The syntax to declare a category uses the @interface keyword, just like a standard Objective-C class description, but does not indicate any inheritance from a subclass. Instead, it specifies the name of the category in parentheses, like this:</p>
<pre class="prettyprint notranslate">
@interface ClassName (CategoryName)

@end
</pre>

<h2>Characteristics of category</h2>
<ul class="list">
<li><p>A category can be declared for any class, even if you don't have the original implementation source code.</p></li>
<li><p>Any methods that you declare in a category will be available to all instances of the original class, as well as any subclasses of the original class.</p></li>
<li><p>At runtime, there's no difference between a method added by a category and one that is implemented by the original class.</p></li>
</ul>
<p>Now, let's look at a sample category implementation. Let's add a category to the Cocoa class NSString. This category will make it possible for us to add a new method getCopyRightString which helps us in returning the copyright string. It is shown below.</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

@interface NSString(MyAdditions)

+(NSString *)getCopyRightString;

@end

@implementation NSString(MyAdditions)

+(NSString *)getCopyRightString{
    return @"Copyright TutorialsPoint.com 2013";
}

@end


int main(int argc, const char * argv[])
{
    
   NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
   NSString *copyrightString = [NSString getCopyRightString];
   NSLog(@"Accessing Category: %@",copyrightString);
   [pool drain];
    return 0;
}
</pre>

<p>Now when we compile and run the program, we will get the following result.</p>
<pre class="prettyprint notranslate">
2013-09-22 21:19:12.125 Categories[340:303] Accessing Category: Copyright TutorialsPoint.com 2013
</pre>

<p>Even though any methods added by a category are available to all instances of the class and its subclasses, you'll need to import the category header file in any source code file where you wish to use the additional methods, otherwise you'll run into compiler warnings and errors.</p>
<p>In our example, since we just have a single class, we have not included any header files, in such a case we should include the header files as said above.</p>
<h1>Objective-C Posing</h1>
<p>Before starting about Posing in Objective-C, I would like to bring to your notice that Posing was declared deprecated in Mac OS X 10.5 and it's not available for use thereafter. So for those who are not concerned about these deprecated methods can skip this chapter.</p>
<p>Objective-C permits a class to wholly replace another class within a program. The replacing class is said to "pose as" the target class.</p>
<p>For the versions that supported posing, all messages sent to the target class are instead received by the posing class.</p>
<p>NSObject contains the poseAsClass: method that enables us to replace the existing class as said above.</p>
<h2>Restrictions in Posing</h2>
<ul class="list">
<li><p>A class may only pose as one of its direct or indirect superclasses.</p></li>
<li><p>The posing class must not define any new instance variables that are absent from the target class (though it may define or override methods).</p></li>
<li><p>The target class may not have received any messages prior to the posing.</p></li>
<li><p>A posing class can call overridden methods through super, thus incorporating the implementation of the target class.</p></li>
<li><p>A posing class can override methods defined in categories.</p></li>
</ul>
<pre class="prettyprint notranslate">
#import &lt;Foundation/Foundation.h&gt;

@interface MyString : NSString

@end

@implementation MyString

- (NSString *)stringByReplacingOccurrencesOfString:(NSString *)target
withString:(NSString *)replacement
{
   NSLog(@"The Target string is %@",target);
   NSLog(@"The Replacement string is %@",replacement);
}

@end

int main()
{
   NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
   [MyString poseAsClass:[NSString class]];
   NSString *string = @"Test";
   [string stringByReplacingOccurrencesOfString:@"a" withString:@"c"];
   [pool drain];
   return 0;
}
</pre>

<p>Now when we compile and run the program in a older Mac OS X (V_10.5 or earlier), we will get the following result.</p>
<pre class="prettyprint notranslate">
2013-09-22 21:23:46.829 Posing[372:303] The Target string is a
2013-09-22 21:23:46.830 Posing[372:303] The Replacement string is c
</pre>
<p>In the above example, we just polluted the original method with our implementation and this will get affected throughout all the NSString operations with the above method.</p>
<h1>Objective-C Extensions</h1>
<p>A class extension bears some similarity to a category, but it can only be added to a class for which you have the source code at compile time (the class is compiled at the same time as the class extension). </p>
<p>The methods declared by a class extension are implemented in the implementation block for the original class, so you can't, for example, declare a class extension on a framework class, such as a Cocoa or Cocoa Touch class like NSString..</p>
<p>Extensions are actually categories without the category name. It's often referred as <b>anonymous categories</b>.</p>
<p>The syntax to declare a extension uses the @interface keyword, just like a standard Objective-C class description, but does not indicate any inheritance from a subclass. Instead, it just adds parentheses, as shown below</p>
<pre class="prettyprint notranslate">
@interface ClassName ()

@end
</pre>

<h2>Characteristics of extensions</h2>
<ul class="list">
<li><p>An extension cannot be declared for any class, only for the classes that we have original implementation of source code.</p></li>
<li><p>An extension is adding private methods and private variables that are only specific to the class.</p></li>
<li><p>Any method or variable declared inside the extensions is not accessible even to the inherited classes.</p></li>
</ul>
<h2>Extensions Example</h2>
<p>Let's create a class SampleClass that has an extension. In the extension, let's have a private variable internalID.</p>
<p>Then, let's have a method getExternalID that returns the externalID after processing the internalID.</p>
<p>The example is shown below and this wont work on online compiler.</p>
<pre class="prettyprint notranslate">
#import &lt;Foundation/Foundation.h&gt;

@interface SampleClass : NSObject
{
    NSString *name;
}

- (void)setInternalID;
- (NSString *)getExternalID;

@end


@interface SampleClass()
{
    NSString *internalID;
}

@end

@implementation SampleClass

- (void)setInternalID{
    internalID = [NSString stringWithFormat: 
    @"UNIQUEINTERNALKEY%dUNIQUEINTERNALKEY",arc4random()%100];
}

- (NSString *)getExternalID{
    return [internalID stringByReplacingOccurrencesOfString: 
    @"UNIQUEINTERNALKEY" withString:@""];
}

@end

int main(int argc, const char * argv[])
{
    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
    SampleClass *sampleClass = [[SampleClass alloc]init];
    [sampleClass setInternalID];
    NSLog(@"ExternalID: %@",[sampleClass getExternalID]);        
    [pool drain];
    return 0;
}
</pre>
<p>Now when we compile and run the program, we will get the following result.</p>
<pre class="prettyprint notranslate">
2013-09-22 21:18:31.754 Extensions[331:303] ExternalID: 51
</pre>
<p>In the above example, we can see that the internalID is not returned directly. We here remove the UNIQUEINTERNALKEY and only make the remaining value available to the method getExternalID.</p>
<p>The above example just uses a string operation, but it can have many features like encryption/decryption and so on.</p>
<h1>Objective-C Protocols</h1>
<p>Objective-C allows you to define protocols, which declare the methods expected to be used for a particular situation. Protocols are implemented in the classes conforming to the protocol.</p>
<p>A simple example would be a network URL handling class, it will have a protocol with methods like processCompleted delegate method that intimates the calling class once the network URL fetching operation is over.</p> 
<p>A syntax of protocol is shown below.</p>
<pre class="prettyprint notranslate">
@protocol ProtocolName
@required
// list of required methods
@optional
// list of optional methods
@end
</pre>
<p>The methods under keyword <b>@required</b> must be implemented in the classes that conforms to the protocol and the methods under <b>@optional</b> keyword are optional to implement.</p>

<p>Here is the syntax for class conforming to protocol</p>
<pre class="prettyprint notranslate">
@interface MyClass : NSObject &lt;MyProtocol&gt;
...
@end
</pre>
<p>This means that any instance of MyClass will respond not only to the methods declared specifically in the interface, but that MyClass also provides implementations for the required methods in MyProtocol. There's no need to redeclare the protocol methods in the class interface - the adoption of the protocol is sufficient.</p>
<p>If you need a class to adopt multiple protocols, you can specify them as a comma-separated list. We have a delegate object that holds the reference of the calling object that implements the protocol.</p>
<p>An example is shown below.</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

@protocol PrintProtocolDelegate

- (void)processCompleted;

@end

@interface PrintClass :NSObject
{
    id delegate;
}

- (void) printDetails;
- (void) setDelegate:(id)newDelegate;
@end

@implementation PrintClass

- (void)printDetails{
    NSLog(@"Printing Details");
    [delegate processCompleted];
}

- (void) setDelegate:(id)newDelegate{
    delegate = newDelegate;
}

@end


@interface SampleClass:NSObject&lt;PrintProtocolDelegate&gt;

- (void)startAction;

@end

@implementation SampleClass

- (void)startAction{
    PrintClass *printClass = [[PrintClass alloc]init];
    [printClass setDelegate:self];
    [printClass printDetails];
}

-(void)processCompleted{
    NSLog(@"Printing Process Completed");
}

@end


int main(int argc, const char * argv[])
{
    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
    SampleClass *sampleClass = [[SampleClass alloc]init];
    [sampleClass startAction];
    [pool drain];
    return 0;
}
</pre>
<p>Now when we compile and run the program, we will get the following result.</p>
<pre class="prettyprint notranslate">
2013-09-22 21:15:50.362 Protocols[275:303] Printing Details
2013-09-22 21:15:50.364 Protocols[275:303] Printing Process Completed
</pre>
<p>In the above example we have seen how the delgate methods are called and executed. Its starts with startAction, once the process is completed, the delegate method processCompleted is called to intimate the operation is completed.</p>
<p>In any iOS or Mac app, we will never have a program implemented without a delegate. So its important we understand the usage of delegates. Delegates objects should use unsafe_unretained property type to avoid memory leaks.</p>
<h1>Objective-C Dynamic Binding</h1>
<p>Dynamic binding is determining the method to invoke at runtime instead of at compile time. Dynamic binding is also referred to as late binding.</p>
<p>In Objective-C, all methods are resolved dynamically at runtime. The exact code executed is determined by both the method name (the selector) and the receiving object.</p>
<p>Dynamic binding enables polymorphism. For example, consider a collection of objects including Rectangle and Square. Each object has its own implementation of a printArea  method.</p>
<p>In the following code fragment, the actual code that should be executed by the expression [anObject printArea] is determined at runtime. The runtime system uses the selector for the method run to identify the appropriate method in whatever class of anObject turns out to be.</p>
<p>Let us look at a simple code that would explain dynamic binding.</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

@interface Square:NSObject
{
   float area;
}
- (void)calculateAreaOfSide:(CGFloat)side;
- (void)printArea;
@end

@implementation Square

- (void)calculateAreaOfSide:(CGFloat)side
{
    area = side * side;
}
- (void)printArea
{
    NSLog(@"The area of square is %f",area);
}

@end

@interface Rectangle:NSObject
{
   float area;
}
- (void)calculateAreaOfLength:(CGFloat)length andBreadth:(CGFloat)breadth;
- (void)printArea;
@end

@implementation  Rectangle

- (void)calculateAreaOfLength:(CGFloat)length andBreadth:(CGFloat)breadth
{
    area = length * breadth;
}
- (void)printArea
{
    NSLog(@"The area of Rectangle is %f",area);
}

@end

int main()
{
   Square *square = [[Square alloc]init];
   [square calculateAreaOfSide:10.0];
   Rectangle *rectangle = [[Rectangle alloc]init];
   [rectangle calculateAreaOfLength:10.0 andBreadth:5.0];
   NSArray *shapes = [[NSArray alloc]initWithObjects: square, rectangle,nil];
   id object1 = [shapes objectAtIndex:0];
   [object1 printArea];
   id object2 = [shapes objectAtIndex:1];
   [object2 printArea];
   return 0;
}
</pre>
<p>Now when we compile and run the program, we will get the following result.</p>
<pre class="prettyprint notranslate">
2013-09-28 07:42:29.821 demo[4916] The area of square is 100.000000
2013-09-28 07:42:29.821 demo[4916] The area of Rectangle is 50.000000</pre>
<p>As you can see in the above example, printArea method is dynamically selected in runtime. It is an example for dynamic binding and is quite useful in many situations when dealing with similar kind of objects.</p>
<h1>Objective-C Composite Objects</h1>
<p>We can create subclass within a class cluster that defines a class that embeds within it an object. These class objects are composite objects.</p>
<p>So you might be wondering what's a class cluster. So we will first see what's a class cluster.</p>
<h2>Class Clusters</h2>
<p>Class clusters are a design pattern that the Foundation framework makes extensive use of. Class clusters group a number of private concrete subclasses under a public abstract superclass. The grouping of classes in this way simplifies the publicly visible architecture of an object-oriented framework without reducing its functional richness. Class clusters are based on the Abstract Factory design pattern.</p>
<p>To make it simple, instead of creating multiple classes for similar functions, we create a single class that will take care of its handling based on the value of input.</p>
<p>For example, in NSNumber we have many clusters of classes like char, int, bool and so on. We group all of them to a single class that takes care of handling the similar operations in a single class. NSNumber actually wraps the value of these primitive types into objects.</p>

<h2>So what's exactly composite object?</h2>
<p>By embedding a private cluster object in an object of our own design, we create a composite object. This composite object can rely on the cluster object for its basic functionality, only intercepting messages that the composite object wants to handle in some particular way. This architecture reduces the amount of code we must write and lets you take advantage of the tested code provided by the Foundation Framework.</p>
<p>This is explained in the following figure.</p>
<img src="/objective_c/images/compositeobject.png" alt="Objective-C Composite Objects" />
<p>The composite object must declare itself to be a subclass of the cluster's abstract superclass. As a subclass, it must override the superclass' primitive methods. It can also override derived methods, but this isn't necessary because the derived methods work through the primitive ones.</p>
<p>The count method of the NSArray class is an example; the intervening object's implementation of a method it overrides can be as simple as:</p>
<pre class="prettyprint notranslate">
- (unsigned)count 
{
return [embeddedObject count];
}
</pre>
<p>In the above example, embedded object is actually of type NSArray.</p>
<h2>A Composite Object example</h2>
<p>Now in order to see a complete example, let's look at the example from the Apple documentation which is given below.</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

@interface ValidatingArray : NSMutableArray
{
    NSMutableArray *embeddedArray;
}

+ validatingArray;
- init;
- (unsigned)count;
- objectAtIndex:(unsigned)index;
- (void)addObject:object;
- (void)replaceObjectAtIndex:(unsigned)index withObject:object;
- (void)removeLastObject;
- (void)insertObject:object atIndex:(unsigned)index;
- (void)removeObjectAtIndex:(unsigned)index;

@end

@implementation ValidatingArray
- init
{
   self = [super init];
   if (self) {
      embeddedArray = [[NSMutableArray allocWithZone:[self zone]] init];
   }
   return self;
}

+ validatingArray
{
   return [[self alloc] init] ;
}
- (unsigned)count
{
   return [embeddedArray count];
}
- objectAtIndex:(unsigned)index
{
    return [embeddedArray objectAtIndex:index];
}
- (void)addObject:(id)object
{
   if (object != nil) {
      [embeddedArray addObject:object];
   }
}
- (void)replaceObjectAtIndex:(unsigned)index withObject:(id)object;
{
   if (index &lt;[embeddedArray count] && object != nil) {
       [embeddedArray replaceObjectAtIndex:index withObject:object];
   }
}
- (void)removeLastObject;
{
   if ([embeddedArray count] > 0) {
       [embeddedArray removeLastObject];
   }
}
- (void)insertObject:(id)object atIndex:(unsigned)index;
{
   if (object != nil) {
       [embeddedArray insertObject:object atIndex:index];
   }
}
- (void)removeObjectAtIndex:(unsigned)index;
{
   if (index &lt;[embeddedArray count]) {
       [embeddedArray removeObjectAtIndex:index];
   }
}

@end

int main()
{
   NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
   ValidatingArray *validatingArray = [ValidatingArray validatingArray];
   [validatingArray addObject:@"Object1"];
   [validatingArray addObject:@"Object2"];
   [validatingArray addObject:[NSNull null]];
   [validatingArray removeObjectAtIndex:2];
   NSString *aString = [validatingArray objectAtIndex:1];
   NSLog(@"The value at Index 1 is %@",aString);
   [pool drain];
   return 0;
}
</pre>
<p>Now when we compile and run the program, we will get the following result.</p>
<pre class="prettyprint notranslate">
2013-09-28 22:03:54.294 demo[6247] The value at Index 1 is Object2</pre>
<p>In the above example, we can see that validating array's one function would not allow adding null objects that will lead to crash in the normal scenario. But our validating array takes care of it. Similarly, each of the method in validating array adds validating processes apart from the normal sequence of operations.</p>
<h1>Obj-C Foundation Framework</h1>
<p>If you refer Apple documentation, you can see the details of Foundation framework as given below.</p>
<p>The Foundation framework defines a base layer of Objective-C classes. In addition to providing a set of useful primitive object classes, it introduces several paradigms that define functionality not covered by the Objective-C language. The Foundation framework is designed with these goals in mind:</p>
<ul class="list">
<li><p>Provide a small set of basic utility classes.<p></li>
<li><p>Make software development easier by introducing consistent conventions for things such as deallocation.<p></li>
<li><p>Support Unicode strings, object persistence, and object distribution.<p></li>
<li><p>Provide a level of OS independence to enhance portability.<p></li>
</ul>
<p>The framework was developed by NeXTStep, which was acquired by Apple and these foundation classes became part of Mac OS X and iOS.</p>
<p>Since it was developed by NeXTStep, it has class prefix of "NS".</p>
<p>We have used Foundation Framework in all our sample programs. It is almost a must to use Foundation Framework.</p>
<p>Generally, we use something like <b>#import &lt;Foundation/NSString.h&gt;</b> to import a Objective-C class, but in order avoid importing too many classes, it's all imported in <b>#import &lt;Foundation/Foundation.h&gt</b>.</p>
<p>NSObject is the base class of all objects including the foundation kit classes. It provides the methods for memory management. It also provides basic interface to the runtime system and ability to behave as Objective-C objects. It doesn't have any base class and is the root for all classes.</p>
<h2>Foundation Classes based on functionality</h2>
<table class="table table-bordered">
<tr>
<th style="width:25%">Loop Type</th>
<th>Description</th>
</tr>
<tr>
<td><a href="/objective_c/objective_c_data_storage.htm" title="Data Storage in Objective-C">Data storage</a></td>
<td>NSArray, NSDictionary, and NSSet provide storage for Objective-C objects of any class.</td>
</tr>
<tr>
<td><a href="/objective_c/objective_c_texts_and_strings.htm" title="Text and strings in Objective-C">Text and strings</a></td>
<td>NSCharacterSet represents various groupings of characters that are used by the NSString and NSScanner classes. The NSString classes represent text strings and provide methods for searching, combining, and comparing strings. An NSScanner object is used to scan numbers and words from an NSString object.</td>
</tr>
<tr>
<td><a href="/objective_c/objective_c_dates_and_times.htm" title="Dates and times in Objective-C">Dates and times</a></td>
<td>The NSDate, NSTimeZone, and NSCalendar classes store times and dates and represent calendrical information. They offer methods for calculating date and time differences. Together with NSLocale, they provide methods for displaying dates and times in many formats and for adjusting times and dates based on location in the world.</td>
</tr>
<tr>
<td><a href="/objective_c/objective_c_exception_handling.htm" title="Exception Handling in Objective-C">Exception handling</a></td>
<td>Exception handling is used to handle unexpected situations and it's offered in Objective-C with NSException.</td>
</tr>
<tr>
<td><a href="/objective_c/objective_c_file_handling.htm" title="File Handling in Objective-C">File handling</a></td>
<td>File handling is done with the help of class NSFileManager.</td>
</tr>
<tr>
<td><a href="/objective_c/objective_c_url_loading_system" title="URL loading system in Objective-C">URL loading system</a></td>
<td>A set of classes and protocols that provide access to common Internet protocols.</td>
</tr>
</table>
<h1>Objective-C Fast Enumeration</h1>
<p>Fast enumeration is an Objective-C's feature that helps in enumerating through a collection. So in order to know about fast enumeration, we need know about collection first which will be explained in the following section.</p>
<h2>Collections in Objective-C</h2>
<p>Collections are fundamental constructs. It is used to hold and manage other objects. The whole purpose of a collection is that it provides a common way to store and retrieve objects efficiently.</p>
<p>There are several different types of collections. While they all fulfil the same purpose of being able to hold other objects, they differ mostly in the way objects are retrieved. The most common collections used in Objective-C are:</p>
<ul class="list">
<li><p>NSSet</p></li>
<li><p>NSArray</p></li>
<li><p>NSDictionary</p></li>
<li><p>NSMutableSet</p></li>
<li><p>NSMutableArray</p></li>
<li><p>NSMutableDictionary</p></li>
</ul>
<p>If you want to know more about these structures, please refer data storage in <a href="/objective_c/objective_c_foundation_framework.htm">Foundation Framework</a>.</p>
<h2>Fast enumeration Syntax</h2>
<pre class="prettyprint notranslate">
for (classType variable in collectionObject )
{ 
  statements 
}
</pre>
<p>Here is an example for fast enumeration.</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

int main()
{
   NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
   NSArray *array = [[NSArray alloc]
   initWithObjects:@"string1", @"string2",@"string3",nil];
   for(NSString *aString in array)
   {
      NSLog(@"Value: %@",aString);
   }
   [pool drain];
   return 0;
}
</pre>
<p>Now when we compile and run the program, we will get the following result.</p>
<pre class="prettyprint notranslate">
2013-09-28 06:26:22.835 demo[7426] Value: string1
2013-09-28 06:26:22.836 demo[7426] Value: string2
2013-09-28 06:26:22.836 demo[7426] Value: string3
</pre>
<p>As you can see in the output, each of the objects in the array is printed in an order.</p>
<h2>Fast Enumeration Backwards</h2>
<pre class="prettyprint notranslate">
for (classType variable in [collectionObject reverseObjectEnumerator] )
{ 
  statements 
}
</pre>
<p>Here is an example for reverseObjectEnumerator in fast enumeration.</p>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

int main()
{
   NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
   NSArray *array = [[NSArray alloc]
   initWithObjects:@"string1", @"string2",@"string3",nil];
   for(NSString *aString in [array reverseObjectEnumerator])
   {
      NSLog(@"Value: %@",aString);
   }
   [pool drain];
   return 0;
}
</pre>
<p>Now when we compile and run the program, we will get the following result.</p>
<pre class="prettyprint notranslate">
2013-09-28 06:27:51.025 demo[12742] Value: string3
2013-09-28 06:27:51.025 demo[12742] Value: string2
2013-09-28 06:27:51.025 demo[12742] Value: string1
</pre>
<p>As you can see in the output, each of the objects in the array is printed but in the reverse order as compared to normal fast enumeration.</p>
<h1>Obj-C Memory Management</h1>
<p>Memory management is one of the most important process in any programming language. It is the process by which the memory of objects are allocated when they are required and deallocated when they are no longer required.</p>
<p>Managing object memory is a matter of performance; if an application doesn't free unneeded objects, its memory footprint grows and performance suffers.</p>
<p>Objective-C Memory management techniques can be broadly classified into two types.</p>
<ul class="list">
<li><p>"Manual Retain-Release" or MRR</p></li>
<li><p>"Automatic Reference Counting" or ARC</p></li>
</ul>
<h2>"Manual Retain-Release" or MRR</h2>
<p>In MRR, we explicitly manage memory by keeping track of objects on our own. This is implemented using a model, known as reference counting, that the Foundation class NSObject provides in conjunction with the runtime environment.</p>
<p>The only difference between MRR and ARC is that the retain and release is handled by us manually in former while its automatically taken care of in the latter.</p>
<p>The following figure represents an example of how memory management work in Objective-C.</p>
<img src="/objective_c/images/memorymgnt_objectivec.png" alt="Objective-C Memory management" />
<p>The memory life cycle of the Class A object is shown in the above figure. As you can see, the retain count is shown below the object, when the retain count of an object becomes 0, the object is freed completely and its memory is deallocated for other objects to use.</p>
<p>Class A object is first created using alloc/init method available in NSObject. Now, the retain count becomes 1.</p>
<p>Now, class B retains the Class A's Object and the retain count of Class A's object becomes 2.</p>
<p>Then, Class C makes a copy of the object. Now, it is created as another instance of Class A with same values for the instance variables. Here, the retain count is 1 and not the retain count of the original object. This is represented by the dotted line in the figure.</p>
<p>The copied object is released by Class C using the release method and the retain count becomes 0 and hence the object is destroyed.</p>
<p>In case of the initial Class A Object, the retain count is 2 and it has to be released twice in order for it to be destroyed. This is done by release statements of Class A and Class B which decrements the retain count to 1 and 0, respectively. Finally, the object is destroyed.</p>
<h2>MRR Basic Rules</h2>
<ul class="list">
<li><p>We own any object we create: We create an object using a method whose name begins with "alloc", "new", "copy", or "mutableCopy"</p></li>
<li><p>We can take ownership of an object using retain: A received object is normally guaranteed to remain valid within the method it was received in, and that method may also safely return the object to its invoker. We use retain in two situations: 
<ul class="list">
<li><p>In the implementation of an accessor method or an init method, to take ownership of an object we want to store as a property value.</p></li> 
<li><p> To prevent an object from being invalidated as a side-effect of some other operation.</p></li>
</ul>
</p></li> 
<li><p>When we no longer need it, we must relinquish ownership of an object we own: We relinquish ownership of an object by sending it a release message or an autorelease message. In Cocoa terminology, relinquishing ownership of an object is therefore typically referred to as "releasing" an object.</p></li>
<li><p>You must not relinquish ownership of an object you do not own: This is just corollary of the previous policy rules stated explicitly.</p></li>
</ul>
<pre class="prettyprint notranslate tryit">
#import &lt;Foundation/Foundation.h&gt;

@interface SampleClass:NSObject
- (void)sampleMethod;
@end

@implementation SampleClass

- (void)sampleMethod
{
   NSLog(@"Hello, World! \n");
}

- (void)dealloc 
{
  NSLog(@"Object deallocated");
  [super dealloc];
}

@end

int main()
{
   /* my first program in Objective-C */
   SampleClass *sampleClass = [[SampleClass alloc]init];
   [sampleClass sampleMethod];
   NSLog(@"Retain Count after initial allocation: %d", 
   [sampleClass retainCount]);
   [sampleClass retain];
   NSLog(@"Retain Count after retain: %d", [sampleClass retainCount]);
   [sampleClass release];
   NSLog(@"Retain Count after release: %d", [sampleClass retainCount]);
   [sampleClass release];
   NSLog(@"SampleClass dealloc will be called before this");
   // Should set the object to nil
   sampleClass = nil;
   return 0;
}
</pre>
<p>When we compile the above program, we will get the following output.</p>
<pre class="prettyprint notranslate">
2013-09-28 04:39:52.310 demo[8385] Hello, World!
2013-09-28 04:39:52.311 demo[8385] Retain Count after initial allocation: 1
2013-09-28 04:39:52.311 demo[8385] Retain Count after retain: 2
2013-09-28 04:39:52.311 demo[8385] Retain Count after release: 1
2013-09-28 04:39:52.311 demo[8385] Object deallocated
2013-09-28 04:39:52.311 demo[8385] SampleClass dealloc will be called before this
</pre>
<h2>"Automatic Reference Counting" or ARC</h2>
<p>In Automatic Reference Counting or ARC, the system uses the same reference counting system as MRR, but it inserts the appropriate memory management method calls for us at compile-time. We are strongly encouraged to use ARC for new projects. If we use ARC, there is typically no need to understand the underlying implementation described in this document, although it may in some situations be helpful. For more about ARC, see <a target="_blank" rel="nofollow" href="https://developer.apple.com/library/ios/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html">Transitioning to ARC Release Notes.</a></p>
<p>As mentioned above, in ARC, we need not add release and retain methods since that will be taken care by the compiler. Actually, the underlying process of Objective-C is still the same. It uses the retain and release operations internally making it easier for the developer to code without worrying about these operations, which will reduce both the amount of code written and the possibility of memory leaks.</p>
<p>There was another principle called garbage collection, which is used in Mac OS-X along with MRR, but since its deprecation in OS-X Mountain Lion, it has not been discussed along with MRR. Also, iOS objects never had garbage collection feature. And with ARC, there is no use of garbage collection in OS-X too.</p>
<p>Here is a simple ARC example. Note this won't work on online compiler since it does not support ARC.</p>
<pre class="prettyprint notranslate">
#import &lt;Foundation/Foundation.h&gt;

@interface SampleClass:NSObject
- (void)sampleMethod;
@end

@implementation SampleClass

- (void)sampleMethod
{
   NSLog(@"Hello, World! \n");
}

- (void)dealloc 
{
  NSLog(@"Object deallocated");
}

@end

int main()
{
   /* my first program in Objective-C */
   @autoreleasepool{
       SampleClass *sampleClass = [[SampleClass alloc]init];
       [sampleClass sampleMethod];
	   sampleClass = nil;
   }
   return 0;
}
</pre>
<p>When we compile the above program, we will get the following output.</p>
<pre class="prettyprint notranslate">
2013-09-28 04:45:47.310 demo[8385] Hello, World!
2013-09-28 04:45:47.311 demo[8385] Object deallocated
</pre>

<title>Objective-C Useful Resources</title>

<h1>Objective-C - Useful Resources</h1>

<p>The following resources contain additional information on Objective C. Please use them to get more in-depth knowledge on this topic.</p>

<h2>Useful Links on Objective C</h2>

<p><a target="_blank" rel="nofollow" href="http://cocoadevcentral.com/d/learn_objectivec">Learn Objective-C</a> &minus; A tutorial written and illustrated by Scott Stevenson</p>

<p><a target="_blank" rel="nofollow" href="http://www.compileonline.com/compile_objective-c_online.php">Online Objective-C Compiler</a> &minus; Compile and run your Objective-C program online.</p>

<p><a target="_blank" rel="nofollow" href="https://github.com/github/objective-c-style-guide">Objective-c Sstyle Guide </a> &minus; These guidelines build on Apple's existing Coding Guidelines for Cocoa.</p>

<p><a target="_blank" rel="nofollow" href="http://en.wikipedia.org/wiki/Objective-C/">Objective C on wikipedia</a> &minus; Short tutorial on Objective C on Wikipedia.</p>

<h2>Useful Books on Objective C</h2>

<p>To enlist your site on this page, please drop an email to <b>contact@tutorialspoint.com</b></p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Discuss Objective-C</title>

<h1>Discuss Objective-C</h1>

<p>Objective-C is a general-purpose, object-oriented programming language that adds Smalltalk-style messaging to the C programming language. This is the main programming language used by Apple for the OS X and iOS operating systems and their respective APIs, Cocoa and Cocoa Touch.</p>

<p>This reference will take you through simple and practical approach while learning Objective-C Programming language.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

</body></html>