<!DOCTYPE html><html><body><title>Automata Theory Tutorial</title>

<h1>Automata Theory Tutorial</h1>

<p><b>Automata Theory</b> is a branch of computer science that deals with designing abstract selfpropelled computing devices that follow a predetermined sequence of operations automatically. An automaton with a finite number of states is called a <b>Finite Automaton</b>. This is a brief and concise tutorial that introduces the fundamental concepts of Finite Automata, Regular Languages, and Pushdown Automata before moving onto Turing machines and Decidability.</p>

<h1>Audience</h1>

<p>This tutorial has been prepared for students pursuing a degree in any information technology or computer science related field. It attempts to help students grasp the essential concepts involved in automata theory.</p>

<h1>Prerequisites</h1>

<p>This tutorial has a good balance between theory and mathematical rigor. The readers are expected to have a basic understanding of discrete mathematical structures.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Automata Theory Introduction</title>

<h1>Automata Theory Introduction</h1>

<h2>Automata – What is it?</h2>

<p>The term "Automata" is derived from the Greek word "αὐτόματα" which means "self-acting". An automaton (Automata in plural) is an abstract self-propelled computing device which follows a predetermined sequence of operations automatically.</p>

<p>An automaton with a finite number of states is called a <b>Finite Automaton</b> (FA) or <b>Finite State Machine</b> (FSM).</p>

<h3>Formal definition of a Finite Automaton</h3>

<p>An automaton can be represented by a 5-tuple (Q, &sum;, &delta;, q<sub>0</sub>, F), where &minus;</p>

<p><b>Q</b> is a finite set of states.</p>

<p><b>&sum;</b> is a finite set of symbols, called the <b>alphabet</b> of the automaton.</p>

<p><b>&delta;</b> is the transition function.</p>

<p><b>q<sub>0</sub></b> is the initial state from where any input is processed (q<sub>0</sub> &isin; Q).</p>

<p><b>F</b> is a set of final state/states of Q (F &sube; Q).</p>

<h2>Related Terminologies </h2>

<h3>Alphabet</h3>

<p><b>Definition</b> &minus; An <b>alphabet</b> is any finite set of symbols.</p>

<p><b>Example</b> &minus; &sum; = {a, b, c, d} is an <b>alphabet set</b> where ‘a’, ‘b’, ‘c’, and ‘d’ are <b>symbols</b>.</p>

<h3>String</h3>

<p><b>Definition</b> &minus; A <b>string</b> is a finite sequence of symbols taken from &sum;.</p>

<p><b>Example</b> &minus; ‘cabcad’ is a valid string on the alphabet set &sum; = {a, b, c, d}</p>

<h3>Length of a String</h3>

<p><b>Definition</b> &minus; It is the number of symbols present in a string. (Denoted by <b>|S|</b>).</p>

<p><b>Examples</b> &minus;</p>

<p>If S = ‘cabcad’, |S|= 6</p>

<p>If |S|= 0, it is called an <b>empty string</b> (Denoted by <b>&lambda;</b> or <b>&epsilon;</b>)</p>

<h3>Kleene Star</h3>

<p><b>Definition</b> &minus; The Kleene star, <b>&sum;*</b>, is a unary operator on a set of symbols or strings, <b>&sum;</b>, that gives the infinite set of all possible strings of all possible lengths over <b>&sum;</b> including <b>&lambda;</b>.</p>

<p><b>Representation</b> &minus; &sum;* = &sum;<sub>0</sub> &cup; &sum;<sub>1</sub> &cup; &sum;<sub>2</sub> &cup;……. where &sum;<sub>p</sub> is the set of all possible strings of length p.</p>

<p><b>Example</b> &minus; If &sum; = {a, b}, &sum;* = {&lambda;, a, b, aa, ab, ba, bb,………..}</p>

<h3>Kleene Closure / Plus</h3>

<p><b>Definition</b> &minus; The set <b>&sum;<sup>+</sup></b> is the infinite set of all possible strings of all possible lengths over &sum; excluding &lambda;.</p>

<p><b>Representation</b> &minus; &sum;<sup>+</sup> = &sum;<sub>1</sub> &cup; &sum;<sub>2</sub> &cup; &sum;<sub>3</sub> &cup;…….</p>

<p><b>Example</b> &minus; If &sum; = { a, b } , &sum;<sup>+</sup> = { a, b, aa, ab, ba, bb,………..}</p>

<h3>Language</h3>

<p><b>Definition</b> &minus; A language is a subset of &sum;* for some alphabet &sum;. It can be finite or infinite.</p>

<p><b>Example</b> &minus; If the language takes all possible strings of length 2 over &sum; = {a, b}, then L = { ab, bb, ba, bb}</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Deterministic Finite Automaton</title>

<h1>Deterministic Finite Automaton</h1>

<p>Finite Automaton can be classified into two types &minus;</p>

<h2>Deterministic Finite Automaton (DFA)</h2>

<p>In DFA, for each input symbol, one can determine the state to which the machine will move. Hence, it is called <b>Deterministic Automaton</b>. As it has a finite number of states, the machine is called <b>Deterministic Finite Machine</b> or <b>Deterministic Finite Automaton.</b></p>

<h2>Formal Definition of a DFA</h2>

<p>A DFA can be represented by a 5-tuple (Q, &sum;, &delta;, q<sub>0</sub>, F) where &minus;</p>

<p><b>Q</b> is a finite set of states.</p>

<p><b>&sum;</b> is a finite set of symbols called the alphabet.</p>

<p><b>&delta;</b> is the transition function where &delta;: Q &times; &sum; &rarr; Q </p>

<p><b>q<sub>0</sub></b> is the initial state from where any input is processed (q<sub>0</sub> &isin; Q).</p>

<p><b>F</b> is a set of final state/states of Q (F &sube; Q).</p>

<h2>Graphical Representation of a DFA</h2>

<p>A DFA is represented by digraphs called <b>state diagram</b>.</b></p>

<h3>Example</h3>

<p>Let a deterministic finite automaton be &rarr;</p>

<p>Transition function &delta; as shown by the following table &minus;</p>

<p>Its graphical representation would be as follows &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Non-deterministic Finite Automaton</title>

<h1>Non-deterministic Finite Automaton</h1>

<p>In NDFA, for a particular input symbol, the machine can move to any combination of the states in the machine. In other words, the exact state to which the machine moves cannot be determined. Hence, it is called <b>Non-deterministic Automaton</b>. As it has finite number of states, the machine is called <b>Non-deterministic Finite Machine</b> or <b>Non-deterministic Finite Automaton</b>.</p>

<h3>Formal Definition of an NDFA</h3>

<p>An NDFA can be represented by a 5-tuple (Q, &sum;, &delta;, q<sub>0</sub>, F) where &minus;</p>

<p><b>Q</b> is a finite set of states.</p>

<p><b>&sum;</b> is a finite set of symbols called the alphabets.</p>

<p><b>&delta;</b> is the transition function where &delta;: Q &times; &sum; &rarr; 2<sup>Q</sup></p>

<p>(Here the power set of Q (2<sup>Q</sup>) has been taken because in case of NDFA, from a state, transition can occur to any combination of Q states)</p>

<p><b>q<sub>0</sub></b> is the initial state from where any input is processed (q<sub>0</sub> &isin; Q).</p>

<p><b>F</b> is a set of final state/states of Q (F &sube; Q).</p>

<h3>Graphical Representation of an NDFA: (same as DFA)</h3>

<p>An NDFA is represented by digraphs called state diagram.</p>

<p><b>Example</b></p>

<p>Let a non-deterministic finite automaton be &rarr;</p>

<p>The transition function &delta; as shown below &minus;</p>

<p>Its graphical representation would be as follows &minus;</p>

<h2>DFA vs NDFA</h2>

<p>The following table lists the differences between DFA and NDFA.</p>

<h2>Acceptors, Classifiers, and Transducers</h2>

<h3>Acceptor (Recognizer)</h3>

<p>An automaton that computes a Boolean function is called an <b>acceptor</b>. All the states of an acceptor is either accepting or rejecting the inputs given to it.</p>

<h3>Classifier</h3>

<p>A <b>classifier</b> has more than two final states and it gives a single output when it terminates.</p>

<h3>Transducer</h3>

<p>An automaton that produces outputs based on current input and/or previous state is called a <b>transducer</b>. Transducers can be of two types &minus;</p>

<p><b>Mealy Machine</b> &minus; The output depends both on the current state and the current input.</p>

<p><b>Moore Machine</b> &minus; The output depends only on the current state.</p>

<h2>Acceptability by DFA and NDFA</h2>

<p>A string is accepted by a DFA/NDFA iff the DFA/NDFA starting at the initial state ends in an accepting state (any of the final states) after reading the string wholly.</p>

<p>A string S is accepted by a DFA/NDFA (Q, &sum;, &delta;, q<sub>0</sub>, F), iff</p>

<p>The language <b>L</b> accepted by DFA/NDFA is</p>

<p>A string S′ is not accepted by a DFA/NDFA (Q, &sum;, &delta;, q<sub>0</sub>, F), iff</p>

<p>The language L′ not accepted by DFA/NDFA (Complement of accepted language L) is</p>

<p><b>Example</b></p>

<p>Let us consider the DFA shown in Figure 1.3. From the DFA, the acceptable strings can be derived.</p>

<p>Strings accepted by the above DFA: {0, 00, 11, 010, 101, ...........}</p>

<p>Strings not accepted by the above DFA: {1, 011, 111, ........}</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>NDFA to DFA Conversion</title>

<h1>NDFA to DFA Conversion</h1>

<h2>Problem Statement</h2>

<p>Let <b>X = (Q<sub>x</sub>, &sum;, &delta;<sub>x</sub>, q<sub>0</sub>, F<sub>x</sub>)</b> be an NDFA which accepts the language L(X). We have to design an equivalent DFA <b>Y = (Q<sub>y</sub>, &sum;, &delta;<sub>y</sub>, q<sub>0</sub>, F<sub>y</sub>)</b> such that <b>L(Y) = L(X)</b>. The following procedure converts the NDFA to its equivalent DFA &minus;</p>

<h2>Algorithm</h2>

<p><b>Input</b> &minus; An NDFA</p>

<p><b>Output</b> &minus; An equivalent DFA</p>

<p><b>Step 1</b> &minus; Create state table from the given NDFA.</p>

<p><b>Step 2</b> &minus; Create a blank state table under possible input alphabets for the equivalent DFA.</p>

<p><b>Step 3</b> &minus; Mark the start state of the DFA by q0 (Same as the NDFA).</p>

<p><b>Step 4</b> &minus; Find out the combination of States {Q<sub>0</sub>, Q<sub>1</sub>,... , Q<sub>n</sub>} for each possible input alphabet.</p>

<p><b>Step 5</b> &minus; Each time we generate a new DFA state under the input alphabet columns, we have to apply step 4 again, otherwise go to step 6.</p>

<p><b>Step 6</b> &minus; The states which contain any of the final states of the NDFA are the final states of the equivalent DFA.</p>

<h2>Example</h2>

<p>Let us consider the NDFA shown in the figure below.</p>

<p>Using the above algorithm, we find its equivalent DFA. The state table of the DFA is shown in below.</p>

<p>The state diagram of the DFA is as follows &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>DFA Minimization</title>

<h1>DFA Minimization</h1>

<h2>DFA Minimization using Myphill-Nerode Theorem</h2>

<h3>Algorithm</h3>

<p><b>Input</b> &minus; DFA</p>

<p><b>Output</b> &minus; Minimized DFA</p>

<p><b>Step 1</b> &minus; Draw a table for all pairs of states (Q<sub>i</sub>, Q<sub>j</sub>) not necessarily connected directly [All are unmarked initially]</p>

<p><b>Step 2</b> &minus; Consider every state pair (Q<sub>i</sub>, Q<sub>j</sub>) in the DFA where Q<sub>i</sub> &isin; F and Q<sub>j</sub> &notin; F or vice versa and mark them. [Here F is the set of final states]</p>

<p><b>Step 3</b> &minus; Repeat this step until we cannot mark anymore states &minus;</p>

<p>If there is an unmarked pair (Q<sub>i</sub>, Q<sub>j</sub>), mark it if the pair {&delta; (Q<sub>i</sub>, A), &delta; (Q<sub>i</sub>, A)} is marked for some input alphabet.</p>

<p><b>Step 4</b> &minus; Combine all the unmarked pair (Q<sub>i</sub>, Q<sub>j</sub>) and make them a single state in the reduced DFA.</p>

<h3>Example</h3>

<p>Let us use Algorithm 2 to minimize the DFA shown below.</p>

<p><b>Step 1</b> &minus; We draw a table for all pair of states.</p>

<p><b>Step 2</b> &minus; We mark the state pairs.</p>

<p><b>Step 3</b> &minus; We will try to mark the state pairs, with green colored check mark, transitively. If we input 1 to state ‘a’ and ‘f’, it will go to state ‘c’ and ‘f’ respectively. (c, f) is already marked, hence we will mark pair (a, f). Now, we input 1 to state ‘b’ and ‘f’; it will go to state ‘d’ and ‘f’ respectively. (d, f) is already marked, hence we will mark pair (b, f).</p>

<p>After step 3, we have got state combinations {a, b} {c, d} {c, e} {d, e} that are unmarked.</p>

<p>We can recombine {c, d} {c, e} {d, e} into {c, d, e}</p>

<p>Hence we got two combined states as &minus; {a, b} and {c, d, e}</p>

<p>So the final minimized DFA will contain three states {f}, {a, b} and {c, d, e}</p>

<h2>DFA Minimization using Equivalence Theorem</h2>

<p>If X and Y are two states in a DFA, we can combine these two states into {X, Y} if they are not distinguishable. Two states are distinguishable, if there is at least one string S, such that one of &delta; (X, S) and &delta; (Y, S) is accepting and another is not accepting. Hence, a DFA is minimal if and only if all the states are distinguishable.</p>

<h3>Algorithm 3</h3>

<p><b>Step 1</b> &minus; All the states <b>Q</b> are divided in two partitions &minus; <b>final states</b> and <b>non-final states</b> and are denoted by <b>P<sub>0</sub></b>. All the states in a partition are 0<sup>th</sup> equivalent. Take a counter <b>k</b> and initialize it with 0.</p>

<p><b>Step 2</b> &minus; Increment k by 1. For each partition in P<sub>k</sub>, divide the states in P<sub>k</sub> into two partitions if they are k-distinguishable. Two states within this partition X and Y are k-distinguishable if there is an input <b>S</b> such that <b>&delta;(X, S)</b> and <b>&delta;(Y, S)</b> are (k-1)-distinguishable.</p>

<p><b>Step 3</b> &minus; If P<sub>k</sub> &ne; P<sub>k-1</sub>, repeat Step 2, otherwise go to Step 4.</p>

<p><b>Step 4</b> &minus; Combine k<sup>th</sup> equivalent sets and make them the new states of the reduced DFA.</p>

<h3>Example</h3>

<p>Let us consider the following DFA &minus;</p>

<p>Let us apply the above algorithm to the above DFA &minus;</p>

<p>Hence, P<sub>1</sub> = P<sub>2</sub>.</p>

<p>There are three states in the reduced DFA. The reduced DFA is as follows &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Moore and Mealy Machines</title>

<h1>Moore and Mealy Machines</h1>

<p>Finite automata may have outputs corresponding to each transition. There are two types of finite state machines that generate output &minus;</p>

<h3>Mealy Machine</h3>

<p>A Mealy Machine is an FSM whose output depends on the present state as well as the present input.</p>

<p>It can be described by a 6 tuple (Q, &sum;, O, &delta;, X, q<sub>0</sub>) where &minus;</p>

<p><b>Q</b> is a finite set of states.</p>

<p><b>&sum;</b> is a finite set of symbols called the input alphabet.</p>

<p><b>O</b> is a finite set of symbols called the output alphabet.</p>

<p><b>&delta;</b> is the input transition function where &delta;: Q &times; &sum; &rarr; Q</p>

<p><b>X</b> is the output transition function where X: Q &times; &sum; &rarr; O</p>

<p><b>q<sub>0</sub></b> is the initial state from where any input is processed (q<sub>0</sub> &isin; Q).</p>

<p>The state table of a Mealy Machine is shown below &minus;</p>

<p>The state diagram of the above Mealy Machine is &minus;</p>

<h3>Moore Machine</h3>

<p>Moore machine is an FSM whose outputs depend on only the present state.</p>

<p>A Moore machine can be described by a 6 tuple (Q, &sum;, O, &delta;, X, q<sub>0</sub>) where &minus;</p>

<p><b>Q</b> is a finite set of states.</p>

<p><b>&sum;</b> is a finite set of symbols called the input alphabet.</p>

<p><b>O</b> is a finite set of symbols called the output alphabet.</p>

<p><b>&delta;</b> is the input transition function where &delta;: Q &times; &sum; &rarr; Q</p>

<p><b>X</b> is the output transition function where X: Q &rarr; O</p>

<p><b>q<sub>0</sub></b> is the initial state from where any input is processed (q<sub>0</sub> &isin; Q).</p>

<p>The state table of a Moore Machine is shown below &minus;</p>

<p>The state diagram of the above Moore Machine is &minus;</p>

<h3>Mealy Machine vs. Moore Machine</h3>

<p>The following table highlights the points that differentiate a Mealy Machine from a Moore Machine.</p>

<h2>Moore Machine to Mealy Machine</h2>

<h3>Algorithm 4</h3>

<p><b>Input</b> &minus; Moore Machine</p>

<p><b>Output</b> &minus; Mealy Machine</p>

<p><b>Step 1</b> &minus; Take a blank Mealy Machine transition table format.</p>

<p><b>Step 2</b> &minus; Copy all the Moore Machine transition states into this table format.</p>

<p><b>Step 3</b> &minus; Check the present states and their corresponding outputs in the Moore Machine state table; if for a state Q<sub>i</sub> output is m, copy it into the output columns of the Mealy Machine state table wherever Q<sub>i</sub> appears in the next state.</p>

<h3>Example</h3>

<p>Let us consider the following Moore machine &minus;</p>

<p>Now we apply Algorithm 4 to convert it to Mealy Machine.</p>

<p><b>Step 1 &amp; 2</b> &minus;</p>

<p><b>Step 3</b> &minus;</p>

<h2>Mealy Machine to Moore Machine</h2>

<h3>Algorithm 5</h3>

<p><b>Input</b> &minus; Mealy Machine</p>

<p><b>Output</b> &minus; Moore Machine</p>

<p><b>Step 1</b> &minus; Calculate the number of different outputs for each state (Q<sub>i</sub>) that are available in the state table of the Mealy machine.</p>

<p><b>Step 2</b> &minus; If all the outputs of Qi are same, copy state Q<sub>i</sub>. If it has n distinct outputs, break Q<sub>i</sub> into n states as Q<sub>in</sub> where <b>n</b> = 0, 1, 2.......</p>

<p><b>Step 3</b> &minus; If the output of the initial state is 1, insert a new initial state at the beginning which gives 0 output.</p>

<h3>Example</h3>

<p>Let us consider the following Mealy Machine &minus;</p>

<p>Here, states ‘a’ and ‘d’ give only 1 and 0 outputs respectively, so we retain states ‘a’ and ‘d’. But states ‘b’ and ‘c’ produce different outputs (1 and 0). So, we divide <b>b</b> into <b>b<sub>0</sub>, b<sub>1</sub></b> and <b>c</b> into <b>c<sub>0</sub>, c<sub>1</sub></b>.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Introduction to Grammars</title>

<h1>Introduction to Grammars</h1>

<p>n the literary sense of the term, grammars denote syntactical rules for conversation in natural languages. Linguistics have attempted to define grammars since the inception of natural languages like English, Sanskrit, Mandarin, etc.</p>

<p>The theory of formal languages finds its applicability extensively in the fields of Computer Science. <b>Noam Chomsky</b> gave a mathematical model of grammar in 1956 which is effective for writing computer languages.</p>

<h2>Grammar</h2>

<p>A grammar <b>G</b> can be formally written as a 4-tuple (N, T, S, P) where &minus;</p>

<p><b>N</b> or <b>V<sub><i><small>N</small></i></sub></b> is a set of variables or non-terminal symbols.</p>

<p><b>T</b> or <b>&sum;</b> is a set of Terminal symbols.</p>

<p><b>S</b> is a special variable called the Start symbol, S &isin; N</p>

<p><b>P</b> is Production rules for Terminals and Non-terminals. A production rule has the form &alpha; &rarr; &beta;, where &alpha; and &beta; are strings on V<sub><i><small>N</small></i></sub> &cup; &sum; and least one symbol of &alpha; belongs to V<sub>N</sub>.</p>

<h3>Example</h3>

<p>Grammar G1 &minus;</p>

<p>Here,</p>

<p><b>S, A,</b> and <b>B</b> are Non-terminal symbols;</p>

<p><b>a</b> and <b>b</b> are Terminal symbols</p>

<p><b>S</b> is the Start symbol, S &isin; N</p>

<p>Productions, <b>P : S &rarr; AB, A &rarr; a, B &rarr; b</b></p>

<h3>Example</h3>

<p>Grammar G2 &minus;</p>

<p>Here,</p>

<p><b>S</b> and <b>A</b> are Non-terminal symbols.</p>

<p><b>a</b> and <b>b</b> are Terminal symbols.</p>

<p><b>&epsilon;</b> is an empty string.</p>

<p><b>S</b> is the Start symbol, S &isin; N</p>

<p>Production <b>P : S &rarr; aAb, aA &rarr; aaAb, A &rarr; &epsilon;</b></p>

<h2>Derivations from a Grammar</h2>

<p>Strings may be derived from other strings using the productions in a grammar. If a grammar <b>G</b> has a production <b>&alpha; &rarr; &beta;</b>, we can say that <b>x &alpha; y</b> derives <b>x &beta; y</b> in <b>G</b>. This derivation is written as &minus;</p>

<h3>Example</h3>

<p>Let us consider the grammar &minus;</p>

<p>Some of the strings that can be derived are &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Language Generated by a Grammar</title>

<h1>Language Generated by a Grammar</h1>

<p>The set of all strings that can be derived from a grammar is said to be the language generated from that grammar. A language generated by a grammar <b>G</b> is a subset formally defined by</p>

<p>If <b>L(G1) = L(G2)</b>, the Grammar <b>G1</b> is equivalent to the Grammar <b>G2</b>.</p>

<h3>Example</h3>

<p>If there is a grammar</p>

<p>Here <b>S</b> produces <b>AB</b>, and we can replace <b>A</b> by <b>a</b>, and <b>B</b> by <b>b</b>. Here, the only accepted string is <b>ab</b>, i.e.,</p>

<h3>Example</h3>

<p>Suppose we have the following grammar &minus;</p>

<p>The language generated by this grammar &minus;</p>

<h2>Construction of a Grammar Generating a Language</h2>

<p>We’ll consider some languages and convert it into a grammar G which produces those languages.</p>

<h3>Example</h3>

<p><b><i>Problem</i></b> &minus; Suppose, L (G) = {a<sup>m</sup> b<sup>n</sup> | m &ge; 0 and n &gt; 0}. We have to find out the grammar <b>G</b> which produces <b>L(G)</b>.</p>

<p><b><i>Solution</i></b></p>

<p>Since L(G) = {a<sup>m</sup> b<sup>n</sup> | m &ge; 0 and n &gt; 0}</p>

<p>the set of strings accepted can be rewritten as &minus;</p>

<p>Here, the start symbol has to take at least one ‘b’ preceded by any number of ‘a’ including null.</p>

<p>To accept the string set {b, ab, bb, aab, abb, …….}, we have taken the productions &minus;</p>

<p>Thus, we can prove every single string in L(G) is accepted by the language generated by the production set.</p>

<p>Hence the grammar &minus;</p>

<h3>Example</h3>

<p><b><i>Problem</i></b> &minus; Suppose, L (G) = {a<sup>m</sup> b<sup>n</sup> | m &gt; 0 and n &ge; 0}. We have to find out the grammar G which produces L(G).</p>

<p><b><i>Solution</i></b> &minus;</p>

<p>Since L(G) = {a<sup>m</sup> b<sup>n</sup> | m &gt; 0 and n &ge; 0}, the set of strings accepted can be rewritten as &minus;</p>

<p>Here, the start symbol has to take at least one ‘a’ followed by any number of ‘b’ including null.</p>

<p>To accept the string set {a, aa, ab, aaa, aab, abb, …….}, we have taken the productions &minus;</p>

<p>Thus, we can prove every single string in L(G) is accepted by the language generated by the production set.</p>

<p>Hence the grammar &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Chomsky Classification of Grammars</title>

<h1>Chomsky Classification of Grammars</h1>

<p>According to Noam Chomosky, there are four types of grammars &minus; Type 0, Type 1, Type 2, and Type 3. The following table shows how they differ from each other &minus;</p>

<p>Take a look at the following illustration. It shows the scope of each type of grammar &minus;</p>

<h2>Type - 3 Grammar</h2>

<p><b>Type-3 grammars</b> generate regular languages. Type-3 grammars must have a single non-terminal on the left-hand side and a right-hand side consisting of a single terminal or single terminal followed by a single non-terminal.</p>

<p>The productions must be in the form <b>X &rarr; a or X &rarr; aY</b></p>

<p>where <span style="padding-left:2%;"><b>X, Y &isin; N</b> (Non terminal)</span></p>

<p>and <span style="padding-left:2%;"><b>a &isin; T</b> (Terminal)</span></p>

<p>The rule <b>S &rarr; &epsilon;</b> is allowed if <b>S</b> does not appear on the right side of any rule.</p>

<h3>Example</h3>

<h2>Type - 2 Grammar</h2>

<p><b>Type-2 grammars</b> generate context-free languages.</p>

<p>The productions must be in the form <b>A &rarr; γ</b></p>

<p>where <span style="padding-left:2%;"><b> A &isin; N</b> (Non terminal)</span></p>

<p>and <span style="padding-left:2%;"><b>γ &isin; (T &cup; N)*</b> (String of terminals and non-terminals).</span></p>

<p>These languages generated by these grammars are be recognized by a non-deterministic pushdown automaton.</p>

<h3>Example</h3>

<h2>Type - 1 Grammar</h2>

<p><b>Type-1 grammars</b> generate context-sensitive languages. The productions must be in the form</p>

<p>where <span style="padding-left:2%;"><b>A &isin; N</b> (Non-terminal)</span></p>

<p>and <span style="padding-left:2%;"><b>&alpha;, &beta;, γ &isin; (T &cup; N)*</b> (Strings of terminals and non-terminals)</span></p>

<p>The strings <b>&alpha;</b> and <b>&beta;</b> may be empty, but <b>γ</b> must be non-empty.</p>

<p>The rule <b>S &rarr; &epsilon;</b> is allowed if S does not appear on the right side of any rule. The languages generated by these grammars are recognized by a linear bounded automaton.</p>

<h3>Example</h3>

<h2>Type - 0 Grammar</h2>

<p><b>Type-0 grammars</b> generate recursively enumerable languages. The productions have no restrictions. They are any phase structure grammar including all formal grammars.</p>

<p>They generate the languages that are recognized by a Turing machine.</p>

<p>The productions can be in the form of <b>&alpha; &rarr; &beta;</b> where <b>&alpha;</b> is a string of terminals and nonterminals with at least one non-terminal and <b>&alpha;</b> cannot be null. <b>&beta;</b> is a string of terminals and non-terminals.</p>

<h3>Example</h3>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
X &rarr; &epsilon; 
X &rarr; a | aY
Y &rarr; b 
</pre>
<h2>Type - 2 Grammar</h2>
<p><b>Type-2 grammars</b> generate context-free languages.</p>
<p>The productions must be in the form <b>A &rarr; γ</b></p>
<p>where <span style="padding-left:2%;"><b> A &isin; N</b> (Non terminal)</span></p>
<p>and <span style="padding-left:2%;"><b>γ &isin; (T &cup; N)*</b> (String of terminals and non-terminals).</span></p>
<p>These languages generated by these grammars are be recognized by a non-deterministic pushdown automaton.</p>
<h3>Example</h3>
<pre class="result notranslate">
S &rarr; X a 
X &rarr; a 
X &rarr; aX 
X &rarr; abc 
X &rarr; &epsilon;
</pre>
<h2>Type - 1 Grammar</h2>
<p><b>Type-1 grammars</b> generate context-sensitive languages. The productions must be in the form</p>
<p style="padding-left:12%;"><b>&alpha; A &beta; &rarr; &alpha; γ &beta;</b></p>
<p>where <span style="padding-left:2%;"><b>A &isin; N</b> (Non-terminal)</span></p>
<p>and <span style="padding-left:2%;"><b>&alpha;, &beta;, γ &isin; (T &cup; N)*</b> (Strings of terminals and non-terminals)</span></p>
<p>The strings <b>&alpha;</b> and <b>&beta;</b> may be empty, but <b>γ</b> must be non-empty.</p>
<p>The rule <b>S &rarr; &epsilon;</b> is allowed if S does not appear on the right side of any rule. The languages generated by these grammars are recognized by a linear bounded automaton.</p>
<h3>Example</h3>
<pre class="result notranslate">
AB &rarr; AbBc 
A &rarr; bcA 
B &rarr; b 
</pre>
<h2>Type - 0 Grammar</h2>
<p><b>Type-0 grammars</b> generate recursively enumerable languages. The productions have no restrictions. They are any phase structure grammar including all formal grammars.</p>
<p>They generate the languages that are recognized by a Turing machine.</p>
<p>The productions can be in the form of <b>&alpha; &rarr; &beta;</b> where <b>&alpha;</b> is a string of terminals and nonterminals with at least one non-terminal and <b>&alpha;</b> cannot be null. <b>&beta;</b> is a string of terminals and non-terminals.</p>
<h3>Example</h3>
<pre class="result notranslate">
S &rarr; ACaB 
Bc &rarr; acB 
CB &rarr; DB 
aD &rarr; Db 
</pre>

<title>Regular Expressions</title>

<h1>Regular Expressions</h1>

<p>A <b>Regular Expression</b> can be recursively defined as follows &minus;</p>

<p><b>&epsilon;</b> is a Regular Expression indicates the language containing an empty string. <b>(L (&epsilon;) = {&epsilon;})</b></p>

<p><b>&phi;</b> is a Regular Expression denoting an empty language. <b>(L (&phi;) = { })</b></p>

<p><b>x</b> is a Regular Expression where <b>L = {x}</b></p>

<p>If <b>X</b> is a Regular Expression denoting the language <b>L(X)</b> and <b>Y</b> is a Regular Expression denoting the language <b>L(Y)</b>, then</p>

<p><b>X + Y</b> is a Regular Expression corresponding to the language <b>L(X) &cup; L(Y)</b> where <b>L(X+Y) = L(X) &cup; L(Y)</b>.</p>

<p><b>X . Y</b> is a Regular Expression corresponding to the language <b>L(X) . L(Y)</b> where <b>L(X.Y) = L(X) . L(Y)</b></p>

<p><b>R*</b> is a Regular Expression corresponding to the language <b>L(R*)</b>where <b>L(R*) = (L(R))*</b></p>

<p>If we apply any of the rules several times from 1 to 5, they are Regular Expressions.</p>

<h2>Some RE Examples</h2>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Regular Sets</title>

<h1>Regular Sets</h1>

<p>Any set that represents the value of the Regular Expression is called a <b>Regular Set.</b></p>

<h3>Properties of Regular Sets</h3>

<p><b>Property 1</b>. <i>The union of two regular set is regular.</i></p>

<p><b>Proof</b> &minus;</p>

<p>Let us take two regular expressions</p>

<p>So, <span style="padding-left:2%">L<sub>1</sub> = {a, aaa, aaaaa,.....} (Strings of odd length excluding Null)</span></p>

<p>and  <span style="padding-left:2%">L<sub>2</sub> ={ &epsilon;, aa, aaaa, aaaaaa,.......} (Strings of even length including Null)</span></p>

<p><b>Hence, proved.</b></p>

<p><b>Property 2.</b> <i>The intersection of two regular set is regular.</i></p>

<p><b>Proof</b> &minus;</p>

<p>Let us take two regular expressions</p>

<p>So, <span style="padding-left:2%">L<sub>1</sub> = { a,aa, aaa, aaaa, ....}  (Strings of all possible lengths excluding Null)</span></p>

<p><b>Hence, proved.</b></p>

<p><b>Property 3.</b> <i>The complement of a regular set is regular.</i></p>

<p><b>Proof</b> &minus;</p>

<p>Let us take a regular expression &minus;</p>

<p>So, <span style="padding-left:2%;">L = {&epsilon;, aa, aaaa, aaaaaa, .......} (Strings of even length including Null)</span></p>

<p>Complement of <b>L</b> is all the strings that is not in <b>L</b>.</p>

<p>So, <span style="padding-left:2%;">L’ = {a, aaa, aaaaa, .....} (Strings of odd length excluding Null)</span></p>

<p><b>Hence, proved.</b></p>

<p><b>Property 4.</b> <i>The difference of two regular set is regular.</i></p>

<p><b>Proof</b> &minus;</p>

<p>Let us take two regular expressions &minus;</p>

<p>So, <span style="padding-left:2%;">L<sub>1</sub> = {a, aa, aaa, aaaa, ....} (Strings of all possible lengths excluding Null)</span></p>

<p><b>Hence, proved.</b></p>

<p><b>Property 5.</b> <i>The reversal of a regular set is regular.</i></p>

<p><b>Proof</b> &minus;</p>

<p>We have to prove <b>L<sup>R</sup></b> is also regular if <b>L</b> is a regular set.</p>

<p>Let, <span style="padding-left:2%">L = {01, 10, 11, 10}</span></p>

<p><b>Hence, proved.</b></p>

<p><b>Property 6.</b> <i>The closure of a regular set is regular.</i></p>

<p><b>Proof</b> &minus;</p>

<p>i.e.,<span style="padding-left:2%;"> RE (L) = a (aa)*</span></p>

<p>RE (L*) = a (a)*</p>

<p><b>Hence, proved.</b></p>

<p><b>Property 7.</b> <i>The concatenation of two regular sets is regular.</i></p>

<p><b>Proof &minus;</b></p>

<p>Let <span style="padding-left:4%">RE<sub>1</sub> = (0+1)*0 and RE<sub>2</sub> = 01(0+1)*</span></p>

<p>Here,<span style="padding-left:2%"> L<sub>1</sub> = {0, 00, 10, 000, 010, ......} <span style="padding-left:5%;">(Set of strings ending in 0)</span></span></p>

<p>and <span style="padding-left:4%">L<sub>2</sub> = {01, 010,011,.....} <span style="padding-left:15%;">(Set of strings beginning with 01)</span></span></p>

<p>Then,<span style="padding-left:2%"> L<sub>1</sub> L<sub>2</sub> = {001,0010,0011,0001,00010,00011,1001,10010,.............}</span></p>

<p>Set of strings containing 001 as a substring which can be represented by an RE &minus; (0 + 1)*001(0 + 1)*</p>

<p>Hence, proved.</p>

<h2>Identities Related to Regular Expressions</h2>

<p>Given R, P, L, Q as regular expressions, the following identities hold &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Arden's Theorem</title>

<h1>Arden's Theorem</h1>

<p>In order to find out a regular expression of a Finite Automaton, we use Arden’s Theorem along with the properties of regular expressions.</p>

<p><b><i>Statement</i></b> &minus;</p>

<p><b>Proof</b> &minus;</p>

<p>When we put the value of <b>R</b> recursively again and again, we get the following equation &minus;</p>

<p>Hence, proved.</p>

<h2>Assumptions for Applying Arden’s Theorem</h2>

<h3>Method</h3>

<p><b>Step 1</b> &minus; Create equations as the following form for all the states of the DFA having n states with initial state q<sub>1</sub>.</p>

<p><b>R<sub>ij</sub></b> represents the set of labels of edges from <b>q<sub>i</sub></b> to <b>q<sub>j</sub></b>, if no such edge exists, then <b>R<sub>ij</sub> = &empty;</b></p>

<p><b>Step 2</b> &minus; Solve these equations to get the equation for the final state in terms of <b>R<sub>ij</sub></b></p>

<p><b>Problem</b></p>

<p>Construct a regular expression corresponding to the automata given below &minus;</p>

<p><b>Solution</b> &minus;</p>

<p>Here the initial state is <b>q<sub>2</sub></b> and the final state is <b>q<sub>1</sub></b>.</p>

<p>The equations for the three states q1, q2, and q3 are as follows &minus;</p>

<p>Now, we will solve these three equations &minus;</p>

<p>Hence, the regular expression is (a + b(b + ab)*aa)*.</p>

<p><b>Problem</b></p>

<p>Construct a regular expression corresponding to the automata given below &minus;</p>

<p><b>Solution</b> &minus;</p>

<p>Here the initial state is q<sub>1</sub> and the final state is q<sub>2</sub></p>

<p>Now we write down the equations &minus;</p>

<p>Now, we will solve these three equations &minus;</p>

<p>So, <span style="padding-left:4%;">q<sub>1</sub> = 0*</span></p>

<p>So, <span style="padding-left:4%;">q<sub>2</sub> = 0*1(0)* [By Arden’s theorem]</span></p>

<p>Hence, the regular expression is 0*10*.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Construction of an FA from an RE</title>

<h1>Construction of an FA from an RE</h1>

<p>We can use Thompson's Construction to find out a Finite Automaton from a Regular Expression. We will reduce the regular expression into smallest regular expressions and converting these to NFA and finally to DFA.</p>

<p>Some basic RA expressions are the following &minus;</p>

<p><b><i>Case 1</i></b> &minus; For a regular expression ‘a’, we can construct the following FA &minus;</p>

<p><b><i>Case 2</i></b> &minus; For a regular expression ‘ab’, we can construct the following FA &minus;</p>

<p><b><i>Case 3</i></b> &minus; For a regular expression (a+b), we can construct the following FA &minus;</p>

<p><b><i>Case 4</i></b> &minus; For a regular expression (a+b)*, we can construct the following FA &minus;</p>

<h3>Method</h3>

<p><b>Step 1</b> <span style="padding-left:3%;">Construct an NFA with Null moves from the given regular expression.</span></p>

<p><b>Step 2</b> <span style="padding-left:3%;">Remove Null transition from the NFA and convert it into its equivalent DFA.</span></p>

<p><b>Problem</b></p>

<p>Convert the following RA into its equivalent DFA &minus; 1 (0 + 1)* 0</p>

<p><b><i>Solution</i></b></p>

<p>We will concatenate three expressions "1", "(0 + 1)*" and "0"</p>

<p>Now we will remove the <b>&epsilon;</b> transitions. After we remove the <b>&epsilon;</b> transitions from the NDFA, we get the following &minus;</p>

<p>It is an NDFA corresponding to the RE &minus; 1 (0 + 1)* 0. If you want to convert it into a DFA, simply apply the method of converting NDFA to DFA discussed in Chapter 1.</p>

<h2>Finite Automata with Null Moves (NFA-&epsilon;)</h2>

<p>A Finite Automaton with null moves (FA-&epsilon;) does transit not only after giving input from the alphabet set but also without any input symbol. This transition without input is called a <b>null move</b>.</p>

<p>An NFA-&epsilon; is represented formally by a 5-tuple (Q, &sum;, &delta;, q<sub>0</sub>, F), consisting of</p>

<p><b>Q</b> &minus; a finite set of states</p>

<p><b>&sum;</b> &minus; a finite set of input symbols</p>

<p><b>&delta;</b> &minus; a transition function δ : Q &times; (&sum; &cup; {&epsilon;}) &rarr; 2<sup>Q</sup></p>

<p><b>q<sub>0</sub></b> &minus; an initial state q<sub>0</sub> &isin; Q</p>

<p><b>F</b> &minus; a set of final state/states of Q (F&sube;Q).</p>

<p>The above <b>(FA-&epsilon;)</b> accepts a string set &minus; {0, 1, 01}</p>

<h2>Removal of Null Moves from Finite Automata</h2>

<p>If in an NDFA, there is  ϵ-move between vertex X to vertex Y, we can remove it using the following steps &minus;</p>

<p><b>Problem</b></p>

<p>Convert the following NFA-&epsilon; to NFA without Null move.</p>

<p><b><i>Solution</i></b></p>

<p><b>Step 1</b> &minus;</p>

<p><b>Step 2</b> &minus;</p>

<p><b>Step 3</b> &minus;</p>

<p><b>Step 4</b> &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Pumping Lemma For Regular Grammars</title>

<h1>Pumping Lemma For Regular Grammars</h1>

<h3>Theorem</h3>

<p>Let L be a regular language. Then there exists a constant <b>‘c’</b> such that for every string <b>w</b> in <b>L</b> &minus;</p>

<p>We can break <b>w</b> into three strings, <b>w = xyz</b>, such that &minus;</p>

<h2>Applications of Pumping Lemma</h2>

<p>Pumping Lemma is to be applied to show that certain languages are not regular. It should never be used to show a language is regular.</p>

<p>If <b>L</b> is regular, it satisfies Pumping Lemma.</p>

<p>If <b>L</b> does not satisfy Pumping Lemma, it is non-regular.</p>

<h2>Method to prove that a language L is not regular</h2>

<p>At first, we have to assume that <b>L</b> is regular.</p>

<p>So, the pumping lemma should hold for <b>L</b>.</p>

<p>Use the pumping lemma to obtain a contradiction &minus;</p>

<p>Select <b>w</b> such that <b>|w| &ge; c</b></p>

<p>Select <b>y</b> such that <b>|y| &ge; 1</b></p>

<p>Select <b>x</b> such that <b>|xy| &le; c</b></p>

<p>Assign the remaining string to <b>z.</b></p>

<p>Select <b>k</b> such that the resulting string is not in <b>L.</b></p>

<p><b>Hence L is not regular.</b></p>

<p><b>Problem</b></p>

<p>Prove that <b>L = {a<sup>i</sup>b<sup>i</sup> | i &ge; 0}</b> is not regular.</p>

<p><b><i>Solution</i></b> &minus;</p>

<p>At first, we assume that <b>L</b> is regular and n is the number of states.</p>

<p>Let w = <i>a<sup>n</sup>b<sup>n</sup></i>. Thus |w| = 2n &ge; n.</p>

<p>By pumping lemma, let w = xyz, where |xy| &le; n.</p>

<p>Let x = a<sup>p</sup>, y = a<sup>q</sup>, and z = a<sup>r</sup>b<sup>n</sup>, where p + q + r = n, p &ne; 0, q &ne; 0, r &ne; 0. Thus |y| &ne; 0.</p>

<p>Let k = 2. Then xy<sup>2</sup>z = a<sup>p</sup>a<sup>2q</sup>a<sup>r</sup>b<sup>n</sup>.</p>

<p>Number of as = (p + 2q + r) = (p + q + r) + q = n + q</p>

<p>Hence, xy<sup>2</sup>z = a<sup>n+q</sup> b<sup>n</sup>. Since q &ne; 0, xy<sup>2</sup>z is not of the form a<sup>n</sup>b<sup>n</sup>.</p>

<p>Thus, xy<sup>2</sup>z is not in L. Hence L is not regular.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>DFA Complement</title>

<h1>DFA Complement</h1>

<p>If (Q, &sum;, &delta;, q<sub>0</sub>, F) be a DFA that accepts a language L, then the complement of the DFA can be obtained by swapping its accepting states with its non-accepting states and vice versa.</p>

<p>We will take an example and elaborate this below &minus;</p>

<p>This DFA accepts the language</p>

<p>over the alphabet</p>

<p>So, RE = a<sup>+</sup>.</p>

<p>Now we will swap its accepting states with its non-accepting states and vice versa and will get the following &minus;</p>

<p>This DFA accepts the language</p>

<p>over the alphabet</p>

<p><b>Note</b> &minus; If we want to complement an NFA, we have to first convert it to DFA and then have to swap states as in the previous method.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Context-Free Grammar Introduction</title>

<h1>Context-Free Grammar Introduction</h1>

<p><b><i>Definition</i></b> &minus; A context-free grammar (CFG) consisting of a finite set of grammar rules is a quadruple <b>(N, T, P, S)</b> where</p>

<p><b>N</b> is a set of non-terminal symbols.</p>

<p><b>T</b> is a set of terminals where <b>N &cap; T = NULL.</b></p>

<p><b>P</b> is a set of rules, <b>P: N &rarr; (N &cup; T)*</b>, i.e., the left-hand side of the production rule <b>P</b> does have any right context or left context.</p>

<p><b>S</b> is the start symbol.</p>

<p><b>Example</b></p>

<h2>Generation of Derivation Tree</h2>

<p>A derivation tree or parse tree is an ordered rooted tree that graphically represents the semantic information a string derived from a context-free grammar.</p>

<h3>Representation Technique</h3>

<p><b>Root vertex</b> &minus; Must be labeled by the start symbol.</p>

<p><b>Vertex</b> &minus; Labeled by a non-terminal symbol.</p>

<p><b>Leaves</b> &minus; Labeled by a terminal symbol or &epsilon;.</p>

<p>If S &rarr; x<sub>1</sub>x<sub>2</sub> …… x<sub>n</sub> is a production rule in a CFG, then the parse tree / derivation tree will be as follows &minus;</p>

<p>There are two different approaches to draw a derivation tree &minus;</p>

<p><b>Top-down Approach &minus;</b></p>

<p>Starts with the starting symbol <b>S</b></p>

<p>Goes down to tree leaves using productions</p>

<p><b>Bottom-up Approach &minus;</b></p>

<p>Starts from tree leaves</p>

<p>Proceeds upward to the root which is the starting symbol <b>S</b></p>

<h3>Derivation or Yield of a Tree</h3>

<p>The derivation or the yield of a parse tree is the final string obtained by concatenating the labels of the leaves of the tree from left to right, ignoring the Nulls. However, if all the leaves are Null, derivation is Null.</p>

<p><b>Example</b></p>

<p>Let a CFG {N,T,P,S} be</p>

<p>One derivation from the above CFG is “abaabb”</p>

<h3>Sentential Form and Partial Derivation Tree</h3>

<p>A partial derivation tree is a sub-tree of a derivation tree/parse tree such that either all of its children are in the sub-tree or none of them are in the sub-tree.</p>

<p><b>Example</b></p>

<p>If in any CFG the productions are &minus;</p>

<p>the partial derivation tree can be the following &minus;</p>

<p>If a partial derivation tree contains the root S, it is called a <b>sentential form</b>. The above sub-tree is also in sentential form.</p>

<h3>Leftmost and Rightmost Derivation of a String</h3>

<p><b>Leftmost derivation</b> &minus; A leftmost derivation is obtained by applying production to the leftmost variable in each step.</p>

<p><b>Rightmost derivation</b> &minus; A rightmost derivation is obtained by applying production to the rightmost variable in each step.</p>

<p><b>Example</b></p>

<p>Let any set of production rules in a CFG be</p>

<p>over an alphabet {a}.</p>

<p>The leftmost derivation for the string <b>"a+a*a"</b> may be &minus;</p>

<p>The stepwise derivation of the above string is shown as below &minus;</p>

<p>The rightmost derivation for the above string <b>"a+a*a"</b> may be &minus;</p>

<p>The stepwise derivation of the above string is shown as below &minus;</p>

<h2>Left and Right Recursive Grammars</h2>

<p>In a context-free grammar <b>G</b>, if there is a production in the form <b>X &rarr; Xa</b> where <b>X</b> is a non-terminal and <b>‘a’</b> is a string of terminals, it is called a <b>left recursive production</b>. The grammar having a left recursive production is called a <b>left recursive grammar</b>.</p>

<p>And if in a context-free grammar <b>G</b>, if there is a production is in the form <b>X &rarr; aX</b> where <b>X</b> is a non-terminal and <b>‘a’</b> is a string of terminals, it is called a <b>right recursive production</b>. The grammar having a right recursive production is called a <b>right recursive grammar</b>.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Ambiguity in Context-Free Grammars</title>

<h1>Ambiguity in Context-Free Grammars</h1>

<p>If a context free grammar <b>G</b> has more than one derivation tree for some string <b>w &isin; L(G)</b>, it is called an <b>ambiguous grammar</b>. There exist multiple right-most or left-most derivations for some string generated from that grammar.</p>

<h2>Problem</h2>

<p>Check whether the grammar G with production rules &minus;</p>

<p>is ambiguous or not.</p>

<h2>Solution</h2>

<p>Let’s find out the derivation tree for the string "a+a*a". It has two leftmost derivations.</p>

<p><b>Derivation 1</b> &minus; <span style="padding-left:3%;">X &rarr; X+X &rarr; a +X &rarr; a+ X*X &rarr; a+a*X &rarr; a+a*a</span></p>

<p><b>Parse tree 1</b> &minus;</p>

<p><b>Derivation 2</b> &minus; <span style="padding-left:3%;">X &rarr; X*X &rarr; X+X*X &rarr; a+ X*X &rarr; a+a*X &rarr; a+a*a</span></p>

<p><b>Parse tree 2</b> &minus;</p>

<p>Since there are two parse trees for a single string "a+a*a", the grammar <b>G</b> is ambiguous.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>CFL Closure Property</title>

<h1>CFL Closure Property</h1>

<p>Context-free languages are <b>closed</b> under &minus;</p>

<h2>Union</h2>

<p>Let L<sub>1</sub> and L<sub>2</sub> be two context free languages. Then L<sub>1</sub> &cup; L<sub>2</sub> is also context free.</p>

<h3>Example</h3>

<p>Let L<sub>1</sub> = { a<sup>n</sup>b<sup>n</sup> , n &gt; 0}. Corresponding grammar G<sub>1</sub> will have P: S1 &rarr; aAb|ab</p>

<p>Let L<sub>2</sub> = { c<sup>m</sup>d<sup>m</sup> , m &ge; 0}. Corresponding grammar G<sub>2</sub> will have P: S2 &rarr; cBb| &epsilon;</p>

<p>Union of L<sub>1</sub> and L<sub>2</sub>, L = L<sub>1</sub> &cup; L<sub>2</sub> = { a<sup>n</sup>b<sup>n</sup> } &cup; { c<sup>m</sup>d<sup>m</sup> }</p>

<p>The corresponding grammar G will have the additional production S &rarr; S1 | S2</p>

<h2>Concatenation</h2>

<p>If L<sub>1</sub> and L<sub>2</sub> are context free languages, then L<sub>1</sub>L<sub>2</sub> is also context free.</p>

<h3>Example</h3>

<p>Union of the languages L<sub>1</sub> and L<sub>2</sub>, L = L<sub>1</sub>L<sub>2</sub> = { a<sup>n</sup>b<sup>n</sup>c<sup>m</sup>d<sup>m</sup> }</p>

<p>The corresponding grammar G will have the additional production S &rarr; S1 S2</p>

<h2>Kleene Star</h2>

<p>If L is a context free language, then L* is also context free.</p>

<h3>Example</h3>

<p>Let L = { a<sup>n</sup>b<sup>n</sup> , n &ge; 0}. Corresponding grammar G will have P: S &rarr; aAb| &epsilon;</p>

<p>Kleene Star L<sub>1</sub> = { a<sup>n</sup>b<sup>n </sup>}*</p>

<p>The corresponding grammar G<sub>1</sub> will have additional productions S1 &rarr; SS<sub>1</sub> | &epsilon;</p>

<p>Context-free languages are <b>not closed</b> under &minus;</p>

<p><b>Intersection</b> &minus; If L1 and L2 are context free languages, then L1 &cap; L2 is not necessarily context free.</p>

<p><b>Intersection with Regular Language</b> &minus; If L1 is a regular language and L2 is a context free language, then L1 &cap; L2 is a context free language.</p>

<p><b>Complement</b> &minus; If L1 is a context free language, then L1’ may not be context free.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>CFG Simplification</title>

<h1>CFG Simplification</h1>

<p>In a CFG, it may happen that all the production rules and symbols are not needed for the derivation of strings. Besides, there may be some null productions and unit productions. Elimination of these productions and symbols is called <b>simplification of CFGs</b>. Simplification essentially comprises of the following steps &minus;</p>

<h2>Reduction of CFG</h2>

<p>CFGs are reduced in two phases &minus;</p>

<p><b>Phase 1</b> &minus; Derivation of an equivalent grammar, <b>G’</b>, from the CFG, <b>G</b>, such that each variable derives some terminal string.</p>

<p><b>Phase 2</b> &minus; Derivation of an equivalent grammar, <b>G”</b>, from the CFG, <b>G’</b>, such that each symbol appears in a sentential form.</p>

<h3>Problem</h3>

<p>Find a reduced grammar equivalent to the grammar G, having production rules, P: S &rarr; AC | B, A &rarr; a, C &rarr; c | BC, E &rarr; aA | e</p>

<h3>Solution</h3>

<p><b>Phase 1</b> &minus;</p>

<p><b>Phase 2</b> &minus;</p>

<h2>Removal of Unit Productions</h2>

<p>Any production rule in the form A &rarr; B where A, B &isin; Non-terminal is called <b>unit production.</b>.</p>

<h3>Removal Procedure &minus;</h3>

<p><b>Step 1</b> &minus; To remove <b>A &rarr; B</b>, add production <b>A &rarr; x</b> to the grammar rule whenever <b>B &rarr; x</b> occurs in the grammar. [x &isin; Terminal, x can be Null]</p>

<p><b>Step 2</b> &minus; Delete <b>A &rarr; B</b> from the grammar.</p>

<p><b>Step 3</b> &minus; Repeat from step 1 until all unit productions are removed.</p>

<p><b>Problem</b></p>

<p>Remove unit production from the following &minus;</p>

<p><b>Solution</b> &minus;</p>

<p>There are 3 unit productions in the grammar &minus;</p>

<p><b>At first, we will remove M &rarr; N.</b></p>

<p>As N &rarr; a, we add M &rarr; a, and M &rarr; N is removed.</p>

<p>The production set becomes</p>

<p><b>Now we will remove Z &rarr; M.</b></p>

<p>As M &rarr; a, we add Z&rarr; a, and Z &rarr; M is removed.</p>

<p>The production set becomes</p>

<p><b>Now we will remove Y &rarr; Z.</b></p>

<p>As Z &rarr; a, we add Y&rarr; a, and Y &rarr; Z is removed.</p>

<p>The production set becomes</p>

<p>Now Z, M, and N are unreachable, hence we can remove those.</p>

<p>The final CFG is unit production free &minus;</p>

<h2>Removal of Null Productions</h2>

<p>In a CFG, a non-terminal symbol <b>‘A’</b> is a nullable variable if there is a production <b>A &rarr; &epsilon;</b> or there is a derivation that starts at <b>A</b> and finally ends up with</p>

<h3>Removal Procedure</h3>

<p><b>Step 1</b> &minus; Find out nullable non-terminal variables which derive &epsilon;.</p>

<p><b>Step 2</b> &minus; For each production <b>A &rarr; a</b>, construct all productions <b>A &rarr; x</b> where <b>x</b> is obtained from <b>‘a’</b> by removing one or multiple non-terminals from Step 1.</p>

<p><b>Step 3</b> &minus; Combine the original productions with the result of step 2 and remove <b>&epsilon; - productions</b>.</p>

<p><b>Problem</b></p>

<p>Remove null production from the following &minus;</p>

<p>S &rarr; ASA | aB | b, A &rarr; B, B &rarr; b | &isin;</p>

<p><b>Solution</b> &minus;</p>

<p>There are two nullable variables &minus; <b>A</b> and <b>B</b></p>

<p><b>At first, we will remove B &rarr; &epsilon;.</b></p>

<p>After removing <b>B &rarr; &epsilon;</b>, the production set becomes &minus;</p>

<p><b>Now we will remove A &rarr; &epsilon;.</b></p>

<p>After removing <b>A &rarr; &epsilon;</b>, the production set becomes &minus;</p>

<p>This is the final production set without null transition.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Chomsky Normal Form</title>

<h1>Chomsky Normal Form</h1>

<p>A CFG is in Chomsky Normal Form if the Productions are in the following forms &minus;</p>

<p>where A, B, and C are non-terminals and <b>a</b> is terminal.</p>

<h2>Algorithm to Convert into Chomsky Normal Form &minus;</h2>

<p><b>Step 1</b> &minus; If the start symbol <b>S</b> occurs on some right side, create a new start symbol <b>S’</b> and a new production <b>S’&rarr; S</b>.</p>

<p><b>Step 2</b> &minus; Remove Null productions. (Using the Null production removal algorithm discussed earlier)</p>

<p><b>Step 3</b> &minus; Remove unit productions. (Using the Unit production removal algorithm discussed earlier)</p>

<p><b>Step 4</b> &minus; Replace each production <b>A &rarr; B<sub>1</sub>…B<sub>n</sub></b> where <b>n &gt; 2</b> with <b>A &rarr; B<sub>1</sub>C</b> where <b>C &rarr; B<sub>2</sub> …B<sub>n</sub></b>. Repeat this step for all productions having two or more symbols in the right side.</p>

<p><b>Step 5</b> &minus; If the right side of any production is in the form <b>A &rarr; aB</b> where a is a terminal and <b>A, B</b> are non-terminal, then the production is replaced by <b>A &rarr; XB</b> and <b>X &rarr; a</b>. Repeat this step for every production which is in the form <b>A &rarr; aB</b>.</p>

<h3>Problem</h3>

<p>Convert the following CFG into CNF</p>

<h3>Solution</h3>

<p><b>(1)</b> Since <b>S</b> appears in R.H.S, we add a new state <b>S<sub>0</sub></b> and <b>S<sub>0</sub>&rarr;S</b> is added to the production set and it becomes &minus;</p>

<p><b>(2)</b> Now we will remove the null productions &minus;</p>

<p>After removing B &rarr; &epsilon;, the production set becomes &minus;</p>

<p>After removing A &rarr; &isin;, the production set becomes &minus;</p>

<p><b>(3)</b> Now we will remove the unit productions.</p>

<p>After removing S &rarr; S, the production set becomes &minus;</p>

<p>After removing S<sub>0</sub>&rarr; S, the production set becomes &minus;</p>

<p>After removing A&rarr; B, the production set becomes &minus;</p>

<p>After removing A&rarr; S, the production set becomes &minus;</p>

<p><b>(4)</b> Now we will find out more than two variables in the R.H.S</p>

<p>Here, S<sub>0</sub>&rarr; ASA, S &rarr; ASA, A&rarr; ASA violates two Non-terminals in R.H.S.</p>

<p>Hence we will apply step 4 and step 5 to get the following final production set which is in CNF &minus;</p>

<p><b>(5)</b> We have to change the productions S<sub>0</sub>&rarr; aB, S&rarr; aB, A&rarr; aB</p>

<p>And the final production set becomes &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Greibach Normal Form</title>

<h1>Greibach Normal Form</h1>

<p>A CFG is in Greibach Normal Form if the Productions are in the following forms &minus;</p>

<p>where A, D<sub>1</sub>,....,D<sub>n</sub> are non-terminals and b is a terminal.</p>

<h2>Algorithm to Convert a CFG into Greibach Normal Form</h2>

<p><b>Step 1</b> &minus; If the start symbol <b>S</b> occurs on some right side, create a new start symbol <b>S’</b> and a new production <b>S’ &rarr; S</b>.</p>

<p><b>Step 2</b> &minus; Remove Null productions. (Using the Null production removal algorithm discussed earlier)</p>

<p><b>Step 3</b> &minus; Remove unit productions. (Using the Unit production removal algorithm discussed earlier)</p>

<p><b>Step 4</b> &minus; Remove all direct and indirect left-recursion.</p>

<p><b>Step 5</b> &minus; Do proper substitutions of productions to convert it into the proper form of GNF.</p>

<h3>Problem</h3>

<p>Convert the following CFG into CNF</p>

<h3>Solution</h3>

<p>Here, <b>S</b> does not appear on the right side of any production and there are no unit or null productions in the production rule set. So, we can skip Step 1 to Step 3.</p>

<p><b>Step 4</b></p>

<p>Now after replacing</p>

<p>with</p>

<p>we obtain</p>

<p>And after replacing</p>

<p>with the right side of</p>

<p>we obtain</p>

<p>Two new productions O &rarr; o and P &rarr; p are added to the production set and then we came to the final GNF as the following &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Pumping Lemma for CFG</title>

<h1>Pumping Lemma for CFG</h1>

<h2>Lemma</h2>

<p>If <b>L</b> is a context-free language, there is a pumping length <b>p</b> such that any string <b>w &isin; L</b> of length <b>&ge; p</b> can be written as <b>w = uvxyz</b>, where <b>vy &ne; &epsilon;</b>, <b>|vxy| &le; p</b>, and for all <b>i &ge; 0, uv<sup>i</sup>xy<sup>i</sup>z &isin; L</b>.</p>

<h2>Applications of Pumping Lemma</h2>

<p>Pumping lemma is used to check whether a grammar is context free or not. Let us take an example and show how it is checked.</p>

<h3>Problem</h3>

<p>Find out whether the language <b>L = {x<sup>n</sup>y<sup>n</sup>z<sup>n</sup> | n &ge; 1}</b> is context free or not.</p>

<h3>Solution</h3>

<p>Let <b>L</b> is context free. Then, <b>L</b> must satisfy pumping lemma.</p>

<p>At first, choose a number <b>n</b> of the pumping lemma. Then, take z as 0<sup>n</sup>1<sup>n</sup>2<sup>n</sup>.</p>

<p>Break <b>z</b> into <b>uvwxy,</b> where</p>

<p>Hence <b>vwx</b> cannot involve both 0s and 2s, since the last 0 and the first 2 are at least (n+1) positions apart. There are two cases &minus;</p>

<p><b>Case 1</b> &minus; <b>vwx</b> has no 2s. Then <b>vx</b> has only 0s and 1s. Then <b>uwy</b>, which would have to be in <b>L</b>, has <b>n</b> 2s, but fewer than <b>n</b> 0s or 1s.</p>

<p><b>Case 2</b> &minus; <b>vwx</b> has no 0s.</p>

<p>Here contradiction occurs.</p>

<p>Hence, <b>L</b> is not a context-free language.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Pushdown Automata Introduction</title>

<h1>Pushdown Automata Introduction</h1>

<h2>Basic Structure of PDA</h2>

<p>A pushdown automaton is a way to implement a context-free grammar in a similar way we design DFA for a regular grammar. A DFA can remember a finite amount of information, but a PDA can remember an infinite amount of information.</p>

<p>Basically a pushdown automaton is &minus;</p>

<p>A pushdown automaton has three components &minus;</p>

<p>The stack head scans the top symbol of the stack.</p>

<p>A stack does two operations &minus;</p>

<p><b>Push</b> &minus; a new symbol is added at the top.</p>

<p><b>Pop</b> &minus; the top symbol is read and removed.</p>

<p>A PDA may or may not read an input symbol, but it has to read the top of the stack in every transition.</p>

<p>A PDA can be formally described as a 7-tuple (Q, &sum;, S, &delta;, q<sub>0</sub>, I, F) &minus;</p>

<p><b>Q</b> is the finite number of states</p>

<p><b>&sum;</b> is input alphabet</p>

<p><b>S</b> is stack symbols</p>

<p><b>δ</b> is the transition function: Q &times; (&sum; &cup; {&epsilon;}) &times; S &times; Q &times; S*</p>

<p><b>q<sub>0</sub></b> is the initial state (q<sub>0</sub> &isin; Q)</p>

<p><b>I</b> is the initial stack top symbol (I &isin; S)</p>

<p><b>F</b> is a set of accepting states (F &isin; Q)</p>

<p>The following diagram shows a transition in a PDA from a state q<sub>1</sub> to state q<sub>2</sub>, labeled as a,b &rarr; c &minus;</p>

<p>This means at state <b>q<sub>1</sub></b>, if we encounter an input string <b>‘a’</b> and top symbol of the stack is <b>‘b’</b>, then we pop <b>‘b’</b>, push <b>‘c’</b> on top of the stack and move to state <b>q<sub>2</sub></b>.</p>

<h2>Terminologies Related to PDA</h2>

<h3>Instantaneous Description</h3>

<p>The instantaneous description (ID) of a PDA is represented by a triplet (q, w, s) where</p>

<p><b>q</b> is the state</p>

<p><b>w</b> is unconsumed input</p>

<p><b>s</b> is the stack contents</p>

<h3>Turnstile Notation</h3>

<p>The "turnstile" notation is used for connecting pairs of ID's that represent one or many moves of a PDA. The process of transition is denoted by the turnstile symbol "&#8866;".</p>

<p>Consider a PDA (Q, &sum;, S, &delta;, q<sub>0</sub>, I, F). A transition can be mathematically represented by the following turnstile notation &minus;</p>

<p>This implies that while taking a transition from state <b>p</b> to state <b>q</b>, the input symbol <b>‘a’</b> is consumed, and the top of the stack <b>‘T’</b> is replaced by a new string <b>‘&alpha;’</b>.</p>

<p><b>Note</b> &minus; If we want zero or more moves of a PDA, we have to use the symbol (&#8866;*) for it.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
(p, aw, T&beta;) &#8866; (q, w, &alpha;b)
</pre>

<title>Pushdown Automata Acceptance</title>

<h1>Pushdown Automata Acceptance</h1>

<p>There are two different ways to define PDA acceptability.</p>

<h2>Final State Acceptability</h2>

<p>In final state acceptability, a PDA accepts a string when, after reading the entire string, the PDA is in a final state. From the starting state, we can make moves that end up in a final state with any stack values. The stack values are irrelevant as long as we end up in a final state.</p>

<p>For a PDA (Q, &sum;, S, &delta;, q<sub>0</sub>, I, F), the language accepted by the set of final states F is &minus;</p>

<p>for any input stack string <b>x</b>.</p>

<h2>Empty Stack Acceptability</h2>

<p>Here a PDA accepts a string when, after reading the entire string, the PDA has emptied its stack.</p>

<p>For a PDA (Q, &sum;, S, &delta;, q<sub>0</sub>, I, F), the language accepted by the empty stack is &minus;</p>

<h3>Example</h3>

<p>Construct a PDA that accepts <b>L = {0<sup>n</sup> 1<sup>n</sup> | n &ge; 0}</b></p>

<h3>Solution</h3>

<p>This language accepts L = {&epsilon;, 01, 0011, 000111, ............................. }</p>

<p>Here, in this example, the number of <b>‘a’</b> and <b>‘b’</b> have to be same.</p>

<p>Initially we put a special symbol <b>‘$’</b> into the empty stack.</p>

<p>Then at state <b>q<sub>2</sub></b>, if we encounter input 0 and top is Null, we push 0 into stack. This may iterate. And if we encounter input 1 and top is 0, we pop this 0.</p>

<p>Then at state <b>q<sub>3</sub></b>, if we encounter input 1 and top is 0, we pop this 0. This may also iterate. And if we encounter input 1 and top is 0, we pop the top element.</p>

<p>If the special symbol ‘$’ is encountered at top of the stack, it is popped out and it finally goes to the accepting state q<sub>4</sub>.</p>

<h3>Example</h3>

<p>Construct a PDA that accepts L = { ww<sup>R</sup> | w = (a+b)* }</p>

<p><b>Solution</b></p>

<p>Initially we put a special symbol ‘$’ into the empty stack. At state <b>q<sub>2</sub></b>, the <b>w</b> is being read. In state <b>q<sub>3</sub></b>, each 0 or 1 is popped when it matches the input. If any other input is given, the PDA will go to a dead state. When we reach that special symbol ‘$’, we go to the accepting state <b>q<sub>4</sub></b>.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>PDA &amp; Context-Free Grammar</title>

<h1>PDA &amp; Context-Free Grammar</h1>

<p>If a grammar <b>G</b> is context-free, we can build an equivalent nondeterministic PDA which accepts the language that is produced by the context-free grammar <b>G</b>. A parser can be built for the grammar <b>G</b>.</p>

<p>Also, if <b>P</b> is a pushdown automaton, an equivalent context-free grammar G can be constructed where</p>

<p>In the next two topics, we will discuss how to convert from PDA to CFG and vice versa.</p>

<h2>Algorithm to find PDA corresponding to a given CFG</h2>

<p><b>Input</b> &minus; A CFG, G = (V, T, P, S)</p>

<p><b>Output</b> &minus; Equivalent PDA, P = (Q, &sum;, S, &delta;, q<sub>0</sub>, I, F)</p>

<p><b>Step 1</b> &minus; Convert the productions of the CFG into GNF.</p>

<p><b>Step 2</b> &minus; The PDA will have only one state {q}.</p>

<p><b>Step 3</b> &minus; The start symbol of CFG will be the start symbol in the PDA.</p>

<p><b>Step 4</b> &minus; All non-terminals of the CFG will be the stack symbols of the PDA and all the terminals of the CFG will be the input symbols of the PDA.</p>

<p><b>Step 5</b> &minus; For each production in the form <b>A &rarr; aX</b> where a is terminal and <b>A, X</b> are combination of terminal and non-terminals, make a transition <b>&delta; (q, a, A)</b>.</p>

<h3>Problem</h3>

<p>Construct a PDA from the following CFG.</p>

<p>where the productions are &minus;</p>

<h3>Solution</h3>

<p>Let the equivalent PDA,</p>

<p>where &delta; &minus;</p>

<h2>Algorithm to find CFG corresponding to a given PDA</h2>

<p><b>Input</b> &minus; A CFG, G = (V, T, P, S)</p>

<p><b>Output</b> &minus; Equivalent PDA, P = (Q, &sum;, S, &delta;, q<sub>0</sub>, I, F) such that the non- terminals of the grammar G will be {X<sub>wx</sub> | w,x &isin; Q} and the start state will be A<sub>q0,F</sub>.</p>

<p><b>Step 1</b> &minus; For every w, x, y, z &isin; Q, m &isin; S and a, b &isin; &sum;, if &delta; (w, a, &epsilon;) contains (y, m) and (z, b, m) contains (x, &epsilon;), add the production rule X<sub>wx</sub> &rarr; a X<sub>yz</sub>b in grammar G.</p>

<p><b>Step 2</b> &minus; For every w, x, y, z &isin; Q, add the production rule X<sub>wx</sub> &rarr; X<sub>wy</sub>X<sub>yx</sub> in grammar G.</p>

<p><b>Step 3</b> &minus; For w &isin; Q, add the production rule X<sub>ww</sub> &rarr; &epsilon; in grammar G.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Pushdown Automata and Parsing</title>

<h1>Pushdown Automata &amp; Parsing</h1>

<p>Parsing is used to derive a string using the production rules of a grammar. It is used to check the acceptability of a string. Compiler is used to check whether or not a string is syntactically correct. A parser takes the inputs and builds a parse tree.</p>

<p>A parser can be of two types &minus;</p>

<p><b>Top-Down Parser</b> &minus; Top-down parsing starts from the top with the start-symbol and derives a string using a parse tree.</p>

<p><b>Bottom-Up Parser</b> &minus; Bottom-up parsing starts from the bottom with the string and comes to the start symbol using a parse tree.</p>

<h2>Design of Top-Down Parser</h2>

<p>For top-down parsing, a PDA has the following four types of transitions &minus;</p>

<p>Pop the non-terminal on the left hand side of the production at the top of the stack and push its right-hand side string.</p>

<p>If the top symbol of the stack matches with the input symbol being read, pop it.</p>

<p>Push the start symbol ‘S’ into the stack.</p>

<p>If the input string is fully read and the stack is empty, go to the final state ‘F’.</p>

<h3>Example</h3>

<p>Design a top-down parser for the expression "x+y*z" for the grammar G with the following production rules &minus;</p>

<p><b><i>Solution</i></b></p>

<p>If the PDA is (Q, &sum;, S, &delta;, q<sub>0</sub>, I, F), then the top-down parsing is &minus;</p>

<h2>Design of a Bottom-Up Parser</h2>

<p>For bottom-up parsing, a PDA has the following four types of transitions &minus;</p>

<p>Push the current input symbol into the stack.</p>

<p>Replace the right-hand side of a production at the top of the stack with its left-hand side.</p>

<p>If the top of the stack element matches with the current input symbol, pop it.</p>

<p>If the input string is fully read and only if the start symbol ‘S’ remains in the stack, pop it and go to the final state ‘F’.</p>

<h3>Example</h3>

<p>Design a top-down parser for the expression "x+y*z" for the grammar G with the following production rules &minus;</p>

<p><b><i>Solution</i></b></p>

<p>If the PDA is (Q, &sum;, S, &delta;, q<sub>0</sub>, I, F), then the bottom-up parsing is &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Turing Machine Introduction</title>

<h1>Turing Machine Introduction</h1>

<p>A Turing Machine is an accepting device which accepts the languages (recursively enumerable set) generated by type 0 grammars. It was invented in 1936 by Alan Turing.</p>

<h2>Definition</h2>

<p>A Turing Machine (TM) is a mathematical model which consists of an infinite length tape divided into cells on which input is given. It consists of a head which reads the input tape. A state register stores the state of the Turing machine. After reading an input symbol, it is replaced with another symbol, its internal state is changed, and it moves from one cell to the right or left. If the TM reaches the final state, the input string is accepted, otherwise rejected.</p>

<p>A TM can be formally described as a 7-tuple (Q, X, &sum;, &delta;, q<sub>0</sub>, B, F) where &minus;</p>

<p><b>Q</b> is a finite set of states</p>

<p><b>X</b> is the tape alphabet</p>

<p><b>&sum;</b> is the input alphabet</p>

<p><b>&delta;</b> is a transition function; &delta; : Q &times; X &rarr; Q &times; X &times; {Left_shift, Right_shift}.</p>

<p><b>q<sub>0</sub></b> is the initial state</p>

<p><b>B</b> is the blank symbol</p>

<p><b>F</b> is the set of final states</p>

<h3>Comparison with the previous automaton</h3>

<p>The following table shows a comparison of how a Turing machine differs from Finite Automaton and Pushdown Automaton.</p>

<h3>Example of Turing machine</h3>

<p>Turing machine M = (Q, X, &sum;, &delta;, q<sub>0</sub>, B, F) with</p>

<p>&delta; is given by &minus;</p>

<p>Here the transition 1Rq<sub>1</sub> implies that the write symbol is 1, the tape moves right, and the next state is q<sub>1</sub>. Similarly, the transition 1Lq<sub>2</sub> implies that the write symbol is 1, the tape moves left, and the next state is q<sub>2</sub>.</p>

<h2>Time and Space Complexity of a Turing Machine</h2>

<p>For a Turing machine, the time complexity refers to the measure of the number of times the tape moves when the machine is initialized for some input symbols and the space complexity is the number of cells of the tape written.</p>

<p>Time complexity all reasonable functions &minus;</p>

<p>TM's space complexity &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Accepted Language and Decided Language</title>

<h1>Accepted Language &amp; Decided Language</h1>

<p>A TM accepts a language if it enters into a final state for any input string w. A language is recursively enumerable (generated by Type-0 grammar) if it is accepted by a Turing machine.</p>

<p>A TM decides a language if it accepts it and enters into a rejecting state for any input not in the language. A language is recursive if it is decided by a Turing machine.</p>

<p>There may be some cases where a TM does not stop. Such TM accepts the language, but it does not decide it.</p>

<h2>Designing a Turing Machine</h2>

<p>The basic guidelines of designing a Turing machine have been explained below with the help of a couple of examples.</p>

<h3>Example 1</h3>

<p>Design a TM to recognize all strings consisting of an odd number of &alpha;’s.</p>

<p><b><i>Solution</i></b></p>

<p>The Turing machine <b>M</b> can be constructed by the following moves &minus;</p>

<p>Let <b>q<sub>1</sub></b> be the initial state.</p>

<p>If <b>M</b> is in <b>q<sub>1</sub></b>; on scanning &alpha;, it enters the state <b>q<sub>2</sub></b> and writes <b>B</b> (blank).</p>

<p>If <b>M</b> is in <b>q<sub>2</sub></b>; on scanning &alpha;, it enters the state <b>q<sub>1</sub></b> and writes <b>B</b> (blank).</p>

<p>From the above moves, we can see that <b>M</b> enters the state <b>q<sub>1</sub></b> if it scans an even number of &alpha;’s, and it enters the state <b>q<sub>2</sub></b> if it scans an odd number of &alpha;’s. Hence <b>q<sub>2</sub></b> is the only accepting state.</p>

<p>Hence,</p>

<p>where &delta; is given by &minus;</p>

<h3>Example 2</h3>

<p>Design a Turing Machine that reads a string representing a binary number and erases all leading 0’s in the string. However, if the string comprises of only 0’s, it keeps one 0.</p>

<p><b><i>Solution</i></b></p>

<p>Let us assume that the input string is terminated by a blank symbol, B, at each end of the string.</p>

<p>The Turing Machine, <b>M</b>, can be constructed by the following moves &minus;</p>

<p>Let <b>q<sub>0</sub></b> be the initial state.</p>

<p>If <b>M</b> is in <b>q<sub>0</sub></b>, on reading 0, it moves right, enters the state <b>q<sub>1</sub></b> and erases 0. On reading 1, it enters the state <b>q<sub>2</sub></b> and moves right.</p>

<p>If <b>M</b> is in <b>q<sub>1</sub></b>, on reading 0, it moves right and erases 0, i.e., it replaces 0’s by B’s. On reaching the leftmost 1, it enters <b>q<sub>2</sub></b> and moves right. If it reaches B, i.e., the string comprises of only 0’s, it moves left and enters the state <b>q<sub>3</sub></b>.</p>

<p>If <b>M</b> is in <b>q<sub>2</sub></b>, on reading either 0 or 1, it moves right. On reaching B, it moves left and enters the state <b>q<sub>4</sub></b>. This validates that the string comprises only of 0’s and 1’s.</p>

<p>If <b>M</b> is in <b>q<sub>3</sub></b>, it replaces B by 0, moves left and reaches the final state <b>q<sub>f</sub></b>.</p>

<p>If <b>M</b> is in <b>q<sub>4</sub></b>, on reading either 0 or 1, it moves left. On reaching the beginning of the string, i.e., when it reads B, it reaches the final state <b>q<sub>f</sub></b>.</p>

<p>Hence,</p>

<p>where &delta; is given by &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Multi-tape Turing Machine</title>

<h1>Multi-tape Turing Machine</h1>

<p>Multi-tape Turing Machines have multiple tapes where each tape is accessed with a separate head. Each head can move independently of the other heads. Initially the input is on tape 1 and others are blank. At first, the first tape is occupied by the input and the other tapes are kept blank. Next, the machine reads consecutive symbols under its heads and the TM prints a symbol on each tape and moves its heads.</p>

<p>A Multi-tape Turing machine can be formally described as a 6-tuple (Q, X, B, &delta;, q<sub>0</sub>, F) where &minus;</p>

<p><b>Q</b> is a finite set of states</p>

<p><b>X</b> is the tape alphabet</p>

<p><b>B</b> is the blank symbol</p>

<p><b>&delta;</b> is a relation on states and symbols where</p>

<p><b>q<sub>0</sub></b> is the initial state</p>

<p><b>F</b> is the set of final states</p>

<p><b>Note</b> &minus; Every Multi-tape Turing machine has an equivalent single-tape Turing machine.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Multi-track Turing Machine</title>

<h1>Multi-track Turing Machine</h1>

<p>Multi-track Turing machines, a specific type of Multi-tape Turing machine, contain multiple tracks but just one tape head reads and writes on all tracks. Here, a single tape head reads n symbols from <b>n</b> tracks at one step. It accepts recursively enumerable languages like a normal single-track single-tape Turing Machine accepts.</p>

<p>A Multi-track Turing machine can be formally described as a 6-tuple (Q, X, &sum;, &delta;, q<sub>0</sub>, F) where &minus;</p>

<p><b>Q</b> is a finite set of states</p>

<p><b>X</b> is the tape alphabet</p>

<p><b>&sum;</b> is the input alphabet</p>

<p><b>&delta;</b> is a relation on states and symbols where</p>

<p><b>q<sub>0</sub></b> is the initial state</p>

<p><b>F</b> is the set of final states</p>

<p><b>Note</b> &minus; For every single-track Turing Machine <b>S</b>, there is an equivalent multi-track Turing Machine <b>M</b> such that <b>L(S) = L(M)</b>.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Non-Deterministic Turing Machine</title>

<h1>Non-Deterministic Turing Machine</h1>

<p>In a Non-Deterministic Turing Machine, for every state and symbol, there are a group of actions the TM can have. So, here the transitions are not deterministic. The computation of a non-deterministic Turing Machine is a tree of configurations that can be reached from the start configuration.</p>

<p>An input is accepted if there is at least one node of the tree which is an accept configuration, otherwise it is not accepted. If all branches of the computational tree halt on all inputs, the non-deterministic Turing Machine is called a <b>Decider</b> and if for some input, all branches are rejected, the input is also rejected.</p>

<p>A non-deterministic Turing machine can be formally defined as a 6-tuple (Q, X, &sum;, &delta;, q<sub>0</sub>, B, F) where &minus;</p>

<p><b>Q</b> is a finite set of states</p>

<p><b>X</b> is the tape alphabet</p>

<p><b>&sum;</b> is the input alphabet</p>

<p><b>&delta;</b> is a transition function;</p>

<p><b>q<sub>0</sub></b> is the initial state</p>

<p><b>B</b> is the blank symbol</p>

<p><b>F</b> is the set of final states</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Semi-Infinite Tape Turing Machine</title>

<h1>Semi-Infinite Tape Turing Machine</h1>

<p>A Turing Machine with a semi-infinite tape has a left end but no right end. The left end is limited with an end marker.</p>

<p>It is a two-track tape &minus;</p>

<p><b>Upper track</b> &minus; It represents the cells to the right of the initial head position.</p>

<p><b>Lower track</b> &minus; It represents the cells to the left of the initial head position in reverse order.</p>

<p>The infinite length input string is initially written on the tape in contiguous tape cells.</p>

<p>The machine starts from the initial state <b>q<sub>0</sub></b> and the head scans from the left end marker ‘End’. In each step, it reads the symbol on the tape under its head. It writes a new symbol on that tape cell and then it moves the head either into left or right one tape cell. A transition function determines the actions to be taken.</p>

<p>It has two special states called <b>accept state</b> and <b>reject state</b>. If at any point of time it enters into the accepted state, the input is accepted and if it enters into the reject state, the input is rejected by the TM. In some cases, it continues to run infinitely without being accepted or rejected for some certain input symbols.</p>

<p><b>Note</b> &minus; Turing machines with semi-infinite tape are equivalent to standard Turing machines.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Linear Bounded Automata</title>

<h1>Linear Bounded Automata</h1>

<p>A linear bounded automaton is a multi-track non-deterministic Turing machine with a tape of some bounded finite length.</p>

<p>Here,</p>

<p>The computation is restricted to the constant bounded area. The input alphabet contains two special symbols which serve as left end markers and right end markers which mean the transitions neither move to the left of the left end marker nor to the right of the right end marker of the tape.</p>

<p>A linear bounded automaton can be defined as an 8-tuple (Q, X, &sum;, q<sub>0</sub>, ML, MR, &delta;, F) where &minus;</p>

<p><b>Q</b> is a finite set of states</p>

<p><b>X</b> is the tape alphabet</p>

<p><b>&sum;</b> is the input alphabet</p>

<p><b>q<sub>0</sub></b> is the initial state</p>

<p><b>M<sub>L</sub></b> is the left end marker</p>

<p><b>M<sub>R</sub></b> is the right end marker where M<sub>R</sub> &ne;  M<sub>L</sub></p>

<p><b>&delta;</b> is a transition function which maps each pair (state, tape symbol) to (state, tape symbol, Constant ‘c’) where c can be 0 or +1 or -1</p>

<p><b>F</b> is the set of final states</p>

<p>A deterministic linear bounded automaton is always <b>context-sensitive</b> and the linear bounded automaton with empty language is <b>undecidable.</b>.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Language Decidability</title>

<h1>Language Decidability</h1>

<p>A language is called <b>Decidable</b> or <b>Recursive</b> if there is a Turing machine which accepts and halts on every input string <b>w</b>. Every decidable language is Turing-Acceptable.</p>

<p>A decision problem <b>P</b> is decidable if the language <b>L</b> of all yes instances to <b>P</b> is decidable.</p>

<p>For a decidable language, for each input string, the TM halts either at the accept or the reject state as depicted in the following diagram &minus;</p>

<h2>Example 1</h2>

<p>Find out whether the following problem is decidable or not &minus;</p>

<h3>Solution</h3>

<p><b>Hence, it is a decidable problem.</b></p>

<h2>Example 2</h2>

<p>Given a regular language <b>L</b> and string <b>w</b>, how can we check if <b>w &isin; L</b>?</p>

<h3>Solution</h3>

<p>Take the DFA that accepts <b>L</b> and check if <b>w</b> is accepted</p>

<p>Some more decidable problems are &minus;</p>

<p><b>Note</b> &minus;</p>

<p>If a language <b>L</b> is decidable, then its complement <b>L'</b> is also decidable</p>

<p>If a language is decidable, then there is an enumerator for it.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Undecidable Languages</title>

<h1>Undecidable Languages</h1>

<p>For an undecidable language, there is no Turing Machine which accepts the language and makes a decision for every input string <b>w</b> (TM can make decision for some input string though). A decision problem <b>P</b> is called “undecidable” if the language <b>L</b> of all yes instances to <b>P</b> is not decidable. Undecidable languages are not recursive languages, but sometimes, they may be recursively enumerable languages.</p>

<h2>Example</h2>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Turing Machine Halting Problem</title>

<h1>Turing Machine Halting Problem</h1>

<p><b>Input</b> &minus; A Turing machine and an input string <b>w</b>.</p>

<p><b>Problem</b> &minus; Does the Turing machine finish computing of the string <b>w</b> in a finite number of steps? The answer must be either yes or no.</p>

<p><b>Proof</b> &minus; At first, we will assume that such a Turing machine exists to solve this problem and then we will show it is contradicting itself. We will call this Turing machine as a <b>Halting machine</b> that produces a ‘yes’ or ‘no’ in a finite amount of time. If the halting machine finishes in a finite amount of time, the output comes as ‘yes’, otherwise as ‘no’. The following is the block diagram of a Halting machine &minus;</p>

<p>Now we will design an <b>inverted halting machine (HM)’</b> as &minus;</p>

<p>If <b>H</b> returns YES, then loop forever.</p>

<p>If <b>H</b> returns NO, then halt.</p>

<p>The following is the block diagram of an ‘Inverted halting machine’ &minus;</p>

<p>Further, a machine <b>(HM)<sub>2</sub></b> which input itself is constructed as follows &minus;</p>

<p>Here, we have got a contradiction. Hence, the halting problem is <b>undecidable</b>.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Rice Theorem</title>

<h1>Rice Theorem</h1>

<h2>Theorem</h2>

<p>If the following two properties hold, it is proved as undecidable &minus;</p>

<p><b>Property 1</b> &minus; If <b>M1</b> and <b>M2</b> recognize the same language, then either <b>&lt;M1&gt; <span style="padding-left:17%">&lt;M2&gt; &isin; L</b> or <b>&lt;M1&gt; &lt;M2&gt; &notin; L</b></span></p>

<p><b>Property 2</b> &minus; For some M1 and M2 such that <b>&lt;M1&gt; &isin; L</b> and <b>&lt;M2&gt; &notin; L</b></p>

<p><b>Proof</b> &minus;</p>

<p>Let there are two Turing machines <b>X<sub>1</sub></b> and <b>X<sub>2</sub></b>.</p>

<p>Let us assume <b>&lt;X<sub>1</sub>&gt; &isin; L</b> such that</p>

<p>For an input ‘w’ in a particular instant, perform the following steps &minus;</p>

<p>If <b>X</b> accepts <b>w</b>, then simulate <b>X<sub>2</sub></b> on <b>x</b>.</p>

<p>Run <b>Z</b> on input <b>&lt;W&gt;</b>.</p>

<p>If <b>Z</b> accepts <b>&lt;W&gt;</b>, Reject it; and if <b>Z</b> rejects <b>&lt;W&gt;</b>, accept it.</p>

<p>If <b>X</b> accepts <b>w</b>, then</p>

<p>If <b>M</b> does not accept w, then</p>

<p>Here the contradiction arises. Hence, it is undecidable.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Post Correspondence Problem</title>

<h1>Post Correspondence Problem</h1>

<p>The Post Correspondence Problem (PCP), introduced by Emil Post in 1946, is an undecidable decision problem. The PCP problem over an alphabet &sum; is stated as follows &minus;</p>

<p>Given the following two lists, <b>M</b> and <b>N</b> of non-empty strings over &sum; &minus;</p>

<p>We can say that there is a Post Correspondence Solution, if for some i<sub>1</sub>,i<sub>2</sub>,………… i<sub>k</sub>, where 1 &le; i<sub>j</sub> &le; n, the condition x<sub>i1</sub> …….x<sub>ik</sub> = y<sub>i1</sub> …….y<sub>ik</sub> satisfies.</p>

<h2>Example 1</h2>

<p>Find whether the lists</p>

<p>have a Post Correspondence Solution?</p>

<h3>Solution</h3>

<p>Here,</p>

<p>and <span style="padding-left:3%;"><b>y<sub>2</sub>y<sub>1</sub>y<sub>3</sub> = ‘aaabbaaa’</b></span></p>

<p>We can see that</p>

<p>Hence, the solution is <b>i = 2, j = 1, and k = 3.</b></p>

<h2>Example 2</h2>

<p>Find whether the lists <b>M = (ab, bab, bbaaa)</b> and <b>N = (a, ba, bab)</b> have a Post Correspondence Solution?</p>

<h3>Solution</h3>

<p>In this case, there is no solution because &minus;</p>

<p>Hence, it can be said that this Post Correspondence Problem is <b>undecidable</b>.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Automata Theory Quick Guide</title>

<h1>Automata Theory - Quick Guide</h1>

<h1>Automata Theory Introduction</h1>

<h2>Automata – What is it?</h2>

<p>The term "Automata" is derived from the Greek word "αὐτόματα" which means "self-acting". An automaton (Automata in plural) is an abstract self-propelled computing device which follows a predetermined sequence of operations automatically.</p>

<p>An automaton with a finite number of states is called a <b>Finite Automaton</b> (FA) or <b>Finite State Machine</b> (FSM).</p>

<h3>Formal definition of a Finite Automaton</h3>

<p>An automaton can be represented by a 5-tuple (Q, &sum;, &delta;, q<sub>0</sub>, F), where &minus;</p>

<p><b>Q</b> is a finite set of states.</p>

<p><b>&sum;</b> is a finite set of symbols, called the <b>alphabet</b> of the automaton.</p>

<p><b>&delta;</b> is the transition function.</p>

<p><b>q<sub>0</sub></b> is the initial state from where any input is processed (q<sub>0</sub> &isin; Q).</p>

<p><b>F</b> is a set of final state/states of Q (F &sube; Q).</p>

<h2>Related Terminologies </h2>

<h3>Alphabet</h3>

<p><b>Definition</b> &minus; An <b>alphabet</b> is any finite set of symbols.</p>

<p><b>Example</b> &minus; &sum; = {a, b, c, d} is an <b>alphabet set</b> where ‘a’, ‘b’, ‘c’, and ‘d’ are <b>symbols</b>.</p>

<h3>String</h3>

<p><b>Definition</b> &minus; A <b>string</b> is a finite sequence of symbols taken from &sum;.</p>

<p><b>Example</b> &minus; ‘cabcad’ is a valid string on the alphabet set &sum; = {a, b, c, d}</p>

<h3>Length of a String</h3>

<p><b>Definition</b> &minus; It is the number of symbols present in a string. (Denoted by <b>|S|</b>).</p>

<p><b>Examples</b> &minus;</p>

<p>If S = ‘cabcad’, |S|= 6</p>

<p>If |S|= 0, it is called an <b>empty string</b> (Denoted by <b>&lambda;</b> or <b>&epsilon;</b>)</p>

<h3>Kleene Star</h3>

<p><b>Definition</b> &minus; The Kleene star, <b>&sum;*</b>, is a unary operator on a set of symbols or strings, <b>&sum;</b>, that gives the infinite set of all possible strings of all possible lengths over <b>&sum;</b> including <b>&lambda;</b>.</p>

<p><b>Representation</b> &minus; &sum;* = &sum;<sub>0</sub> &cup; &sum;<sub>1</sub> &cup; &sum;<sub>2</sub> &cup;……. where &sum;<sub>p</sub> is the set of all possible strings of length p.</p>

<p><b>Example</b> &minus; If &sum; = {a, b}, &sum;* = {&lambda;, a, b, aa, ab, ba, bb,………..}</p>

<h3>Kleene Closure / Plus</h3>

<p><b>Definition</b> &minus; The set <b>&sum;<sup>+</sup></b> is the infinite set of all possible strings of all possible lengths over &sum; excluding &lambda;.</p>

<p><b>Representation</b> &minus; &sum;<sup>+</sup> = &sum;<sub>1</sub> &cup; &sum;<sub>2</sub> &cup; &sum;<sub>3</sub> &cup;…….</p>

<p><b>Example</b> &minus; If &sum; = { a, b } , &sum;<sup>+</sup> = { a, b, aa, ab, ba, bb,………..}</p>

<h3>Language</h3>

<p><b>Definition</b> &minus; A language is a subset of &sum;* for some alphabet &sum;. It can be finite or infinite.</p>

<p><b>Example</b> &minus; If the language takes all possible strings of length 2 over &sum; = {a, b}, then L = { ab, bb, ba, bb}</p>

<h1>Deterministic Finite Automaton</h1>

<p>Finite Automaton can be classified into two types &minus;</p>

<h2>Deterministic Finite Automaton (DFA)</h2>

<p>In DFA, for each input symbol, one can determine the state to which the machine will move. Hence, it is called <b>Deterministic Automaton</b>. As it has a finite number of states, the machine is called <b>Deterministic Finite Machine</b> or <b>Deterministic Finite Automaton.</b></p>

<h2>Formal Definition of a DFA</h2>

<p>A DFA can be represented by a 5-tuple (Q, &sum;, &delta;, q<sub>0</sub>, F) where &minus;</p>

<p><b>Q</b> is a finite set of states.</p>

<p><b>&sum;</b> is a finite set of symbols called the alphabet.</p>

<p><b>&delta;</b> is the transition function where &delta;: Q &times; &sum; &rarr; Q </p>

<p><b>q<sub>0</sub></b> is the initial state from where any input is processed (q<sub>0</sub> &isin; Q).</p>

<p><b>F</b> is a set of final state/states of Q (F &sube; Q).</p>

<h2>Graphical Representation of a DFA</h2>

<p>A DFA is represented by digraphs called <b>state diagram</b>.</b></p>

<h3>Example</h3>

<p>Let a deterministic finite automaton be &rarr;</p>

<p>Transition function &delta; as shown by the following table &minus;</p>

<p>Its graphical representation would be as follows &minus;</p>

<h1>Non-deterministic Finite Automaton</h1>

<p>In NDFA, for a particular input symbol, the machine can move to any combination of the states in the machine. In other words, the exact state to which the machine moves cannot be determined. Hence, it is called <b>Non-deterministic Automaton</b>. As it has finite number of states, the machine is called <b>Non-deterministic Finite Machine</b> or <b>Non-deterministic Finite Automaton</b>.</p>

<h3>Formal Definition of an NDFA</h3>

<p>An NDFA can be represented by a 5-tuple (Q, &sum;, &delta;, q<sub>0</sub>, F) where &minus;</p>

<p><b>Q</b> is a finite set of states.</p>

<p><b>&sum;</b> is a finite set of symbols called the alphabets.</p>

<p><b>&delta;</b> is the transition function where &delta;: Q &times; &sum; &rarr; 2<sup>Q</sup></p>

<p>(Here the power set of Q (2<sup>Q</sup>) has been taken because in case of NDFA, from a state, transition can occur to any combination of Q states)</p>

<p><b>q<sub>0</sub></b> is the initial state from where any input is processed (q<sub>0</sub> &isin; Q).</p>

<p><b>F</b> is a set of final state/states of Q (F &sube; Q).</p>

<h3>Graphical Representation of an NDFA: (same as DFA)</h3>

<p>An NDFA is represented by digraphs called state diagram.</p>

<p><b>Example</b></p>

<p>Let a non-deterministic finite automaton be &rarr;</p>

<p>The transition function &delta; as shown below &minus;</p>

<p>Its graphical representation would be as follows &minus;</p>

<h2>DFA vs NDFA</h2>

<p>The following table lists the differences between DFA and NDFA.</p>

<h2>Acceptors, Classifiers, and Transducers</h2>

<h3>Acceptor (Recognizer)</h3>

<p>An automaton that computes a Boolean function is called an <b>acceptor</b>. All the states of an acceptor is either accepting or rejecting the inputs given to it.</p>

<h3>Classifier</h3>

<p>A <b>classifier</b> has more than two final states and it gives a single output when it terminates.</p>

<h3>Transducer</h3>

<p>An automaton that produces outputs based on current input and/or previous state is called a <b>transducer</b>. Transducers can be of two types &minus;</p>

<p><b>Mealy Machine</b> &minus; The output depends both on the current state and the current input.</p>

<p><b>Moore Machine</b> &minus; The output depends only on the current state.</p>

<h2>Acceptability by DFA and NDFA</h2>

<p>A string is accepted by a DFA/NDFA iff the DFA/NDFA starting at the initial state ends in an accepting state (any of the final states) after reading the string wholly.</p>

<p>A string S is accepted by a DFA/NDFA (Q, &sum;, &delta;, q<sub>0</sub>, F), iff</p>

<p>The language <b>L</b> accepted by DFA/NDFA is</p>

<p>A string S′ is not accepted by a DFA/NDFA (Q, &sum;, &delta;, q<sub>0</sub>, F), iff</p>

<p>The language L′ not accepted by DFA/NDFA (Complement of accepted language L) is</p>

<p><b>Example</b></p>

<p>Let us consider the DFA shown in Figure 1.3. From the DFA, the acceptable strings can be derived.</p>

<p>Strings accepted by the above DFA: {0, 00, 11, 010, 101, ...........}</p>

<p>Strings not accepted by the above DFA: {1, 011, 111, ........}</p>

<h1>NDFA to DFA Conversion</h1>

<h2>Problem Statement</h2>

<p>Let <b>X = (Q<sub>x</sub>, &sum;, &delta;<sub>x</sub>, q<sub>0</sub>, F<sub>x</sub>)</b> be an NDFA which accepts the language L(X). We have to design an equivalent DFA <b>Y = (Q<sub>y</sub>, &sum;, &delta;<sub>y</sub>, q<sub>0</sub>, F<sub>y</sub>)</b> such that <b>L(Y) = L(X)</b>. The following procedure converts the NDFA to its equivalent DFA &minus;</p>

<h2>Algorithm</h2>

<p><b>Input</b> &minus; An NDFA</p>

<p><b>Output</b> &minus; An equivalent DFA</p>

<p><b>Step 1</b> &minus; Create state table from the given NDFA.</p>

<p><b>Step 2</b> &minus; Create a blank state table under possible input alphabets for the equivalent DFA.</p>

<p><b>Step 3</b> &minus; Mark the start state of the DFA by q0 (Same as the NDFA).</p>

<p><b>Step 4</b> &minus; Find out the combination of States {Q<sub>0</sub>, Q<sub>1</sub>,... , Q<sub>n</sub>} for each possible input alphabet.</p>

<p><b>Step 5</b> &minus; Each time we generate a new DFA state under the input alphabet columns, we have to apply step 4 again, otherwise go to step 6.</p>

<p><b>Step 6</b> &minus; The states which contain any of the final states of the NDFA are the final states of the equivalent DFA.</p>

<h2>Example</h2>

<p>Let us consider the NDFA shown in the figure below.</p>

<p>Using the above algorithm, we find its equivalent DFA. The state table of the DFA is shown in below.</p>

<p>The state diagram of the DFA is as follows &minus;</p>

<h1>DFA Minimization</h1>

<h2>DFA Minimization using Myphill-Nerode Theorem</h2>

<h3>Algorithm</h3>

<p><b>Input</b> &minus; DFA</p>

<p><b>Output</b> &minus; Minimized DFA</p>

<p><b>Step 1</b> &minus; Draw a table for all pairs of states (Q<sub>i</sub>, Q<sub>j</sub>) not necessarily connected directly [All are unmarked initially]</p>

<p><b>Step 2</b> &minus; Consider every state pair (Q<sub>i</sub>, Q<sub>j</sub>) in the DFA where Q<sub>i</sub> &isin; F and Q<sub>j</sub> &notin; F or vice versa and mark them. [Here F is the set of final states]</p>

<p><b>Step 3</b> &minus; Repeat this step until we cannot mark anymore states &minus;</p>

<p>If there is an unmarked pair (Q<sub>i</sub>, Q<sub>j</sub>), mark it if the pair {&delta; (Q<sub>i</sub>, A), &delta; (Q<sub>i</sub>, A)} is marked for some input alphabet.</p>

<p><b>Step 4</b> &minus; Combine all the unmarked pair (Q<sub>i</sub>, Q<sub>j</sub>) and make them a single state in the reduced DFA.</p>

<h3>Example</h3>

<p>Let us use Algorithm 2 to minimize the DFA shown below.</p>

<p><b>Step 1</b> &minus; We draw a table for all pair of states.</p>

<p><b>Step 2</b> &minus; We mark the state pairs.</p>

<p><b>Step 3</b> &minus; We will try to mark the state pairs, with green colored check mark, transitively. If we input 1 to state ‘a’ and ‘f’, it will go to state ‘c’ and ‘f’ respectively. (c, f) is already marked, hence we will mark pair (a, f). Now, we input 1 to state ‘b’ and ‘f’; it will go to state ‘d’ and ‘f’ respectively. (d, f) is already marked, hence we will mark pair (b, f).</p>

<p>After step 3, we have got state combinations {a, b} {c, d} {c, e} {d, e} that are unmarked.</p>

<p>We can recombine {c, d} {c, e} {d, e} into {c, d, e}</p>

<p>Hence we got two combined states as &minus; {a, b} and {c, d, e}</p>

<p>So the final minimized DFA will contain three states {f}, {a, b} and {c, d, e}</p>

<h2>DFA Minimization using Equivalence Theorem</h2>

<p>If X and Y are two states in a DFA, we can combine these two states into {X, Y} if they are not distinguishable. Two states are distinguishable, if there is at least one string S, such that one of &delta; (X, S) and &delta; (Y, S) is accepting and another is not accepting. Hence, a DFA is minimal if and only if all the states are distinguishable.</p>

<h3>Algorithm 3</h3>

<p><b>Step 1</b> &minus; All the states <b>Q</b> are divided in two partitions &minus; <b>final states</b> and <b>non-final states</b> and are denoted by <b>P<sub>0</sub></b>. All the states in a partition are 0<sup>th</sup> equivalent. Take a counter <b>k</b> and initialize it with 0.</p>

<p><b>Step 2</b> &minus; Increment k by 1. For each partition in P<sub>k</sub>, divide the states in P<sub>k</sub> into two partitions if they are k-distinguishable. Two states within this partition X and Y are k-distinguishable if there is an input <b>S</b> such that <b>&delta;(X, S)</b> and <b>&delta;(Y, S)</b> are (k-1)-distinguishable.</p>

<p><b>Step 3</b> &minus; If P<sub>k</sub> &ne; P<sub>k-1</sub>, repeat Step 2, otherwise go to Step 4.</p>

<p><b>Step 4</b> &minus; Combine k<sup>th</sup> equivalent sets and make them the new states of the reduced DFA.</p>

<h3>Example</h3>

<p>Let us consider the following DFA &minus;</p>

<p>Let us apply the above algorithm to the above DFA &minus;</p>

<p>Hence, P<sub>1</sub> = P<sub>2</sub>.</p>

<p>There are three states in the reduced DFA. The reduced DFA is as follows &minus;</p>

<h1>Moore and Mealy Machines</h1>

<p>Finite automata may have outputs corresponding to each transition. There are two types of finite state machines that generate output &minus;</p>

<h3>Mealy Machine</h3>

<p>A Mealy Machine is an FSM whose output depends on the present state as well as the present input.</p>

<p>It can be described by a 6 tuple (Q, &sum;, O, &delta;, X, q<sub>0</sub>) where &minus;</p>

<p><b>Q</b> is a finite set of states.</p>

<p><b>&sum;</b> is a finite set of symbols called the input alphabet.</p>

<p><b>O</b> is a finite set of symbols called the output alphabet.</p>

<p><b>&delta;</b> is the input transition function where &delta;: Q &times; &sum; &rarr; Q</p>

<p><b>X</b> is the output transition function where X: Q &times; &sum; &rarr; O</p>

<p><b>q<sub>0</sub></b> is the initial state from where any input is processed (q<sub>0</sub> &isin; Q).</p>

<p>The state table of a Mealy Machine is shown below &minus;</p>

<p>The state diagram of the above Mealy Machine is &minus;</p>

<h3>Moore Machine</h3>

<p>Moore machine is an FSM whose outputs depend on only the present state.</p>

<p>A Moore machine can be described by a 6 tuple (Q, &sum;, O, &delta;, X, q<sub>0</sub>) where &minus;</p>

<p><b>Q</b> is a finite set of states.</p>

<p><b>&sum;</b> is a finite set of symbols called the input alphabet.</p>

<p><b>O</b> is a finite set of symbols called the output alphabet.</p>

<p><b>&delta;</b> is the input transition function where &delta;: Q &times; &sum; &rarr; Q</p>

<p><b>X</b> is the output transition function where X: Q &rarr; O</p>

<p><b>q<sub>0</sub></b> is the initial state from where any input is processed (q<sub>0</sub> &isin; Q).</p>

<p>The state table of a Moore Machine is shown below &minus;</p>

<p>The state diagram of the above Moore Machine is &minus;</p>

<h3>Mealy Machine vs. Moore Machine</h3>

<p>The following table highlights the points that differentiate a Mealy Machine from a Moore Machine.</p>

<h2>Moore Machine to Mealy Machine</h2>

<h3>Algorithm 4</h3>

<p><b>Input</b> &minus; Moore Machine</p>

<p><b>Output</b> &minus; Mealy Machine</p>

<p><b>Step 1</b> &minus; Take a blank Mealy Machine transition table format.</p>

<p><b>Step 2</b> &minus; Copy all the Moore Machine transition states into this table format.</p>

<p><b>Step 3</b> &minus; Check the present states and their corresponding outputs in the Moore Machine state table; if for a state Q<sub>i</sub> output is m, copy it into the output columns of the Mealy Machine state table wherever Q<sub>i</sub> appears in the next state.</p>

<h3>Example</h3>

<p>Let us consider the following Moore machine &minus;</p>

<p>Now we apply Algorithm 4 to convert it to Mealy Machine.</p>

<p><b>Step 1 &amp; 2</b> &minus;</p>

<p><b>Step 3</b> &minus;</p>

<h2>Mealy Machine to Moore Machine</h2>

<h3>Algorithm 5</h3>

<p><b>Input</b> &minus; Mealy Machine</p>

<p><b>Output</b> &minus; Moore Machine</p>

<p><b>Step 1</b> &minus; Calculate the number of different outputs for each state (Q<sub>i</sub>) that are available in the state table of the Mealy machine.</p>

<p><b>Step 2</b> &minus; If all the outputs of Qi are same, copy state Q<sub>i</sub>. If it has n distinct outputs, break Q<sub>i</sub> into n states as Q<sub>in</sub> where <b>n</b> = 0, 1, 2.......</p>

<p><b>Step 3</b> &minus; If the output of the initial state is 1, insert a new initial state at the beginning which gives 0 output.</p>

<h3>Example</h3>

<p>Let us consider the following Mealy Machine &minus;</p>

<p>Here, states ‘a’ and ‘d’ give only 1 and 0 outputs respectively, so we retain states ‘a’ and ‘d’. But states ‘b’ and ‘c’ produce different outputs (1 and 0). So, we divide <b>b</b> into <b>b<sub>0</sub>, b<sub>1</sub></b> and <b>c</b> into <b>c<sub>0</sub>, c<sub>1</sub></b>.</p>

<h1>Introduction to Grammars</h1>

<p>n the literary sense of the term, grammars denote syntactical rules for conversation in natural languages. Linguistics have attempted to define grammars since the inception of natural languages like English, Sanskrit, Mandarin, etc.</p>

<p>The theory of formal languages finds its applicability extensively in the fields of Computer Science. <b>Noam Chomsky</b> gave a mathematical model of grammar in 1956 which is effective for writing computer languages.</p>

<h2>Grammar</h2>

<p>A grammar <b>G</b> can be formally written as a 4-tuple (N, T, S, P) where &minus;</p>

<p><b>N</b> or <b>V<sub><i><small>N</small></i></sub></b> is a set of variables or non-terminal symbols.</p>

<p><b>T</b> or <b>&sum;</b> is a set of Terminal symbols.</p>

<p><b>S</b> is a special variable called the Start symbol, S &isin; N</p>

<p><b>P</b> is Production rules for Terminals and Non-terminals. A production rule has the form &alpha; &rarr; &beta;, where &alpha; and &beta; are strings on V<sub><i><small>N</small></i></sub> &cup; &sum; and least one symbol of &alpha; belongs to V<sub>N</sub>.</p>

<h3>Example</h3>

<p>Grammar G1 &minus;</p>

<p>Here,</p>

<p><b>S, A,</b> and <b>B</b> are Non-terminal symbols;</p>

<p><b>a</b> and <b>b</b> are Terminal symbols</p>

<p><b>S</b> is the Start symbol, S &isin; N</p>

<p>Productions, <b>P : S &rarr; AB, A &rarr; a, B &rarr; b</b></p>

<h3>Example</h3>

<p>Grammar G2 &minus;</p>

<p>Here,</p>

<p><b>S</b> and <b>A</b> are Non-terminal symbols.</p>

<p><b>a</b> and <b>b</b> are Terminal symbols.</p>

<p><b>&epsilon;</b> is an empty string.</p>

<p><b>S</b> is the Start symbol, S &isin; N</p>

<p>Production <b>P : S &rarr; aAb, aA &rarr; aaAb, A &rarr; &epsilon;</b></p>

<h2>Derivations from a Grammar</h2>

<p>Strings may be derived from other strings using the productions in a grammar. If a grammar <b>G</b> has a production <b>&alpha; &rarr; &beta;</b>, we can say that <b>x &alpha; y</b> derives <b>x &beta; y</b> in <b>G</b>. This derivation is written as &minus;</p>

<h3>Example</h3>

<p>Let us consider the grammar &minus;</p>

<p>Some of the strings that can be derived are &minus;</p>

<h1>Language Generated by a Grammar</h1>

<p>The set of all strings that can be derived from a grammar is said to be the language generated from that grammar. A language generated by a grammar <b>G</b> is a subset formally defined by</p>

<p>If <b>L(G1) = L(G2)</b>, the Grammar <b>G1</b> is equivalent to the Grammar <b>G2</b>.</p>

<h3>Example</h3>

<p>If there is a grammar</p>

<p>Here <b>S</b> produces <b>AB</b>, and we can replace <b>A</b> by <b>a</b>, and <b>B</b> by <b>b</b>. Here, the only accepted string is <b>ab</b>, i.e.,</p>

<h3>Example</h3>

<p>Suppose we have the following grammar &minus;</p>

<p>The language generated by this grammar &minus;</p>

<h2>Construction of a Grammar Generating a Language</h2>

<p>We’ll consider some languages and convert it into a grammar G which produces those languages.</p>

<h3>Example</h3>

<p><b><i>Problem</i></b> &minus; Suppose, L (G) = {a<sup>m</sup> b<sup>n</sup> | m &ge; 0 and n &gt; 0}. We have to find out the grammar <b>G</b> which produces <b>L(G)</b>.</p>

<p><b><i>Solution</i></b></p>

<p>Since L(G) = {a<sup>m</sup> b<sup>n</sup> | m &ge; 0 and n &gt; 0}</p>

<p>the set of strings accepted can be rewritten as &minus;</p>

<p>Here, the start symbol has to take at least one ‘b’ preceded by any number of ‘a’ including null.</p>

<p>To accept the string set {b, ab, bb, aab, abb, …….}, we have taken the productions &minus;</p>

<p>Thus, we can prove every single string in L(G) is accepted by the language generated by the production set.</p>

<p>Hence the grammar &minus;</p>

<h3>Example</h3>

<p><b><i>Problem</i></b> &minus; Suppose, L (G) = {a<sup>m</sup> b<sup>n</sup> | m &gt; 0 and n &ge; 0}. We have to find out the grammar G which produces L(G).</p>

<p><b><i>Solution</i></b> &minus;</p>

<p>Since L(G) = {a<sup>m</sup> b<sup>n</sup> | m &gt; 0 and n &ge; 0}, the set of strings accepted can be rewritten as &minus;</p>

<p>Here, the start symbol has to take at least one ‘a’ followed by any number of ‘b’ including null.</p>

<p>To accept the string set {a, aa, ab, aaa, aab, abb, …….}, we have taken the productions &minus;</p>

<p>Thus, we can prove every single string in L(G) is accepted by the language generated by the production set.</p>

<p>Hence the grammar &minus;</p>

<h1>Chomsky Classification of Grammars</h1>

<p>According to Noam Chomosky, there are four types of grammars &minus; Type 0, Type 1, Type 2, and Type 3. The following table shows how they differ from each other &minus;</p>

<p>Take a look at the following illustration. It shows the scope of each type of grammar &minus;</p>

<h2>Type - 3 Grammar</h2>

<p><b>Type-3 grammars</b> generate regular languages. Type-3 grammars must have a single non-terminal on the left-hand side and a right-hand side consisting of a single terminal or single terminal followed by a single non-terminal.</p>

<p>The productions must be in the form <b>X &rarr; a or X &rarr; aY</b></p>

<p>where <span style="padding-left:2%;"><b>X, Y &isin; N</b> (Non terminal)</span></p>

<p>and <span style="padding-left:2%;"><b>a &isin; T</b> (Terminal)</span></p>

<p>The rule <b>S &rarr; &epsilon;</b> is allowed if <b>S</b> does not appear on the right side of any rule.</p>

<h3>Example</h3>

<h2>Type - 2 Grammar</h2>

<p><b>Type-2 grammars</b> generate context-free languages.</p>

<p>The productions must be in the form <b>A &rarr; γ</b></p>

<p>where <span style="padding-left:2%;"><b> A &isin; N</b> (Non terminal)</span></p>

<p>and <span style="padding-left:2%;"><b>γ &isin; (T &cup; N)*</b> (String of terminals and non-terminals).</span></p>

<p>These languages generated by these grammars are be recognized by a non-deterministic pushdown automaton.</p>

<h3>Example</h3>

<h2>Type - 1 Grammar</h2>

<p><b>Type-1 grammars</b> generate context-sensitive languages. The productions must be in the form</p>

<p>where <span style="padding-left:2%;"><b>A &isin; N</b> (Non-terminal)</span></p>

<p>and <span style="padding-left:2%;"><b>&alpha;, &beta;, γ &isin; (T &cup; N)*</b> (Strings of terminals and non-terminals)</span></p>

<p>The strings <b>&alpha;</b> and <b>&beta;</b> may be empty, but <b>γ</b> must be non-empty.</p>

<p>The rule <b>S &rarr; &epsilon;</b> is allowed if S does not appear on the right side of any rule. The languages generated by these grammars are recognized by a linear bounded automaton.</p>

<h3>Example</h3>

<h2>Type - 0 Grammar</h2>

<p><b>Type-0 grammars</b> generate recursively enumerable languages. The productions have no restrictions. They are any phase structure grammar including all formal grammars.</p>

<p>They generate the languages that are recognized by a Turing machine.</p>

<p>The productions can be in the form of <b>&alpha; &rarr; &beta;</b> where <b>&alpha;</b> is a string of terminals and nonterminals with at least one non-terminal and <b>&alpha;</b> cannot be null. <b>&beta;</b> is a string of terminals and non-terminals.</p>

<h3>Example</h3>

<h1>Regular Expressions</h1>

<p>A <b>Regular Expression</b> can be recursively defined as follows &minus;</p>

<p><b>&epsilon;</b> is a Regular Expression indicates the language containing an empty string. <b>(L (&epsilon;) = {&epsilon;})</b></p>

<p><b>&phi;</b> is a Regular Expression denoting an empty language. <b>(L (&phi;) = { })</b></p>

<p><b>x</b> is a Regular Expression where <b>L = {x}</b></p>

<p>If <b>X</b> is a Regular Expression denoting the language <b>L(X)</b> and <b>Y</b> is a Regular Expression denoting the language <b>L(Y)</b>, then</p>

<p><b>X + Y</b> is a Regular Expression corresponding to the language <b>L(X) &cup; L(Y)</b> where <b>L(X+Y) = L(X) &cup; L(Y)</b>.</p>

<p><b>X . Y</b> is a Regular Expression corresponding to the language <b>L(X) . L(Y)</b> where <b>L(X.Y) = L(X) . L(Y)</b></p>

<p><b>R*</b> is a Regular Expression corresponding to the language <b>L(R*)</b>where <b>L(R*) = (L(R))*</b></p>

<p>If we apply any of the rules several times from 1 to 5, they are Regular Expressions.</p>

<h2>Some RE Examples</h2>

<h1>Regular Sets</h1>

<p>Any set that represents the value of the Regular Expression is called a <b>Regular Set.</b></p>

<h3>Properties of Regular Sets</h3>

<p><b>Property 1</b>. <i>The union of two regular set is regular.</i></p>

<p><b>Proof</b> &minus;</p>

<p>Let us take two regular expressions</p>

<p>So, <span style="padding-left:2%">L<sub>1</sub> = {a, aaa, aaaaa,.....} (Strings of odd length excluding Null)</span></p>

<p>and  <span style="padding-left:2%">L<sub>2</sub> ={ &epsilon;, aa, aaaa, aaaaaa,.......} (Strings of even length including Null)</span></p>

<p><b>Hence, proved.</b></p>

<p><b>Property 2.</b> <i>The intersection of two regular set is regular.</i></p>

<p><b>Proof</b> &minus;</p>

<p>Let us take two regular expressions</p>

<p>So, <span style="padding-left:2%">L<sub>1</sub> = { a,aa, aaa, aaaa, ....}  (Strings of all possible lengths excluding Null)</span></p>

<p><b>Hence, proved.</b></p>

<p><b>Property 3.</b> <i>The complement of a regular set is regular.</i></p>

<p><b>Proof</b> &minus;</p>

<p>Let us take a regular expression &minus;</p>

<p>So, <span style="padding-left:2%;">L = {&epsilon;, aa, aaaa, aaaaaa, .......} (Strings of even length including Null)</span></p>

<p>Complement of <b>L</b> is all the strings that is not in <b>L</b>.</p>

<p>So, <span style="padding-left:2%;">L’ = {a, aaa, aaaaa, .....} (Strings of odd length excluding Null)</span></p>

<p><b>Hence, proved.</b></p>

<p><b>Property 4.</b> <i>The difference of two regular set is regular.</i></p>

<p><b>Proof</b> &minus;</p>

<p>Let us take two regular expressions &minus;</p>

<p>So, <span style="padding-left:2%;">L<sub>1</sub> = {a, aa, aaa, aaaa, ....} (Strings of all possible lengths excluding Null)</span></p>

<p><b>Hence, proved.</b></p>

<p><b>Property 5.</b> <i>The reversal of a regular set is regular.</i></p>

<p><b>Proof</b> &minus;</p>

<p>We have to prove <b>L<sup>R</sup></b> is also regular if <b>L</b> is a regular set.</p>

<p>Let, <span style="padding-left:2%">L = {01, 10, 11, 10}</span></p>

<p><b>Hence, proved.</b></p>

<p><b>Property 6.</b> <i>The closure of a regular set is regular.</i></p>

<p><b>Proof</b> &minus;</p>

<p>i.e.,<span style="padding-left:2%;"> RE (L) = a (aa)*</span></p>

<p>RE (L*) = a (a)*</p>

<p><b>Hence, proved.</b></p>

<p><b>Property 7.</b> <i>The concatenation of two regular sets is regular.</i></p>

<p><b>Proof &minus;</b></p>

<p>Let <span style="padding-left:4%">RE<sub>1</sub> = (0+1)*0 and RE<sub>2</sub> = 01(0+1)*</span></p>

<p>Here,<span style="padding-left:2%"> L<sub>1</sub> = {0, 00, 10, 000, 010, ......} <span style="padding-left:5%;">(Set of strings ending in 0)</span></span></p>

<p>and <span style="padding-left:4%">L<sub>2</sub> = {01, 010,011,.....} <span style="padding-left:15%;">(Set of strings beginning with 01)</span></span></p>

<p>Then,<span style="padding-left:2%"> L<sub>1</sub> L<sub>2</sub> = {001,0010,0011,0001,00010,00011,1001,10010,.............}</span></p>

<p>Set of strings containing 001 as a substring which can be represented by an RE &minus; (0 + 1)*001(0 + 1)*</p>

<p>Hence, proved.</p>

<h2>Identities Related to Regular Expressions</h2>

<p>Given R, P, L, Q as regular expressions, the following identities hold &minus;</p>

<h1>Arden's Theorem</h1>

<p>In order to find out a regular expression of a Finite Automaton, we use Arden’s Theorem along with the properties of regular expressions.</p>

<p><b><i>Statement</i></b> &minus;</p>

<p><b>Proof</b> &minus;</p>

<p>When we put the value of <b>R</b> recursively again and again, we get the following equation &minus;</p>

<p>Hence, proved.</p>

<h2>Assumptions for Applying Arden’s Theorem</h2>

<h3>Method</h3>

<p><b>Step 1</b> &minus; Create equations as the following form for all the states of the DFA having n states with initial state q<sub>1</sub>.</p>

<p><b>R<sub>ij</sub></b> represents the set of labels of edges from <b>q<sub>i</sub></b> to <b>q<sub>j</sub></b>, if no such edge exists, then <b>R<sub>ij</sub> = &empty;</b></p>

<p><b>Step 2</b> &minus; Solve these equations to get the equation for the final state in terms of <b>R<sub>ij</sub></b></p>

<p><b>Problem</b></p>

<p>Construct a regular expression corresponding to the automata given below &minus;</p>

<p><b>Solution</b> &minus;</p>

<p>Here the initial state is <b>q<sub>2</sub></b> and the final state is <b>q<sub>1</sub></b>.</p>

<p>The equations for the three states q1, q2, and q3 are as follows &minus;</p>

<p>Now, we will solve these three equations &minus;</p>

<p>Hence, the regular expression is (a + b(b + ab)*aa)*.</p>

<p><b>Problem</b></p>

<p>Construct a regular expression corresponding to the automata given below &minus;</p>

<p><b>Solution</b> &minus;</p>

<p>Here the initial state is q<sub>1</sub> and the final state is q<sub>2</sub></p>

<p>Now we write down the equations &minus;</p>

<p>Now, we will solve these three equations &minus;</p>

<p>So, <span style="padding-left:4%;">q<sub>1</sub> = 0*</span></p>

<p>So, <span style="padding-left:4%;">q<sub>2</sub> = 0*1(0)* [By Arden’s theorem]</span></p>

<p>Hence, the regular expression is 0*10*.</p>

<h1>Construction of an FA from an RE</h1>

<p>We can use Thompson's Construction to find out a Finite Automaton from a Regular Expression. We will reduce the regular expression into smallest regular expressions and converting these to NFA and finally to DFA.</p>

<p>Some basic RA expressions are the following &minus;</p>

<p><b><i>Case 1</i></b> &minus; For a regular expression ‘a’, we can construct the following FA &minus;</p>

<p><b><i>Case 2</i></b> &minus; For a regular expression ‘ab’, we can construct the following FA &minus;</p>

<p><b><i>Case 3</i></b> &minus; For a regular expression (a+b), we can construct the following FA &minus;</p>

<p><b><i>Case 4</i></b> &minus; For a regular expression (a+b)*, we can construct the following FA &minus;</p>

<h3>Method</h3>

<p><b>Step 1</b> <span style="padding-left:3%;">Construct an NFA with Null moves from the given regular expression.</span></p>

<p><b>Step 2</b> <span style="padding-left:3%;">Remove Null transition from the NFA and convert it into its equivalent DFA.</span></p>

<p><b>Problem</b></p>

<p>Convert the following RA into its equivalent DFA &minus; 1 (0 + 1)* 0</p>

<p><b><i>Solution</i></b></p>

<p>We will concatenate three expressions "1", "(0 + 1)*" and "0"</p>

<p>Now we will remove the <b>&epsilon;</b> transitions. After we remove the <b>&epsilon;</b> transitions from the NDFA, we get the following &minus;</p>

<p>It is an NDFA corresponding to the RE &minus; 1 (0 + 1)* 0. If you want to convert it into a DFA, simply apply the method of converting NDFA to DFA discussed in Chapter 1.</p>

<h2>Finite Automata with Null Moves (NFA-&epsilon;)</h2>

<p>A Finite Automaton with null moves (FA-&epsilon;) does transit not only after giving input from the alphabet set but also without any input symbol. This transition without input is called a <b>null move</b>.</p>

<p>An NFA-&epsilon; is represented formally by a 5-tuple (Q, &sum;, &delta;, q<sub>0</sub>, F), consisting of</p>

<p><b>Q</b> &minus; a finite set of states</p>

<p><b>&sum;</b> &minus; a finite set of input symbols</p>

<p><b>&delta;</b> &minus; a transition function δ : Q &times; (&sum; &cup; {&epsilon;}) &rarr; 2<sup>Q</sup></p>

<p><b>q<sub>0</sub></b> &minus; an initial state q<sub>0</sub> &isin; Q</p>

<p><b>F</b> &minus; a set of final state/states of Q (F&sube;Q).</p>

<p>The above <b>(FA-&epsilon;)</b> accepts a string set &minus; {0, 1, 01}</p>

<h2>Removal of Null Moves from Finite Automata</h2>

<p>If in an NDFA, there is  ϵ-move between vertex X to vertex Y, we can remove it using the following steps &minus;</p>

<p><b>Problem</b></p>

<p>Convert the following NFA-&epsilon; to NFA without Null move.</p>

<p><b><i>Solution</i></b></p>

<p><b>Step 1</b> &minus;</p>

<p><b>Step 2</b> &minus;</p>

<p><b>Step 3</b> &minus;</p>

<p><b>Step 4</b> &minus;</p>

<h1>Pumping Lemma For Regular Grammars</h1>

<h3>Theorem</h3>

<p>Let L be a regular language. Then there exists a constant <b>‘c’</b> such that for every string <b>w</b> in <b>L</b> &minus;</p>

<p>We can break <b>w</b> into three strings, <b>w = xyz</b>, such that &minus;</p>

<h2>Applications of Pumping Lemma</h2>

<p>Pumping Lemma is to be applied to show that certain languages are not regular. It should never be used to show a language is regular.</p>

<p>If <b>L</b> is regular, it satisfies Pumping Lemma.</p>

<p>If <b>L</b> does not satisfy Pumping Lemma, it is non-regular.</p>

<h2>Method to prove that a language L is not regular</h2>

<p>At first, we have to assume that <b>L</b> is regular.</p>

<p>So, the pumping lemma should hold for <b>L</b>.</p>

<p>Use the pumping lemma to obtain a contradiction &minus;</p>

<p>Select <b>w</b> such that <b>|w| &ge; c</b></p>

<p>Select <b>y</b> such that <b>|y| &ge; 1</b></p>

<p>Select <b>x</b> such that <b>|xy| &le; c</b></p>

<p>Assign the remaining string to <b>z.</b></p>

<p>Select <b>k</b> such that the resulting string is not in <b>L.</b></p>

<p><b>Hence L is not regular.</b></p>

<p><b>Problem</b></p>

<p>Prove that <b>L = {a<sup>i</sup>b<sup>i</sup> | i &ge; 0}</b> is not regular.</p>

<p><b><i>Solution</i></b> &minus;</p>

<p>At first, we assume that <b>L</b> is regular and n is the number of states.</p>

<p>Let w = <i>a<sup>n</sup>b<sup>n</sup></i>. Thus |w| = 2n &ge; n.</p>

<p>By pumping lemma, let w = xyz, where |xy| &le; n.</p>

<p>Let x = a<sup>p</sup>, y = a<sup>q</sup>, and z = a<sup>r</sup>b<sup>n</sup>, where p + q + r = n, p &ne; 0, q &ne; 0, r &ne; 0. Thus |y| &ne; 0.</p>

<p>Let k = 2. Then xy<sup>2</sup>z = a<sup>p</sup>a<sup>2q</sup>a<sup>r</sup>b<sup>n</sup>.</p>

<p>Number of as = (p + 2q + r) = (p + q + r) + q = n + q</p>

<p>Hence, xy<sup>2</sup>z = a<sup>n+q</sup> b<sup>n</sup>. Since q &ne; 0, xy<sup>2</sup>z is not of the form a<sup>n</sup>b<sup>n</sup>.</p>

<p>Thus, xy<sup>2</sup>z is not in L. Hence L is not regular.</p>

<h1>DFA Complement</h1>

<p>If (Q, &sum;, &delta;, q<sub>0</sub>, F) be a DFA that accepts a language L, then the complement of the DFA can be obtained by swapping its accepting states with its non-accepting states and vice versa.</p>

<p>We will take an example and elaborate this below &minus;</p>

<p>This DFA accepts the language</p>

<p>over the alphabet</p>

<p>So, RE = a<sup>+</sup>.</p>

<p>Now we will swap its accepting states with its non-accepting states and vice versa and will get the following &minus;</p>

<p>This DFA accepts the language</p>

<p>over the alphabet</p>

<p><b>Note</b> &minus; If we want to complement an NFA, we have to first convert it to DFA and then have to swap states as in the previous method.</p>

<h1>Context-Free Grammar Introduction</h1>

<p><b><i>Definition</i></b> &minus; A context-free grammar (CFG) consisting of a finite set of grammar rules is a quadruple <b>(N, T, P, S)</b> where</p>

<p><b>N</b> is a set of non-terminal symbols.</p>

<p><b>T</b> is a set of terminals where <b>N &cap; T = NULL.</b></p>

<p><b>P</b> is a set of rules, <b>P: N &rarr; (N &cup; T)*</b>, i.e., the left-hand side of the production rule <b>P</b> does have any right context or left context.</p>

<p><b>S</b> is the start symbol.</p>

<p><b>Example</b></p>

<h2>Generation of Derivation Tree</h2>

<p>A derivation tree or parse tree is an ordered rooted tree that graphically represents the semantic information a string derived from a context-free grammar.</p>

<h3>Representation Technique</h3>

<p><b>Root vertex</b> &minus; Must be labeled by the start symbol.</p>

<p><b>Vertex</b> &minus; Labeled by a non-terminal symbol.</p>

<p><b>Leaves</b> &minus; Labeled by a terminal symbol or &epsilon;.</p>

<p>If S &rarr; x<sub>1</sub>x<sub>2</sub> …… x<sub>n</sub> is a production rule in a CFG, then the parse tree / derivation tree will be as follows &minus;</p>

<p>There are two different approaches to draw a derivation tree &minus;</p>

<p><b>Top-down Approach &minus;</b></p>

<p>Starts with the starting symbol <b>S</b></p>

<p>Goes down to tree leaves using productions</p>

<p><b>Bottom-up Approach &minus;</b></p>

<p>Starts from tree leaves</p>

<p>Proceeds upward to the root which is the starting symbol <b>S</b></p>

<h3>Derivation or Yield of a Tree</h3>

<p>The derivation or the yield of a parse tree is the final string obtained by concatenating the labels of the leaves of the tree from left to right, ignoring the Nulls. However, if all the leaves are Null, derivation is Null.</p>

<p><b>Example</b></p>

<p>Let a CFG {N,T,P,S} be</p>

<p>One derivation from the above CFG is “abaabb”</p>

<h3>Sentential Form and Partial Derivation Tree</h3>

<p>A partial derivation tree is a sub-tree of a derivation tree/parse tree such that either all of its children are in the sub-tree or none of them are in the sub-tree.</p>

<p><b>Example</b></p>

<p>If in any CFG the productions are &minus;</p>

<p>the partial derivation tree can be the following &minus;</p>

<p>If a partial derivation tree contains the root S, it is called a <b>sentential form</b>. The above sub-tree is also in sentential form.</p>

<h3>Leftmost and Rightmost Derivation of a String</h3>

<p><b>Leftmost derivation</b> &minus; A leftmost derivation is obtained by applying production to the leftmost variable in each step.</p>

<p><b>Rightmost derivation</b> &minus; A rightmost derivation is obtained by applying production to the rightmost variable in each step.</p>

<p><b>Example</b></p>

<p>Let any set of production rules in a CFG be</p>

<p>over an alphabet {a}.</p>

<p>The leftmost derivation for the string <b>"a+a*a"</b> may be &minus;</p>

<p>The stepwise derivation of the above string is shown as below &minus;</p>

<p>The rightmost derivation for the above string <b>"a+a*a"</b> may be &minus;</p>

<p>The stepwise derivation of the above string is shown as below &minus;</p>

<h2>Left and Right Recursive Grammars</h2>

<p>In a context-free grammar <b>G</b>, if there is a production in the form <b>X &rarr; Xa</b> where <b>X</b> is a non-terminal and <b>‘a’</b> is a string of terminals, it is called a <b>left recursive production</b>. The grammar having a left recursive production is called a <b>left recursive grammar</b>.</p>

<p>And if in a context-free grammar <b>G</b>, if there is a production is in the form <b>X &rarr; aX</b> where <b>X</b> is a non-terminal and <b>‘a’</b> is a string of terminals, it is called a <b>right recursive production</b>. The grammar having a right recursive production is called a <b>right recursive grammar</b>.</p>

<h1>Ambiguity in Context-Free Grammars</h1>

<p>If a context free grammar <b>G</b> has more than one derivation tree for some string <b>w &isin; L(G)</b>, it is called an <b>ambiguous grammar</b>. There exist multiple right-most or left-most derivations for some string generated from that grammar.</p>

<h2>Problem</h2>

<p>Check whether the grammar G with production rules &minus;</p>

<p>is ambiguous or not.</p>

<h2>Solution</h2>

<p>Let’s find out the derivation tree for the string "a+a*a". It has two leftmost derivations.</p>

<p><b>Derivation 1</b> &minus; <span style="padding-left:3%;">X &rarr; X+X &rarr; a +X &rarr; a+ X*X &rarr; a+a*X &rarr; a+a*a</span></p>

<p><b>Parse tree 1</b> &minus;</p>

<p><b>Derivation 2</b> &minus; <span style="padding-left:3%;">X &rarr; X*X &rarr; X+X*X &rarr; a+ X*X &rarr; a+a*X &rarr; a+a*a</span></p>

<p><b>Parse tree 2</b> &minus;</p>

<p>Since there are two parse trees for a single string "a+a*a", the grammar <b>G</b> is ambiguous.</p>

<h1>CFL Closure Property</h1>

<p>Context-free languages are <b>closed</b> under &minus;</p>

<h2>Union</h2>

<p>Let L<sub>1</sub> and L<sub>2</sub> be two context free languages. Then L<sub>1</sub> &cup; L<sub>2</sub> is also context free.</p>

<h3>Example</h3>

<p>Let L<sub>1</sub> = { a<sup>n</sup>b<sup>n</sup> , n &gt; 0}. Corresponding grammar G<sub>1</sub> will have P: S1 &rarr; aAb|ab</p>

<p>Let L<sub>2</sub> = { c<sup>m</sup>d<sup>m</sup> , m &ge; 0}. Corresponding grammar G<sub>2</sub> will have P: S2 &rarr; cBb| &epsilon;</p>

<p>Union of L<sub>1</sub> and L<sub>2</sub>, L = L<sub>1</sub> &cup; L<sub>2</sub> = { a<sup>n</sup>b<sup>n</sup> } &cup; { c<sup>m</sup>d<sup>m</sup> }</p>

<p>The corresponding grammar G will have the additional production S &rarr; S1 | S2</p>

<h2>Concatenation</h2>

<p>If L<sub>1</sub> and L<sub>2</sub> are context free languages, then L<sub>1</sub>L<sub>2</sub> is also context free.</p>

<h3>Example</h3>

<p>Union of the languages L<sub>1</sub> and L<sub>2</sub>, L = L<sub>1</sub>L<sub>2</sub> = { a<sup>n</sup>b<sup>n</sup>c<sup>m</sup>d<sup>m</sup> }</p>

<p>The corresponding grammar G will have the additional production S &rarr; S1 S2</p>

<h2>Kleene Star</h2>

<p>If L is a context free language, then L* is also context free.</p>

<h3>Example</h3>

<p>Let L = { a<sup>n</sup>b<sup>n</sup> , n &ge; 0}. Corresponding grammar G will have P: S &rarr; aAb| &epsilon;</p>

<p>Kleene Star L<sub>1</sub> = { a<sup>n</sup>b<sup>n </sup>}*</p>

<p>The corresponding grammar G<sub>1</sub> will have additional productions S1 &rarr; SS<sub>1</sub> | &epsilon;</p>

<p>Context-free languages are <b>not closed</b> under &minus;</p>

<p><b>Intersection</b> &minus; If L1 and L2 are context free languages, then L1 &cap; L2 is not necessarily context free.</p>

<p><b>Intersection with Regular Language</b> &minus; If L1 is a regular language and L2 is a context free language, then L1 &cap; L2 is a context free language.</p>

<p><b>Complement</b> &minus; If L1 is a context free language, then L1’ may not be context free.</p>

<h1>CFG Simplification</h1>

<p>In a CFG, it may happen that all the production rules and symbols are not needed for the derivation of strings. Besides, there may be some null productions and unit productions. Elimination of these productions and symbols is called <b>simplification of CFGs</b>. Simplification essentially comprises of the following steps &minus;</p>

<h2>Reduction of CFG</h2>

<p>CFGs are reduced in two phases &minus;</p>

<p><b>Phase 1</b> &minus; Derivation of an equivalent grammar, <b>G’</b>, from the CFG, <b>G</b>, such that each variable derives some terminal string.</p>

<p><b>Phase 2</b> &minus; Derivation of an equivalent grammar, <b>G”</b>, from the CFG, <b>G’</b>, such that each symbol appears in a sentential form.</p>

<h3>Problem</h3>

<p>Find a reduced grammar equivalent to the grammar G, having production rules, P: S &rarr; AC | B, A &rarr; a, C &rarr; c | BC, E &rarr; aA | e</p>

<h3>Solution</h3>

<p><b>Phase 1</b> &minus;</p>

<p><b>Phase 2</b> &minus;</p>

<h2>Removal of Unit Productions</h2>

<p>Any production rule in the form A &rarr; B where A, B &isin; Non-terminal is called <b>unit production.</b>.</p>

<h3>Removal Procedure &minus;</h3>

<p><b>Step 1</b> &minus; To remove <b>A &rarr; B</b>, add production <b>A &rarr; x</b> to the grammar rule whenever <b>B &rarr; x</b> occurs in the grammar. [x &isin; Terminal, x can be Null]</p>

<p><b>Step 2</b> &minus; Delete <b>A &rarr; B</b> from the grammar.</p>

<p><b>Step 3</b> &minus; Repeat from step 1 until all unit productions are removed.</p>

<p><b>Problem</b></p>

<p>Remove unit production from the following &minus;</p>

<p><b>Solution</b> &minus;</p>

<p>There are 3 unit productions in the grammar &minus;</p>

<p><b>At first, we will remove M &rarr; N.</b></p>

<p>As N &rarr; a, we add M &rarr; a, and M &rarr; N is removed.</p>

<p>The production set becomes</p>

<p><b>Now we will remove Z &rarr; M.</b></p>

<p>As M &rarr; a, we add Z&rarr; a, and Z &rarr; M is removed.</p>

<p>The production set becomes</p>

<p><b>Now we will remove Y &rarr; Z.</b></p>

<p>As Z &rarr; a, we add Y&rarr; a, and Y &rarr; Z is removed.</p>

<p>The production set becomes</p>

<p>Now Z, M, and N are unreachable, hence we can remove those.</p>

<p>The final CFG is unit production free &minus;</p>

<h2>Removal of Null Productions</h2>

<p>In a CFG, a non-terminal symbol <b>‘A’</b> is a nullable variable if there is a production <b>A &rarr; &epsilon;</b> or there is a derivation that starts at <b>A</b> and finally ends up with</p>

<h3>Removal Procedure</h3>

<p><b>Step 1</b> &minus; Find out nullable non-terminal variables which derive &epsilon;.</p>

<p><b>Step 2</b> &minus; For each production <b>A &rarr; a</b>, construct all productions <b>A &rarr; x</b> where <b>x</b> is obtained from <b>‘a’</b> by removing one or multiple non-terminals from Step 1.</p>

<p><b>Step 3</b> &minus; Combine the original productions with the result of step 2 and remove <b>&epsilon; - productions</b>.</p>

<p><b>Problem</b></p>

<p>Remove null production from the following &minus;</p>

<p>S &rarr; ASA | aB | b, A &rarr; B, B &rarr; b | &isin;</p>

<p><b>Solution</b> &minus;</p>

<p>There are two nullable variables &minus; <b>A</b> and <b>B</b></p>

<p><b>At first, we will remove B &rarr; &epsilon;.</b></p>

<p>After removing <b>B &rarr; &epsilon;</b>, the production set becomes &minus;</p>

<p><b>Now we will remove A &rarr; &epsilon;.</b></p>

<p>After removing <b>A &rarr; &epsilon;</b>, the production set becomes &minus;</p>

<p>This is the final production set without null transition.</p>

<h1>Chomsky Normal Form</h1>

<p>A CFG is in Chomsky Normal Form if the Productions are in the following forms &minus;</p>

<p>where A, B, and C are non-terminals and <b>a</b> is terminal.</p>

<h2>Algorithm to Convert into Chomsky Normal Form &minus;</h2>

<p><b>Step 1</b> &minus; If the start symbol <b>S</b> occurs on some right side, create a new start symbol <b>S’</b> and a new production <b>S’&rarr; S</b>.</p>

<p><b>Step 2</b> &minus; Remove Null productions. (Using the Null production removal algorithm discussed earlier)</p>

<p><b>Step 3</b> &minus; Remove unit productions. (Using the Unit production removal algorithm discussed earlier)</p>

<p><b>Step 4</b> &minus; Replace each production <b>A &rarr; B<sub>1</sub>…B<sub>n</sub></b> where <b>n &gt; 2</b> with <b>A &rarr; B<sub>1</sub>C</b> where <b>C &rarr; B<sub>2</sub> …B<sub>n</sub></b>. Repeat this step for all productions having two or more symbols in the right side.</p>

<p><b>Step 5</b> &minus; If the right side of any production is in the form <b>A &rarr; aB</b> where a is a terminal and <b>A, B</b> are non-terminal, then the production is replaced by <b>A &rarr; XB</b> and <b>X &rarr; a</b>. Repeat this step for every production which is in the form <b>A &rarr; aB</b>.</p>

<h3>Problem</h3>

<p>Convert the following CFG into CNF</p>

<h3>Solution</h3>

<p><b>(1)</b> Since <b>S</b> appears in R.H.S, we add a new state <b>S<sub>0</sub></b> and <b>S<sub>0</sub>&rarr;S</b> is added to the production set and it becomes &minus;</p>

<p><b>(2)</b> Now we will remove the null productions &minus;</p>

<p>After removing B &rarr; &epsilon;, the production set becomes &minus;</p>

<p>After removing A &rarr; &isin;, the production set becomes &minus;</p>

<p><b>(3)</b> Now we will remove the unit productions.</p>

<p>After removing S &rarr; S, the production set becomes &minus;</p>

<p>After removing S<sub>0</sub>&rarr; S, the production set becomes &minus;</p>

<p>After removing A&rarr; B, the production set becomes &minus;</p>

<p>After removing A&rarr; S, the production set becomes &minus;</p>

<p><b>(4)</b> Now we will find out more than two variables in the R.H.S</p>

<p>Here, S<sub>0</sub>&rarr; ASA, S &rarr; ASA, A&rarr; ASA violates two Non-terminals in R.H.S.</p>

<p>Hence we will apply step 4 and step 5 to get the following final production set which is in CNF &minus;</p>

<p><b>(5)</b> We have to change the productions S<sub>0</sub>&rarr; aB, S&rarr; aB, A&rarr; aB</p>

<p>And the final production set becomes &minus;</p>

<h1>Greibach Normal Form</h1>

<p>A CFG is in Greibach Normal Form if the Productions are in the following forms &minus;</p>

<p>where A, D<sub>1</sub>,....,D<sub>n</sub> are non-terminals and b is a terminal.</p>

<h2>Algorithm to Convert a CFG into Greibach Normal Form</h2>

<p><b>Step 1</b> &minus; If the start symbol <b>S</b> occurs on some right side, create a new start symbol <b>S’</b> and a new production <b>S’ &rarr; S</b>.</p>

<p><b>Step 2</b> &minus; Remove Null productions. (Using the Null production removal algorithm discussed earlier)</p>

<p><b>Step 3</b> &minus; Remove unit productions. (Using the Unit production removal algorithm discussed earlier)</p>

<p><b>Step 4</b> &minus; Remove all direct and indirect left-recursion.</p>

<p><b>Step 5</b> &minus; Do proper substitutions of productions to convert it into the proper form of GNF.</p>

<h3>Problem</h3>

<p>Convert the following CFG into CNF</p>

<h3>Solution</h3>

<p>Here, <b>S</b> does not appear on the right side of any production and there are no unit or null productions in the production rule set. So, we can skip Step 1 to Step 3.</p>

<p><b>Step 4</b></p>

<p>Now after replacing</p>

<p>with</p>

<p>we obtain</p>

<p>And after replacing</p>

<p>with the right side of</p>

<p>we obtain</p>

<p>Two new productions O &rarr; o and P &rarr; p are added to the production set and then we came to the final GNF as the following &minus;</p>

<h1>Pumping Lemma for CFG</h1>

<h2>Lemma</h2>

<p>If <b>L</b> is a context-free language, there is a pumping length <b>p</b> such that any string <b>w &isin; L</b> of length <b>&ge; p</b> can be written as <b>w = uvxyz</b>, where <b>vy &ne; &epsilon;</b>, <b>|vxy| &le; p</b>, and for all <b>i &ge; 0, uv<sup>i</sup>xy<sup>i</sup>z &isin; L</b>.</p>

<h2>Applications of Pumping Lemma</h2>

<p>Pumping lemma is used to check whether a grammar is context free or not. Let us take an example and show how it is checked.</p>

<h3>Problem</h3>

<p>Find out whether the language <b>L = {x<sup>n</sup>y<sup>n</sup>z<sup>n</sup> | n &ge; 1}</b> is context free or not.</p>

<h3>Solution</h3>

<p>Let <b>L</b> is context free. Then, <b>L</b> must satisfy pumping lemma.</p>

<p>At first, choose a number <b>n</b> of the pumping lemma. Then, take z as 0<sup>n</sup>1<sup>n</sup>2<sup>n</sup>.</p>

<p>Break <b>z</b> into <b>uvwxy,</b> where</p>

<p>Hence <b>vwx</b> cannot involve both 0s and 2s, since the last 0 and the first 2 are at least (n+1) positions apart. There are two cases &minus;</p>

<p><b>Case 1</b> &minus; <b>vwx</b> has no 2s. Then <b>vx</b> has only 0s and 1s. Then <b>uwy</b>, which would have to be in <b>L</b>, has <b>n</b> 2s, but fewer than <b>n</b> 0s or 1s.</p>

<p><b>Case 2</b> &minus; <b>vwx</b> has no 0s.</p>

<p>Here contradiction occurs.</p>

<p>Hence, <b>L</b> is not a context-free language.</p>

<h1>Pushdown Automata Introduction</h1>

<h2>Basic Structure of PDA</h2>

<p>A pushdown automaton is a way to implement a context-free grammar in a similar way we design DFA for a regular grammar. A DFA can remember a finite amount of information, but a PDA can remember an infinite amount of information.</p>

<p>Basically a pushdown automaton is &minus;</p>

<p>A pushdown automaton has three components &minus;</p>

<p>The stack head scans the top symbol of the stack.</p>

<p>A stack does two operations &minus;</p>

<p><b>Push</b> &minus; a new symbol is added at the top.</p>

<p><b>Pop</b> &minus; the top symbol is read and removed.</p>

<p>A PDA may or may not read an input symbol, but it has to read the top of the stack in every transition.</p>

<p>A PDA can be formally described as a 7-tuple (Q, &sum;, S, &delta;, q<sub>0</sub>, I, F) &minus;</p>

<p><b>Q</b> is the finite number of states</p>

<p><b>&sum;</b> is input alphabet</p>

<p><b>S</b> is stack symbols</p>

<p><b>δ</b> is the transition function: Q &times; (&sum; &cup; {&epsilon;}) &times; S &times; Q &times; S*</p>

<p><b>q<sub>0</sub></b> is the initial state (q<sub>0</sub> &isin; Q)</p>

<p><b>I</b> is the initial stack top symbol (I &isin; S)</p>

<p><b>F</b> is a set of accepting states (F &isin; Q)</p>

<p>The following diagram shows a transition in a PDA from a state q<sub>1</sub> to state q<sub>2</sub>, labeled as a,b &rarr; c &minus;</p>

<p>This means at state <b>q<sub>1</sub></b>, if we encounter an input string <b>‘a’</b> and top symbol of the stack is <b>‘b’</b>, then we pop <b>‘b’</b>, push <b>‘c’</b> on top of the stack and move to state <b>q<sub>2</sub></b>.</p>

<h2>Terminologies Related to PDA</h2>

<h3>Instantaneous Description</h3>

<p>The instantaneous description (ID) of a PDA is represented by a triplet (q, w, s) where</p>

<p><b>q</b> is the state</p>

<p><b>w</b> is unconsumed input</p>

<p><b>s</b> is the stack contents</p>

<h3>Turnstile Notation</h3>

<p>The "turnstile" notation is used for connecting pairs of ID's that represent one or many moves of a PDA. The process of transition is denoted by the turnstile symbol "&#8866;".</p>

<p>Consider a PDA (Q, &sum;, S, &delta;, q<sub>0</sub>, I, F). A transition can be mathematically represented by the following turnstile notation &minus;</p>

<p>This implies that while taking a transition from state <b>p</b> to state <b>q</b>, the input symbol <b>‘a’</b> is consumed, and the top of the stack <b>‘T’</b> is replaced by a new string <b>‘&alpha;’</b>.</p>

<p><b>Note</b> &minus; If we want zero or more moves of a PDA, we have to use the symbol (&#8866;*) for it.</p>

<h1>Pushdown Automata Acceptance</h1>

<p>There are two different ways to define PDA acceptability.</p>

<h2>Final State Acceptability</h2>

<p>In final state acceptability, a PDA accepts a string when, after reading the entire string, the PDA is in a final state. From the starting state, we can make moves that end up in a final state with any stack values. The stack values are irrelevant as long as we end up in a final state.</p>

<p>For a PDA (Q, &sum;, S, &delta;, q<sub>0</sub>, I, F), the language accepted by the set of final states F is &minus;</p>

<p>for any input stack string <b>x</b>.</p>

<h2>Empty Stack Acceptability</h2>

<p>Here a PDA accepts a string when, after reading the entire string, the PDA has emptied its stack.</p>

<p>For a PDA (Q, &sum;, S, &delta;, q<sub>0</sub>, I, F), the language accepted by the empty stack is &minus;</p>

<h3>Example</h3>

<p>Construct a PDA that accepts <b>L = {0<sup>n</sup> 1<sup>n</sup> | n &ge; 0}</b></p>

<h3>Solution</h3>

<p>This language accepts L = {&epsilon;, 01, 0011, 000111, ............................. }</p>

<p>Here, in this example, the number of <b>‘a’</b> and <b>‘b’</b> have to be same.</p>

<p>Initially we put a special symbol <b>‘$’</b> into the empty stack.</p>

<p>Then at state <b>q<sub>2</sub></b>, if we encounter input 0 and top is Null, we push 0 into stack. This may iterate. And if we encounter input 1 and top is 0, we pop this 0.</p>

<p>Then at state <b>q<sub>3</sub></b>, if we encounter input 1 and top is 0, we pop this 0. This may also iterate. And if we encounter input 1 and top is 0, we pop the top element.</p>

<p>If the special symbol ‘$’ is encountered at top of the stack, it is popped out and it finally goes to the accepting state q<sub>4</sub>.</p>

<h3>Example</h3>

<p>Construct a PDA that accepts L = { ww<sup>R</sup> | w = (a+b)* }</p>

<p><b>Solution</b></p>

<p>Initially we put a special symbol ‘$’ into the empty stack. At state <b>q<sub>2</sub></b>, the <b>w</b> is being read. In state <b>q<sub>3</sub></b>, each 0 or 1 is popped when it matches the input. If any other input is given, the PDA will go to a dead state. When we reach that special symbol ‘$’, we go to the accepting state <b>q<sub>4</sub></b>.</p>

<h1>PDA &amp; Context-Free Grammar</h1>

<p>If a grammar <b>G</b> is context-free, we can build an equivalent nondeterministic PDA which accepts the language that is produced by the context-free grammar <b>G</b>. A parser can be built for the grammar <b>G</b>.</p>

<p>Also, if <b>P</b> is a pushdown automaton, an equivalent context-free grammar G can be constructed where</p>

<p>In the next two topics, we will discuss how to convert from PDA to CFG and vice versa.</p>

<h2>Algorithm to find PDA corresponding to a given CFG</h2>

<p><b>Input</b> &minus; A CFG, G = (V, T, P, S)</p>

<p><b>Output</b> &minus; Equivalent PDA, P = (Q, &sum;, S, &delta;, q<sub>0</sub>, I, F)</p>

<p><b>Step 1</b> &minus; Convert the productions of the CFG into GNF.</p>

<p><b>Step 2</b> &minus; The PDA will have only one state {q}.</p>

<p><b>Step 3</b> &minus; The start symbol of CFG will be the start symbol in the PDA.</p>

<p><b>Step 4</b> &minus; All non-terminals of the CFG will be the stack symbols of the PDA and all the terminals of the CFG will be the input symbols of the PDA.</p>

<p><b>Step 5</b> &minus; For each production in the form <b>A &rarr; aX</b> where a is terminal and <b>A, X</b> are combination of terminal and non-terminals, make a transition <b>&delta; (q, a, A)</b>.</p>

<h3>Problem</h3>

<p>Construct a PDA from the following CFG.</p>

<p>where the productions are &minus;</p>

<h3>Solution</h3>

<p>Let the equivalent PDA,</p>

<p>where &delta; &minus;</p>

<h2>Algorithm to find CFG corresponding to a given PDA</h2>

<p><b>Input</b> &minus; A CFG, G = (V, T, P, S)</p>

<p><b>Output</b> &minus; Equivalent PDA, P = (Q, &sum;, S, &delta;, q<sub>0</sub>, I, F) such that the non- terminals of the grammar G will be {X<sub>wx</sub> | w,x &isin; Q} and the start state will be A<sub>q0,F</sub>.</p>

<p><b>Step 1</b> &minus; For every w, x, y, z &isin; Q, m &isin; S and a, b &isin; &sum;, if &delta; (w, a, &epsilon;) contains (y, m) and (z, b, m) contains (x, &epsilon;), add the production rule X<sub>wx</sub> &rarr; a X<sub>yz</sub>b in grammar G.</p>

<p><b>Step 2</b> &minus; For every w, x, y, z &isin; Q, add the production rule X<sub>wx</sub> &rarr; X<sub>wy</sub>X<sub>yx</sub> in grammar G.</p>

<p><b>Step 3</b> &minus; For w &isin; Q, add the production rule X<sub>ww</sub> &rarr; &epsilon; in grammar G.</p>

<h1>Pushdown Automata &amp; Parsing</h1>

<p>Parsing is used to derive a string using the production rules of a grammar. It is used to check the acceptability of a string. Compiler is used to check whether or not a string is syntactically correct. A parser takes the inputs and builds a parse tree.</p>

<p>A parser can be of two types &minus;</p>

<p><b>Top-Down Parser</b> &minus; Top-down parsing starts from the top with the start-symbol and derives a string using a parse tree.</p>

<p><b>Bottom-Up Parser</b> &minus; Bottom-up parsing starts from the bottom with the string and comes to the start symbol using a parse tree.</p>

<h2>Design of Top-Down Parser</h2>

<p>For top-down parsing, a PDA has the following four types of transitions &minus;</p>

<p>Pop the non-terminal on the left hand side of the production at the top of the stack and push its right-hand side string.</p>

<p>If the top symbol of the stack matches with the input symbol being read, pop it.</p>

<p>Push the start symbol ‘S’ into the stack.</p>

<p>If the input string is fully read and the stack is empty, go to the final state ‘F’.</p>

<h3>Example</h3>

<p>Design a top-down parser for the expression "x+y*z" for the grammar G with the following production rules &minus;</p>

<p><b><i>Solution</i></b></p>

<p>If the PDA is (Q, &sum;, S, &delta;, q<sub>0</sub>, I, F), then the top-down parsing is &minus;</p>

<h2>Design of a Bottom-Up Parser</h2>

<p>For bottom-up parsing, a PDA has the following four types of transitions &minus;</p>

<p>Push the current input symbol into the stack.</p>

<p>Replace the right-hand side of a production at the top of the stack with its left-hand side.</p>

<p>If the top of the stack element matches with the current input symbol, pop it.</p>

<p>If the input string is fully read and only if the start symbol ‘S’ remains in the stack, pop it and go to the final state ‘F’.</p>

<h3>Example</h3>

<p>Design a top-down parser for the expression "x+y*z" for the grammar G with the following production rules &minus;</p>

<p><b><i>Solution</i></b></p>

<p>If the PDA is (Q, &sum;, S, &delta;, q<sub>0</sub>, I, F), then the bottom-up parsing is &minus;</p>

<h1>Turing Machine Introduction</h1>

<p>A Turing Machine is an accepting device which accepts the languages (recursively enumerable set) generated by type 0 grammars. It was invented in 1936 by Alan Turing.</p>

<h2>Definition</h2>

<p>A Turing Machine (TM) is a mathematical model which consists of an infinite length tape divided into cells on which input is given. It consists of a head which reads the input tape. A state register stores the state of the Turing machine. After reading an input symbol, it is replaced with another symbol, its internal state is changed, and it moves from one cell to the right or left. If the TM reaches the final state, the input string is accepted, otherwise rejected.</p>

<p>A TM can be formally described as a 7-tuple (Q, X, &sum;, &delta;, q<sub>0</sub>, B, F) where &minus;</p>

<p><b>Q</b> is a finite set of states</p>

<p><b>X</b> is the tape alphabet</p>

<p><b>&sum;</b> is the input alphabet</p>

<p><b>&delta;</b> is a transition function; &delta; : Q &times; X &rarr; Q &times; X &times; {Left_shift, Right_shift}.</p>

<p><b>q<sub>0</sub></b> is the initial state</p>

<p><b>B</b> is the blank symbol</p>

<p><b>F</b> is the set of final states</p>

<h3>Comparison with the previous automaton</h3>

<p>The following table shows a comparison of how a Turing machine differs from Finite Automaton and Pushdown Automaton.</p>

<h3>Example of Turing machine</h3>

<p>Turing machine M = (Q, X, &sum;, &delta;, q<sub>0</sub>, B, F) with</p>

<p>&delta; is given by &minus;</p>

<p>Here the transition 1Rq<sub>1</sub> implies that the write symbol is 1, the tape moves right, and the next state is q<sub>1</sub>. Similarly, the transition 1Lq<sub>2</sub> implies that the write symbol is 1, the tape moves left, and the next state is q<sub>2</sub>.</p>

<h2>Time and Space Complexity of a Turing Machine</h2>

<p>For a Turing machine, the time complexity refers to the measure of the number of times the tape moves when the machine is initialized for some input symbols and the space complexity is the number of cells of the tape written.</p>

<p>Time complexity all reasonable functions &minus;</p>

<p>TM's space complexity &minus;</p>

<h1>Accepted Language &amp; Decided Language</h1>

<p>A TM accepts a language if it enters into a final state for any input string w. A language is recursively enumerable (generated by Type-0 grammar) if it is accepted by a Turing machine.</p>

<p>A TM decides a language if it accepts it and enters into a rejecting state for any input not in the language. A language is recursive if it is decided by a Turing machine.</p>

<p>There may be some cases where a TM does not stop. Such TM accepts the language, but it does not decide it.</p>

<h2>Designing a Turing Machine</h2>

<p>The basic guidelines of designing a Turing machine have been explained below with the help of a couple of examples.</p>

<h3>Example 1</h3>

<p>Design a TM to recognize all strings consisting of an odd number of &alpha;’s.</p>

<p><b><i>Solution</i></b></p>

<p>The Turing machine <b>M</b> can be constructed by the following moves &minus;</p>

<p>Let <b>q<sub>1</sub></b> be the initial state.</p>

<p>If <b>M</b> is in <b>q<sub>1</sub></b>; on scanning &alpha;, it enters the state <b>q<sub>2</sub></b> and writes <b>B</b> (blank).</p>

<p>If <b>M</b> is in <b>q<sub>2</sub></b>; on scanning &alpha;, it enters the state <b>q<sub>1</sub></b> and writes <b>B</b> (blank).</p>

<p>From the above moves, we can see that <b>M</b> enters the state <b>q<sub>1</sub></b> if it scans an even number of &alpha;’s, and it enters the state <b>q<sub>2</sub></b> if it scans an odd number of &alpha;’s. Hence <b>q<sub>2</sub></b> is the only accepting state.</p>

<p>Hence,</p>

<p>where &delta; is given by &minus;</p>

<h3>Example 2</h3>

<p>Design a Turing Machine that reads a string representing a binary number and erases all leading 0’s in the string. However, if the string comprises of only 0’s, it keeps one 0.</p>

<p><b><i>Solution</i></b></p>

<p>Let us assume that the input string is terminated by a blank symbol, B, at each end of the string.</p>

<p>The Turing Machine, <b>M</b>, can be constructed by the following moves &minus;</p>

<p>Let <b>q<sub>0</sub></b> be the initial state.</p>

<p>If <b>M</b> is in <b>q<sub>0</sub></b>, on reading 0, it moves right, enters the state <b>q<sub>1</sub></b> and erases 0. On reading 1, it enters the state <b>q<sub>2</sub></b> and moves right.</p>

<p>If <b>M</b> is in <b>q<sub>1</sub></b>, on reading 0, it moves right and erases 0, i.e., it replaces 0’s by B’s. On reaching the leftmost 1, it enters <b>q<sub>2</sub></b> and moves right. If it reaches B, i.e., the string comprises of only 0’s, it moves left and enters the state <b>q<sub>3</sub></b>.</p>

<p>If <b>M</b> is in <b>q<sub>2</sub></b>, on reading either 0 or 1, it moves right. On reaching B, it moves left and enters the state <b>q<sub>4</sub></b>. This validates that the string comprises only of 0’s and 1’s.</p>

<p>If <b>M</b> is in <b>q<sub>3</sub></b>, it replaces B by 0, moves left and reaches the final state <b>q<sub>f</sub></b>.</p>

<p>If <b>M</b> is in <b>q<sub>4</sub></b>, on reading either 0 or 1, it moves left. On reaching the beginning of the string, i.e., when it reads B, it reaches the final state <b>q<sub>f</sub></b>.</p>

<p>Hence,</p>

<p>where &delta; is given by &minus;</p>

<h1>Multi-tape Turing Machine</h1>

<p>Multi-tape Turing Machines have multiple tapes where each tape is accessed with a separate head. Each head can move independently of the other heads. Initially the input is on tape 1 and others are blank. At first, the first tape is occupied by the input and the other tapes are kept blank. Next, the machine reads consecutive symbols under its heads and the TM prints a symbol on each tape and moves its heads.</p>

<p>A Multi-tape Turing machine can be formally described as a 6-tuple (Q, X, B, &delta;, q<sub>0</sub>, F) where &minus;</p>

<p><b>Q</b> is a finite set of states</p>

<p><b>X</b> is the tape alphabet</p>

<p><b>B</b> is the blank symbol</p>

<p><b>&delta;</b> is a relation on states and symbols where</p>

<p><b>q<sub>0</sub></b> is the initial state</p>

<p><b>F</b> is the set of final states</p>

<p><b>Note</b> &minus; Every Multi-tape Turing machine has an equivalent single-tape Turing machine.</p>

<h1>Multi-track Turing Machine</h1>

<p>Multi-track Turing machines, a specific type of Multi-tape Turing machine, contain multiple tracks but just one tape head reads and writes on all tracks. Here, a single tape head reads n symbols from <b>n</b> tracks at one step. It accepts recursively enumerable languages like a normal single-track single-tape Turing Machine accepts.</p>

<p>A Multi-track Turing machine can be formally described as a 6-tuple (Q, X, &sum;, &delta;, q<sub>0</sub>, F) where &minus;</p>

<p><b>Q</b> is a finite set of states</p>

<p><b>X</b> is the tape alphabet</p>

<p><b>&sum;</b> is the input alphabet</p>

<p><b>&delta;</b> is a relation on states and symbols where</p>

<p><b>q<sub>0</sub></b> is the initial state</p>

<p><b>F</b> is the set of final states</p>

<p><b>Note</b> &minus; For every single-track Turing Machine <b>S</b>, there is an equivalent multi-track Turing Machine <b>M</b> such that <b>L(S) = L(M)</b>.</p>

<h1>Non-Deterministic Turing Machine</h1>

<p>In a Non-Deterministic Turing Machine, for every state and symbol, there are a group of actions the TM can have. So, here the transitions are not deterministic. The computation of a non-deterministic Turing Machine is a tree of configurations that can be reached from the start configuration.</p>

<p>An input is accepted if there is at least one node of the tree which is an accept configuration, otherwise it is not accepted. If all branches of the computational tree halt on all inputs, the non-deterministic Turing Machine is called a <b>Decider</b> and if for some input, all branches are rejected, the input is also rejected.</p>

<p>A non-deterministic Turing machine can be formally defined as a 6-tuple (Q, X, &sum;, &delta;, q<sub>0</sub>, B, F) where &minus;</p>

<p><b>Q</b> is a finite set of states</p>

<p><b>X</b> is the tape alphabet</p>

<p><b>&sum;</b> is the input alphabet</p>

<p><b>&delta;</b> is a transition function;</p>

<p><b>q<sub>0</sub></b> is the initial state</p>

<p><b>B</b> is the blank symbol</p>

<p><b>F</b> is the set of final states</p>

<h1>Semi-Infinite Tape Turing Machine</h1>

<p>A Turing Machine with a semi-infinite tape has a left end but no right end. The left end is limited with an end marker.</p>

<p>It is a two-track tape &minus;</p>

<p><b>Upper track</b> &minus; It represents the cells to the right of the initial head position.</p>

<p><b>Lower track</b> &minus; It represents the cells to the left of the initial head position in reverse order.</p>

<p>The infinite length input string is initially written on the tape in contiguous tape cells.</p>

<p>The machine starts from the initial state <b>q<sub>0</sub></b> and the head scans from the left end marker ‘End’. In each step, it reads the symbol on the tape under its head. It writes a new symbol on that tape cell and then it moves the head either into left or right one tape cell. A transition function determines the actions to be taken.</p>

<p>It has two special states called <b>accept state</b> and <b>reject state</b>. If at any point of time it enters into the accepted state, the input is accepted and if it enters into the reject state, the input is rejected by the TM. In some cases, it continues to run infinitely without being accepted or rejected for some certain input symbols.</p>

<p><b>Note</b> &minus; Turing machines with semi-infinite tape are equivalent to standard Turing machines.</p>

<h1>Linear Bounded Automata</h1>

<p>A linear bounded automaton is a multi-track non-deterministic Turing machine with a tape of some bounded finite length.</p>

<p>Here,</p>

<p>The computation is restricted to the constant bounded area. The input alphabet contains two special symbols which serve as left end markers and right end markers which mean the transitions neither move to the left of the left end marker nor to the right of the right end marker of the tape.</p>

<p>A linear bounded automaton can be defined as an 8-tuple (Q, X, &sum;, q<sub>0</sub>, ML, MR, &delta;, F) where &minus;</p>

<p><b>Q</b> is a finite set of states</p>

<p><b>X</b> is the tape alphabet</p>

<p><b>&sum;</b> is the input alphabet</p>

<p><b>q<sub>0</sub></b> is the initial state</p>

<p><b>M<sub>L</sub></b> is the left end marker</p>

<p><b>M<sub>R</sub></b> is the right end marker where M<sub>R</sub> &ne;  M<sub>L</sub></p>

<p><b>&delta;</b> is a transition function which maps each pair (state, tape symbol) to (state, tape symbol, Constant ‘c’) where c can be 0 or +1 or -1</p>

<p><b>F</b> is the set of final states</p>

<p>A deterministic linear bounded automaton is always <b>context-sensitive</b> and the linear bounded automaton with empty language is <b>undecidable.</b>.</p>

<h1>Language Decidability</h1>

<p>A language is called <b>Decidable</b> or <b>Recursive</b> if there is a Turing machine which accepts and halts on every input string <b>w</b>. Every decidable language is Turing-Acceptable.</p>

<p>A decision problem <b>P</b> is decidable if the language <b>L</b> of all yes instances to <b>P</b> is decidable.</p>

<p>For a decidable language, for each input string, the TM halts either at the accept or the reject state as depicted in the following diagram &minus;</p>

<h2>Example 1</h2>

<p>Find out whether the following problem is decidable or not &minus;</p>

<h3>Solution</h3>

<p><b>Hence, it is a decidable problem.</b></p>

<h2>Example 2</h2>

<p>Given a regular language <b>L</b> and string <b>w</b>, how can we check if <b>w &isin; L</b>?</p>

<h3>Solution</h3>

<p>Take the DFA that accepts <b>L</b> and check if <b>w</b> is accepted</p>

<p>Some more decidable problems are &minus;</p>

<p><b>Note</b> &minus;</p>

<p>If a language <b>L</b> is decidable, then its complement <b>L'</b> is also decidable</p>

<p>If a language is decidable, then there is an enumerator for it.</p>

<h1>Undecidable Languages</h1>

<p>For an undecidable language, there is no Turing Machine which accepts the language and makes a decision for every input string <b>w</b> (TM can make decision for some input string though). A decision problem <b>P</b> is called “undecidable” if the language <b>L</b> of all yes instances to <b>P</b> is not decidable. Undecidable languages are not recursive languages, but sometimes, they may be recursively enumerable languages.</p>

<h2>Example</h2>

<h1>Turing Machine Halting Problem</h1>

<p><b>Input</b> &minus; A Turing machine and an input string <b>w</b>.</p>

<p><b>Problem</b> &minus; Does the Turing machine finish computing of the string <b>w</b> in a finite number of steps? The answer must be either yes or no.</p>

<p><b>Proof</b> &minus; At first, we will assume that such a Turing machine exists to solve this problem and then we will show it is contradicting itself. We will call this Turing machine as a <b>Halting machine</b> that produces a ‘yes’ or ‘no’ in a finite amount of time. If the halting machine finishes in a finite amount of time, the output comes as ‘yes’, otherwise as ‘no’. The following is the block diagram of a Halting machine &minus;</p>

<p>Now we will design an <b>inverted halting machine (HM)’</b> as &minus;</p>

<p>If <b>H</b> returns YES, then loop forever.</p>

<p>If <b>H</b> returns NO, then halt.</p>

<p>The following is the block diagram of an ‘Inverted halting machine’ &minus;</p>

<p>Further, a machine <b>(HM)<sub>2</sub></b> which input itself is constructed as follows &minus;</p>

<p>Here, we have got a contradiction. Hence, the halting problem is <b>undecidable</b>.</p>

<h1>Rice Theorem</h1>

<h2>Theorem</h2>

<p>If the following two properties hold, it is proved as undecidable &minus;</p>

<p><b>Property 1</b> &minus; If <b>M1</b> and <b>M2</b> recognize the same language, then either <b>&lt;M1&gt; <span style="padding-left:17%">&lt;M2&gt; &isin; L</b> or <b>&lt;M1&gt; &lt;M2&gt; &notin; L</b></span></p>

<p><b>Property 2</b> &minus; For some M1 and M2 such that <b>&lt;M1&gt; &isin; L</b> and <b>&lt;M2&gt; &notin; L</b></p>

<p><b>Proof</b> &minus;</p>

<p>Let there are two Turing machines <b>X<sub>1</sub></b> and <b>X<sub>2</sub></b>.</p>

<p>Let us assume <b>&lt;X<sub>1</sub>&gt; &isin; L</b> such that</p>

<p>For an input ‘w’ in a particular instant, perform the following steps &minus;</p>

<p>If <b>X</b> accepts <b>w</b>, then simulate <b>X<sub>2</sub></b> on <b>x</b>.</p>

<p>Run <b>Z</b> on input <b>&lt;W&gt;</b>.</p>

<p>If <b>Z</b> accepts <b>&lt;W&gt;</b>, Reject it; and if <b>Z</b> rejects <b>&lt;W&gt;</b>, accept it.</p>

<p>If <b>X</b> accepts <b>w</b>, then</p>

<p>If <b>M</b> does not accept w, then</p>

<p>Here the contradiction arises. Hence, it is undecidable.</p>

<h1>Post Correspondence Problem</h1>

<p>The Post Correspondence Problem (PCP), introduced by Emil Post in 1946, is an undecidable decision problem. The PCP problem over an alphabet &sum; is stated as follows &minus;</p>

<p>Given the following two lists, <b>M</b> and <b>N</b> of non-empty strings over &sum; &minus;</p>

<p>We can say that there is a Post Correspondence Solution, if for some i<sub>1</sub>,i<sub>2</sub>,………… i<sub>k</sub>, where 1 &le; i<sub>j</sub> &le; n, the condition x<sub>i1</sub> …….x<sub>ik</sub> = y<sub>i1</sub> …….y<sub>ik</sub> satisfies.</p>

<h2>Example 1</h2>

<p>Find whether the lists</p>

<p>have a Post Correspondence Solution?</p>

<h3>Solution</h3>

<p>Here,</p>

<p>and <span style="padding-left:3%;"><b>y<sub>2</sub>y<sub>1</sub>y<sub>3</sub> = ‘aaabbaaa’</b></span></p>

<p>We can see that</p>

<p>Hence, the solution is <b>i = 2, j = 1, and k = 3.</b></p>

<h2>Example 2</h2>

<p>Find whether the lists <b>M = (ab, bab, bbaaa)</b> and <b>N = (a, ba, bab)</b> have a Post Correspondence Solution?</p>

<h3>Solution</h3>

<p>In this case, there is no solution because &minus;</p>

<p>Hence, it can be said that this Post Correspondence Problem is <b>undecidable</b>.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
X &rarr; &epsilon; 
X &rarr; a | aY
Y &rarr; b 
</pre>
<h2>Type - 2 Grammar</h2>
<p><b>Type-2 grammars</b> generate context-free languages.</p>
<p>The productions must be in the form <b>A &rarr; γ</b></p>
<p>where <span style="padding-left:2%;"><b> A &isin; N</b> (Non terminal)</span></p>
<p>and <span style="padding-left:2%;"><b>γ &isin; (T &cup; N)*</b> (String of terminals and non-terminals).</span></p>
<p>These languages generated by these grammars are be recognized by a non-deterministic pushdown automaton.</p>
<h3>Example</h3>
<pre class="result notranslate">
S &rarr; X a 
X &rarr; a 
X &rarr; aX 
X &rarr; abc 
X &rarr; &epsilon;
</pre>
<h2>Type - 1 Grammar</h2>
<p><b>Type-1 grammars</b> generate context-sensitive languages. The productions must be in the form</p>
<p style="padding-left:12%;"><b>&alpha; A &beta; &rarr; &alpha; γ &beta;</b></p>
<p>where <span style="padding-left:2%;"><b>A &isin; N</b> (Non-terminal)</span></p>
<p>and <span style="padding-left:2%;"><b>&alpha;, &beta;, γ &isin; (T &cup; N)*</b> (Strings of terminals and non-terminals)</span></p>
<p>The strings <b>&alpha;</b> and <b>&beta;</b> may be empty, but <b>γ</b> must be non-empty.</p>
<p>The rule <b>S &rarr; &epsilon;</b> is allowed if S does not appear on the right side of any rule. The languages generated by these grammars are recognized by a linear bounded automaton.</p>
<h3>Example</h3>
<pre class="result notranslate">
AB &rarr; AbBc 
A &rarr; bcA 
B &rarr; b 
</pre>
<h2>Type - 0 Grammar</h2>
<p><b>Type-0 grammars</b> generate recursively enumerable languages. The productions have no restrictions. They are any phase structure grammar including all formal grammars.</p>
<p>They generate the languages that are recognized by a Turing machine.</p>
<p>The productions can be in the form of <b>&alpha; &rarr; &beta;</b> where <b>&alpha;</b> is a string of terminals and nonterminals with at least one non-terminal and <b>&alpha;</b> cannot be null. <b>&beta;</b> is a string of terminals and non-terminals.</p>
<h3>Example</h3>
<pre class="result notranslate">
S &rarr; ACaB 
Bc &rarr; acB 
CB &rarr; DB 
aD &rarr; Db 
</pre>
<h1>Regular Expressions</h1>
<p>A <b>Regular Expression</b> can be recursively defined as follows &minus;</p>
<ul class="list">
<li><p><b>&epsilon;</b> is a Regular Expression indicates the language containing an empty string. <b>(L (&epsilon;) = {&epsilon;})</b></p></li>
<li><p><b>&phi;</b> is a Regular Expression denoting an empty language. <b>(L (&phi;) = { })</b></p></li>
<li><p><b>x</b> is a Regular Expression where <b>L = {x}</b></p></li>
<li><p>If <b>X</b> is a Regular Expression denoting the language <b>L(X)</b> and <b>Y</b> is a Regular Expression denoting the language <b>L(Y)</b>, then</p>
<ul class="list">
<li><p><b>X + Y</b> is a Regular Expression corresponding to the language <b>L(X) &cup; L(Y)</b> where <b>L(X+Y) = L(X) &cup; L(Y)</b>.</p></li>
<li><p><b>X . Y</b> is a Regular Expression corresponding to the language <b>L(X) . L(Y)</b> where <b>L(X.Y) = L(X) . L(Y)</b></p></li>
<li><p><b>R*</b> is a Regular Expression corresponding to the language <b>L(R*)</b>where <b>L(R*) = (L(R))*</b></p></li>
</ul>
</li>
<li><p>If we apply any of the rules several times from 1 to 5, they are Regular Expressions.</p></li>
</ul>
<h2>Some RE Examples</h2>
<table class="table table-bordered">
<tr>
<th style="text-align:center; width:25%">Regular Expressions</th>
<th style="text-align:center;">Regular Set</th>
</tr>
<tr>
<td style="text-align:center">(0 + 10*)</td>
<td>L = { 0, 1, 10, 100, 1000, 10000, … }</td>
</tr>
<tr>
<td style="text-align:center">(0*10*)</td>
<td>L = {1, 01, 10, 010, 0010, …}</td>
</tr>
<tr>
<td style="text-align:center">(0 + &epsilon;)(1 + &epsilon;)</td>
<td>L = {&epsilon;, 0, 1, 01}</td>
</tr>
<tr>
<td style="text-align:center">(a+b)*</td>
<td>Set of strings of a’s and b’s of any length including the null string.  So L = { &epsilon;, a, b, aa , ab , bb , ba, aaa…….}</td>
</tr>
<tr>
<td style="text-align:center">(a+b)*abb</td>
<td>Set of strings of a’s and b’s ending with the string abb. So L = {abb, aabb, babb, aaabb, ababb, …………..}</td>
</tr>
<tr>
<td style="text-align:center">(11)*</td>
<td>Set consisting of even number of 1’s including empty string, So L= {&epsilon;, 11, 1111, 111111, ……….}</td>
</tr>
<tr>
<td style="text-align:center">(aa)*(bb)*b</td>
<td>Set of strings consisting of even number of a’s followed by odd number of b’s , so L = {b, aab, aabbb, aabbbbb, aaaab, aaaabbb, …………..}</td>
</tr>
<tr>
<td style="text-align:center">(aa + ab + ba + bb)*</td>
<td>String of a’s and b’s of even length can be obtained by concatenating any combination of the strings aa, ab, ba and bb  including null, so L = {aa, ab, ba, bb, aaab, aaba, …………..}</td>
</tr>
</table>
<h1>Regular Sets</h1>
<p>Any set that represents the value of the Regular Expression is called a <b>Regular Set.</b></p>
<h3>Properties of Regular Sets</h3>
<p><b>Property 1</b>. <i>The union of two regular set is regular.</i></p>
<p><b>Proof</b> &minus;</p>
<p>Let us take two regular expressions</p>
<p style="padding-left:10%;">RE<sub>1</sub> = a(aa)*  and RE<sub>2</sub> = (aa)*</p>
<p>So, <span style="padding-left:2%">L<sub>1</sub> = {a, aaa, aaaaa,.....} (Strings of odd length excluding Null)</span></p>
<p>and  <span style="padding-left:2%">L<sub>2</sub> ={ &epsilon;, aa, aaaa, aaaaaa,.......} (Strings of even length including Null)</span></p>
<p style="padding-left:7%;">L<sub>1</sub> &cup; L<sub>2</sub> = { &epsilon;, a, aa, aaa, aaaa, aaaaa, aaaaaa,.......}</p>
<p style="padding-left:7%;">(Strings of all possible lengths including Null)</p>
<p style="padding-left:7%;">RE (L<sub>1</sub> &cup; L<sub>2</sub>) = a* <span style="padding-left:2%;">(which is a regular expression itself)</span></p>
<p><b>Hence, proved.</b></p>
<p><b>Property 2.</b> <i>The intersection of two regular set is regular.</i></p>
<p><b>Proof</b> &minus;</p>
<p>Let us take two regular expressions</p>
<p style="padding-left:10%;">RE<sub>1</sub> = a(a*)   and RE<sub>2</sub> = (aa)*</p>
<p>So, <span style="padding-left:2%">L<sub>1</sub> = { a,aa, aaa, aaaa, ....}  (Strings of all possible lengths excluding Null)</span></p>
<p style="padding-left:6%;">L<sub>2</sub> = { &epsilon;, aa, aaaa, aaaaaa,.......} (Strings of even length including Null)</p>
<p style="padding-left:6%;">L<sub>1</sub> &cap; L<sub>2</sub> = { aa, aaaa, aaaaaa,.......} (Strings of even length excluding Null)</p>
<p style="padding-left:6%;">RE (L<sub>1</sub> &cap; L<sub>2</sub>) = aa(aa)* which is a regular expression itself.</p>
<p><b>Hence, proved.</b></p>
<p><b>Property 3.</b> <i>The complement of a regular set is regular.</i></p>
<p><b>Proof</b> &minus;</p>
<p>Let us take a regular expression &minus;</p>
<p style="padding-left:10%;">RE = (aa)*</p>
<p>So, <span style="padding-left:2%;">L = {&epsilon;, aa, aaaa, aaaaaa, .......} (Strings of even length including Null)</span></p>
<p>Complement of <b>L</b> is all the strings that is not in <b>L</b>.</p>
<p>So, <span style="padding-left:2%;">L’ = {a, aaa, aaaaa, .....} (Strings of odd length excluding Null)</span></p>
<p style="padding-left:6%;">RE (L’) = a(aa)* which is a regular expression itself.</p>
<p><b>Hence, proved.</b></p>
<p><b>Property 4.</b> <i>The difference of two regular set is regular.</i></p>
<p><b>Proof</b> &minus;</p>
<p>Let us take two regular expressions &minus;</p>
<p style="padding-left:10%;">RE<sub>1</sub> = a (a*) and RE<sub>2</sub> = (aa)*</p>
<p>So, <span style="padding-left:2%;">L<sub>1</sub> = {a, aa, aaa, aaaa, ....} (Strings of all possible lengths excluding Null)</span></p>
<p style="padding-left:6%;">L<sub>2</sub> = { &epsilon;, aa, aaaa, aaaaaa,.......} (Strings of even length including Null)</p>
<p style="padding-left:6%;">L<sub>1</sub> – L<sub>2</sub> = {a, aaa, aaaaa, aaaaaaa, ....}</p>
<p style="padding-left:6%;">(Strings of all odd lengths excluding Null)</p>
<p style="padding-left:6%;">RE (L<sub>1</sub> – L<sub>2</sub>) = a (aa)* which is a regular expression.</p>
<p><b>Hence, proved.</b></p>
<p><b>Property 5.</b> <i>The reversal of a regular set is regular.</i></p>
<p><b>Proof</b> &minus;</p>
<p>We have to prove <b>L<sup>R</sup></b> is also regular if <b>L</b> is a regular set.</p>
<p>Let, <span style="padding-left:2%">L = {01, 10, 11, 10}</span></p>
<p style="padding-left:7%;">RE (L) = 01 + 10 + 11 + 10</p>
<p style="padding-left:7%;">L<sup>R</sup> = {10, 01, 11, 01}</p>
<p style="padding-left:7%;">RE (L<sup>R</sup>) = 01 + 10 + 11 + 10 which is regular</p>
<p><b>Hence, proved.</b></p>
<p><b>Property 6.</b> <i>The closure of a regular set is regular.</i></p>
<p><b>Proof</b> &minus;</p>
<p style="padding-left:7%;">If L = {a, aaa, aaaaa, .......} <span style="padding-left:6%;">(Strings of odd length excluding Null)</span></p>
<p>i.e.,<span style="padding-left:2%;"> RE (L) = a (aa)*</span></p>
<p style="padding-left:7%;">L* = {a, aa, aaa, aaaa , aaaaa,……………} <span style="padding-left:3%;">(Strings of all lengths excluding Null)</span></p>
<p>RE (L*) = a (a)*</p>
<p><b>Hence, proved.</b></p>
<p><b>Property 7.</b> <i>The concatenation of two regular sets is regular.</i></p>
<p><b>Proof &minus;</b></p>
<p>Let <span style="padding-left:4%">RE<sub>1</sub> = (0+1)*0 and RE<sub>2</sub> = 01(0+1)*</span></p>
<p>Here,<span style="padding-left:2%"> L<sub>1</sub> = {0, 00, 10, 000, 010, ......} <span style="padding-left:5%;">(Set of strings ending in 0)</span></span></p>
<p>and <span style="padding-left:4%">L<sub>2</sub> = {01, 010,011,.....} <span style="padding-left:15%;">(Set of strings beginning with 01)</span></span></p>
<p>Then,<span style="padding-left:2%"> L<sub>1</sub> L<sub>2</sub> = {001,0010,0011,0001,00010,00011,1001,10010,.............}</span></p>
<p>Set of strings containing 001 as a substring which can be represented by an RE &minus; (0 + 1)*001(0 + 1)*</p>
<p>Hence, proved.</p>
<h2>Identities Related to Regular Expressions</h2>
<p>Given R, P, L, Q as regular expressions, the following identities hold &minus;</p>
<ul class="list">
<li>&empty;* = &epsilon;</li>
<li>&epsilon;* = &epsilon;</li>
<li>RR* = R*R</li>
<li>R*R* = R*</li>
<li>(R*)* = R*</li>
<li>RR* = R*R</li>
<li>(PQ)*P =P(QP)*</li>
<li>(a+b)* = (a*b*)* = (a*+b*)* = (a+b*)* = a*(ba*)*</li>
<li>R + &empty; = &empty; + R = R <span style="padding-left:8%;">(The identity for union)</span></li>
<li>R &epsilon; = &epsilon; R = R <span style="padding-left:14%;">(The identity for concatenation)</span></li>
<li>&empty; L = L &empty; = &empty; <span style="padding-left:14%;">(The annihilator for concatenation)</span></li>
<li>R + R = R <span style="padding-left:18%;">(Idempotent law)</span></li>
<li>L (M + N) = LM + LN <span style="padding-left:5%;">(Left distributive law)</span></li>
<li>(M + N) L = LM + LN <span style="padding-left:5%;">(Right distributive law)</span></li>
<li>&epsilon; + RR* = &epsilon; + R*R = R*</li>
</ul>
<h1>Arden's Theorem</h1>
<p>In order to find out a regular expression of a Finite Automaton, we use Arden’s Theorem along with the properties of regular expressions.</p>
<p><b><i>Statement</i></b> &minus;</p>
<p style="padding-left:6%;">Let <b>P</b> and <b>Q</b> be two regular expressions.</p>
<p style="padding-left:6%;">If <b>P</b> does not contain null string, then <b>R = Q + RP</b> has a unique solution that is <b>R = QP*</b></p>
<p><b>Proof</b> &minus;</p>
<p style="padding-left:6%;">R = Q + (Q + RP)P <span style="padding-left:3%">[After putting the value R = Q + RP]</span></p>
<p style="padding-left:8%;">= Q + QP + RPP</p>
<p>When we put the value of <b>R</b> recursively again and again, we get the following equation &minus;</p>
<p style="padding-left:6%;">R = Q + QP + QP<sup>2</sup> + QP<sup>3</sup>…..</p>
<p style="padding-left:6%;">R = Q (&epsilon; + P + P<sup>2</sup> + P<sup>3</sup> + …. )</p>
<p style="padding-left:6%;">R = QP* <span style="padding-left:3%">[As P* represents (&epsilon; + P + P2 + P3 + ….) ]</span></p>
<p>Hence, proved.</p>
<h2>Assumptions for Applying Arden’s Theorem</h2>
<ul class="list">
<li>The transition diagram must not have NULL transitions</li>
<li>It must have only one initial state</li>
</ul>
<h3>Method</h3>
<p><b>Step 1</b> &minus; Create equations as the following form for all the states of the DFA having n states with initial state q<sub>1</sub>.</p>
<p style="padding-left:8%;">q<sub>1</sub> = q<sub>1</sub>R<sub>11</sub> + q<sub>2</sub>R<sub>21</sub> + … + q<sub>n</sub>R<sub>n1</sub> + &epsilon;</p>
<p style="padding-left:8%;">q<sub>2</sub> = q<sub>1</sub>R<sub>12</sub> + q<sub>2</sub>R<sub>22</sub> + … + q<sub>n</sub>R<sub>n2</sub></p>
<p style="padding-left:8%;">…………………………</p>
<p style="padding-left:8%;">…………………………</p>
<p style="padding-left:8%;">…………………………</p>
<p style="padding-left:8%;">…………………………</p>
<p style="padding-left:8%;">q<sub>n</sub> = q<sub>1</sub>R<sub>1n</sub> + q<sub>2</sub>R<sub>2n</sub> + … + q<sub>n</sub>R<sub>nn</sub></p>
<p><b>R<sub>ij</sub></b> represents the set of labels of edges from <b>q<sub>i</sub></b> to <b>q<sub>j</sub></b>, if no such edge exists, then <b>R<sub>ij</sub> = &empty;</b></p>
<p><b>Step 2</b> &minus; Solve these equations to get the equation for the final state in terms of <b>R<sub>ij</sub></b></p>
<p><b>Problem</b></p>
<p>Construct a regular expression corresponding to the automata given below &minus;</p>
<img src="/automata_theory/images/finite_automata.jpg" alt="Finite Automata" />
<p><b>Solution</b> &minus;</p>
<p>Here the initial state is <b>q<sub>2</sub></b> and the final state is <b>q<sub>1</sub></b>.</p>
<p>The equations for the three states q1, q2, and q3 are as follows &minus;</p>
<p style="padding-left:8%;">q<sub>1</sub> = q<sub>1</sub>a + q<sub>3</sub>a + &epsilon; <span style="padding-left:3%">(&epsilon; move is because q1 is the initial state0</span></p>
<p style="padding-left:8%;">q<sub>2</sub> = q<sub>1</sub>b + q<sub>2</sub>b + q<sub>3</sub>b</p>
<p style="padding-left:8%;">q<sub>3</sub> = q<sub>2</sub>a</p>
<p>Now, we will solve these three equations &minus;</p>
<p style="padding-left:8%;">q<sub>2</sub> = q<sub>1</sub>b + q<sub>2</sub>b + q<sub>3</sub>b</p>
<p style="padding-left:11%;"> = q<sub>1</sub>b + q<sub>2</sub>b + (q<sub>2</sub>a)b <span style="padding-left:12%">(Substituting value of q<sub>3</sub>)</span></p>
<p style="padding-left:11%;">= q<sub>1</sub>b + q<sub>2</sub>(b + ab)</p>
<p style="padding-left:11%;">= q<sub>1</sub>b (b + ab)* <span style="padding-left:19%">(Applying Arden’s Theorem)</span></p>
<p style="padding-left:8%;">q<sub>1</sub> = q<sub>1</sub>a + q<sub>3</sub>a + &epsilon;</p>
<p style="padding-left:11%;">= q<sub>1</sub>a + q<sub>2</sub>aa + &epsilon; <span style="padding-left:17%">(Substituting value of q<sub>3</sub>)</span></p>
<p style="padding-left:11%;">= q<sub>1</sub>a + q<sub>1</sub>b(b + ab*)aa + &epsilon; <span style="padding-left:3%">(Substituting value of q<sub>2</sub>)</span></p>
<p style="padding-left:11%;">= q<sub>1</sub>(a + b(b + ab)*aa) + &epsilon;</p>
<p style="padding-left:11%;">= &epsilon; (a+ b(b + ab)*aa)*</p>
<p style="padding-left:11%;">= (a + b(b + ab)*aa)*</p>
<p>Hence, the regular expression is (a + b(b + ab)*aa)*.</p>
<p><b>Problem</b></p>
<p>Construct a regular expression corresponding to the automata given below &minus;</p>
<img src="/automata_theory/images/finite_automata1.jpg" alt="Finite Automata1" />
<p><b>Solution</b> &minus;</p>
<p>Here the initial state is q<sub>1</sub> and the final state is q<sub>2</sub></p>
<p>Now we write down the equations &minus;</p>
<p style="padding-left:8%;">q<sub>1</sub> = q<sub>1</sub>0 + &epsilon;</p>
<p style="padding-left:8%;">q<sub>2</sub> = q<sub>1</sub>1 + q<sub>2</sub>0</p>
<p style="padding-left:8%;">q<sub>3</sub> = q<sub>2</sub>1 + q<sub>3</sub>0 + q<sub>3</sub>1</p>
<p>Now, we will solve these three equations &minus;</p>
<p style="padding-left:8%;">q<sub>1</sub> = &epsilon;0* [As, εR = R]</p>
<p>So, <span style="padding-left:4%;">q<sub>1</sub> = 0*</span></p>
<p style="padding-left:8%;">q<sub>2</sub> = 0*1 + q<sub>2</sub>0</p>
<p>So, <span style="padding-left:4%;">q<sub>2</sub> = 0*1(0)* [By Arden’s theorem]</span></p>
<p>Hence, the regular expression is 0*10*.</p>
<h1>Construction of an FA from an RE</h1>
<p>We can use Thompson's Construction to find out a Finite Automaton from a Regular Expression. We will reduce the regular expression into smallest regular expressions and converting these to NFA and finally to DFA.</p>
<p>Some basic RA expressions are the following &minus;</p>
<p><b><i>Case 1</i></b> &minus; For a regular expression ‘a’, we can construct the following FA &minus;</p>
<img src="/automata_theory/images/finite_automata_for_re.jpg" alt="Finite Automata for RE" />
<p><b><i>Case 2</i></b> &minus; For a regular expression ‘ab’, we can construct the following FA &minus;</p>
<img src="/automata_theory/images/finite_automata_for_re1.jpg" alt="Finite Automata for RE1" />
<p><b><i>Case 3</i></b> &minus; For a regular expression (a+b), we can construct the following FA &minus;</p>
<img src="/automata_theory/images/finite_automata_for_re2.jpg" alt="Finite Automata for RE2" />
<p><b><i>Case 4</i></b> &minus; For a regular expression (a+b)*, we can construct the following FA &minus;</p>
<img src="/automata_theory/images/finite_automata_for_re3.jpg" alt="Finite Automata for RE3" />
<h3>Method</h3>
<p><b>Step 1</b> <span style="padding-left:3%;">Construct an NFA with Null moves from the given regular expression.</span></p>
<p><b>Step 2</b> <span style="padding-left:3%;">Remove Null transition from the NFA and convert it into its equivalent DFA.</span></p>
<p><b>Problem</b></p>
<p>Convert the following RA into its equivalent DFA &minus; 1 (0 + 1)* 0</p>
<p><b><i>Solution</i></b></p>
<p>We will concatenate three expressions "1", "(0 + 1)*" and "0"</p>
<img src="/automata_theory/images/ndfa_with_null_transition_for_ra.jpg" alt="NDFA with Null Transition for RA" />
<p>Now we will remove the <b>&epsilon;</b> transitions. After we remove the <b>&epsilon;</b> transitions from the NDFA, we get the following &minus;</p>
<img src="/automata_theory/images/ndfa_with_null_transition_for_ra1.jpg" alt="NDFA with Null Transition for RA1" />
<p>It is an NDFA corresponding to the RE &minus; 1 (0 + 1)* 0. If you want to convert it into a DFA, simply apply the method of converting NDFA to DFA discussed in Chapter 1.</p>
<h2>Finite Automata with Null Moves (NFA-&epsilon;)</h2>
<p>A Finite Automaton with null moves (FA-&epsilon;) does transit not only after giving input from the alphabet set but also without any input symbol. This transition without input is called a <b>null move</b>.</p>
<p>An NFA-&epsilon; is represented formally by a 5-tuple (Q, &sum;, &delta;, q<sub>0</sub>, F), consisting of</p>
<ul class="list">
<li><p><b>Q</b> &minus; a finite set of states</p></li>
<li><p><b>&sum;</b> &minus; a finite set of input symbols</p></li>
<li><p><b>&delta;</b> &minus; a transition function δ : Q &times; (&sum; &cup; {&epsilon;}) &rarr; 2<sup>Q</sup></p></li>
<li><p><b>q<sub>0</sub></b> &minus; an initial state q<sub>0</sub> &isin; Q</p></li>
<li><p><b>F</b> &minus; a set of final state/states of Q (F&sube;Q).</p></li>
</ul>
<img src="/automata_theory/images/finite_automata_with_null_moves.jpg" alt="Finite Automata with Null Moves" />
<p>The above <b>(FA-&epsilon;)</b> accepts a string set &minus; {0, 1, 01}</p>
<h2>Removal of Null Moves from Finite Automata</h2>
<p>If in an NDFA, there is  ϵ-move between vertex X to vertex Y, we can remove it using the following steps &minus;</p>
<ul class="list">
<li>Find all the outgoing edges from Y.</li>
<li>Copy all these edges starting from X without changing the edge labels.</li>
<li>If X is an initial state, make Y also an initial state.</li>
<li>If Y is a final state, make X also a final state.</li>
</ul>
<p><b>Problem</b></p>
<p>Convert the following NFA-&epsilon; to NFA without Null move.</p>
<img src="/automata_theory/images/finite_automata_with_null_moves1.jpg" alt="Finite Automata with Null Moves1" />
<p><b><i>Solution</i></b></p>
<p><b>Step 1</b> &minus;</p>
<p style="padding-left:8%;">Here the &epsilon; transition is between <b>q<sub>1</sub></b> and <b>q<sub>2</sub></b>, so let <b>q<sub>1</sub></b> is <b>X</b> and <b>q<sub>f</sub></b> is <b>Y</b>.</p>
<p style="padding-left:8%;">Here the outgoing edges from q<sub>f</sub> is to q<sub>f</sub> for inputs 0 and 1.</p>
<p><b>Step 2</b> &minus;</p>
<p style="padding-left:8%;">Now we will Copy all these edges from q<sub>1</sub> without changing the edges from q<sub>f</sub> and get the following FA &minus;</p>
<img src="/automata_theory/images/ndfa_after_step2.jpg" alt="NDFA After Step 2" />
<p><b>Step 3</b> &minus;</p>
<p style="padding-left:8%;">Here q<sub>1</sub> is an initial state, so we make q<sub>f</sub> also an initial state.</p>
<p style="padding-left:8%;">So the FA becomes &minus;</p>
<img src="/automata_theory/images/ndfa_after_step3.jpg" alt="NDFA After Step 3" />
<p><b>Step 4</b> &minus;</p>
<p style="padding-left:8%;">Here q<sub>f</sub> is a final state, so we make q<sub>1</sub> also a final state.</p>
<p style="padding-left:8%;">So the FA becomes &minus;</p>
<img src="/automata_theory/images/final_ndfa_without_null_moves.jpg" alt="Final NDFA Without Null Moves" />
<h1>Pumping Lemma For Regular Grammars</h1>
<h3>Theorem</h3>
<p>Let L be a regular language. Then there exists a constant <b>‘c’</b> such that for every string <b>w</b> in <b>L</b> &minus;</p>
<p style="padding-left:8%;"><b>|w| &ge; c</b></p>
<p>We can break <b>w</b> into three strings, <b>w = xyz</b>, such that &minus;</p>
<ul class="list">
<li>|y| &gt; 0</li>
<li>|xy| &le; c</li>
<li>For all k &ge; 0, the string xy<sup>k</sup>z is also in L.</li>
</ul>
<h2>Applications of Pumping Lemma</h2>
<p>Pumping Lemma is to be applied to show that certain languages are not regular. It should never be used to show a language is regular.</p>
<ul class="list">
<li><p>If <b>L</b> is regular, it satisfies Pumping Lemma.</p></li>
<li><p>If <b>L</b> does not satisfy Pumping Lemma, it is non-regular.</p></li>
</ul>
<h2>Method to prove that a language L is not regular</h2>
<ul class="list">
<li><p>At first, we have to assume that <b>L</b> is regular.</p></li>
<li><p>So, the pumping lemma should hold for <b>L</b>.</p></li>
<li><p>Use the pumping lemma to obtain a contradiction &minus;</p>
<ul class="list">
<li><p>Select <b>w</b> such that <b>|w| &ge; c</b></p></li>
<li><p>Select <b>y</b> such that <b>|y| &ge; 1</b></p></li>
<li><p>Select <b>x</b> such that <b>|xy| &le; c</b></p></li>
<li><p>Assign the remaining string to <b>z.</b></p></li>
<li><p>Select <b>k</b> such that the resulting string is not in <b>L.</b></p></li>
</ul>
</li>
</ul>
<p><b>Hence L is not regular.</b></p>
<p><b>Problem</b></p>
<p>Prove that <b>L = {a<sup>i</sup>b<sup>i</sup> | i &ge; 0}</b> is not regular.</p>
<p><b><i>Solution</i></b> &minus;</p>
<ul class="list">
<li><p>At first, we assume that <b>L</b> is regular and n is the number of states.</p></li>
<li><p>Let w = <i>a<sup>n</sup>b<sup>n</sup></i>. Thus |w| = 2n &ge; n.</p></li>
<li><p>By pumping lemma, let w = xyz, where |xy| &le; n.</p></li>
<li><p>Let x = a<sup>p</sup>, y = a<sup>q</sup>, and z = a<sup>r</sup>b<sup>n</sup>, where p + q + r = n, p &ne; 0, q &ne; 0, r &ne; 0. Thus |y| &ne; 0.</p></li>
<li><p>Let k = 2. Then xy<sup>2</sup>z = a<sup>p</sup>a<sup>2q</sup>a<sup>r</sup>b<sup>n</sup>.</p></li>
<li><p>Number of as = (p + 2q + r) = (p + q + r) + q = n + q</p></li>
<li><p>Hence, xy<sup>2</sup>z = a<sup>n+q</sup> b<sup>n</sup>. Since q &ne; 0, xy<sup>2</sup>z is not of the form a<sup>n</sup>b<sup>n</sup>.</p></li>
<li><p>Thus, xy<sup>2</sup>z is not in L. Hence L is not regular.</p></li>
</ul>
<h1>DFA Complement</h1>
<p>If (Q, &sum;, &delta;, q<sub>0</sub>, F) be a DFA that accepts a language L, then the complement of the DFA can be obtained by swapping its accepting states with its non-accepting states and vice versa.</p>
<p>We will take an example and elaborate this below &minus;</p>
<img src="/automata_theory/images/dfa_accepting_language_l.jpg" alt="DFA Accepting Language L" />
<p>This DFA accepts the language</p>
<p style="padding-left:8%;">L = {a, aa, aaa , ............. }</p>
<p>over the alphabet</p>
<p style="padding-left:8%;">&sum; = {a, b}</p>
<p>So, RE = a<sup>+</sup>.</p>
<p>Now we will swap its accepting states with its non-accepting states and vice versa and will get the following &minus;</p>
<img src="/automata_theory/images/dfa_accepting_complement_language_l.jpg" alt="DFA Accepting Complement Language L" />
<p>This DFA accepts the language</p>
<p style="padding-left:8%;">Ľ = {&epsilon;, b, ab ,bb,ba, ............... }</p>
<p>over the alphabet</p>
<p style="padding-left:8%;">&sum; = {a, b}</p>
<p><b>Note</b> &minus; If we want to complement an NFA, we have to first convert it to DFA and then have to swap states as in the previous method.</p>
<h1>Context-Free Grammar Introduction</h1>
<p><b><i>Definition</i></b> &minus; A context-free grammar (CFG) consisting of a finite set of grammar rules is a quadruple <b>(N, T, P, S)</b> where</p>
<ul class="list">
<li><p><b>N</b> is a set of non-terminal symbols.</p></li>
<li><p><b>T</b> is a set of terminals where <b>N &cap; T = NULL.</b></p></li>
<li><p><b>P</b> is a set of rules, <b>P: N &rarr; (N &cup; T)*</b>, i.e., the left-hand side of the production rule <b>P</b> does have any right context or left context.</p></li>
<li><p><b>S</b> is the start symbol.</p></li>
</ul>
<p><b>Example</b></p>
<ul class="list">
<li>The grammar ({A}, {a, b, c}, P, A), P : A &rarr; aA, A &rarr; abc.</li>
<li>The grammar ({S, a, b}, {a, b}, P, S), P: S &rarr; aSa, S &rarr; bSb, S &rarr; &epsilon;</li>
<li>The grammar ({S, F}, {0, 1}, P, S), P: S &rarr; 00S | 11F, F &rarr; 00F | &epsilon;</li>
</ul>
<h2>Generation of Derivation Tree</h2>
<p>A derivation tree or parse tree is an ordered rooted tree that graphically represents the semantic information a string derived from a context-free grammar.</p>
<h3>Representation Technique</h3>
<ul class="list">
<li><p><b>Root vertex</b> &minus; Must be labeled by the start symbol.</p></li>
<li><p><b>Vertex</b> &minus; Labeled by a non-terminal symbol.</p></li>
<li><p><b>Leaves</b> &minus; Labeled by a terminal symbol or &epsilon;.</p></li>
</ul>
<p>If S &rarr; x<sub>1</sub>x<sub>2</sub> …… x<sub>n</sub> is a production rule in a CFG, then the parse tree / derivation tree will be as follows &minus;</p>
<img src="/automata_theory/images/derivation_tree.jpg" alt="Derivation Tree" />
<p>There are two different approaches to draw a derivation tree &minus;</p>
<p><b>Top-down Approach &minus;</b></p>
<ul class="list">
<li><p>Starts with the starting symbol <b>S</b></p></li>
<li><p>Goes down to tree leaves using productions</p></li>
</ul>
<p><b>Bottom-up Approach &minus;</b></p>
<ul class="list">
<li><p>Starts from tree leaves</p></li>
<li><p>Proceeds upward to the root which is the starting symbol <b>S</b></p></li>
</ul>
<h3>Derivation or Yield of a Tree</h3>
<p>The derivation or the yield of a parse tree is the final string obtained by concatenating the labels of the leaves of the tree from left to right, ignoring the Nulls. However, if all the leaves are Null, derivation is Null.</p>
<p><b>Example</b></p>
<p>Let a CFG {N,T,P,S} be</p>
<p style="padding-left:10%;">N = {S}, T = {a, b}, Starting symbol = S, P = S &rarr; SS | aSb | &epsilon;</p>
<p>One derivation from the above CFG is “abaabb”</p>
<p style="padding-left:10%;">S &rarr; SS &rarr; aSbS &rarr; abS &rarr; abaSb &rarr; abaaSbb &rarr; abaabb</p>
<img src="/automata_theory/images/yield_of_a_tree.jpg" alt="Yield of a Tree" />
<h3>Sentential Form and Partial Derivation Tree</h3>
<p>A partial derivation tree is a sub-tree of a derivation tree/parse tree such that either all of its children are in the sub-tree or none of them are in the sub-tree.</p>
<p><b>Example</b></p>
<p>If in any CFG the productions are &minus;</p>
<p style="padding-left:10%;">S &rarr; AB,  A &rarr; aaA | &epsilon;,  B &rarr; Bb| &epsilon;</p>
<p>the partial derivation tree can be the following &minus;</p>
<img src="/automata_theory/images/sentential_form_and_partial_derivation_tree.jpg" alt="Sentential Form and Partial Derivation Tree" />
<p>If a partial derivation tree contains the root S, it is called a <b>sentential form</b>. The above sub-tree is also in sentential form.</p>
<h3>Leftmost and Rightmost Derivation of a String</h3>
<ul class="list">
<li><p><b>Leftmost derivation</b> &minus; A leftmost derivation is obtained by applying production to the leftmost variable in each step.</p></li>
<li><p><b>Rightmost derivation</b> &minus; A rightmost derivation is obtained by applying production to the rightmost variable in each step.</p></li>
</ul>
<p><b>Example</b></p>
<p>Let any set of production rules in a CFG be</p>
<p style="padding-left:10%;">X &rarr; X+X | X*X |X| a</p>
<p>over an alphabet {a}.</p>
<p>The leftmost derivation for the string <b>"a+a*a"</b> may be &minus;</p>
<p style="padding-left:10%;">X &rarr; X+X &rarr; a+X &rarr; a + X*X &rarr; a+a*X &rarr; a+a*a</p>
<p>The stepwise derivation of the above string is shown as below &minus;</p>
<img src="/automata_theory/images/leftmost.jpg" alt="Leftmost" />
<p>The rightmost derivation for the above string <b>"a+a*a"</b> may be &minus;</p>
<p style="padding-left:10%;">X &rarr; X*X &rarr; X*a &rarr; X+X*a &rarr; X+a*a &rarr; a+a*a</p>
<p>The stepwise derivation of the above string is shown as below &minus;</p>
<img src="/automata_theory/images/rightmost.jpg" alt="Rightmost" />
<h2>Left and Right Recursive Grammars</h2>
<p>In a context-free grammar <b>G</b>, if there is a production in the form <b>X &rarr; Xa</b> where <b>X</b> is a non-terminal and <b>‘a’</b> is a string of terminals, it is called a <b>left recursive production</b>. The grammar having a left recursive production is called a <b>left recursive grammar</b>.</p>
<p>And if in a context-free grammar <b>G</b>, if there is a production is in the form <b>X &rarr; aX</b> where <b>X</b> is a non-terminal and <b>‘a’</b> is a string of terminals, it is called a <b>right recursive production</b>. The grammar having a right recursive production is called a <b>right recursive grammar</b>.</p>
<h1>Ambiguity in Context-Free Grammars</h1>
<p>If a context free grammar <b>G</b> has more than one derivation tree for some string <b>w &isin; L(G)</b>, it is called an <b>ambiguous grammar</b>. There exist multiple right-most or left-most derivations for some string generated from that grammar.</p>
<h2>Problem</h2>
<p>Check whether the grammar G with production rules &minus;</p>
<p style="padding-left:10%;">X &rarr; X+X | X*X |X| a</p>
<p>is ambiguous or not.</p>
<h2>Solution</h2>
<p>Let’s find out the derivation tree for the string "a+a*a". It has two leftmost derivations.</p>
<p><b>Derivation 1</b> &minus; <span style="padding-left:3%;">X &rarr; X+X &rarr; a +X &rarr; a+ X*X &rarr; a+a*X &rarr; a+a*a</span></p>
<p><b>Parse tree 1</b> &minus;</p>
<img src="/automata_theory/images/parse_tree1.jpg" alt="Parse Tree 1" />
<p><b>Derivation 2</b> &minus; <span style="padding-left:3%;">X &rarr; X*X &rarr; X+X*X &rarr; a+ X*X &rarr; a+a*X &rarr; a+a*a</span></p>
<p><b>Parse tree 2</b> &minus;</p>
<img src="/automata_theory/images/parse_tree2.jpg" alt="Parse Tree 2" />
<p>Since there are two parse trees for a single string "a+a*a", the grammar <b>G</b> is ambiguous.</p>
<h1>CFL Closure Property</h1>
<p>Context-free languages are <b>closed</b> under &minus;</p>
<ul class="list">
<li>Union</li>
<li>Concatenation</li>
<li>Kleene Star operation</li>
</ul>
<h2>Union</h2>
<p>Let L<sub>1</sub> and L<sub>2</sub> be two context free languages. Then L<sub>1</sub> &cup; L<sub>2</sub> is also context free.</p>
<h3>Example</h3>
<p>Let L<sub>1</sub> = { a<sup>n</sup>b<sup>n</sup> , n &gt; 0}. Corresponding grammar G<sub>1</sub> will have P: S1 &rarr; aAb|ab</p>
<p>Let L<sub>2</sub> = { c<sup>m</sup>d<sup>m</sup> , m &ge; 0}. Corresponding grammar G<sub>2</sub> will have P: S2 &rarr; cBb| &epsilon;</p>
<p>Union of L<sub>1</sub> and L<sub>2</sub>, L = L<sub>1</sub> &cup; L<sub>2</sub> = { a<sup>n</sup>b<sup>n</sup> } &cup; { c<sup>m</sup>d<sup>m</sup> }</p>
<p>The corresponding grammar G will have the additional production S &rarr; S1 | S2</p>
<h2>Concatenation</h2>
<p>If L<sub>1</sub> and L<sub>2</sub> are context free languages, then L<sub>1</sub>L<sub>2</sub> is also context free.</p>
<h3>Example</h3>
<p>Union of the languages L<sub>1</sub> and L<sub>2</sub>, L = L<sub>1</sub>L<sub>2</sub> = { a<sup>n</sup>b<sup>n</sup>c<sup>m</sup>d<sup>m</sup> }</p>
<p>The corresponding grammar G will have the additional production S &rarr; S1 S2</p>
<h2>Kleene Star</h2>
<p>If L is a context free language, then L* is also context free.</p>
<h3>Example</h3>
<p>Let L = { a<sup>n</sup>b<sup>n</sup> , n &ge; 0}. Corresponding grammar G will have P: S &rarr; aAb| &epsilon;</p>
<p>Kleene Star L<sub>1</sub> = { a<sup>n</sup>b<sup>n </sup>}*</p>
<p>The corresponding grammar G<sub>1</sub> will have additional productions S1 &rarr; SS<sub>1</sub> | &epsilon;</p>
<p>Context-free languages are <b>not closed</b> under &minus;</p>
<ul class="list">
<li><p><b>Intersection</b> &minus; If L1 and L2 are context free languages, then L1 &cap; L2 is not necessarily context free.</p></li>
<li><p><b>Intersection with Regular Language</b> &minus; If L1 is a regular language and L2 is a context free language, then L1 &cap; L2 is a context free language.</p></li>
<li><p><b>Complement</b> &minus; If L1 is a context free language, then L1’ may not be context free.</p></li>
</ul>
<h1>CFG Simplification</h1>
<p>In a CFG, it may happen that all the production rules and symbols are not needed for the derivation of strings. Besides, there may be some null productions and unit productions. Elimination of these productions and symbols is called <b>simplification of CFGs</b>. Simplification essentially comprises of the following steps &minus;</p>
<ul class="list">
<li>Reduction of CFG</li>
<li>Removal of Unit Productions</li>
<li>Removal of Null Productions</li>
</ul>
<h2>Reduction of CFG</h2>
<p>CFGs are reduced in two phases &minus;</p>
<p><b>Phase 1</b> &minus; Derivation of an equivalent grammar, <b>G’</b>, from the CFG, <b>G</b>, such that each variable derives some terminal string.</p>
<p style="padding-left:8%"><b>Derivation Procedure</b> &minus;</p>
<p style="padding-left:8%">Step 1 &minus; Include all symbols, <b>W<sub>1</sub></b>, that derive some terminal and initialize <b>i=1</b>.</p>
<p style="padding-left:8%">Step 2 &minus; Include all symbols, <b>W<sub>i+1</sub></b>, that derive <b>W<sub>i</sub></b>.</p>
<p style="padding-left:8%">Step 3 &minus; Increment <b>i</b> and repeat Step 2, until <b>W<sub>i+1</sub> = W<sub>i</sub></b>.</p>
<p style="padding-left:8%">Step 4 &minus; Include all production rules that have <b>W<sub>i</sub></b> in it.</p>
<p><b>Phase 2</b> &minus; Derivation of an equivalent grammar, <b>G”</b>, from the CFG, <b>G’</b>, such that each symbol appears in a sentential form.</p>
<p style="padding-left:8%"><b>Derivation Procedure</b> &minus;</p>
<p style="padding-left:8%">Step 1 &minus; Include the start symbol in <b>Y<sub>1</sub></b> and initialize <b>i = 1</b>.</p>
<p style="padding-left:8%">Step 2 &minus; Include all symbols, <b>Y<sub>i+1</sub></b>, that can be derived from <b>Y<sub>i</sub></b> and include all production rules that have been applied.</p>
<p style="padding-left:8%">Step 3 &minus; Increment <b>i</b> and repeat Step 2, until <b>Y<sub>i+1</sub> = Y<sub>i</sub></b>.</p>
<h3>Problem</h3>
<p>Find a reduced grammar equivalent to the grammar G, having production rules, P: S &rarr; AC | B, A &rarr; a, C &rarr; c | BC, E &rarr; aA | e</p>
<h3>Solution</h3>
<p><b>Phase 1</b> &minus;</p>
<p style="padding-left:10%;">T = { a, c, e }</p>
<p style="padding-left:10%;">W<sub>1</sub> = { A, C, E } from rules A &rarr; a, C &rarr; c and E &rarr; aA</p>
<p style="padding-left:10%;">W<sub>2</sub> = { A, C, E } U { S } from rule S &rarr; AC</p>
<p style="padding-left:10%;">W<sub>3</sub> = { A, C, E, S } U &empty;</p>
<p style="padding-left:10%;">Since W<sub>2</sub> = W<sub>3</sub>, we can derive G’ as &minus;</p>
<p style="padding-left:12%;">G’ = { { A, C, E, S }, { a, c, e }, P, {S}}</p>
<p style="padding-left:10%;">where P: S &rarr; AC, A &rarr; a, C &rarr; c , E &rarr; aA | e</p>
<p><b>Phase 2</b> &minus;</p>
<p style="padding-left:10%;">Y<sub>1</sub> = { S }</p>
<p style="padding-left:10%;">Y<sub>2</sub> = { S, A, C } from rule S &rarr; AC</p>
<p style="padding-left:10%;">Y<sub>3</sub> = { S, A, C, a, c } from rules A &rarr; a and C &rarr; c</p>
<p style="padding-left:10%;">Y<sub>4</sub> = { S, A, C, a, c }</p>
<p style="padding-left:10%;">Since Y<sub>3</sub> = Y<sub>4</sub>, we can derive G” as &minus;</p>
<p style="padding-left:13%;">G” = { { A, C, S }, { a, c }, P, {S}}</p>
<p style="padding-left:10%;">where P: S &rarr; AC, A &rarr; a, C &rarr; c</p>
<h2>Removal of Unit Productions</h2>
<p>Any production rule in the form A &rarr; B where A, B &isin; Non-terminal is called <b>unit production.</b>.</p>
<h3>Removal Procedure &minus;</h3>
<p><b>Step 1</b> &minus; To remove <b>A &rarr; B</b>, add production <b>A &rarr; x</b> to the grammar rule whenever <b>B &rarr; x</b> occurs in the grammar. [x &isin; Terminal, x can be Null]</p>
<p><b>Step 2</b> &minus; Delete <b>A &rarr; B</b> from the grammar.</p>
<p><b>Step 3</b> &minus; Repeat from step 1 until all unit productions are removed.</p>
<p><b>Problem</b></p>
<p>Remove unit production from the following &minus;</p>
<p style="padding-left:10%;">S &rarr; XY, X &rarr; a, Y &rarr; Z | b, Z &rarr; M, M &rarr; N, N &rarr; a</p>
<p><b>Solution</b> &minus;</p>
<p>There are 3 unit productions in the grammar &minus;</p>
<p style="padding-left:10%;">Y &rarr; Z, Z &rarr; M, and M &rarr; N</p>
<p><b>At first, we will remove M &rarr; N.</b></p>
<p>As N &rarr; a, we add M &rarr; a, and M &rarr; N is removed.</p>
<p>The production set becomes</p>
<p style="padding-left:10%;">S &rarr; XY, X &rarr; a, Y &rarr; Z | b, Z &rarr; M, M &rarr; a, N &rarr; a</p>
<p><b>Now we will remove Z &rarr; M.</b></p>
<p>As M &rarr; a, we add Z&rarr; a, and Z &rarr; M is removed.</p>
<p>The production set becomes</p>
<p style="padding-left:10%;">S &rarr; XY, X &rarr; a, Y &rarr; Z | b, Z &rarr; a, M &rarr; a, N &rarr; a</p>
<p><b>Now we will remove Y &rarr; Z.</b></p>
<p>As Z &rarr; a, we add Y&rarr; a, and Y &rarr; Z is removed.</p>
<p>The production set becomes</p>
<p style="padding-left:12%;">S &rarr; XY, X &rarr; a, Y &rarr; a | b, Z &rarr; a, M &rarr; a, N &rarr; a</p>
<p>Now Z, M, and N are unreachable, hence we can remove those.</p>
<p>The final CFG is unit production free &minus;</p>
<p style="padding-left:12%;">S &rarr; XY, X &rarr; a, Y &rarr; a | b</p>
<h2>Removal of Null Productions</h2>
<p>In a CFG, a non-terminal symbol <b>‘A’</b> is a nullable variable if there is a production <b>A &rarr; &epsilon;</b> or there is a derivation that starts at <b>A</b> and finally ends up with</p>
<p style="padding-left:10%">&epsilon;: A &rarr; .......… &rarr; &epsilon;</p>
<h3>Removal Procedure</h3>
<p><b>Step 1</b> &minus; Find out nullable non-terminal variables which derive &epsilon;.</p>
<p><b>Step 2</b> &minus; For each production <b>A &rarr; a</b>, construct all productions <b>A &rarr; x</b> where <b>x</b> is obtained from <b>‘a’</b> by removing one or multiple non-terminals from Step 1.</p>
<p><b>Step 3</b> &minus; Combine the original productions with the result of step 2 and remove <b>&epsilon; - productions</b>.</p>
<p><b>Problem</b></p>
<p>Remove null production from the following &minus;</p>
<p>S &rarr; ASA | aB | b, A &rarr; B, B &rarr; b | &isin;</p>
<p><b>Solution</b> &minus;</p>
<p>There are two nullable variables &minus; <b>A</b> and <b>B</b></p>
<p><b>At first, we will remove B &rarr; &epsilon;.</b></p>
<p>After removing <b>B &rarr; &epsilon;</b>, the production set becomes &minus;</p>
<p style="padding-left:10%;">S&rarr;ASA | aB | b | a, A &epsilon; B| b | &epsilon, B &rarr; b</p>
<p><b>Now we will remove A &rarr; &epsilon;.</b></p>
<p>After removing <b>A &rarr; &epsilon;</b>, the production set becomes &minus;</p>
<p style="padding-left:10%;">S&rarr;ASA | aB | b | a | SA | AS | S, A &rarr; B| b, B &rarr; b</p>
<p>This is the final production set without null transition.</p>
<h1>Chomsky Normal Form</h1>
<p>A CFG is in Chomsky Normal Form if the Productions are in the following forms &minus;</p>
<ul class="list">
<li>A &rarr; a</li>
<li>A &rarr; BC</li>
<li>S &rarr; &epsilon;</li>
</ul>
<p>where A, B, and C are non-terminals and <b>a</b> is terminal.</p>
<h2>Algorithm to Convert into Chomsky Normal Form &minus;</h2>
<p><b>Step 1</b> &minus; If the start symbol <b>S</b> occurs on some right side, create a new start symbol <b>S’</b> and a new production <b>S’&rarr; S</b>.</p>
<p><b>Step 2</b> &minus; Remove Null productions. (Using the Null production removal algorithm discussed earlier)</p>
<p><b>Step 3</b> &minus; Remove unit productions. (Using the Unit production removal algorithm discussed earlier)</p>
<p><b>Step 4</b> &minus; Replace each production <b>A &rarr; B<sub>1</sub>…B<sub>n</sub></b> where <b>n &gt; 2</b> with <b>A &rarr; B<sub>1</sub>C</b> where <b>C &rarr; B<sub>2</sub> …B<sub>n</sub></b>. Repeat this step for all productions having two or more symbols in the right side.</p>
<p><b>Step 5</b> &minus; If the right side of any production is in the form <b>A &rarr; aB</b> where a is a terminal and <b>A, B</b> are non-terminal, then the production is replaced by <b>A &rarr; XB</b> and <b>X &rarr; a</b>. Repeat this step for every production which is in the form <b>A &rarr; aB</b>.</p>
<h3>Problem</h3>
<p>Convert the following CFG into CNF</p>
<p style="padding-left:10%;">S &rarr; ASA | aB,  A &rarr; B | S, B &rarr; b | &epsilon;</p>
<h3>Solution</h3>
<p><b>(1)</b> Since <b>S</b> appears in R.H.S, we add a new state <b>S<sub>0</sub></b> and <b>S<sub>0</sub>&rarr;S</b> is added to the production set and it becomes &minus;</p>
<p style="padding-left:10%;">S<sub>0</sub>&rarr;S, S&rarr; ASA | aB, A &rarr; B | S, B &rarr; b | &isin;</p>
<p><b>(2)</b> Now we will remove the null productions &minus;</p>
<p style="padding-left:10%;">B &rarr; &isin; and A &rarr; &isin;</p>
<p>After removing B &rarr; &epsilon;, the production set becomes &minus;</p>
<p style="padding-left:10%;">S<sub>0</sub>&rarr;S, S&rarr; ASA | aB | a, A &rarr; B | S | &isin;, B &rarr; b</p>
<p>After removing A &rarr; &isin;, the production set becomes &minus;</p>
<p style="padding-left:10%;">S<sub>0</sub>&rarr;S, S&rarr; ASA | aB | a | AS | SA | S, A &rarr; B | S, B &rarr; b</p>
<p><b>(3)</b> Now we will remove the unit productions.</p>
<p>After removing S &rarr; S, the production set becomes &minus;</p>
<p style="padding-left:10%;">S<sub>0</sub>&rarr;S, S&rarr; ASA | aB | a | AS | SA, A &rarr; B | S, B &rarr; b</p>
<p>After removing S<sub>0</sub>&rarr; S, the production set becomes &minus;</p> 
<p style="padding-left:10%;">S<sub>0</sub>&rarr; ASA | aB | a | AS | SA, S&rarr; ASA | aB | a | AS | SA</p>
<p style="padding-left:10%;">A &rarr; B | S,  B &rarr; b</p>
<p>After removing A&rarr; B, the production set becomes &minus;</p>
<p style="padding-left:10%;">S<sub>0</sub> &rarr; ASA | aB | a | AS | SA, S&rarr; ASA | aB | a | AS | SA</p>
<p style="padding-left:10%;">A &rarr; S | b</p>
<p style="padding-left:10%;">B &rarr; b</p>
<p>After removing A&rarr; S, the production set becomes &minus;</p>
<p style="padding-left:10%;">S<sub>0</sub> &rarr; ASA | aB | a | AS | SA,  S&rarr; ASA | aB | a | AS | SA</p>
<p style="padding-left:10%;">A &rarr; b |ASA | aB | a | AS | SA, B &rarr; b</p>
<p><b>(4)</b> Now we will find out more than two variables in the R.H.S</p>
<p>Here, S<sub>0</sub>&rarr; ASA, S &rarr; ASA, A&rarr; ASA violates two Non-terminals in R.H.S.</p>
<p>Hence we will apply step 4 and step 5 to get the following final production set which is in CNF &minus;</p>
<p style="padding-left:10%;">S<sub>0</sub>&rarr; AX | aB | a | AS | SA</p>
<p style="padding-left:10%;">S&rarr; AX | aB | a | AS | SA</p>
<p style="padding-left:10%;">A &rarr; b |AX | aB | a | AS | SA</p>
<p style="padding-left:10%;">B &rarr; b</p>
<p style="padding-left:10%;">X &rarr; SA</p>
<p><b>(5)</b> We have to change the productions S<sub>0</sub>&rarr; aB, S&rarr; aB, A&rarr; aB</p>
<p>And the final production set becomes &minus;</p>
<p style="padding-left:10%;">S<sub>0</sub>&rarr; AX | YB | a | AS | SA</p>
<p style="padding-left:10%;">S&rarr; AX | YB | a | AS | SA</p>
<p style="padding-left:10%;">A &rarr; b A &rarr; b |AX | YB | a | AS | SA</p>
<p style="padding-left:10%;">B &rarr; b</p>
<p style="padding-left:10%;">X &rarr; SA</p>
<p style="padding-left:10%;">Y &rarr; a</p>
<h1>Greibach Normal Form</h1>
<p>A CFG is in Greibach Normal Form if the Productions are in the following forms &minus;</p>
<p style="padding-left:7%;">A &rarr; b</p>
<p style="padding-left:7%;">A &rarr; bD<sub>1</sub>…D<sub>n</sub></p>
<p style="padding-left:7%;">S &rarr; &epsilon;</p>
<p>where A, D<sub>1</sub>,....,D<sub>n</sub> are non-terminals and b is a terminal.</p>
<h2>Algorithm to Convert a CFG into Greibach Normal Form</h2>
<p><b>Step 1</b> &minus; If the start symbol <b>S</b> occurs on some right side, create a new start symbol <b>S’</b> and a new production <b>S’ &rarr; S</b>.</p>
<p><b>Step 2</b> &minus; Remove Null productions. (Using the Null production removal algorithm discussed earlier)</p>
<p><b>Step 3</b> &minus; Remove unit productions. (Using the Unit production removal algorithm discussed earlier)</p>
<p><b>Step 4</b> &minus; Remove all direct and indirect left-recursion.</p>
<p><b>Step 5</b> &minus; Do proper substitutions of productions to convert it into the proper form of GNF.</p>
<h3>Problem</h3>
<p>Convert the following CFG into CNF</p>
<p style="padding-left:7%;">S &rarr; XY | Xn | p</p>
<p style="padding-left:7%;">X &rarr; mX | m</p>
<p style="padding-left:7%;">Y &rarr; Xn | o</p>
<h3>Solution</h3>
<p>Here, <b>S</b> does not appear on the right side of any production and there are no unit or null productions in the production rule set. So, we can skip Step 1 to Step 3.</p>
<p><b>Step 4</b></p>
<p>Now after replacing</p>
<p style="padding-left:7%;">X in S &rarr; XY | Xo | p</p>
<p>with</p>
<p style="padding-left:7%;">mX | m</p>
<p>we obtain</p>
<p style="padding-left:7%;">S &rarr; mXY | mY | mXo | mo | p.</p>
<p>And after replacing</p>
<p style="padding-left:7%;">X in Y &rarr; X<sub>n</sub> | o</p>
<p>with the right side of</p>
<p style="padding-left:7%;">X &rarr; mX | m</p>
<p>we obtain</p>
<p style="padding-left:7%;">Y &rarr; mXn | mn | o.</p>
<p>Two new productions O &rarr; o and P &rarr; p are added to the production set and then we came to the final GNF as the following &minus;</p>
<p style="padding-left:7%;">S &rarr; mXY | mY | mXC | mC | p</p>
<p style="padding-left:7%;">X &rarr; mX | m</p>
<p style="padding-left:7%;">Y &rarr; mXD | mD | o</p>
<p style="padding-left:7%;">O &rarr; o</p>
<p style="padding-left:7%;">P &rarr; p</p>
<h1>Pumping Lemma for CFG</h1>
<h2>Lemma</h2>
<p>If <b>L</b> is a context-free language, there is a pumping length <b>p</b> such that any string <b>w &isin; L</b> of length <b>&ge; p</b> can be written as <b>w = uvxyz</b>, where <b>vy &ne; &epsilon;</b>, <b>|vxy| &le; p</b>, and for all <b>i &ge; 0, uv<sup>i</sup>xy<sup>i</sup>z &isin; L</b>.</p>
<h2>Applications of Pumping Lemma</h2>
<p>Pumping lemma is used to check whether a grammar is context free or not. Let us take an example and show how it is checked.</p>
<h3>Problem</h3>
<p>Find out whether the language <b>L = {x<sup>n</sup>y<sup>n</sup>z<sup>n</sup> | n &ge; 1}</b> is context free or not.</p>
<h3>Solution</h3>
<p>Let <b>L</b> is context free. Then, <b>L</b> must satisfy pumping lemma.</p>
<p>At first, choose a number <b>n</b> of the pumping lemma. Then, take z as 0<sup>n</sup>1<sup>n</sup>2<sup>n</sup>.</p>
<p>Break <b>z</b> into <b>uvwxy,</b> where</p>
<p style="padding-left:10%;"><b>|vwx| &le; n and vx &ne; &epsilon;.</b></p>
<p>Hence <b>vwx</b> cannot involve both 0s and 2s, since the last 0 and the first 2 are at least (n+1) positions apart. There are two cases &minus;</p>
<p><b>Case 1</b> &minus; <b>vwx</b> has no 2s. Then <b>vx</b> has only 0s and 1s. Then <b>uwy</b>, which would have to be in <b>L</b>, has <b>n</b> 2s, but fewer than <b>n</b> 0s or 1s.</p>
<p><b>Case 2</b> &minus; <b>vwx</b> has no 0s.</p>
<p>Here contradiction occurs.</p>
<p>Hence, <b>L</b> is not a context-free language.</p>
<h1>Pushdown Automata Introduction</h1>
<h2>Basic Structure of PDA</h2>
<p>A pushdown automaton is a way to implement a context-free grammar in a similar way we design DFA for a regular grammar. A DFA can remember a finite amount of information, but a PDA can remember an infinite amount of information.</p>
<p>Basically a pushdown automaton is &minus;</p>
<p style="padding-left:7%;"><b>"Finite state machine" + "a stack"</b></p>
<p>A pushdown automaton has three components &minus;</p>
<ul class="list">
<li>an input tape,</li>
<li>a control unit, and</li>
<li>a stack with infinite size.</li>
</ul>
<p>The stack head scans the top symbol of the stack.</p>
<p>A stack does two operations &minus;</p>
<ul class="list">
<li><p><b>Push</b> &minus; a new symbol is added at the top.</p></li>
<li><p><b>Pop</b> &minus; the top symbol is read and removed.</p></li>
</ul>
<p>A PDA may or may not read an input symbol, but it has to read the top of the stack in every transition.</p>
<img src="/automata_theory/images/pda.jpg" alt="PDA" />
<p>A PDA can be formally described as a 7-tuple (Q, &sum;, S, &delta;, q<sub>0</sub>, I, F) &minus;</p>
<ul class="list">
<li><p><b>Q</b> is the finite number of states</p></li>
<li><p><b>&sum;</b> is input alphabet</p></li>
<li><p><b>S</b> is stack symbols</p></li>
<li><p><b>δ</b> is the transition function: Q &times; (&sum; &cup; {&epsilon;}) &times; S &times; Q &times; S*</p></li>
<li><p><b>q<sub>0</sub></b> is the initial state (q<sub>0</sub> &isin; Q)</p></li>
<li><p><b>I</b> is the initial stack top symbol (I &isin; S)</p></li>
<li><p><b>F</b> is a set of accepting states (F &isin; Q)</p></li>
</ul>
<p>The following diagram shows a transition in a PDA from a state q<sub>1</sub> to state q<sub>2</sub>, labeled as a,b &rarr; c &minus;</p>
<img src="/automata_theory/images/transition_in_a_pda.jpg" alt="Transition in a PDA" />
<p>This means at state <b>q<sub>1</sub></b>, if we encounter an input string <b>‘a’</b> and top symbol of the stack is <b>‘b’</b>, then we pop <b>‘b’</b>, push <b>‘c’</b> on top of the stack and move to state <b>q<sub>2</sub></b>.</p>
<h2>Terminologies Related to PDA</h2>
<h3>Instantaneous Description</h3>
<p>The instantaneous description (ID) of a PDA is represented by a triplet (q, w, s) where</p>
<ul class="list">
<li><p><b>q</b> is the state</p></li>
<li><p><b>w</b> is unconsumed input</p></li>
<li><p><b>s</b> is the stack contents</p></li>
</ul>
<h3>Turnstile Notation</h3>
<p>The "turnstile" notation is used for connecting pairs of ID's that represent one or many moves of a PDA. The process of transition is denoted by the turnstile symbol "&#8866;".</p>
<p>Consider a PDA (Q, &sum;, S, &delta;, q<sub>0</sub>, I, F). A transition can be mathematically represented by the following turnstile notation &minus;</p>
<pre class="result notranslate">
(p, aw, T&beta;) &#8866; (q, w, &alpha;b)
</pre>

<title>Automata Theory Useful Resources</title>

<h1>Automata Theory - Useful Resources</h1>

<p>The following resources contain additional information on Automata Theory. Please use them to get more in-depth knowledge on this.</p>

<h2>Useful Links on Automata Theory</h2>

<p><a rel="nofollow" target="_blank" href="https://en.wikipedia.org/wiki/Automata_theory">Automata Theory Wiki</a> -  Wikipedia Reference for Automata Theory.</p>

<p><a rel="nofollow" target="_blank" href="https://cs.stanford.edu/people/eroberts/courses/soco/projects/2004-05/automata-theory/basics.html">Automata Theory Basics</a> - Basics of Automata Theory</p>

<h2>Useful Books on Automata Theory</h2>

<p>To enlist your site on this page, please drop an email to <b>contact@tutorialspoint.com</b></p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Discuss Automata Theory</title>

<h1>Discuss Automata Theory</h1>

<p><b>Automata Theory</b> is a branch of computer science that deals with designing abstract selfpropelled computing devices that follow a predetermined sequence of operations automatically. An automaton with a finite number of states is called a <b>Finite Automaton</b>. This is a brief and concise tutorial that introduces the fundamental concepts of Finite Automata, Regular Languages, and Pushdown Automata before moving onto Turing machines and Decidability.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

</body></html>