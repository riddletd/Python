<!DOCTYPE html><html><body><title>Pascal Tutorial</title>

<h1>Pascal Tutorial</h1>

<p>Pascal is a procedural programming language, designed in 1968 and published in 1970 by Niklaus Wirth and named in honour of the French mathematician and philosopher Blaise Pascal. Pascal runs on a variety of platforms, such as Windows, Mac OS, and various versions of UNIX/Linux.</p>

<p>This tutorial should introduce you to the understanding of Pascal to proceed with Delphi and other related frameworks etc.</p>

<h1>Audience</h1>

<p>This tutorial is designed for Software Professionals who are willing to learn Pascal Programming Language in simple and easy steps. This tutorial should give you basic understanding on Pascal Programming concepts, and after completing this tutorial, you should be at intermediate level of expertise from where you can take yourself to higher level of expertise.</p>

<h1>Prerequisites</h1>

<p>Before proceeding with this tutorial you should have a basic understanding of software basic concepts like what is source code, compiler, text editor and execution of programs, etc. If you already have understanding on any other computer programming language, then it will be an added advantage to proceed.</p>

<h1>Execute Pascal Online</h1>

<p>You do not need to have your own environment to start learning Pascal programming! We have set up an on-line compiler for you that can be used to compile and execute the programs on-line.</p>

<p>For most of the examples available in this tutorial, you will find a Try it option at the top right corner of the code box. Use it to verify the programs and check the outcome with different options. Feel free to modify any example and execute it online.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate tryit">
program HelloWorld;
uses crt;

(* Here the main program block starts *)
begin
   writeln('Hello, World!');
   readkey;
end. 
</pre>

<title>Pascal Overview</title>

<h1>Pascal - Overview</h1>

<p>Pascal is a general-purpose, high-level language that was originally developed by Niklaus Wirth in the early 1970s. It was developed for teaching programming as a systematic discipline and to develop reliable and efficient programs. </p>

<p>Pascal is Algol-based language and includes many constructs of Algol. Algol 60 is a subset of Pascal. Pascal offers several data types and programming structures. It is easy to understand and maintain the Pascal programs.</p>

<p>Pascal has grown in popularity in the teaching and academics arena for various reasons:</p>

<p>Easy to learn.</p>

<p>Structured language.</p>

<p>It produces transparent, efficient and reliable programs.</p>

<p>It can be compiled on a variety of computer platforms.</p>

<h2>Features of the Pascal Language</h2>

<p>Pascal has the following features &minus;</p>

<p>Pascal is a strongly typed language.</p>

<p>It offers extensive error checking.</p>

<p>It offers several data types like arrays, records, files and sets.</p>

<p>It offers a variety of programming structures.</p>

<p>It supports structured programming through functions and procedures.</p>

<p>It supports object oriented programming.</p>

<h2>Facts about Pascal</h2>

<p>The Pascal language was named for Blaise Pascal, French mathematician and pioneer in computer development.</p>

<p>Niklaus Wirth completed development of the original Pascal programming language in 1970.</p>

<p>Pascal is based on the block structured style of the Algol programming language.</p>

<p>Pascal was developed as a language suitable for teaching programming as a systematic discipline, whose implementations could be both reliable and efficient.</p>

<p>The ISO 7185 Pascal Standard was originally published in 1983.</p>

<p>Pascal was the primary high-level language used for development in the Apple Lisa, and in the early years of the Mac.</p>

<p>In 1986, Apple Computer released the first Object Pascal implementation, and in 1993, the Pascal Standards Committee published an Object-Oriented Extension to Pascal.</p>

<h2>Why to use Pascal?</h2>

<p>Pascal allows the programmers to define complex structured data types and build dynamic and recursive data structures, such as lists, trees and graphs. Pascal offers features like records, enumerations, subranges, dynamically allocated variables with associated pointers and sets. </p>

<p>Pascal allows nested procedure definitions to any level of depth. This truly provides a great programming environment for learning  programming as a systematic discipline based on the fundamental concepts.</p>

<p>Among the most amazing implementations of Pascal are &minus;</p>

<p>Skype</p>

<p>Total Commander</p>

<p>TeX</p>

<p>Macromedia Captivate</p>

<p>Apple Lisa</p>

<p>Various PC Games</p>

<p>Embedded Systems</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Pascal Environment Set Up</title>

<h1>Pascal - Environment Set Up</h1>

<h3>Try it Option Online</h3>

<p>We have set up the Pascal Programming environment online, so that you can compile and execute all the available examples online. It gives you confidence in what you are reading and enables you to verify the programs with different options. Feel free to modify any example and execute it online.</p>

<p>Try the following example using our online compiler available at <a href="http://www.tutorialspoint.com/codingground.htm">CodingGround</a></p>

<p>For most of the examples given in this tutorial, you will find a Try it option in our website code sections at the top right corner that will take you to the online compiler. So just make use of it and enjoy your learning.</p>

<p>There are several Pascal compilers and interpreters available for general use. Among these are &minus;</p>

<p><b>Turbo Pascal</b> &minus; provides an IDE and compiler for running Pascal programs on CP/M, CP/M-86, DOS, Windows and Macintosh.</p>

<p><b>Delphi</b> &minus; provides compilers for running Object Pascal and generates native code for 32- and 64-bit Windows operating systems, as well as 32-bit Mac OS X and iOS. Embarcadero is planning to build support for the Linux and Android operating system.</p>

<p><b>Free Pascal</b> &minus; it is a free compiler for running Pascal and Object Pascal programs. Free Pascal compiler is a 32- and 64-bit Turbo Pascal and Delphi compatible Pascal compiler for Linux, Windows, OS/2, FreeBSD, Mac OS X, DOS and several other platforms.</p>

<p><b>Turbo51</b> &minus; It is a free Pascal compiler for the 8051 family of microcontrollers, with Turbo Pascal 7 syntax.</p>

<p><b>Oxygene</b> &minus; It is an Object Pascal compiler for the .NET and Mono platforms.</p>

<p><b>GNU Pascal (GPC)</b> &minus; It is a Pascal compiler composed of a front end to GNU Compiler Collection.</p>

<p>We will be using Free Pascal in these tutorials. You can download Free Pascal for your operating system from the link: <a rel="nofollow" target="_blank" href="http://www.freepascal.org/download.var">Download Free Pascal</a></p>

<h2>Installing Free Pascal on Linux</h2>

<p>The Linux distribution of Free Pascal comes in three forms &minus;</p>

<p>a <b>tar.gz</b> version, also available as separate files.</p>

<p>a <b>.rpm</b> (Red Hat Package Manager) version.</p>

<p>a <b>.deb</b> (Debian) version.</p>

<p>Installation code for the .rpm version:: </p>

<p>Where X.Y.Z is the version number of the .rpm file, and ARCH is one of the supported architectures (i386, x86_64, etc.).</p>

<p>Installation code for the Debian version (like Ubuntu): </p>

<p>Where XXX is the  version number of the .deb file.</p>

<p>For details read: <a rel="nofollow" target="_blank" href="http://www.freepascal.org/docs-html/user/usersu5.html">Free Pascal Installation Guide</a></p>

<h2>Installing Free Pascal on Mac</h2>

<p>If you use Mac OS X, the easiest way to use Free Pascal is to download the Xcode development environment from Apple's web site and follow the simple installation instructions. Once you have Xcode setup, you will be able to use the Free Pascal compiler.</p>

<h2>Installing Free Pascal on Windows </h2>

<p>For Windows, you will download the Windows installer, setup.exe. This is a usual installation program. You need to take the following steps for installation &minus;</p>

<p>Select a directory.</p>

<p>Select parts of the package you want to install.</p>

<p>Optionally choose to associate the .pp or .pas extensions with the Free Pascal IDE.</p>

<p>For details read: <a rel="nofollow" target="_blank" href="http://www.freepascal.org/docs-html/user/usersu3.html">Free Pascal Installation Guide</a></p>

<h2>Text Editor</h2>

<p>This will be used to type your program. Examples of few editors include Windows Notepad, OS Edit command, Brief, Epsilon, EMACS, and vim or vi.</p>

<p>Name and version of text editor can vary on different operating systems. For example, Notepad will be used on Windows and vim or vi can be used on windows as well as Linux or UNIX.</p>

<p>The files you create with your editor are called source files and contain program source code. The source files for Pascal programs are typically named with the extension <b>.pas</b>.</p>

<p>Before starting your programming, make sure you have one text editor in place and you have enough experience to write a computer program, save it in a file, compile it and finally execute it.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate tryit">
program HelloWorld;
uses crt;

(* Here the main program block starts *)
begin
   writeln('Hello, World!');
   readkey;
end. 
</pre>
<p>For most of the examples given in this tutorial, you will find a Try it option in our website code sections at the top right corner that will take you to the online compiler. So just make use of it and enjoy your learning.</p>
</blockquote>
<p>There are several Pascal compilers and interpreters available for general use. Among these are &minus;</p>
<ul class="list">
<li><p><b>Turbo Pascal</b> &minus; provides an IDE and compiler for running Pascal programs on CP/M, CP/M-86, DOS, Windows and Macintosh.</p></li>
<li><p><b>Delphi</b> &minus; provides compilers for running Object Pascal and generates native code for 32- and 64-bit Windows operating systems, as well as 32-bit Mac OS X and iOS. Embarcadero is planning to build support for the Linux and Android operating system.</p></li>
<li><p><b>Free Pascal</b> &minus; it is a free compiler for running Pascal and Object Pascal programs. Free Pascal compiler is a 32- and 64-bit Turbo Pascal and Delphi compatible Pascal compiler for Linux, Windows, OS/2, FreeBSD, Mac OS X, DOS and several other platforms.</p></li>
<li><p><b>Turbo51</b> &minus; It is a free Pascal compiler for the 8051 family of microcontrollers, with Turbo Pascal 7 syntax.</p></li>
<li><p><b>Oxygene</b> &minus; It is an Object Pascal compiler for the .NET and Mono platforms.</p></li>
<li><p><b>GNU Pascal (GPC)</b> &minus; It is a Pascal compiler composed of a front end to GNU Compiler Collection.</p></li>
</ul>
<p>We will be using Free Pascal in these tutorials. You can download Free Pascal for your operating system from the link: <a rel="nofollow" target="_blank" href="http://www.freepascal.org/download.var">Download Free Pascal</a></p>
<h2>Installing Free Pascal on Linux</h2>
<p>The Linux distribution of Free Pascal comes in three forms &minus;</p>
<ul class="list">
<li><p>a <b>tar.gz</b> version, also available as separate files.</p></li>
<li><p>a <b>.rpm</b> (Red Hat Package Manager) version.</p></li>
<li><p>a <b>.deb</b> (Debian) version.</p></li>
</ul>
<p>Installation code for the .rpm version:: </p>
<pre class="prettyprint notranslate">
rpm -i fpc-X.Y.Z-N.ARCH.rpm
</pre>
<p>Where X.Y.Z is the version number of the .rpm file, and ARCH is one of the supported architectures (i386, x86_64, etc.).</p>
<p>Installation code for the Debian version (like Ubuntu): </p>
<pre class="prettyprint notranslate">
dpkg -i fpc-XXX.deb
</pre>

<title>Pascal Program Structures</title>

<h1>Pascal - Program Structures</h1>

<p>Before we study basic building blocks of the Pascal programming language, let us look a bare minimum Pascal program structure so that we can take it as a reference in upcoming chapters.</p>

<h2>Pascal Program Structure</h2>

<p>A Pascal program basically consists of the following parts &minus;</p>

<p>Every pascal program generally has a heading statement, a declaration and an execution part strictly in that order. Following format shows the basic syntax for a Pascal program &minus;</p>

<h2>Pascal Hello World Example</h2>

<p>Following is a simple pascal code that would print the words "Hello, World!":</p>

<p>This will produce following result &minus;</p>

<p>Let us look various parts of the above program &minus;</p>

<p>The first line of the program <b>program HelloWorld;</b> indicates the name of the program.</p>

<p>The second line of the program <b>uses crt;</b> is a preprocessor command, which tells the compiler to include the crt unit before going to actual compilation.</p>

<p>The next lines enclosed within begin and end statements are the main program block. Every block in Pascal is enclosed within a <b>begin</b> statement and an <b>end</b> statement. However, the end statement indicating the end of the main program is followed by a full stop (.) instead of semicolon (;). </p>

<p>The <b>begin</b> statement of the main program block is where the program execution begins.</p>

<p>The lines within  <b>(*...*)</b> will be ignored by the compiler and it has been put to add a <b>comment</b> in the program. </p>

<p>The statement <b>writeln('Hello, World!');</b> uses the writeln function available in Pascal which causes the message "Hello, World!" to be displayed on the screen.</p>

<p>The statement <b>readkey;</b> allows the display to pause until the user presses a key. It is part of the crt unit. A unit is like a library in Pascal.</p>

<p>The last statement <b>end.</b> ends your program.</p>

<h2>Compile and Execute Pascal Program</h2>

<p>Open a text editor and add the above-mentioned code.</p>

<p>Save the file as <i>hello.pas</i></p>

<p>Open a command prompt and go to the directory, where you saved the file.</p>

<p>Type fpc hello.pas at command prompt and press enter to compile your code.</p>

<p>If there are no errors in your code, the command prompt will take you to the next line and would generate <b>hello</b> executable file and <b>hello.o</b> object file.</p>

<p>Now, type <b>hello</b> at command prompt to execute your program.</p>

<p>You will be able to see "Hello World" printed on the screen and program waits till you press any key.</p>

<p>Make sure that free pascal compiler <b>fpc</b> is in your path and that you are running it in the directory containing source file hello.pas.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
program {name of the program}
uses {comma delimited names of libraries you use}
const {global constant declaration block}
var {global variable declaration block}

function {function declarations, if any}
{ local variables }
begin
...
end;

procedure { procedure declarations, if any}
{ local variables }
begin
...
end;

begin { main program block starts}
...
end. { the end of main program block }
</pre>
<h2>Pascal Hello World Example</h2>
<p>Following is a simple pascal code that would print the words "Hello, World!":</p>
<pre class="prettyprint notranslate tryit">
program HelloWorld;
uses crt;

(* Here the main program block starts *)
begin
   writeln('Hello, World!');
   readkey;
end. 
</pre>
<p>This will produce following result &minus;</p>
<pre class="result notranslate">
Hello, World!
</pre>
<p>Let us look various parts of the above program &minus;</p>
<ul class="list">
<li><p>The first line of the program <b>program HelloWorld;</b> indicates the name of the program.</p></li>
<li><p>The second line of the program <b>uses crt;</b> is a preprocessor command, which tells the compiler to include the crt unit before going to actual compilation.</p></li>
<li><p>The next lines enclosed within begin and end statements are the main program block. Every block in Pascal is enclosed within a <b>begin</b> statement and an <b>end</b> statement. However, the end statement indicating the end of the main program is followed by a full stop (.) instead of semicolon (;). </p></li>
<li><p>The <b>begin</b> statement of the main program block is where the program execution begins.</p></li>
<li><p>The lines within  <b>(*...*)</b> will be ignored by the compiler and it has been put to add a <b>comment</b> in the program. </p></li>
<li><p>The statement <b>writeln('Hello, World!');</b> uses the writeln function available in Pascal which causes the message "Hello, World!" to be displayed on the screen.</p></li>
<li><p>The statement <b>readkey;</b> allows the display to pause until the user presses a key. It is part of the crt unit. A unit is like a library in Pascal.</p></li>
<li><p>The last statement <b>end.</b> ends your program.</p></li>
</ul>
<h2>Compile and Execute Pascal Program</h2>
<ul class="list">
<li><p>Open a text editor and add the above-mentioned code.</p></li>
<li><p>Save the file as <i>hello.pas</i></p></li>
<li><p>Open a command prompt and go to the directory, where you saved the file.</p></li>
<li><p>Type fpc hello.pas at command prompt and press enter to compile your code.</p></li>
<li><p>If there are no errors in your code, the command prompt will take you to the next line and would generate <b>hello</b> executable file and <b>hello.o</b> object file.</p></li>
<li><p>Now, type <b>hello</b> at command prompt to execute your program.</p></li>
<li><p>You will be able to see "Hello World" printed on the screen and program waits till you press any key.</p></li>
</ul>
<pre class="prettyprint notranslate">
$ fpc hello.pas
Free Pascal Compiler version 2.6.0 [2011/12/23] for x86_64
Copyright (c) 1993-2011 by Florian Klaempfl and others
Target OS: Linux for x86-64
Compiling hello.pas
Linking hello
8 lines compiled, 0.1 sec

$ ./hello
Hello, World!
</pre>

<title>Pascal Basic Syntax</title>

<h1>Pascal - Basic Syntax</h1>

<p>You have seen a basic structure of pascal program, so it will be easy to understand other basic building blocks of the pascal programming language.</p>

<h2>Variables</h2>

<p>A variable definition is put in a block beginning with a <b>var</b> keyword, followed by definitions of the variables as follows:</p>

<p>Pascal variables are declared outside the code-body of the function which means they are not declared within the <b>begin</b> and <b>end</b> pairs, but they are declared after the definition of the procedure/function and before the <b>begin</b> keyword. For global variables, they are defined after the program header.</p>

<h2>Functions/Procedures</h2>

<p>In Pascal, a <b>procedure</b> is set of instructions to be executed, with no return value and a <b>function</b> is a procedure with a return value. The definition of function/procedures will be as follows &minus;</p>

<h2>Comments</h2>

<p>The multiline comments are enclosed within curly brackets and asterisks as {* ... *}. Pascal allows single-line comment enclosed within curly brackets { ... }. </p>

<h2>Case Sensitivity</h2>

<p>Pascal is a case non-sensitive language, which means you can write your variables, functions and procedure in either case. Like variables A_Variable, a_variable and A_VARIABLE have same meaning in Pascal.</p>

<h2>Pascal Statements </h2>

<p>Pascal programs are made of statements. Each statement specifies a definite job of the program. These jobs could be declaration, assignment, reading data, writing data, taking logical decisions, transferring program flow control, etc.</p>

<p>For example &minus;</p>

<h2> Reserved Words in Pascal</h2>

<p>The statements in Pascal are designed with some specific Pascal words, which are called the reserved words. For example, the words, program, input, output, var, real, begin, readline, writeline and end are all reserved words.</p>

<p>Following is a list of reserved words available in Pascal.</p>

<h2>Character set and Identifiers in Pascal</h2>

<p>The Pascal character set consists of &minus;</p>

<p>All upper case letters (A-Z)</p>

<p>All lower case letters (a-z)</p>

<p>All digits (0-9)</p>

<p>Special symbols   - + * / := , . ;. () [] = {} ` white space</p>

<p>The entities in a Pascal program like variables and constants, types, functions, procedures and records, etc., have a name or identifier.  An identifier is a sequence of letters and digits, beginning with a letter. Special symbols and blanks must not be used in an identifier.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
var
A_Variable, B_Variable ... : Variable_Type;
</pre>
<p>Pascal variables are declared outside the code-body of the function which means they are not declared within the <b>begin</b> and <b>end</b> pairs, but they are declared after the definition of the procedure/function and before the <b>begin</b> keyword. For global variables, they are defined after the program header.</p>
<h2>Functions/Procedures</h2>
<p>In Pascal, a <b>procedure</b> is set of instructions to be executed, with no return value and a <b>function</b> is a procedure with a return value. The definition of function/procedures will be as follows &minus;</p>
<pre class="prettyprint notranslate">
Function Func_Name(params...) : Return_Value;
Procedure Proc_Name(params...);
</pre>
<h2>Comments</h2>
<p>The multiline comments are enclosed within curly brackets and asterisks as {* ... *}. Pascal allows single-line comment enclosed within curly brackets { ... }. </p>
<pre class="prettyprint notranslate">
{* This is a multi-line comments
   and it will span multiple lines. *}

{ This is a single line comment in pascal }
</pre>
<h2>Case Sensitivity</h2>
<p>Pascal is a case non-sensitive language, which means you can write your variables, functions and procedure in either case. Like variables A_Variable, a_variable and A_VARIABLE have same meaning in Pascal.</p>
<h2>Pascal Statements </h2>
<p>Pascal programs are made of statements. Each statement specifies a definite job of the program. These jobs could be declaration, assignment, reading data, writing data, taking logical decisions, transferring program flow control, etc.</p>
<p>For example &minus;</p>
<pre class="prettyprint notranslate">
readln (a, b, c);
s := (a + b + c)/2.0;
area := sqrt(s * (s - a)*(s-b)*(s-c));
writeln(area);        
</pre>

<title>Pascal Data Types</title>

<h1>Pascal - Data Types</h1>

<p>Data types of an entity indicates the meaning, constraints, possible values, operations, functions and mode of storage associated with it.</p>

<p>Integer, real, Boolean and character types are referred as standard data types. Data types can be categorized as scalar, pointer and structured data types. Examples of scalar data types are integer, real, Boolean, character, subrange and enumerated. Structured data types are made of the scalar types; for example, arrays, records, files and sets. We will discuss the pointer data types later.</p>

<h2>Pascal Data Types</h2>

<p>Pascal data types can be summarized as below in the following diagram &minus;</p>

<h2>Type Declarations</h2>

<p>The type declaration is used to declare the data type of an identifier. Syntax of type declaration is &minus;</p>

<p>For example, the following declaration defines the variables days and age as integer type, yes and true as Boolean type, name and city as string type, fees and expenses as real type.</p>

<h2>Integer Types</h2>

<p>Following table gives you details about standard integer types with its storage sizes and value ranges used in Object Pascal &minus;</p>

<h2>Constants</h2>

<p>Use of constants makes a program more readable and helps to keep special quantities at one place in the beginning of the program. Pascal allows <i>numerical, logical, string</i> and <i>character</i> constants. Constants can be declared in the declaration part of the program by specifying the <b>const</b> declaration.</p>

<p>Syntax of constant type declaration is follows &minus;</p>

<p>Following are some examples of constant declarations &minus;</p>

<p>All constant declarations must be given before the variable declaration.</p>

<h2>Enumerated types</h2>

<p>Enumerated data types are user-defined data types. They allow values to be specified in a list. Only <i>assignment</i> operators and <i>relational</i> operators are permitted on enumerated data type. Enumerated data types can be declared as follows &minus;</p>

<p>Following are some examples of enumerated  type declarations &minus;</p>

<p>The order in which the items are listed in the domain of an enumerated type defines the order of the items. For example, in the enumerated type SUMMER, April comes before May, May comes before June, and so on. The domain of enumerated type identifiers cannot consist of numeric or character constants.</p>

<h2>Subrange Types</h2>

<p>Subrange types allow a variable to assume values that lie within a certain range. For example, if the <i>age</i> of voters should lie between 18 to 100 years, a variable named age could be declared as &minus;</p>

<p>We will look at variable declaration in detail in the next section. You can also define a subrange type using the type declaration. Syntax for declaring a subrange type is as follows &minus;</p>

<p>Following are some examples of subrange type declarations &minus;</p>

<p>Subrange types can be created from a subset of an already defined enumerated type, For example &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
 type-identifier-1, type-identfier-2 = type-specifier;
</pre>
<p>For example, the following declaration defines the variables days and age as integer type, yes and true as Boolean type, name and city as string type, fees and expenses as real type.</p>
<pre class="prettyprint notranslate">
type
days, age = integer;
yes, true = boolean;
name, city = string;
fees, expenses = real;
</pre>
<h2>Integer Types</h2>
<p>Following table gives you details about standard integer types with its storage sizes and value ranges used in Object Pascal &minus;</p>
<table class="table table-bordered">
<tr>
<th>Type</th>
<th>Minimum</th>
<th>Maximum</th>
<th>Format</th>
</tr>
<tr>
<td>Integer</td>
<td>-2147483648</td>
<td>2147483647</td>
<td>signed 32-bit</td>
</tr>
<tr>
<td>Cardinal</td>
<td>0</td>
<td>4294967295</td>
<td>unsigned 32-bit</td></tr>
<tr>
<td>Shortint</td>
<td> -128</td>
<td>127</td>
<td>signed 8-bit</td>
</tr>
<tr>
<td>Smallint</td>
<td> -32768</td>
<td>32767</td>
<td>signed 16-bit</td>
</tr>
<tr>
<td>Longint</td>
<td> -2147483648</td>
<td>2147483647</td>
<td>signed 32-bit</td>
</tr>
<tr>
<td>Int64</td>
<td> -2^63</td>
<td>2^63 - 1</td>
<td>signed 64-bit</td>
</tr>
<tr>
<td>Byte</td>
<td>0</td>
<td>255</td>
<td>unsigned 8-bit</td>
</tr>
<tr>
<td>Word</td>
<td>0</td>
<td>65535</td>
<td>unsigned 16-bit</td>
</tr>
<tr>
<td>Longword</td>
<td>0</td>
<td>4294967295</td>
<td>unsigned 32-bit</td>
</tr>
</table>
<h2>Constants</h2>
<p>Use of constants makes a program more readable and helps to keep special quantities at one place in the beginning of the program. Pascal allows <i>numerical, logical, string</i> and <i>character</i> constants. Constants can be declared in the declaration part of the program by specifying the <b>const</b> declaration.</p>
<p>Syntax of constant type declaration is follows &minus;</p>
<pre class="prettyprint notranslate">
const
Identifier = contant_value;
</pre>
<p>Following are some examples of constant declarations &minus;</p>
<pre class="prettyprint notranslate">
VELOCITY_LIGHT = 3.0E=10;
PIE = 3.141592;
NAME = 'Stuart Little';
CHOICE = yes;
OPERATOR = '+';
</pre>
<p>All constant declarations must be given before the variable declaration.</p>
<h2>Enumerated types</h2>
<p>Enumerated data types are user-defined data types. They allow values to be specified in a list. Only <i>assignment</i> operators and <i>relational</i> operators are permitted on enumerated data type. Enumerated data types can be declared as follows &minus;</p>
<pre class="prettyprint notranslate">
type
enum-identifier = (item1, item2, item3, ... )
</pre>
<p>Following are some examples of enumerated  type declarations &minus;</p>
<pre class="prettyprint notranslate">
type
SUMMER = (April, May, June, July, September);
COLORS = (Red, Green, Blue, Yellow, Magenta, Cyan, Black, White);
TRANSPORT = (Bus, Train, Airplane, Ship);
</pre>
<p>The order in which the items are listed in the domain of an enumerated type defines the order of the items. For example, in the enumerated type SUMMER, April comes before May, May comes before June, and so on. The domain of enumerated type identifiers cannot consist of numeric or character constants.</p>
<h2>Subrange Types</h2>
<p>Subrange types allow a variable to assume values that lie within a certain range. For example, if the <i>age</i> of voters should lie between 18 to 100 years, a variable named age could be declared as &minus;</p>
<pre class="prettyprint notranslate">
var
age: 18 ... 100;
</pre>
<p>We will look at variable declaration in detail in the next section. You can also define a subrange type using the type declaration. Syntax for declaring a subrange type is as follows &minus;</p>
<pre class="prettyprint notranslate">
type
subrange-identifier = lower-limit ... upper-limit;
</pre>
<p>Following are some examples of subrange type declarations &minus;</p>
<pre class="prettyprint notranslate">
const
P = 18;
Q = 90;
type
Number = 1 ... 100;
Value = P ... Q;
</pre>
<p>Subrange types can be created from a subset of an already defined enumerated type, For example &minus;</p>
<pre class="prettyprint notranslate">
type
months = (Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec);
Summer = Apr ... Aug;
Winter = Oct ... Dec;
</pre>

<title>Pascal Variable Types</title>

<h1>Pascal - Variable Types</h1>

<p>A variable is nothing but a name given to a storage area that our programs can manipulate. Each variable in Pascal has a specific type, which determines the size and layout of the variable's memory; the range of values that can be stored within that memory; and the set of operations that can be applied to the variable.</p>

<p>The name of a variable can be composed of letters, digits, and the underscore character. It must begin with either a letter or an underscore. Pascal is <b>not case-sensitive</b>, so uppercase and lowercase letters mean same here. Based on the basic types explained in previous chapter, there will be following basic variable types &minus;</p>

<h2>Basic Variables in Pascal</h2>

<p>Pascal programming language also allows defining various other types of variables, which we will cover in subsequent chapters like Pointer, Array, Records, Sets, and Files, etc. For this chapter, let us study only basic variable types.</p>

<h2>Variable Declaration in Pascal</h2>

<p>All variables must be declared before we use them in Pascal program. All variable declarations are followed by the <i>var</i> keyword. A declaration specifies a list of variables, followed by a colon (:) and the type. Syntax of variable declaration is &minus;</p>

<p>Here, type must be a valid Pascal data type including character, integer, real, boolean, or any user-defined data type, etc., and variable_list may consist of one or more identifier names separated by commas. Some valid variable declarations are shown here &minus;</p>

<p>In the previous tutorial, we have discussed that Pascal allows declaring a type. A type can be identified by a name or identifier. This type can be used to define variables of that type. For example,</p>

<p>Now, the types so defined can be used in variable declarations &minus;</p>

<p>Please note the difference between <i>type</i> declaration and <i>var</i> declaration. Type declaration indicates the category or class of the types such as integer, real, etc., whereas the variable specification indicates the type of values a variable may take. You can compare <i>type</i> declaration in Pascal with <i>typedef</i> in C. Most importantly, the variable name refers to the memory location where the value of the variable is going to be stored. This is not so with the type declaration.</p>

<h2>Variable Initialization in Pascal</h2>

<p>Variables are assigned a value with a colon and the equal sign, followed by a constant expression. The general form of assigning a value is &minus;</p>

<p>By default, variables in Pascal are not initialized with zero. They may contain rubbish values. So it is a better practice to initialize variables in a program. Variables can be initialized (assigned an initial value) in their declaration. The initialization is followed by the <b>var</b> keyword and the syntax of initialization is as follows &minus;</p>

<p>Some examples are &minus;</p>

<p>Let us look at an example, which makes use of various types of variables discussed so far &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<h2>Enumerated Variables</h2>

<p>You have seen how to use simple variable types like integer, real and boolean. Now, let's see variables of enumerated type, which can be defined as &minus;</p>

<p>When you have declared an enumerated type, you can declare variables of that type. For example,</p>

<p>The following example illustrates the concept &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<h2>Subrange Variables</h2>

<p>Subrange variables are declared as &minus;</p>

<p>Examples of subrange variables are &minus;</p>

<p>The following program illustrates the concept &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
var
variable_list : type;
</pre>
<p>Here, type must be a valid Pascal data type including character, integer, real, boolean, or any user-defined data type, etc., and variable_list may consist of one or more identifier names separated by commas. Some valid variable declarations are shown here &minus;</p>
<pre class="prettyprint notranslate">
var
age, weekdays : integer;
taxrate, net_income: real;
choice, isready: boolean;
initials, grade: char;
name, surname : string;
</pre>
<p>In the previous tutorial, we have discussed that Pascal allows declaring a type. A type can be identified by a name or identifier. This type can be used to define variables of that type. For example,</p>
<pre class="prettyprint notranslate">
type
days, age = integer;
yes, true = boolean;
name, city = string;
fees, expenses = real;
</pre>
<p>Now, the types so defined can be used in variable declarations &minus;</p>
<pre class="prettyprint notranslate">
var
weekdays, holidays : days;
choice: yes;
student_name, emp_name : name;
capital: city;
cost: expenses;
</pre>
<p>Please note the difference between <i>type</i> declaration and <i>var</i> declaration. Type declaration indicates the category or class of the types such as integer, real, etc., whereas the variable specification indicates the type of values a variable may take. You can compare <i>type</i> declaration in Pascal with <i>typedef</i> in C. Most importantly, the variable name refers to the memory location where the value of the variable is going to be stored. This is not so with the type declaration.</p>
<h2>Variable Initialization in Pascal</h2>
<p>Variables are assigned a value with a colon and the equal sign, followed by a constant expression. The general form of assigning a value is &minus;</p>
<pre class="prettyprint notranslate">
variable_name := value;
</pre>
<p>By default, variables in Pascal are not initialized with zero. They may contain rubbish values. So it is a better practice to initialize variables in a program. Variables can be initialized (assigned an initial value) in their declaration. The initialization is followed by the <b>var</b> keyword and the syntax of initialization is as follows &minus;</p> 
<pre class="prettyprint notranslate">
var
variable_name : type = value;
</pre>
<p>Some examples are &minus;</p>
<pre class="prettyprint notranslate">
age: integer = 15;
taxrate: real = 0.5;
grade: char = 'A';
name: string = 'John Smith';
</pre>
<p>Let us look at an example, which makes use of various types of variables discussed so far &minus;</p>
<pre class="prettyprint notranslate tryit">
program Greetings;
const
message = ' Welcome to the world of Pascal ';

type
name = string;
var
firstname, surname: name;

begin
   writeln('Please enter your first name: ');
   readln(firstname);
   
   writeln('Please enter your surname: ');
   readln(surname);
   
   writeln;
   writeln(message, ' ', firstname, ' ', surname);
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Please enter your first name:
John
Please enter your surname:
Smith
Welcome to the world of Pascal John Smith
</pre>
<h2>Enumerated Variables</h2>
<p>You have seen how to use simple variable types like integer, real and boolean. Now, let's see variables of enumerated type, which can be defined as &minus;</p>
<pre class="prettyprint notranslate">
var
var1, var2, ...  : enum-identifier;
</pre>
<p>When you have declared an enumerated type, you can declare variables of that type. For example,</p>
<pre class="prettyprint notranslate">
type
months = (January, February, March, April, May, June, July, August, September, October, November, December);
Var
m: months;
...
M := January;
</pre>
<p>The following example illustrates the concept &minus;</p>
<pre class="prettyprint notranslate tryit">
program exEnumeration;
type
beverage = (coffee, tea, milk, water, coke, limejuice);

var
drink:beverage;

begin
   writeln('Which drink do you want?');
   drink := limejuice;
   
   writeln('You can drink ', drink);
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Which drink do you want?
You can drink limejuice
</pre>
<h2>Subrange Variables</h2>
<p>Subrange variables are declared as &minus;</p>
<pre class="prettyprint notranslate">
var
subrange-name : lowerlim ... uperlim;
</pre>
<p>Examples of subrange variables are &minus;</p>
<pre class="prettyprint notranslate">
var
marks: 1 ... 100;
grade: 'A' ... 'E';
age: 1 ... 25;
</pre>
<p>The following program illustrates the concept &minus;</p>
<pre class="prettyprint notranslate tryit">
program exSubrange;
var
marks: 1 .. 100;
grade: 'A' .. 'E';

begin
   writeln( 'Enter your marks(1 - 100): ');
   readln(marks);
   
   writeln( 'Enter your grade(A - E): ');
   readln(grade);
   
   writeln('Marks: ' , marks, ' Grade: ', grade);
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Enter your marks(1 - 100): 
100
Enter your grade(A - E):
A
Marks: 100 Grade: A
</pre>

<title>Pascal Constants</title>

<h1>Pascal - Constants</h1>

<p>A constant is an entity that remains unchanged during program execution. Pascal allows only constants of the following types to be declared &minus;</p>

<h2>Declaring Constants</h2>

<p>Syntax for declaring constants is as follows &minus;</p>

<p>The following table provides examples of some valid constant declarations &minus;</p>

<p>velocity_light = 3.0E+10;</p>

<p>The following example illustrates the concept &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<p>Observe the formatting in the output statement of the program. The variable c is to be formatted with total number of digits 7 and 2 digits after the decimal sign. Pascal allows such output formatting with the numerical variables.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
const
identifier = constant_value;
</pre>
<p>The following table provides examples of some valid constant declarations &minus;</p>
<table class="table table-bordered">
<tr>
<th>Constant Type</th>
<th>Examples</th>
</tr>
<tr>
<td>Ordinal(Integer)type constant</td>
<td>valid_age = 21; </td>
</tr>
<tr>
<td>Set type constant</td>
<td>Vowels = set of (A,E,I,O,U);</td>
</tr>
<tr>
<td>Pointer type constant</td>
<td>P = NIL;</td>
</tr>
<tr>
<td>Real type constant</td>
<td><p>e = 2.7182818; 
<p>velocity_light = 3.0E+10;</p>
</td>
</tr>
<tr>
<td>Character type constant</td>
<td>Operator = '+';</td>
</tr>
<tr>
<td>String type constant</td>
<td>president = 'Johnny Depp';</td>
</tr>
</table>
<p>The following example illustrates the concept &minus;</p>
<pre class="prettyprint notranslate tryit">
program const_circle (input,output);
const
PI = 3.141592654;

var
r, d, c : real;   {variable declaration: radius, dia, circumference}

begin
   writeln('Enter the radius of the circle');
   readln(r);
   
   d := 2 * r;
   c :=  PI * d;
   writeln('The circumference of the circle is ',c:7:2);
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Enter the radius of the circle
23
The circumference of the circle is 144.51
</pre>

<title>Pascal Operators</title>

<h1>Pascal - Operators</h1>

<p>An operator is a symbol that tells the compiler to perform specific mathematical or logical manipulations. Pascal allows the following types of operators &minus;</p>

<p>Let us discuss the arithmetic, relational, Boolean and bit operators one by one. We will discuss the set operators and string operations later.</p>

<h2>Arithmetic Operators</h2>

<p>Following table shows all the arithmetic operators supported by Pascal. Assume variable <b>A</b> holds 10 and variable <b>B</b> holds 20, then &minus;</p>

<p><a href="/pascal/pascal_arithmetic_operators.htm" title="Arithmetic Operators in Pascal">Show Examples</a></p>

<h2>Relational Operators</h2>

<p>Following table shows all the relational operators supported by Pascal. Assume variable <b>A</b> holds 10 and variable <b>B</b> holds 20, then &minus;</p>

<p><a href="/pascal/pascal_relational_operators.htm" title="Relational Operators in Pascal">Show Examples</a></p>

<h2>Boolean Operators</h2>

<p>Following table shows all the Boolean operators supported by Pascal language. All these operators work on Boolean operands and produce Boolean results. Assume variable <b>A</b> holds true and variable <b>B</b> holds false, then &minus;</p>

<p><a href="/pascal/pascal_boolean_operators.htm" title="Boolean Operators in Pascal">Show Examples</a></p>

<h2>Bit Operators</h2>

<p>Bitwise operators work on bits and perform bit-by-bit operation. All these operators work on integer operands and produces integer results. The truth table for bitwise and (&amp;), bitwise or (|), and bitwise not (~) are as follows &minus;</p>

<p>Assume if A = 60; and B = 13; now in binary format they will be as follows &minus;</p>

<p>A = 0011 1100</p>

<p>B = 0000 1101</p>

<p>-----------------</p>

<p>A&amp;B = 0000 1100</p>

<p>A^B = 0011 0001</p>

<p>~A&nbsp; = 1100 0011</p>

<p>The Bitwise operators supported by Pascal are listed in the following table. Assume variable A holds 60 and variable B holds 13, then:</p>

<p><a href="/pascal/pascal_bit_operators.htm" title="Bit Operators in Pascal">Show Examples</a></p>

<p>Please note that different implementations of Pascal differ in bitwise operators. Free Pascal, the compiler we used here, however, supports the following bitwise operators &minus;</p>

<h2>Operators Precedence in Pascal</h2>

<p>Operator precedence determines the grouping of terms in an expression. This affects how an expression is evaluated. Certain operators have higher precedence than others; for example, the multiplication operator has higher precedence than the addition operator.</p>

<p>For example x = 7 + 3 * 2; here, x is assigned 13, not 20 because operator * has higher precedence than +, so it first gets multiplied with 3*2 and then adds into 7.</p>

<p>Here, operators with the highest precedence appear at the top of the table, those with the lowest appear at the bottom. Within an expression, higher precedence operators will be evaluated first.</p>

<p><a href="/pascal/pascal_operators_precedence.htm" title="Operators Precedence in Pascal">Show Examples</a></p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Pascal Decision Making</title>

<h1>Pascal - Decision Making</h1>

<p>Decision making structures require that the programmer specify one or more conditions to be evaluated or tested by the program, along with a statement or statements to be executed if the condition is determined to be true, and optionally, other statements to be executed if the condition is determined to be false.</p>

<p>Following is the general form of a typical decision making structure found in most of the programming languages &minus;</p>

<p>Pascal programming language provides the following types of decision making statements. Click the following links to check their detail.</p>

<p><a href="/pascal/pascal_if_then_statement.htm" title="if then statement in Pascal">if - then statement</a></p>

<p><a href="/pascal/pascal_if_then_else_statement.htm" title="if then else statement in Pascal">If-then-else statement</a></p>

<p><a href="/pascal/pascal_nested_if_statement.htm" title="nested if statements in Pascal">nested if statements</a></p>

<p><a href="/pascal/pascal_case_statement.htm" title="case statement in Pascal">case statement</a></p>

<p><a href="/pascal/pascal_case_else_statement.htm" title="case else statement in Pascal">case - else statement</a></p>

<p><a href="/pascal/pascal_nested_case_statement.htm" title="nested case statements in Pascal">nested case statements</a></p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Pascal Loops</title>

<h1>Pascal - Loops</h1>

<p>There may be a situation, when you need to execute a block of code several number of times. In general, statements are executed sequentially: The first statement in a function is executed first, followed by the second, and so on.</p>

<p>Programming languages provide various control structures that allow for more complicated execution paths.</p>

<p>A loop statement allows us to execute a statement or group of statements multiple times and following is the general form of a loop statement in most of the programming languages &minus;</p>

<p>Pascal programming language provides the following types of loop constructs to handle looping requirements. Click the following links to check their details.</p>

<p><a href="/pascal/pascal_while_do_loop.htm" title="while-do loop in Pascal">while-do loop</a></p>

<p><a href="/pascal/pascal_for_do_loop.htm" title="for loop in Pascal">for-do  loop</a></p>

<p><a href="/pascal/pascal_repeat_until_loop.htm" title="repeat-until loop in Pascal">repeat-until loop</a></p>

<p><a href="/pascal/pascal_nested_loops.htm" title="nested loops in Pascal">nested loops</a></p>

<h2>Loop Control Statements</h2>

<p>Loop control statements change execution from its normal sequence. When execution leaves a scope, all automatic objects that were created in that scope are destroyed.</p>

<p>Pascal supports the following control statements. Click the following links to check their details. </p>

<p><a href="/pascal/pascal_break_statement.htm" title="break statement in Pascal">break statement</a></p>

<p><a href="/pascal/pascal_continue_statement.htm" title="continue statement in Pascal">continue statement</a></p>

<p><a href="/pascal/pascal_goto_statement.htm" title="goto statement in Pascal">goto statement</a></p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Pascal Functions</title>

<h1>Pascal - Functions</h1>

<h2>Subprograms</h2>

<p>A subprogram is a program unit/module that performs a particular task. These subprograms are combined to form larger programs. This is basically called the 'Modular design.' A subprogram can be invoked by a subprogram/program, which is called the calling program.</p>

<p>Pascal provides two kinds of subprograms &minus;</p>

<p><b>Functions</b> &minus; these subprograms return a single value. </p>

<p><b>Procedures</b> &minus; these subprograms do not return a value directly.</p>

<h2>Functions</h2>

<p>A <b>function</b> is a group of statements that together perform a task. Every Pascal program has at least one function, which is the program itself, and all the most trivial programs can define additional functions.</p>

<p>A function <b>declaration</b> tells the compiler about a function's name, return type, and parameters. A function <b>definition</b> provides the actual body of the function.</p>

<p>Pascal standard library provides numerous built-in functions that your program can call. For example, function <b>AppendStr()</b> appends two strings, function <b>New()</b> dynamically allocates memory to variables and many more functions.</p>

<h2>Defining a Function</h2>

<p>In Pascal, a <b>function</b> is defined using the function keyword. The general form of a function definition is as follows &minus;</p>

<p>A function definition in Pascal consists of a function <b>header</b>, local <b>declarations</b> and a function <b>body</b>. The function header consists of the keyword function and a <b>name</b> given to the function. Here are all the parts of a function &minus;</p>

<p><b>Arguments</b> &minus; The argument(s) establish the linkage between the calling program and the function identifiers and also called the formal parameters. A parameter is like a placeholder. When a function is invoked, you pass a value to the parameter. This value is referred to as actual parameter or argument. The parameter list refers to the type, order, and number of parameters of a function. Use of such formal parameters is optional. These parameters may have standard data type, user-defined data type or subrange data type.</p>

<p>The formal parameters list appearing in the function statement could be simple or subscripted variables, arrays or structured variables, or subprograms.</p>

<p><b>Return Type</b> &minus; All functions must return a value, so all functions must be assigned a type. The <b>function-type</b> is the data type of the value the function returns. It may be standard, user-defined scalar or subrange type but it cannot be structured type.</p>

<p><b>Local declarations</b> &minus; Local declarations refer to the declarations for labels, constants, variables, functions and procedures, which are application to the body of function only.</p>

<p><b>Function Body</b> &minus; The function body contains a collection of statements that define what the function does. It should always be enclosed between the reserved words begin and end.  It is the part of a function where all computations are done. There must be an assignment statement of the type - <b>name := expression;</b> in the function body that assigns a value to the function name. This value is returned as and when the function is executed. The last statement in the body must be an end statement.</p>

<p>Following is an example showing how to define a function in pascal &minus;</p>

<h2>Function Declarations</h2>

<p>A function <b>declaration</b> tells the compiler about a function name and how to call the function. The actual body of the function can be defined separately.</p>

<p>A function declaration has the following parts &minus;</p>

<p>For the above-defined function max(), following is the function declaration &minus;</p>

<p>Function declaration is required when you define a function in one source file and you call that function in another file. In such case, you should declare the function at the top of the file calling the function.</p>

<h2>Calling a Function</h2>

<p>While creating a function, you give a definition of what the function has to do. To use a function, you will have to call that function to perform the defined task. When a program calls a function, program control is transferred to the called function. A called function performs defined task, and when its return statement is executed or when it last end statement is reached, it returns program control back to the main program.</p>

<p>To call a function, you simply need to pass the required parameters along with function name, and if function returns a value, then you can store returned value. Following is a simple example to show the usage &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
function name(argument(s): type1; argument(s): type2; ...): function_type;
local declarations;

begin
   ...
   &lt; statements &gt;
   ...
   name:= expression;
end;
</pre>
<p>A function definition in Pascal consists of a function <b>header</b>, local <b>declarations</b> and a function <b>body</b>. The function header consists of the keyword function and a <b>name</b> given to the function. Here are all the parts of a function &minus;</p>
<ul class="list">
<li><p><b>Arguments</b> &minus; The argument(s) establish the linkage between the calling program and the function identifiers and also called the formal parameters. A parameter is like a placeholder. When a function is invoked, you pass a value to the parameter. This value is referred to as actual parameter or argument. The parameter list refers to the type, order, and number of parameters of a function. Use of such formal parameters is optional. These parameters may have standard data type, user-defined data type or subrange data type.</p> 
<p>The formal parameters list appearing in the function statement could be simple or subscripted variables, arrays or structured variables, or subprograms.</p></li>
<li><p><b>Return Type</b> &minus; All functions must return a value, so all functions must be assigned a type. The <b>function-type</b> is the data type of the value the function returns. It may be standard, user-defined scalar or subrange type but it cannot be structured type.</p></li>
<li><p><b>Local declarations</b> &minus; Local declarations refer to the declarations for labels, constants, variables, functions and procedures, which are application to the body of function only.</p></li>
<li><p><b>Function Body</b> &minus; The function body contains a collection of statements that define what the function does. It should always be enclosed between the reserved words begin and end.  It is the part of a function where all computations are done. There must be an assignment statement of the type - <b>name := expression;</b> in the function body that assigns a value to the function name. This value is returned as and when the function is executed. The last statement in the body must be an end statement.</p></li>
</ul>
<p>Following is an example showing how to define a function in pascal &minus;</p>
<pre class="prettyprint notranslate">
(* function returning the max between two numbers *)
function max(num1, num2: integer): integer;

var
   (* local variable declaration *)
   result: integer;

begin
   if (num1 &gt; num2) then
      result := num1
   
   else
      result := num2;
   max := result;
end;
</pre>
<h2>Function Declarations</h2>
<p>A function <b>declaration</b> tells the compiler about a function name and how to call the function. The actual body of the function can be defined separately.</p>
<p>A function declaration has the following parts &minus;</p>
<pre class="prettyprint notranslate">
function name(argument(s): type1; argument(s): type2; ...): function_type;
</pre>
<p>For the above-defined function max(), following is the function declaration &minus;</p>
<pre class="prettyprint notranslate">
function max(num1, num2: integer): integer;
</pre>
<p>Function declaration is required when you define a function in one source file and you call that function in another file. In such case, you should declare the function at the top of the file calling the function.</p>
<h2>Calling a Function</h2>
<p>While creating a function, you give a definition of what the function has to do. To use a function, you will have to call that function to perform the defined task. When a program calls a function, program control is transferred to the called function. A called function performs defined task, and when its return statement is executed or when it last end statement is reached, it returns program control back to the main program.</p>
<p>To call a function, you simply need to pass the required parameters along with function name, and if function returns a value, then you can store returned value. Following is a simple example to show the usage &minus;</p>
<pre class="prettyprint notranslate tryit">
program exFunction;
var
   a, b, ret : integer;

(*function definition *)
function max(num1, num2: integer): integer;
var
   (* local variable declaration *)
   result: integer;

begin
   if (num1 &gt; num2) then
      result := num1
   
   else
      result := num2;
   max := result;
end;

begin
   a := 100;
   b := 200;
   (* calling a function to get max value *)
   ret := max(a, b);
   
   writeln( 'Max value is : ', ret );
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Max value is : 200 
</pre>

<title>Pascal Procedures</title>

<h1>Pascal - Procedures</h1>

<p><b>Procedures </b>are subprograms that, instead of returning a single value, allow to obtain a group of results.</p>

<h2>Defining a Procedure</h2>

<p>In Pascal, a procedure is defined using the <b>procedure</b> keyword. The general form of a procedure definition is as follows &minus;</p>

<p>A procedure <b>definition</b> in Pascal consists of a <b>header</b>, local <b>declarations</b> and a <b>body</b> of the procedure. The procedure header consists of the keyword <b>procedure</b> and a name given to the procedure. Here are all the parts of a procedure &minus;</p>

<p><b>Arguments</b> &minus; The argument(s) establish the linkage between the calling program and the procedure identifiers and also called the formal parameters. Rules for arguments in procedures are same as that for the functions.</p>

<p><b>Local declarations</b> &minus; Local declarations refer to the declarations for labels, constants, variables, functions and procedures, which are applicable to the body of the procedure only.</p>

<p><b>Procedure Body</b> &minus; The procedure body contains a collection of statements that define what the procedure does. It should always be enclosed between the reserved words begin and end. It is the part of a procedure where all computations are done.</p>

<p>Following is the source code for a procedure called <i>findMin()</i>. This procedure takes 4 parameters x, y, z and m and stores the minimum among the first three variables in the variable named m. The variable m is passed by <b>reference</b> (we will discuss passing arguments by reference a little later) &minus;</p>

<h2>Procedure Declarations</h2>

<p>A procedure <b>declaration</b> tells the compiler about a procedure name and how to call the procedure. The actual body of the procedure can be defined separately.</p>

<p>A procedure declaration has the following syntax &minus;</p>

<p>Please note that the <b>name of the procedure is not associated with any type</b>. For the above defined procedure <i>findMin()</i>, following is the declaration &minus;</p>

<h2>Calling a Procedure</h2>

<p>While creating a procedure, you give a definition of what the procedure has to do. To use the procedure, you will have to call that procedure to perform the defined task. When a program calls a procedure, program control is transferred to the called procedure. A called procedure performs the defined task, and when its last end statement is reached, it returns the control back to the calling program.</p>

<p>To call a procedure, you simply need to pass the required parameters along with the procedure name as shown below &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<h2>Recursive Subprograms</h2>

<p>We have seen that a program or subprogram may call another subprogram. When a subprogram calls itself, it is referred to as a recursive call and the process is known as recursion.</p>

<p>To illustrate the concept, let us calculate the factorial of a number. Factorial of a number n is defined as &minus;</p>

<p>The following program calculates the factorial of a given number by calling itself recursively.</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<p>Following is another example, which generates the <b>Fibonacci Series</b> for a given number using a <b>recursive</b> function &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<h2>Arguments of a Subprogram</h2>

<p>If a subprogram (<b>function or procedure</b>) is to use arguments, it must declare variables that accept the values of the arguments. These variables are called the <b>formal parameters</b> of the subprogram.</p>

<p>The formal parameters behave like other local variables inside the subprogram and are created upon entry into the subprogram and destroyed upon exit.</p>

<p>While calling a subprogram, there are two ways that arguments can be passed to the subprogram &minus;</p>

<p><a href="/pascal/pascal_call_by_value.htm" title="Subprogram call by value in Pascal">Call by value</a></p>

<p><a href="/pascal/pascal_call_by_reference.htm" title="Subprogram call by reference in Pascal">Call by reference</a></p>

<p>By default, Pascal uses <b>call by value</b> to pass arguments. In general, this means that code within a subprogram cannot alter the arguments used to call the subprogram. The example program we used in the chapter 'Pascal - Functions' called the function named max() using <b>call by value</b>.</p>

<p>Whereas, the example program provided here (<i>exProcedure</i>) calls the procedure findMin() using <b>call by reference</b>.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
procedure name(argument(s): type1, argument(s): type 2, ... );
   &lt; local declarations &gt;
begin
   &lt; procedure body &gt;
end;
</pre>
<p>A procedure <b>definition</b> in Pascal consists of a <b>header</b>, local <b>declarations</b> and a <b>body</b> of the procedure. The procedure header consists of the keyword <b>procedure</b> and a name given to the procedure. Here are all the parts of a procedure &minus;</p>
<ul class="list">
<li><p><b>Arguments</b> &minus; The argument(s) establish the linkage between the calling program and the procedure identifiers and also called the formal parameters. Rules for arguments in procedures are same as that for the functions.</p></li>
<li><p><b>Local declarations</b> &minus; Local declarations refer to the declarations for labels, constants, variables, functions and procedures, which are applicable to the body of the procedure only.</p></li>
<li><p><b>Procedure Body</b> &minus; The procedure body contains a collection of statements that define what the procedure does. It should always be enclosed between the reserved words begin and end. It is the part of a procedure where all computations are done.</p></li>
</ul>
<p>Following is the source code for a procedure called <i>findMin()</i>. This procedure takes 4 parameters x, y, z and m and stores the minimum among the first three variables in the variable named m. The variable m is passed by <b>reference</b> (we will discuss passing arguments by reference a little later) &minus;</p>
<pre class="prettyprint notranslate">
procedure findMin(x, y, z: integer; var m: integer); 
(* Finds the minimum of the 3 values *)

begin
   if x &lt; y then
      m := x
   else
      m := y;
   
   if z &lt;m then
      m := z;
end; { end of procedure findMin }  
</pre>
<h2>Procedure Declarations</h2>
<p>A procedure <b>declaration</b> tells the compiler about a procedure name and how to call the procedure. The actual body of the procedure can be defined separately.</p>
<p>A procedure declaration has the following syntax &minus;</p>
<pre class="prettyprint notranslate">
procedure name(argument(s): type1, argument(s): type 2, ... );
</pre>
<p>Please note that the <b>name of the procedure is not associated with any type</b>. For the above defined procedure <i>findMin()</i>, following is the declaration &minus;</p>
<pre class="prettyprint notranslate">
procedure findMin(x, y, z: integer; var m: integer);
</pre>
<h2>Calling a Procedure</h2>
<p>While creating a procedure, you give a definition of what the procedure has to do. To use the procedure, you will have to call that procedure to perform the defined task. When a program calls a procedure, program control is transferred to the called procedure. A called procedure performs the defined task, and when its last end statement is reached, it returns the control back to the calling program.</p>
<p>To call a procedure, you simply need to pass the required parameters along with the procedure name as shown below &minus;</p>
<pre class="prettyprint notranslate tryit">
program exProcedure;
var
   a, b, c,  min: integer;
procedure findMin(x, y, z: integer; var m: integer); 
(* Finds the minimum of the 3 values *)

begin
   if x &lt; y then
      m:= x
   else
      m:= y;
   
   if z &lt; m then
      m:= z;
end; { end of procedure findMin }  

begin
   writeln(' Enter three numbers: ');
   readln( a, b, c);
   findMin(a, b, c, min); (* Procedure call *)
   
   writeln(' Minimum: ', min);
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Enter three numbers:
89 45 67
Minimum: 45
</pre>
<h2>Recursive Subprograms</h2>
<p>We have seen that a program or subprogram may call another subprogram. When a subprogram calls itself, it is referred to as a recursive call and the process is known as recursion.</p>
<p>To illustrate the concept, let us calculate the factorial of a number. Factorial of a number n is defined as &minus;</p>
<pre class="prettyprint notranslate">
n! = n*(n-1)!
   = n*(n-1)*(n-2)!
      ...
   = n*(n-1)*(n-2)*(n-3)... 1
</pre>
<p>The following program calculates the factorial of a given number by calling itself recursively.</p>
<pre class="prettyprint notranslate tryit">
program exRecursion;
var
   num, f: integer;
function fact(x: integer): integer; (* calculates factorial of x - x! *)

begin
   if x=0 then
      fact := 1
   else
      fact := x * fact(x-1); (* recursive call *)
end; { end of function fact}

begin
   writeln(' Enter a number: ');
   readln(num);
   f := fact(num);
   
   writeln(' Factorial ', num, ' is: ' , f);
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Enter a number:
5
Factorial 5 is: 120
</pre>
<p>Following is another example, which generates the <b>Fibonacci Series</b> for a given number using a <b>recursive</b> function &minus;</p>
<pre class="prettyprint notranslate tryit">
program recursiveFibonacci;
var
   i: integer;
function fibonacci(n: integer): integer;

begin
   if n=1 then
      fibonacci := 0
   
   else if n=2 then
      fibonacci := 1
   
   else
      fibonacci := fibonacci(n-1) + fibonacci(n-2);
end; 

begin
   for i:= 1 to 10 do
   
   write(fibonacci (i), '  ');
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
0 1 1 2	3 5 8 13 21 34
</pre>

<title>Pascal Variable Scope</title>

<h1>Pascal - Variable Scope</h1>

<p>A scope in any programming is a region of the program where a defined variable can have its existence and beyond that variable cannot be accessed. There are three places, where variables can be declared in Pascal programming language &minus;</p>

<p>Inside a subprogram or a block which is called local variables</p>

<p>Outside of all subprograms which is called global variables</p>

<p>In the definition of subprogram parameters which is called formal parameters</p>

<p>Let us explain what are <b>local</b> and <b>global</b> variables and formal parameters.</p>

<h2>Local Variables</h2>

<p>Variables that are declared inside a subprogram or block are called local variables. They can be used only by statements that are inside that  subprogram or block of code. Local variables are not known to subprograms outside their own. Following is the example using local variables. Here, all the variables <i>a</i>, <i>b</i> and <i>c</i> are local to program named <i>exLocal</i>.</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<p>Now, let us extend the program little more, let us create a procedure named display, which will have its own set of variables <i>a</i>, <i>b</i> and <i>c</i> and display their values, right from the program <i>exLocal</i>.</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<h2>Global Variables</h2>

<p>Global variables are defined outside of a function, usually on top of the program. The global variables will hold their value throughout the lifetime of your program and they can be accessed inside any of the functions defined for the program.</p>

<p>A <b>global</b> variable can be accessed by any function. That is, a global variable is available for use throughout your entire program after its declaration. Following is an example using <b>global</b> and <b>local</b> variables &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<p>Please note that the procedure display has access to the variables a, b and c, which are global variables with respect to display as well as its own local variables. A program can have same name for local and global variables but value of local variable inside a function will take preference.</p>

<p>Let us change the previous example a little, now the local variables for the procedure display has same names as <i>a</i>, <i>b</i>, <i>c</i> &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate tryit">
program exLocal; 
var
   a, b, c: integer;

begin
   (* actual initialization *)
   a := 10;
   b := 20;
   c := a + b;
   
   writeln('value of a = ', a , ' b =  ',  b, ' and c = ', c);
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
value of a = 10 b = 20 c = 30
</pre>
<p>Now, let us extend the program little more, let us create a procedure named display, which will have its own set of variables <i>a</i>, <i>b</i> and <i>c</i> and display their values, right from the program <i>exLocal</i>.</p>
<pre class="prettyprint notranslate tryit">
program exLocal;
var
   a, b, c: integer;
procedure display;

var
   a, b, c: integer;
begin
   (* local variables *)
   a := 10;
   b := 20;
   c := a + b;
   
   writeln('Winthin the procedure display');
   writeln('value of a = ', a , ' b =  ',  b, ' and c = ', c);
end;

begin
   a:= 100;
   b:= 200;
   c:= a + b;
   
   writeln('Winthin the program exlocal');
   writeln('value of a = ', a , ' b =  ',  b, ' and c = ', c);
   display();
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Within the program exlocal
value of a = 100 b = 200 c = 300
Within the procedure display
value of a = 10 b = 20 c = 30
</pre>
<h2>Global Variables</h2>
<p>Global variables are defined outside of a function, usually on top of the program. The global variables will hold their value throughout the lifetime of your program and they can be accessed inside any of the functions defined for the program.</p>
<p>A <b>global</b> variable can be accessed by any function. That is, a global variable is available for use throughout your entire program after its declaration. Following is an example using <b>global</b> and <b>local</b> variables &minus;</p>
<pre class="prettyprint notranslate tryit">
program exGlobal;
var
   a, b, c: integer;
procedure display;
var
   x, y, z: integer;

begin
   (* local variables *)
   x := 10;
   y := 20;
   z := x + y;
   
   (*global variables *)
   a := 30;
   b:= 40;
   c:= a + b;
   
   writeln('Winthin the procedure display');
   writeln(' Displaying the global variables a, b, and c');
   
   writeln('value of a = ', a , ' b =  ',  b, ' and c = ', c);
   writeln('Displaying the local variables x, y, and z');
   
   writeln('value of x = ', x , ' y =  ',  y, ' and z = ', z);
end;

begin
   a:= 100;
   b:= 200;
   c:= 300;
   
   writeln('Winthin the program exlocal');
   writeln('value of a = ', a , ' b =  ',  b, ' and c = ', c);
   
   display();
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Within the program exlocal
value of a = 100 b = 200 c = 300
Within the procedure display
Displaying the global variables a, b, and c
value of a = 30 b = 40 c = 70
Displaying the local variables x, y, and z
value of x = 10 y = 20 z = 30
</pre>
<p>Please note that the procedure display has access to the variables a, b and c, which are global variables with respect to display as well as its own local variables. A program can have same name for local and global variables but value of local variable inside a function will take preference.</p>
<p>Let us change the previous example a little, now the local variables for the procedure display has same names as <i>a</i>, <i>b</i>, <i>c</i> &minus;</p>
<pre class="prettyprint notranslate tryit">
program exGlobal;
var
   a, b, c: integer;
procedure display;

var
   a, b, c: integer;

begin
   (* local variables *)
   a := 10;
   b := 20;
   c := a + b;
   
   writeln('Winthin the procedure display');
   writeln(' Displaying the global variables a, b, and c');
   
   writeln('value of a = ', a , ' b =  ',  b, ' and c = ', c);
   writeln('Displaying the local variables a, b, and c');
   
   writeln('value of a = ', a , ' b =  ',  b, ' and c = ', c);
end;

begin
   a:= 100;
   b:= 200;
   c:= 300;
   
   writeln('Winthin the program exlocal');
   writeln('value of a = ', a , ' b =  ',  b, ' and c = ', c);   
   
   display();
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Within the program exlocal
value of a = 100 b = 200 c = 300
Within the procedure display
Displaying the global variables a, b, and c
value of a = 10 b = 20 c = 30
Displaying the local variables a, b, and c
value of a = 10 b = 20 c = 30
</pre>

<title>Pascal Strings</title>

<h1>Pascal - Strings</h1>

<p>The string in Pascal is actually a sequence of characters with an optional size specification. The characters could be numeric, letters, blank, special characters or a combination of all. Extended Pascal provides numerous types of string objects depending upon the system and implementation. We will discuss more common types of strings used in programs.</p>

<p>You can define a string in many ways &minus;</p>

<p><b>Character arrays</b> &minus; This is a  character string which is a sequence of zero or more byte-sized characters  enclosed in single quotes.</p>

<p><b>String variables</b> &minus; The variable of String type, as defined in Turbo Pascal.</p>

<p><b>Short strings</b> &minus; The variable of String type with size specification.</p>

<p><b>Null terminated strings</b> &minus; The variable of <b>pchar</b> type.</p>

<p><b>AnsiStrings</b> &minus; Ansistrings are strings that have no length limit.</p>

<p>Pascal provides only one string operator, string concatenation operator (+).</p>

<h3>Examples</h3>

<p>The following program prints first four kinds of strings. We will use AnsiStrings in the next example.</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<p>Following example makes use of few more functions, let's see &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<h2>Pascal String Functions and Procedures </h2>

<p>Pascal supports a wide range of functions and procedures that manipulate strings. These subprograms vary implement-wise. Here, we are listing various string manipulating subprograms provided by Free Pascal &minus;</p>

<p><b>function AnsiCompareStr(const S1: ; const S2:):Integer; </b></p>

<p>Compares two strings</p>

<p><b>function AnsiCompareText(const S1: ; const S2:):Integer;</b></p>

<p>Compares two strings, case insensitive</p>

<p><b>function AnsiExtractQuotedStr(var Src: PChar; Quote: Char):;</b></p>

<p>Removes quotes from string</p>

<p><b>function AnsiLastChar(const S:):PChar;</b></p>

<p>Gets last character of string</p>

<p><b>function AnsiLowerCase(const s:):</b></p>

<p>Converts string to all-lowercase</p>

<p><b>function AnsiQuotedStr(const S: ; Quote: Char):;</b></p>

<p>Quotes a string</p>

<p><b>function AnsiStrComp(S1: PChar;S2: PChar):Integer;</b></p>

<p>Compares strings case-sensitive</p>

<p><b>function AnsiStrIComp(S1: PChar; S2: PChar):Integer;</b></p>

<p>Compares strings case-insensitive</p>

<p><b>function AnsiStrLComp(S1: PChar; S2: PChar; MaxLen: Cardinal):Integer;</b></p>

<p>Compares L characters of strings case sensitive</p>

<p><b>function AnsiStrLIComp(S1: PChar; S2: PChar; MaxLen: Cardinal):Integer;</b></p>

<p>Compares L characters of strings case insensitive</p>

<p><b>function AnsiStrLastChar(Str: PChar):PChar;</b></p>

<p>Gets last character of string</p>

<p><b>function AnsiStrLower(Str: PChar):PChar;</b></p>

<p>Converts string to all-lowercase</p>

<p><b>function AnsiStrUpper(Str: PChar):PChar;</b></p>

<p>Converts string to all-uppercase</p>

<p><b>function AnsiUpperCase(const s:):;</b></p>

<p>Converts string to all-uppercase</p>

<p><b>procedure AppendStr(var Dest: ; const S:);</b></p>

<p>Appends 2 strings</p>

<p><b>procedure AssignStr(var P: PString; const S:);</b></p>

<p>Assigns value of strings on heap</p>

<p><b>function CompareStr(const S1: ; const S2:):Integer; overload;</b></p>

<p>Compares two strings case sensitive</p>

<p><b>function CompareText(const S1: ; const S2:):Integer;</b></p>

<p>Compares two strings case insensitive</p>

<p><b>procedure DisposeStr(S: PShortString); overload;</b></p>

<p>Removes string from heap</p>

<p><b>function IsValidIdent( const Ident:):Boolean;</b></p>

<p>Is string a valid pascal identifier</p>

<p><b>function LastDelimiter(const Delimiters: ; const S:):Integer;</b></p>

<p>Last occurrence of character in a string</p>

<p><b>function LeftStr(const S: ; Count: Integer):;</b></p>

<p>Gets first N characters of a string</p>

<p><b>function LoadStr(Ident: Integer):; </b></p>

<p>Loads string from resources</p>

<p><b>function LowerCase(const s: ):; overload; </b></p>

<p>Converts string to all-lowercase</p>

<p><b>function LowerCase(const V: variant ):; overload; </b></p>

<p>Converts string to all-lowercase</p>

<p><b>function NewStr(const S:):PString; overload;</b></p>

<p>Allocates new string on heap</p>

<p><b>function RightStr(const S: ; Count: Integer):;</b></p>

<p>Gets last N characters of a string</p>

<p><b>function StrAlloc(Size: Cardinal):PChar;</b></p>

<p>Allocates memory for string</p>

<p><b>function StrBufSize(Str: PChar):SizeUInt;</b></p>

<p>Reserves memory for a string</p>

<p><b>procedure StrDispose(Str: PChar);</b></p>

<p>Removes string from heap</p>

<p><b>function StrPas(Str: PChar):; </b></p>

<p>Converts PChar to pascal string</p>

<p><b>function StrPCopy(Dest: PChar; Source:):PChar;</b></p>

<p>Copies pascal string</p>

<p><b>function StrPLCopy(Dest: PChar; Source: ; MaxLen: SizeUInt):PChar;</b></p>

<p>Copies N bytes of pascal string</p>

<p><b>function UpperCase(const s:):;</b></p>

<p>Converts string to all-uppercase</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate tryit">
program exString;
var
   greetings: string;
   name: packed array [1..10] of char;
   organisation: string[10];
   message: pchar;

begin
   greetings := 'Hello ';
   message := 'Good Day!';
   
   writeln('Please Enter your Name');
   readln(name);
   
   writeln('Please Enter the name of your Organisation');
   readln(organisation);
   
   writeln(greetings, name, ' from ', organisation);
   writeln(message); 
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Please Enter your Name
John Smith
Please Enter the name of your Organisation
Infotech
Hello John Smith from Infotech
</pre>
<p>Following example makes use of few more functions, let's see &minus;</p>
<pre class="prettyprint notranslate tryit">
program exString;
uses sysutils;
var
   str1, str2, str3 : ansistring;
   str4: string;
   len: integer;

begin
   str1 := 'Hello ';
   str2 := 'There!';
   
   (* copy str1 into str3 *)
   str3 := str1;
   writeln('appendstr( str3, str1) :  ', str3 );
   
   (* concatenates str1 and str2 *)
   appendstr( str1, str2);
   writeln( 'appendstr( str1, str2) ' , str1 );
   str4 := str1 + str2;
   writeln('Now str4 is: ', str4);
   
   (* total lenghth of str4 after concatenation  *)
   len := byte(str4[0]);
   writeln('Length of the final string str4: ', len); 
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
appendstr( str3, str1) : Hello
appendstr( str1, str2) : Hello There!
Now str4 is: Hello There! There!
Length of the final string str4: 18
</pre>

<title>Pascal Booleans</title>

<h1>Pascal - Booleans</h1>

<p>Pascal provides data type Boolean that enables the programmers to define, store and manipulate logical entities, such as constants, variables, functions and expressions, etc.</p>

<p>Boolean values are basically integer type. Boolean type variables have two pre-defined possible values <b>True</b> and <b>False</b>. The expressions resolving to a Boolean value can also be assigned to a Boolean type.</p>

<p>Free Pascal also supports the <b>ByteBool</b>, <b>WordBool</b> and <b>LongBool</b> types. These are of type Byte, Word or Longint, respectively.</p>

<p>The value False is equivalent to 0 (zero) and any nonzero value is considered True when converting to a Boolean value.  A Boolean value of True is converted to -1 in case it is assigned to a variable of type LongBool.</p>

<p>It should be noted that logical operators <b>and</b>, <b>or</b> and <b>not</b> are defined for Boolean data types.</p>

<h2>Declaration of Boolean Data Types</h2>

<p> A variable of Boolean type is declared using the var keyword.</p>

<p>for example,</p>

<h3>Example</h3>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
var
boolean-identifier: boolean;
</pre>
<p>for example,</p>
<pre class="prettyprint notranslate">
var
choice: boolean;
</pre>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
program exBoolean;
var
exit: boolean;

choice: char;
   begin
   writeln('Do you want to continue? ');
   writeln('Enter Y/y for yes, and N/n for no');
   readln(choice);

if(choice = 'n') then
   exit := true
else
   exit := false;

if (exit) then
   writeln(' Good Bye!')
else
   writeln('Please Continue');

readln;
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Do you want to continue?
Enter Y/y for yes, and N/n for no
N
Good Bye!
Y
Please Continue
</pre>

<title>Pascal Arrays</title>

<h1>Pascal - Arrays</h1>

<p>Pascal programming language provides a data structure called the array, which can store a fixed-size sequential collection of elements of the same type. An array is used to store a collection of data, but it is often more useful to think of an array as a collection of variables of the same type.</p>

<p>Instead of declaring individual variables, such as number1, number2, ..., and number100, you declare one array variable such as numbers and use numbers[1], numbers[2], and ..., numbers[100] to represent individual variables. A specific element in an array is accessed by an index.</p>

<p>All arrays consist of contiguous memory locations. The lowest address corresponds to the first element and the highest address to the last element.</p>

<p>Please note that if you want a C style array starting from index 0, you just need to start the index from 0, instead of 1.</p>

<h2>Declaring Arrays</h2>

<p>To declare an array in Pascal, a programmer may either declare the type and then create variables of that array or directly declare the array variable.</p>

<p>The general form of type declaration of one-dimensional array is &minus;</p>

<p>Where,</p>

<p><b>array-identifier</b> &minus; indicates the name of the array type.</p>

<p><b>index-type</b> &minus; specifies the subscript of the array; it can be any scalar data type except real</p>

<p><b>element-type</b> &minus; specifies the types of values that are going to be stored</p>

<p>For example,</p>

<p>Now, velocity is a variable array of vector type, which is sufficient to hold up to 25 real numbers.</p>

<p>To start the array from 0 index, the declaration would be &minus;</p>

<h2>Types of Array Subscript</h2>

<p>In Pascal, an array subscript could be of any scalar type like, integer, Boolean, enumerated or subrange, except real. Array subscripts could have negative values too.</p>

<p>For example,</p>

<p>Let us take up another example where the subscript is of character type &minus;</p>

<p>Subscript could be of enumerated type &minus;</p>

<h2>Initializing Arrays</h2>

<p>In Pascal, arrays are initialized through assignment, either by specifying a particular subscript or using a for-do loop.</p>

<p>For example &minus;</p>

<h2>Accessing Array Elements</h2>

<p>An element is accessed by indexing the array name. This is done by placing the index of the element within square brackets after the name of the array. For example &minus;</p>

<p>The above statement will take the first element from the array named alphabet and assign the value to the variable a.</p>

<p>Following is an example, which will use all the above-mentioned three concepts viz. declaration, assignment and accessing arrays &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<h2>Pascal Arrays in Detail</h2>

<p>Arrays are important to Pascal and should need lots of more details. There are following few important concepts related to array which should be clear to a Pascal programmer &minus;</p>

<p><a href="/pascal/pascal_multi_dimensional_arrays.htm" title="Multi-dimensional arrays in Pascal">Multi-dimensional arrays</a></p>

<p><a href="/pascal/pascal_dynamic_arrays.htm" title="Dynamic Arrays in Pascal">Dynamic array</a></p>

<p><a href="/pascal/pascal_packed_array.htm" title="Packed Array in Pascal">Packed array</a></p>

<p><a href="/pascal/pascal_passing_arrays_to_subprograms.htm" title="Passing arrays to subprogram as arguments in Pascal">Passing arrays to subprograms</a></p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
type
   array-identifier = array[index-type] of element-type;
</pre>
<p>Where,</p>
<ul class="list">
<li><p><b>array-identifier</b> &minus; indicates the name of the array type.</p></li>
<li><p><b>index-type</b> &minus; specifies the subscript of the array; it can be any scalar data type except real</p></li>
<li><p><b>element-type</b> &minus; specifies the types of values that are going to be stored</p></li>
</ul>
<p>For example,</p>
<pre class="prettyprint notranslate">
type
   vector = array [ 1..25] of real;
var
   velocity: vector;
</pre>
<p>Now, velocity is a variable array of vector type, which is sufficient to hold up to 25 real numbers.</p>
<p>To start the array from 0 index, the declaration would be &minus;</p>
<pre class="prettyprint notranslate">
type
   vector = array [ 0..24] of real;
var
   velocity: vector;
</pre>
<h2>Types of Array Subscript</h2>
<p>In Pascal, an array subscript could be of any scalar type like, integer, Boolean, enumerated or subrange, except real. Array subscripts could have negative values too.</p>
<p>For example,</p>
<pre class="prettyprint notranslate">
type
   temperature = array [-10 .. 50] of real;
var
   day_temp, night_temp: temperature;
</pre>
<p>Let us take up another example where the subscript is of character type &minus;</p>
<pre class="prettyprint notranslate">
type
   ch_array = array[char] of 1..26;
var
   alphabet: ch_array;
</pre>
<p>Subscript could be of enumerated type &minus;</p>
<pre class="prettyprint notranslate">
type
   color = ( red, black, blue, silver, beige);
   car_color = array of [color] of boolean;
var
   car_body: car_color;
</pre>
<h2>Initializing Arrays</h2>
<p>In Pascal, arrays are initialized through assignment, either by specifying a particular subscript or using a for-do loop.</p>
<p>For example &minus;</p>
<pre class="prettyprint notranslate">
type
   ch_array = array[char] of 1..26;
var
   alphabet: ch_array;
   c: char;

begin
   ...
   for c:= 'A' to 'Z' do
   alphabet[c] := ord[m];  
   (* the ord() function returns the ordinal values *)
</pre>
<h2>Accessing Array Elements</h2>
<p>An element is accessed by indexing the array name. This is done by placing the index of the element within square brackets after the name of the array. For example &minus;</p>
<pre class="prettyprint notranslate">
a: integer;
a: = alphabet['A'];
</pre>
<p>The above statement will take the first element from the array named alphabet and assign the value to the variable a.</p>
<p>Following is an example, which will use all the above-mentioned three concepts viz. declaration, assignment and accessing arrays &minus;</p>
<pre class="prettyprint notranslate tryit">
program exArrays;
var
   n: array [1..10] of integer;   (* n is an array of 10 integers *)
   i, j: integer;

begin
   (* initialize elements of array n to 0 *)        
   for i := 1 to 10 do
       n[ i ] := i + 100;   (* set element at location i to i + 100 *)
    (* output each array element's value *)
   
   for j:= 1 to 10 do
      writeln('Element[', j, '] = ', n[j] );
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Element[1] = 101
Element[2] = 102
Element[3] = 103
Element[4] = 104
Element[5] = 105
Element[6] = 106
Element[7] = 107
Element[8] = 108
Element[9] = 109
Element[10] = 110
</pre>

<title>Pascal Pointers</title>

<h1>Pascal - Pointers</h1>

<p>Pointers in Pascal are easy and fun to learn. Some Pascal programming tasks are performed more easily with pointers, and other tasks, such as dynamic memory allocation, cannot be performed without using pointers. So it becomes necessary to learn pointers to become a perfect  Pascal programmer. Let's start learning them in simple and easy steps.</p>

<p>As you know, every variable is a memory location and every memory location has its address defined which can be accessed using the name of the pointer variable, which denotes an address in memory.</p>

<h2>What Are Pointers?</h2>

<p>A pointer is a dynamic variable, whose value is the address of another variable, i.e., direct address of the memory location. Like any variable or constant, you must declare a pointer before you can use it to store any variable address.  The general form of a pointer variable declaration is &minus;</p>

<p>The pointer type is defined by prefixing the up-arrow of caret symbol (^) with the base type.  The base-type defines the types of the data items. Once a pointer variable is defined to be of certain type, it can point data items of that type only. Once a pointer type has been defined, we can use the <b>var</b> declaration to declare pointer variables.</p>

<p>Following are some valid pointer declarations &minus;</p>

<p>The pointer variables are dereferenced by using the same caret symbol (^). For example, the associated variable referred by a pointer <i>rptr</i>, is <i>rptr^</i>. It can be accessed as &minus;</p>

<p>The following example will illustrate this concept &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<h2>Printing a Memory Address in Pascal</h2>

<p>In Pascal, we can assign the address of a variable to a pointer variable using the address operator (@). We use this pointer to manipulate and access the data item. However, if for some reason, we need to work with the memory address itself, we need to store it in a word type variable.</p>

<p>Let us extend the above example to print the memory address stored in the pointer <i>iptr</i> &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<h2>NIL Pointers</h2>

<p>It is always a good practice to assign a <b>NIL</b> value to a pointer variable in case you do not have exact address to be assigned. This is done at the time of variable declaration. A pointer that is assigned <b>NIL</b> points to nowhere. Consider the following program &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<p>To check for a <b>nil</b> pointer you can use an if statement as follows &minus;</p>

<h2>Pascal Pointers in Detail</h2>

<p>Pointers have many but easy concepts and they are very important to Pascal programming. There are following few important pointer concepts, which should be clear to a Pascal programmer &minus;</p>

<p><a href="/pascal/pascal_pointer_arithmetic.htm" title="Pascal - Pointer Arithmetic">Pascal - Pointer arithmetic</a></p>

<p><a href="/pascal/pascal_array_of_pointers.htm" title="Pascal - Array of Pointers">Pascal  - Array of pointers</a></p>

<p><a href="/pascal/pascal_pointer_to_pointer.htm" title="Pascal - Pointer to Pointer Operators">Pascal - Pointer to pointer</a></p>

<p><a href="/pascal/pascal_passing_pointers_to_subprograms.htm" title="Passing pointers to subprograms in Pascal">Passing pointers to subprograms in Pascal</a></p>

<p><a href="/pascal/pascal_return_pointer_from_subprograms.htm" title="Return pointer from subprograms in Pascal">Return pointer from subprograms in Pascal</a></p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
type
   ptr-identifier = ^base-variable-type;
</pre>
<p>The pointer type is defined by prefixing the up-arrow of caret symbol (^) with the base type.  The base-type defines the types of the data items. Once a pointer variable is defined to be of certain type, it can point data items of that type only. Once a pointer type has been defined, we can use the <b>var</b> declaration to declare pointer variables.</p>
<pre class="prettyprint notranslate">
var
   p1, p2, ... : ptr-identifier;
</pre>
<p>Following are some valid pointer declarations &minus;</p>
<pre class="prettyprint notranslate">
type
   Rptr = ^real;
   Cptr = ^char;
   Bptr = ^ Boolean;
   Aptr = ^array[1..5] of real;
   date-ptr = ^ date;
      Date = record
         Day: 1..31;
         Month: 1..12;
         Year: 1900..3000;
      End;
var
   a, b : Rptr;
   d: date-ptr;
</pre>
<p>The pointer variables are dereferenced by using the same caret symbol (^). For example, the associated variable referred by a pointer <i>rptr</i>, is <i>rptr^</i>. It can be accessed as &minus;</p>
<pre class="prettyprint notranslate">
rptr^ := 234.56;
</pre>
<p>The following example will illustrate this concept &minus;</p>
<pre class="prettyprint notranslate tryit">
program exPointers;
var
   number: integer;
   iptr: ^integer;

begin
   number := 100;
   writeln('Number is: ', number);
   
   iptr := @number;
   writeln('iptr points to a value: ', iptr^);
   
   iptr^ := 200;
   writeln('Number is: ', number);
   writeln('iptr points to a value: ', iptr^);
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Number is: 100
iptr points to a value: 100
Number is: 200
iptr points to a value: 200
</pre>
<h2>Printing a Memory Address in Pascal</h2>
<p>In Pascal, we can assign the address of a variable to a pointer variable using the address operator (@). We use this pointer to manipulate and access the data item. However, if for some reason, we need to work with the memory address itself, we need to store it in a word type variable.</p>
<p>Let us extend the above example to print the memory address stored in the pointer <i>iptr</i> &minus;</p>
<pre class="prettyprint notranslate tryit">
program exPointers;
var
   number: integer;
   iptr: ^integer;
   y: ^word;

begin
   number := 100;
   writeln('Number is: ', number);
   iptr := @number;
   writeln('iptr points to a value: ', iptr^);
   
   iptr^ := 200;
   writeln('Number is: ', number);
   writeln('iptr points to a value: ', iptr^);
   y := addr(iptr);
   writeln(y^); 
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Number is: 100
iptr points to a value: 100
Number is: 200
iptr points to a value: 200
36864
</pre>
<h2>NIL Pointers</h2>
<p>It is always a good practice to assign a <b>NIL</b> value to a pointer variable in case you do not have exact address to be assigned. This is done at the time of variable declaration. A pointer that is assigned <b>NIL</b> points to nowhere. Consider the following program &minus;</p>
<pre class="prettyprint notranslate tryit">
program exPointers;
var
   number: integer;
   iptr: ^integer;
   y: ^word;

begin
   iptr := nil;
   y := addr(iptr);
   
   writeln('the vaule of iptr is ', y^);
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
The value of ptr is 0
</pre>
<p>To check for a <b>nil</b> pointer you can use an if statement as follows &minus;</p>
<pre class="prettyprint notranslate">
if(ptr &lt;&gt; nill )then     (* succeeds if p is not null *)
if(ptr = nill)then    (* succeeds if p is null *)
</pre>

<title>Pascal Records</title>

<h1>Pascal - Records</h1>

<p>Pascal arrays allow you to define type of variables that can hold several data items of the same kind but a record is another user-defined data type available in Pascal which allows you to combine data items of different kinds.</p>

<p>Records consist of different fields. Suppose you want to keep track of your books in a library, you might want to track the following attributes about each book &minus;</p>

<h2>Defining a Record</h2>

<p>To define a record type, you may use the type declaration statement. The record type is defined as &minus;</p>

<p>Here is the way you would declare the Book record &minus;</p>

<p>The record variables are defined in the usual way as </p>

<p>Alternatively, you can directly define a record type variable as &minus;</p>

<h2>Accessing Fields of a Record</h2>

<p>To access any field of a record, we use the member access operator (.). The member access operator is coded as a period between the record variable name and the field that we wish to access. Following is the example to explain usage of structure &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<h2>Records as Subprogram Arguments</h2>

<p>You can pass a record as a subprogram argument in very similar way as you pass any other variable or pointer. You would access the record fields in the similar way as you have accessed in the above example &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<h2>Pointers to Records</h2>

<p>You can define pointers to records in very similar way as you define pointer to any other variable as follows &minus;</p>

<p>Now, you can store the address of a record type variable in the above-defined pointer variable. To declare a variable of the created pointer type, you use the var keyword &minus;</p>

<p>Before using these pointers, you must create storage for a record-name type variable, which will be manipulated by these pointers.</p>

<p>To access the members of a record using a pointer to that record, you must use the ^. operator as follows &minus;</p>

<p>Finally, don't forget to dispose the used storage, when it is no longer in use &minus;</p>

<p>Let us re-write the first example using a pointer to the Books record. Hope this will be easy for you to understand the concept &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<h2>The With Statement</h2>

<p>We have discussed that the members of a record can be accessed using the member access operator (.). This way the name of the record variable has to be written every time. The <b>With</b> statement provides an alternative way to do that.</p>

<p>Look at the following code snippet taken from our first example &minus;</p>

<p>The same assignment could be written using the <b>With</b> statement as &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
type
record-name = record
   field-1: field-type1;
   field-2: field-type2;
   ...
   field-n: field-typen;
end;
</pre>
<p>Here is the way you would declare the Book record &minus;</p>
<pre class="prettyprint notranslate">
type 
Books = record
   title: packed array [1..50] of char;
   author: packed array [1..50] of char;
   subject: packed array [1..100] of char;
   book_id: integer;
end;
</pre>
<p>The record variables are defined in the usual way as </p>
<pre class="prettyprint notranslate">
var
   r1, r2, ... : record-name;
</pre>
<p>Alternatively, you can directly define a record type variable as &minus;</p>
<pre class="prettyprint notranslate">
var
Books : record
   title: packed array [1..50] of char;
   author: packed array [1..50] of char;
   subject: packed array [1..100] of char;
   book_id: integer;
end;
</pre>
<h2>Accessing Fields of a Record</h2>
<p>To access any field of a record, we use the member access operator (.). The member access operator is coded as a period between the record variable name and the field that we wish to access. Following is the example to explain usage of structure &minus;</p>
<pre class="prettyprint notranslate tryit">
program exRecords;
type
Books = record
   title: packed array [1..50] of char;
   author: packed array [1..50] of char;
   subject: packed array [1..100] of char;
   book_id: longint;
end;

var
   Book1, Book2: Books; (* Declare Book1 and Book2 of type Books *)

begin
   (* book 1 specification *)
   Book1.title  := 'C Programming';
   Book1.author := 'Nuha Ali '; 
   Book1.subject := 'C Programming Tutorial';
   Book1.book_id := 6495407;

   (* book 2 specification *)
   Book2.title := 'Telecom Billing';
   Book2.author := 'Zara Ali';
   Book2.subject := 'Telecom Billing Tutorial';
   Book2.book_id := 6495700;
 
   (* print Book1 info *)
   writeln ('Book 1 title : ', Book1.title);
   writeln('Book 1 author : ', Book1.author);
   writeln( 'Book 1 subject : ', Book1.subject);
   writeln( 'Book 1 book_id : ', Book1.book_id);
   writeln; 

   (* print Book2 info *)
   writeln ('Book 2 title : ', Book2.title);
   writeln('Book 2 author : ', Book2.author);
   writeln( 'Book 2 subject : ', Book2.subject);
   writeln( 'Book 2 book_id : ', Book2.book_id);
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Book 1 title : C Programming
Book 1 author : Nuha Ali
Book 1 subject : C Programming Tutorial
Book 1 book_id : 6495407

Book 2 title : Telecom Billing
Book 2 author : Zara Ali
Book 2 subject : Telecom Billing Tutorial
Book 2 book_id : 6495700
</pre>
<h2>Records as Subprogram Arguments</h2>
<p>You can pass a record as a subprogram argument in very similar way as you pass any other variable or pointer. You would access the record fields in the similar way as you have accessed in the above example &minus;</p>
<pre class="prettyprint notranslate tryit">
program exRecords;
type
Books = record
   title: packed array [1..50] of char;
   author: packed array [1..50] of char;
   subject: packed array [1..100] of char;
   book_id: longint;
end;

var
   Book1, Book2: Books; (* Declare Book1 and Book2 of type Books *)

(* procedure declaration *)
procedure printBook( var book: Books );

begin
   (* print Book info *)
   writeln ('Book  title : ', book.title);
   writeln('Book  author : ', book.author);
   writeln( 'Book  subject : ', book.subject);
   writeln( 'Book book_id : ', book.book_id);
end;

begin
   (* book 1 specification *)
   Book1.title  := 'C Programming';
   Book1.author := 'Nuha Ali '; 
   Book1.subject := 'C Programming Tutorial';
   Book1.book_id := 6495407;
   
   (* book 2 specification *)
   Book2.title := 'Telecom Billing';
   Book2.author := 'Zara Ali';
   Book2.subject := 'Telecom Billing Tutorial';
   Book2.book_id := 6495700;
   
   (* print Book1 info *)
   printbook(Book1);
   writeln; 

   (* print Book2 info *)
   printbook(Book2);
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Book 1 title : C Programming
Book 1 author : Nuha Ali
Book 1 subject : C Programming Tutorial
Book 1 book_id : 6495407

Book 2 title : Telecom Billing
Book 2 author : Zara Ali
Book 2 subject : Telecom Billing Tutorial
Book 2 book_id : 6495700
</pre>
<h2>Pointers to Records</h2>
<p>You can define pointers to records in very similar way as you define pointer to any other variable as follows &minus;</p>
<pre class="prettyprint notranslate">
type
record-ptr = ^ record-name;
record-name = record
   field-1: field-type1;
   field-2: field-type2;
   ...
   field-n: field-typen;
end;
</pre>
<p>Now, you can store the address of a record type variable in the above-defined pointer variable. To declare a variable of the created pointer type, you use the var keyword &minus;</p>
<pre class="prettyprint notranslate">
var
   r1, r2, ... : record-ptr;
</pre>
<p>Before using these pointers, you must create storage for a record-name type variable, which will be manipulated by these pointers.</p>
<pre class="prettyprint notranslate">
new(r1);
new(r2);
</pre>
<p>To access the members of a record using a pointer to that record, you must use the ^. operator as follows &minus;</p>
<pre class="prettyprint notranslate">
r1^.feild1 := value1;
r1^.feild2 := value2;
...
r1^fieldn := valuen;
</pre>
<p>Finally, don't forget to dispose the used storage, when it is no longer in use &minus;</p>
<pre class="prettyprint notranslate">
dispose(r1);
dispose(r2);
</pre>
<p>Let us re-write the first example using a pointer to the Books record. Hope this will be easy for you to understand the concept &minus;</p>
<pre class="prettyprint notranslate tryit">
program exRecords;
type
BooksPtr = ^ Books;
Books = record
   title: packed array [1..50] of char;
   author: packed array [1..50] of char;
   subject: packed array [1..100] of char;
   book_id: longint;
end;

var
  (* Declare Book1 and Book2 of pointer type that refers to Book type *)
   Book1, Book2: BooksPtr; 

begin
   new(Book1);
   new(book2);
   
   (* book 1 specification *)
   Book1^.title  := 'C Programming';
   Book1^.author := 'Nuha Ali '; 
   Book1^.subject := 'C Programming Tutorial';
   Book1^.book_id := 6495407;
   
   (* book 2 specification *)
   Book2^.title := 'Telecom Billing';
   Book2^.author := 'Zara Ali';
   Book2^.subject := 'Telecom Billing Tutorial';
   Book2^.book_id := 6495700;
   
   (* print Book1 info *)
   writeln ('Book 1 title : ', Book1^.title);
   writeln('Book 1 author : ', Book1^.author);
   writeln( 'Book 1 subject : ', Book1^.subject);
   writeln( 'Book 1 book_id : ', Book1^.book_id);
   
   (* print Book2 info *)
   writeln ('Book 2 title : ', Book2^.title);
   writeln('Book 2 author : ', Book2^.author);
   writeln( 'Book 2 subject : ', Book2^.subject);
   writeln( 'Book 2 book_id : ', Book2^.book_id);
   
   dispose(Book1); 
   dispose(Book2);
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Book 1 title : C Programming
Book 1 author : Nuha Ali
Book 1 subject : C Programming Tutorial
Book 1 book_id : 6495407

Book 2 title : Telecom Billing
Book 2 author : Zara Ali
Book 2 subject : Telecom Billing Tutorial
Book 2 book_id : 6495700
</pre>
<h2>The With Statement</h2>
<p>We have discussed that the members of a record can be accessed using the member access operator (.). This way the name of the record variable has to be written every time. The <b>With</b> statement provides an alternative way to do that.</p>
<p>Look at the following code snippet taken from our first example &minus;</p>
<pre class="prettyprint notranslate">
   (* book 1 specification *)
   Book1.title  := 'C Programming';
   Book1.author := 'Nuha Ali '; 
   Book1.subject := 'C Programming Tutorial';
   Book1.book_id := 6495407;
</pre>
<p>The same assignment could be written using the <b>With</b> statement as &minus;</p>
<pre class="prettyprint notranslate">
(* book 1 specification *)
With Book1 do
begin
   title  := 'C Programming';
   author := 'Nuha Ali '; 
   subject := 'C Programming Tutorial';
   book_id := 6495407;
end;
</pre>

<title>Pascal Variants</title>

<h1>Pascal - Variants</h1>

<p>Pascal supports a unique type of storage named variants.  You can assign any simple type of values in a variant variable. The type of a value stored in a variant is only determined at runtime. Almost any simple type can be assigned to variants: ordinal types, string types, int64 types.</p>

<p>Structured types such as sets, records, arrays, files, objects and classes are not assignment-compatible with a variant.  You can also assign a pointer to a variant.</p>

<p>Free Pascal supports variants.</p>

<h2>Declaring a Variant</h2>

<p>You can declare variant type like any other types using the <b>var</b> keyword. The syntax for declaring a variant type is &minus;</p>

<p>Now, this variant variable v can be assigned to almost all simple types including the enumerated types and vice versa.</p>

<h3>Example</h3>

<p>The following example would illustrate the concept &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
var
   v: variant;
</pre>
<p>Now, this variant variable v can be assigned to almost all simple types including the enumerated types and vice versa.</p>
<pre class="prettyprint notranslate">
type  
   color = (red, black, white);  
var  
   v : variant;  
   i : integer;  
   b : byte;  
   w : word;  
   q : int64;  
   e : extended;  
   d : double;  
   en : color;  
   as : ansistring;  
   ws : widestring;  

begin  
   v := i;  
   v := b;  
   v := w;  
   v := q;  
   v := e;  
   v := en;  
   v := d:  
   v := as;  
   v := ws;  
end;
</pre>
<h3>Example</h3>
<p>The following example would illustrate the concept &minus;</p>
<pre class="prettyprint notranslate tryit">
Program exVariant;

uses variants;
type
   color = (red, black, white);

var
   v : variant;
   i : integer;
   r: real;
   c : color;
   as : ansistring;


begin
   i := 100;
   v:= i;
   writeln('Variant as Integer: ', v);

   r:= 234.345;
   v:= r;
   writeln('Variant as real: ', v);

   c := red;
   v := c;
   writeln('Variant as Enumerated data: ', v);

   as:= ' I am an AnsiString';
   v:= as;
   writeln('Variant as AnsiString: ', v);
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Variant as Integer: 100
Variant as real: 234.345
Variant as Enumerated data: 0
Variant as AnsiString: I am an AnsiString
</pre>

<title>Pascal Sets</title>

<h1>Pascal - Sets</h1>

<p>A set is a collection of elements of same type. Pascal allows defining the set data type. The elements in a set are called its members. In mathematics, sets are represented by enclosing the members within <i>braces{}</i>.  However, in Pascal, set elements are enclosed within square brackets [], which are referred as set constructor.</p>

<h2>Defining Set Types and Variables</h2>

<p>Pascal Set types are defined as</p>

<p>Variables of set type are defined as</p>

<p>or,</p>

<p>Examples of some valid set type declaration are &minus;</p>

<h2>Set Operators</h2>

<p>You can perform the following set operations on Pascal sets.</p>

<p>Following table shows all the set operators supported by Free Pascal. Assume that <b>S1</b> and <b>S2</b> are two character sets, such that &minus;</p>

<p>S1 := ['a', 'b', 'c']; </p>

<p>S2 := ['c', 'd', 'e']; </p>

<p>S1 + S2 will give a set</p>

<p>['a', 'b', 'c', 'd', 'e']</p>

<p>S1 - S2 will give a set</p>

<p>['a', 'b']</p>

<p>S1 * S2 will give a set</p>

<p>['c']</p>

<p>Include (S1, ['d']) will give a set</p>

<p>['a', 'b', 'c', 'd']</p>

<p>Exclude (S2, ['d']) will give a set</p>

<p>['c', 'e']</p>

<h3>Example</h3>

<p>The following example illustrates the use of some of these operators &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
type
set-identifier = set of base type;
</pre>
<p>Variables of set type are defined as</p>
<pre class="prettyprint notranslate">
var
s1, s2, ...: set-identifier;
</pre>
<p>or,</p>
<pre class="prettyprint notranslate">
s1, s2...: set of base type;
</pre>
<p>Examples of some valid set type declaration are &minus;</p>
<pre class="prettyprint notranslate">
type
Days = (mon, tue, wed, thu, fri, sat, sun);
Letters = set of char;
DaySet = set of days;
Alphabets = set of 'A' .. 'Z';
studentAge = set of 13..20;
</pre>
<h2>Set Operators</h2>
<p>You can perform the following set operations on Pascal sets.</p>
<table class="table table-bordered">
<tr>
<th style="width:20%;">Operations</th>
<th>Descriptions</th>
</tr>
<tr>
<td>Union</td>
<td>This joins two sets and gives a new set with members from both sets.</td>
</tr>
<tr>
<td>Difference</td>
<td>Gets the difference of two sets and gives a new set with elements not common to either set.</td>
</tr>
<tr>
<td>Intersection</td>
<td>Gets the intersection of two sets and gives a new set with elements common to both sets.</td>
</tr>
<tr>
<td>Inclusion</td>
<td>A set P is included in set Q, if all items in P are also in Q but not vice versa.</td>
</tr>
<tr>
<td>Symmetric difference</td>
<td>Gets the symmetric difference of two sets and gives a set of elements, which are in either of the sets and not in their intersection.</td>
</tr>
<tr>
<td>In </td>
<td>It checks membership.</td>
</tr>
</table>
<p>Following table shows all the set operators supported by Free Pascal. Assume that <b>S1</b> and <b>S2</b> are two character sets, such that &minus;</p>
<p>S1 := ['a', 'b', 'c']; </p>
<p>S2 := ['c', 'd', 'e']; </p>
<table class="table table-bordered">
<tr>
<th style="width:10%">Operator</th>
<th style="width:55%;">Description</th>
<th>Example</th>
</tr>
<tr>
<td>+</td>
<td>Union of two sets</td>
<td><p>S1 + S2 will give a set</p>
<p>['a', 'b', 'c', 'd', 'e']</p>
</td>
</tr>
<tr>
<td>-</td>
<td>Difference of two sets</td>
<td><p>S1 - S2 will give a set</p> 
<p>['a', 'b']</p>
</td>
</tr>
<tr>
<td>*</td>
<td>Intersection of two sets</td>
<td><p>S1 * S2 will give a set</p>
<p>['c']</p>
</td>
</tr>
<tr>
<td>&gt;&lt;</td>
<td>Symmetric difference of two sets</td>
<td>S1 &gt;&lt; S2 will give a set ['a', 'b', 'd', 'e']</td>
</tr>
<tr>
<td> =</td>
<td>Checks equality of two sets</td>
<td>S1 = S2 will give the boolean value False</td>
</tr>
<tr>
<td> &lt;&gt;</td>
<td>Checks non-equality of two sets</td>
<td> S1 &lt;&gt; S2 will give the boolean value True</td>
</tr>
<tr>
<td>&lt;= </td>
<td>Contains (Checks if one set is a subset of the other)</td>
<td>S1 &lt;= S2 will give the boolean value False </td>
</tr>
<tr>
<td>Include</td>
<td>Includes an element in the set; basically it is the Union of a set and an element of same base type</td>
<td><p>Include (S1, ['d']) will give a set</p>
<p>['a', 'b', 'c', 'd']</p>
</td>
</tr>
<tr>
<td>Exclude</td>
<td>Excludes an element from a set; basically it is the Difference of a set and an element of same base type </td>
<td><p>Exclude (S2, ['d']) will give a set</p> 
<p>['c', 'e']</p>
</td>
</tr>
<tr>
<td>In</td>
<td>Checks set membership of an element in a set</td>
<td>['e'] in S2 gives the boolean value True</td>
</tr>
</table>
<h3>Example</h3>
<p>The following example illustrates the use of some of these operators &minus;</p>
<pre class="prettyprint notranslate tryit">
program setColors;
type  
color = (red, blue, yellow, green, white, black, orange);  
colors = set of color;  
 
procedure displayColors(c : colors);  
const  
names : array [color] of String[7]  
  = ('red', 'blue', 'yellow', 'green', 'white', 'black', 'orange');  
var  
   cl : color;  
   s : String;  

begin  
   s:= ' ';  
   for cl:=red to orange do  
      if cl in c then  
      begin  
         if (s&lt;&gt;' ') then s :=s +' , ';  
         s:=s+names[cl];  
      end;  
   writeln('[',s,']');  
end;  
 
var  
   c : colors;  
 
begin  
   c:= [red, blue, yellow, green, white, black, orange];
   displayColors(c);

   c:=[red, blue]+[yellow, green]; 
   displayColors(c);  

   c:=[red, blue, yellow, green, white, black, orange] - [green, white];     
   displayColors(c);    

   c:= [red, blue, yellow, green, white, black, orange]*[green, white];     
   displayColors(c);  

   c:= [red, blue, yellow, green]&gt;&lt;[yellow, green, white, black]; 
   displayColors(c);  
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
[ red , blue , yellow , green , white , black , orange]
[ red , blue , yellow , green]
[ red , blue , yellow , black , orange]
[ green , white]
[ red , blue , white , black]
</pre>

<title>Pascal File Handling</title>

<h1>Pascal - File Handling</h1>

<p>Pascal treats a file as a sequence of components, which must be of uniform type. A file's type is determined by the type of the components. File data type is defined as &minus;</p>

<p>Where, the base-type indicates the type of the components of the file. The base type could be anything like, integer, real, Boolean, enumerated, subrange, record, arrays and sets except another file type. Variables of a file type are created using the <i>var</i> declaration &minus;</p>

<p>Following are some examples of defining some file types and file variables &minus;</p>

<h2>Creating and Writing to a File</h2>

<p>Let us write a program that would create a data file for students' records. It would create a file named students.dat and write a student's data into it &minus;</p>

<p>When compiled and run, the program would create a file named <i>students.dat</i> into the working directory. You can open the file using a text editor, like notepad, to look at John Smith's data.</p>

<h2>Reading from a File</h2>

<p>We have just created and written into a file named students.dat. Now, let us write a program that would read the student's data from the file &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<h2>Files as Subprogram Parameter</h2>

<p>Pascal allows file variables to be used as parameters in standard and user-defined subprograms. The following example illustrates this concept. The program creates a file named rainfall.txt and stores some rainfall data. Next, it opens the file, reads the data and computes the average rainfall.</p>

<p>Please note that, <b>if you use a file parameter with subprograms, it must be declared as a var parameter.</b></p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<h2>Text Files</h2>

<p>A text file, in Pascal, consists of lines of characters where each line is terminated with an end-of-line marker. You can declare and define such files as &minus;</p>

<p>Difference between a normal file of characters and a text file is that a text file is divided into lines, each terminated by a special end-of-line marker, automatically inserted by the system. The following example creates and writes into a text file named contact.txt &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<h2>Appending to a File</h2>

<p>Appending to a file means writing to an existing file that already has some data without overwriting the file. The following program illustrates this &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<h2>File  Handling Functions</h2>

<p>Free Pascal provides the following functions/procedures for file handling &minus;</p>

<p><b>procedure Append(var t: Text);</b></p>

<p>Opens a file in append mode</p>

<p><b>procedure Assign(out f: file; const Name:);</b></p>

<p>Assigns a name to a file</p>

<p><b>procedure Assign(out f: file; p: PChar);</b></p>

<p>Assigns a name to a file</p>

<p><b>procedure Assign(out f: file; c: Char);</b></p>

<p>Assigns a name to a file</p>

<p><b>procedure Assign(out f: TypedFile; const Name:);</b></p>

<p>Assigns a name to a file</p>

<p><b>procedure Assign(out f: TypedFile; p: PChar);</b></p>

<p>Assigns a name to a file</p>

<p><b>procedure Assign(out f: TypedFile; c: Char);</b></p>

<p>Assigns a name to a file</p>

<p><b>procedure Assign(out t: Text; const s:);</b></p>

<p>Assigns a name to a file</p>

<p><b>procedure Assign(out t: Text; p: PChar);</b></p>

<p>Assigns a name to a file</p>

<p><b>procedure Assign(out t: Text; c: Char);</b></p>

<p>Assigns a name to a file</p>

<p><b>procedure BlockRead(var f: file; var Buf; count: Int64; var Result: Int64);</b></p>

<p>Reads data from a file into memory</p>

<p><b>procedure BlockRead(var f: file; var Buf; count: LongInt; var Result: LongInt);</b></p>

<p>Reads data from a file into memory</p>

<p><b>procedure BlockRead(var f: file; var Buf; count: Cardinal; var Result: Cardinal);</b></p>

<p>Reads data from a file into memory</p>

<p><b>procedure BlockRead(var f: file; var Buf; count: Word; var Result: Word);</b></p>

<p>Reads data from a file into memory</p>

<p><b>procedure BlockRead(var f: file; var Buf; count: Word; var Result: Integer);</b></p>

<p>Reads data from a file into memory</p>

<p><b>procedure BlockRead(var f: file; var Buf; count: Int64);</b></p>

<p>Reads data from a file into memory</p>

<p><b>procedure BlockWrite(var f: file; const Buf; Count: Int64; var Result: Int64);</b></p>

<p>Writes data from memory to a file</p>

<p><b>procedure BlockWrite(var f: file; const Buf; Count: LongInt; var Result: LongInt);</b></p>

<p>Writes data from memory to a file</p>

<p><b>procedure BlockWrite(var f: file; const Buf; Count: Cardinal; var Result: Cardinal);</b></p>

<p>Writes data from memory to a file</p>

<p><b>procedure BlockWrite(var f: file; const Buf; Count: Word; var Result: Word);</b></p>

<p>Writes data from memory to a file</p>

<p><b>procedure BlockWrite(var f: file; const Buf; Count: Word; var Result: Integer);</b></p>

<p>Writes data from memory to a file</p>

<p><b>procedure BlockWrite(var f: file; const Buf; Count: LongInt);</b></p>

<p>Writes data from memory to a file</p>

<p><b>procedure Close(var f: file);</b></p>

<p>Closes a file</p>

<p><b>procedure Close(var t: Text);</b></p>

<p>Closes a file</p>

<p><b>function EOF(var f: file):Boolean; </b></p>

<p>Checks for end of file</p>

<p><b>function EOF(var t: Text):Boolean;</b></p>

<p>Checks for end of file</p>

<p><b>function EOF: Boolean;</b></p>

<p>Checks for end of file</p>

<p><b>function EOLn(var t: Text):Boolean; </b></p>

<p>Checks for end of line</p>

<p><b>function EOLn: Boolean;</b></p>

<p>Checks for end of line</p>

<p><b>procedure Erase(var f: file);</b></p>

<p>Deletes file from disk</p>

<p><b>procedure Erase(var t: Text);</b></p>

<p>Deletes file from disk</p>

<p><b>function FilePos( var f: file):Int64; </b></p>

<p>Position in file</p>

<p><b>function FileSize(var f: file):Int64;</b></p>

<p>Size of file</p>

<p><b>procedure Flush(var t: Text);</b></p>

<p>Writes file buffers to disk</p>

<p><b>function IOResult: Word;</b></p>

<p>Returns result of last file IO operation</p>

<p><b>procedure Read(var F: Text; Args: Arguments);</b></p>

<p>Reads from file into variable</p>

<p><b>procedure Read(Args: Arguments);</b></p>

<p>Reads from file into variable</p>

<p><b>procedure ReadLn(var F: Text; Args: Arguments);</b></p>

<p>Reads from file into variable and goto next line</p>

<p><b>procedure ReadLn(Args: Arguments);</b></p>

<p>Reads from file into variable and goto next line</p>

<p><b>procedure Rename(var f: file; const s:);</b></p>

<p>Renames file on disk</p>

<p><b>procedure Rename(var f: file; p: PChar);</b></p>

<p>Renames file on disk</p>

<p><b>procedure Rename(var f: file; c: Char);</b></p>

<p>Renames file on disk</p>

<p><b>procedure Rename(var t: Text; const s); </b></p>

<p>Rename file on disk</p>

<p><b>procedure Rename(var t: Text; p: PChar);</b></p>

<p>Renames file on disk</p>

<p><b>procedure Rename( var t: Text; c: Char);</b></p>

<p>Renames file on disk</p>

<p><b>procedure Reset(var f: file; l: LongInt);</b></p>

<p>Opens file for reading</p>

<p><b>procedure Reset(var f: file);</b></p>

<p>Opens file for reading</p>

<p><b>procedure Reset(var f: TypedFile);</b></p>

<p>Opens file for reading</p>

<p><b>procedure Reset(var t: Text);</b></p>

<p>Opens file for reading</p>

<p><b>procedure Rewrite(var f: file; l: LongInt);</b></p>

<p>Opens file for writing</p>

<p><b>procedure Rewrite(var f: file);</b></p>

<p>Opens file for writing</p>

<p><b>procedure Rewrite(var f: TypedFile);</b></p>

<p>Opens file for writing</p>

<p><b>procedure Rewrite(var t: Text);</b></p>

<p>Opens file for writing</p>

<p><b>procedure Seek(var f: file; Pos: Int64);</b></p>

<p>Sets file position</p>

<p><b>function SeekEOF(var t: Text):Boolean;</b></p>

<p>Sets file position to end of file</p>

<p><b>function SeekEOF: Boolean;</b></p>

<p>Sets file position to end of file</p>

<p><b>function SeekEOLn(var t: Text):Boolean;</b></p>

<p>Sets file position to end of line</p>

<p><b>function SeekEOLn: Boolean;</b></p>

<p>Sets file position to end of line</p>

<p><b>procedure SetTextBuf(var f: Text; var Buf);</b></p>

<p>Sets size of file buffer</p>

<p><b>procedure SetTextBuf(var f: Text; var Buf; Size: SizeInt);</b></p>

<p>Sets size of file buffer</p>

<p><b>procedure Truncate(var F: file);</b></p>

<p>Truncate the file at position</p>

<p><b>procedure Write(Args: Arguments);</b></p>

<p>Writes variable to file</p>

<p><b>procedure Write(var F: Text; Args: Arguments);</b></p>

<p>Write variable to file</p>

<p><b>procedure Writeln(Args: Arguments);</b></p>

<p>Writes variable to file and append newline</p>

<p><b>procedure WriteLn(var F: Text; Args: Arguments);</b></p>

<p>Writes variable to file and append newline</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
type
file-name = file of base-type;
</pre>
<p>Where, the base-type indicates the type of the components of the file. The base type could be anything like, integer, real, Boolean, enumerated, subrange, record, arrays and sets except another file type. Variables of a file type are created using the <i>var</i> declaration &minus;</p>
<pre class="prettyprint notranslate">
var
f1, f2,...: file-name;
</pre>
<p>Following are some examples of defining some file types and file variables &minus;</p>
<pre class="prettyprint notranslate">
type
   rfile = file of real;
   ifile = file of integer;
   bfile = file of boolean;
   datafile = file of record
   arrfile = file of array[1..4] of integer;

var
   marks: arrfile;
   studentdata: datafile;
   rainfalldata: rfile;
   tempdata: ifile;
   choices: bfile;
</pre>
<h2>Creating and Writing to a File</h2>
<p>Let us write a program that would create a data file for students' records. It would create a file named students.dat and write a student's data into it &minus;</p>
<pre class="prettyprint notranslate">
program DataFiles;
type
   StudentRecord = Record
      s_name: String;
      s_addr: String;
      s_batchcode: String;
   end;

var
   Student: StudentRecord;
   f: file of StudentRecord;

begin
   Assign(f,'students.dat');
   Rewrite(f);
   Student.s_name := 'John Smith';
   Student.s_addr := 'United States of America';
   Student.s_batchcode := 'Computer Science';
   Write(f,Student);
   Close(f);
end.
</pre>
<p>When compiled and run, the program would create a file named <i>students.dat</i> into the working directory. You can open the file using a text editor, like notepad, to look at John Smith's data.</p>
<h2>Reading from a File</h2>
<p>We have just created and written into a file named students.dat. Now, let us write a program that would read the student's data from the file &minus;</p>
<pre class="prettyprint notranslate">
program DataFiles;
type
   StudentRecord = Record
      s_name: String;
      s_addr: String;
      s_batchcode: String;
   end;

var
   Student: StudentRecord;
   f: file of StudentRecord;

begin
   assign(f, 'students.dat');
   reset(f); 
   while not eof(f) do
   
   begin
      read(f,Student);
      writeln('Name: ',Student.s_name);
      writeln('Address: ',Student.s_addr);
      writeln('Batch Code: ', Student.s_batchcode);
   end;
   
   close(f);
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Name: John Smith
Address: United States of America
Batch Code: Computer Science
</pre>
<h2>Files as Subprogram Parameter</h2>
<p>Pascal allows file variables to be used as parameters in standard and user-defined subprograms. The following example illustrates this concept. The program creates a file named rainfall.txt and stores some rainfall data. Next, it opens the file, reads the data and computes the average rainfall.</p>
<p>Please note that, <b>if you use a file parameter with subprograms, it must be declared as a var parameter.</b></p>
<pre class="prettyprint notranslate tryit">
program addFiledata;
const
   MAX = 4;
type
   raindata = file of real;

var
   rainfile: raindata;
   filename: string;
procedure writedata(var f: raindata);

var
   data: real;
   i: integer;

begin
   rewrite(f, sizeof(data));
   for i:=1 to MAX do
   
   begin
      writeln('Enter rainfall data: ');
      readln(data);
      write(f, data);
   end;
   
   close(f);
end;

procedure computeAverage(var x: raindata);
var
   d, sum: real;
   average: real;

begin
   reset(x);
   sum:= 0.0;
   while not eof(x) do
   
   begin
      read(x, d);
      sum := sum + d;
   end;
   
   average := sum/MAX;
   close(x);
   writeln('Average Rainfall: ', average:7:2);
end;

begin
   writeln('Enter the File Name: ');
   readln(filename);
   assign(rainfile, filename);
   writedata(rainfile);
   computeAverage(rainfile);
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Enter the File Name:
rainfall.txt
Enter rainfall data:
34
Enter rainfall data:
45
Enter rainfall data:
56
Enter rainfall data:
78
Average Rainfall: 53.25
</pre>
<h2>Text Files</h2>
<p>A text file, in Pascal, consists of lines of characters where each line is terminated with an end-of-line marker. You can declare and define such files as &minus;</p>
<pre class="prettyprint notranslate">
type
file-name = text;
</pre>
<p>Difference between a normal file of characters and a text file is that a text file is divided into lines, each terminated by a special end-of-line marker, automatically inserted by the system. The following example creates and writes into a text file named contact.txt &minus;</p>
<pre class="prettyprint notranslate tryit">
program exText;
var
   filename, data: string;
   myfile: text;

begin
   writeln('Enter the file name: ');
   readln(filename);
   
   assign(myfile, filename);
   rewrite(myfile);
   
   writeln(myfile, 'Note to Students: ');
   writeln(myfile, 'For details information on Pascal Programming');
   writeln(myfile, 'Contact: Tutorials Point');
   writeln('Completed writing'); 
   
   close(myfile);
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Enter the file name:
contact.txt 
Completed writing
</pre>
<h2>Appending to a File</h2>
<p>Appending to a file means writing to an existing file that already has some data without overwriting the file. The following program illustrates this &minus;</p>
<pre class="prettyprint notranslate tryit">
program exAppendfile;
var
   myfile: text;
   info: string;

begin
   assign(myfile, 'contact.txt');
   append(myfile);
   
   writeln('Contact Details');
   writeln('webmaster@tutorialspoint.com');
   close(myfile);
   
   (* let us read from this file *)
   assign(myfile, 'contact.txt');
   reset(myfile);
   while not eof(myfile) do
   
   begin
      readln(myfile, info);
      writeln(info);
   end;
   close(myfile);
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Contact Details
webmaster@tutorialspoint.com
Note to Students:
For details information on Pascal Programming
Contact: Tutorials Point
</pre>

<title>Pascal Memory Management</title>

<h1>Pascal - Memory Management</h1>

<p>This chapter explains dynamic memory management in Pascal. Pascal programming language provides several functions for memory allocation and management.</p>

<h2>Allocating Memory Dynamically</h2>

<p>While doing programming, if you are aware about the size of an array, then it is easy and you can define it as an array. For example, to store a name of any person, it can go max 100 characters so you can define something as follows &minus;</p>

<p>But now, let us consider a situation, where you have no idea about the length of the text you need to store, for example, you want to store a detailed description about a topic.  Here, we need to define a pointer to string without defining how much memory is required.</p>

<p>Pascal provides a procedure <b>new</b>to create pointer variables.</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<p>Now, if you need to define a pointer with specific number of bytes to be referred by it later, you should use the <b>getmem</b> function or the <b>getmem</b> procedure, which has the following syntax &minus;</p>

<p>In the previous example, we declared a pointer to a string. A string has a maximum value of 255 bytes. If you really don't need that much space, or a larger space, in terms of bytes, <i>getmem</i> subprogram allows specifying that. Let us rewrite the previous example, using <i>getmem</i> &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<p>So, you have complete control and you can pass any size value while allocating memory unlike arrays, where once you defined the size cannot be changed.</p>

<h2>Resizing and Releasing Memory</h2>

<p>When your program comes out, operating system automatically releases all the memory allocated by your program, but as a good practice when you are not in need of memory anymore, then you should release that memory.</p>

<p>Pascal provides the procedure <b>dispose</b> to free a dynamically created variable using the procedure <b>new.</b> If you have allocated memory using the <b>getmem</b> subprogram, then you need to use the subprogram <b>freemem</b> to free this memory. The <i>freemem</i> subprograms have the following syntax &minus;</p>

<p>Alternatively, you can increase or decrease the size of an allocated memory block by calling the function <i>ReAllocMem</i>. Let us check the above program once again and make use of <i>ReAllocMem</i> and <i>freemem</i> subprograms. Following is the syntax for <i>ReAllocMem</i> &minus;</p>

<p>Following is an example which makes use of <i>ReAllocMem</i> and <i>freemem</i> subprograms &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<h2>Memory Management Functions</h2>

<p>Pascal provides a hoard of memory management functions that is used in implementing various data structures and implementing low-level programming in Pascal. Many of these functions are implementation dependent. Free Pascal provides the following functions and procedures for memory management &minus;</p>

<p><b>function Addr(X: TAnytype):Pointer;</b></p>

<p>Returns address of variable</p>

<p><b>function Assigned(P: Pointer):Boolean;</b></p>

<p>Checks if a pointer is valid</p>

<p><b>function CompareByte(const buf1; const buf2; len: SizeInt):SizeInt;</b></p>

<p>Compares 2 memory buffers byte per byte</p>

<p><b>function CompareChar(const buf1; const buf2; len: SizeInt):SizeInt;</b></p>

<p>Compares 2 memory buffers byte per byte</p>

<p><b>function CompareDWord(const buf1; const buf2; len: SizeInt):SizeInt;</b></p>

<p>Compares 2 memory buffers byte per byte</p>

<p><b>function CompareWord(const buf1; const buf2; len: SizeInt):SizeInt;</b></p>

<p>Compares 2 memory buffers byte per byte</p>

<p><b>function Cseg: Word;</b></p>

<p>Returns code segment</p>

<p><b>procedure Dispose(P: Pointer);</b></p>

<p>Frees dynamically allocated memory</p>

<p><b>procedure Dispose(P: TypedPointer; Des: TProcedure);</b></p>

<p>Frees dynamically allocated memory</p>

<p><b>function Dseg: Word;</b></p>

<p>Returns data segment</p>

<p><b>procedure FillByte(var x; count: SizeInt;  value: Byte);</b></p>

<p>Fills memory region with 8-bit pattern</p>

<p><b>procedure FillChar(  var x;  count: SizeInt; Value: Byte|Boolean|Char);</b></p>

<p>Fills memory region with certain character</p>

<p><b>procedure FillDWord( var x; count: SizeInt; value: DWord);</b></p>

<p>Fills memory region with 32-bit pattern</p>

<p><b>procedure FillQWord( var x;  count: SizeInt;  value: QWord);</b></p>

<p>Fills memory region with 64-bit pattern</p>

<p><b>procedure Freemem(  p: pointer;  Size: PtrUInt);</b></p>

<p>Releases allocated memory</p>

<p><b>procedure Freemem(  p: pointer );</b></p>

<p>Releases allocated memory</p>

<p><b>procedure Getmem( out p: pointer; Size: PtrUInt);</b></p>

<p>Allocates new memory</p>

<p><b>procedure Getmem( out p: pointer);</b></p>

<p>Allocates new memory</p>

<p><b>procedure GetMemoryManager(  var MemMgr: TMemoryManager);</b></p>

<p>Returns current memory manager</p>

<p><b>function High(  Arg: TypeOrVariable):TOrdinal;</b></p>

<p>Returns highest index of open array or enumerated</p>

<p><b>function IndexByte(  const buf;  len: SizeInt;  b: Byte):SizeInt;</b></p>

<p>Finds byte-sized value in a memory range</p>

<p><b>function IndexChar(  const buf;  len: SizeInt;  b: Char):SizeInt;</b></p>

<p>Finds char-sized value in a memory range</p>

<p><b>function IndexDWord(  const buf;  len: SizeInt;  b: DWord):SizeInt;</b></p>

<p>Finds DWord-sized (32-bit) value in a memory range</p>

<p><b>function IndexQWord(  const buf;  len: SizeInt;  b: QWord):SizeInt;</b></p>

<p>Finds QWord-sized value in a memory range</p>

<p><b>function Indexword(  const buf;  len: SizeInt;  b: Word):SizeInt;</b></p>

<p>Finds word-sized value in a memory range</p>

<p><b>function IsMemoryManagerSet: Boolean;</b></p>

<p>Is the memory manager set</p>

<p><b>function Low(  Arg: TypeOrVariable ):TOrdinal;</b></p>

<p>Returns lowest index of open array or enumerated</p>

<p><b>procedure Move(  const source;  var dest;  count: SizeInt );</b></p>

<p>Moves data from one location in memory to another</p>

<p><b>procedure MoveChar0(  const buf1;  var buf2;  len: SizeInt);</b></p>

<p>Moves data till first zero character</p>

<p><b>procedure New(  var P: Pointer);</b></p>

<p>Dynamically allocate memory for variable</p>

<p><b>procedure New(  var P: Pointer;  Cons: TProcedure);</b></p>

<p>Dynamically allocates memory for variable</p>

<p><b>function Ofs(  var X ):LongInt;</b></p>

<p>Returns offset of variable</p>

<p><b>function ptr(  sel: LongInt;  off: LongInt):farpointer;</b></p>

<p>Combines segment and offset to pointer</p>

<p><b>function ReAllocMem(  var p: pointer;  Size: PtrUInt):pointer;</b></p>

<p>Resizes a memory block on the heap</p>

<p><b>function Seg(  var X):LongInt;</b></p>

<p>Returns segment</p>

<p><b>procedure SetMemoryManager(  const MemMgr: TMemoryManager );</b></p>

<p>Sets a memory manager</p>

<p><b>function Sptr: Pointer;</b></p>

<p>Returns current stack pointer</p>

<p><b>function Sseg: Word;</b></p>

<p>Returns stack segment register value</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
var
name: array[1..100] of char;
</pre>
<p>But now, let us consider a situation, where you have no idea about the length of the text you need to store, for example, you want to store a detailed description about a topic.  Here, we need to define a pointer to string without defining how much memory is required.</p>
<p>Pascal provides a procedure <b>new</b>to create pointer variables.</p>
<pre class="prettyprint notranslate tryit">
program exMemory;
var
name: array[1..100] of char;
description: ^string;

begin
   name:= 'Zara Ali';
   
   new(description);
      if not assigned(description) then
         writeln(' Error - unable to allocate required memory')
      else
         description^ := 'Zara ali a DPS student in class 10th';
   writeln('Name = ', name );
   writeln('Description: ', description^ );
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Name = Zara Ali
Description: Zara ali a DPS student in class 10th
</pre>
<p>Now, if you need to define a pointer with specific number of bytes to be referred by it later, you should use the <b>getmem</b> function or the <b>getmem</b> procedure, which has the following syntax &minus;</p>
<pre class="prettyprint notranslate">
procedure Getmem(
   out p: pointer;
   Size: PtrUInt
);

function GetMem(
   size: PtrUInt
):pointer;
</pre>
<p>In the previous example, we declared a pointer to a string. A string has a maximum value of 255 bytes. If you really don't need that much space, or a larger space, in terms of bytes, <i>getmem</i> subprogram allows specifying that. Let us rewrite the previous example, using <i>getmem</i> &minus;</p>
<pre class="prettyprint notranslate tryit">
program exMemory;
var
name: array[1..100] of char;
description: ^string;

begin
   name:= 'Zara Ali';
   
   description := getmem(200);
      if not assigned(description) then
         writeln(' Error - unable to allocate required memory')
      else
         description^ := 'Zara ali a DPS student in class 10th';
   writeln('Name = ', name );
   writeln('Description: ', description^ );
   
   freemem(description);
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Name = Zara Ali
Description: Zara ali a DPS student in class 10th
</pre>
<p>So, you have complete control and you can pass any size value while allocating memory unlike arrays, where once you defined the size cannot be changed.</p>
<h2>Resizing and Releasing Memory</h2>
<p>When your program comes out, operating system automatically releases all the memory allocated by your program, but as a good practice when you are not in need of memory anymore, then you should release that memory.</p>
<p>Pascal provides the procedure <b>dispose</b> to free a dynamically created variable using the procedure <b>new.</b> If you have allocated memory using the <b>getmem</b> subprogram, then you need to use the subprogram <b>freemem</b> to free this memory. The <i>freemem</i> subprograms have the following syntax &minus;</p>
<pre class="prettyprint notranslate">
procedure Freemem(
   p: pointer;
  Size: PtrUInt
);

function Freemem(
   p: pointer
):PtrUInt;
</pre>
<p>Alternatively, you can increase or decrease the size of an allocated memory block by calling the function <i>ReAllocMem</i>. Let us check the above program once again and make use of <i>ReAllocMem</i> and <i>freemem</i> subprograms. Following is the syntax for <i>ReAllocMem</i> &minus;</p>
<pre class="prettyprint notranslate">
function ReAllocMem(
   var p: pointer;
   Size: PtrUInt
):pointer;   
</pre>
<p>Following is an example which makes use of <i>ReAllocMem</i> and <i>freemem</i> subprograms &minus;</p>
<pre class="prettyprint notranslate tryit">
program exMemory;
var
name: array[1..100] of char;
description: ^string;
desp: string;

begin
   name:= 'Zara Ali';
   desp := 'Zara ali a DPS student.';
   
   description := getmem(30);
      if not assigned(description) then
         writeln('Error - unable to allocate required memory')
      else
         description^ := desp;

   (* Suppose you want to store bigger description *)
   description := reallocmem(description, 100);
   desp := desp + ' She is in class 10th.';
   description^:= desp; 
   
   writeln('Name = ', name );
   writeln('Description: ', description^ );
   
   freemem(description);
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Name = Zara Ali
Description: Zara ali a DPS student. She is in class 10th
</pre>

<title>Pascal Units</title>

<h1>Pascal - Units</h1>

<p>A Pascal program can consist of modules called units. A unit might consist of some code blocks, which in turn are made up of variables and type declarations, statements, procedures, etc. There are many built-in units in Pascal and Pascal allows programmers to define and write their own units to be used later in various programs.</p>

<h2>Using Built-in Units</h2>

<p>Both the built-in units and user-defined units are included in a program by the uses clause. We have already used the variants unit in <i>Pascal - Variants</i> tutorial. This tutorial explains creating and including user-defined units. However, let us first see how to include a built-in unit <b>crt</b> in your program &minus;</p>

<p>The following example illustrates using the <b>crt</b> unit &minus;</p>

<p>It is the same program we used right at the beginning of the Pascal tutorial, compile and run it to find the effects of the change.</p>

<h2>Creating and Using a Pascal Unit</h2>

<p>To create a unit, you need to write the modules or subprograms you want to store in it and save it in a file with <b>.pas</b> extension. The first line of this file should start with the keyword unit followed by the name of the unit. For example &minus;</p>

<p>Following are three important steps in creating a Pascal unit &minus;</p>

<p>The name of the file and the name of the unit should be exactly same. So, our unit <i>calculateArea</i> will be saved in a file named <i>calculateArea.pas.</i></p>

<p>The next line should consist of a single keyword <b>interface</b>. After this line, you will write the declarations for all the functions and procedures that will come in this unit.</p>

<p>Right after the function declarations, write the word <b>implementation</b>, which is again a keyword. After the line containing the keyword implementation, provide definition of all the subprograms.</p>

<p>The following program creates the unit named calculateArea &minus;</p>

<p>Next, let us write a simple program that would use the unit we defined above &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
program myprog;
uses crt;
</pre>
<p>The following example illustrates using the <b>crt</b> unit &minus;</p>
<pre class="prettyprint notranslate">
Program Calculate_Area (input, output);
uses crt;
var 
   a, b, c, s, area: real;

begin
   textbackground(white); (* gives a white background *)
   clrscr; (*clears the screen *)
   
   textcolor(green); (* text color is green *)
   gotoxy(30, 4); (* takes the pointer to the 4th line and 30th column) 
   
   writeln('This program calculates area of a triangle:');
   writeln('Area = area = sqrt(s(s-a)(s-b)(s-c))');
   writeln('S stands for semi-perimeter');
   writeln('a, b, c are sides of the triangle');
   writeln('Press any key when you are ready');
   
   readkey;
   clrscr;
   gotoxy(20,3);
   
   write('Enter a: ');
   readln(a);
   gotoxy(20,5);
   
   write('Enter b:');
   readln(b);
   gotoxy(20, 7);
   
   write('Enter c: ');
   readln(c);

   s := (a + b + c)/2.0;
   area := sqrt(s * (s - a)*(s-b)*(s-c));
   gotoxy(20, 9);
   
   writeln('Area: ',area:10:3);
   readkey;
end.
</pre>
<p>It is the same program we used right at the beginning of the Pascal tutorial, compile and run it to find the effects of the change.</p>
<h2>Creating and Using a Pascal Unit</h2>
<p>To create a unit, you need to write the modules or subprograms you want to store in it and save it in a file with <b>.pas</b> extension. The first line of this file should start with the keyword unit followed by the name of the unit. For example &minus;</p>
<pre class="result notranslate">
unit calculateArea;
</pre>
<p>Following are three important steps in creating a Pascal unit &minus;</p>
<ul class="list">
<li><p>The name of the file and the name of the unit should be exactly same. So, our unit <i>calculateArea</i> will be saved in a file named <i>calculateArea.pas.</i></p></li>
<li><p>The next line should consist of a single keyword <b>interface</b>. After this line, you will write the declarations for all the functions and procedures that will come in this unit.</p></li>
<li><p>Right after the function declarations, write the word <b>implementation</b>, which is again a keyword. After the line containing the keyword implementation, provide definition of all the subprograms.</p></li>
</ul>
<p>The following program creates the unit named calculateArea &minus;</p>
<pre class="prettyprint notranslate">
unit CalculateArea;
interface

function RectangleArea( length, width: real): real;
function CircleArea(radius: real) : real;
function TriangleArea( side1, side2, side3: real): real;

implementation

function RectangleArea( length, width: real): real;
begin
   RectangleArea := length * width;
end;

function CircleArea(radius: real) : real;
const
   PI = 3.14159;
begin
   CircleArea := PI * radius * radius;
end;

function TriangleArea( side1, side2, side3: real): real;
var
   s, area: real;

begin
   s := (side1 + side2 + side3)/2.0;
   area := sqrt(s * (s - side1)*(s-side2)*(s-side3));
   TriangleArea := area;
end;

end.
</pre>
<p>Next, let us write a simple program that would use the unit we defined above &minus;</p>
<pre class="prettyprint notranslate">
program AreaCalculation;
uses CalculateArea,crt;

var
   l, w, r, a, b, c, area: real;

begin
   clrscr;
   l := 5.4;
   w := 4.7;
   area := RectangleArea(l, w);
   writeln('Area of Rectangle 5.4 x 4.7 is: ', area:7:3);

   r:= 7.0;
   area:= CircleArea(r);
   writeln('Area of Circle with radius 7.0 is: ', area:7:3);

   a := 3.0;
   b:= 4.0;
   c:= 5.0;
  
   area:= TriangleArea(a, b, c);
   writeln('Area of Triangle 3.0 by 4.0 by 5.0 is: ', area:7:3);
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Area of Rectangle 5.4 x 4.7 is: 25.380
Area of Circle with radius 7.0 is: 153.938
Area of Triangle 3.0 by 4.0 by 5.0 is: 6.000
</pre>

<title>Pascal Date and Time</title>

<h1>Pascal - Date and Time</h1>

<p>Most of the softwares you write need implementing some form of date functions returning current date and time. Dates are so much part of everyday life that it becomes easy to work with them without thinking. Pascal also provides powerful tools for date arithmetic that makes manipulating dates easy. However, the actual name and workings of these functions are different for different compilers.</p>

<h2>Getting the Current Date &amp; Time</h2>

<p>Pascal's TimeToString function gives you the current time in a colon(: ) delimited form. The following example shows how to get the current time &minus;</p>

<p>When the above code was compiled and executed, it produces the following result &minus;</p>

<p>The <b>Date</b> function returns the current date in <b>TDateTime</b> format. The TDateTime is a double value, which needs some decoding and formatting. The following program demonstrates how to use it in your program to display the current date &minus;</p>

<p>When the above code was compiled and executed, it produces the following result &minus;</p>

<p>The Now function returns the current date and time &minus;</p>

<p>When the above code was compiled and executed, it produces the following result &minus;</p>

<p>Free Pascal provides a simple time stamp structure named <b>TTimeStamp</b>, which has the following format &minus;</p>

<h2>Various Date &amp; Time Functions</h2>

<p>Free Pascal provides the following date and time functions &minus;</p>

<p><b>function DateTimeToFileDate(DateTime: TDateTime):LongInt;</b></p>

<p>Converts DateTime type to file date.</p>

<p><b>function DateTimeToStr( DateTime: TDateTime):; </b></p>

<p>Constructs string representation of DateTime</p>

<p><b>function DateTimeToStr(DateTime: TDateTime; const FormatSettings: TFormatSettings):;</b></p>

<p>Constructs string representation of DateTime</p>

<p><b>procedure DateTimeToString(out Result: ;const FormatStr: ;const DateTime: TDateTime);</b></p>

<p>Constructs string representation of DateTime</p>

<p><b>procedure DateTimeToString(out Result: ; const FormatStr: ; const DateTime: TDateTime; const FormatSettings: TFormatSettings);</b></p>

<p>Constructs string representation of DateTime</p>

<p><b>procedure DateTimeToSystemTime(DateTime: TDateTime; out SystemTime: TSystemTime);</b></p>

<p>Converts DateTime to system time</p>

<p><b>function DateTimeToTimeStamp( DateTime: TDateTime):TTimeStamp;</b>Converts DateTime to timestamp</p>

<p><b>function DateToStr(Date: TDateTime):;</b></p>

<p>Constructs string representation of date</p>

<p><b>function DateToStr(Date: TDateTime; const FormatSettings: TFormatSettings):;</b></p>

<p>Constructs string representation of date</p>

<p><b>function Date: TDateTime;</b></p>

<p>Gets current date</p>

<p><b>function DayOfWeek(DateTime: TDateTime):Integer;</b></p>

<p>Gets day of week</p>

<p><b>procedure DecodeDate(Date: TDateTime; out Year: Word; out Month: Word; out Day: Word);</b></p>

<p>Decodes DateTime to year month and day</p>

<p><b>procedure DecodeTime(Time: TDateTime; out Hour: Word; out Minute: Word; out Second: Word;  out MilliSecond: Word);</b></p>

<p>Decodes DateTime to hours, minutes and seconds</p>

<p><b>function EncodeDate(Year: Word; Month: Word; Day: Word):TDateTime; </b></p>

<p>Encodes year, day and month to DateTime</p>

<p><b>function EncodeTime(Hour: Word; Minute: Word; Second: Word; MilliSecond: Word):TDateTime; </b></p>

<p>Encodes hours, minutes and seconds to DateTime</p>

<p><b>function FormatDateTime(const FormatStr: ; DateTime: TDateTime):;</b></p>

<p>Returns string representation of DateTime</p>

<p><b>function FormatDateTime(const FormatStr: ; DateTime: TDateTime; const FormatSettings: TFormatSettings):;</b></p>

<p>Returns string representation of DateTime</p>

<p><b>function IncMonth(const DateTime: TDateTime; NumberOfMonths: Integer = 1):TDateTime;</b></p>

<p>Adds 1 to month</p>

<p><b>function IsLeapYear(Year: Word):Boolean;</b></p>

<p>Determines if year is leap year</p>

<p><b>function MSecsToTimeStamp(MSecs: Comp):TTimeStamp;</b></p>

<p>Converts number of milliseconds to timestamp</p>

<p><b>function Now: TDateTime;</b></p>

<p>Gets current date and time</p>

<p><b>function StrToDateTime(const S:):TDateTime;</b></p>

<p>Converts string to DateTime</p>

<p><b>function StrToDateTime(const s: ShortString; const FormatSettings: TFormatSettings):TDateTime;</b></p>

<p>Converts string to DateTime</p>

<p><b>function StrToDateTime(const s: AnsiString; const FormatSettings: TFormatSettings):TDateTime;</b></p>

<p>Converts string to DateTime</p>

<p><b>function StrToDate(const S: ShortString):TDateTime;</b></p>

<p>Converts string to date</p>

<p><b>function StrToDate(const S: Ansistring):TDateTime;</b></p>

<p>Converts string to date</p>

<p><b>function StrToDate(const S: ShortString; separator: Char):TDateTime;</b></p>

<p>Converts string to date</p>

<p><b>function StrToDate(const S: AnsiString; separator: Char):TDateTime;</b></p>

<p>Converts string to date</p>

<p>Converts string to date</p>

<p><b>function StrToDate(const S: AnsiString; const useformat: ; separator: Char):TDateTime;</b></p>

<p>Converts string to date</p>

<p><b>function StrToDate(const S: PChar; Len: Integer; const useformat: ; separator: Char = #0):TDateTime;</b></p>

<p>Converts string to date</p>

<p><b>function StrToTime(const S: Shortstring):TDateTime;</b></p>

<p>Converts string to time</p>

<p><b>function StrToTime(const S: Ansistring):TDateTime;</b></p>

<p>Converts string to time</p>

<p><b>function StrToTime(const S: ShortString; separator: Char):TDateTime;</b></p>

<p>Converts string to time</p>

<p><b>function StrToTime(const S: AnsiString; separator: Char):TDateTime;</b></p>

<p>Converts string to time</p>

<p><b>function StrToTime(const S: ; FormatSettings: TFormatSettings):TDateTime;</b></p>

<p>Converts string to time</p>

<p><b>function StrToTime(const S: PChar; Len: Integer; separator: Char = #0):TDateTime;</b></p>

<p>Converts string to time</p>

<p><b>function SystemTimeToDateTime(const SystemTime: TSystemTime):TDateTime;</b></p>

<p>Converts system time to datetime</p>

<p><b>function TimeStampToDateTime(const TimeStamp: TTimeStamp):TDateTime;</b></p>

<p>Converts time stamp to DateTime</p>

<p><b>function TimeStampToMSecs(const TimeStamp: TTimeStamp):comp;</b></p>

<p>Converts Timestamp to number of milliseconds</p>

<p><b>function TimeToStr(Time: TDateTime):;</b></p>

<p>Returns string representation of Time</p>

<p><b>function TimeToStr(Time: TDateTime; const FormatSettings: TFormatSettings):;</b></p>

<p>Returns string representation of Time</p>

<p><b>function Time: TDateTime;</b></p>

<p>Get current time</p>

<p>The following example illustrates the use of some of the above functions &minus;</p>

<p>When the above code was compiled and executed, it produced the following result:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate tryit">
program TimeDemo;
uses sysutils;

begin
   writeln ('Current time : ',TimeToStr(Time));
end.
</pre>
<p>When the above code was compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Current time : 18:33:08
</pre>
<p>The <b>Date</b> function returns the current date in <b>TDateTime</b> format. The TDateTime is a double value, which needs some decoding and formatting. The following program demonstrates how to use it in your program to display the current date &minus;</p>
<pre class="prettyprint notranslate tryit">
Program DateDemo;
uses sysutils;
var
   YY,MM,DD : Word;

begin
   writeln ('Date : ',Date);
   DeCodeDate (Date,YY,MM,DD);
   writeln (format ('Today is (DD/MM/YY): %d/%d/%d ',[dd,mm,yy]));
end.
</pre>
<p>When the above code was compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Date: 4.111300000000000E+004
Today is (DD/MM/YY):23/7/2012
</pre>
<p>The Now function returns the current date and time &minus;</p>
<pre class="prettyprint notranslate tryit">
Program DatenTimeDemo;
uses sysutils;
begin
   writeln ('Date and Time at the time of writing : ',DateTimeToStr(Now));
end.
</pre>
<p>When the above code was compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Date and Time at the time of writing : 23/7/2012 18:51:
</pre>
<p>Free Pascal provides a simple time stamp structure named <b>TTimeStamp</b>, which has the following format &minus;</p>
<pre class="prettyprint notranslate">
type TTimeStamp = record
   Time: Integer;
   Date: Integer;
end;
</pre>
<h2>Various Date &amp; Time Functions</h2>
<p>Free Pascal provides the following date and time functions &minus;</p>
<table class="table table-bordered">
<tr>
<th style="width:5%;">Sr.No.</th>
<th>Function Name &amp; Description</th>
</tr>
<tr>
<td>1</td>
<td>
<p><b>function DateTimeToFileDate(DateTime: TDateTime):LongInt;</b></p> 
<p>Converts DateTime type to file date.</p></td>
</tr>
<tr>
<td>2</td>
<td>
<p><b>function DateTimeToStr( DateTime: TDateTime):; </b></p>
<p>Constructs string representation of DateTime</p>
</td>
</tr>
<tr>
<td>3</td>
<td>
<p><b>function DateTimeToStr(DateTime: TDateTime; const FormatSettings: TFormatSettings):;</b></p>
<p>Constructs string representation of DateTime</p>
</td>
</tr>
<tr>
<td>4</td>
<td>
<p><b>procedure DateTimeToString(out Result: ;const FormatStr: ;const DateTime: TDateTime);</b></p> 
<p>Constructs string representation of DateTime</p>
</td>
</tr>
<tr>
<td>5</td>
<td>
<p><b>procedure DateTimeToString(out Result: ; const FormatStr: ; const DateTime: TDateTime; const FormatSettings: TFormatSettings);</b></p>
<p>Constructs string representation of DateTime</p>
</td>
</tr>
<tr>
<td>6</td>
<td>
<p><b>procedure DateTimeToSystemTime(DateTime: TDateTime; out SystemTime: TSystemTime);</b></p>
<p>Converts DateTime to system time</p>
</td>
</tr>
<tr>
<td>7</td>
<td>
<p><b>function DateTimeToTimeStamp( DateTime: TDateTime):TTimeStamp;</b>Converts DateTime to timestamp</p></td>
</tr>
<tr>
<td>8</td>
<td>
<p><b>function DateToStr(Date: TDateTime):;</b></p> 
<p>Constructs string representation of date</p>
</td>
</tr>
<tr>
<td>9</td>
<td>
<p><b>function DateToStr(Date: TDateTime; const FormatSettings: TFormatSettings):;</b></p> 
<p>Constructs string representation of date</p>
</td>
</tr>
<tr>
<td>10</td>
<td>
<p><b>function Date: TDateTime;</b></p> 
<p>Gets current date</p>
</td>
</tr>
<tr>
<td>11</td>
<td>
<p><b>function DayOfWeek(DateTime: TDateTime):Integer;</b></p> 
<p>Gets day of week</p>
</td>
</tr>
<tr>
<td>12</td>
<td>
<p><b>procedure DecodeDate(Date: TDateTime; out Year: Word; out Month: Word; out Day: Word);</b></p> 
<p>Decodes DateTime to year month and day</p>
</td>
</tr>
<tr>
<td>13</td>
<td>
<p><b>procedure DecodeTime(Time: TDateTime; out Hour: Word; out Minute: Word; out Second: Word;  out MilliSecond: Word);</b></p> 
<p>Decodes DateTime to hours, minutes and seconds</p>
</td>
</tr>
<tr>
<td>14</td>
<td>
<p><b>function EncodeDate(Year: Word; Month: Word; Day: Word):TDateTime; </b></p> 
<p>Encodes year, day and month to DateTime</p>
</td>
</tr>
<tr>
<td>15</td>
<td>
<p><b>function EncodeTime(Hour: Word; Minute: Word; Second: Word; MilliSecond: Word):TDateTime; </b></p> 
<p>Encodes hours, minutes and seconds to DateTime</p>
</td>
</tr>
<tr>
<td>16</td>
<td>
<p><b>function FormatDateTime(const FormatStr: ; DateTime: TDateTime):;</b></p> 
<p>Returns string representation of DateTime</p>
</td>
</tr>
<tr>
<td>17</td>
<td>
<p><b>function FormatDateTime(const FormatStr: ; DateTime: TDateTime; const FormatSettings: TFormatSettings):;</b></p> 
<p>Returns string representation of DateTime</p>
</td>
</tr>
<tr>
<td>18</td>
<td>
<p><b>function IncMonth(const DateTime: TDateTime; NumberOfMonths: Integer = 1):TDateTime;</b></p> 
<p>Adds 1 to month</p>
</td>
</tr>
<tr>
<td>19</td>
<td>
<p><b>function IsLeapYear(Year: Word):Boolean;</b></p> 
<p>Determines if year is leap year</p>
</td>
</tr>
<tr>
<td>20</td>
<td>
<p><b>function MSecsToTimeStamp(MSecs: Comp):TTimeStamp;</b></p> 
<p>Converts number of milliseconds to timestamp</p>
</td>
</tr>
<tr>
<td>21</td>
<td>
<p><b>function Now: TDateTime;</b></p> 
<p>Gets current date and time</p>
</td>
</tr>
<tr>
<td>22</td>
<td>
<p><b>function StrToDateTime(const S:):TDateTime;</b></p> 
<p>Converts string to DateTime</p>
</td>
</tr>
<tr>
<td>23</td>
<td>
<p><b>function StrToDateTime(const s: ShortString; const FormatSettings: TFormatSettings):TDateTime;</b></p> 
<p>Converts string to DateTime</p>
</td>
</tr>
<tr>
<td>24</td>
<td>
<p><b>function StrToDateTime(const s: AnsiString; const FormatSettings: TFormatSettings):TDateTime;</b></p> 
<p>Converts string to DateTime</p>
</td>
</tr>
<tr>
<td>25</td>
<td>
<p><b>function StrToDate(const S: ShortString):TDateTime;</b></p> 
<p>Converts string to date</p>
</td>
</tr>
<tr>
<td>26</td>
<td>
<p><b>function StrToDate(const S: Ansistring):TDateTime;</b></p> 
<p>Converts string to date</p>
</td>
</tr>
<tr>
<td>27</td>
<td>
<p><b>function StrToDate(const S: ShortString; separator: Char):TDateTime;</b></p> 
<p>Converts string to date</p>
</td>
</tr>
<tr>
<td>28</td>
<td>
<p><b>function StrToDate(const S: AnsiString; separator: Char):TDateTime;</b></p> 
<p>Converts string to date</p>
</td>
</tr>
<tr>
<td>29</td>
<td>
<p><b>function StrToDate(const S: ShortString; const useformat: ; separator: Char):TDateTime;
</b></p>
<p>Converts string to date</p>
</td>
</tr>
<tr>
<td>30</td>
<td>
<p><b>function StrToDate(const S: AnsiString; const useformat: ; separator: Char):TDateTime;</b></p>
<p>Converts string to date</p>
</td>
</tr>
<tr>
<td>31</td>
<td>
<p><b>function StrToDate(const S: PChar; Len: Integer; const useformat: ; separator: Char = #0):TDateTime;</b></p> 
<p>Converts string to date</p>
</td>
</tr>
<tr>
<td>32</td>
<td>
<p><b>function StrToTime(const S: Shortstring):TDateTime;</b></p> 
<p>Converts string to time</p>
</td>
</tr>
<tr>
<td>33</td>
<td>
<p><b>function StrToTime(const S: Ansistring):TDateTime;</b></p> 
<p>Converts string to time</p>
</td>
</tr>
<tr>
<td>34</td>
<td>
<p><b>function StrToTime(const S: ShortString; separator: Char):TDateTime;</b></p> 
<p>Converts string to time</p>
</td>
</tr>
<tr>
<td>35</td>
<td>
<p><b>function StrToTime(const S: AnsiString; separator: Char):TDateTime;</b></p> 
<p>Converts string to time</p>
</td>
</tr>
<tr>
<td>36</td>
<td>
<p><b>function StrToTime(const S: ; FormatSettings: TFormatSettings):TDateTime;</b></p> 
<p>Converts string to time</p>
</td>
</tr>
<tr>
<td>37</td>
<td>
<p><b>function StrToTime(const S: PChar; Len: Integer; separator: Char = #0):TDateTime;</b></p> 
<p>Converts string to time</p>
</td>
</tr>
<tr>
<td>38</td>
<td>
<p><b>function SystemTimeToDateTime(const SystemTime: TSystemTime):TDateTime;</b></p> 
<p>Converts system time to datetime</p>
</td>
</tr>
<tr>
<td>39</td>
<td>
<p><b>function TimeStampToDateTime(const TimeStamp: TTimeStamp):TDateTime;</b></p> 
<p>Converts time stamp to DateTime</p>
</td>
</tr>
<tr>
<td>40</td>
<td>
<p><b>function TimeStampToMSecs(const TimeStamp: TTimeStamp):comp;</b></p>
<p>Converts Timestamp to number of milliseconds</p>
</td>
</tr>
<tr>
<td>41</td>
<td>
<p><b>function TimeToStr(Time: TDateTime):;</b></p>
<p>Returns string representation of Time</p>
</td>
</tr>
<tr>
<td>42</td>
<td>
<p><b>function TimeToStr(Time: TDateTime; const FormatSettings: TFormatSettings):;</b></p>
<p>Returns string representation of Time</p>
</td>
</tr>
<tr>
<td>43</td>
<td>
<p><b>function Time: TDateTime;</b></p>
<p>Get current time</p>
</td>
</tr>
</table>
<p>The following example illustrates the use of some of the above functions &minus;</p>
<pre class="prettyprint notranslate tryit">
Program DatenTimeDemo;
uses sysutils;
var
year, month, day, hr, min, sec, ms: Word;

begin
   writeln ('Date and Time at the time of writing : ',DateTimeToStr(Now));
   writeln('Today is ',LongDayNames[DayOfWeek(Date)]);
   writeln;
   writeln('Details of Date: ');
   
   DecodeDate(Date,year,month,day);
   writeln (Format ('Day: %d',[day]));
   writeln (Format ('Month: %d',[month]));
   writeln (Format ('Year: %d',[year]));
   writeln;
   writeln('Details of Time: ');
   
   DecodeTime(Time,hr, min, sec, ms);
   writeln (format('Hour: %d:',[hr]));
   writeln (format('Minutes: %d:',[min]));
   writeln (format('Seconds: %d:',[sec]));
   writeln (format('Milliseconds: %d:',[hr]));
end.
</pre>
<p>When the above code was compiled and executed, it produced the following result:</p>
<pre class="result notranslate">
Date and Time at the time of writing : 7/24/2012 8:26:
Today is Tuesday
Details of Date:
Day:24
Month:7
Year: 2012
Details of Time:
Hour: 8
Minutes: 26
Seconds: 21
Milliseconds: 8
</pre>

<title>Pascal Object Oriented</title>

<h1>Pascal - Object Oriented</h1>

<p>We can imagine our universe made of different objects like sun, earth, moon, etc. Similarly, we can imagine our car made of different objects like wheel, steering, gear, etc. Same way, there are object-oriented programming concepts, which assume everything as an object and implement a software using different objects. In Pascal, there are two structural data types used to implement a real world object &minus;</p>

<h2>Object-Oriented Concepts</h2>

<p>Before we go in detail, let's define important Pascal terms related to Object-Oriented Pascal.</p>

<p><b>Object</b> &minus; An Object is a special kind of record that contains fields like a record; however, unlike records, objects contain procedures and functions as part of the object. These procedures and functions are held as pointers to the methods associated with the object's type.</p>

<p><b>Class</b> &minus; A Class is defined in almost the same way as an Object, but there is a difference in way they are created. The Class is allocated on the Heap of a program, whereas the Object is allocated on the Stack. It is a pointer to the object, not the object itself.</p>

<p><b>Instantiation of a class</b> &minus; Instantiation means creating a variable of that class type. Since a class is just a pointer, when a variable of a class type is declared, there is memory allocated only for the pointer, not for the entire object. Only when it is instantiated using one of its constructors, memory is allocated for the object. Instances of a class are also called 'objects', but do not confuse them with Object Pascal Objects. In this tutorial, we will write 'Object' for Pascal Objects and 'object' for the conceptual object or class instance.</p>

<p><b>Member Variables</b> &minus; These are the variables defined inside a Class or an Object.</p>

<p><b>Member Functions</b> &minus; These are the functions or procedures defined inside a Class or an Object and are used to access object data.</p>

<p><b>Visibility of Members</b> &minus; The members of an Object or Class are also called the fields. These fields have different visibilities. Visibility refers to accessibility of the members, i.e., exactly where these members will be accessible. Objects have three visibility levels: public, private and protected. Classes have five visibility types: public, private, strictly private, protected and published. We will discuss visibility in details.</p>

<p><b>Inheritance</b> &minus; When a Class is defined by inheriting existing functionalities of a parent Class, then it is said to be inherited. Here child class will inherit all or few member functions and variables of a parent class. Objects can also be inherited.</p>

<p><b>Parent Class</b> &minus; A Class that is inherited by another Class. This is also called a base class or super class.</p>

<p><b>Child Class</b> &minus; A class that inherits from another class. This is also called a subclass or derived class.</p>

<p><b>Polymorphism</b> &minus; This is an object-oriented concept where same function can be used for different purposes. For example, function name will remain same but it may take different number of arguments and can do different tasks. Pascal classes implement polymorphism. Objects do not implement polymorphism. </p>

<p><b>Overloading</b> &minus; It is a type of polymorphism in which some or all of operators have different implementations depending on the types of their arguments. Similarly functions can also be overloaded with different implementation. Pascal classes implement overloading, but the Objects do not. </p>

<p><b>Data Abstraction</b> &minus; Any representation of data in which the implementation details are hidden (abstracted).</p>

<p><b>Encapsulation</b> &minus; Refers to a concept where we encapsulate all the data and member functions together to form an object.</p>

<p><b>Constructor</b> &minus; Refers to a special type of function which will be called automatically whenever there is an object formation from a class or an Object.</p>

<p><b>Destructor</b> &minus; Refers to a special type of function which will be called automatically whenever an Object or Class is deleted or goes out of scope.</p>

<h2>Defining Pascal Objects</h2>

<p>An object is declared using the type declaration. The general form of an object declaration is as follows &minus;</p>

<p>Let us define a Rectangle Object that has two integer type data members - <b>length</b> and <b>width</b> and some member functions to manipulate these data members and a procedure to draw the rectangle.</p>

<p>After creating your objects, you will be able to call member functions related to that object. One member function will be able to process member variable of related object only.</p>

<p>Following example shows how to set lengths and widths for two rectangle objects and draw them by calling the member functions.</p>

<p>Following is a complete example to show how to use objects in Pascal &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<h2>Visibility of the Object Members</h2>

<p>Visibility indicates the accessibility of the object members. Pascal object members have three types of visibility &minus;</p>

<p>By default, fields and methods of an object are public and are exported outside the current unit.</p>

<h2>Constructors and Destructors for Pascal Objects:</h2>

<p><b>Constructors</b> are special type of methods, which are called automatically whenever an object is created. You create a constructor in Pascal just by declaring a method with a keyword constructor. Conventionally, the method name is Init, however, you can provide any valid identifier of your own. You can pass as many arguments as you like into the constructor function.</p>

<p><b>Destructors</b> are methods that are called during the destruction of the object. The destructor methods destroy any memory allocation created by constructors.</p>

<p>Following example will provide a constructor and a destructor for the Rectangle class which will initialize length and width for the rectangle at the time of object creation and destroy it when it goes out of scope.</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<h2>Inheritance for Pascal Objects</h2>

<p>Pascal objects can optionally inherit from a parent object. The following program illustrates inheritance in Pascal Objects. Let us create another object named <b>TableTop</b>, which is inheriting from the Rectangle object.</p>

<p>Following are the important points which should be noted down &minus;</p>

<p>The object <i>Tabletop</i> has inherited all the members of the Rectangle object. </p>

<p>There is a draw method in <i>TableTop</i> also. When the <i>draw</i> method is called using a <i>TableTop</i> object, TableTop's draw gets invoked.</p>

<p>There is an implicit instance named <b>self</b> that refers to the current instance of the object.</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
type object-identifier = object  
   private
   field1 : field-type;  
   field2 : field-type;  
   ...
   public
   procedure proc1;  
   function f1(): function-type;
   end;  
var objectvar : object-identifier;
</pre>
<p>Let us define a Rectangle Object that has two integer type data members - <b>length</b> and <b>width</b> and some member functions to manipulate these data members and a procedure to draw the rectangle.</p>
<pre class="prettyprint notranslate">
type 
   Rectangle = object  
   private  
      length, width: integer; 
   
   public  
      constructor init;  
      destructor done;  
      
      procedure setlength(l: inteter);  
      function getlength(): integer;  
      
      procedure setwidth(w: integer);  
      function getwidth(): integer;  
      
      procedure draw;
end;
var
   r1: Rectangle;
   pr1: ^Rectangle;
</pre>
<p>After creating your objects, you will be able to call member functions related to that object. One member function will be able to process member variable of related object only.</p>
<p>Following example shows how to set lengths and widths for two rectangle objects and draw them by calling the member functions.</p>
<pre class="prettyprint notranslate">
r1.setlength(3);
r1.setwidth(7);

writeln(' Draw a rectangle: ', r1.getlength(), ' by ' , r1.getwidth());
r1.draw;
new(pr1);
pr1^.setlength(5);
pr1^.setwidth(4);

writeln(' Draw a rectangle: ', pr1^.getlength(), ' by ' ,pr1^.getwidth());
pr1^.draw;
dispose(pr1);
</pre>
<p>Following is a complete example to show how to use objects in Pascal &minus;</p>
<pre class="prettyprint notranslate tryit">
program exObjects;
type 
   Rectangle = object  
   private  
      length, width: integer; 
   
   public  
      procedure setlength(l: integer);
      function getlength(): integer;  
      
      procedure setwidth(w: integer);  
      function getwidth(): integer;  
      
      procedure draw;
end;
var
   r1: Rectangle;
   pr1: ^Rectangle;

procedure Rectangle.setlength(l: integer);
begin
   length := l;
end;

procedure Rectangle.setwidth(w: integer);
begin
   width :=w;
end;

function Rectangle.getlength(): integer;  
begin
   getlength := length;
end;

function Rectangle.getwidth(): integer;  
begin
   getwidth := width;
end;

procedure Rectangle.draw;
var 
   i, j: integer;
begin
   for i:= 1 to length do
   begin
     for j:= 1 to width do
        write(' * ');
     writeln;
   end;
end;

begin
   r1.setlength(3);
   r1.setwidth(7);
   
   writeln('Draw a rectangle:', r1.getlength(), ' by ' , r1.getwidth());
   r1.draw;
   new(pr1);
   pr1^.setlength(5);
   pr1^.setwidth(4);
   
   writeln('Draw a rectangle:', pr1^.getlength(), ' by ' ,pr1^.getwidth());
   pr1^.draw;
   dispose(pr1);
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Draw a rectangle: 3 by 7
* * * * * * *
* * * * * * *
* * * * * * *
Draw a rectangle: 5 by 4
* * * *
* * * *
* * * *
* * * *
* * * *
</pre>
<h2>Visibility of the Object Members</h2>
<p>Visibility indicates the accessibility of the object members. Pascal object members have three types of visibility &minus;</p>
<table class="table table-bordered">
<tr>
<th>Visibility</th>
<th>Accessibility</th>
</tr>
<tr>
<td>Public</td>
<td>The members can be used by other units outside the program unit</td>
</tr>
<tr>
<td>Private</td>
<td>The members are only accessible in the current unit.</td>
</tr>
<tr>
<td>Protected</td>
<td>The members are available only to objects descended from the parent object.</td>
</tr>
</table>
<p>By default, fields and methods of an object are public and are exported outside the current unit.</p>
<h2>Constructors and Destructors for Pascal Objects:</h2>
<p><b>Constructors</b> are special type of methods, which are called automatically whenever an object is created. You create a constructor in Pascal just by declaring a method with a keyword constructor. Conventionally, the method name is Init, however, you can provide any valid identifier of your own. You can pass as many arguments as you like into the constructor function.</p>
<p><b>Destructors</b> are methods that are called during the destruction of the object. The destructor methods destroy any memory allocation created by constructors.</p>
<p>Following example will provide a constructor and a destructor for the Rectangle class which will initialize length and width for the rectangle at the time of object creation and destroy it when it goes out of scope.</p>
<pre class="prettyprint notranslate tryit">
program exObjects;
type 
   Rectangle = object  
   private  
      length, width: integer; 
   public  
      constructor init(l, w: integer);
      destructor done;
      
      procedure setlength(l: integer);
      function getlength(): integer;  
      
      procedure setwidth(w: integer);  
      function getwidth(): integer;  
      
      procedure draw;
end;

var
   r1: Rectangle;
   pr1: ^Rectangle;

constructor Rectangle.init(l, w: integer);
begin
   length := l;
   width := w;
end;

destructor Rectangle.done;
begin
   writeln(' Desctructor Called');
end; 

procedure Rectangle.setlength(l: integer);
begin
   length := l;
end;

procedure Rectangle.setwidth(w: integer);
begin
   width :=w;
end;

function Rectangle.getlength(): integer;  
begin
   getlength := length;
end;

function Rectangle.getwidth(): integer;  
begin
   getwidth := width;
end;

procedure Rectangle.draw;
var 
   i, j: integer;
begin
   for i:= 1 to length do
   begin
      for j:= 1 to width do
         write(' * ');
      writeln;
   end;
end;

begin
   r1.init(3, 7);
   writeln('Draw a rectangle:', r1.getlength(), ' by ' , r1.getwidth());
   r1.draw;
   new(pr1, init(5, 4));
   
   writeln('Draw a rectangle:', pr1^.getlength(), ' by ',pr1^.getwidth());
   pr1^.draw;
   pr1^.init(7, 9);
   
   writeln('Draw a rectangle:', pr1^.getlength(), ' by ' ,pr1^.getwidth());
   pr1^.draw;
   dispose(pr1);
   r1.done;
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Draw a rectangle: 3 by 7
* * * * * * *
* * * * * * *
* * * * * * *
Draw a rectangle: 5 by 4
* * * *
* * * *
* * * *
* * * *
* * * *
Draw a rectangle: 7 by 9
* * * * * * * * *
* * * * * * * * *
* * * * * * * * *
* * * * * * * * *
* * * * * * * * *
* * * * * * * * *
* * * * * * * * *
Destructor Called
</pre>
<h2>Inheritance for Pascal Objects</h2>
<p>Pascal objects can optionally inherit from a parent object. The following program illustrates inheritance in Pascal Objects. Let us create another object named <b>TableTop</b>, which is inheriting from the Rectangle object.</p>
<pre class="prettyprint notranslate tryit">
program exObjects;
type 
   Rectangle = object  
   private  
      length, width: integer; 
   public  
      procedure setlength(l: integer);  
      function getlength(): integer;  
      procedure setwidth(w: integer);  
      function getwidth(): integer;  
      procedure draw;
end;

TableTop = object (Rectangle)
   private
     material: string;
   public
      function getmaterial(): string;
      procedure setmaterial( m: string);
      procedure displaydetails;
      procedure draw;
end;

var
   tt1: TableTop;

procedure Rectangle.setlength(l: integer);
begin
   length := l;
end;

procedure Rectangle.setwidth(w: integer);
begin
   width :=w;
end;

function Rectangle.getlength(): integer;  
begin
   getlength := length;
end;

function Rectangle.getwidth():integer;
begin
   getwidth := width;
end;

procedure Rectangle.draw;
var 
   i, j: integer;
begin
   for i:= 1 to length do
   begin
      for j:= 1 to width do
         write(' * ');
      writeln;
  end;
end;

function TableTop.getmaterial(): string;
begin
   getmaterial := material;
end;

procedure TableTop.setmaterial( m: string);
begin
   material := m;
end;

procedure TableTop.displaydetails;
begin
   writeln('Table Top: ', self.getlength(), ' by ' , self.getwidth());
   writeln('Material: ', self.getmaterial());
end;

procedure TableTop.draw();
var
   i, j: integer;
begin
   for i:= 1 to length do
   begin
      for j:= 1 to width do
         write(' * ');
   writeln;
   end;
   writeln('Material: ', material);
end;

begin
   tt1.setlength(3);
   tt1.setwidth(7);
   tt1.setmaterial('Wood');
   tt1.displaydetails();
   writeln;
   writeln('Calling the Draw method');
   tt1.draw();
end.
</pre>
<p>Following are the important points which should be noted down &minus;</p>
<ul class="list">
<li><p>The object <i>Tabletop</i> has inherited all the members of the Rectangle object. </p></li>
<li><p>There is a draw method in <i>TableTop</i> also. When the <i>draw</i> method is called using a <i>TableTop</i> object, TableTop's draw gets invoked.</p></li>
<li><p>There is an implicit instance named <b>self</b> that refers to the current instance of the object.</p></li>
</ul>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Table Top: 3 by 7
Material: Wood

Calling the Draw Method 
* * * * * * *
* * * * * * *
* * * * * * *
Material: Wood
</pre>

<title>Pascal Classes</title>

<h1>Pascal - Classes</h1>

<p>You have seen that Pascal Objects exhibit some characteristics of object-oriented paradigm. They implement encapsulation, data hiding and inheritance, but they also have limitations. For example, Pascal Objects do not take part in polymorphism. So classes are widely used to implement proper object-oriented behavior in a program, especially the GUI-based software.</p>

<p>A Class is defined in almost the same way as an Object, but is a pointer to an Object rather than the Object itself. Technically, this means that the Class is allocated on the Heap of a program, whereas the Object is allocated on the Stack. In other words, when you declare a variable the object type, it will take up as much space on the stack as the size of the object, but when you declare a variable of the class type, it will always take the size of a pointer on the stack. The actual class data will be on the heap.</p>

<h2>Defining Pascal Classes</h2>

<p>A class is declared in the same way as an object, using the type declaration. The general form of a class declaration is as follows &minus;</p>

<p>Its worth to note following important points &minus;</p>

<p>Class definitions should come under the type declaration part of the program only.</p>

<p>A class is defined using the <b>class</b> keyword.</p>

<p>Fields are data items that exist in each instance of the class.</p>

<p>Methods are declared within the definition of a class.</p>

<p>There is a predefined constructor called <b>Create</b> in the Root class.  Every abstract class and every concrete class is a descendant of Root, so all classes have at least one constructor.</p>

<p>There is a predefined destructor called <b>Destroy</b> in the Root class.  Every abstract class and every concrete class is a descendant of Root, so, all classes have at least one destructor.</p>

<p>Let us define a Rectangle class that has two integer type data members - length and width and some member functions to manipulate these data members and a procedure to draw the rectangle.</p>

<p>Let us write a complete program that would create an instance of a rectangle class and draw the rectangle. This is the same example we used while discussing Pascal Objects. You will find both programs are almost same, with the following exceptions &minus;</p>

<p>You will need to include the {$mode objfpc} directive for using the classes.</p>

<p>You will need to include the {$m+} directive for using constructors.</p>

<p>Class instantiation is different than object instantiation. Only declaring the variable does not create space for the instance, you will use the constructor create to allocate memory.</p>

<p>Here is the complete example &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<h2>Visibility of the Class Members</h2>

<p>Visibility indicates the accessibility of the class members. Pascal class members have five types of visibility &minus;</p>

<h2>Constructors and Destructors for Pascal Classes</h2>

<p>Constructors are special methods, which are called automatically whenever an object is created. So we take full advantage of this behavior by initializing many things through constructor functions.</p>

<p>Pascal provides a special function called create() to define a constructor. You can pass as many arguments as you like into the constructor function.</p>

<p>Following example will create one constructor for a class named Books and it will initialize price and title for the book at the time of object creation.</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<p>Like the implicit constructor named create, there is also an implicit destructor method destroy using which you can release all the resources used in the class.</p>

<h2>Inheritance</h2>

<p>Pascal class definitions can optionally inherit from a parent class definition. The syntax is as follows &minus;</p>

<p>Following example provides a novels class, which inherits the Books class and adds more functionality based on the requirement.</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<p>Its worth to note following important points &minus;</p>

<p>The members of the Books class have <b>protected</b> visibility. </p>

<p>The Novels class has two constructors, so the <b>overload</b> operator is used for function overloading.</p>

<p>The Books.Display procedure has been declared <b>virtual</b>, so that the same method from the Novels class can <b>override</b> it. </p>

<p>The Novels.Create constructor calls the base class constructor using the <b>inherited</b> keyword. </p>

<h2>Interfaces</h2>

<p>Interfaces are defined to provide a common function name to the implementers. Different implementers can implement those interfaces according to their requirements. You can say, interfaces are skeletons, which are implemented by developers. Following is an example of interface &minus;</p>

<p>Please note that, when a class implements an interface, it should implement all methods of the interface. If a method of an interface is not implemented, then the compiler will give an error.</p>

<h2>Abstract Classes</h2>

<p>An abstract class is one that cannot be instantiated, only inherited. An abstract class is specified by including the word symbol abstract in the class definition, like this &minus;</p>

<p>When inheriting from an abstract class, all methods marked abstract in the parent's class declaration must be defined by the child; additionally, these methods must be defined with the same visibility.</p>

<h2>Static Keyword</h2>

<p>Declaring class members or methods as static makes them accessible without needing an instantiation of the class. A member declared as static cannot be accessed with an instantiated class object (though a static method can). The following example illustrates the concept &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<p>You must use the directive {$static on} for using the static members.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
type class-identifier = class  
   private
      field1 : field-type;  
      field2 : field-type;  
        ...
   
   public
      constructor create();
      procedure proc1;  
      function f1(): function-type;
end;  
var classvar : class-identifier;
</pre>
<p>Its worth to note following important points &minus;</p>
<ul class="list">
<li><p>Class definitions should come under the type declaration part of the program only.</p></li>
<li><p>A class is defined using the <b>class</b> keyword.</p></li>
<li><p>Fields are data items that exist in each instance of the class.</p></li>
<li><p>Methods are declared within the definition of a class.</p></li>
<li><p>There is a predefined constructor called <b>Create</b> in the Root class.  Every abstract class and every concrete class is a descendant of Root, so all classes have at least one constructor.</p></li>
<li><p>There is a predefined destructor called <b>Destroy</b> in the Root class.  Every abstract class and every concrete class is a descendant of Root, so, all classes have at least one destructor.</p></li>
</ul>
<p>Let us define a Rectangle class that has two integer type data members - length and width and some member functions to manipulate these data members and a procedure to draw the rectangle.</p>
<pre class="prettyprint notranslate">
type
   Rectangle = class
   private
      length, width: integer;
   
   public
      constructor create(l, w: integer);
      procedure setlength(l: integer);
      function getlength(): integer;
      procedure setwidth(w: integer);
      function getwidth(): integer;
      procedure draw;
end;
</pre>
<p>Let us write a complete program that would create an instance of a rectangle class and draw the rectangle. This is the same example we used while discussing Pascal Objects. You will find both programs are almost same, with the following exceptions &minus;</p>
<ul class="list">
<li><p>You will need to include the {$mode objfpc} directive for using the classes.</p></li>
<li><p>You will need to include the {$m+} directive for using constructors.</p></li>
<li><p>Class instantiation is different than object instantiation. Only declaring the variable does not create space for the instance, you will use the constructor create to allocate memory.</p></li>
</ul>
<p>Here is the complete example &minus;</p>
<pre class="prettyprint notranslate tryit">
{$mode objfpc} // directive to be used for defining classes
{$m+}		   // directive to be used for using constructor

program exClass;
type
   Rectangle = class
   private
      length, width: integer;
   
   public
      constructor create(l, w: integer);
      procedure setlength(l: integer);
      
      function getlength(): integer;
      procedure setwidth(w: integer);
      
      function getwidth(): integer;
      procedure draw;
end;
var
   r1: Rectangle;

constructor Rectangle.create(l, w: integer);
begin
   length := l;
   width := w;
end;

procedure Rectangle.setlength(l: integer);
begin
   length := l;
end;

procedure Rectangle.setwidth(w: integer);
begin
   width :=w;
end;

function Rectangle.getlength(): integer;
begin
   getlength := length;
end;

function Rectangle.getwidth(): integer;
begin
   getwidth := width;
end;

procedure Rectangle.draw;
var
   i, j: integer;
begin
   for i:= 1 to length do
   begin
      for j:= 1 to width do
         write(' * ');
      writeln;
   end;
end;

begin
   r1:= Rectangle.create(3, 7);
   
   writeln(' Draw Rectangle: ', r1.getlength(), ' by ' , r1.getwidth());
   r1.draw;
   r1.setlength(4);
   r1.setwidth(6);
   
   writeln(' Draw Rectangle: ', r1.getlength(), ' by ' , r1.getwidth());
   r1.draw;
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Draw Rectangle: 3 by 7
* * * * * * *
* * * * * * *
* * * * * * *
Draw Rectangle: 4 by 6
* * * * * * 
* * * * * * 
* * * * * * 
* * * * * * 
</pre>
<h2>Visibility of the Class Members</h2>
<p>Visibility indicates the accessibility of the class members. Pascal class members have five types of visibility &minus;</p>
<table class="table table-bordered">
<tr>
<th style="width:25%;">Visibility</th>
<th>Accessibility</th>
</tr>
<tr>
<td>Public</td>
<td>These members are always accessible.</td>
</tr>
<tr>
<td>Private</td>
<td>These members can only be accessed in the module or unit that contains the class definition. They can be accessed from inside the class methods or from outside them.</td>
</tr>
<tr>
<td>Strict Private</td>
<td>These members can only be accessed from methods of the class itself. Other classes or descendent classes in the same unit cannot access them.</td>
</tr>
<tr>
<td>Protected</td>
<td>This is same as private, except, these members are accessible to descendent types, even if they are implemented in other modules.</td>
</tr>
<tr>
<td>Published</td>
<td>This is same as a Public, but the compiler generates type information that is needed for automatic streaming of these classes if the compiler is in the {$M+} state. Fields defined in a published section must be of class type.</td>
</tr>
</table>
<h2>Constructors and Destructors for Pascal Classes</h2>
<p>Constructors are special methods, which are called automatically whenever an object is created. So we take full advantage of this behavior by initializing many things through constructor functions.</p>
<p>Pascal provides a special function called create() to define a constructor. You can pass as many arguments as you like into the constructor function.</p>
<p>Following example will create one constructor for a class named Books and it will initialize price and title for the book at the time of object creation.</p>
<pre class="prettyprint notranslate tryit">
program classExample;

{$MODE OBJFPC} //directive to be used for creating classes
{$M+} //directive that allows class constructors and destructors
type
   Books = Class 
   private 
      title : String; 
      price: real;
   
   public
      constructor Create(t : String; p: real); //default constructor
      
      procedure setTitle(t : String); //sets title for a book
      function getTitle() : String; //retrieves title
      
      procedure setPrice(p : real); //sets price for a book
      function getPrice() : real; //retrieves price
      
      procedure Display(); // display details of a book
end;
var
   physics, chemistry, maths: Books;

//default constructor 
constructor Books.Create(t : String; p: real);
begin
   title := t;
   price := p;
end;

procedure Books.setTitle(t : String); //sets title for a book
begin
   title := t;
end;

function Books.getTitle() : String; //retrieves title
begin
   getTitle := title;
end;

procedure Books.setPrice(p : real); //sets price for a book
begin
   price := p;
end;

function Books.getPrice() : real; //retrieves price
begin
   getPrice:= price;
end;

procedure Books.Display();
begin
   writeln('Title: ', title);
   writeln('Price: ', price:5:2);
end;

begin 
   physics := Books.Create('Physics for High School', 10);
   chemistry := Books.Create('Advanced Chemistry', 15);
   maths := Books.Create('Algebra', 7);
   
   physics.Display;
   chemistry.Display;
   maths.Display;
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Title: Physics for High School
Price: 10
Title: Advanced Chemistry
Price: 15
Title: Algebra
Price: 7
</pre>
<p>Like the implicit constructor named create, there is also an implicit destructor method destroy using which you can release all the resources used in the class.</p>
<h2>Inheritance</h2>
<p>Pascal class definitions can optionally inherit from a parent class definition. The syntax is as follows &minus;</p>
<pre class="prettyprint notranslate">
type
childClas-identifier = class(baseClass-identifier) 
&lt; members &gt;
end; 
</pre>
<p>Following example provides a novels class, which inherits the Books class and adds more functionality based on the requirement.</p>
<pre class="prettyprint notranslate tryit">
program inheritanceExample;

{$MODE OBJFPC} //directive to be used for creating classes
{$M+} //directive that allows class constructors and destructors

type
   Books = Class 
   protected 
      title : String; 
      price: real;
   
   public
      constructor Create(t : String; p: real); //default constructor
      
      procedure setTitle(t : String); //sets title for a book
      function getTitle() : String; //retrieves title
      
      procedure setPrice(p : real); //sets price for a book
      function getPrice() : real; //retrieves price
      
      procedure Display(); virtual; // display details of a book
end;
(* Creating a derived class *)

type
   Novels = Class(Books)
   private
      author: String;
   
   public
      constructor Create(t: String); overload;
      constructor Create(a: String; t: String; p: real); overload;
      
      procedure setAuthor(a: String); // sets author for a book
      function getAuthor(): String; // retrieves author name
      
      procedure Display(); override;
end;
var
   n1, n2: Novels;

//default constructor 
constructor Books.Create(t : String; p: real);
begin
   title := t;
   price := p;
end;

procedure Books.setTitle(t : String); //sets title for a book
begin
   title := t;
end;

function Books.getTitle() : String; //retrieves title
begin
   getTitle := title;
end;

procedure Books.setPrice(p : real); //sets price for a book
begin
   price := p;
end;

function Books.getPrice() : real; //retrieves price
begin
   getPrice:= price;
end;

procedure Books.Display();
begin
   writeln('Title: ', title);
   writeln('Price: ', price);
end;

(* Now the derived class methods  *)
constructor Novels.Create(t: String);
begin
   inherited Create(t, 0.0);
   author:= ' ';
end;

constructor Novels.Create(a: String; t: String; p: real);
begin
   inherited Create(t, p);
   author:= a;
end;

procedure Novels.setAuthor(a : String); //sets author for a book
begin
   author := a;
end;

function Novels.getAuthor() : String; //retrieves author
begin
   getAuthor := author;
end;

procedure Novels.Display();
begin
   writeln('Title: ', title);
   writeln('Price: ', price:5:2);
   writeln('Author: ', author);
end;

begin 
   n1 := Novels.Create('Gone with the Wind');
   n2 := Novels.Create('Ayn Rand','Atlas Shrugged', 467.75);
   n1.setAuthor('Margaret Mitchell');
   n1.setPrice(375.99);
   n1.Display;
   n2.Display;
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Title: Gone with the Wind
Price: 375.99
Author: Margaret Mitchell
Title: Atlas Shrugged
Price: 467.75
Author: Ayn Rand
</pre>
<p>Its worth to note following important points &minus;</p>
<ul class="list">
<li><p>The members of the Books class have <b>protected</b> visibility. </p></li>
<li><p>The Novels class has two constructors, so the <b>overload</b> operator is used for function overloading.</p></li>
<li><p>The Books.Display procedure has been declared <b>virtual</b>, so that the same method from the Novels class can <b>override</b> it. </p></li>
<li><p>The Novels.Create constructor calls the base class constructor using the <b>inherited</b> keyword. </p></li>
</ul>
<h2>Interfaces</h2>
<p>Interfaces are defined to provide a common function name to the implementers. Different implementers can implement those interfaces according to their requirements. You can say, interfaces are skeletons, which are implemented by developers. Following is an example of interface &minus;</p>
<pre class="prettyprint notranslate">
type  
   Mail = Interface  
      Procedure SendMail;  
      Procedure GetMail;  
   end;  
   
   Report = Class(TInterfacedObject,  Mail)  
      Procedure SendMail;  
      Procedure GetMail;  
   end;  
</pre>
<p>Please note that, when a class implements an interface, it should implement all methods of the interface. If a method of an interface is not implemented, then the compiler will give an error.</p>
<h2>Abstract Classes</h2>
<p>An abstract class is one that cannot be instantiated, only inherited. An abstract class is specified by including the word symbol abstract in the class definition, like this &minus;</p>
<pre class="prettyprint notranslate">
type
   Shape = ABSTRACT CLASS (Root)
      Procedure draw; ABSTRACT;
      ...
   end;
</pre>
<p>When inheriting from an abstract class, all methods marked abstract in the parent's class declaration must be defined by the child; additionally, these methods must be defined with the same visibility.</p>
<h2>Static Keyword</h2>
<p>Declaring class members or methods as static makes them accessible without needing an instantiation of the class. A member declared as static cannot be accessed with an instantiated class object (though a static method can). The following example illustrates the concept &minus;</p>
<pre class="prettyprint notranslate tryit">
program StaticExample;
{$mode objfpc}
{$static on}
type
   myclass=class
      num : integer;static;
   end;
var
   n1, n2 : myclass;
begin
   n1:= myclass.create;
   n2:= myclass.create;
   n1.num := 12;
   writeln(n2.num);
   n2.num := 31;
   writeln(n1.num);
   writeln(myclass.num);
   myclass.num := myclass.num + 20;
   writeln(n1.num);
   writeln(n2.num);
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
12
31
31
51
51
</pre>

<title>Pascal Quick Guide</title>

<h1>Pascal - Quick Guide</h1>

<h1>Pascal - Overview</h1>

<p>Pascal is a general-purpose, high-level language that was originally developed by Niklaus Wirth in the early 1970s. It was developed for teaching programming as a systematic discipline and to develop reliable and efficient programs. </p>

<p>Pascal is Algol-based language and includes many constructs of Algol. Algol 60 is a subset of Pascal. Pascal offers several data types and programming structures. It is easy to understand and maintain the Pascal programs.</p>

<p>Pascal has grown in popularity in the teaching and academics arena for various reasons:</p>

<p>Easy to learn.</p>

<p>Structured language.</p>

<p>It produces transparent, efficient and reliable programs.</p>

<p>It can be compiled on a variety of computer platforms.</p>

<h2>Features of the Pascal Language</h2>

<p>Pascal has the following features &minus;</p>

<p>Pascal is a strongly typed language.</p>

<p>It offers extensive error checking.</p>

<p>It offers several data types like arrays, records, files and sets.</p>

<p>It offers a variety of programming structures.</p>

<p>It supports structured programming through functions and procedures.</p>

<p>It supports object oriented programming.</p>

<h2>Facts about Pascal</h2>

<p>The Pascal language was named for Blaise Pascal, French mathematician and pioneer in computer development.</p>

<p>Niklaus Wirth completed development of the original Pascal programming language in 1970.</p>

<p>Pascal is based on the block structured style of the Algol programming language.</p>

<p>Pascal was developed as a language suitable for teaching programming as a systematic discipline, whose implementations could be both reliable and efficient.</p>

<p>The ISO 7185 Pascal Standard was originally published in 1983.</p>

<p>Pascal was the primary high-level language used for development in the Apple Lisa, and in the early years of the Mac.</p>

<p>In 1986, Apple Computer released the first Object Pascal implementation, and in 1993, the Pascal Standards Committee published an Object-Oriented Extension to Pascal.</p>

<h2>Why to use Pascal?</h2>

<p>Pascal allows the programmers to define complex structured data types and build dynamic and recursive data structures, such as lists, trees and graphs. Pascal offers features like records, enumerations, subranges, dynamically allocated variables with associated pointers and sets. </p>

<p>Pascal allows nested procedure definitions to any level of depth. This truly provides a great programming environment for learning  programming as a systematic discipline based on the fundamental concepts.</p>

<p>Among the most amazing implementations of Pascal are &minus;</p>

<p>Skype</p>

<p>Total Commander</p>

<p>TeX</p>

<p>Macromedia Captivate</p>

<p>Apple Lisa</p>

<p>Various PC Games</p>

<p>Embedded Systems</p>

<h1>Pascal - Environment Set Up</h1>

<p>There are several Pascal compilers and interpreters available for general use. Among these are &minus;</p>

<p><b>Turbo Pascal</b> &minus; provides an IDE and compiler for running Pascal programs on CP/M, CP/M-86, DOS, Windows and Macintosh.</p>

<p><b>Delphi</b> &minus; provides compilers for running Object Pascal and generates native code for 32- and 64-bit Windows operating systems, as well as 32-bit Mac OS X and iOS. Embarcadero is planning to build support for the Linux and Android operating system.</p>

<p><b>Free Pascal</b> &minus; it is a free compiler for running Pascal and Object Pascal programs. Free Pascal compiler is a 32- and 64-bit Turbo Pascal and Delphi compatible Pascal compiler for Linux, Windows, OS/2, FreeBSD, Mac OS X, DOS and several other platforms.</p>

<p><b>Turbo51</b> &minus; It is a free Pascal compiler for the 8051 family of microcontrollers, with Turbo Pascal 7 syntax.</p>

<p><b>Oxygene</b> &minus; It is an Object Pascal compiler for the .NET and Mono platforms.</p>

<p><b>GNU Pascal (GPC)</b> &minus; It is a Pascal compiler composed of a front end to GNU Compiler Collection.</p>

<p>We will be using Free Pascal in these tutorials. You can download Free Pascal for your operating system from the link: <a rel="nofollow" target="_blank" href="http://www.freepascal.org/download.var">Download Free Pascal</a></p>

<h2>Installing Free Pascal on Linux</h2>

<p>The Linux distribution of Free Pascal comes in three forms &minus;</p>

<p>a <b>tar.gz</b> version, also available as separate files.</p>

<p>a <b>.rpm</b> (Red Hat Package Manager) version.</p>

<p>a <b>.deb</b> (Debian) version.</p>

<p>Installation code for the .rpm version:: </p>

<p>Where X.Y.Z is the version number of the .rpm file, and ARCH is one of the supported architectures (i386, x86_64, etc.).</p>

<p>Installation code for the Debian version (like Ubuntu): </p>

<p>Where XXX is the  version number of the .deb file.</p>

<p>For details read: <a rel="nofollow" target="_blank" href="http://www.freepascal.org/docs-html/user/usersu5.html">Free Pascal Installation Guide</a></p>

<h2>Installing Free Pascal on Mac</h2>

<p>If you use Mac OS X, the easiest way to use Free Pascal is to download the Xcode development environment from Apple's web site and follow the simple installation instructions. Once you have Xcode setup, you will be able to use the Free Pascal compiler.</p>

<h2>Installing Free Pascal on Windows </h2>

<p>For Windows, you will download the Windows installer, setup.exe. This is a usual installation program. You need to take the following steps for installation &minus;</p>

<p>Select a directory.</p>

<p>Select parts of the package you want to install.</p>

<p>Optionally choose to associate the .pp or .pas extensions with the Free Pascal IDE.</p>

<p>For details read: <a rel="nofollow" target="_blank" href="http://www.freepascal.org/docs-html/user/usersu3.html">Free Pascal Installation Guide</a></p>

<h2>Text Editor</h2>

<p>This will be used to type your program. Examples of few editors include Windows Notepad, OS Edit command, Brief, Epsilon, EMACS, and vim or vi.</p>

<p>Name and version of text editor can vary on different operating systems. For example, Notepad will be used on Windows and vim or vi can be used on windows as well as Linux or UNIX.</p>

<p>The files you create with your editor are called source files and contain program source code. The source files for Pascal programs are typically named with the extension <b>.pas</b>.</p>

<p>Before starting your programming, make sure you have one text editor in place and you have enough experience to write a computer program, save it in a file, compile it and finally execute it.</p>

<h1>Pascal - Program Structures</h1>

<p>Before we study basic building blocks of the Pascal programming language, let us look a bare minimum Pascal program structure so that we can take it as a reference in upcoming chapters.</p>

<h2>Pascal Program Structure</h2>

<p>A Pascal program basically consists of the following parts &minus;</p>

<p>Every pascal program generally has a heading statement, a declaration and an execution part strictly in that order. Following format shows the basic syntax for a Pascal program &minus;</p>

<h2>Pascal Hello World Example</h2>

<p>Following is a simple pascal code that would print the words "Hello, World!":</p>

<p>This will produce following result &minus;</p>

<p>Let us look various parts of the above program &minus;</p>

<p>The first line of the program <b>program HelloWorld;</b> indicates the name of the program.</p>

<p>The second line of the program <b>uses crt;</b> is a preprocessor command, which tells the compiler to include the crt unit before going to actual compilation.</p>

<p>The next lines enclosed within begin and end statements are the main program block. Every block in Pascal is enclosed within a <b>begin</b> statement and an <b>end</b> statement. However, the end statement indicating the end of the main program is followed by a full stop (.) instead of semicolon (;). </p>

<p>The <b>begin</b> statement of the main program block is where the program execution begins.</p>

<p>The lines within  <b>(*...*)</b> will be ignored by the compiler and it has been put to add a <b>comment</b> in the program. </p>

<p>The statement <b>writeln('Hello, World!');</b> uses the writeln function available in Pascal which causes the message "Hello, World!" to be displayed on the screen.</p>

<p>The statement <b>readkey;</b> allows the display to pause until the user presses a key. It is part of the crt unit. A unit is like a library in Pascal.</p>

<p>The last statement <b>end.</b> ends your program.</p>

<h2>Compile and Execute Pascal Program</h2>

<p>Open a text editor and add the above-mentioned code.</p>

<p>Save the file as <i>hello.pas</i></p>

<p>Open a command prompt and go to the directory, where you saved the file.</p>

<p>Type fpc hello.pas at command prompt and press enter to compile your code.</p>

<p>If there are no errors in your code, the command prompt will take you to the next line and would generate <b>hello</b> executable file and <b>hello.o</b> object file.</p>

<p>Now, type <b>hello</b> at command prompt to execute your program.</p>

<p>You will be able to see "Hello World" printed on the screen and program waits till you press any key.</p>

<p>Make sure that free pascal compiler <b>fpc</b> is in your path and that you are running it in the directory containing source file hello.pas.</p>

<h1>Pascal - Basic Syntax</h1>

<p>You have seen a basic structure of pascal program, so it will be easy to understand other basic building blocks of the pascal programming language.</p>

<h2>Variables</h2>

<p>A variable definition is put in a block beginning with a <b>var</b> keyword, followed by definitions of the variables as follows:</p>

<p>Pascal variables are declared outside the code-body of the function which means they are not declared within the <b>begin</b> and <b>end</b> pairs, but they are declared after the definition of the procedure/function and before the <b>begin</b> keyword. For global variables, they are defined after the program header.</p>

<h2>Functions/Procedures</h2>

<p>In Pascal, a <b>procedure</b> is set of instructions to be executed, with no return value and a <b>function</b> is a procedure with a return value. The definition of function/procedures will be as follows &minus;</p>

<h2>Comments</h2>

<p>The multiline comments are enclosed within curly brackets and asterisks as {* ... *}. Pascal allows single-line comment enclosed within curly brackets { ... }. </p>

<h2>Case Sensitivity</h2>

<p>Pascal is a case non-sensitive language, which means you can write your variables, functions and procedure in either case. Like variables A_Variable, a_variable and A_VARIABLE have same meaning in Pascal.</p>

<h2>Pascal Statements </h2>

<p>Pascal programs are made of statements. Each statement specifies a definite job of the program. These jobs could be declaration, assignment, reading data, writing data, taking logical decisions, transferring program flow control, etc.</p>

<p>For example &minus;</p>

<h2> Reserved Words in Pascal</h2>

<p>The statements in Pascal are designed with some specific Pascal words, which are called the reserved words. For example, the words, program, input, output, var, real, begin, readline, writeline and end are all reserved words.</p>

<p>Following is a list of reserved words available in Pascal.</p>

<h2>Character set and Identifiers in Pascal</h2>

<p>The Pascal character set consists of &minus;</p>

<p>All upper case letters (A-Z)</p>

<p>All lower case letters (a-z)</p>

<p>All digits (0-9)</p>

<p>Special symbols   - + * / := , . ;. () [] = {} ` white space</p>

<p>The entities in a Pascal program like variables and constants, types, functions, procedures and records, etc., have a name or identifier.  An identifier is a sequence of letters and digits, beginning with a letter. Special symbols and blanks must not be used in an identifier.</p>

<h1>Pascal - Data Types</h1>

<p>Data types of an entity indicates the meaning, constraints, possible values, operations, functions and mode of storage associated with it.</p>

<p>Integer, real, Boolean and character types are referred as standard data types. Data types can be categorized as scalar, pointer and structured data types. Examples of scalar data types are integer, real, Boolean, character, subrange and enumerated. Structured data types are made of the scalar types; for example, arrays, records, files and sets. We will discuss the pointer data types later.</p>

<h2>Pascal Data Types</h2>

<p>Pascal data types can be summarized as below in the following diagram &minus;</p>

<h2>Type Declarations</h2>

<p>The type declaration is used to declare the data type of an identifier. Syntax of type declaration is &minus;</p>

<p>For example, the following declaration defines the variables days and age as integer type, yes and true as Boolean type, name and city as string type, fees and expenses as real type.</p>

<h2>Integer Types</h2>

<p>Following table gives you details about standard integer types with its storage sizes and value ranges used in Object Pascal &minus;</p>

<h2>Constants</h2>

<p>Use of constants makes a program more readable and helps to keep special quantities at one place in the beginning of the program. Pascal allows <i>numerical, logical, string</i> and <i>character</i> constants. Constants can be declared in the declaration part of the program by specifying the <b>const</b> declaration.</p>

<p>Syntax of constant type declaration is follows &minus;</p>

<p>Following are some examples of constant declarations &minus;</p>

<p>All constant declarations must be given before the variable declaration.</p>

<h2>Enumerated types</h2>

<p>Enumerated data types are user-defined data types. They allow values to be specified in a list. Only <i>assignment</i> operators and <i>relational</i> operators are permitted on enumerated data type. Enumerated data types can be declared as follows &minus;</p>

<p>Following are some examples of enumerated  type declarations &minus;</p>

<p>The order in which the items are listed in the domain of an enumerated type defines the order of the items. For example, in the enumerated type SUMMER, April comes before May, May comes before June, and so on. The domain of enumerated type identifiers cannot consist of numeric or character constants.</p>

<h2>Subrange Types</h2>

<p>Subrange types allow a variable to assume values that lie within a certain range. For example, if the <i>age</i> of voters should lie between 18 to 100 years, a variable named age could be declared as &minus;</p>

<p>We will look at variable declaration in detail in the next section. You can also define a subrange type using the type declaration. Syntax for declaring a subrange type is as follows &minus;</p>

<p>Following are some examples of subrange type declarations &minus;</p>

<p>Subrange types can be created from a subset of an already defined enumerated type, For example &minus;</p>

<h1>Pascal - Variable Types</h1>

<p>A variable is nothing but a name given to a storage area that our programs can manipulate. Each variable in Pascal has a specific type, which determines the size and layout of the variable's memory; the range of values that can be stored within that memory; and the set of operations that can be applied to the variable.</p>

<p>The name of a variable can be composed of letters, digits, and the underscore character. It must begin with either a letter or an underscore. Pascal is <b>not case-sensitive</b>, so uppercase and lowercase letters mean same here. Based on the basic types explained in previous chapter, there will be following basic variable types &minus;</p>

<h2>Basic Variables in Pascal</h2>

<p>Pascal programming language also allows defining various other types of variables, which we will cover in subsequent chapters like Pointer, Array, Records, Sets, and Files, etc. For this chapter, let us study only basic variable types.</p>

<h2>Variable Declaration in Pascal</h2>

<p>All variables must be declared before we use them in Pascal program. All variable declarations are followed by the <i>var</i> keyword. A declaration specifies a list of variables, followed by a colon (:) and the type. Syntax of variable declaration is &minus;</p>

<p>Here, type must be a valid Pascal data type including character, integer, real, boolean, or any user-defined data type, etc., and variable_list may consist of one or more identifier names separated by commas. Some valid variable declarations are shown here &minus;</p>

<p>In the previous tutorial, we have discussed that Pascal allows declaring a type. A type can be identified by a name or identifier. This type can be used to define variables of that type. For example,</p>

<p>Now, the types so defined can be used in variable declarations &minus;</p>

<p>Please note the difference between <i>type</i> declaration and <i>var</i> declaration. Type declaration indicates the category or class of the types such as integer, real, etc., whereas the variable specification indicates the type of values a variable may take. You can compare <i>type</i> declaration in Pascal with <i>typedef</i> in C. Most importantly, the variable name refers to the memory location where the value of the variable is going to be stored. This is not so with the type declaration.</p>

<h2>Variable Initialization in Pascal</h2>

<p>Variables are assigned a value with a colon and the equal sign, followed by a constant expression. The general form of assigning a value is &minus;</p>

<p>By default, variables in Pascal are not initialized with zero. They may contain rubbish values. So it is a better practice to initialize variables in a program. Variables can be initialized (assigned an initial value) in their declaration. The initialization is followed by the <b>var</b> keyword and the syntax of initialization is as follows &minus;</p>

<p>Some examples are &minus;</p>

<p>Let us look at an example, which makes use of various types of variables discussed so far &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<h2>Enumerated Variables</h2>

<p>You have seen how to use simple variable types like integer, real and boolean. Now, let's see variables of enumerated type, which can be defined as &minus;</p>

<p>When you have declared an enumerated type, you can declare variables of that type. For example,</p>

<p>The following example illustrates the concept &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<h2>Subrange Variables</h2>

<p>Subrange variables are declared as &minus;</p>

<p>Examples of subrange variables are &minus;</p>

<p>The following program illustrates the concept &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<h1>Pascal - Constants</h1>

<p>A constant is an entity that remains unchanged during program execution. Pascal allows only constants of the following types to be declared &minus;</p>

<h2>Declaring Constants</h2>

<p>Syntax for declaring constants is as follows &minus;</p>

<p>The following table provides examples of some valid constant declarations &minus;</p>

<p>velocity_light = 3.0E+10;</p>

<p>The following example illustrates the concept &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<p>Observe the formatting in the output statement of the program. The variable c is to be formatted with total number of digits 7 and 2 digits after the decimal sign. Pascal allows such output formatting with the numerical variables.</p>

<h1>Pascal - Operators</h1>

<p>An operator is a symbol that tells the compiler to perform specific mathematical or logical manipulations. Pascal allows the following types of operators &minus;</p>

<p>Let us discuss the arithmetic, relational, Boolean and bit operators one by one. We will discuss the set operators and string operations later.</p>

<h2>Arithmetic Operators</h2>

<p>Following table shows all the arithmetic operators supported by Pascal. Assume variable <b>A</b> holds 10 and variable <b>B</b> holds 20, then &minus;</p>

<p><a href="/pascal/pascal_arithmetic_operators.htm" title="Arithmetic Operators in Pascal">Show Examples</a></p>

<h2>Relational Operators</h2>

<p>Following table shows all the relational operators supported by Pascal. Assume variable <b>A</b> holds 10 and variable <b>B</b> holds 20, then &minus;</p>

<p><a href="/pascal/pascal_relational_operators.htm" title="Relational Operators in Pascal">Show Examples</a></p>

<h2>Boolean Operators</h2>

<p>Following table shows all the Boolean operators supported by Pascal language. All these operators work on Boolean operands and produce Boolean results. Assume variable <b>A</b> holds true and variable <b>B</b> holds false, then &minus;</p>

<p><a href="/pascal/pascal_boolean_operators.htm" title="Boolean Operators in Pascal">Show Examples</a></p>

<h2>Bit Operators</h2>

<p>Bitwise operators work on bits and perform bit-by-bit operation. All these operators work on integer operands and produces integer results. The truth table for bitwise and (&amp;), bitwise or (|), and bitwise not (~) are as follows &minus;</p>

<p>Assume if A = 60; and B = 13; now in binary format they will be as follows &minus;</p>

<p>A = 0011 1100</p>

<p>B = 0000 1101</p>

<p>-----------------</p>

<p>A&amp;B = 0000 1100</p>

<p>A^B = 0011 0001</p>

<p>~A&nbsp; = 1100 0011</p>

<p>The Bitwise operators supported by Pascal are listed in the following table. Assume variable A holds 60 and variable B holds 13, then:</p>

<p><a href="/pascal/pascal_bit_operators.htm" title="Bit Operators in Pascal">Show Examples</a></p>

<p>Please note that different implementations of Pascal differ in bitwise operators. Free Pascal, the compiler we used here, however, supports the following bitwise operators &minus;</p>

<h2>Operators Precedence in Pascal</h2>

<p>Operator precedence determines the grouping of terms in an expression. This affects how an expression is evaluated. Certain operators have higher precedence than others; for example, the multiplication operator has higher precedence than the addition operator.</p>

<p>For example x = 7 + 3 * 2; here, x is assigned 13, not 20 because operator * has higher precedence than +, so it first gets multiplied with 3*2 and then adds into 7.</p>

<p>Here, operators with the highest precedence appear at the top of the table, those with the lowest appear at the bottom. Within an expression, higher precedence operators will be evaluated first.</p>

<p><a href="/pascal/pascal_operators_precedence.htm" title="Operators Precedence in Pascal">Show Examples</a></p>

<h1>Pascal - Decision Making</h1>

<p>Decision making structures require that the programmer specify one or more conditions to be evaluated or tested by the program, along with a statement or statements to be executed if the condition is determined to be true, and optionally, other statements to be executed if the condition is determined to be false.</p>

<p>Following is the general form of a typical decision making structure found in most of the programming languages &minus;</p>

<p>Pascal programming language provides the following types of decision making statements. Click the following links to check their detail.</p>

<p><a href="/pascal/pascal_if_then_statement.htm" title="if then statement in Pascal">if - then statement</a></p>

<p><a href="/pascal/pascal_if_then_else_statement.htm" title="if then else statement in Pascal">If-then-else statement</a></p>

<p><a href="/pascal/pascal_nested_if_statement.htm" title="nested if statements in Pascal">nested if statements</a></p>

<p><a href="/pascal/pascal_case_statement.htm" title="case statement in Pascal">case statement</a></p>

<p><a href="/pascal/pascal_case_else_statement.htm" title="case else statement in Pascal">case - else statement</a></p>

<p><a href="/pascal/pascal_nested_case_statement.htm" title="nested case statements in Pascal">nested case statements</a></p>

<h1>Pascal - Loops</h1>

<p>There may be a situation, when you need to execute a block of code several number of times. In general, statements are executed sequentially: The first statement in a function is executed first, followed by the second, and so on.</p>

<p>Programming languages provide various control structures that allow for more complicated execution paths.</p>

<p>A loop statement allows us to execute a statement or group of statements multiple times and following is the general form of a loop statement in most of the programming languages &minus;</p>

<p>Pascal programming language provides the following types of loop constructs to handle looping requirements. Click the following links to check their details.</p>

<p><a href="/pascal/pascal_while_do_loop.htm" title="while-do loop in Pascal">while-do loop</a></p>

<p><a href="/pascal/pascal_for_do_loop.htm" title="for loop in Pascal">for-do  loop</a></p>

<p><a href="/pascal/pascal_repeat_until_loop.htm" title="repeat-until loop in Pascal">repeat-until loop</a></p>

<p><a href="/pascal/pascal_nested_loops.htm" title="nested loops in Pascal">nested loops</a></p>

<h2>Loop Control Statements</h2>

<p>Loop control statements change execution from its normal sequence. When execution leaves a scope, all automatic objects that were created in that scope are destroyed.</p>

<p>Pascal supports the following control statements. Click the following links to check their details. </p>

<p><a href="/pascal/pascal_break_statement.htm" title="break statement in Pascal">break statement</a></p>

<p><a href="/pascal/pascal_continue_statement.htm" title="continue statement in Pascal">continue statement</a></p>

<p><a href="/pascal/pascal_goto_statement.htm" title="goto statement in Pascal">goto statement</a></p>

<h1>Pascal - Functions</h1>

<h2>Subprograms</h2>

<p>A subprogram is a program unit/module that performs a particular task. These subprograms are combined to form larger programs. This is basically called the 'Modular design.' A subprogram can be invoked by a subprogram/program, which is called the calling program.</p>

<p>Pascal provides two kinds of subprograms &minus;</p>

<p><b>Functions</b> &minus; these subprograms return a single value. </p>

<p><b>Procedures</b> &minus; these subprograms do not return a value directly.</p>

<h2>Functions</h2>

<p>A <b>function</b> is a group of statements that together perform a task. Every Pascal program has at least one function, which is the program itself, and all the most trivial programs can define additional functions.</p>

<p>A function <b>declaration</b> tells the compiler about a function's name, return type, and parameters. A function <b>definition</b> provides the actual body of the function.</p>

<p>Pascal standard library provides numerous built-in functions that your program can call. For example, function <b>AppendStr()</b> appends two strings, function <b>New()</b> dynamically allocates memory to variables and many more functions.</p>

<h2>Defining a Function</h2>

<p>In Pascal, a <b>function</b> is defined using the function keyword. The general form of a function definition is as follows &minus;</p>

<p>A function definition in Pascal consists of a function <b>header</b>, local <b>declarations</b> and a function <b>body</b>. The function header consists of the keyword function and a <b>name</b> given to the function. Here are all the parts of a function &minus;</p>

<p><b>Arguments</b> &minus; The argument(s) establish the linkage between the calling program and the function identifiers and also called the formal parameters. A parameter is like a placeholder. When a function is invoked, you pass a value to the parameter. This value is referred to as actual parameter or argument. The parameter list refers to the type, order, and number of parameters of a function. Use of such formal parameters is optional. These parameters may have standard data type, user-defined data type or subrange data type.</p>

<p>The formal parameters list appearing in the function statement could be simple or subscripted variables, arrays or structured variables, or subprograms.</p>

<p><b>Return Type</b> &minus; All functions must return a value, so all functions must be assigned a type. The <b>function-type</b> is the data type of the value the function returns. It may be standard, user-defined scalar or subrange type but it cannot be structured type.</p>

<p><b>Local declarations</b> &minus; Local declarations refer to the declarations for labels, constants, variables, functions and procedures, which are application to the body of function only.</p>

<p><b>Function Body</b> &minus; The function body contains a collection of statements that define what the function does. It should always be enclosed between the reserved words begin and end.  It is the part of a function where all computations are done. There must be an assignment statement of the type - <b>name := expression;</b> in the function body that assigns a value to the function name. This value is returned as and when the function is executed. The last statement in the body must be an end statement.</p>

<p>Following is an example showing how to define a function in pascal &minus;</p>

<h2>Function Declarations</h2>

<p>A function <b>declaration</b> tells the compiler about a function name and how to call the function. The actual body of the function can be defined separately.</p>

<p>A function declaration has the following parts &minus;</p>

<p>For the above-defined function max(), following is the function declaration &minus;</p>

<p>Function declaration is required when you define a function in one source file and you call that function in another file. In such case, you should declare the function at the top of the file calling the function.</p>

<h2>Calling a Function</h2>

<p>While creating a function, you give a definition of what the function has to do. To use a function, you will have to call that function to perform the defined task. When a program calls a function, program control is transferred to the called function. A called function performs defined task, and when its return statement is executed or when it last end statement is reached, it returns program control back to the main program.</p>

<p>To call a function, you simply need to pass the required parameters along with function name, and if function returns a value, then you can store returned value. Following is a simple example to show the usage &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<h1>Pascal - Procedures</h1>

<p><b>Procedures </b>are subprograms that, instead of returning a single value, allow to obtain a group of results.</p>

<h2>Defining a Procedure</h2>

<p>In Pascal, a procedure is defined using the <b>procedure</b> keyword. The general form of a procedure definition is as follows &minus;</p>

<p>A procedure <b>definition</b> in Pascal consists of a <b>header</b>, local <b>declarations</b> and a <b>body</b> of the procedure. The procedure header consists of the keyword <b>procedure</b> and a name given to the procedure. Here are all the parts of a procedure &minus;</p>

<p><b>Arguments</b> &minus; The argument(s) establish the linkage between the calling program and the procedure identifiers and also called the formal parameters. Rules for arguments in procedures are same as that for the functions.</p>

<p><b>Local declarations</b> &minus; Local declarations refer to the declarations for labels, constants, variables, functions and procedures, which are applicable to the body of the procedure only.</p>

<p><b>Procedure Body</b> &minus; The procedure body contains a collection of statements that define what the procedure does. It should always be enclosed between the reserved words begin and end. It is the part of a procedure where all computations are done.</p>

<p>Following is the source code for a procedure called <i>findMin()</i>. This procedure takes 4 parameters x, y, z and m and stores the minimum among the first three variables in the variable named m. The variable m is passed by <b>reference</b> (we will discuss passing arguments by reference a little later) &minus;</p>

<h2>Procedure Declarations</h2>

<p>A procedure <b>declaration</b> tells the compiler about a procedure name and how to call the procedure. The actual body of the procedure can be defined separately.</p>

<p>A procedure declaration has the following syntax &minus;</p>

<p>Please note that the <b>name of the procedure is not associated with any type</b>. For the above defined procedure <i>findMin()</i>, following is the declaration &minus;</p>

<h2>Calling a Procedure</h2>

<p>While creating a procedure, you give a definition of what the procedure has to do. To use the procedure, you will have to call that procedure to perform the defined task. When a program calls a procedure, program control is transferred to the called procedure. A called procedure performs the defined task, and when its last end statement is reached, it returns the control back to the calling program.</p>

<p>To call a procedure, you simply need to pass the required parameters along with the procedure name as shown below &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<h2>Recursive Subprograms</h2>

<p>We have seen that a program or subprogram may call another subprogram. When a subprogram calls itself, it is referred to as a recursive call and the process is known as recursion.</p>

<p>To illustrate the concept, let us calculate the factorial of a number. Factorial of a number n is defined as &minus;</p>

<p>The following program calculates the factorial of a given number by calling itself recursively.</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<p>Following is another example, which generates the <b>Fibonacci Series</b> for a given number using a <b>recursive</b> function &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<h2>Arguments of a Subprogram</h2>

<p>If a subprogram (<b>function or procedure</b>) is to use arguments, it must declare variables that accept the values of the arguments. These variables are called the <b>formal parameters</b> of the subprogram.</p>

<p>The formal parameters behave like other local variables inside the subprogram and are created upon entry into the subprogram and destroyed upon exit.</p>

<p>While calling a subprogram, there are two ways that arguments can be passed to the subprogram &minus;</p>

<p><a href="/pascal/pascal_call_by_value.htm" title="Subprogram call by value in Pascal">Call by value</a></p>

<p><a href="/pascal/pascal_call_by_reference.htm" title="Subprogram call by reference in Pascal">Call by reference</a></p>

<p>By default, Pascal uses <b>call by value</b> to pass arguments. In general, this means that code within a subprogram cannot alter the arguments used to call the subprogram. The example program we used in the chapter 'Pascal - Functions' called the function named max() using <b>call by value</b>.</p>

<p>Whereas, the example program provided here (<i>exProcedure</i>) calls the procedure findMin() using <b>call by reference</b>.</p>

<h1>Pascal - Variable Scope</h1>

<p>A scope in any programming is a region of the program where a defined variable can have its existence and beyond that variable cannot be accessed. There are three places, where variables can be declared in Pascal programming language &minus;</p>

<p>Inside a subprogram or a block which is called local variables</p>

<p>Outside of all subprograms which is called global variables</p>

<p>In the definition of subprogram parameters which is called formal parameters</p>

<p>Let us explain what are <b>local</b> and <b>global</b> variables and formal parameters.</p>

<h2>Local Variables</h2>

<p>Variables that are declared inside a subprogram or block are called local variables. They can be used only by statements that are inside that  subprogram or block of code. Local variables are not known to subprograms outside their own. Following is the example using local variables. Here, all the variables <i>a</i>, <i>b</i> and <i>c</i> are local to program named <i>exLocal</i>.</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<p>Now, let us extend the program little more, let us create a procedure named display, which will have its own set of variables <i>a</i>, <i>b</i> and <i>c</i> and display their values, right from the program <i>exLocal</i>.</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<h2>Global Variables</h2>

<p>Global variables are defined outside of a function, usually on top of the program. The global variables will hold their value throughout the lifetime of your program and they can be accessed inside any of the functions defined for the program.</p>

<p>A <b>global</b> variable can be accessed by any function. That is, a global variable is available for use throughout your entire program after its declaration. Following is an example using <b>global</b> and <b>local</b> variables &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<p>Please note that the procedure display has access to the variables a, b and c, which are global variables with respect to display as well as its own local variables. A program can have same name for local and global variables but value of local variable inside a function will take preference.</p>

<p>Let us change the previous example a little, now the local variables for the procedure display has same names as <i>a</i>, <i>b</i>, <i>c</i> &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<h1>Pascal - Strings</h1>

<p>The string in Pascal is actually a sequence of characters with an optional size specification. The characters could be numeric, letters, blank, special characters or a combination of all. Extended Pascal provides numerous types of string objects depending upon the system and implementation. We will discuss more common types of strings used in programs.</p>

<p>You can define a string in many ways &minus;</p>

<p><b>Character arrays</b> &minus; This is a  character string which is a sequence of zero or more byte-sized characters  enclosed in single quotes.</p>

<p><b>String variables</b> &minus; The variable of String type, as defined in Turbo Pascal.</p>

<p><b>Short strings</b> &minus; The variable of String type with size specification.</p>

<p><b>Null terminated strings</b> &minus; The variable of <b>pchar</b> type.</p>

<p><b>AnsiStrings</b> &minus; Ansistrings are strings that have no length limit.</p>

<p>Pascal provides only one string operator, string concatenation operator (+).</p>

<h3>Examples</h3>

<p>The following program prints first four kinds of strings. We will use AnsiStrings in the next example.</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<p>Following example makes use of few more functions, let's see &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<h2>Pascal String Functions and Procedures </h2>

<p>Pascal supports a wide range of functions and procedures that manipulate strings. These subprograms vary implement-wise. Here, we are listing various string manipulating subprograms provided by Free Pascal &minus;</p>

<p><b>function AnsiCompareStr(const S1: ; const S2:):Integer; </b></p>

<p>Compares two strings</p>

<p><b>function AnsiCompareText(const S1: ; const S2:):Integer;</b></p>

<p>Compares two strings, case insensitive</p>

<p><b>function AnsiExtractQuotedStr(var Src: PChar; Quote: Char):;</b></p>

<p>Removes quotes from string</p>

<p><b>function AnsiLastChar(const S:):PChar;</b></p>

<p>Gets last character of string</p>

<p><b>function AnsiLowerCase(const s:):</b></p>

<p>Converts string to all-lowercase</p>

<p><b>function AnsiQuotedStr(const S: ; Quote: Char):;</b></p>

<p>Quotes a string</p>

<p><b>function AnsiStrComp(S1: PChar;S2: PChar):Integer;</b></p>

<p>Compares strings case-sensitive</p>

<p><b>function AnsiStrIComp(S1: PChar; S2: PChar):Integer;</b></p>

<p>Compares strings case-insensitive</p>

<p><b>function AnsiStrLComp(S1: PChar; S2: PChar; MaxLen: Cardinal):Integer;</b></p>

<p>Compares L characters of strings case sensitive</p>

<p><b>function AnsiStrLIComp(S1: PChar; S2: PChar; MaxLen: Cardinal):Integer;</b></p>

<p>Compares L characters of strings case insensitive</p>

<p><b>function AnsiStrLastChar(Str: PChar):PChar;</b></p>

<p>Gets last character of string</p>

<p><b>function AnsiStrLower(Str: PChar):PChar;</b></p>

<p>Converts string to all-lowercase</p>

<p><b>function AnsiStrUpper(Str: PChar):PChar;</b></p>

<p>Converts string to all-uppercase</p>

<p><b>function AnsiUpperCase(const s:):;</b></p>

<p>Converts string to all-uppercase</p>

<p><b>procedure AppendStr(var Dest: ; const S:);</b></p>

<p>Appends 2 strings</p>

<p><b>procedure AssignStr(var P: PString; const S:);</b></p>

<p>Assigns value of strings on heap</p>

<p><b>function CompareStr(const S1: ; const S2:):Integer; overload;</b></p>

<p>Compares two strings case sensitive</p>

<p><b>function CompareText(const S1: ; const S2:):Integer;</b></p>

<p>Compares two strings case insensitive</p>

<p><b>procedure DisposeStr(S: PShortString); overload;</b></p>

<p>Removes string from heap</p>

<p><b>function IsValidIdent( const Ident:):Boolean;</b></p>

<p>Is string a valid pascal identifier</p>

<p><b>function LastDelimiter(const Delimiters: ; const S:):Integer;</b></p>

<p>Last occurrence of character in a string</p>

<p><b>function LeftStr(const S: ; Count: Integer):;</b></p>

<p>Gets first N characters of a string</p>

<p><b>function LoadStr(Ident: Integer):; </b></p>

<p>Loads string from resources</p>

<p><b>function LowerCase(const s: ):; overload; </b></p>

<p>Converts string to all-lowercase</p>

<p><b>function LowerCase(const V: variant ):; overload; </b></p>

<p>Converts string to all-lowercase</p>

<p><b>function NewStr(const S:):PString; overload;</b></p>

<p>Allocates new string on heap</p>

<p><b>function RightStr(const S: ; Count: Integer):;</b></p>

<p>Gets last N characters of a string</p>

<p><b>function StrAlloc(Size: Cardinal):PChar;</b></p>

<p>Allocates memory for string</p>

<p><b>function StrBufSize(Str: PChar):SizeUInt;</b></p>

<p>Reserves memory for a string</p>

<p><b>procedure StrDispose(Str: PChar);</b></p>

<p>Removes string from heap</p>

<p><b>function StrPas(Str: PChar):; </b></p>

<p>Converts PChar to pascal string</p>

<p><b>function StrPCopy(Dest: PChar; Source:):PChar;</b></p>

<p>Copies pascal string</p>

<p><b>function StrPLCopy(Dest: PChar; Source: ; MaxLen: SizeUInt):PChar;</b></p>

<p>Copies N bytes of pascal string</p>

<p><b>function UpperCase(const s:):;</b></p>

<p>Converts string to all-uppercase</p>

<h1>Pascal - Booleans</h1>

<p>Pascal provides data type Boolean that enables the programmers to define, store and manipulate logical entities, such as constants, variables, functions and expressions, etc.</p>

<p>Boolean values are basically integer type. Boolean type variables have two pre-defined possible values <b>True</b> and <b>False</b>. The expressions resolving to a Boolean value can also be assigned to a Boolean type.</p>

<p>Free Pascal also supports the <b>ByteBool</b>, <b>WordBool</b> and <b>LongBool</b> types. These are of type Byte, Word or Longint, respectively.</p>

<p>The value False is equivalent to 0 (zero) and any nonzero value is considered True when converting to a Boolean value.  A Boolean value of True is converted to -1 in case it is assigned to a variable of type LongBool.</p>

<p>It should be noted that logical operators <b>and</b>, <b>or</b> and <b>not</b> are defined for Boolean data types.</p>

<h2>Declaration of Boolean Data Types</h2>

<p> A variable of Boolean type is declared using the var keyword.</p>

<p>for example,</p>

<h3>Example</h3>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<h1>Pascal - Arrays</h1>

<p>Pascal programming language provides a data structure called the array, which can store a fixed-size sequential collection of elements of the same type. An array is used to store a collection of data, but it is often more useful to think of an array as a collection of variables of the same type.</p>

<p>Instead of declaring individual variables, such as number1, number2, ..., and number100, you declare one array variable such as numbers and use numbers[1], numbers[2], and ..., numbers[100] to represent individual variables. A specific element in an array is accessed by an index.</p>

<p>All arrays consist of contiguous memory locations. The lowest address corresponds to the first element and the highest address to the last element.</p>

<p>Please note that if you want a C style array starting from index 0, you just need to start the index from 0, instead of 1.</p>

<h2>Declaring Arrays</h2>

<p>To declare an array in Pascal, a programmer may either declare the type and then create variables of that array or directly declare the array variable.</p>

<p>The general form of type declaration of one-dimensional array is &minus;</p>

<p>Where,</p>

<p><b>array-identifier</b> &minus; indicates the name of the array type.</p>

<p><b>index-type</b> &minus; specifies the subscript of the array; it can be any scalar data type except real</p>

<p><b>element-type</b> &minus; specifies the types of values that are going to be stored</p>

<p>For example,</p>

<p>Now, velocity is a variable array of vector type, which is sufficient to hold up to 25 real numbers.</p>

<p>To start the array from 0 index, the declaration would be &minus;</p>

<h2>Types of Array Subscript</h2>

<p>In Pascal, an array subscript could be of any scalar type like, integer, Boolean, enumerated or subrange, except real. Array subscripts could have negative values too.</p>

<p>For example,</p>

<p>Let us take up another example where the subscript is of character type &minus;</p>

<p>Subscript could be of enumerated type &minus;</p>

<h2>Initializing Arrays</h2>

<p>In Pascal, arrays are initialized through assignment, either by specifying a particular subscript or using a for-do loop.</p>

<p>For example &minus;</p>

<h2>Accessing Array Elements</h2>

<p>An element is accessed by indexing the array name. This is done by placing the index of the element within square brackets after the name of the array. For example &minus;</p>

<p>The above statement will take the first element from the array named alphabet and assign the value to the variable a.</p>

<p>Following is an example, which will use all the above-mentioned three concepts viz. declaration, assignment and accessing arrays &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<h2>Pascal Arrays in Detail</h2>

<p>Arrays are important to Pascal and should need lots of more details. There are following few important concepts related to array which should be clear to a Pascal programmer &minus;</p>

<p><a href="/pascal/pascal_multi_dimensional_arrays.htm" title="Multi-dimensional arrays in Pascal">Multi-dimensional arrays</a></p>

<p><a href="/pascal/pascal_dynamic_arrays.htm" title="Dynamic Arrays in Pascal">Dynamic array</a></p>

<p><a href="/pascal/pascal_packed_array.htm" title="Packed Array in Pascal">Packed array</a></p>

<p><a href="/pascal/pascal_passing_arrays_to_subprograms.htm" title="Passing arrays to subprogram as arguments in Pascal">Passing arrays to subprograms</a></p>

<h1>Pascal - Pointers</h1>

<p>Pointers in Pascal are easy and fun to learn. Some Pascal programming tasks are performed more easily with pointers, and other tasks, such as dynamic memory allocation, cannot be performed without using pointers. So it becomes necessary to learn pointers to become a perfect  Pascal programmer. Let's start learning them in simple and easy steps.</p>

<p>As you know, every variable is a memory location and every memory location has its address defined which can be accessed using the name of the pointer variable, which denotes an address in memory.</p>

<h2>What Are Pointers?</h2>

<p>A pointer is a dynamic variable, whose value is the address of another variable, i.e., direct address of the memory location. Like any variable or constant, you must declare a pointer before you can use it to store any variable address.  The general form of a pointer variable declaration is &minus;</p>

<p>The pointer type is defined by prefixing the up-arrow of caret symbol (^) with the base type.  The base-type defines the types of the data items. Once a pointer variable is defined to be of certain type, it can point data items of that type only. Once a pointer type has been defined, we can use the <b>var</b> declaration to declare pointer variables.</p>

<p>Following are some valid pointer declarations &minus;</p>

<p>The pointer variables are dereferenced by using the same caret symbol (^). For example, the associated variable referred by a pointer <i>rptr</i>, is <i>rptr^</i>. It can be accessed as &minus;</p>

<p>The following example will illustrate this concept &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<h2>Printing a Memory Address in Pascal</h2>

<p>In Pascal, we can assign the address of a variable to a pointer variable using the address operator (@). We use this pointer to manipulate and access the data item. However, if for some reason, we need to work with the memory address itself, we need to store it in a word type variable.</p>

<p>Let us extend the above example to print the memory address stored in the pointer <i>iptr</i> &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<h2>NIL Pointers</h2>

<p>It is always a good practice to assign a <b>NIL</b> value to a pointer variable in case you do not have exact address to be assigned. This is done at the time of variable declaration. A pointer that is assigned <b>NIL</b> points to nowhere. Consider the following program &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<p>To check for a <b>nil</b> pointer you can use an if statement as follows &minus;</p>

<h2>Pascal Pointers in Detail</h2>

<p>Pointers have many but easy concepts and they are very important to Pascal programming. There are following few important pointer concepts, which should be clear to a Pascal programmer &minus;</p>

<p><a href="/pascal/pascal_pointer_arithmetic.htm" title="Pascal - Pointer Arithmetic">Pascal - Pointer arithmetic</a></p>

<p><a href="/pascal/pascal_array_of_pointers.htm" title="Pascal - Array of Pointers">Pascal  - Array of pointers</a></p>

<p><a href="/pascal/pascal_pointer_to_pointer.htm" title="Pascal - Pointer to Pointer Operators">Pascal - Pointer to pointer</a></p>

<p><a href="/pascal/pascal_passing_pointers_to_subprograms.htm" title="Passing pointers to subprograms in Pascal">Passing pointers to subprograms in Pascal</a></p>

<p><a href="/pascal/pascal_return_pointer_from_subprograms.htm" title="Return pointer from subprograms in Pascal">Return pointer from subprograms in Pascal</a></p>

<h1>Pascal - Records</h1>

<p>Pascal arrays allow you to define type of variables that can hold several data items of the same kind but a record is another user-defined data type available in Pascal which allows you to combine data items of different kinds.</p>

<p>Records consist of different fields. Suppose you want to keep track of your books in a library, you might want to track the following attributes about each book &minus;</p>

<h2>Defining a Record</h2>

<p>To define a record type, you may use the type declaration statement. The record type is defined as &minus;</p>

<p>Here is the way you would declare the Book record &minus;</p>

<p>The record variables are defined in the usual way as </p>

<p>Alternatively, you can directly define a record type variable as &minus;</p>

<h2>Accessing Fields of a Record</h2>

<p>To access any field of a record, we use the member access operator (.). The member access operator is coded as a period between the record variable name and the field that we wish to access. Following is the example to explain usage of structure &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<h2>Records as Subprogram Arguments</h2>

<p>You can pass a record as a subprogram argument in very similar way as you pass any other variable or pointer. You would access the record fields in the similar way as you have accessed in the above example &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<h2>Pointers to Records</h2>

<p>You can define pointers to records in very similar way as you define pointer to any other variable as follows &minus;</p>

<p>Now, you can store the address of a record type variable in the above-defined pointer variable. To declare a variable of the created pointer type, you use the var keyword &minus;</p>

<p>Before using these pointers, you must create storage for a record-name type variable, which will be manipulated by these pointers.</p>

<p>To access the members of a record using a pointer to that record, you must use the ^. operator as follows &minus;</p>

<p>Finally, don't forget to dispose the used storage, when it is no longer in use &minus;</p>

<p>Let us re-write the first example using a pointer to the Books record. Hope this will be easy for you to understand the concept &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<h2>The With Statement</h2>

<p>We have discussed that the members of a record can be accessed using the member access operator (.). This way the name of the record variable has to be written every time. The <b>With</b> statement provides an alternative way to do that.</p>

<p>Look at the following code snippet taken from our first example &minus;</p>

<p>The same assignment could be written using the <b>With</b> statement as &minus;</p>

<h1>Pascal - Variants</h1>

<p>Pascal supports a unique type of storage named variants.  You can assign any simple type of values in a variant variable. The type of a value stored in a variant is only determined at runtime. Almost any simple type can be assigned to variants: ordinal types, string types, int64 types.</p>

<p>Structured types such as sets, records, arrays, files, objects and classes are not assignment-compatible with a variant.  You can also assign a pointer to a variant.</p>

<p>Free Pascal supports variants.</p>

<h2>Declaring a Variant</h2>

<p>You can declare variant type like any other types using the <b>var</b> keyword. The syntax for declaring a variant type is &minus;</p>

<p>Now, this variant variable v can be assigned to almost all simple types including the enumerated types and vice versa.</p>

<h3>Example</h3>

<p>The following example would illustrate the concept &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<h1>Pascal - Sets</h1>

<p>A set is a collection of elements of same type. Pascal allows defining the set data type. The elements in a set are called its members. In mathematics, sets are represented by enclosing the members within <i>braces{}</i>.  However, in Pascal, set elements are enclosed within square brackets [], which are referred as set constructor.</p>

<h2>Defining Set Types and Variables</h2>

<p>Pascal Set types are defined as</p>

<p>Variables of set type are defined as</p>

<p>or,</p>

<p>Examples of some valid set type declaration are &minus;</p>

<h2>Set Operators</h2>

<p>You can perform the following set operations on Pascal sets.</p>

<p>Following table shows all the set operators supported by Free Pascal. Assume that <b>S1</b> and <b>S2</b> are two character sets, such that &minus;</p>

<p>S1 := ['a', 'b', 'c']; </p>

<p>S2 := ['c', 'd', 'e']; </p>

<p>S1 + S2 will give a set</p>

<p>['a', 'b', 'c', 'd', 'e']</p>

<p>S1 - S2 will give a set</p>

<p>['a', 'b']</p>

<p>S1 * S2 will give a set</p>

<p>['c']</p>

<p>Include (S1, ['d']) will give a set</p>

<p>['a', 'b', 'c', 'd']</p>

<p>Exclude (S2, ['d']) will give a set</p>

<p>['c', 'e']</p>

<h3>Example</h3>

<p>The following example illustrates the use of some of these operators &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<h1>Pascal - File Handling</h1>

<p>Pascal treats a file as a sequence of components, which must be of uniform type. A file's type is determined by the type of the components. File data type is defined as &minus;</p>

<p>Where, the base-type indicates the type of the components of the file. The base type could be anything like, integer, real, Boolean, enumerated, subrange, record, arrays and sets except another file type. Variables of a file type are created using the <i>var</i> declaration &minus;</p>

<p>Following are some examples of defining some file types and file variables &minus;</p>

<h2>Creating and Writing to a File</h2>

<p>Let us write a program that would create a data file for students' records. It would create a file named students.dat and write a student's data into it &minus;</p>

<p>When compiled and run, the program would create a file named <i>students.dat</i> into the working directory. You can open the file using a text editor, like notepad, to look at John Smith's data.</p>

<h2>Reading from a File</h2>

<p>We have just created and written into a file named students.dat. Now, let us write a program that would read the student's data from the file &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<h2>Files as Subprogram Parameter</h2>

<p>Pascal allows file variables to be used as parameters in standard and user-defined subprograms. The following example illustrates this concept. The program creates a file named rainfall.txt and stores some rainfall data. Next, it opens the file, reads the data and computes the average rainfall.</p>

<p>Please note that, <b>if you use a file parameter with subprograms, it must be declared as a var parameter.</b></p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<h2>Text Files</h2>

<p>A text file, in Pascal, consists of lines of characters where each line is terminated with an end-of-line marker. You can declare and define such files as &minus;</p>

<p>Difference between a normal file of characters and a text file is that a text file is divided into lines, each terminated by a special end-of-line marker, automatically inserted by the system. The following example creates and writes into a text file named contact.txt &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<h2>Appending to a File</h2>

<p>Appending to a file means writing to an existing file that already has some data without overwriting the file. The following program illustrates this &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<h2>File  Handling Functions</h2>

<p>Free Pascal provides the following functions/procedures for file handling &minus;</p>

<p><b>procedure Append(var t: Text);</b></p>

<p>Opens a file in append mode</p>

<p><b>procedure Assign(out f: file; const Name:);</b></p>

<p>Assigns a name to a file</p>

<p><b>procedure Assign(out f: file; p: PChar);</b></p>

<p>Assigns a name to a file</p>

<p><b>procedure Assign(out f: file; c: Char);</b></p>

<p>Assigns a name to a file</p>

<p><b>procedure Assign(out f: TypedFile; const Name:);</b></p>

<p>Assigns a name to a file</p>

<p><b>procedure Assign(out f: TypedFile; p: PChar);</b></p>

<p>Assigns a name to a file</p>

<p><b>procedure Assign(out f: TypedFile; c: Char);</b></p>

<p>Assigns a name to a file</p>

<p><b>procedure Assign(out t: Text; const s:);</b></p>

<p>Assigns a name to a file</p>

<p><b>procedure Assign(out t: Text; p: PChar);</b></p>

<p>Assigns a name to a file</p>

<p><b>procedure Assign(out t: Text; c: Char);</b></p>

<p>Assigns a name to a file</p>

<p><b>procedure BlockRead(var f: file; var Buf; count: Int64; var Result: Int64);</b></p>

<p>Reads data from a file into memory</p>

<p><b>procedure BlockRead(var f: file; var Buf; count: LongInt; var Result: LongInt);</b></p>

<p>Reads data from a file into memory</p>

<p><b>procedure BlockRead(var f: file; var Buf; count: Cardinal; var Result: Cardinal);</b></p>

<p>Reads data from a file into memory</p>

<p><b>procedure BlockRead(var f: file; var Buf; count: Word; var Result: Word);</b></p>

<p>Reads data from a file into memory</p>

<p><b>procedure BlockRead(var f: file; var Buf; count: Word; var Result: Integer);</b></p>

<p>Reads data from a file into memory</p>

<p><b>procedure BlockRead(var f: file; var Buf; count: Int64);</b></p>

<p>Reads data from a file into memory</p>

<p><b>procedure BlockWrite(var f: file; const Buf; Count: Int64; var Result: Int64);</b></p>

<p>Writes data from memory to a file</p>

<p><b>procedure BlockWrite(var f: file; const Buf; Count: LongInt; var Result: LongInt);</b></p>

<p>Writes data from memory to a file</p>

<p><b>procedure BlockWrite(var f: file; const Buf; Count: Cardinal; var Result: Cardinal);</b></p>

<p>Writes data from memory to a file</p>

<p><b>procedure BlockWrite(var f: file; const Buf; Count: Word; var Result: Word);</b></p>

<p>Writes data from memory to a file</p>

<p><b>procedure BlockWrite(var f: file; const Buf; Count: Word; var Result: Integer);</b></p>

<p>Writes data from memory to a file</p>

<p><b>procedure BlockWrite(var f: file; const Buf; Count: LongInt);</b></p>

<p>Writes data from memory to a file</p>

<p><b>procedure Close(var f: file);</b></p>

<p>Closes a file</p>

<p><b>procedure Close(var t: Text);</b></p>

<p>Closes a file</p>

<p><b>function EOF(var f: file):Boolean; </b></p>

<p>Checks for end of file</p>

<p><b>function EOF(var t: Text):Boolean;</b></p>

<p>Checks for end of file</p>

<p><b>function EOF: Boolean;</b></p>

<p>Checks for end of file</p>

<p><b>function EOLn(var t: Text):Boolean; </b></p>

<p>Checks for end of line</p>

<p><b>function EOLn: Boolean;</b></p>

<p>Checks for end of line</p>

<p><b>procedure Erase(var f: file);</b></p>

<p>Deletes file from disk</p>

<p><b>procedure Erase(var t: Text);</b></p>

<p>Deletes file from disk</p>

<p><b>function FilePos( var f: file):Int64; </b></p>

<p>Position in file</p>

<p><b>function FileSize(var f: file):Int64;</b></p>

<p>Size of file</p>

<p><b>procedure Flush(var t: Text);</b></p>

<p>Writes file buffers to disk</p>

<p><b>function IOResult: Word;</b></p>

<p>Returns result of last file IO operation</p>

<p><b>procedure Read(var F: Text; Args: Arguments);</b></p>

<p>Reads from file into variable</p>

<p><b>procedure Read(Args: Arguments);</b></p>

<p>Reads from file into variable</p>

<p><b>procedure ReadLn(var F: Text; Args: Arguments);</b></p>

<p>Reads from file into variable and goto next line</p>

<p><b>procedure ReadLn(Args: Arguments);</b></p>

<p>Reads from file into variable and goto next line</p>

<p><b>procedure Rename(var f: file; const s:);</b></p>

<p>Renames file on disk</p>

<p><b>procedure Rename(var f: file; p: PChar);</b></p>

<p>Renames file on disk</p>

<p><b>procedure Rename(var f: file; c: Char);</b></p>

<p>Renames file on disk</p>

<p><b>procedure Rename(var t: Text; const s); </b></p>

<p>Rename file on disk</p>

<p><b>procedure Rename(var t: Text; p: PChar);</b></p>

<p>Renames file on disk</p>

<p><b>procedure Rename( var t: Text; c: Char);</b></p>

<p>Renames file on disk</p>

<p><b>procedure Reset(var f: file; l: LongInt);</b></p>

<p>Opens file for reading</p>

<p><b>procedure Reset(var f: file);</b></p>

<p>Opens file for reading</p>

<p><b>procedure Reset(var f: TypedFile);</b></p>

<p>Opens file for reading</p>

<p><b>procedure Reset(var t: Text);</b></p>

<p>Opens file for reading</p>

<p><b>procedure Rewrite(var f: file; l: LongInt);</b></p>

<p>Opens file for writing</p>

<p><b>procedure Rewrite(var f: file);</b></p>

<p>Opens file for writing</p>

<p><b>procedure Rewrite(var f: TypedFile);</b></p>

<p>Opens file for writing</p>

<p><b>procedure Rewrite(var t: Text);</b></p>

<p>Opens file for writing</p>

<p><b>procedure Seek(var f: file; Pos: Int64);</b></p>

<p>Sets file position</p>

<p><b>function SeekEOF(var t: Text):Boolean;</b></p>

<p>Sets file position to end of file</p>

<p><b>function SeekEOF: Boolean;</b></p>

<p>Sets file position to end of file</p>

<p><b>function SeekEOLn(var t: Text):Boolean;</b></p>

<p>Sets file position to end of line</p>

<p><b>function SeekEOLn: Boolean;</b></p>

<p>Sets file position to end of line</p>

<p><b>procedure SetTextBuf(var f: Text; var Buf);</b></p>

<p>Sets size of file buffer</p>

<p><b>procedure SetTextBuf(var f: Text; var Buf; Size: SizeInt);</b></p>

<p>Sets size of file buffer</p>

<p><b>procedure Truncate(var F: file);</b></p>

<p>Truncate the file at position</p>

<p><b>procedure Write(Args: Arguments);</b></p>

<p>Writes variable to file</p>

<p><b>procedure Write(var F: Text; Args: Arguments);</b></p>

<p>Write variable to file</p>

<p><b>procedure Writeln(Args: Arguments);</b></p>

<p>Writes variable to file and append newline</p>

<p><b>procedure WriteLn(var F: Text; Args: Arguments);</b></p>

<p>Writes variable to file and append newline</p>

<h1>Pascal - Memory Management</h1>

<p>This chapter explains dynamic memory management in Pascal. Pascal programming language provides several functions for memory allocation and management.</p>

<h2>Allocating Memory Dynamically</h2>

<p>While doing programming, if you are aware about the size of an array, then it is easy and you can define it as an array. For example, to store a name of any person, it can go max 100 characters so you can define something as follows &minus;</p>

<p>But now, let us consider a situation, where you have no idea about the length of the text you need to store, for example, you want to store a detailed description about a topic.  Here, we need to define a pointer to string without defining how much memory is required.</p>

<p>Pascal provides a procedure <b>new</b>to create pointer variables.</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<p>Now, if you need to define a pointer with specific number of bytes to be referred by it later, you should use the <b>getmem</b> function or the <b>getmem</b> procedure, which has the following syntax &minus;</p>

<p>In the previous example, we declared a pointer to a string. A string has a maximum value of 255 bytes. If you really don't need that much space, or a larger space, in terms of bytes, <i>getmem</i> subprogram allows specifying that. Let us rewrite the previous example, using <i>getmem</i> &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<p>So, you have complete control and you can pass any size value while allocating memory unlike arrays, where once you defined the size cannot be changed.</p>

<h2>Resizing and Releasing Memory</h2>

<p>When your program comes out, operating system automatically releases all the memory allocated by your program, but as a good practice when you are not in need of memory anymore, then you should release that memory.</p>

<p>Pascal provides the procedure <b>dispose</b> to free a dynamically created variable using the procedure <b>new.</b> If you have allocated memory using the <b>getmem</b> subprogram, then you need to use the subprogram <b>freemem</b> to free this memory. The <i>freemem</i> subprograms have the following syntax &minus;</p>

<p>Alternatively, you can increase or decrease the size of an allocated memory block by calling the function <i>ReAllocMem</i>. Let us check the above program once again and make use of <i>ReAllocMem</i> and <i>freemem</i> subprograms. Following is the syntax for <i>ReAllocMem</i> &minus;</p>

<p>Following is an example which makes use of <i>ReAllocMem</i> and <i>freemem</i> subprograms &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<h2>Memory Management Functions</h2>

<p>Pascal provides a hoard of memory management functions that is used in implementing various data structures and implementing low-level programming in Pascal. Many of these functions are implementation dependent. Free Pascal provides the following functions and procedures for memory management &minus;</p>

<p><b>function Addr(X: TAnytype):Pointer;</b></p>

<p>Returns address of variable</p>

<p><b>function Assigned(P: Pointer):Boolean;</b></p>

<p>Checks if a pointer is valid</p>

<p><b>function CompareByte(const buf1; const buf2; len: SizeInt):SizeInt;</b></p>

<p>Compares 2 memory buffers byte per byte</p>

<p><b>function CompareChar(const buf1; const buf2; len: SizeInt):SizeInt;</b></p>

<p>Compares 2 memory buffers byte per byte</p>

<p><b>function CompareDWord(const buf1; const buf2; len: SizeInt):SizeInt;</b></p>

<p>Compares 2 memory buffers byte per byte</p>

<p><b>function CompareWord(const buf1; const buf2; len: SizeInt):SizeInt;</b></p>

<p>Compares 2 memory buffers byte per byte</p>

<p><b>function Cseg: Word;</b></p>

<p>Returns code segment</p>

<p><b>procedure Dispose(P: Pointer);</b></p>

<p>Frees dynamically allocated memory</p>

<p><b>procedure Dispose(P: TypedPointer; Des: TProcedure);</b></p>

<p>Frees dynamically allocated memory</p>

<p><b>function Dseg: Word;</b></p>

<p>Returns data segment</p>

<p><b>procedure FillByte(var x; count: SizeInt;  value: Byte);</b></p>

<p>Fills memory region with 8-bit pattern</p>

<p><b>procedure FillChar(  var x;  count: SizeInt; Value: Byte|Boolean|Char);</b></p>

<p>Fills memory region with certain character</p>

<p><b>procedure FillDWord( var x; count: SizeInt; value: DWord);</b></p>

<p>Fills memory region with 32-bit pattern</p>

<p><b>procedure FillQWord( var x;  count: SizeInt;  value: QWord);</b></p>

<p>Fills memory region with 64-bit pattern</p>

<p><b>procedure Freemem(  p: pointer;  Size: PtrUInt);</b></p>

<p>Releases allocated memory</p>

<p><b>procedure Freemem(  p: pointer );</b></p>

<p>Releases allocated memory</p>

<p><b>procedure Getmem( out p: pointer; Size: PtrUInt);</b></p>

<p>Allocates new memory</p>

<p><b>procedure Getmem( out p: pointer);</b></p>

<p>Allocates new memory</p>

<p><b>procedure GetMemoryManager(  var MemMgr: TMemoryManager);</b></p>

<p>Returns current memory manager</p>

<p><b>function High(  Arg: TypeOrVariable):TOrdinal;</b></p>

<p>Returns highest index of open array or enumerated</p>

<p><b>function IndexByte(  const buf;  len: SizeInt;  b: Byte):SizeInt;</b></p>

<p>Finds byte-sized value in a memory range</p>

<p><b>function IndexChar(  const buf;  len: SizeInt;  b: Char):SizeInt;</b></p>

<p>Finds char-sized value in a memory range</p>

<p><b>function IndexDWord(  const buf;  len: SizeInt;  b: DWord):SizeInt;</b></p>

<p>Finds DWord-sized (32-bit) value in a memory range</p>

<p><b>function IndexQWord(  const buf;  len: SizeInt;  b: QWord):SizeInt;</b></p>

<p>Finds QWord-sized value in a memory range</p>

<p><b>function Indexword(  const buf;  len: SizeInt;  b: Word):SizeInt;</b></p>

<p>Finds word-sized value in a memory range</p>

<p><b>function IsMemoryManagerSet: Boolean;</b></p>

<p>Is the memory manager set</p>

<p><b>function Low(  Arg: TypeOrVariable ):TOrdinal;</b></p>

<p>Returns lowest index of open array or enumerated</p>

<p><b>procedure Move(  const source;  var dest;  count: SizeInt );</b></p>

<p>Moves data from one location in memory to another</p>

<p><b>procedure MoveChar0(  const buf1;  var buf2;  len: SizeInt);</b></p>

<p>Moves data till first zero character</p>

<p><b>procedure New(  var P: Pointer);</b></p>

<p>Dynamically allocate memory for variable</p>

<p><b>procedure New(  var P: Pointer;  Cons: TProcedure);</b></p>

<p>Dynamically allocates memory for variable</p>

<p><b>function Ofs(  var X ):LongInt;</b></p>

<p>Returns offset of variable</p>

<p><b>function ptr(  sel: LongInt;  off: LongInt):farpointer;</b></p>

<p>Combines segment and offset to pointer</p>

<p><b>function ReAllocMem(  var p: pointer;  Size: PtrUInt):pointer;</b></p>

<p>Resizes a memory block on the heap</p>

<p><b>function Seg(  var X):LongInt;</b></p>

<p>Returns segment</p>

<p><b>procedure SetMemoryManager(  const MemMgr: TMemoryManager );</b></p>

<p>Sets a memory manager</p>

<p><b>function Sptr: Pointer;</b></p>

<p>Returns current stack pointer</p>

<p><b>function Sseg: Word;</b></p>

<p>Returns stack segment register value</p>

<h1>Pascal - Units</h1>

<p>A Pascal program can consist of modules called units. A unit might consist of some code blocks, which in turn are made up of variables and type declarations, statements, procedures, etc. There are many built-in units in Pascal and Pascal allows programmers to define and write their own units to be used later in various programs.</p>

<h2>Using Built-in Units</h2>

<p>Both the built-in units and user-defined units are included in a program by the uses clause. We have already used the variants unit in <i>Pascal - Variants</i> tutorial. This tutorial explains creating and including user-defined units. However, let us first see how to include a built-in unit <b>crt</b> in your program &minus;</p>

<p>The following example illustrates using the <b>crt</b> unit &minus;</p>

<p>It is the same program we used right at the beginning of the Pascal tutorial, compile and run it to find the effects of the change.</p>

<h2>Creating and Using a Pascal Unit</h2>

<p>To create a unit, you need to write the modules or subprograms you want to store in it and save it in a file with <b>.pas</b> extension. The first line of this file should start with the keyword unit followed by the name of the unit. For example &minus;</p>

<p>Following are three important steps in creating a Pascal unit &minus;</p>

<p>The name of the file and the name of the unit should be exactly same. So, our unit <i>calculateArea</i> will be saved in a file named <i>calculateArea.pas.</i></p>

<p>The next line should consist of a single keyword <b>interface</b>. After this line, you will write the declarations for all the functions and procedures that will come in this unit.</p>

<p>Right after the function declarations, write the word <b>implementation</b>, which is again a keyword. After the line containing the keyword implementation, provide definition of all the subprograms.</p>

<p>The following program creates the unit named calculateArea &minus;</p>

<p>Next, let us write a simple program that would use the unit we defined above &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<h1>Pascal - Date and Time</h1>

<p>Most of the softwares you write need implementing some form of date functions returning current date and time. Dates are so much part of everyday life that it becomes easy to work with them without thinking. Pascal also provides powerful tools for date arithmetic that makes manipulating dates easy. However, the actual name and workings of these functions are different for different compilers.</p>

<h2>Getting the Current Date &amp; Time</h2>

<p>Pascal's TimeToString function gives you the current time in a colon(: ) delimited form. The following example shows how to get the current time &minus;</p>

<p>When the above code was compiled and executed, it produces the following result &minus;</p>

<p>The <b>Date</b> function returns the current date in <b>TDateTime</b> format. The TDateTime is a double value, which needs some decoding and formatting. The following program demonstrates how to use it in your program to display the current date &minus;</p>

<p>When the above code was compiled and executed, it produces the following result &minus;</p>

<p>The Now function returns the current date and time &minus;</p>

<p>When the above code was compiled and executed, it produces the following result &minus;</p>

<p>Free Pascal provides a simple time stamp structure named <b>TTimeStamp</b>, which has the following format &minus;</p>

<h2>Various Date &amp; Time Functions</h2>

<p>Free Pascal provides the following date and time functions &minus;</p>

<p><b>function DateTimeToFileDate(DateTime: TDateTime):LongInt;</b></p>

<p>Converts DateTime type to file date.</p>

<p><b>function DateTimeToStr( DateTime: TDateTime):; </b></p>

<p>Constructs string representation of DateTime</p>

<p><b>function DateTimeToStr(DateTime: TDateTime; const FormatSettings: TFormatSettings):;</b></p>

<p>Constructs string representation of DateTime</p>

<p><b>procedure DateTimeToString(out Result: ;const FormatStr: ;const DateTime: TDateTime);</b></p>

<p>Constructs string representation of DateTime</p>

<p><b>procedure DateTimeToString(out Result: ; const FormatStr: ; const DateTime: TDateTime; const FormatSettings: TFormatSettings);</b></p>

<p>Constructs string representation of DateTime</p>

<p><b>procedure DateTimeToSystemTime(DateTime: TDateTime; out SystemTime: TSystemTime);</b></p>

<p>Converts DateTime to system time</p>

<p><b>function DateTimeToTimeStamp( DateTime: TDateTime):TTimeStamp;</b>Converts DateTime to timestamp</p>

<p><b>function DateToStr(Date: TDateTime):;</b></p>

<p>Constructs string representation of date</p>

<p><b>function DateToStr(Date: TDateTime; const FormatSettings: TFormatSettings):;</b></p>

<p>Constructs string representation of date</p>

<p><b>function Date: TDateTime;</b></p>

<p>Gets current date</p>

<p><b>function DayOfWeek(DateTime: TDateTime):Integer;</b></p>

<p>Gets day of week</p>

<p><b>procedure DecodeDate(Date: TDateTime; out Year: Word; out Month: Word; out Day: Word);</b></p>

<p>Decodes DateTime to year month and day</p>

<p><b>procedure DecodeTime(Time: TDateTime; out Hour: Word; out Minute: Word; out Second: Word;  out MilliSecond: Word);</b></p>

<p>Decodes DateTime to hours, minutes and seconds</p>

<p><b>function EncodeDate(Year: Word; Month: Word; Day: Word):TDateTime; </b></p>

<p>Encodes year, day and month to DateTime</p>

<p><b>function EncodeTime(Hour: Word; Minute: Word; Second: Word; MilliSecond: Word):TDateTime; </b></p>

<p>Encodes hours, minutes and seconds to DateTime</p>

<p><b>function FormatDateTime(const FormatStr: ; DateTime: TDateTime):;</b></p>

<p>Returns string representation of DateTime</p>

<p><b>function FormatDateTime(const FormatStr: ; DateTime: TDateTime; const FormatSettings: TFormatSettings):;</b></p>

<p>Returns string representation of DateTime</p>

<p><b>function IncMonth(const DateTime: TDateTime; NumberOfMonths: Integer = 1):TDateTime;</b></p>

<p>Adds 1 to month</p>

<p><b>function IsLeapYear(Year: Word):Boolean;</b></p>

<p>Determines if year is leap year</p>

<p><b>function MSecsToTimeStamp(MSecs: Comp):TTimeStamp;</b></p>

<p>Converts number of milliseconds to timestamp</p>

<p><b>function Now: TDateTime;</b></p>

<p>Gets current date and time</p>

<p><b>function StrToDateTime(const S:):TDateTime;</b></p>

<p>Converts string to DateTime</p>

<p><b>function StrToDateTime(const s: ShortString; const FormatSettings: TFormatSettings):TDateTime;</b></p>

<p>Converts string to DateTime</p>

<p><b>function StrToDateTime(const s: AnsiString; const FormatSettings: TFormatSettings):TDateTime;</b></p>

<p>Converts string to DateTime</p>

<p><b>function StrToDate(const S: ShortString):TDateTime;</b></p>

<p>Converts string to date</p>

<p><b>function StrToDate(const S: Ansistring):TDateTime;</b></p>

<p>Converts string to date</p>

<p><b>function StrToDate(const S: ShortString; separator: Char):TDateTime;</b></p>

<p>Converts string to date</p>

<p><b>function StrToDate(const S: AnsiString; separator: Char):TDateTime;</b></p>

<p>Converts string to date</p>

<p>Converts string to date</p>

<p><b>function StrToDate(const S: AnsiString; const useformat: ; separator: Char):TDateTime;</b></p>

<p>Converts string to date</p>

<p><b>function StrToDate(const S: PChar; Len: Integer; const useformat: ; separator: Char = #0):TDateTime;</b></p>

<p>Converts string to date</p>

<p><b>function StrToTime(const S: Shortstring):TDateTime;</b></p>

<p>Converts string to time</p>

<p><b>function StrToTime(const S: Ansistring):TDateTime;</b></p>

<p>Converts string to time</p>

<p><b>function StrToTime(const S: ShortString; separator: Char):TDateTime;</b></p>

<p>Converts string to time</p>

<p><b>function StrToTime(const S: AnsiString; separator: Char):TDateTime;</b></p>

<p>Converts string to time</p>

<p><b>function StrToTime(const S: ; FormatSettings: TFormatSettings):TDateTime;</b></p>

<p>Converts string to time</p>

<p><b>function StrToTime(const S: PChar; Len: Integer; separator: Char = #0):TDateTime;</b></p>

<p>Converts string to time</p>

<p><b>function SystemTimeToDateTime(const SystemTime: TSystemTime):TDateTime;</b></p>

<p>Converts system time to datetime</p>

<p><b>function TimeStampToDateTime(const TimeStamp: TTimeStamp):TDateTime;</b></p>

<p>Converts time stamp to DateTime</p>

<p><b>function TimeStampToMSecs(const TimeStamp: TTimeStamp):comp;</b></p>

<p>Converts Timestamp to number of milliseconds</p>

<p><b>function TimeToStr(Time: TDateTime):;</b></p>

<p>Returns string representation of Time</p>

<p><b>function TimeToStr(Time: TDateTime; const FormatSettings: TFormatSettings):;</b></p>

<p>Returns string representation of Time</p>

<p><b>function Time: TDateTime;</b></p>

<p>Get current time</p>

<p>The following example illustrates the use of some of the above functions &minus;</p>

<p>When the above code was compiled and executed, it produced the following result:</p>

<h1>Pascal - Object Oriented</h1>

<p>We can imagine our universe made of different objects like sun, earth, moon, etc. Similarly, we can imagine our car made of different objects like wheel, steering, gear, etc. Same way, there are object-oriented programming concepts, which assume everything as an object and implement a software using different objects. In Pascal, there are two structural data types used to implement a real world object &minus;</p>

<h2>Object-Oriented Concepts</h2>

<p>Before we go in detail, let's define important Pascal terms related to Object-Oriented Pascal.</p>

<p><b>Object</b> &minus; An Object is a special kind of record that contains fields like a record; however, unlike records, objects contain procedures and functions as part of the object. These procedures and functions are held as pointers to the methods associated with the object's type.</p>

<p><b>Class</b> &minus; A Class is defined in almost the same way as an Object, but there is a difference in way they are created. The Class is allocated on the Heap of a program, whereas the Object is allocated on the Stack. It is a pointer to the object, not the object itself.</p>

<p><b>Instantiation of a class</b> &minus; Instantiation means creating a variable of that class type. Since a class is just a pointer, when a variable of a class type is declared, there is memory allocated only for the pointer, not for the entire object. Only when it is instantiated using one of its constructors, memory is allocated for the object. Instances of a class are also called 'objects', but do not confuse them with Object Pascal Objects. In this tutorial, we will write 'Object' for Pascal Objects and 'object' for the conceptual object or class instance.</p>

<p><b>Member Variables</b> &minus; These are the variables defined inside a Class or an Object.</p>

<p><b>Member Functions</b> &minus; These are the functions or procedures defined inside a Class or an Object and are used to access object data.</p>

<p><b>Visibility of Members</b> &minus; The members of an Object or Class are also called the fields. These fields have different visibilities. Visibility refers to accessibility of the members, i.e., exactly where these members will be accessible. Objects have three visibility levels: public, private and protected. Classes have five visibility types: public, private, strictly private, protected and published. We will discuss visibility in details.</p>

<p><b>Inheritance</b> &minus; When a Class is defined by inheriting existing functionalities of a parent Class, then it is said to be inherited. Here child class will inherit all or few member functions and variables of a parent class. Objects can also be inherited.</p>

<p><b>Parent Class</b> &minus; A Class that is inherited by another Class. This is also called a base class or super class.</p>

<p><b>Child Class</b> &minus; A class that inherits from another class. This is also called a subclass or derived class.</p>

<p><b>Polymorphism</b> &minus; This is an object-oriented concept where same function can be used for different purposes. For example, function name will remain same but it may take different number of arguments and can do different tasks. Pascal classes implement polymorphism. Objects do not implement polymorphism. </p>

<p><b>Overloading</b> &minus; It is a type of polymorphism in which some or all of operators have different implementations depending on the types of their arguments. Similarly functions can also be overloaded with different implementation. Pascal classes implement overloading, but the Objects do not. </p>

<p><b>Data Abstraction</b> &minus; Any representation of data in which the implementation details are hidden (abstracted).</p>

<p><b>Encapsulation</b> &minus; Refers to a concept where we encapsulate all the data and member functions together to form an object.</p>

<p><b>Constructor</b> &minus; Refers to a special type of function which will be called automatically whenever there is an object formation from a class or an Object.</p>

<p><b>Destructor</b> &minus; Refers to a special type of function which will be called automatically whenever an Object or Class is deleted or goes out of scope.</p>

<h2>Defining Pascal Objects</h2>

<p>An object is declared using the type declaration. The general form of an object declaration is as follows &minus;</p>

<p>Let us define a Rectangle Object that has two integer type data members - <b>length</b> and <b>width</b> and some member functions to manipulate these data members and a procedure to draw the rectangle.</p>

<p>After creating your objects, you will be able to call member functions related to that object. One member function will be able to process member variable of related object only.</p>

<p>Following example shows how to set lengths and widths for two rectangle objects and draw them by calling the member functions.</p>

<p>Following is a complete example to show how to use objects in Pascal &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<h2>Visibility of the Object Members</h2>

<p>Visibility indicates the accessibility of the object members. Pascal object members have three types of visibility &minus;</p>

<p>By default, fields and methods of an object are public and are exported outside the current unit.</p>

<h2>Constructors and Destructors for Pascal Objects:</h2>

<p><b>Constructors</b> are special type of methods, which are called automatically whenever an object is created. You create a constructor in Pascal just by declaring a method with a keyword constructor. Conventionally, the method name is Init, however, you can provide any valid identifier of your own. You can pass as many arguments as you like into the constructor function.</p>

<p><b>Destructors</b> are methods that are called during the destruction of the object. The destructor methods destroy any memory allocation created by constructors.</p>

<p>Following example will provide a constructor and a destructor for the Rectangle class which will initialize length and width for the rectangle at the time of object creation and destroy it when it goes out of scope.</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<h2>Inheritance for Pascal Objects</h2>

<p>Pascal objects can optionally inherit from a parent object. The following program illustrates inheritance in Pascal Objects. Let us create another object named <b>TableTop</b>, which is inheriting from the Rectangle object.</p>

<p>Following are the important points which should be noted down &minus;</p>

<p>The object <i>Tabletop</i> has inherited all the members of the Rectangle object. </p>

<p>There is a draw method in <i>TableTop</i> also. When the <i>draw</i> method is called using a <i>TableTop</i> object, TableTop's draw gets invoked.</p>

<p>There is an implicit instance named <b>self</b> that refers to the current instance of the object.</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<h1>Pascal - Classes</h1>

<p>You have seen that Pascal Objects exhibit some characteristics of object-oriented paradigm. They implement encapsulation, data hiding and inheritance, but they also have limitations. For example, Pascal Objects do not take part in polymorphism. So classes are widely used to implement proper object-oriented behavior in a program, especially the GUI-based software.</p>

<p>A Class is defined in almost the same way as an Object, but is a pointer to an Object rather than the Object itself. Technically, this means that the Class is allocated on the Heap of a program, whereas the Object is allocated on the Stack. In other words, when you declare a variable the object type, it will take up as much space on the stack as the size of the object, but when you declare a variable of the class type, it will always take the size of a pointer on the stack. The actual class data will be on the heap.</p>

<h2>Defining Pascal Classes</h2>

<p>A class is declared in the same way as an object, using the type declaration. The general form of a class declaration is as follows &minus;</p>

<p>Its worth to note following important points &minus;</p>

<p>Class definitions should come under the type declaration part of the program only.</p>

<p>A class is defined using the <b>class</b> keyword.</p>

<p>Fields are data items that exist in each instance of the class.</p>

<p>Methods are declared within the definition of a class.</p>

<p>There is a predefined constructor called <b>Create</b> in the Root class.  Every abstract class and every concrete class is a descendant of Root, so all classes have at least one constructor.</p>

<p>There is a predefined destructor called <b>Destroy</b> in the Root class.  Every abstract class and every concrete class is a descendant of Root, so, all classes have at least one destructor.</p>

<p>Let us define a Rectangle class that has two integer type data members - length and width and some member functions to manipulate these data members and a procedure to draw the rectangle.</p>

<p>Let us write a complete program that would create an instance of a rectangle class and draw the rectangle. This is the same example we used while discussing Pascal Objects. You will find both programs are almost same, with the following exceptions &minus;</p>

<p>You will need to include the {$mode objfpc} directive for using the classes.</p>

<p>You will need to include the {$m+} directive for using constructors.</p>

<p>Class instantiation is different than object instantiation. Only declaring the variable does not create space for the instance, you will use the constructor create to allocate memory.</p>

<p>Here is the complete example &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<h2>Visibility of the Class Members</h2>

<p>Visibility indicates the accessibility of the class members. Pascal class members have five types of visibility &minus;</p>

<h2>Constructors and Destructors for Pascal Classes</h2>

<p>Constructors are special methods, which are called automatically whenever an object is created. So we take full advantage of this behavior by initializing many things through constructor functions.</p>

<p>Pascal provides a special function called create() to define a constructor. You can pass as many arguments as you like into the constructor function.</p>

<p>Following example will create one constructor for a class named Books and it will initialize price and title for the book at the time of object creation.</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<p>Like the implicit constructor named create, there is also an implicit destructor method destroy using which you can release all the resources used in the class.</p>

<h2>Inheritance</h2>

<p>Pascal class definitions can optionally inherit from a parent class definition. The syntax is as follows &minus;</p>

<p>Following example provides a novels class, which inherits the Books class and adds more functionality based on the requirement.</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<p>Its worth to note following important points &minus;</p>

<p>The members of the Books class have <b>protected</b> visibility. </p>

<p>The Novels class has two constructors, so the <b>overload</b> operator is used for function overloading.</p>

<p>The Books.Display procedure has been declared <b>virtual</b>, so that the same method from the Novels class can <b>override</b> it. </p>

<p>The Novels.Create constructor calls the base class constructor using the <b>inherited</b> keyword. </p>

<h2>Interfaces</h2>

<p>Interfaces are defined to provide a common function name to the implementers. Different implementers can implement those interfaces according to their requirements. You can say, interfaces are skeletons, which are implemented by developers. Following is an example of interface &minus;</p>

<p>Please note that, when a class implements an interface, it should implement all methods of the interface. If a method of an interface is not implemented, then the compiler will give an error.</p>

<h2>Abstract Classes</h2>

<p>An abstract class is one that cannot be instantiated, only inherited. An abstract class is specified by including the word symbol abstract in the class definition, like this &minus;</p>

<p>When inheriting from an abstract class, all methods marked abstract in the parent's class declaration must be defined by the child; additionally, these methods must be defined with the same visibility.</p>

<h2>Static Keyword</h2>

<p>Declaring class members or methods as static makes them accessible without needing an instantiation of the class. A member declared as static cannot be accessed with an instantiated class object (though a static method can). The following example illustrates the concept &minus;</p>

<p>When the above code is compiled and executed, it produces the following result &minus;</p>

<p>You must use the directive {$static on} for using the static members.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
rpm -i fpc-X.Y.Z-N.ARCH.rpm
</pre>
<p>Where X.Y.Z is the version number of the .rpm file, and ARCH is one of the supported architectures (i386, x86_64, etc.).</p>
<p>Installation code for the Debian version (like Ubuntu): </p>
<pre class="prettyprint notranslate">
dpkg -i fpc-XXX.deb
</pre>
<p>Where XXX is the  version number of the .deb file.</p>
<p>For details read: <a rel="nofollow" target="_blank" href="http://www.freepascal.org/docs-html/user/usersu5.html">Free Pascal Installation Guide</a></p>
<h2>Installing Free Pascal on Mac</h2>
<p>If you use Mac OS X, the easiest way to use Free Pascal is to download the Xcode development environment from Apple's web site and follow the simple installation instructions. Once you have Xcode setup, you will be able to use the Free Pascal compiler.</p>
<h2>Installing Free Pascal on Windows </h2>
<p>For Windows, you will download the Windows installer, setup.exe. This is a usual installation program. You need to take the following steps for installation &minus;</p>
<ul class="list">
<li><p>Select a directory.</p></li>
<li><p>Select parts of the package you want to install.</p></li>
<li><p>Optionally choose to associate the .pp or .pas extensions with the Free Pascal IDE.</p></li>
</ul>
<p>For details read: <a rel="nofollow" target="_blank" href="http://www.freepascal.org/docs-html/user/usersu3.html">Free Pascal Installation Guide</a></p>
<h2>Text Editor</h2>
<p>This will be used to type your program. Examples of few editors include Windows Notepad, OS Edit command, Brief, Epsilon, EMACS, and vim or vi.</p>
<p>Name and version of text editor can vary on different operating systems. For example, Notepad will be used on Windows and vim or vi can be used on windows as well as Linux or UNIX.</p>
<p>The files you create with your editor are called source files and contain program source code. The source files for Pascal programs are typically named with the extension <b>.pas</b>.</p>
<p>Before starting your programming, make sure you have one text editor in place and you have enough experience to write a computer program, save it in a file, compile it and finally execute it.</p>
<h1>Pascal - Program Structures</h1>
<p>Before we study basic building blocks of the Pascal programming language, let us look a bare minimum Pascal program structure so that we can take it as a reference in upcoming chapters.</p>
<h2>Pascal Program Structure</h2>
<p>A Pascal program basically consists of the following parts &minus;</p>
<ul class="list">
<li>Program name</li>
<li>Uses command</li>
<li>Type declarations</li>
<li>Constant declarations</li>
<li>Variables declarations</li>
<li>Functions declarations</li>
<li>Procedures declarations</li>
<li>Main program block</li>
<li>Statements and Expressions within each block</li>
<li>Comments</li>
</ul>
<p>Every pascal program generally has a heading statement, a declaration and an execution part strictly in that order. Following format shows the basic syntax for a Pascal program &minus;</p>
<pre class="prettyprint notranslate">
program {name of the program}
uses {comma delimited names of libraries you use}
const {global constant declaration block}
var {global variable declaration block}

function {function declarations, if any}
{ local variables }
begin
...
end;

procedure { procedure declarations, if any}
{ local variables }
begin
...
end;

begin { main program block starts}
...
end. { the end of main program block }
</pre>
<h2>Pascal Hello World Example</h2>
<p>Following is a simple pascal code that would print the words "Hello, World!":</p>
<pre class="prettyprint notranslate tryit">
program HelloWorld;
uses crt;

(* Here the main program block starts *)
begin
   writeln('Hello, World!');
   readkey;
end. 
</pre>
<p>This will produce following result &minus;</p>
<pre class="result notranslate">
Hello, World!
</pre>
<p>Let us look various parts of the above program &minus;</p>
<ul class="list">
<li><p>The first line of the program <b>program HelloWorld;</b> indicates the name of the program.</p></li>
<li><p>The second line of the program <b>uses crt;</b> is a preprocessor command, which tells the compiler to include the crt unit before going to actual compilation.</p></li>
<li><p>The next lines enclosed within begin and end statements are the main program block. Every block in Pascal is enclosed within a <b>begin</b> statement and an <b>end</b> statement. However, the end statement indicating the end of the main program is followed by a full stop (.) instead of semicolon (;). </p></li>
<li><p>The <b>begin</b> statement of the main program block is where the program execution begins.</p></li>
<li><p>The lines within  <b>(*...*)</b> will be ignored by the compiler and it has been put to add a <b>comment</b> in the program. </p></li>
<li><p>The statement <b>writeln('Hello, World!');</b> uses the writeln function available in Pascal which causes the message "Hello, World!" to be displayed on the screen.</p></li>
<li><p>The statement <b>readkey;</b> allows the display to pause until the user presses a key. It is part of the crt unit. A unit is like a library in Pascal.</p></li>
<li><p>The last statement <b>end.</b> ends your program.</p></li>
</ul>
<h2>Compile and Execute Pascal Program</h2>
<ul class="list">
<li><p>Open a text editor and add the above-mentioned code.</p></li>
<li><p>Save the file as <i>hello.pas</i></p></li>
<li><p>Open a command prompt and go to the directory, where you saved the file.</p></li>
<li><p>Type fpc hello.pas at command prompt and press enter to compile your code.</p></li>
<li><p>If there are no errors in your code, the command prompt will take you to the next line and would generate <b>hello</b> executable file and <b>hello.o</b> object file.</p></li>
<li><p>Now, type <b>hello</b> at command prompt to execute your program.</p></li>
<li><p>You will be able to see "Hello World" printed on the screen and program waits till you press any key.</p></li>
</ul>
<pre class="prettyprint notranslate">
$ fpc hello.pas
Free Pascal Compiler version 2.6.0 [2011/12/23] for x86_64
Copyright (c) 1993-2011 by Florian Klaempfl and others
Target OS: Linux for x86-64
Compiling hello.pas
Linking hello
8 lines compiled, 0.1 sec

$ ./hello
Hello, World!
</pre>
<p>Make sure that free pascal compiler <b>fpc</b> is in your path and that you are running it in the directory containing source file hello.pas.</p>
<h1>Pascal - Basic Syntax</h1>
<p>You have seen a basic structure of pascal program, so it will be easy to understand other basic building blocks of the pascal programming language.</p>
<h2>Variables</h2>
<p>A variable definition is put in a block beginning with a <b>var</b> keyword, followed by definitions of the variables as follows:</p>
<pre class="prettyprint notranslate">
var
A_Variable, B_Variable ... : Variable_Type;
</pre>
<p>Pascal variables are declared outside the code-body of the function which means they are not declared within the <b>begin</b> and <b>end</b> pairs, but they are declared after the definition of the procedure/function and before the <b>begin</b> keyword. For global variables, they are defined after the program header.</p>
<h2>Functions/Procedures</h2>
<p>In Pascal, a <b>procedure</b> is set of instructions to be executed, with no return value and a <b>function</b> is a procedure with a return value. The definition of function/procedures will be as follows &minus;</p>
<pre class="prettyprint notranslate">
Function Func_Name(params...) : Return_Value;
Procedure Proc_Name(params...);
</pre>
<h2>Comments</h2>
<p>The multiline comments are enclosed within curly brackets and asterisks as {* ... *}. Pascal allows single-line comment enclosed within curly brackets { ... }. </p>
<pre class="prettyprint notranslate">
{* This is a multi-line comments
   and it will span multiple lines. *}

{ This is a single line comment in pascal }
</pre>
<h2>Case Sensitivity</h2>
<p>Pascal is a case non-sensitive language, which means you can write your variables, functions and procedure in either case. Like variables A_Variable, a_variable and A_VARIABLE have same meaning in Pascal.</p>
<h2>Pascal Statements </h2>
<p>Pascal programs are made of statements. Each statement specifies a definite job of the program. These jobs could be declaration, assignment, reading data, writing data, taking logical decisions, transferring program flow control, etc.</p>
<p>For example &minus;</p>
<pre class="prettyprint notranslate">
readln (a, b, c);
s := (a + b + c)/2.0;
area := sqrt(s * (s - a)*(s-b)*(s-c));
writeln(area);        
</pre>
<h2> Reserved Words in Pascal</h2>
<p>The statements in Pascal are designed with some specific Pascal words, which are called the reserved words. For example, the words, program, input, output, var, real, begin, readline, writeline and end are all reserved words.</p> 
<p>Following is a list of reserved words available in Pascal.</p>
<table class="table table-bordered">
<tr>
<td>and</td>
<td>array</td>
<td>begin</td>
<td>case</td>
<td>const</td>
</tr>
<tr>
<td>div</td>
<td>do</td>
<td>downto</td>
<td>else</td>
<td>end</td>
</tr>
<tr>
<td>file</td>
<td>for</td>
<td>function</td>
<td>goto</td>
<td>if</td>
</tr>
<tr>
<td>in</td>
<td>label</td>
<td>mod</td>
<td>nil</td>
<td>not</td>
</tr>
<tr>
<td>of</td>
<td>or</td>
<td>packed</td>
<td>procedure</td>
<td>program</td>
</tr>
<tr>
<td>record</td>
<td>repeat</td>
<td>set</td>
<td>then</td>
<td>to</td>
</tr>
<tr>
<td>type</td>
<td>until</td>
<td>var</td>
<td>while</td>
<td>with</td>
</tr>
</table>
<h2>Character set and Identifiers in Pascal</h2>
<p>The Pascal character set consists of &minus;</p>
<ul class="list">
<li><p>All upper case letters (A-Z)</p></li>
<li><p>All lower case letters (a-z)</p></li>
<li><p>All digits (0-9)</p></li>
<li><p>Special symbols   - + * / := , . ;. () [] = {} ` white space</p></li>
</ul>
<p>The entities in a Pascal program like variables and constants, types, functions, procedures and records, etc., have a name or identifier.  An identifier is a sequence of letters and digits, beginning with a letter. Special symbols and blanks must not be used in an identifier.</p>
<h1>Pascal - Data Types</h1>
<p>Data types of an entity indicates the meaning, constraints, possible values, operations, functions and mode of storage associated with it.</p>
<p>Integer, real, Boolean and character types are referred as standard data types. Data types can be categorized as scalar, pointer and structured data types. Examples of scalar data types are integer, real, Boolean, character, subrange and enumerated. Structured data types are made of the scalar types; for example, arrays, records, files and sets. We will discuss the pointer data types later.</p>
<h2>Pascal Data Types</h2>
<p>Pascal data types can be summarized as below in the following diagram &minus;</p>
<img src="/pascal/images/pascal_datatypes.jpg" alt="Pascal Data Types"/>
<h2>Type Declarations</h2>
<p>The type declaration is used to declare the data type of an identifier. Syntax of type declaration is &minus;</p>
<pre class="prettyprint notranslate">
 type-identifier-1, type-identfier-2 = type-specifier;
</pre>
<p>For example, the following declaration defines the variables days and age as integer type, yes and true as Boolean type, name and city as string type, fees and expenses as real type.</p>
<pre class="prettyprint notranslate">
type
days, age = integer;
yes, true = boolean;
name, city = string;
fees, expenses = real;
</pre>
<h2>Integer Types</h2>
<p>Following table gives you details about standard integer types with its storage sizes and value ranges used in Object Pascal &minus;</p>
<table class="table table-bordered">
<tr>
<th>Type</th>
<th>Minimum</th>
<th>Maximum</th>
<th>Format</th>
</tr>
<tr>
<td>Integer</td>
<td>-2147483648</td>
<td>2147483647</td>
<td>signed 32-bit</td>
</tr>
<tr>
<td>Cardinal</td>
<td>0</td>
<td>4294967295</td>
<td>unsigned 32-bit</td></tr>
<tr>
<td>Shortint</td>
<td> -128</td>
<td>127</td>
<td>signed 8-bit</td>
</tr>
<tr>
<td>Smallint</td>
<td> -32768</td>
<td>32767</td>
<td>signed 16-bit</td>
</tr>
<tr>
<td>Longint</td>
<td> -2147483648</td>
<td>2147483647</td>
<td>signed 32-bit</td>
</tr>
<tr>
<td>Int64</td>
<td> -2^63</td>
<td>2^63 - 1</td>
<td>signed 64-bit</td>
</tr>
<tr>
<td>Byte</td>
<td>0</td>
<td>255</td>
<td>unsigned 8-bit</td>
</tr>
<tr>
<td>Word</td>
<td>0</td>
<td>65535</td>
<td>unsigned 16-bit</td>
</tr>
<tr>
<td>Longword</td>
<td>0</td>
<td>4294967295</td>
<td>unsigned 32-bit</td>
</tr>
</table>
<h2>Constants</h2>
<p>Use of constants makes a program more readable and helps to keep special quantities at one place in the beginning of the program. Pascal allows <i>numerical, logical, string</i> and <i>character</i> constants. Constants can be declared in the declaration part of the program by specifying the <b>const</b> declaration.</p>
<p>Syntax of constant type declaration is follows &minus;</p>
<pre class="prettyprint notranslate">
const
Identifier = contant_value;
</pre>
<p>Following are some examples of constant declarations &minus;</p>
<pre class="prettyprint notranslate">
VELOCITY_LIGHT = 3.0E=10;
PIE = 3.141592;
NAME = 'Stuart Little';
CHOICE = yes;
OPERATOR = '+';
</pre>
<p>All constant declarations must be given before the variable declaration.</p>
<h2>Enumerated types</h2>
<p>Enumerated data types are user-defined data types. They allow values to be specified in a list. Only <i>assignment</i> operators and <i>relational</i> operators are permitted on enumerated data type. Enumerated data types can be declared as follows &minus;</p>
<pre class="prettyprint notranslate">
type
enum-identifier = (item1, item2, item3, ... )
</pre>
<p>Following are some examples of enumerated  type declarations &minus;</p>
<pre class="prettyprint notranslate">
type
SUMMER = (April, May, June, July, September);
COLORS = (Red, Green, Blue, Yellow, Magenta, Cyan, Black, White);
TRANSPORT = (Bus, Train, Airplane, Ship);
</pre>
<p>The order in which the items are listed in the domain of an enumerated type defines the order of the items. For example, in the enumerated type SUMMER, April comes before May, May comes before June, and so on. The domain of enumerated type identifiers cannot consist of numeric or character constants.</p>
<h2>Subrange Types</h2>
<p>Subrange types allow a variable to assume values that lie within a certain range. For example, if the <i>age</i> of voters should lie between 18 to 100 years, a variable named age could be declared as &minus;</p>
<pre class="prettyprint notranslate">
var
age: 18 ... 100;
</pre>
<p>We will look at variable declaration in detail in the next section. You can also define a subrange type using the type declaration. Syntax for declaring a subrange type is as follows &minus;</p>
<pre class="prettyprint notranslate">
type
subrange-identifier = lower-limit ... upper-limit;
</pre>
<p>Following are some examples of subrange type declarations &minus;</p>
<pre class="prettyprint notranslate">
const
P = 18;
Q = 90;
type
Number = 1 ... 100;
Value = P ... Q;
</pre>
<p>Subrange types can be created from a subset of an already defined enumerated type, For example &minus;</p>
<pre class="prettyprint notranslate">
type
months = (Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec);
Summer = Apr ... Aug;
Winter = Oct ... Dec;
</pre>
<h1>Pascal - Variable Types</h1>
<p>A variable is nothing but a name given to a storage area that our programs can manipulate. Each variable in Pascal has a specific type, which determines the size and layout of the variable's memory; the range of values that can be stored within that memory; and the set of operations that can be applied to the variable.</p>
<p>The name of a variable can be composed of letters, digits, and the underscore character. It must begin with either a letter or an underscore. Pascal is <b>not case-sensitive</b>, so uppercase and lowercase letters mean same here. Based on the basic types explained in previous chapter, there will be following basic variable types &minus;</p>
<h2>Basic Variables in Pascal</h2>
<table class="table table-bordered">
<tr>
<th style="width:25%;">Type</th>
<th>Description</th>
</tr>
<tr>
<td>Character</td>
<td>Typically a single octet (one byte). This is an integer type.</td>
</tr>
<tr>
<td>Integer</td>
<td>The most natural size of integer for the machine.</td>
</tr>
<tr>
<td>Real</td>
<td>A single-precision floating point value.</td>
</tr>
<tr>
<td>Boolean</td>
<td>Specifies true or false logical values. This is also an integer type.</td>
</tr>
<tr>
<td>Enumerated</td>
<td>Specifies a user-defined list.</td>
</tr>
<tr>
<td>Subrange</td>
<td>Represents variables, whose values lie within a range.</td>
</tr>
<tr>
<td>String</td>
<td>Stores an array of characters.</td>
</tr>
</table>
<p>Pascal programming language also allows defining various other types of variables, which we will cover in subsequent chapters like Pointer, Array, Records, Sets, and Files, etc. For this chapter, let us study only basic variable types.</p>
<h2>Variable Declaration in Pascal</h2>
<p>All variables must be declared before we use them in Pascal program. All variable declarations are followed by the <i>var</i> keyword. A declaration specifies a list of variables, followed by a colon (:) and the type. Syntax of variable declaration is &minus;</p>
<pre class="prettyprint notranslate">
var
variable_list : type;
</pre>
<p>Here, type must be a valid Pascal data type including character, integer, real, boolean, or any user-defined data type, etc., and variable_list may consist of one or more identifier names separated by commas. Some valid variable declarations are shown here &minus;</p>
<pre class="prettyprint notranslate">
var
age, weekdays : integer;
taxrate, net_income: real;
choice, isready: boolean;
initials, grade: char;
name, surname : string;
</pre>
<p>In the previous tutorial, we have discussed that Pascal allows declaring a type. A type can be identified by a name or identifier. This type can be used to define variables of that type. For example,</p>
<pre class="prettyprint notranslate">
type
days, age = integer;
yes, true = boolean;
name, city = string;
fees, expenses = real;
</pre>
<p>Now, the types so defined can be used in variable declarations &minus;</p>
<pre class="prettyprint notranslate">
var
weekdays, holidays : days;
choice: yes;
student_name, emp_name : name;
capital: city;
cost: expenses;
</pre>
<p>Please note the difference between <i>type</i> declaration and <i>var</i> declaration. Type declaration indicates the category or class of the types such as integer, real, etc., whereas the variable specification indicates the type of values a variable may take. You can compare <i>type</i> declaration in Pascal with <i>typedef</i> in C. Most importantly, the variable name refers to the memory location where the value of the variable is going to be stored. This is not so with the type declaration.</p>
<h2>Variable Initialization in Pascal</h2>
<p>Variables are assigned a value with a colon and the equal sign, followed by a constant expression. The general form of assigning a value is &minus;</p>
<pre class="prettyprint notranslate">
variable_name := value;
</pre>
<p>By default, variables in Pascal are not initialized with zero. They may contain rubbish values. So it is a better practice to initialize variables in a program. Variables can be initialized (assigned an initial value) in their declaration. The initialization is followed by the <b>var</b> keyword and the syntax of initialization is as follows &minus;</p> 
<pre class="prettyprint notranslate">
var
variable_name : type = value;
</pre>
<p>Some examples are &minus;</p>
<pre class="prettyprint notranslate">
age: integer = 15;
taxrate: real = 0.5;
grade: char = 'A';
name: string = 'John Smith';
</pre>
<p>Let us look at an example, which makes use of various types of variables discussed so far &minus;</p>
<pre class="prettyprint notranslate tryit">
program Greetings;
const
message = ' Welcome to the world of Pascal ';

type
name = string;
var
firstname, surname: name;

begin
   writeln('Please enter your first name: ');
   readln(firstname);
   
   writeln('Please enter your surname: ');
   readln(surname);
   
   writeln;
   writeln(message, ' ', firstname, ' ', surname);
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Please enter your first name:
John
Please enter your surname:
Smith
Welcome to the world of Pascal John Smith
</pre>
<h2>Enumerated Variables</h2>
<p>You have seen how to use simple variable types like integer, real and boolean. Now, let's see variables of enumerated type, which can be defined as &minus;</p>
<pre class="prettyprint notranslate">
var
var1, var2, ...  : enum-identifier;
</pre>
<p>When you have declared an enumerated type, you can declare variables of that type. For example,</p>
<pre class="prettyprint notranslate">
type
months = (January, February, March, April, May, June, July, August, September, October, November, December);
Var
m: months;
...
M := January;
</pre>
<p>The following example illustrates the concept &minus;</p>
<pre class="prettyprint notranslate tryit">
program exEnumeration;
type
beverage = (coffee, tea, milk, water, coke, limejuice);

var
drink:beverage;

begin
   writeln('Which drink do you want?');
   drink := limejuice;
   
   writeln('You can drink ', drink);
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Which drink do you want?
You can drink limejuice
</pre>
<h2>Subrange Variables</h2>
<p>Subrange variables are declared as &minus;</p>
<pre class="prettyprint notranslate">
var
subrange-name : lowerlim ... uperlim;
</pre>
<p>Examples of subrange variables are &minus;</p>
<pre class="prettyprint notranslate">
var
marks: 1 ... 100;
grade: 'A' ... 'E';
age: 1 ... 25;
</pre>
<p>The following program illustrates the concept &minus;</p>
<pre class="prettyprint notranslate tryit">
program exSubrange;
var
marks: 1 .. 100;
grade: 'A' .. 'E';

begin
   writeln( 'Enter your marks(1 - 100): ');
   readln(marks);
   
   writeln( 'Enter your grade(A - E): ');
   readln(grade);
   
   writeln('Marks: ' , marks, ' Grade: ', grade);
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Enter your marks(1 - 100): 
100
Enter your grade(A - E):
A
Marks: 100 Grade: A
</pre>
<h1>Pascal - Constants</h1>
<p>A constant is an entity that remains unchanged during program execution. Pascal allows only constants of the following types to be declared &minus;</p>
<ul class="list">
<li>Ordinal types</li>
<li>Set types</li>
<li>Pointer types (but the only allowed value is Nil).</li>
<li>Real types</li>
<li>Char</li>
<li>String</li>
</ul>
<h2>Declaring Constants</h2>
<p>Syntax for declaring constants is as follows &minus;</p>
<pre class="prettyprint notranslate">
const
identifier = constant_value;
</pre>
<p>The following table provides examples of some valid constant declarations &minus;</p>
<table class="table table-bordered">
<tr>
<th>Constant Type</th>
<th>Examples</th>
</tr>
<tr>
<td>Ordinal(Integer)type constant</td>
<td>valid_age = 21; </td>
</tr>
<tr>
<td>Set type constant</td>
<td>Vowels = set of (A,E,I,O,U);</td>
</tr>
<tr>
<td>Pointer type constant</td>
<td>P = NIL;</td>
</tr>
<tr>
<td>Real type constant</td>
<td><p>e = 2.7182818; 
<p>velocity_light = 3.0E+10;</p>
</td>
</tr>
<tr>
<td>Character type constant</td>
<td>Operator = '+';</td>
</tr>
<tr>
<td>String type constant</td>
<td>president = 'Johnny Depp';</td>
</tr>
</table>
<p>The following example illustrates the concept &minus;</p>
<pre class="prettyprint notranslate tryit">
program const_circle (input,output);
const
PI = 3.141592654;

var
r, d, c : real;   {variable declaration: radius, dia, circumference}

begin
   writeln('Enter the radius of the circle');
   readln(r);
   
   d := 2 * r;
   c :=  PI * d;
   writeln('The circumference of the circle is ',c:7:2);
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Enter the radius of the circle
23
The circumference of the circle is 144.51
</pre>
<p>Observe the formatting in the output statement of the program. The variable c is to be formatted with total number of digits 7 and 2 digits after the decimal sign. Pascal allows such output formatting with the numerical variables.</p>
<h1>Pascal - Operators</h1>
<p>An operator is a symbol that tells the compiler to perform specific mathematical or logical manipulations. Pascal allows the following types of operators &minus;</p>
<ul class="list">
<li>Arithmetic operators</li>
<li>Relational operators</li>
<li>Boolean operators</li>
<li>Bit operators</li>
<li>Set operators</li>
<li>String operators</li>
</ul>
<p>Let us discuss the arithmetic, relational, Boolean and bit operators one by one. We will discuss the set operators and string operations later.</p>
<h2>Arithmetic Operators</h2>
<p>Following table shows all the arithmetic operators supported by Pascal. Assume variable <b>A</b> holds 10 and variable <b>B</b> holds 20, then &minus;</p>
<p><a href="/pascal/pascal_arithmetic_operators.htm" title="Arithmetic Operators in Pascal">Show Examples</a></p>
<table class="table table-bordered">
<tr>
<th style="width:10%">Operator</th>
<th style="width:55%;">Description</th>
<th>Example</th>
</tr>
<tr>
<td>+</td>
<td>Adds two operands</td>
<td>A + B will give 30</td>
</tr>
<tr>
<td>-</td>
<td>Subtracts second operand from the first</td>
<td>A - B will give -10</td>
</tr>
<tr>
<td>*</td>
<td>Multiplies both operands</td>
<td>A * B will give 200</td>
</tr>
<tr>
<td>/</td>
<td>Divides numerator by denominator</td>
<td>B / A will give 2</td>
</tr>
<tr>
<td>%</td>
<td>Modulus Operator and remainder of after an integer division</td>
<td>B % A will give 0</td>
</tr>
</table>
<h2>Relational Operators</h2>
<p>Following table shows all the relational operators supported by Pascal. Assume variable <b>A</b> holds 10 and variable <b>B</b> holds 20, then &minus;</p>
<p><a href="/pascal/pascal_relational_operators.htm" title="Relational Operators in Pascal">Show Examples</a></p>
<table class="table table-bordered">
<tr>
<th style="width:10%">Operator</th>
<th style="width:55%;">Description</th>
<th>Example</th>
</tr>
<tr>
<td>=</td>
<td>Checks if the values of two operands are equal or not, if yes, then condition becomes true.</td>
<td>(A = B) is not true.</td>
</tr>
<tr>
<td>&lt;&gt;</td>
<td>Checks if the values of two operands are equal or not, if values are not equal, then condition becomes true.</td>
<td>(A &lt;&gt; B) is true.</td>
</tr>
<tr>
<td>&gt;</td>
<td>Checks if the value of left  operand is greater than the value of right operand, if yes, then condition becomes true.</td>
<td>(A &gt; B) is not true. </td>
</tr>
<tr>
<td>&lt;</td>
<td>Checks if the value of left  operand is less than the value of right operand, if yes, then condition becomes true.</td>
<td>(A &lt; B) is true. </td>
</tr>
<tr>
<td>&gt;=</td>
<td>Checks if the value of left  operand is greater than or equal to the value of right operand, if yes, then condition becomes true.</td>
<td>(A &gt;= B) is not true. </td>
</tr>
<tr>
<td>&lt;=</td>
<td>Checks if the value of left  operand is less than or equal to the value of right operand, if yes, then condition becomes true.</td>
<td>(A &lt;= B) is true. </td>
</tr>
</table>
<h2>Boolean Operators</h2>
<p>Following table shows all the Boolean operators supported by Pascal language. All these operators work on Boolean operands and produce Boolean results. Assume variable <b>A</b> holds true and variable <b>B</b> holds false, then &minus;</p>
<p><a href="/pascal/pascal_boolean_operators.htm" title="Boolean Operators in Pascal">Show Examples</a></p>
<table class="table table-bordered">
<tr>
<th style="width:10%">Operator</th>
<th style="width:55%">Description</th>
<th>Example</th>
</tr>
<tr>
<td>and</td>
<td>Called Boolean AND operator. If both the operands are true, then condition becomes true.</td>
<td>(A and B) is false.</td>
</tr>
<tr>
<td>and then</td>
<td>It is similar to the AND operator, however, it guarantees the order in which the compiler evaluates the logical expression. Left to right and the right operands are evaluated only when necessary.</td>
<td>(A and then B) is false.</td>
</tr>
<tr>
<td>or</td>
<td>Called Boolean OR Operator. If any of the two operands is true, then condition becomes true.</td>
<td>(A or B) is true.</td>
</tr>
<tr>
<td>or else</td>
<td>It is similar to Boolean OR, however,  it guarantees the order in which the compiler evaluates the logical expression. Left to right and the right operands are evaluated only when necessary.</td>
<td>(A or else B) is true.</td>
</tr>
<tr>
<td>not</td>
<td>Called Boolean NOT Operator. Used to reverse the logical state of its operand. If a condition is true, then Logical NOT operator will make it false.</td>
<td>not (A and B) is true.</td>
</tr>
</table>
<h2>Bit Operators</h2>
<p>Bitwise operators work on bits and perform bit-by-bit operation. All these operators work on integer operands and produces integer results. The truth table for bitwise and (&amp;), bitwise or (|), and bitwise not (~) are as follows &minus;</p>
<table class="table table-bordered">
<tr>
<th style="width:10%">p</th>
<th style="width:10%">q</th>
<th style="width:20%">p &amp; q</th>
<th style="width:20%">p | q</th>
<th style="width:20%">~p </th>
<th style="width:20%">~q </th>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
</table>
<p>Assume if A = 60; and B = 13; now in binary format they will be as follows &minus;</p>
<p>A = 0011 1100</p>
<p>B = 0000 1101</p>
<p>-----------------</p>
<p>A&amp;B = 0000 1100</p>
<p>A^B = 0011 0001</p>
<p>~A&nbsp; = 1100 0011</p>
<p>The Bitwise operators supported by Pascal are listed in the following table. Assume variable A holds 60 and variable B holds 13, then:</p>
<p><a href="/pascal/pascal_bit_operators.htm" title="Bit Operators in Pascal">Show Examples</a></p>
<table class="table table-bordered">
<tr>
<th style="width:10%">Operator</th>
<th style="width:55%;">Description</th>
<th>Example</th>
</tr>
<tr>
<td>&amp;</td>
<td>Binary AND Operator copies a bit to the result if it exists in both operands. </td>
<td>(A &amp; B) will give 12, which is 0000 1100</td>
</tr>
<tr>
<td>|</td>
<td>Binary OR Operator copies a bit if it exists in either operand. </td>
<td>(A | B) will give 61, which is 0011 1101</td>
</tr>
<tr>
<td>!</td>
<td>Binary OR Operator copies a bit if it exists in either operand.  Its same as | operator.</td><td> (A ! B) will give 61, which is 0011 1101</td>
</tr>
<tr>
<td>~</td>
<td>Binary Ones Complement Operator is unary and has the effect of 'flipping' bits. </td>
<td>(~A ) will give -61, which is 1100 0011 in 2's complement form due to a signed binary number.</td></tr>
<tr>
<td>&lt;&lt;</td>
<td>Binary Left Shift Operator. The left operands value is moved left by the number of bits specified by the right operand. </td>
<td>A &lt;&lt; 2 will give 240, which is 1111 0000</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>Binary Right Shift Operator. The left operands value is moved right by the number of bits specified by the right operand. </td>
<td>A &gt;&gt; 2 will give 15, which is 0000 1111</td>
</tr>
</table>
<p>Please note that different implementations of Pascal differ in bitwise operators. Free Pascal, the compiler we used here, however, supports the following bitwise operators &minus;</p>
<table class="table table-bordered">
<tr>
<th style="width:25%;">Operators</th>
<th>Operations</th>
</tr>
<tr>
<td>not</td>
<td>Bitwise NOT</td>
</tr>
<tr>
<td>and</td>
<td>Bitwise AND</td>
</tr>
<tr>
<td>or</td>
<td>Bitwise OR</td>
</tr>
<tr>
<td>xor</td>
<td>Bitwise exclusive OR</td>
</tr>
<tr>
<td>shl</td>
<td>Bitwise shift left</td>
</tr>
<tr>
<td>shr</td>
<td>Bitwise shift right</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>Bitwise shift left</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>Bitwise shift right</td>
</tr>
</table>
<h2>Operators Precedence in Pascal</h2>
<p>Operator precedence determines the grouping of terms in an expression. This affects how an expression is evaluated. Certain operators have higher precedence than others; for example, the multiplication operator has higher precedence than the addition operator.</p>
<p>For example x = 7 + 3 * 2; here, x is assigned 13, not 20 because operator * has higher precedence than +, so it first gets multiplied with 3*2 and then adds into 7.</p>
<p>Here, operators with the highest precedence appear at the top of the table, those with the lowest appear at the bottom. Within an expression, higher precedence operators will be evaluated first.</p> 
<p><a href="/pascal/pascal_operators_precedence.htm" title="Operators Precedence in Pascal">Show Examples</a></p>
<table class="table table-bordered">
<tr>
<th style="width:50%;">Operator</th>
<th>Precedence</th>
</tr>
<tr>
<td>~, not,</td>
<td>Highest</td>
</tr>
<tr>
<td>*, /, div, mod, and, &amp;</td>
<td></td>
</tr>
<tr>
<td>|, !, +, -, or,</td>
<td></td>
</tr>
<tr>
<td>=, &lt;&gt;, &lt;, &lt;=, &gt;, &gt;=, in</td>
<td></td>
</tr>
<tr>
<td>or else, and then</td>
<td>Lowest</td>
</tr>
</table>
<h1>Pascal - Decision Making</h1>
<p>Decision making structures require that the programmer specify one or more conditions to be evaluated or tested by the program, along with a statement or statements to be executed if the condition is determined to be true, and optionally, other statements to be executed if the condition is determined to be false.</p>
<p>Following is the general form of a typical decision making structure found in most of the programming languages &minus;</p>
<img src="/pascal/images/decision_making.jpg" alt="Decision making statements in Pascal" />
<p>Pascal programming language provides the following types of decision making statements. Click the following links to check their detail.</p>
<table class="table table-bordered">
<tr>
<th style="width:35%">Statement</th>
<th>Description</th>
</tr>
<tr>
<td><p><a href="/pascal/pascal_if_then_statement.htm" title="if then statement in Pascal">if - then statement</a></p></td>
<td>An <b>if - then statement</b> consists of a boolean expression followed by one or more statements.</td>
</tr>
<tr>
<td><p><a href="/pascal/pascal_if_then_else_statement.htm" title="if then else statement in Pascal">If-then-else statement</a></p></td>
<td>An <b>if - then statement</b> can be followed by an optional <b>else statement</b>, which executes when the boolean expression is false.</td>
</tr>
<tr>
<td><p><a href="/pascal/pascal_nested_if_statement.htm" title="nested if statements in Pascal">nested if statements</a></p></td>
<td>You can use one <b>if</b> or <b>else if</b> statement inside another <b>if</b> or <b>else if</b> statement(s).</td>
</tr>
<tr>
<td><p><a href="/pascal/pascal_case_statement.htm" title="case statement in Pascal">case statement</a></p></td>
<td>A <b>case</b> statement allows a variable to be tested for equality against a list of values.</td>
</tr>
<tr>
<td><p><a href="/pascal/pascal_case_else_statement.htm" title="case else statement in Pascal">case - else statement</a></p></td>
<td>It is similar to the <b>if-then-else </b>statement. Here, an <b>else</b> term follows the <b>case statement</b>.</td>
</tr>
<tr>
<td><p><a href="/pascal/pascal_nested_case_statement.htm" title="nested case statements in Pascal">nested case statements</a></p></td>
<td>You can use one <b>case</b> statement inside another <b>case</b> statement(s).</td>
</tr>
</table>
<h1>Pascal - Loops</h1>
<p>There may be a situation, when you need to execute a block of code several number of times. In general, statements are executed sequentially: The first statement in a function is executed first, followed by the second, and so on.</p>
<p>Programming languages provide various control structures that allow for more complicated execution paths.</p>
<p>A loop statement allows us to execute a statement or group of statements multiple times and following is the general form of a loop statement in most of the programming languages &minus;</p>
<img src="/pascal/images/loop_architecture.jpg" alt="Loop Architecture" />
<p>Pascal programming language provides the following types of loop constructs to handle looping requirements. Click the following links to check their details.</p>
<table class="table table-bordered">
<tr>
<th style="width:30%">Loop Type</th>
<th>Description</th>
</tr>
<tr>
<td><p><a href="/pascal/pascal_while_do_loop.htm" title="while-do loop in Pascal">while-do loop</a></p></td>
<td>Repeats a statement or group of statements while a given condition is true. It tests the condition before executing the loop body.</td>
</tr>
<tr>
<td><p><a href="/pascal/pascal_for_do_loop.htm" title="for loop in Pascal">for-do  loop</a></p></td>
<td>Executes a sequence of statements multiple times and abbreviates the code that manages the loop variable.</td>
</tr>
<tr>
<td><p><a href="/pascal/pascal_repeat_until_loop.htm" title="repeat-until loop in Pascal">repeat-until loop</a></p></td>
<td>Like a while statement, except that it tests the condition at the end of the loop body.</td>
</tr>
<tr>
<td><p><a href="/pascal/pascal_nested_loops.htm" title="nested loops in Pascal">nested loops</a></p></td>
<td>You can use one or more loop inside any another while, for or repeat until loop.</td></tr>
</table>
<h2>Loop Control Statements</h2>
<p>Loop control statements change execution from its normal sequence. When execution leaves a scope, all automatic objects that were created in that scope are destroyed.</p>
<p>Pascal supports the following control statements. Click the following links to check their details. </p>
<table class="table table-bordered">
<tr>
<th style="width:30%">Control Statement</th>
<th>Description</th>
</tr>
<tr>
<td><p><a href="/pascal/pascal_break_statement.htm" title="break statement in Pascal">break statement</a></p></td>
<td>Terminates the <b>loop</b> or <b>case</b> statement and transfers execution to the statement immediately following the loop or case statement.</td>
</tr>
<tr>
<td><p><a href="/pascal/pascal_continue_statement.htm" title="continue statement in Pascal">continue statement</a></p></td>
<td>Causes the loop to skip the remainder of its body and immediately retest its condition prior to reiterating.</td>
</tr>
<tr>
<td><p><a href="/pascal/pascal_goto_statement.htm" title="goto statement in Pascal">goto statement</a></p></td>
<td>Transfers control to the labeled statement. Though it is not advised to use goto statement in your program.</td>
</tr>
</table>
<h1>Pascal - Functions</h1>
<h2>Subprograms</h2>
<p>A subprogram is a program unit/module that performs a particular task. These subprograms are combined to form larger programs. This is basically called the 'Modular design.' A subprogram can be invoked by a subprogram/program, which is called the calling program.</p>
<p>Pascal provides two kinds of subprograms &minus;</p>
<ul class="list">
<li><p><b>Functions</b> &minus; these subprograms return a single value. </p></li>
<li><p><b>Procedures</b> &minus; these subprograms do not return a value directly.</p></li>
</ul>
<h2>Functions</h2>
<p>A <b>function</b> is a group of statements that together perform a task. Every Pascal program has at least one function, which is the program itself, and all the most trivial programs can define additional functions.</p>
<p>A function <b>declaration</b> tells the compiler about a function's name, return type, and parameters. A function <b>definition</b> provides the actual body of the function.</p>
<p>Pascal standard library provides numerous built-in functions that your program can call. For example, function <b>AppendStr()</b> appends two strings, function <b>New()</b> dynamically allocates memory to variables and many more functions.</p>
<h2>Defining a Function</h2>
<p>In Pascal, a <b>function</b> is defined using the function keyword. The general form of a function definition is as follows &minus;</p>
<pre class="prettyprint notranslate">
function name(argument(s): type1; argument(s): type2; ...): function_type;
local declarations;

begin
   ...
   &lt; statements &gt;
   ...
   name:= expression;
end;
</pre>
<p>A function definition in Pascal consists of a function <b>header</b>, local <b>declarations</b> and a function <b>body</b>. The function header consists of the keyword function and a <b>name</b> given to the function. Here are all the parts of a function &minus;</p>
<ul class="list">
<li><p><b>Arguments</b> &minus; The argument(s) establish the linkage between the calling program and the function identifiers and also called the formal parameters. A parameter is like a placeholder. When a function is invoked, you pass a value to the parameter. This value is referred to as actual parameter or argument. The parameter list refers to the type, order, and number of parameters of a function. Use of such formal parameters is optional. These parameters may have standard data type, user-defined data type or subrange data type.</p> 
<p>The formal parameters list appearing in the function statement could be simple or subscripted variables, arrays or structured variables, or subprograms.</p></li>
<li><p><b>Return Type</b> &minus; All functions must return a value, so all functions must be assigned a type. The <b>function-type</b> is the data type of the value the function returns. It may be standard, user-defined scalar or subrange type but it cannot be structured type.</p></li>
<li><p><b>Local declarations</b> &minus; Local declarations refer to the declarations for labels, constants, variables, functions and procedures, which are application to the body of function only.</p></li>
<li><p><b>Function Body</b> &minus; The function body contains a collection of statements that define what the function does. It should always be enclosed between the reserved words begin and end.  It is the part of a function where all computations are done. There must be an assignment statement of the type - <b>name := expression;</b> in the function body that assigns a value to the function name. This value is returned as and when the function is executed. The last statement in the body must be an end statement.</p></li>
</ul>
<p>Following is an example showing how to define a function in pascal &minus;</p>
<pre class="prettyprint notranslate">
(* function returning the max between two numbers *)
function max(num1, num2: integer): integer;

var
   (* local variable declaration *)
   result: integer;

begin
   if (num1 &gt; num2) then
      result := num1
   
   else
      result := num2;
   max := result;
end;
</pre>
<h2>Function Declarations</h2>
<p>A function <b>declaration</b> tells the compiler about a function name and how to call the function. The actual body of the function can be defined separately.</p>
<p>A function declaration has the following parts &minus;</p>
<pre class="prettyprint notranslate">
function name(argument(s): type1; argument(s): type2; ...): function_type;
</pre>
<p>For the above-defined function max(), following is the function declaration &minus;</p>
<pre class="prettyprint notranslate">
function max(num1, num2: integer): integer;
</pre>
<p>Function declaration is required when you define a function in one source file and you call that function in another file. In such case, you should declare the function at the top of the file calling the function.</p>
<h2>Calling a Function</h2>
<p>While creating a function, you give a definition of what the function has to do. To use a function, you will have to call that function to perform the defined task. When a program calls a function, program control is transferred to the called function. A called function performs defined task, and when its return statement is executed or when it last end statement is reached, it returns program control back to the main program.</p>
<p>To call a function, you simply need to pass the required parameters along with function name, and if function returns a value, then you can store returned value. Following is a simple example to show the usage &minus;</p>
<pre class="prettyprint notranslate tryit">
program exFunction;
var
   a, b, ret : integer;

(*function definition *)
function max(num1, num2: integer): integer;
var
   (* local variable declaration *)
   result: integer;

begin
   if (num1 &gt; num2) then
      result := num1
   
   else
      result := num2;
   max := result;
end;

begin
   a := 100;
   b := 200;
   (* calling a function to get max value *)
   ret := max(a, b);
   
   writeln( 'Max value is : ', ret );
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Max value is : 200 
</pre>
<h1>Pascal - Procedures</h1>
<p><b>Procedures </b>are subprograms that, instead of returning a single value, allow to obtain a group of results.</p>
<h2>Defining a Procedure</h2>
<p>In Pascal, a procedure is defined using the <b>procedure</b> keyword. The general form of a procedure definition is as follows &minus;</p>
<pre class="prettyprint notranslate">
procedure name(argument(s): type1, argument(s): type 2, ... );
   &lt; local declarations &gt;
begin
   &lt; procedure body &gt;
end;
</pre>
<p>A procedure <b>definition</b> in Pascal consists of a <b>header</b>, local <b>declarations</b> and a <b>body</b> of the procedure. The procedure header consists of the keyword <b>procedure</b> and a name given to the procedure. Here are all the parts of a procedure &minus;</p>
<ul class="list">
<li><p><b>Arguments</b> &minus; The argument(s) establish the linkage between the calling program and the procedure identifiers and also called the formal parameters. Rules for arguments in procedures are same as that for the functions.</p></li>
<li><p><b>Local declarations</b> &minus; Local declarations refer to the declarations for labels, constants, variables, functions and procedures, which are applicable to the body of the procedure only.</p></li>
<li><p><b>Procedure Body</b> &minus; The procedure body contains a collection of statements that define what the procedure does. It should always be enclosed between the reserved words begin and end. It is the part of a procedure where all computations are done.</p></li>
</ul>
<p>Following is the source code for a procedure called <i>findMin()</i>. This procedure takes 4 parameters x, y, z and m and stores the minimum among the first three variables in the variable named m. The variable m is passed by <b>reference</b> (we will discuss passing arguments by reference a little later) &minus;</p>
<pre class="prettyprint notranslate">
procedure findMin(x, y, z: integer; var m: integer); 
(* Finds the minimum of the 3 values *)

begin
   if x &lt; y then
      m := x
   else
      m := y;
   
   if z &lt;m then
      m := z;
end; { end of procedure findMin }  
</pre>
<h2>Procedure Declarations</h2>
<p>A procedure <b>declaration</b> tells the compiler about a procedure name and how to call the procedure. The actual body of the procedure can be defined separately.</p>
<p>A procedure declaration has the following syntax &minus;</p>
<pre class="prettyprint notranslate">
procedure name(argument(s): type1, argument(s): type 2, ... );
</pre>
<p>Please note that the <b>name of the procedure is not associated with any type</b>. For the above defined procedure <i>findMin()</i>, following is the declaration &minus;</p>
<pre class="prettyprint notranslate">
procedure findMin(x, y, z: integer; var m: integer);
</pre>
<h2>Calling a Procedure</h2>
<p>While creating a procedure, you give a definition of what the procedure has to do. To use the procedure, you will have to call that procedure to perform the defined task. When a program calls a procedure, program control is transferred to the called procedure. A called procedure performs the defined task, and when its last end statement is reached, it returns the control back to the calling program.</p>
<p>To call a procedure, you simply need to pass the required parameters along with the procedure name as shown below &minus;</p>
<pre class="prettyprint notranslate tryit">
program exProcedure;
var
   a, b, c,  min: integer;
procedure findMin(x, y, z: integer; var m: integer); 
(* Finds the minimum of the 3 values *)

begin
   if x &lt; y then
      m:= x
   else
      m:= y;
   
   if z &lt; m then
      m:= z;
end; { end of procedure findMin }  

begin
   writeln(' Enter three numbers: ');
   readln( a, b, c);
   findMin(a, b, c, min); (* Procedure call *)
   
   writeln(' Minimum: ', min);
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Enter three numbers:
89 45 67
Minimum: 45
</pre>
<h2>Recursive Subprograms</h2>
<p>We have seen that a program or subprogram may call another subprogram. When a subprogram calls itself, it is referred to as a recursive call and the process is known as recursion.</p>
<p>To illustrate the concept, let us calculate the factorial of a number. Factorial of a number n is defined as &minus;</p>
<pre class="prettyprint notranslate">
n! = n*(n-1)!
   = n*(n-1)*(n-2)!
      ...
   = n*(n-1)*(n-2)*(n-3)... 1
</pre>
<p>The following program calculates the factorial of a given number by calling itself recursively.</p>
<pre class="prettyprint notranslate tryit">
program exRecursion;
var
   num, f: integer;
function fact(x: integer): integer; (* calculates factorial of x - x! *)

begin
   if x=0 then
      fact := 1
   else
      fact := x * fact(x-1); (* recursive call *)
end; { end of function fact}

begin
   writeln(' Enter a number: ');
   readln(num);
   f := fact(num);
   
   writeln(' Factorial ', num, ' is: ' , f);
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Enter a number:
5
Factorial 5 is: 120
</pre>
<p>Following is another example, which generates the <b>Fibonacci Series</b> for a given number using a <b>recursive</b> function &minus;</p>
<pre class="prettyprint notranslate tryit">
program recursiveFibonacci;
var
   i: integer;
function fibonacci(n: integer): integer;

begin
   if n=1 then
      fibonacci := 0
   
   else if n=2 then
      fibonacci := 1
   
   else
      fibonacci := fibonacci(n-1) + fibonacci(n-2);
end; 

begin
   for i:= 1 to 10 do
   
   write(fibonacci (i), '  ');
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
0 1 1 2	3 5 8 13 21 34
</pre>
<h2>Arguments of a Subprogram</h2>
<p>If a subprogram (<b>function or procedure</b>) is to use arguments, it must declare variables that accept the values of the arguments. These variables are called the <b>formal parameters</b> of the subprogram.</p>
<p>The formal parameters behave like other local variables inside the subprogram and are created upon entry into the subprogram and destroyed upon exit.</p>
<p>While calling a subprogram, there are two ways that arguments can be passed to the subprogram &minus;</p>
<table class="table table-bordered">
<tr>
<th style = "width:30%">Call Type</th>
<th>Description</th>
</tr>
<tr>
<td><p><a href="/pascal/pascal_call_by_value.htm" title="Subprogram call by value in Pascal">Call by value</a></p></td><td>This method copies the actual value of an argument into the formal parameter of the subprogram. In this case, changes made to the parameter inside the subprogram have no effect on the argument.</td> 
</tr>
<tr>
<td><p><a href="/pascal/pascal_call_by_reference.htm" title="Subprogram call by reference in Pascal">Call by reference</a></p></td><td>This method copies the address of an argument into the formal parameter. Inside the subprogram, the address is used to access the actual argument used in the call. This means that changes made to the parameter affect the argument.</td> 
</tr>
</table>
<p>By default, Pascal uses <b>call by value</b> to pass arguments. In general, this means that code within a subprogram cannot alter the arguments used to call the subprogram. The example program we used in the chapter 'Pascal - Functions' called the function named max() using <b>call by value</b>.</p>
<p>Whereas, the example program provided here (<i>exProcedure</i>) calls the procedure findMin() using <b>call by reference</b>.</p>
<h1>Pascal - Variable Scope</h1>
<p>A scope in any programming is a region of the program where a defined variable can have its existence and beyond that variable cannot be accessed. There are three places, where variables can be declared in Pascal programming language &minus;</p>
<ul class="list">
<li><p>Inside a subprogram or a block which is called local variables</p></li>
<li><p>Outside of all subprograms which is called global variables</p></li>
<li><p>In the definition of subprogram parameters which is called formal parameters</p></li>
</ul>
<p>Let us explain what are <b>local</b> and <b>global</b> variables and formal parameters.</p>
<h2>Local Variables</h2>
<p>Variables that are declared inside a subprogram or block are called local variables. They can be used only by statements that are inside that  subprogram or block of code. Local variables are not known to subprograms outside their own. Following is the example using local variables. Here, all the variables <i>a</i>, <i>b</i> and <i>c</i> are local to program named <i>exLocal</i>.</p>
<pre class="prettyprint notranslate tryit">
program exLocal; 
var
   a, b, c: integer;

begin
   (* actual initialization *)
   a := 10;
   b := 20;
   c := a + b;
   
   writeln('value of a = ', a , ' b =  ',  b, ' and c = ', c);
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
value of a = 10 b = 20 c = 30
</pre>
<p>Now, let us extend the program little more, let us create a procedure named display, which will have its own set of variables <i>a</i>, <i>b</i> and <i>c</i> and display their values, right from the program <i>exLocal</i>.</p>
<pre class="prettyprint notranslate tryit">
program exLocal;
var
   a, b, c: integer;
procedure display;

var
   a, b, c: integer;
begin
   (* local variables *)
   a := 10;
   b := 20;
   c := a + b;
   
   writeln('Winthin the procedure display');
   writeln('value of a = ', a , ' b =  ',  b, ' and c = ', c);
end;

begin
   a:= 100;
   b:= 200;
   c:= a + b;
   
   writeln('Winthin the program exlocal');
   writeln('value of a = ', a , ' b =  ',  b, ' and c = ', c);
   display();
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Within the program exlocal
value of a = 100 b = 200 c = 300
Within the procedure display
value of a = 10 b = 20 c = 30
</pre>
<h2>Global Variables</h2>
<p>Global variables are defined outside of a function, usually on top of the program. The global variables will hold their value throughout the lifetime of your program and they can be accessed inside any of the functions defined for the program.</p>
<p>A <b>global</b> variable can be accessed by any function. That is, a global variable is available for use throughout your entire program after its declaration. Following is an example using <b>global</b> and <b>local</b> variables &minus;</p>
<pre class="prettyprint notranslate tryit">
program exGlobal;
var
   a, b, c: integer;
procedure display;
var
   x, y, z: integer;

begin
   (* local variables *)
   x := 10;
   y := 20;
   z := x + y;
   
   (*global variables *)
   a := 30;
   b:= 40;
   c:= a + b;
   
   writeln('Winthin the procedure display');
   writeln(' Displaying the global variables a, b, and c');
   
   writeln('value of a = ', a , ' b =  ',  b, ' and c = ', c);
   writeln('Displaying the local variables x, y, and z');
   
   writeln('value of x = ', x , ' y =  ',  y, ' and z = ', z);
end;

begin
   a:= 100;
   b:= 200;
   c:= 300;
   
   writeln('Winthin the program exlocal');
   writeln('value of a = ', a , ' b =  ',  b, ' and c = ', c);
   
   display();
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Within the program exlocal
value of a = 100 b = 200 c = 300
Within the procedure display
Displaying the global variables a, b, and c
value of a = 30 b = 40 c = 70
Displaying the local variables x, y, and z
value of x = 10 y = 20 z = 30
</pre>
<p>Please note that the procedure display has access to the variables a, b and c, which are global variables with respect to display as well as its own local variables. A program can have same name for local and global variables but value of local variable inside a function will take preference.</p>
<p>Let us change the previous example a little, now the local variables for the procedure display has same names as <i>a</i>, <i>b</i>, <i>c</i> &minus;</p>
<pre class="prettyprint notranslate tryit">
program exGlobal;
var
   a, b, c: integer;
procedure display;

var
   a, b, c: integer;

begin
   (* local variables *)
   a := 10;
   b := 20;
   c := a + b;
   
   writeln('Winthin the procedure display');
   writeln(' Displaying the global variables a, b, and c');
   
   writeln('value of a = ', a , ' b =  ',  b, ' and c = ', c);
   writeln('Displaying the local variables a, b, and c');
   
   writeln('value of a = ', a , ' b =  ',  b, ' and c = ', c);
end;

begin
   a:= 100;
   b:= 200;
   c:= 300;
   
   writeln('Winthin the program exlocal');
   writeln('value of a = ', a , ' b =  ',  b, ' and c = ', c);   
   
   display();
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Within the program exlocal
value of a = 100 b = 200 c = 300
Within the procedure display
Displaying the global variables a, b, and c
value of a = 10 b = 20 c = 30
Displaying the local variables a, b, and c
value of a = 10 b = 20 c = 30
</pre>
<h1>Pascal - Strings</h1>
<p>The string in Pascal is actually a sequence of characters with an optional size specification. The characters could be numeric, letters, blank, special characters or a combination of all. Extended Pascal provides numerous types of string objects depending upon the system and implementation. We will discuss more common types of strings used in programs.</p>
<p>You can define a string in many ways &minus;</p>
<ul class="list">
<li><p><b>Character arrays</b> &minus; This is a  character string which is a sequence of zero or more byte-sized characters  enclosed in single quotes.</p></li>
<li><p><b>String variables</b> &minus; The variable of String type, as defined in Turbo Pascal.</p></li>
<li><p><b>Short strings</b> &minus; The variable of String type with size specification.</p></li>
<li><p><b>Null terminated strings</b> &minus; The variable of <b>pchar</b> type.</p></li>
<li><p><b>AnsiStrings</b> &minus; Ansistrings are strings that have no length limit.</p></li>
</ul>
<p>Pascal provides only one string operator, string concatenation operator (+).</p>
<h3>Examples</h3>
<p>The following program prints first four kinds of strings. We will use AnsiStrings in the next example.</p>
<pre class="prettyprint notranslate tryit">
program exString;
var
   greetings: string;
   name: packed array [1..10] of char;
   organisation: string[10];
   message: pchar;

begin
   greetings := 'Hello ';
   message := 'Good Day!';
   
   writeln('Please Enter your Name');
   readln(name);
   
   writeln('Please Enter the name of your Organisation');
   readln(organisation);
   
   writeln(greetings, name, ' from ', organisation);
   writeln(message); 
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Please Enter your Name
John Smith
Please Enter the name of your Organisation
Infotech
Hello John Smith from Infotech
</pre>
<p>Following example makes use of few more functions, let's see &minus;</p>
<pre class="prettyprint notranslate tryit">
program exString;
uses sysutils;
var
   str1, str2, str3 : ansistring;
   str4: string;
   len: integer;

begin
   str1 := 'Hello ';
   str2 := 'There!';
   
   (* copy str1 into str3 *)
   str3 := str1;
   writeln('appendstr( str3, str1) :  ', str3 );
   
   (* concatenates str1 and str2 *)
   appendstr( str1, str2);
   writeln( 'appendstr( str1, str2) ' , str1 );
   str4 := str1 + str2;
   writeln('Now str4 is: ', str4);
   
   (* total lenghth of str4 after concatenation  *)
   len := byte(str4[0]);
   writeln('Length of the final string str4: ', len); 
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
appendstr( str3, str1) : Hello
appendstr( str1, str2) : Hello There!
Now str4 is: Hello There! There!
Length of the final string str4: 18
</pre>
<h2>Pascal String Functions and Procedures </h2>
<p>Pascal supports a wide range of functions and procedures that manipulate strings. These subprograms vary implement-wise. Here, we are listing various string manipulating subprograms provided by Free Pascal &minus;</p>
<table class="table table-bordered">
<tr>
<th style="width:5%">Sr.No.</th>
<th>Function &amp; Purpose</th>
</tr>
<tr>
<td>1</td>
<td>
<p><b>function AnsiCompareStr(const S1: ; const S2:):Integer; </b></p> 
<p>Compares two strings</p>
</td>
</tr>
<tr>
<td>2</td>
<td>
<p><b>function AnsiCompareText(const S1: ; const S2:):Integer;</b></p> 
<p>Compares two strings, case insensitive</p>
</td>
</tr>
<tr>
<td>3</td>
<td>
<p><b>function AnsiExtractQuotedStr(var Src: PChar; Quote: Char):;</b></p> 
<p>Removes quotes from string</p>
</td>
</tr>
<tr>
<td>4</td>
<td>
<p><b>function AnsiLastChar(const S:):PChar;</b></p>
<p>Gets last character of string</p>
</td>
</tr>
<tr>
<td>5</td>
<td>
<p><b>function AnsiLowerCase(const s:):</b></p>
<p>Converts string to all-lowercase</p>
</td>
</tr>
<tr>
<td>6</td>
<td>
<p><b>function AnsiQuotedStr(const S: ; Quote: Char):;</b></p> 
<p>Quotes a string</p>
</td>
</tr>
<tr>
<td>7</td>
<td>
<p><b>function AnsiStrComp(S1: PChar;S2: PChar):Integer;</b></p> 
<p>Compares strings case-sensitive</p>
</td>
</tr>
<tr>
<td>8</td>
<td>
<p><b>function AnsiStrIComp(S1: PChar; S2: PChar):Integer;</b></p> 
<p>Compares strings case-insensitive</p>
</td>
</tr>
<tr>
<td>9</td>
<td>
<p><b>function AnsiStrLComp(S1: PChar; S2: PChar; MaxLen: Cardinal):Integer;</b></p> 
<p>Compares L characters of strings case sensitive</p>
</td>
</tr>
<tr>
<td>10</td>
<td>
<p><b>function AnsiStrLIComp(S1: PChar; S2: PChar; MaxLen: Cardinal):Integer;</b></p> 
<p>Compares L characters of strings case insensitive</p>
</td>
</tr>
<tr>
<td>11</td>
<td>
<p><b>function AnsiStrLastChar(Str: PChar):PChar;</b></p> 
<p>Gets last character of string</p>
</td>
</tr>
<tr>
<td>12</td>
<td>
<p><b>function AnsiStrLower(Str: PChar):PChar;</b></p> 
<p>Converts string to all-lowercase</p>
</td>
</tr>
<tr>
<td>13</td>
<td>
<p><b>function AnsiStrUpper(Str: PChar):PChar;</b></p> 
<p>Converts string to all-uppercase</p>
</td>
</tr>
<tr>
<td>14</td>
<td>
<p><b>function AnsiUpperCase(const s:):;</b></p> 
<p>Converts string to all-uppercase</p>
</td>
</tr>
<tr>
<td>15</td>
<td>
<p><b>procedure AppendStr(var Dest: ; const S:);</b></p> 
<p>Appends 2 strings</p>
</td>
</tr>
<tr>
<td>16</td>
<td>
<p><b>procedure AssignStr(var P: PString; const S:);</b></p> 
<p>Assigns value of strings on heap</p>
</td>
</tr>
<tr>
<td>17</td>
<td>
<p><b>function CompareStr(const S1: ; const S2:):Integer; overload;</b></p> 
<p>Compares two strings case sensitive</p>
</td>
</tr>
<tr>
<td>18</td>
<td>
<p><b>function CompareText(const S1: ; const S2:):Integer;</b></p> 
<p>Compares two strings case insensitive</p>
</td>
</tr>
<tr>
<td>19</td>
<td>
<b>procedure DisposeStr(S: PString); overload;</b> 
<p>Removes string from heap</td>
</tr>
<tr>
<td>20</td>
<td>
<p><b>procedure DisposeStr(S: PShortString); overload;</b></p> 
<p>Removes string from heap</p>
</td>
</tr>
<tr>
<td>21</td>
<td>
<p><b>function IsValidIdent( const Ident:):Boolean;</b></p> 
<p>Is string a valid pascal identifier</p>
</td>
</tr>
<tr>
<td>22</td>
<td>
<p><b>function LastDelimiter(const Delimiters: ; const S:):Integer;</b></p> 
<p>Last occurrence of character in a string</p>
</td>
</tr>
<tr>
<td>23</td>
<td>
<p><b>function LeftStr(const S: ; Count: Integer):;</b></p>
<p>Gets first N characters of a string</p>
</td>
</tr>
<tr>
<td>24</td>
<td>
<p><b>function LoadStr(Ident: Integer):; </b></p> 
<p>Loads string from resources</p>
</td>
</tr>
<tr>
<td>25</td>
<td>
<p><b>function LowerCase(const s: ):; overload; </b></p> 
<p>Converts string to all-lowercase</p>
</td>
</tr>
<tr>
<td>26</td>
<td>
<p><b>function LowerCase(const V: variant ):; overload; </b></p> 
<p>Converts string to all-lowercase</p>
</td>
</tr>
<tr>
<td>27</td>
<td>
<p><b>function NewStr(const S:):PString; overload;</b></p> 
<p>Allocates new string on heap</p>
</td>
</tr>
<tr>
<td>28</td>
<td>
<p><b>function RightStr(const S: ; Count: Integer):;</b></p> 
<p>Gets last N characters of a string</p>
</td>
</tr>
<tr>
<td>29</td>
<td>
<p><b>function StrAlloc(Size: Cardinal):PChar;</b></p> 
<p>Allocates memory for string</p>
</td>
</tr>
<tr>
<td>30</td>
<td>
<p><b>function StrBufSize(Str: PChar):SizeUInt;</b></p> 
<p>Reserves memory for a string</p>
</td>
</tr>
<tr>
<td>31</td>
<td>
<p><b>procedure StrDispose(Str: PChar);</b></p> 
<p>Removes string from heap</p>
</td>
</tr>
<tr>
<td>32</td>
<td>
<p><b>function StrPas(Str: PChar):; </b></p> 
<p>Converts PChar to pascal string</p>
</td>
</tr>
<tr>
<td>33</td>
<td>
<p><b>function StrPCopy(Dest: PChar; Source:):PChar;</b></p> 
<p>Copies pascal string</p>
</td>
</tr>
<tr>
<td>34</td>
<td>
<p><b>function StrPLCopy(Dest: PChar; Source: ; MaxLen: SizeUInt):PChar;</b></p> 
<p>Copies N bytes of pascal string</p>
</td>
</tr>
<tr>
<td>35</td>
<td>
<p><b>function UpperCase(const s:):;</b></p> 
<p>Converts string to all-uppercase</p>
</td>
</tr>
</table>
<h1>Pascal - Booleans</h1>
<p>Pascal provides data type Boolean that enables the programmers to define, store and manipulate logical entities, such as constants, variables, functions and expressions, etc.</p>
<p>Boolean values are basically integer type. Boolean type variables have two pre-defined possible values <b>True</b> and <b>False</b>. The expressions resolving to a Boolean value can also be assigned to a Boolean type.</p>
<p>Free Pascal also supports the <b>ByteBool</b>, <b>WordBool</b> and <b>LongBool</b> types. These are of type Byte, Word or Longint, respectively.</p>
<p>The value False is equivalent to 0 (zero) and any nonzero value is considered True when converting to a Boolean value.  A Boolean value of True is converted to -1 in case it is assigned to a variable of type LongBool.</p>
<p>It should be noted that logical operators <b>and</b>, <b>or</b> and <b>not</b> are defined for Boolean data types.</p>
<h2>Declaration of Boolean Data Types</h2>
<p> A variable of Boolean type is declared using the var keyword.</p>
<pre class="prettyprint notranslate">
var
boolean-identifier: boolean;
</pre>
<p>for example,</p>
<pre class="prettyprint notranslate">
var
choice: boolean;
</pre>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
program exBoolean;
var
exit: boolean;

choice: char;
   begin
   writeln('Do you want to continue? ');
   writeln('Enter Y/y for yes, and N/n for no');
   readln(choice);

if(choice = 'n') then
   exit := true
else
   exit := false;

if (exit) then
   writeln(' Good Bye!')
else
   writeln('Please Continue');

readln;
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Do you want to continue?
Enter Y/y for yes, and N/n for no
N
Good Bye!
Y
Please Continue
</pre>
<h1>Pascal - Arrays</h1>
<p>Pascal programming language provides a data structure called the array, which can store a fixed-size sequential collection of elements of the same type. An array is used to store a collection of data, but it is often more useful to think of an array as a collection of variables of the same type.</p>
<p>Instead of declaring individual variables, such as number1, number2, ..., and number100, you declare one array variable such as numbers and use numbers[1], numbers[2], and ..., numbers[100] to represent individual variables. A specific element in an array is accessed by an index.</p>
<p>All arrays consist of contiguous memory locations. The lowest address corresponds to the first element and the highest address to the last element.</p>
<p>Please note that if you want a C style array starting from index 0, you just need to start the index from 0, instead of 1.</p>
<img src="/pascal/images/arrays.jpg" alt="Arrays in Pascal" />
<h2>Declaring Arrays</h2>
<p>To declare an array in Pascal, a programmer may either declare the type and then create variables of that array or directly declare the array variable.</p>
<p>The general form of type declaration of one-dimensional array is &minus;</p>
<pre class="prettyprint notranslate">
type
   array-identifier = array[index-type] of element-type;
</pre>
<p>Where,</p>
<ul class="list">
<li><p><b>array-identifier</b> &minus; indicates the name of the array type.</p></li>
<li><p><b>index-type</b> &minus; specifies the subscript of the array; it can be any scalar data type except real</p></li>
<li><p><b>element-type</b> &minus; specifies the types of values that are going to be stored</p></li>
</ul>
<p>For example,</p>
<pre class="prettyprint notranslate">
type
   vector = array [ 1..25] of real;
var
   velocity: vector;
</pre>
<p>Now, velocity is a variable array of vector type, which is sufficient to hold up to 25 real numbers.</p>
<p>To start the array from 0 index, the declaration would be &minus;</p>
<pre class="prettyprint notranslate">
type
   vector = array [ 0..24] of real;
var
   velocity: vector;
</pre>
<h2>Types of Array Subscript</h2>
<p>In Pascal, an array subscript could be of any scalar type like, integer, Boolean, enumerated or subrange, except real. Array subscripts could have negative values too.</p>
<p>For example,</p>
<pre class="prettyprint notranslate">
type
   temperature = array [-10 .. 50] of real;
var
   day_temp, night_temp: temperature;
</pre>
<p>Let us take up another example where the subscript is of character type &minus;</p>
<pre class="prettyprint notranslate">
type
   ch_array = array[char] of 1..26;
var
   alphabet: ch_array;
</pre>
<p>Subscript could be of enumerated type &minus;</p>
<pre class="prettyprint notranslate">
type
   color = ( red, black, blue, silver, beige);
   car_color = array of [color] of boolean;
var
   car_body: car_color;
</pre>
<h2>Initializing Arrays</h2>
<p>In Pascal, arrays are initialized through assignment, either by specifying a particular subscript or using a for-do loop.</p>
<p>For example &minus;</p>
<pre class="prettyprint notranslate">
type
   ch_array = array[char] of 1..26;
var
   alphabet: ch_array;
   c: char;

begin
   ...
   for c:= 'A' to 'Z' do
   alphabet[c] := ord[m];  
   (* the ord() function returns the ordinal values *)
</pre>
<h2>Accessing Array Elements</h2>
<p>An element is accessed by indexing the array name. This is done by placing the index of the element within square brackets after the name of the array. For example &minus;</p>
<pre class="prettyprint notranslate">
a: integer;
a: = alphabet['A'];
</pre>
<p>The above statement will take the first element from the array named alphabet and assign the value to the variable a.</p>
<p>Following is an example, which will use all the above-mentioned three concepts viz. declaration, assignment and accessing arrays &minus;</p>
<pre class="prettyprint notranslate tryit">
program exArrays;
var
   n: array [1..10] of integer;   (* n is an array of 10 integers *)
   i, j: integer;

begin
   (* initialize elements of array n to 0 *)        
   for i := 1 to 10 do
       n[ i ] := i + 100;   (* set element at location i to i + 100 *)
    (* output each array element's value *)
   
   for j:= 1 to 10 do
      writeln('Element[', j, '] = ', n[j] );
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Element[1] = 101
Element[2] = 102
Element[3] = 103
Element[4] = 104
Element[5] = 105
Element[6] = 106
Element[7] = 107
Element[8] = 108
Element[9] = 109
Element[10] = 110
</pre>
<h2>Pascal Arrays in Detail</h2>
<p>Arrays are important to Pascal and should need lots of more details. There are following few important concepts related to array which should be clear to a Pascal programmer &minus;</p>
<table class="table table-bordered">
<tr>
<th style="width:40%">Concept</th>
<th>Description</th>
</tr>
<tr>
<td><p><a href="/pascal/pascal_multi_dimensional_arrays.htm" title="Multi-dimensional arrays in Pascal">Multi-dimensional arrays</a></p></td>
<td>Pascal supports multidimensional arrays. The simplest form of the multidimensional array is the two-dimensional array.</td> 
</tr>
<tr>
<td><p><a href="/pascal/pascal_dynamic_arrays.htm" title="Dynamic Arrays in Pascal">Dynamic array</a></p></td>
<td>In this type of arrays, the initial length is zero. The actual length of the array must be set with the standard <b>SetLength</b> function.</td> 
</tr>
<tr>
<td><p><a href="/pascal/pascal_packed_array.htm" title="Packed Array in Pascal">Packed array</a></p></td>
<td>These arrays are bit-packed, i.e., each character or truth values are stored in consecutive bytes instead of using one storage unit, usually a word (4 bytes or more).</td> 
</tr>
<tr>
<td><p><a href="/pascal/pascal_passing_arrays_to_subprograms.htm" title="Passing arrays to subprogram as arguments in Pascal">Passing arrays to subprograms</a></p></td>
<td>You can pass to a subprogram a pointer to an array by specifying the array's name without an index.</td> 
</tr>
</table>
<h1>Pascal - Pointers</h1>
<p>Pointers in Pascal are easy and fun to learn. Some Pascal programming tasks are performed more easily with pointers, and other tasks, such as dynamic memory allocation, cannot be performed without using pointers. So it becomes necessary to learn pointers to become a perfect  Pascal programmer. Let's start learning them in simple and easy steps.</p>
<p>As you know, every variable is a memory location and every memory location has its address defined which can be accessed using the name of the pointer variable, which denotes an address in memory.</p>
<h2>What Are Pointers?</h2>
<p>A pointer is a dynamic variable, whose value is the address of another variable, i.e., direct address of the memory location. Like any variable or constant, you must declare a pointer before you can use it to store any variable address.  The general form of a pointer variable declaration is &minus;</p>
<pre class="prettyprint notranslate">
type
   ptr-identifier = ^base-variable-type;
</pre>
<p>The pointer type is defined by prefixing the up-arrow of caret symbol (^) with the base type.  The base-type defines the types of the data items. Once a pointer variable is defined to be of certain type, it can point data items of that type only. Once a pointer type has been defined, we can use the <b>var</b> declaration to declare pointer variables.</p>
<pre class="prettyprint notranslate">
var
   p1, p2, ... : ptr-identifier;
</pre>
<p>Following are some valid pointer declarations &minus;</p>
<pre class="prettyprint notranslate">
type
   Rptr = ^real;
   Cptr = ^char;
   Bptr = ^ Boolean;
   Aptr = ^array[1..5] of real;
   date-ptr = ^ date;
      Date = record
         Day: 1..31;
         Month: 1..12;
         Year: 1900..3000;
      End;
var
   a, b : Rptr;
   d: date-ptr;
</pre>
<p>The pointer variables are dereferenced by using the same caret symbol (^). For example, the associated variable referred by a pointer <i>rptr</i>, is <i>rptr^</i>. It can be accessed as &minus;</p>
<pre class="prettyprint notranslate">
rptr^ := 234.56;
</pre>
<p>The following example will illustrate this concept &minus;</p>
<pre class="prettyprint notranslate tryit">
program exPointers;
var
   number: integer;
   iptr: ^integer;

begin
   number := 100;
   writeln('Number is: ', number);
   
   iptr := @number;
   writeln('iptr points to a value: ', iptr^);
   
   iptr^ := 200;
   writeln('Number is: ', number);
   writeln('iptr points to a value: ', iptr^);
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Number is: 100
iptr points to a value: 100
Number is: 200
iptr points to a value: 200
</pre>
<h2>Printing a Memory Address in Pascal</h2>
<p>In Pascal, we can assign the address of a variable to a pointer variable using the address operator (@). We use this pointer to manipulate and access the data item. However, if for some reason, we need to work with the memory address itself, we need to store it in a word type variable.</p>
<p>Let us extend the above example to print the memory address stored in the pointer <i>iptr</i> &minus;</p>
<pre class="prettyprint notranslate tryit">
program exPointers;
var
   number: integer;
   iptr: ^integer;
   y: ^word;

begin
   number := 100;
   writeln('Number is: ', number);
   iptr := @number;
   writeln('iptr points to a value: ', iptr^);
   
   iptr^ := 200;
   writeln('Number is: ', number);
   writeln('iptr points to a value: ', iptr^);
   y := addr(iptr);
   writeln(y^); 
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Number is: 100
iptr points to a value: 100
Number is: 200
iptr points to a value: 200
36864
</pre>
<h2>NIL Pointers</h2>
<p>It is always a good practice to assign a <b>NIL</b> value to a pointer variable in case you do not have exact address to be assigned. This is done at the time of variable declaration. A pointer that is assigned <b>NIL</b> points to nowhere. Consider the following program &minus;</p>
<pre class="prettyprint notranslate tryit">
program exPointers;
var
   number: integer;
   iptr: ^integer;
   y: ^word;

begin
   iptr := nil;
   y := addr(iptr);
   
   writeln('the vaule of iptr is ', y^);
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
The value of ptr is 0
</pre>
<p>To check for a <b>nil</b> pointer you can use an if statement as follows &minus;</p>
<pre class="prettyprint notranslate">
if(ptr &lt;&gt; nill )then     (* succeeds if p is not null *)
if(ptr = nill)then    (* succeeds if p is null *)
</pre>
<h2>Pascal Pointers in Detail</h2>
<p>Pointers have many but easy concepts and they are very important to Pascal programming. There are following few important pointer concepts, which should be clear to a Pascal programmer &minus;</p>
<table class="table table-bordered">
<tr>
<th style="width:45%">Concept</th>
<th>Description</th>
</tr>
<tr>
<td><p><a href="/pascal/pascal_pointer_arithmetic.htm" title="Pascal - Pointer Arithmetic">Pascal - Pointer arithmetic</a></p></td>
<td>There are four arithmetic operators that can be used on pointers: increment,decrement, +, -</td> 
</tr>
<tr>
<td><p><a href="/pascal/pascal_array_of_pointers.htm" title="Pascal - Array of Pointers">Pascal  - Array of pointers</a></p></td>
<td>You can define arrays to hold a number of pointers.</td> 
</tr>
<tr>
<td><p><a href="/pascal/pascal_pointer_to_pointer.htm" title="Pascal - Pointer to Pointer Operators">Pascal - Pointer to pointer</a></p></td>
<td>Pascal allows you to have pointer on a pointer and so on.</td> 
</tr>
<tr>
<td><p><a href="/pascal/pascal_passing_pointers_to_subprograms.htm" title="Passing pointers to subprograms in Pascal">Passing pointers to subprograms in Pascal</a></p></td>
<td>Passing an argument by reference or by address both enable the passed argument to be changed in the calling subprogram by the called subprogram.</td> </tr>
<tr>
<td><p><a href="/pascal/pascal_return_pointer_from_subprograms.htm" title="Return pointer from subprograms in Pascal">Return pointer from subprograms in Pascal</a></p></td>
<td>Pascal allows a subprogram to return a pointer.</td> 
</tr>
</table>
<h1>Pascal - Records</h1>
<p>Pascal arrays allow you to define type of variables that can hold several data items of the same kind but a record is another user-defined data type available in Pascal which allows you to combine data items of different kinds.</p>
<p>Records consist of different fields. Suppose you want to keep track of your books in a library, you might want to track the following attributes about each book &minus;</p>
<ul class="list">
<li>Title</li>
<li>Author</li>
<li>Subject</li>
<li>Book ID</li>
</ul>
<h2>Defining a Record</h2>
<p>To define a record type, you may use the type declaration statement. The record type is defined as &minus;</p>
<pre class="prettyprint notranslate">
type
record-name = record
   field-1: field-type1;
   field-2: field-type2;
   ...
   field-n: field-typen;
end;
</pre>
<p>Here is the way you would declare the Book record &minus;</p>
<pre class="prettyprint notranslate">
type 
Books = record
   title: packed array [1..50] of char;
   author: packed array [1..50] of char;
   subject: packed array [1..100] of char;
   book_id: integer;
end;
</pre>
<p>The record variables are defined in the usual way as </p>
<pre class="prettyprint notranslate">
var
   r1, r2, ... : record-name;
</pre>
<p>Alternatively, you can directly define a record type variable as &minus;</p>
<pre class="prettyprint notranslate">
var
Books : record
   title: packed array [1..50] of char;
   author: packed array [1..50] of char;
   subject: packed array [1..100] of char;
   book_id: integer;
end;
</pre>
<h2>Accessing Fields of a Record</h2>
<p>To access any field of a record, we use the member access operator (.). The member access operator is coded as a period between the record variable name and the field that we wish to access. Following is the example to explain usage of structure &minus;</p>
<pre class="prettyprint notranslate tryit">
program exRecords;
type
Books = record
   title: packed array [1..50] of char;
   author: packed array [1..50] of char;
   subject: packed array [1..100] of char;
   book_id: longint;
end;

var
   Book1, Book2: Books; (* Declare Book1 and Book2 of type Books *)

begin
   (* book 1 specification *)
   Book1.title  := 'C Programming';
   Book1.author := 'Nuha Ali '; 
   Book1.subject := 'C Programming Tutorial';
   Book1.book_id := 6495407;

   (* book 2 specification *)
   Book2.title := 'Telecom Billing';
   Book2.author := 'Zara Ali';
   Book2.subject := 'Telecom Billing Tutorial';
   Book2.book_id := 6495700;
 
   (* print Book1 info *)
   writeln ('Book 1 title : ', Book1.title);
   writeln('Book 1 author : ', Book1.author);
   writeln( 'Book 1 subject : ', Book1.subject);
   writeln( 'Book 1 book_id : ', Book1.book_id);
   writeln; 

   (* print Book2 info *)
   writeln ('Book 2 title : ', Book2.title);
   writeln('Book 2 author : ', Book2.author);
   writeln( 'Book 2 subject : ', Book2.subject);
   writeln( 'Book 2 book_id : ', Book2.book_id);
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Book 1 title : C Programming
Book 1 author : Nuha Ali
Book 1 subject : C Programming Tutorial
Book 1 book_id : 6495407

Book 2 title : Telecom Billing
Book 2 author : Zara Ali
Book 2 subject : Telecom Billing Tutorial
Book 2 book_id : 6495700
</pre>
<h2>Records as Subprogram Arguments</h2>
<p>You can pass a record as a subprogram argument in very similar way as you pass any other variable or pointer. You would access the record fields in the similar way as you have accessed in the above example &minus;</p>
<pre class="prettyprint notranslate tryit">
program exRecords;
type
Books = record
   title: packed array [1..50] of char;
   author: packed array [1..50] of char;
   subject: packed array [1..100] of char;
   book_id: longint;
end;

var
   Book1, Book2: Books; (* Declare Book1 and Book2 of type Books *)

(* procedure declaration *)
procedure printBook( var book: Books );

begin
   (* print Book info *)
   writeln ('Book  title : ', book.title);
   writeln('Book  author : ', book.author);
   writeln( 'Book  subject : ', book.subject);
   writeln( 'Book book_id : ', book.book_id);
end;

begin
   (* book 1 specification *)
   Book1.title  := 'C Programming';
   Book1.author := 'Nuha Ali '; 
   Book1.subject := 'C Programming Tutorial';
   Book1.book_id := 6495407;
   
   (* book 2 specification *)
   Book2.title := 'Telecom Billing';
   Book2.author := 'Zara Ali';
   Book2.subject := 'Telecom Billing Tutorial';
   Book2.book_id := 6495700;
   
   (* print Book1 info *)
   printbook(Book1);
   writeln; 

   (* print Book2 info *)
   printbook(Book2);
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Book 1 title : C Programming
Book 1 author : Nuha Ali
Book 1 subject : C Programming Tutorial
Book 1 book_id : 6495407

Book 2 title : Telecom Billing
Book 2 author : Zara Ali
Book 2 subject : Telecom Billing Tutorial
Book 2 book_id : 6495700
</pre>
<h2>Pointers to Records</h2>
<p>You can define pointers to records in very similar way as you define pointer to any other variable as follows &minus;</p>
<pre class="prettyprint notranslate">
type
record-ptr = ^ record-name;
record-name = record
   field-1: field-type1;
   field-2: field-type2;
   ...
   field-n: field-typen;
end;
</pre>
<p>Now, you can store the address of a record type variable in the above-defined pointer variable. To declare a variable of the created pointer type, you use the var keyword &minus;</p>
<pre class="prettyprint notranslate">
var
   r1, r2, ... : record-ptr;
</pre>
<p>Before using these pointers, you must create storage for a record-name type variable, which will be manipulated by these pointers.</p>
<pre class="prettyprint notranslate">
new(r1);
new(r2);
</pre>
<p>To access the members of a record using a pointer to that record, you must use the ^. operator as follows &minus;</p>
<pre class="prettyprint notranslate">
r1^.feild1 := value1;
r1^.feild2 := value2;
...
r1^fieldn := valuen;
</pre>
<p>Finally, don't forget to dispose the used storage, when it is no longer in use &minus;</p>
<pre class="prettyprint notranslate">
dispose(r1);
dispose(r2);
</pre>
<p>Let us re-write the first example using a pointer to the Books record. Hope this will be easy for you to understand the concept &minus;</p>
<pre class="prettyprint notranslate tryit">
program exRecords;
type
BooksPtr = ^ Books;
Books = record
   title: packed array [1..50] of char;
   author: packed array [1..50] of char;
   subject: packed array [1..100] of char;
   book_id: longint;
end;

var
  (* Declare Book1 and Book2 of pointer type that refers to Book type *)
   Book1, Book2: BooksPtr; 

begin
   new(Book1);
   new(book2);
   
   (* book 1 specification *)
   Book1^.title  := 'C Programming';
   Book1^.author := 'Nuha Ali '; 
   Book1^.subject := 'C Programming Tutorial';
   Book1^.book_id := 6495407;
   
   (* book 2 specification *)
   Book2^.title := 'Telecom Billing';
   Book2^.author := 'Zara Ali';
   Book2^.subject := 'Telecom Billing Tutorial';
   Book2^.book_id := 6495700;
   
   (* print Book1 info *)
   writeln ('Book 1 title : ', Book1^.title);
   writeln('Book 1 author : ', Book1^.author);
   writeln( 'Book 1 subject : ', Book1^.subject);
   writeln( 'Book 1 book_id : ', Book1^.book_id);
   
   (* print Book2 info *)
   writeln ('Book 2 title : ', Book2^.title);
   writeln('Book 2 author : ', Book2^.author);
   writeln( 'Book 2 subject : ', Book2^.subject);
   writeln( 'Book 2 book_id : ', Book2^.book_id);
   
   dispose(Book1); 
   dispose(Book2);
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Book 1 title : C Programming
Book 1 author : Nuha Ali
Book 1 subject : C Programming Tutorial
Book 1 book_id : 6495407

Book 2 title : Telecom Billing
Book 2 author : Zara Ali
Book 2 subject : Telecom Billing Tutorial
Book 2 book_id : 6495700
</pre>
<h2>The With Statement</h2>
<p>We have discussed that the members of a record can be accessed using the member access operator (.). This way the name of the record variable has to be written every time. The <b>With</b> statement provides an alternative way to do that.</p>
<p>Look at the following code snippet taken from our first example &minus;</p>
<pre class="prettyprint notranslate">
   (* book 1 specification *)
   Book1.title  := 'C Programming';
   Book1.author := 'Nuha Ali '; 
   Book1.subject := 'C Programming Tutorial';
   Book1.book_id := 6495407;
</pre>
<p>The same assignment could be written using the <b>With</b> statement as &minus;</p>
<pre class="prettyprint notranslate">
(* book 1 specification *)
With Book1 do
begin
   title  := 'C Programming';
   author := 'Nuha Ali '; 
   subject := 'C Programming Tutorial';
   book_id := 6495407;
end;
</pre>
<h1>Pascal - Variants</h1>
<p>Pascal supports a unique type of storage named variants.  You can assign any simple type of values in a variant variable. The type of a value stored in a variant is only determined at runtime. Almost any simple type can be assigned to variants: ordinal types, string types, int64 types.</p>
<p>Structured types such as sets, records, arrays, files, objects and classes are not assignment-compatible with a variant.  You can also assign a pointer to a variant.</p>
<p>Free Pascal supports variants.</p>
<h2>Declaring a Variant</h2>
<p>You can declare variant type like any other types using the <b>var</b> keyword. The syntax for declaring a variant type is &minus;</p>
<pre class="prettyprint notranslate">
var
   v: variant;
</pre>
<p>Now, this variant variable v can be assigned to almost all simple types including the enumerated types and vice versa.</p>
<pre class="prettyprint notranslate">
type  
   color = (red, black, white);  
var  
   v : variant;  
   i : integer;  
   b : byte;  
   w : word;  
   q : int64;  
   e : extended;  
   d : double;  
   en : color;  
   as : ansistring;  
   ws : widestring;  

begin  
   v := i;  
   v := b;  
   v := w;  
   v := q;  
   v := e;  
   v := en;  
   v := d:  
   v := as;  
   v := ws;  
end;
</pre>
<h3>Example</h3>
<p>The following example would illustrate the concept &minus;</p>
<pre class="prettyprint notranslate tryit">
Program exVariant;

uses variants;
type
   color = (red, black, white);

var
   v : variant;
   i : integer;
   r: real;
   c : color;
   as : ansistring;


begin
   i := 100;
   v:= i;
   writeln('Variant as Integer: ', v);

   r:= 234.345;
   v:= r;
   writeln('Variant as real: ', v);

   c := red;
   v := c;
   writeln('Variant as Enumerated data: ', v);

   as:= ' I am an AnsiString';
   v:= as;
   writeln('Variant as AnsiString: ', v);
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Variant as Integer: 100
Variant as real: 234.345
Variant as Enumerated data: 0
Variant as AnsiString: I am an AnsiString
</pre>
<h1>Pascal - Sets</h1>
<p>A set is a collection of elements of same type. Pascal allows defining the set data type. The elements in a set are called its members. In mathematics, sets are represented by enclosing the members within <i>braces{}</i>.  However, in Pascal, set elements are enclosed within square brackets [], which are referred as set constructor.</p>
<h2>Defining Set Types and Variables</h2>
<p>Pascal Set types are defined as</p>
<pre class="prettyprint notranslate">
type
set-identifier = set of base type;
</pre>
<p>Variables of set type are defined as</p>
<pre class="prettyprint notranslate">
var
s1, s2, ...: set-identifier;
</pre>
<p>or,</p>
<pre class="prettyprint notranslate">
s1, s2...: set of base type;
</pre>
<p>Examples of some valid set type declaration are &minus;</p>
<pre class="prettyprint notranslate">
type
Days = (mon, tue, wed, thu, fri, sat, sun);
Letters = set of char;
DaySet = set of days;
Alphabets = set of 'A' .. 'Z';
studentAge = set of 13..20;
</pre>
<h2>Set Operators</h2>
<p>You can perform the following set operations on Pascal sets.</p>
<table class="table table-bordered">
<tr>
<th style="width:20%;">Operations</th>
<th>Descriptions</th>
</tr>
<tr>
<td>Union</td>
<td>This joins two sets and gives a new set with members from both sets.</td>
</tr>
<tr>
<td>Difference</td>
<td>Gets the difference of two sets and gives a new set with elements not common to either set.</td>
</tr>
<tr>
<td>Intersection</td>
<td>Gets the intersection of two sets and gives a new set with elements common to both sets.</td>
</tr>
<tr>
<td>Inclusion</td>
<td>A set P is included in set Q, if all items in P are also in Q but not vice versa.</td>
</tr>
<tr>
<td>Symmetric difference</td>
<td>Gets the symmetric difference of two sets and gives a set of elements, which are in either of the sets and not in their intersection.</td>
</tr>
<tr>
<td>In </td>
<td>It checks membership.</td>
</tr>
</table>
<p>Following table shows all the set operators supported by Free Pascal. Assume that <b>S1</b> and <b>S2</b> are two character sets, such that &minus;</p>
<p>S1 := ['a', 'b', 'c']; </p>
<p>S2 := ['c', 'd', 'e']; </p>
<table class="table table-bordered">
<tr>
<th style="width:10%">Operator</th>
<th style="width:55%;">Description</th>
<th>Example</th>
</tr>
<tr>
<td>+</td>
<td>Union of two sets</td>
<td><p>S1 + S2 will give a set</p>
<p>['a', 'b', 'c', 'd', 'e']</p>
</td>
</tr>
<tr>
<td>-</td>
<td>Difference of two sets</td>
<td><p>S1 - S2 will give a set</p> 
<p>['a', 'b']</p>
</td>
</tr>
<tr>
<td>*</td>
<td>Intersection of two sets</td>
<td><p>S1 * S2 will give a set</p>
<p>['c']</p>
</td>
</tr>
<tr>
<td>&gt;&lt;</td>
<td>Symmetric difference of two sets</td>
<td>S1 &gt;&lt; S2 will give a set ['a', 'b', 'd', 'e']</td>
</tr>
<tr>
<td> =</td>
<td>Checks equality of two sets</td>
<td>S1 = S2 will give the boolean value False</td>
</tr>
<tr>
<td> &lt;&gt;</td>
<td>Checks non-equality of two sets</td>
<td> S1 &lt;&gt; S2 will give the boolean value True</td>
</tr>
<tr>
<td>&lt;= </td>
<td>Contains (Checks if one set is a subset of the other)</td>
<td>S1 &lt;= S2 will give the boolean value False </td>
</tr>
<tr>
<td>Include</td>
<td>Includes an element in the set; basically it is the Union of a set and an element of same base type</td>
<td><p>Include (S1, ['d']) will give a set</p>
<p>['a', 'b', 'c', 'd']</p>
</td>
</tr>
<tr>
<td>Exclude</td>
<td>Excludes an element from a set; basically it is the Difference of a set and an element of same base type </td>
<td><p>Exclude (S2, ['d']) will give a set</p> 
<p>['c', 'e']</p>
</td>
</tr>
<tr>
<td>In</td>
<td>Checks set membership of an element in a set</td>
<td>['e'] in S2 gives the boolean value True</td>
</tr>
</table>
<h3>Example</h3>
<p>The following example illustrates the use of some of these operators &minus;</p>
<pre class="prettyprint notranslate tryit">
program setColors;
type  
color = (red, blue, yellow, green, white, black, orange);  
colors = set of color;  
 
procedure displayColors(c : colors);  
const  
names : array [color] of String[7]  
  = ('red', 'blue', 'yellow', 'green', 'white', 'black', 'orange');  
var  
   cl : color;  
   s : String;  

begin  
   s:= ' ';  
   for cl:=red to orange do  
      if cl in c then  
      begin  
         if (s&lt;&gt;' ') then s :=s +' , ';  
         s:=s+names[cl];  
      end;  
   writeln('[',s,']');  
end;  
 
var  
   c : colors;  
 
begin  
   c:= [red, blue, yellow, green, white, black, orange];
   displayColors(c);

   c:=[red, blue]+[yellow, green]; 
   displayColors(c);  

   c:=[red, blue, yellow, green, white, black, orange] - [green, white];     
   displayColors(c);    

   c:= [red, blue, yellow, green, white, black, orange]*[green, white];     
   displayColors(c);  

   c:= [red, blue, yellow, green]&gt;&lt;[yellow, green, white, black]; 
   displayColors(c);  
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
[ red , blue , yellow , green , white , black , orange]
[ red , blue , yellow , green]
[ red , blue , yellow , black , orange]
[ green , white]
[ red , blue , white , black]
</pre>
<h1>Pascal - File Handling</h1>
<p>Pascal treats a file as a sequence of components, which must be of uniform type. A file's type is determined by the type of the components. File data type is defined as &minus;</p>
<pre class="prettyprint notranslate">
type
file-name = file of base-type;
</pre>
<p>Where, the base-type indicates the type of the components of the file. The base type could be anything like, integer, real, Boolean, enumerated, subrange, record, arrays and sets except another file type. Variables of a file type are created using the <i>var</i> declaration &minus;</p>
<pre class="prettyprint notranslate">
var
f1, f2,...: file-name;
</pre>
<p>Following are some examples of defining some file types and file variables &minus;</p>
<pre class="prettyprint notranslate">
type
   rfile = file of real;
   ifile = file of integer;
   bfile = file of boolean;
   datafile = file of record
   arrfile = file of array[1..4] of integer;

var
   marks: arrfile;
   studentdata: datafile;
   rainfalldata: rfile;
   tempdata: ifile;
   choices: bfile;
</pre>
<h2>Creating and Writing to a File</h2>
<p>Let us write a program that would create a data file for students' records. It would create a file named students.dat and write a student's data into it &minus;</p>
<pre class="prettyprint notranslate">
program DataFiles;
type
   StudentRecord = Record
      s_name: String;
      s_addr: String;
      s_batchcode: String;
   end;

var
   Student: StudentRecord;
   f: file of StudentRecord;

begin
   Assign(f,'students.dat');
   Rewrite(f);
   Student.s_name := 'John Smith';
   Student.s_addr := 'United States of America';
   Student.s_batchcode := 'Computer Science';
   Write(f,Student);
   Close(f);
end.
</pre>
<p>When compiled and run, the program would create a file named <i>students.dat</i> into the working directory. You can open the file using a text editor, like notepad, to look at John Smith's data.</p>
<h2>Reading from a File</h2>
<p>We have just created and written into a file named students.dat. Now, let us write a program that would read the student's data from the file &minus;</p>
<pre class="prettyprint notranslate">
program DataFiles;
type
   StudentRecord = Record
      s_name: String;
      s_addr: String;
      s_batchcode: String;
   end;

var
   Student: StudentRecord;
   f: file of StudentRecord;

begin
   assign(f, 'students.dat');
   reset(f); 
   while not eof(f) do
   
   begin
      read(f,Student);
      writeln('Name: ',Student.s_name);
      writeln('Address: ',Student.s_addr);
      writeln('Batch Code: ', Student.s_batchcode);
   end;
   
   close(f);
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Name: John Smith
Address: United States of America
Batch Code: Computer Science
</pre>
<h2>Files as Subprogram Parameter</h2>
<p>Pascal allows file variables to be used as parameters in standard and user-defined subprograms. The following example illustrates this concept. The program creates a file named rainfall.txt and stores some rainfall data. Next, it opens the file, reads the data and computes the average rainfall.</p>
<p>Please note that, <b>if you use a file parameter with subprograms, it must be declared as a var parameter.</b></p>
<pre class="prettyprint notranslate tryit">
program addFiledata;
const
   MAX = 4;
type
   raindata = file of real;

var
   rainfile: raindata;
   filename: string;
procedure writedata(var f: raindata);

var
   data: real;
   i: integer;

begin
   rewrite(f, sizeof(data));
   for i:=1 to MAX do
   
   begin
      writeln('Enter rainfall data: ');
      readln(data);
      write(f, data);
   end;
   
   close(f);
end;

procedure computeAverage(var x: raindata);
var
   d, sum: real;
   average: real;

begin
   reset(x);
   sum:= 0.0;
   while not eof(x) do
   
   begin
      read(x, d);
      sum := sum + d;
   end;
   
   average := sum/MAX;
   close(x);
   writeln('Average Rainfall: ', average:7:2);
end;

begin
   writeln('Enter the File Name: ');
   readln(filename);
   assign(rainfile, filename);
   writedata(rainfile);
   computeAverage(rainfile);
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Enter the File Name:
rainfall.txt
Enter rainfall data:
34
Enter rainfall data:
45
Enter rainfall data:
56
Enter rainfall data:
78
Average Rainfall: 53.25
</pre>
<h2>Text Files</h2>
<p>A text file, in Pascal, consists of lines of characters where each line is terminated with an end-of-line marker. You can declare and define such files as &minus;</p>
<pre class="prettyprint notranslate">
type
file-name = text;
</pre>
<p>Difference between a normal file of characters and a text file is that a text file is divided into lines, each terminated by a special end-of-line marker, automatically inserted by the system. The following example creates and writes into a text file named contact.txt &minus;</p>
<pre class="prettyprint notranslate tryit">
program exText;
var
   filename, data: string;
   myfile: text;

begin
   writeln('Enter the file name: ');
   readln(filename);
   
   assign(myfile, filename);
   rewrite(myfile);
   
   writeln(myfile, 'Note to Students: ');
   writeln(myfile, 'For details information on Pascal Programming');
   writeln(myfile, 'Contact: Tutorials Point');
   writeln('Completed writing'); 
   
   close(myfile);
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Enter the file name:
contact.txt 
Completed writing
</pre>
<h2>Appending to a File</h2>
<p>Appending to a file means writing to an existing file that already has some data without overwriting the file. The following program illustrates this &minus;</p>
<pre class="prettyprint notranslate tryit">
program exAppendfile;
var
   myfile: text;
   info: string;

begin
   assign(myfile, 'contact.txt');
   append(myfile);
   
   writeln('Contact Details');
   writeln('webmaster@tutorialspoint.com');
   close(myfile);
   
   (* let us read from this file *)
   assign(myfile, 'contact.txt');
   reset(myfile);
   while not eof(myfile) do
   
   begin
      readln(myfile, info);
      writeln(info);
   end;
   close(myfile);
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Contact Details
webmaster@tutorialspoint.com
Note to Students:
For details information on Pascal Programming
Contact: Tutorials Point
</pre>
<h2>File  Handling Functions</h2>
<p>Free Pascal provides the following functions/procedures for file handling &minus;</p>
<table class="table table-bordered">
<tr>
<th style="width:5%;">Sr.No.</th>
<th>Function Name &amp; Description</th></tr>
<tr>
<td>1</td>
<td>
<p><b>procedure Append(var t: Text);</b></p>
<p>Opens a file in append mode</p>
</td>
</tr>
<tr>
<td>2</td>
<td>
<p><b>procedure Assign(out f: file; const Name:);</b></p>
<p>Assigns a name to a file</p>
</td>
</tr>
<tr>
<td>3</td>
<td>
<p><b>procedure Assign(out f: file; p: PChar);</b></p>
<p>Assigns a name to a file</p>
</td>
</tr>
<tr>
<td>4</td>
<td>
<p><b>procedure Assign(out f: file; c: Char);</b></p>
<p>Assigns a name to a file</p>
</td>
</tr>
<tr>
<td>5</td>
<td>
<p><b>procedure Assign(out f: TypedFile; const Name:);</b></p>
<p>Assigns a name to a file</p>
</td>
</tr>
<tr>
<td>6</td>
<td>
<p><b>procedure Assign(out f: TypedFile; p: PChar);</b></p>
<p>Assigns a name to a file</p>
</td>
</tr>
<tr>
<td>7</td>
<td>
<p><b>procedure Assign(out f: TypedFile; c: Char);</b></p>
<p>Assigns a name to a file</p>
</td>
</tr>
<tr>
<td>8</td>
<td>
<p><b>procedure Assign(out t: Text; const s:);</b></p>
<p>Assigns a name to a file</p>
</td>
</tr>
<tr>
<td>9</td>
<td>
<p><b>procedure Assign(out t: Text; p: PChar);</b></p>
<p>Assigns a name to a file</p>
</td>
</tr>
<tr>
<td>10</td>
<td>
<p><b>procedure Assign(out t: Text; c: Char);</b></p>
<p>Assigns a name to a file</p>
</td>
</tr>
<tr>
<td>11</td>
<td>
<p><b>procedure BlockRead(var f: file; var Buf; count: Int64; var Result: Int64);</b></p>
<p>Reads data from a file into memory</p>
</td>
</tr>
<tr>
<td>12</td>
<td>
<p><b>procedure BlockRead(var f: file; var Buf; count: LongInt; var Result: LongInt);</b></p>
<p>Reads data from a file into memory</p>
</td>
</tr>
<tr>
<td>13</td>
<td>
<p><b>procedure BlockRead(var f: file; var Buf; count: Cardinal; var Result: Cardinal);</b></p>
<p>Reads data from a file into memory</p>
</td>
</tr>
<tr>
<td>14</td>
<td>
<p><b>procedure BlockRead(var f: file; var Buf; count: Word; var Result: Word);</b></p>
<p>Reads data from a file into memory</p>
</td>
</tr>
<tr>
<td>15</td>
<td>
<p><b>procedure BlockRead(var f: file; var Buf; count: Word; var Result: Integer);</b></p>
<p>Reads data from a file into memory</p>
</td>
</tr>
<tr>
<td>16</td>
<td>
<p><b>procedure BlockRead(var f: file; var Buf; count: Int64);</b></p>
<p>Reads data from a file into memory</p>
</td>
</tr>
<tr>
<td>17</td>
<td>
<p><b>procedure BlockWrite(var f: file; const Buf; Count: Int64; var Result: Int64);</b></p>
<p>Writes data from memory to a file</p>
</td>
</tr>
<tr>
<td>18</td>
<td>
<p><b>procedure BlockWrite(var f: file; const Buf; Count: LongInt; var Result: LongInt);</b></p>
<p>Writes data from memory to a file</p>
</td>
</tr>
<tr>
<td>19</td>
<td>
<p><b>procedure BlockWrite(var f: file; const Buf; Count: Cardinal; var Result: Cardinal);</b></p>
<p>Writes data from memory to a file</p>
</td>
</tr>
<tr>
<td>20 </td>
<td>
<p><b>procedure BlockWrite(var f: file; const Buf; Count: Word; var Result: Word);</b></p>
<p>Writes data from memory to a file</p>
</td>
</tr>
<tr>
<td>21</td>
<td>
<p><b>procedure BlockWrite(var f: file; const Buf; Count: Word; var Result: Integer);</b></p>
<p>Writes data from memory to a file</p>
</td>
</tr>
<tr>
<td>22</td>
<td>
<p><b>procedure BlockWrite(var f: file; const Buf; Count: LongInt);</b></p>
<p>Writes data from memory to a file</p>
</td>
</tr>
<tr>
<td>23</td>
<td>
<p><b>procedure Close(var f: file);</b></p>
<p>Closes a file</p>
</td>
</tr>
<tr>
<td>24</td>
<td>
<p><b>procedure Close(var t: Text);</b></p>
<p>Closes a file</p>
</td>
</tr>
<tr>
<td>25</td>
<td>
<p><b>function EOF(var f: file):Boolean; </b></p>
<p>Checks for end of file</p>
</td>
</tr>
<tr>
<td>26</td>
<td>
<p><b>function EOF(var t: Text):Boolean;</b></p>
<p>Checks for end of file</p>
</td>
</tr>
<tr>
<td>27</td>
<td>
<p><b>function EOF: Boolean;</b></p>
<p>Checks for end of file</p>
</td>
</tr>
<tr>
<td>28</td>
<td>
<p><b>function EOLn(var t: Text):Boolean; </b></p>
<p>Checks for end of line</p>
</td>
</tr>
<tr>
<td>29</td>
<td>
<p><b>function EOLn: Boolean;</b></p>
<p>Checks for end of line</p>
</td>
</tr>
<tr>
<td>30</td>
<td>
<p><b>procedure Erase(var f: file);</b></p>
<p>Deletes file from disk</p>
</td>
</tr>
<tr>
<td>31</td>
<td>
<p><b>procedure Erase(var t: Text);</b></p>
<p>Deletes file from disk</p>
</td>
</tr>
<tr>
<td>32</td>
<td>
<p><b>function FilePos( var f: file):Int64; </b></p>
<p>Position in file</p>
</td>
</tr>
<tr>
<td>33</td>
<td>
<p><b>function FileSize(var f: file):Int64;</b></p>
<p>Size of file</p></td>
</tr>
<tr>
<td>34</td>
<td>
<p><b>procedure Flush(var t: Text);</b></p>
<p>Writes file buffers to disk</p>
</td>
</tr>
<tr>
<td>35</td>
<td>
<p><b>function IOResult: Word;</b></p>
<p>Returns result of last file IO operation</p>
</td>
</tr>
<tr>
<td>36</td>
<td>
<p><b>procedure Read(var F: Text; Args: Arguments);</b></p>
<p>Reads from file into variable</p>
</td>
</tr>
<tr>
<td>37</td>
<td>
<p><b>procedure Read(Args: Arguments);</b></p>
<p>Reads from file into variable</p>
</td>
</tr>
<tr>
<td>38</td>
<td>
<p><b>procedure ReadLn(var F: Text; Args: Arguments);</b></p>
<p>Reads from file into variable and goto next line</p>
</td>
</tr>
<tr>
<td>39</td>
<td>
<p><b>procedure ReadLn(Args: Arguments);</b></p>
<p>Reads from file into variable and goto next line</p>
</td>
</tr>
<tr>
<td>40</td>
<td>
<p><b>procedure Rename(var f: file; const s:);</b></p>
<p>Renames file on disk</p>
</td>
</tr>
<tr>
<td>41</td>
<td>
<p><b>procedure Rename(var f: file; p: PChar);</b></p>
<p>Renames file on disk</p>
</td>
</tr>
<tr>
<td>42</td>
<td>
<p><b>procedure Rename(var f: file; c: Char);</b></p>
<p>Renames file on disk</p>
</td>
</tr>
<tr>
<td>43</td>
<td>
<p><b>procedure Rename(var t: Text; const s); </b></p>
<p>Rename file on disk</p>
</td>
</tr>
<tr>
<td>44</td>
<td>
<p><b>procedure Rename(var t: Text; p: PChar);</b></p>
<p>Renames file on disk</p>
</td>
</tr>
<tr>
<td>45</td>
<td>
<p><b>procedure Rename( var t: Text; c: Char);</b></p>
<p>Renames file on disk</p>
</td>
</tr>
<tr>
<td>46</td>
<td>
<p><b>procedure Reset(var f: file; l: LongInt);</b></p>
<p>Opens file for reading</p>
</td>
</tr>
<tr>
<td>47</td>
<td>
<p><b>procedure Reset(var f: file);</b></p>
<p>Opens file for reading</p>
</td>
</tr>
<tr>
<td>48</td>
<td>
<p><b>procedure Reset(var f: TypedFile);</b></p>
<p>Opens file for reading</p>
</td>
</tr>
<tr>
<td>49</td>
<td>
<p><b>procedure Reset(var t: Text);</b></p>
<p>Opens file for reading</p>
</td>
</tr>
<tr>
<td>50</td>
<td>
<p><b>procedure Rewrite(var f: file; l: LongInt);</b></p>
<p>Opens file for writing</p>
</td>
</tr>
<tr>
<td>51</td>
<td>
<p><b>procedure Rewrite(var f: file);</b></p>
<p>Opens file for writing</p>
</td>
</tr>
<tr>
<td>52</td>
<td>
<p><b>procedure Rewrite(var f: TypedFile);</b></p>
<p>Opens file for writing</p>
</td>
</tr>
<tr>
<td>53</td>
<td>
<p><b>procedure Rewrite(var t: Text);</b></p>
<p>Opens file for writing</p>
</td>
</tr>
<tr>
<td>54</td>
<td>
<p><b>procedure Seek(var f: file; Pos: Int64);</b></p>
<p>Sets file position</p>
</td>
</tr>
<tr>
<td>55</td>
<td>
<p><b>function SeekEOF(var t: Text):Boolean;</b></p>
<p>Sets file position to end of file</p>
</td>
</tr>
<tr>
<td>56</td>
<td>
<p><b>function SeekEOF: Boolean;</b></p>
<p>Sets file position to end of file</p>
</td>
</tr>
<tr>
<td>57</td>
<td>
<p><b>function SeekEOLn(var t: Text):Boolean;</b></p>
<p>Sets file position to end of line</p>
</td>
</tr>
<tr>
<td>58</td>
<td>
<p><b>function SeekEOLn: Boolean;</b></p>
<p>Sets file position to end of line</p>
</td>
</tr>
<tr>
<td>59</td>
<td>
<p><b>procedure SetTextBuf(var f: Text; var Buf);</b></p>
<p>Sets size of file buffer</p>
</td>
</tr>
<tr>
<td>60</td>
<td>
<p><b>procedure SetTextBuf(var f: Text; var Buf; Size: SizeInt);</b></p>
<p>Sets size of file buffer</p>
</td>
</tr>
<tr>
<td>61</td>
<td>
<p><b>procedure Truncate(var F: file);</b></p>
<p>Truncate the file at position</p>
</td>
</tr>
<tr>
<td>62</td>
<td>
<p><b>procedure Write(Args: Arguments);</b></p>
<p>Writes variable to file</p>
</td>
</tr>
<tr>
<td>63</td>
<td>
<p><b>procedure Write(var F: Text; Args: Arguments);</b></p>
<p>Write variable to file</p>
</td>
</tr>
<tr>
<td>64</td>
<td>
<p><b>procedure Writeln(Args: Arguments);</b></p>
<p>Writes variable to file and append newline</p>
</td>
</tr>
<tr>
<td>65</td>
<td>
<p><b>procedure WriteLn(var F: Text; Args: Arguments);</b></p>
<p>Writes variable to file and append newline</p>
</td>
</tr>
</table>
<h1>Pascal - Memory Management</h1>
<p>This chapter explains dynamic memory management in Pascal. Pascal programming language provides several functions for memory allocation and management.</p>
<h2>Allocating Memory Dynamically</h2>
<p>While doing programming, if you are aware about the size of an array, then it is easy and you can define it as an array. For example, to store a name of any person, it can go max 100 characters so you can define something as follows &minus;</p>
<pre class="prettyprint notranslate">
var
name: array[1..100] of char;
</pre>
<p>But now, let us consider a situation, where you have no idea about the length of the text you need to store, for example, you want to store a detailed description about a topic.  Here, we need to define a pointer to string without defining how much memory is required.</p>
<p>Pascal provides a procedure <b>new</b>to create pointer variables.</p>
<pre class="prettyprint notranslate tryit">
program exMemory;
var
name: array[1..100] of char;
description: ^string;

begin
   name:= 'Zara Ali';
   
   new(description);
      if not assigned(description) then
         writeln(' Error - unable to allocate required memory')
      else
         description^ := 'Zara ali a DPS student in class 10th';
   writeln('Name = ', name );
   writeln('Description: ', description^ );
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Name = Zara Ali
Description: Zara ali a DPS student in class 10th
</pre>
<p>Now, if you need to define a pointer with specific number of bytes to be referred by it later, you should use the <b>getmem</b> function or the <b>getmem</b> procedure, which has the following syntax &minus;</p>
<pre class="prettyprint notranslate">
procedure Getmem(
   out p: pointer;
   Size: PtrUInt
);

function GetMem(
   size: PtrUInt
):pointer;
</pre>
<p>In the previous example, we declared a pointer to a string. A string has a maximum value of 255 bytes. If you really don't need that much space, or a larger space, in terms of bytes, <i>getmem</i> subprogram allows specifying that. Let us rewrite the previous example, using <i>getmem</i> &minus;</p>
<pre class="prettyprint notranslate tryit">
program exMemory;
var
name: array[1..100] of char;
description: ^string;

begin
   name:= 'Zara Ali';
   
   description := getmem(200);
      if not assigned(description) then
         writeln(' Error - unable to allocate required memory')
      else
         description^ := 'Zara ali a DPS student in class 10th';
   writeln('Name = ', name );
   writeln('Description: ', description^ );
   
   freemem(description);
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Name = Zara Ali
Description: Zara ali a DPS student in class 10th
</pre>
<p>So, you have complete control and you can pass any size value while allocating memory unlike arrays, where once you defined the size cannot be changed.</p>
<h2>Resizing and Releasing Memory</h2>
<p>When your program comes out, operating system automatically releases all the memory allocated by your program, but as a good practice when you are not in need of memory anymore, then you should release that memory.</p>
<p>Pascal provides the procedure <b>dispose</b> to free a dynamically created variable using the procedure <b>new.</b> If you have allocated memory using the <b>getmem</b> subprogram, then you need to use the subprogram <b>freemem</b> to free this memory. The <i>freemem</i> subprograms have the following syntax &minus;</p>
<pre class="prettyprint notranslate">
procedure Freemem(
   p: pointer;
  Size: PtrUInt
);

function Freemem(
   p: pointer
):PtrUInt;
</pre>
<p>Alternatively, you can increase or decrease the size of an allocated memory block by calling the function <i>ReAllocMem</i>. Let us check the above program once again and make use of <i>ReAllocMem</i> and <i>freemem</i> subprograms. Following is the syntax for <i>ReAllocMem</i> &minus;</p>
<pre class="prettyprint notranslate">
function ReAllocMem(
   var p: pointer;
   Size: PtrUInt
):pointer;   
</pre>
<p>Following is an example which makes use of <i>ReAllocMem</i> and <i>freemem</i> subprograms &minus;</p>
<pre class="prettyprint notranslate tryit">
program exMemory;
var
name: array[1..100] of char;
description: ^string;
desp: string;

begin
   name:= 'Zara Ali';
   desp := 'Zara ali a DPS student.';
   
   description := getmem(30);
      if not assigned(description) then
         writeln('Error - unable to allocate required memory')
      else
         description^ := desp;

   (* Suppose you want to store bigger description *)
   description := reallocmem(description, 100);
   desp := desp + ' She is in class 10th.';
   description^:= desp; 
   
   writeln('Name = ', name );
   writeln('Description: ', description^ );
   
   freemem(description);
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Name = Zara Ali
Description: Zara ali a DPS student. She is in class 10th
</pre>
<h2>Memory Management Functions</h2>
<p>Pascal provides a hoard of memory management functions that is used in implementing various data structures and implementing low-level programming in Pascal. Many of these functions are implementation dependent. Free Pascal provides the following functions and procedures for memory management &minus;</p>
<table class="table table-bordered">
<tr>
<th style="width:5%;">S.N</th>
<th>Function Name &amp; Description</th>
</tr>
<tr>
<td>1</td>
<td>
<p><b>function Addr(X: TAnytype):Pointer;</b></p>
<p>Returns address of variable</p>
</td>
</tr>
<tr>
<td>2</td>
<td>
<p><b>function Assigned(P: Pointer):Boolean;</b></p>
<p>Checks if a pointer is valid</p>
</td>
</tr>
<tr>
<td>3</td>
<td>
<p><b>function CompareByte(const buf1; const buf2; len: SizeInt):SizeInt;</b></p>
<p>Compares 2 memory buffers byte per byte</p>
</td>
</tr>
<tr>
<td>4</td>
<td>
<p><b>function CompareChar(const buf1; const buf2; len: SizeInt):SizeInt;</b></p>
<p>Compares 2 memory buffers byte per byte</p>
</td>
</tr>
<tr>
<td>5</td>
<td>
<p><b>function CompareDWord(const buf1; const buf2; len: SizeInt):SizeInt;</b></p>
<p>Compares 2 memory buffers byte per byte</p>
</td>
</tr>
<tr>
<td>6</td>
<td>
<p><b>function CompareWord(const buf1; const buf2; len: SizeInt):SizeInt;</b></p>
<p>Compares 2 memory buffers byte per byte</p>
</td>
</tr>
<tr>
<td>7</td>
<td>
<p><b>function Cseg: Word;</b></p>
<p>Returns code segment</p>
</td>
</tr>
<tr>
<td>8</td>
<td>
<p><b>procedure Dispose(P: Pointer);</b></p>
<p>Frees dynamically allocated memory</p>
</td>
</tr>
<tr>
<td>9</td>
<td>
<p><b>procedure Dispose(P: TypedPointer; Des: TProcedure);</b></p>
<p>Frees dynamically allocated memory</p>
</td>
</tr>
<tr>
<td>10</td>
<td>
<p><b>function Dseg: Word;</b></p>
<p>Returns data segment</p>
</td>
</tr>
<tr>
<td>11</td>
<td>
<p><b>procedure FillByte(var x; count: SizeInt;  value: Byte);</b></p>
<p>Fills memory region with 8-bit pattern</p>
</td>
</tr>
<tr>
<td>12</td>
<td>
<p><b>procedure FillChar(  var x;  count: SizeInt; Value: Byte|Boolean|Char);</b></p>
<p>Fills memory region with certain character</p>
</td>
</tr>
<tr>
<td>13</td>
<td>
<p><b>procedure FillDWord( var x; count: SizeInt; value: DWord);</b></p>
<p>Fills memory region with 32-bit pattern</p>
</td>
</tr>
<tr>
<td>14</td>
<td>
<p><b>procedure FillQWord( var x;  count: SizeInt;  value: QWord);</b></p>
<p>Fills memory region with 64-bit pattern</p>
</td>
</tr>
<tr>
<td>15</td>
<td>
<b>procedure FillWord(  var x;  count: SizeInt;  Value: Word);</b>
<p>Fills memory region with 16-bit pattern</td>
</tr>
<tr>
<td>16</td>
<td>
<p><b>procedure Freemem(  p: pointer;  Size: PtrUInt);</b></p>
<p>Releases allocated memory</p>
</td>
</tr>
<tr>
<td>17</td>
<td>
<p><b>procedure Freemem(  p: pointer );</b></p>
<p>Releases allocated memory</p>
</td>
</tr>
<tr>
<td>18</td>
<td>
<p><b>procedure Getmem( out p: pointer; Size: PtrUInt);</b></p>
<p>Allocates new memory</p>
</td>
</tr>
<tr>
<td>19</td>
<td>
<p><b>procedure Getmem( out p: pointer);</b></p>
<p>Allocates new memory</p>
</td>
</tr>
<tr>
<td>20</td>
<td>
<p><b>procedure GetMemoryManager(  var MemMgr: TMemoryManager);</b></p>
<p>Returns current memory manager</p>
</td>
</tr>
<tr>
<td>21</td>
<td>
<p><b>function High(  Arg: TypeOrVariable):TOrdinal;</b></p>
<p>Returns highest index of open array or enumerated</p>
</td>
</tr>
<tr>
<td>22</td>
<td>
<p><b>function IndexByte(  const buf;  len: SizeInt;  b: Byte):SizeInt;</b></p>
<p>Finds byte-sized value in a memory range</p>
</td>
</tr>
<tr>
<td>23</td>
<td>
<p><b>function IndexChar(  const buf;  len: SizeInt;  b: Char):SizeInt;</b></p>
<p>Finds char-sized value in a memory range</p>
</td>
</tr>
<tr>
<td>24</td>
<td>
<p><b>function IndexDWord(  const buf;  len: SizeInt;  b: DWord):SizeInt;</b></p>
<p>Finds DWord-sized (32-bit) value in a memory range</p>
</td>
</tr>
<tr>
<td>25</td>
<td>
<p><b>function IndexQWord(  const buf;  len: SizeInt;  b: QWord):SizeInt;</b></p>
<p>Finds QWord-sized value in a memory range</p>
</td>
</tr>
<tr>
<td>26</td>
<td>
<p><b>function Indexword(  const buf;  len: SizeInt;  b: Word):SizeInt;</b></p>
<p>Finds word-sized value in a memory range</p>
</td>
</tr>
<tr>
<td>27</td>
<td>
<p><b>function IsMemoryManagerSet: Boolean;</b></p>
<p>Is the memory manager set</p>
</td>
</tr>
<tr>
<td>28</td>
<td>
<p><b>function Low(  Arg: TypeOrVariable ):TOrdinal;</b></p>
<p>Returns lowest index of open array or enumerated</p>
</td>
</tr>
<tr>
<td>29</td>
<td>
<p><b>procedure Move(  const source;  var dest;  count: SizeInt );</b></p>
<p>Moves data from one location in memory to another</p>
</td>
</tr>
<tr>
<td>30</td>
<td>
<p><b>procedure MoveChar0(  const buf1;  var buf2;  len: SizeInt);</b></p>
<p>Moves data till first zero character</p>
</td>
</tr>
<tr>
<td>31</td>
<td>
<p><b>procedure New(  var P: Pointer);</b></p>
<p>Dynamically allocate memory for variable</p>
</td>
</tr>
<tr>
<td>32</td>
<td>
<p><b>procedure New(  var P: Pointer;  Cons: TProcedure);</b></p>
<p>Dynamically allocates memory for variable</p>
</td>
</tr>
<tr>
<td>33</td>
<td>
<p><b>function Ofs(  var X ):LongInt;</b></p>
<p>Returns offset of variable</p>
</td>
</tr>
<tr>
<td>34</td>
<td>
<p><b>function ptr(  sel: LongInt;  off: LongInt):farpointer;</b></p>
<p>Combines segment and offset to pointer</p>
</td>
</tr>
<tr>
<td>35</td>
<td>
<p><b>function ReAllocMem(  var p: pointer;  Size: PtrUInt):pointer;</b></p>
<p>Resizes a memory block on the heap</p>
</td>
</tr>
<tr>
<td>36</td>
<td>
<p><b>function Seg(  var X):LongInt;</b></p>
<p>Returns segment</p>
</td>
</tr>
<tr>
<td>37</td>
<td>
<p><b>procedure SetMemoryManager(  const MemMgr: TMemoryManager );</b></p>
<p>Sets a memory manager</p>
</td>
</tr>
<tr>
<td>38</td>
<td>
<p><b>function Sptr: Pointer;</b></p>
<p>Returns current stack pointer</p>
</td>
</tr>
<tr>
<td>39</td>
<td>
<p><b>function Sseg: Word;</b></p>
<p>Returns stack segment register value</p>
</td>
</tr>
</table>
<h1>Pascal - Units</h1>
<p>A Pascal program can consist of modules called units. A unit might consist of some code blocks, which in turn are made up of variables and type declarations, statements, procedures, etc. There are many built-in units in Pascal and Pascal allows programmers to define and write their own units to be used later in various programs.</p>
<h2>Using Built-in Units</h2>
<p>Both the built-in units and user-defined units are included in a program by the uses clause. We have already used the variants unit in <i>Pascal - Variants</i> tutorial. This tutorial explains creating and including user-defined units. However, let us first see how to include a built-in unit <b>crt</b> in your program &minus;</p>
<pre class="result notranslate">
program myprog;
uses crt;
</pre>
<p>The following example illustrates using the <b>crt</b> unit &minus;</p>
<pre class="prettyprint notranslate">
Program Calculate_Area (input, output);
uses crt;
var 
   a, b, c, s, area: real;

begin
   textbackground(white); (* gives a white background *)
   clrscr; (*clears the screen *)
   
   textcolor(green); (* text color is green *)
   gotoxy(30, 4); (* takes the pointer to the 4th line and 30th column) 
   
   writeln('This program calculates area of a triangle:');
   writeln('Area = area = sqrt(s(s-a)(s-b)(s-c))');
   writeln('S stands for semi-perimeter');
   writeln('a, b, c are sides of the triangle');
   writeln('Press any key when you are ready');
   
   readkey;
   clrscr;
   gotoxy(20,3);
   
   write('Enter a: ');
   readln(a);
   gotoxy(20,5);
   
   write('Enter b:');
   readln(b);
   gotoxy(20, 7);
   
   write('Enter c: ');
   readln(c);

   s := (a + b + c)/2.0;
   area := sqrt(s * (s - a)*(s-b)*(s-c));
   gotoxy(20, 9);
   
   writeln('Area: ',area:10:3);
   readkey;
end.
</pre>
<p>It is the same program we used right at the beginning of the Pascal tutorial, compile and run it to find the effects of the change.</p>
<h2>Creating and Using a Pascal Unit</h2>
<p>To create a unit, you need to write the modules or subprograms you want to store in it and save it in a file with <b>.pas</b> extension. The first line of this file should start with the keyword unit followed by the name of the unit. For example &minus;</p>
<pre class="result notranslate">
unit calculateArea;
</pre>
<p>Following are three important steps in creating a Pascal unit &minus;</p>
<ul class="list">
<li><p>The name of the file and the name of the unit should be exactly same. So, our unit <i>calculateArea</i> will be saved in a file named <i>calculateArea.pas.</i></p></li>
<li><p>The next line should consist of a single keyword <b>interface</b>. After this line, you will write the declarations for all the functions and procedures that will come in this unit.</p></li>
<li><p>Right after the function declarations, write the word <b>implementation</b>, which is again a keyword. After the line containing the keyword implementation, provide definition of all the subprograms.</p></li>
</ul>
<p>The following program creates the unit named calculateArea &minus;</p>
<pre class="prettyprint notranslate">
unit CalculateArea;
interface

function RectangleArea( length, width: real): real;
function CircleArea(radius: real) : real;
function TriangleArea( side1, side2, side3: real): real;

implementation

function RectangleArea( length, width: real): real;
begin
   RectangleArea := length * width;
end;

function CircleArea(radius: real) : real;
const
   PI = 3.14159;
begin
   CircleArea := PI * radius * radius;
end;

function TriangleArea( side1, side2, side3: real): real;
var
   s, area: real;

begin
   s := (side1 + side2 + side3)/2.0;
   area := sqrt(s * (s - side1)*(s-side2)*(s-side3));
   TriangleArea := area;
end;

end.
</pre>
<p>Next, let us write a simple program that would use the unit we defined above &minus;</p>
<pre class="prettyprint notranslate">
program AreaCalculation;
uses CalculateArea,crt;

var
   l, w, r, a, b, c, area: real;

begin
   clrscr;
   l := 5.4;
   w := 4.7;
   area := RectangleArea(l, w);
   writeln('Area of Rectangle 5.4 x 4.7 is: ', area:7:3);

   r:= 7.0;
   area:= CircleArea(r);
   writeln('Area of Circle with radius 7.0 is: ', area:7:3);

   a := 3.0;
   b:= 4.0;
   c:= 5.0;
  
   area:= TriangleArea(a, b, c);
   writeln('Area of Triangle 3.0 by 4.0 by 5.0 is: ', area:7:3);
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Area of Rectangle 5.4 x 4.7 is: 25.380
Area of Circle with radius 7.0 is: 153.938
Area of Triangle 3.0 by 4.0 by 5.0 is: 6.000
</pre>
<h1>Pascal - Date and Time</h1>
<p>Most of the softwares you write need implementing some form of date functions returning current date and time. Dates are so much part of everyday life that it becomes easy to work with them without thinking. Pascal also provides powerful tools for date arithmetic that makes manipulating dates easy. However, the actual name and workings of these functions are different for different compilers.</p>
<h2>Getting the Current Date &amp; Time</h2>
<p>Pascal's TimeToString function gives you the current time in a colon(: ) delimited form. The following example shows how to get the current time &minus;</p>
<pre class="prettyprint notranslate tryit">
program TimeDemo;
uses sysutils;

begin
   writeln ('Current time : ',TimeToStr(Time));
end.
</pre>
<p>When the above code was compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Current time : 18:33:08
</pre>
<p>The <b>Date</b> function returns the current date in <b>TDateTime</b> format. The TDateTime is a double value, which needs some decoding and formatting. The following program demonstrates how to use it in your program to display the current date &minus;</p>
<pre class="prettyprint notranslate tryit">
Program DateDemo;
uses sysutils;
var
   YY,MM,DD : Word;

begin
   writeln ('Date : ',Date);
   DeCodeDate (Date,YY,MM,DD);
   writeln (format ('Today is (DD/MM/YY): %d/%d/%d ',[dd,mm,yy]));
end.
</pre>
<p>When the above code was compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Date: 4.111300000000000E+004
Today is (DD/MM/YY):23/7/2012
</pre>
<p>The Now function returns the current date and time &minus;</p>
<pre class="prettyprint notranslate tryit">
Program DatenTimeDemo;
uses sysutils;
begin
   writeln ('Date and Time at the time of writing : ',DateTimeToStr(Now));
end.
</pre>
<p>When the above code was compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Date and Time at the time of writing : 23/7/2012 18:51:
</pre>
<p>Free Pascal provides a simple time stamp structure named <b>TTimeStamp</b>, which has the following format &minus;</p>
<pre class="prettyprint notranslate">
type TTimeStamp = record
   Time: Integer;
   Date: Integer;
end;
</pre>
<h2>Various Date &amp; Time Functions</h2>
<p>Free Pascal provides the following date and time functions &minus;</p>
<table class="table table-bordered">
<tr>
<th style="width:5%;">Sr.No.</th>
<th>Function Name &amp; Description</th>
</tr>
<tr>
<td>1</td>
<td>
<p><b>function DateTimeToFileDate(DateTime: TDateTime):LongInt;</b></p> 
<p>Converts DateTime type to file date.</p></td>
</tr>
<tr>
<td>2</td>
<td>
<p><b>function DateTimeToStr( DateTime: TDateTime):; </b></p>
<p>Constructs string representation of DateTime</p>
</td>
</tr>
<tr>
<td>3</td>
<td>
<p><b>function DateTimeToStr(DateTime: TDateTime; const FormatSettings: TFormatSettings):;</b></p>
<p>Constructs string representation of DateTime</p>
</td>
</tr>
<tr>
<td>4</td>
<td>
<p><b>procedure DateTimeToString(out Result: ;const FormatStr: ;const DateTime: TDateTime);</b></p> 
<p>Constructs string representation of DateTime</p>
</td>
</tr>
<tr>
<td>5</td>
<td>
<p><b>procedure DateTimeToString(out Result: ; const FormatStr: ; const DateTime: TDateTime; const FormatSettings: TFormatSettings);</b></p>
<p>Constructs string representation of DateTime</p>
</td>
</tr>
<tr>
<td>6</td>
<td>
<p><b>procedure DateTimeToSystemTime(DateTime: TDateTime; out SystemTime: TSystemTime);</b></p>
<p>Converts DateTime to system time</p>
</td>
</tr>
<tr>
<td>7</td>
<td>
<p><b>function DateTimeToTimeStamp( DateTime: TDateTime):TTimeStamp;</b>Converts DateTime to timestamp</p></td>
</tr>
<tr>
<td>8</td>
<td>
<p><b>function DateToStr(Date: TDateTime):;</b></p> 
<p>Constructs string representation of date</p>
</td>
</tr>
<tr>
<td>9</td>
<td>
<p><b>function DateToStr(Date: TDateTime; const FormatSettings: TFormatSettings):;</b></p> 
<p>Constructs string representation of date</p>
</td>
</tr>
<tr>
<td>10</td>
<td>
<p><b>function Date: TDateTime;</b></p> 
<p>Gets current date</p>
</td>
</tr>
<tr>
<td>11</td>
<td>
<p><b>function DayOfWeek(DateTime: TDateTime):Integer;</b></p> 
<p>Gets day of week</p>
</td>
</tr>
<tr>
<td>12</td>
<td>
<p><b>procedure DecodeDate(Date: TDateTime; out Year: Word; out Month: Word; out Day: Word);</b></p> 
<p>Decodes DateTime to year month and day</p>
</td>
</tr>
<tr>
<td>13</td>
<td>
<p><b>procedure DecodeTime(Time: TDateTime; out Hour: Word; out Minute: Word; out Second: Word;  out MilliSecond: Word);</b></p> 
<p>Decodes DateTime to hours, minutes and seconds</p>
</td>
</tr>
<tr>
<td>14</td>
<td>
<p><b>function EncodeDate(Year: Word; Month: Word; Day: Word):TDateTime; </b></p> 
<p>Encodes year, day and month to DateTime</p>
</td>
</tr>
<tr>
<td>15</td>
<td>
<p><b>function EncodeTime(Hour: Word; Minute: Word; Second: Word; MilliSecond: Word):TDateTime; </b></p> 
<p>Encodes hours, minutes and seconds to DateTime</p>
</td>
</tr>
<tr>
<td>16</td>
<td>
<p><b>function FormatDateTime(const FormatStr: ; DateTime: TDateTime):;</b></p> 
<p>Returns string representation of DateTime</p>
</td>
</tr>
<tr>
<td>17</td>
<td>
<p><b>function FormatDateTime(const FormatStr: ; DateTime: TDateTime; const FormatSettings: TFormatSettings):;</b></p> 
<p>Returns string representation of DateTime</p>
</td>
</tr>
<tr>
<td>18</td>
<td>
<p><b>function IncMonth(const DateTime: TDateTime; NumberOfMonths: Integer = 1):TDateTime;</b></p> 
<p>Adds 1 to month</p>
</td>
</tr>
<tr>
<td>19</td>
<td>
<p><b>function IsLeapYear(Year: Word):Boolean;</b></p> 
<p>Determines if year is leap year</p>
</td>
</tr>
<tr>
<td>20</td>
<td>
<p><b>function MSecsToTimeStamp(MSecs: Comp):TTimeStamp;</b></p> 
<p>Converts number of milliseconds to timestamp</p>
</td>
</tr>
<tr>
<td>21</td>
<td>
<p><b>function Now: TDateTime;</b></p> 
<p>Gets current date and time</p>
</td>
</tr>
<tr>
<td>22</td>
<td>
<p><b>function StrToDateTime(const S:):TDateTime;</b></p> 
<p>Converts string to DateTime</p>
</td>
</tr>
<tr>
<td>23</td>
<td>
<p><b>function StrToDateTime(const s: ShortString; const FormatSettings: TFormatSettings):TDateTime;</b></p> 
<p>Converts string to DateTime</p>
</td>
</tr>
<tr>
<td>24</td>
<td>
<p><b>function StrToDateTime(const s: AnsiString; const FormatSettings: TFormatSettings):TDateTime;</b></p> 
<p>Converts string to DateTime</p>
</td>
</tr>
<tr>
<td>25</td>
<td>
<p><b>function StrToDate(const S: ShortString):TDateTime;</b></p> 
<p>Converts string to date</p>
</td>
</tr>
<tr>
<td>26</td>
<td>
<p><b>function StrToDate(const S: Ansistring):TDateTime;</b></p> 
<p>Converts string to date</p>
</td>
</tr>
<tr>
<td>27</td>
<td>
<p><b>function StrToDate(const S: ShortString; separator: Char):TDateTime;</b></p> 
<p>Converts string to date</p>
</td>
</tr>
<tr>
<td>28</td>
<td>
<p><b>function StrToDate(const S: AnsiString; separator: Char):TDateTime;</b></p> 
<p>Converts string to date</p>
</td>
</tr>
<tr>
<td>29</td>
<td>
<p><b>function StrToDate(const S: ShortString; const useformat: ; separator: Char):TDateTime;
</b></p>
<p>Converts string to date</p>
</td>
</tr>
<tr>
<td>30</td>
<td>
<p><b>function StrToDate(const S: AnsiString; const useformat: ; separator: Char):TDateTime;</b></p>
<p>Converts string to date</p>
</td>
</tr>
<tr>
<td>31</td>
<td>
<p><b>function StrToDate(const S: PChar; Len: Integer; const useformat: ; separator: Char = #0):TDateTime;</b></p> 
<p>Converts string to date</p>
</td>
</tr>
<tr>
<td>32</td>
<td>
<p><b>function StrToTime(const S: Shortstring):TDateTime;</b></p> 
<p>Converts string to time</p>
</td>
</tr>
<tr>
<td>33</td>
<td>
<p><b>function StrToTime(const S: Ansistring):TDateTime;</b></p> 
<p>Converts string to time</p>
</td>
</tr>
<tr>
<td>34</td>
<td>
<p><b>function StrToTime(const S: ShortString; separator: Char):TDateTime;</b></p> 
<p>Converts string to time</p>
</td>
</tr>
<tr>
<td>35</td>
<td>
<p><b>function StrToTime(const S: AnsiString; separator: Char):TDateTime;</b></p> 
<p>Converts string to time</p>
</td>
</tr>
<tr>
<td>36</td>
<td>
<p><b>function StrToTime(const S: ; FormatSettings: TFormatSettings):TDateTime;</b></p> 
<p>Converts string to time</p>
</td>
</tr>
<tr>
<td>37</td>
<td>
<p><b>function StrToTime(const S: PChar; Len: Integer; separator: Char = #0):TDateTime;</b></p> 
<p>Converts string to time</p>
</td>
</tr>
<tr>
<td>38</td>
<td>
<p><b>function SystemTimeToDateTime(const SystemTime: TSystemTime):TDateTime;</b></p> 
<p>Converts system time to datetime</p>
</td>
</tr>
<tr>
<td>39</td>
<td>
<p><b>function TimeStampToDateTime(const TimeStamp: TTimeStamp):TDateTime;</b></p> 
<p>Converts time stamp to DateTime</p>
</td>
</tr>
<tr>
<td>40</td>
<td>
<p><b>function TimeStampToMSecs(const TimeStamp: TTimeStamp):comp;</b></p>
<p>Converts Timestamp to number of milliseconds</p>
</td>
</tr>
<tr>
<td>41</td>
<td>
<p><b>function TimeToStr(Time: TDateTime):;</b></p>
<p>Returns string representation of Time</p>
</td>
</tr>
<tr>
<td>42</td>
<td>
<p><b>function TimeToStr(Time: TDateTime; const FormatSettings: TFormatSettings):;</b></p>
<p>Returns string representation of Time</p>
</td>
</tr>
<tr>
<td>43</td>
<td>
<p><b>function Time: TDateTime;</b></p>
<p>Get current time</p>
</td>
</tr>
</table>
<p>The following example illustrates the use of some of the above functions &minus;</p>
<pre class="prettyprint notranslate tryit">
Program DatenTimeDemo;
uses sysutils;
var
year, month, day, hr, min, sec, ms: Word;

begin
   writeln ('Date and Time at the time of writing : ',DateTimeToStr(Now));
   writeln('Today is ',LongDayNames[DayOfWeek(Date)]);
   writeln;
   writeln('Details of Date: ');
   
   DecodeDate(Date,year,month,day);
   writeln (Format ('Day: %d',[day]));
   writeln (Format ('Month: %d',[month]));
   writeln (Format ('Year: %d',[year]));
   writeln;
   writeln('Details of Time: ');
   
   DecodeTime(Time,hr, min, sec, ms);
   writeln (format('Hour: %d:',[hr]));
   writeln (format('Minutes: %d:',[min]));
   writeln (format('Seconds: %d:',[sec]));
   writeln (format('Milliseconds: %d:',[hr]));
end.
</pre>
<p>When the above code was compiled and executed, it produced the following result:</p>
<pre class="result notranslate">
Date and Time at the time of writing : 7/24/2012 8:26:
Today is Tuesday
Details of Date:
Day:24
Month:7
Year: 2012
Details of Time:
Hour: 8
Minutes: 26
Seconds: 21
Milliseconds: 8
</pre>
<h1>Pascal - Object Oriented</h1>
<p>We can imagine our universe made of different objects like sun, earth, moon, etc. Similarly, we can imagine our car made of different objects like wheel, steering, gear, etc. Same way, there are object-oriented programming concepts, which assume everything as an object and implement a software using different objects. In Pascal, there are two structural data types used to implement a real world object &minus;</p>
<ul class="list">
<li>Object types</li>
<li>Class types</li>
</ul>
<h2>Object-Oriented Concepts</h2>
<p>Before we go in detail, let's define important Pascal terms related to Object-Oriented Pascal.</p>
<ul class="list">
<li><p><b>Object</b> &minus; An Object is a special kind of record that contains fields like a record; however, unlike records, objects contain procedures and functions as part of the object. These procedures and functions are held as pointers to the methods associated with the object's type.</p></li>
<li><p><b>Class</b> &minus; A Class is defined in almost the same way as an Object, but there is a difference in way they are created. The Class is allocated on the Heap of a program, whereas the Object is allocated on the Stack. It is a pointer to the object, not the object itself.</p></li>
<li><p><b>Instantiation of a class</b> &minus; Instantiation means creating a variable of that class type. Since a class is just a pointer, when a variable of a class type is declared, there is memory allocated only for the pointer, not for the entire object. Only when it is instantiated using one of its constructors, memory is allocated for the object. Instances of a class are also called 'objects', but do not confuse them with Object Pascal Objects. In this tutorial, we will write 'Object' for Pascal Objects and 'object' for the conceptual object or class instance.</p></li>
<li><p><b>Member Variables</b> &minus; These are the variables defined inside a Class or an Object.</p></li>
<li><p><b>Member Functions</b> &minus; These are the functions or procedures defined inside a Class or an Object and are used to access object data.</p></li>
<li><p><b>Visibility of Members</b> &minus; The members of an Object or Class are also called the fields. These fields have different visibilities. Visibility refers to accessibility of the members, i.e., exactly where these members will be accessible. Objects have three visibility levels: public, private and protected. Classes have five visibility types: public, private, strictly private, protected and published. We will discuss visibility in details.</p></li>
<li><p><b>Inheritance</b> &minus; When a Class is defined by inheriting existing functionalities of a parent Class, then it is said to be inherited. Here child class will inherit all or few member functions and variables of a parent class. Objects can also be inherited.</p></li>
<li><p><b>Parent Class</b> &minus; A Class that is inherited by another Class. This is also called a base class or super class.</p></li>
<li><p><b>Child Class</b> &minus; A class that inherits from another class. This is also called a subclass or derived class.</p></li>
<li><p><b>Polymorphism</b> &minus; This is an object-oriented concept where same function can be used for different purposes. For example, function name will remain same but it may take different number of arguments and can do different tasks. Pascal classes implement polymorphism. Objects do not implement polymorphism. </p></li>
<li><p><b>Overloading</b> &minus; It is a type of polymorphism in which some or all of operators have different implementations depending on the types of their arguments. Similarly functions can also be overloaded with different implementation. Pascal classes implement overloading, but the Objects do not. </p></li>
<li><p><b>Data Abstraction</b> &minus; Any representation of data in which the implementation details are hidden (abstracted).</p></li>
<li><p><b>Encapsulation</b> &minus; Refers to a concept where we encapsulate all the data and member functions together to form an object.</p></li>
<li><p><b>Constructor</b> &minus; Refers to a special type of function which will be called automatically whenever there is an object formation from a class or an Object.</p></li>
<li><p><b>Destructor</b> &minus; Refers to a special type of function which will be called automatically whenever an Object or Class is deleted or goes out of scope.</p></li>
</ul>
<h2>Defining Pascal Objects</h2>
<p>An object is declared using the type declaration. The general form of an object declaration is as follows &minus;</p>
<pre class="prettyprint notranslate">
type object-identifier = object  
   private
   field1 : field-type;  
   field2 : field-type;  
   ...
   public
   procedure proc1;  
   function f1(): function-type;
   end;  
var objectvar : object-identifier;
</pre>
<p>Let us define a Rectangle Object that has two integer type data members - <b>length</b> and <b>width</b> and some member functions to manipulate these data members and a procedure to draw the rectangle.</p>
<pre class="prettyprint notranslate">
type 
   Rectangle = object  
   private  
      length, width: integer; 
   
   public  
      constructor init;  
      destructor done;  
      
      procedure setlength(l: inteter);  
      function getlength(): integer;  
      
      procedure setwidth(w: integer);  
      function getwidth(): integer;  
      
      procedure draw;
end;
var
   r1: Rectangle;
   pr1: ^Rectangle;
</pre>
<p>After creating your objects, you will be able to call member functions related to that object. One member function will be able to process member variable of related object only.</p>
<p>Following example shows how to set lengths and widths for two rectangle objects and draw them by calling the member functions.</p>
<pre class="prettyprint notranslate">
r1.setlength(3);
r1.setwidth(7);

writeln(' Draw a rectangle: ', r1.getlength(), ' by ' , r1.getwidth());
r1.draw;
new(pr1);
pr1^.setlength(5);
pr1^.setwidth(4);

writeln(' Draw a rectangle: ', pr1^.getlength(), ' by ' ,pr1^.getwidth());
pr1^.draw;
dispose(pr1);
</pre>
<p>Following is a complete example to show how to use objects in Pascal &minus;</p>
<pre class="prettyprint notranslate tryit">
program exObjects;
type 
   Rectangle = object  
   private  
      length, width: integer; 
   
   public  
      procedure setlength(l: integer);
      function getlength(): integer;  
      
      procedure setwidth(w: integer);  
      function getwidth(): integer;  
      
      procedure draw;
end;
var
   r1: Rectangle;
   pr1: ^Rectangle;

procedure Rectangle.setlength(l: integer);
begin
   length := l;
end;

procedure Rectangle.setwidth(w: integer);
begin
   width :=w;
end;

function Rectangle.getlength(): integer;  
begin
   getlength := length;
end;

function Rectangle.getwidth(): integer;  
begin
   getwidth := width;
end;

procedure Rectangle.draw;
var 
   i, j: integer;
begin
   for i:= 1 to length do
   begin
     for j:= 1 to width do
        write(' * ');
     writeln;
   end;
end;

begin
   r1.setlength(3);
   r1.setwidth(7);
   
   writeln('Draw a rectangle:', r1.getlength(), ' by ' , r1.getwidth());
   r1.draw;
   new(pr1);
   pr1^.setlength(5);
   pr1^.setwidth(4);
   
   writeln('Draw a rectangle:', pr1^.getlength(), ' by ' ,pr1^.getwidth());
   pr1^.draw;
   dispose(pr1);
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Draw a rectangle: 3 by 7
* * * * * * *
* * * * * * *
* * * * * * *
Draw a rectangle: 5 by 4
* * * *
* * * *
* * * *
* * * *
* * * *
</pre>
<h2>Visibility of the Object Members</h2>
<p>Visibility indicates the accessibility of the object members. Pascal object members have three types of visibility &minus;</p>
<table class="table table-bordered">
<tr>
<th>Visibility</th>
<th>Accessibility</th>
</tr>
<tr>
<td>Public</td>
<td>The members can be used by other units outside the program unit</td>
</tr>
<tr>
<td>Private</td>
<td>The members are only accessible in the current unit.</td>
</tr>
<tr>
<td>Protected</td>
<td>The members are available only to objects descended from the parent object.</td>
</tr>
</table>
<p>By default, fields and methods of an object are public and are exported outside the current unit.</p>
<h2>Constructors and Destructors for Pascal Objects:</h2>
<p><b>Constructors</b> are special type of methods, which are called automatically whenever an object is created. You create a constructor in Pascal just by declaring a method with a keyword constructor. Conventionally, the method name is Init, however, you can provide any valid identifier of your own. You can pass as many arguments as you like into the constructor function.</p>
<p><b>Destructors</b> are methods that are called during the destruction of the object. The destructor methods destroy any memory allocation created by constructors.</p>
<p>Following example will provide a constructor and a destructor for the Rectangle class which will initialize length and width for the rectangle at the time of object creation and destroy it when it goes out of scope.</p>
<pre class="prettyprint notranslate tryit">
program exObjects;
type 
   Rectangle = object  
   private  
      length, width: integer; 
   public  
      constructor init(l, w: integer);
      destructor done;
      
      procedure setlength(l: integer);
      function getlength(): integer;  
      
      procedure setwidth(w: integer);  
      function getwidth(): integer;  
      
      procedure draw;
end;

var
   r1: Rectangle;
   pr1: ^Rectangle;

constructor Rectangle.init(l, w: integer);
begin
   length := l;
   width := w;
end;

destructor Rectangle.done;
begin
   writeln(' Desctructor Called');
end; 

procedure Rectangle.setlength(l: integer);
begin
   length := l;
end;

procedure Rectangle.setwidth(w: integer);
begin
   width :=w;
end;

function Rectangle.getlength(): integer;  
begin
   getlength := length;
end;

function Rectangle.getwidth(): integer;  
begin
   getwidth := width;
end;

procedure Rectangle.draw;
var 
   i, j: integer;
begin
   for i:= 1 to length do
   begin
      for j:= 1 to width do
         write(' * ');
      writeln;
   end;
end;

begin
   r1.init(3, 7);
   writeln('Draw a rectangle:', r1.getlength(), ' by ' , r1.getwidth());
   r1.draw;
   new(pr1, init(5, 4));
   
   writeln('Draw a rectangle:', pr1^.getlength(), ' by ',pr1^.getwidth());
   pr1^.draw;
   pr1^.init(7, 9);
   
   writeln('Draw a rectangle:', pr1^.getlength(), ' by ' ,pr1^.getwidth());
   pr1^.draw;
   dispose(pr1);
   r1.done;
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Draw a rectangle: 3 by 7
* * * * * * *
* * * * * * *
* * * * * * *
Draw a rectangle: 5 by 4
* * * *
* * * *
* * * *
* * * *
* * * *
Draw a rectangle: 7 by 9
* * * * * * * * *
* * * * * * * * *
* * * * * * * * *
* * * * * * * * *
* * * * * * * * *
* * * * * * * * *
* * * * * * * * *
Destructor Called
</pre>
<h2>Inheritance for Pascal Objects</h2>
<p>Pascal objects can optionally inherit from a parent object. The following program illustrates inheritance in Pascal Objects. Let us create another object named <b>TableTop</b>, which is inheriting from the Rectangle object.</p>
<pre class="prettyprint notranslate tryit">
program exObjects;
type 
   Rectangle = object  
   private  
      length, width: integer; 
   public  
      procedure setlength(l: integer);  
      function getlength(): integer;  
      procedure setwidth(w: integer);  
      function getwidth(): integer;  
      procedure draw;
end;

TableTop = object (Rectangle)
   private
     material: string;
   public
      function getmaterial(): string;
      procedure setmaterial( m: string);
      procedure displaydetails;
      procedure draw;
end;

var
   tt1: TableTop;

procedure Rectangle.setlength(l: integer);
begin
   length := l;
end;

procedure Rectangle.setwidth(w: integer);
begin
   width :=w;
end;

function Rectangle.getlength(): integer;  
begin
   getlength := length;
end;

function Rectangle.getwidth():integer;
begin
   getwidth := width;
end;

procedure Rectangle.draw;
var 
   i, j: integer;
begin
   for i:= 1 to length do
   begin
      for j:= 1 to width do
         write(' * ');
      writeln;
  end;
end;

function TableTop.getmaterial(): string;
begin
   getmaterial := material;
end;

procedure TableTop.setmaterial( m: string);
begin
   material := m;
end;

procedure TableTop.displaydetails;
begin
   writeln('Table Top: ', self.getlength(), ' by ' , self.getwidth());
   writeln('Material: ', self.getmaterial());
end;

procedure TableTop.draw();
var
   i, j: integer;
begin
   for i:= 1 to length do
   begin
      for j:= 1 to width do
         write(' * ');
   writeln;
   end;
   writeln('Material: ', material);
end;

begin
   tt1.setlength(3);
   tt1.setwidth(7);
   tt1.setmaterial('Wood');
   tt1.displaydetails();
   writeln;
   writeln('Calling the Draw method');
   tt1.draw();
end.
</pre>
<p>Following are the important points which should be noted down &minus;</p>
<ul class="list">
<li><p>The object <i>Tabletop</i> has inherited all the members of the Rectangle object. </p></li>
<li><p>There is a draw method in <i>TableTop</i> also. When the <i>draw</i> method is called using a <i>TableTop</i> object, TableTop's draw gets invoked.</p></li>
<li><p>There is an implicit instance named <b>self</b> that refers to the current instance of the object.</p></li>
</ul>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Table Top: 3 by 7
Material: Wood

Calling the Draw Method 
* * * * * * *
* * * * * * *
* * * * * * *
Material: Wood
</pre>
<h1>Pascal - Classes</h1>
<p>You have seen that Pascal Objects exhibit some characteristics of object-oriented paradigm. They implement encapsulation, data hiding and inheritance, but they also have limitations. For example, Pascal Objects do not take part in polymorphism. So classes are widely used to implement proper object-oriented behavior in a program, especially the GUI-based software.</p>
<p>A Class is defined in almost the same way as an Object, but is a pointer to an Object rather than the Object itself. Technically, this means that the Class is allocated on the Heap of a program, whereas the Object is allocated on the Stack. In other words, when you declare a variable the object type, it will take up as much space on the stack as the size of the object, but when you declare a variable of the class type, it will always take the size of a pointer on the stack. The actual class data will be on the heap.</p>
<h2>Defining Pascal Classes</h2>
<p>A class is declared in the same way as an object, using the type declaration. The general form of a class declaration is as follows &minus;</p>
<pre class="prettyprint notranslate">
type class-identifier = class  
   private
      field1 : field-type;  
      field2 : field-type;  
        ...
   
   public
      constructor create();
      procedure proc1;  
      function f1(): function-type;
end;  
var classvar : class-identifier;
</pre>
<p>Its worth to note following important points &minus;</p>
<ul class="list">
<li><p>Class definitions should come under the type declaration part of the program only.</p></li>
<li><p>A class is defined using the <b>class</b> keyword.</p></li>
<li><p>Fields are data items that exist in each instance of the class.</p></li>
<li><p>Methods are declared within the definition of a class.</p></li>
<li><p>There is a predefined constructor called <b>Create</b> in the Root class.  Every abstract class and every concrete class is a descendant of Root, so all classes have at least one constructor.</p></li>
<li><p>There is a predefined destructor called <b>Destroy</b> in the Root class.  Every abstract class and every concrete class is a descendant of Root, so, all classes have at least one destructor.</p></li>
</ul>
<p>Let us define a Rectangle class that has two integer type data members - length and width and some member functions to manipulate these data members and a procedure to draw the rectangle.</p>
<pre class="prettyprint notranslate">
type
   Rectangle = class
   private
      length, width: integer;
   
   public
      constructor create(l, w: integer);
      procedure setlength(l: integer);
      function getlength(): integer;
      procedure setwidth(w: integer);
      function getwidth(): integer;
      procedure draw;
end;
</pre>
<p>Let us write a complete program that would create an instance of a rectangle class and draw the rectangle. This is the same example we used while discussing Pascal Objects. You will find both programs are almost same, with the following exceptions &minus;</p>
<ul class="list">
<li><p>You will need to include the {$mode objfpc} directive for using the classes.</p></li>
<li><p>You will need to include the {$m+} directive for using constructors.</p></li>
<li><p>Class instantiation is different than object instantiation. Only declaring the variable does not create space for the instance, you will use the constructor create to allocate memory.</p></li>
</ul>
<p>Here is the complete example &minus;</p>
<pre class="prettyprint notranslate tryit">
{$mode objfpc} // directive to be used for defining classes
{$m+}		   // directive to be used for using constructor

program exClass;
type
   Rectangle = class
   private
      length, width: integer;
   
   public
      constructor create(l, w: integer);
      procedure setlength(l: integer);
      
      function getlength(): integer;
      procedure setwidth(w: integer);
      
      function getwidth(): integer;
      procedure draw;
end;
var
   r1: Rectangle;

constructor Rectangle.create(l, w: integer);
begin
   length := l;
   width := w;
end;

procedure Rectangle.setlength(l: integer);
begin
   length := l;
end;

procedure Rectangle.setwidth(w: integer);
begin
   width :=w;
end;

function Rectangle.getlength(): integer;
begin
   getlength := length;
end;

function Rectangle.getwidth(): integer;
begin
   getwidth := width;
end;

procedure Rectangle.draw;
var
   i, j: integer;
begin
   for i:= 1 to length do
   begin
      for j:= 1 to width do
         write(' * ');
      writeln;
   end;
end;

begin
   r1:= Rectangle.create(3, 7);
   
   writeln(' Draw Rectangle: ', r1.getlength(), ' by ' , r1.getwidth());
   r1.draw;
   r1.setlength(4);
   r1.setwidth(6);
   
   writeln(' Draw Rectangle: ', r1.getlength(), ' by ' , r1.getwidth());
   r1.draw;
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Draw Rectangle: 3 by 7
* * * * * * *
* * * * * * *
* * * * * * *
Draw Rectangle: 4 by 6
* * * * * * 
* * * * * * 
* * * * * * 
* * * * * * 
</pre>
<h2>Visibility of the Class Members</h2>
<p>Visibility indicates the accessibility of the class members. Pascal class members have five types of visibility &minus;</p>
<table class="table table-bordered">
<tr>
<th style="width:25%;">Visibility</th>
<th>Accessibility</th>
</tr>
<tr>
<td>Public</td>
<td>These members are always accessible.</td>
</tr>
<tr>
<td>Private</td>
<td>These members can only be accessed in the module or unit that contains the class definition. They can be accessed from inside the class methods or from outside them.</td>
</tr>
<tr>
<td>Strict Private</td>
<td>These members can only be accessed from methods of the class itself. Other classes or descendent classes in the same unit cannot access them.</td>
</tr>
<tr>
<td>Protected</td>
<td>This is same as private, except, these members are accessible to descendent types, even if they are implemented in other modules.</td>
</tr>
<tr>
<td>Published</td>
<td>This is same as a Public, but the compiler generates type information that is needed for automatic streaming of these classes if the compiler is in the {$M+} state. Fields defined in a published section must be of class type.</td>
</tr>
</table>
<h2>Constructors and Destructors for Pascal Classes</h2>
<p>Constructors are special methods, which are called automatically whenever an object is created. So we take full advantage of this behavior by initializing many things through constructor functions.</p>
<p>Pascal provides a special function called create() to define a constructor. You can pass as many arguments as you like into the constructor function.</p>
<p>Following example will create one constructor for a class named Books and it will initialize price and title for the book at the time of object creation.</p>
<pre class="prettyprint notranslate tryit">
program classExample;

{$MODE OBJFPC} //directive to be used for creating classes
{$M+} //directive that allows class constructors and destructors
type
   Books = Class 
   private 
      title : String; 
      price: real;
   
   public
      constructor Create(t : String; p: real); //default constructor
      
      procedure setTitle(t : String); //sets title for a book
      function getTitle() : String; //retrieves title
      
      procedure setPrice(p : real); //sets price for a book
      function getPrice() : real; //retrieves price
      
      procedure Display(); // display details of a book
end;
var
   physics, chemistry, maths: Books;

//default constructor 
constructor Books.Create(t : String; p: real);
begin
   title := t;
   price := p;
end;

procedure Books.setTitle(t : String); //sets title for a book
begin
   title := t;
end;

function Books.getTitle() : String; //retrieves title
begin
   getTitle := title;
end;

procedure Books.setPrice(p : real); //sets price for a book
begin
   price := p;
end;

function Books.getPrice() : real; //retrieves price
begin
   getPrice:= price;
end;

procedure Books.Display();
begin
   writeln('Title: ', title);
   writeln('Price: ', price:5:2);
end;

begin 
   physics := Books.Create('Physics for High School', 10);
   chemistry := Books.Create('Advanced Chemistry', 15);
   maths := Books.Create('Algebra', 7);
   
   physics.Display;
   chemistry.Display;
   maths.Display;
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Title: Physics for High School
Price: 10
Title: Advanced Chemistry
Price: 15
Title: Algebra
Price: 7
</pre>
<p>Like the implicit constructor named create, there is also an implicit destructor method destroy using which you can release all the resources used in the class.</p>
<h2>Inheritance</h2>
<p>Pascal class definitions can optionally inherit from a parent class definition. The syntax is as follows &minus;</p>
<pre class="prettyprint notranslate">
type
childClas-identifier = class(baseClass-identifier) 
&lt; members &gt;
end; 
</pre>
<p>Following example provides a novels class, which inherits the Books class and adds more functionality based on the requirement.</p>
<pre class="prettyprint notranslate tryit">
program inheritanceExample;

{$MODE OBJFPC} //directive to be used for creating classes
{$M+} //directive that allows class constructors and destructors

type
   Books = Class 
   protected 
      title : String; 
      price: real;
   
   public
      constructor Create(t : String; p: real); //default constructor
      
      procedure setTitle(t : String); //sets title for a book
      function getTitle() : String; //retrieves title
      
      procedure setPrice(p : real); //sets price for a book
      function getPrice() : real; //retrieves price
      
      procedure Display(); virtual; // display details of a book
end;
(* Creating a derived class *)

type
   Novels = Class(Books)
   private
      author: String;
   
   public
      constructor Create(t: String); overload;
      constructor Create(a: String; t: String; p: real); overload;
      
      procedure setAuthor(a: String); // sets author for a book
      function getAuthor(): String; // retrieves author name
      
      procedure Display(); override;
end;
var
   n1, n2: Novels;

//default constructor 
constructor Books.Create(t : String; p: real);
begin
   title := t;
   price := p;
end;

procedure Books.setTitle(t : String); //sets title for a book
begin
   title := t;
end;

function Books.getTitle() : String; //retrieves title
begin
   getTitle := title;
end;

procedure Books.setPrice(p : real); //sets price for a book
begin
   price := p;
end;

function Books.getPrice() : real; //retrieves price
begin
   getPrice:= price;
end;

procedure Books.Display();
begin
   writeln('Title: ', title);
   writeln('Price: ', price);
end;

(* Now the derived class methods  *)
constructor Novels.Create(t: String);
begin
   inherited Create(t, 0.0);
   author:= ' ';
end;

constructor Novels.Create(a: String; t: String; p: real);
begin
   inherited Create(t, p);
   author:= a;
end;

procedure Novels.setAuthor(a : String); //sets author for a book
begin
   author := a;
end;

function Novels.getAuthor() : String; //retrieves author
begin
   getAuthor := author;
end;

procedure Novels.Display();
begin
   writeln('Title: ', title);
   writeln('Price: ', price:5:2);
   writeln('Author: ', author);
end;

begin 
   n1 := Novels.Create('Gone with the Wind');
   n2 := Novels.Create('Ayn Rand','Atlas Shrugged', 467.75);
   n1.setAuthor('Margaret Mitchell');
   n1.setPrice(375.99);
   n1.Display;
   n2.Display;
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Title: Gone with the Wind
Price: 375.99
Author: Margaret Mitchell
Title: Atlas Shrugged
Price: 467.75
Author: Ayn Rand
</pre>
<p>Its worth to note following important points &minus;</p>
<ul class="list">
<li><p>The members of the Books class have <b>protected</b> visibility. </p></li>
<li><p>The Novels class has two constructors, so the <b>overload</b> operator is used for function overloading.</p></li>
<li><p>The Books.Display procedure has been declared <b>virtual</b>, so that the same method from the Novels class can <b>override</b> it. </p></li>
<li><p>The Novels.Create constructor calls the base class constructor using the <b>inherited</b> keyword. </p></li>
</ul>
<h2>Interfaces</h2>
<p>Interfaces are defined to provide a common function name to the implementers. Different implementers can implement those interfaces according to their requirements. You can say, interfaces are skeletons, which are implemented by developers. Following is an example of interface &minus;</p>
<pre class="prettyprint notranslate">
type  
   Mail = Interface  
      Procedure SendMail;  
      Procedure GetMail;  
   end;  
   
   Report = Class(TInterfacedObject,  Mail)  
      Procedure SendMail;  
      Procedure GetMail;  
   end;  
</pre>
<p>Please note that, when a class implements an interface, it should implement all methods of the interface. If a method of an interface is not implemented, then the compiler will give an error.</p>
<h2>Abstract Classes</h2>
<p>An abstract class is one that cannot be instantiated, only inherited. An abstract class is specified by including the word symbol abstract in the class definition, like this &minus;</p>
<pre class="prettyprint notranslate">
type
   Shape = ABSTRACT CLASS (Root)
      Procedure draw; ABSTRACT;
      ...
   end;
</pre>
<p>When inheriting from an abstract class, all methods marked abstract in the parent's class declaration must be defined by the child; additionally, these methods must be defined with the same visibility.</p>
<h2>Static Keyword</h2>
<p>Declaring class members or methods as static makes them accessible without needing an instantiation of the class. A member declared as static cannot be accessed with an instantiated class object (though a static method can). The following example illustrates the concept &minus;</p>
<pre class="prettyprint notranslate tryit">
program StaticExample;
{$mode objfpc}
{$static on}
type
   myclass=class
      num : integer;static;
   end;
var
   n1, n2 : myclass;
begin
   n1:= myclass.create;
   n2:= myclass.create;
   n1.num := 12;
   writeln(n2.num);
   n2.num := 31;
   writeln(n1.num);
   writeln(myclass.num);
   myclass.num := myclass.num + 20;
   writeln(n1.num);
   writeln(n2.num);
end.
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
12
31
31
51
51
</pre>

<title>Pascal Useful Resources</title>

<h1>Pascal - Useful Resources</h1>

<p>The following resources contain additional information on Pascal. Please use them to get more in-depth knowledge on this topic.</p>

<h2>Useful Links on Pascal</h2>

<p><a target="_blank" rel="nofollow" href="http://www.freepascal.org/download.var">Free Pascal Compiler</a> &minus; The official website Open source Pascal compiler.</p>

<p><a target="_blank" rel="nofollow" href="http://www.freepascal.org/docs.var">Free pascal Documentation</a>  &minus; A complete guide for Free Pascal programming.</p>

<p><a target="_blank" rel="nofollow" href="http://www.gnu-pascal.de/gpc/h-index.html">GNU Pascal</a>  &minus; Home site of GNU Pascal, the free 32/64-bit Pascal compiler!</p>

<p><a target="_blank" rel="nofollow" href="http://www.gnu-pascal.de/gpc/">GNU Pascal Manual</a>  &minus; This manual documents how to run, install and maintain the GNU Pascal Compiler (GPC), as well as its new features and incompatibilities.</p>

<h2>Useful Books on Pascal</h2>

<p>To enlist your site on this page, please drop an email to <b>contact@tutorialspoint.com</b></p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Discuss Pascal</title>

<h1>Discuss Pascal</h1>

<p>Pascal is a procedural programming language, designed in 1968 and published in 1970 by Niklaus Wirth and named in honour of the French mathematician and philosopher Blaise Pascal. Pascal runs on a variety of platforms, such as Windows, Mac OS, and various versions of UNIX/Linux.</p>

<p>This tutorial will give you great understanding of Pascal to proceed with Delphi and other related frameworks etc.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

</body></html>