<!DOCTYPE html><html><body><title>Go Tutorial</title>

<h1>Go Tutorial</h1>

<p>Go language, is a programming language initially developed at Google in year 2007 by Robert Griesemer, Rob Pike, and Ken Thompson. Go programming language is a statically-typed language with syntax similar to that of C. It provides garbage collection, type safety, dynamic-typing capability, many advanced built-in types such as variable length arrays and key-value maps. It also provides a rich standard library.</p>

<p>The Go programming language was announced in November 2009 and is used in some of the Google's production systems.</p>

<h1>Audience</h1>

<p>This tutorial is designed for software programmers with a need to understand the Go programming language starting from scratch. This tutorial will give you enough understanding on Go programming language from where you can take yourself to higher level of expertise.</p>

<h1>Prerequisites</h1>

<p>Before proceeding with this tutorial, you should have a basic understanding of Computer Programming terminologies. A basic understanding of any of the programming languages will help you in understanding the Go programming concepts and move fast on the learning track.</p>

<h1>Compile/Execute Go Programs</h1>

<p>For most of the examples given in this tutorial, you will find <b>Try it</b> option, so just make use of it and enjoy your learning.</p>

<p>Try following example using <b>Try it</b> option available at the top right corner of the below sample code box:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   fmt.Println("Hello, World!")
}
</pre>

<title>Go Overview</title>

<h1>Go - Overview</h1>

<p>Go is a general-purpose language designed with systems programming in mind.It was initially developed at Google in year 2007 by Robert Griesemer, Rob Pike, and Ken Thompson. It is strongly and statically typed, provides inbuilt support for garbage collection and supports concurrent programming. Programs are constructed using packages, for efficient management of dependencies. Go programming implementations use a traditional compile and link model to generate executable binaries.</p>

<p>The Go programming language was announced in November 2009 and is used in some of the Google's production systems</p>

<h2>Design Principles</h2>

<p>Support for environment adopting patterns similar to dynamic languages. For example type inference (x := 0 is valid declaration of a variable x of type int)</p>

<p>Compilation time is fast.</p>

<p>InBuilt concurrency support: light-weight processes (via goroutines), channels, select statement.</p>

<p>Conciseness, Simplicity, and Safety</p>

<p>Support for Interfaces and Type embedding.</p>

<p>Production of statically linked native binaries without external dependencies.</p>

<h2>Features excluded intentionally</h2>

<p>To keep language simple and concise, following features commonly available in similar languages are ommitted.</p>

<p>No support for type inheritance</p>

<p>No support for method or operator overloading</p>

<p>No support for circular dependencies among packages</p>

<p>No support for pointer arithmetic</p>

<p>No support for assertions</p>

<p>No support for generic programming</p>

<h2>Go Programs</h2>

<p>A Go program can vary from 3 lines to millions of lines and it should be written into one or more text files with extension ".go"; for example, hello.go. You can use "vi", "vim" or any other text editor to write your Go program into a file.</p>

<p>This tutorial assumes that you know how to edit a text file and how to write source code inside a program file.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Go Environment Setup</title>

<h1>Go - Environment Setup</h1>

<h2>Try it Option Online</h2>

<p>You really do not need to set up your own environment to start learning Go programming language. Reason is very simple, we already have set up Go Programming environment online, so that you can compile and execute all the available examples online at the same time when you are doing your theory work. This gives you confidence in what you are reading and to check the result with different options. Feel free to modify any example and execute it online.</p>

<p>Try following example using <b>Try it</b> option available at the top right corner of the below sample code box:</p>

<p>For most of the examples given in this tutorial, you will find <b>Try it</b> option, so just make use of it and enjoy your learning.</p>

<h2>Local Environment Setup</h2>

<p>If you are still willing to set up your environment for Go programming language, you need the following two softwares available on your computer, (a) Text Editor and (b) The Go Compiler.</p>

<h2>Text Editor</h2>

<p>This will be used to type your program. Examples of few editors include Windows Notepad, OS Edit command, Brief, Epsilon, EMACS, and vim or vi.</p>

<p>Name and version of text editor can vary on different operating systems. For example, Notepad will be used on Windows, and vim or vi can be used on windows as well as Linux or UNIX.</p>

<p>The files you create with your editor are called source files and contain program source code. The source files for Go programs are typically named with the extension "<b>.go</b>".</p>

<p>Before starting your programming, make sure you have one text editor in place and you have enough experience to write a computer program, save it in a file, compile it and finally execute it.</p>

<h2>The Go Compiler</h2>

<p>The source code written in source file is the human readable source for your program. It needs to be "compiled", to turn into machine language so that your CPU can actually execute the program as per instructions given.</p>

<p>This Go programming language compiler will be used to compile your source code into final executable program. I assume you have basic knowledge about a programming language compiler.</p>

<p>Go distribution comes as a binary installable for FreeBSD (release 8 and above), Linux, Mac OS X (Snow Leopard and above), and Windows operating systems with the 32-bit (386) and 64-bit (amd64) x86 processor architectures. </p>

<p>Following section guides you on how to install Go binary distribution on various OS.</p>

<h2>Download Go archive</h2>

<p>Download latest version of Go installable archive file  from <a target="_blank" rel="nofollow" href="https://golang.org/dl/">Go Downloads</a>. At the time of writing this tutorial, I downloaded <i>go1.4.windows-amd64.msi</i> and copied it into C:\&gt;go folder.</p>

<h2>Installation on UNIX/Linux/Mac OS X, and FreeBSD</h2>

<p>Extract the download archive into /usr/local, creating a Go tree in /usr/local/go. For example:</p>

<p>tar -C /usr/local -xzf go1.4.linux-amd64.tar.gz</p>

<p>Add /usr/local/go/bin to the PATH environment variable.</p>

<h2>Installation on Windows</h2>

<p>Use the MSI file and follow the prompts to install the Go tools. By default, the installer uses the Go distribution in c:\Go. The installer should set the c:\Go\bin directory in window's PATH environment variable. Restart any open command prompts for the change to take effect.</p>

<h2>Verify installation</h2>

<p>Create a go file named test.go in <b>C:\>Go_WorkSpace</b>.</p>

<p><i>File: test.go</i></p>

<p>Now run the test.go to see the result:</p>

<p>Verify the Output</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   fmt.Println("Hello, World!")
}
</pre>
<p>For most of the examples given in this tutorial, you will find <b>Try it</b> option, so just make use of it and enjoy your learning.</p>
</blockquote>
<h2>Local Environment Setup</h2>
<p>If you are still willing to set up your environment for Go programming language, you need the following two softwares available on your computer, (a) Text Editor and (b) The Go Compiler.</p>
<h2>Text Editor</h2>
<p>This will be used to type your program. Examples of few editors include Windows Notepad, OS Edit command, Brief, Epsilon, EMACS, and vim or vi.</p>
<p>Name and version of text editor can vary on different operating systems. For example, Notepad will be used on Windows, and vim or vi can be used on windows as well as Linux or UNIX.</p>
<p>The files you create with your editor are called source files and contain program source code. The source files for Go programs are typically named with the extension "<b>.go</b>".</p>
<p>Before starting your programming, make sure you have one text editor in place and you have enough experience to write a computer program, save it in a file, compile it and finally execute it.</p>
<h2>The Go Compiler</h2>
<p>The source code written in source file is the human readable source for your program. It needs to be "compiled", to turn into machine language so that your CPU can actually execute the program as per instructions given.</p>
<p>This Go programming language compiler will be used to compile your source code into final executable program. I assume you have basic knowledge about a programming language compiler.</p>
<p>Go distribution comes as a binary installable for FreeBSD (release 8 and above), Linux, Mac OS X (Snow Leopard and above), and Windows operating systems with the 32-bit (386) and 64-bit (amd64) x86 processor architectures. </p>
<p>Following section guides you on how to install Go binary distribution on various OS.</p>
<h2>Download Go archive</h2>
<p>Download latest version of Go installable archive file  from <a target="_blank" rel="nofollow" href="https://golang.org/dl/">Go Downloads</a>. At the time of writing this tutorial, I downloaded <i>go1.4.windows-amd64.msi</i> and copied it into C:\&gt;go folder.</p>
<table class="src">
<tr><th style="width:20%">OS</th><th>Archive name</th></tr>
<tr><td>Windows</td><td>go1.4.windows-amd64.msi</td></tr>
<tr><td>Linux</td><td>go1.4.linux-amd64.tar.gz</td></tr>
<tr><td>Mac</td><td>go1.4.darwin-amd64-osx10.8.pkg</td></tr>
<tr><td>FreeBSD</td><td>go1.4.freebsd-amd64.tar.gz</td></tr>
</table>
<h2>Installation on UNIX/Linux/Mac OS X, and FreeBSD</h2>
<p>Extract the download archive into /usr/local, creating a Go tree in /usr/local/go. For example:</p>
<p>tar -C /usr/local -xzf go1.4.linux-amd64.tar.gz</p>
<p>Add /usr/local/go/bin to the PATH environment variable.</p>
<table class="src">
<tr><th style="width:20%">OS</th><th>Output</th></tr>
<tr><td>Linux</td><td>export PATH=$PATH:/usr/local/go/bin</td></tr>
<tr><td>Mac</td><td>export PATH=$PATH:/usr/local/go/bin</td></tr>
<tr><td>FreeBSD</td><td>export PATH=$PATH:/usr/local/go/bin</td></tr>
</table>
<h2>Installation on Windows</h2>
<p>Use the MSI file and follow the prompts to install the Go tools. By default, the installer uses the Go distribution in c:\Go. The installer should set the c:\Go\bin directory in window's PATH environment variable. Restart any open command prompts for the change to take effect.</p>
<h2>Verify installation</h2>
<p>Create a go file named test.go in <b>C:\>Go_WorkSpace</b>.</p>
<p><i>File: test.go</i></p>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   fmt.Println("Hello, World!")
}
</pre>
<p>Now run the test.go to see the result:</p>
<pre class="prettyprint notranslate">
C:\Go_WorkSpace>go run test.go
</pre>
<p>Verify the Output</p>
<pre class="result notranslate">
Hello, World!
</pre>

<title>Go Program Structure</title>

<h1>Go - Program Structure</h1>

<p>Before we study basic building blocks of the Go programming language, let us look a bare minimum Go program structure so that we can take it as a reference in upcoming chapters.</p>

<h2>Go Hello World Example</h2>

<p>A Go program basically consists of the following parts:</p>

<p>Package Declaration</p>

<p>Import Packages</p>

<p>Functions</p>

<p>Variables</p>

<p>Statements &amp; Expressions</p>

<p>Comments</p>

<p>Let us look at a simple code that would print the words "Hello World":</p>

<p>Let us look various parts of the above program:</p>

<p>The first line of the program <i>package main</i> defines the package name in which this program should lie. It is a must statement as Go programs runs in packages. main package is the starting point to run the program. Each package has a path and name associated with it.</p>

<p>The next line<i>import "fmt"</i> is a preprocessor command which tell the Go compiler to include files lying in package fmt.</p>

<p>The next line <i>func main()</i> is the main function where program execution begins.</p>

<p>The next line /*...*/ will be ignored by the compiler and it has been put to add additional comments in the program. So such lines are called comments in the program. Comments are also represented using // similar to Java or C++ comments. </p>

<p>The next line <i>fmt.Println(...)</i> is another function available in Go which causes the message "Hello, World!" to be displayed on the screen. Here fmt package has exported Println method which is used to display message on the screen.</p>

<p>Notice the capital P of Println method. In Go language, a name is exported if it starts with capital letter. Exported means that a function or variable/constant is accessible to importer of the respective package.</p>

<h2>Execute Go Program:</h2>

<p>Lets look at how to save the source code in a file, and how to compile and run it. Following are the simple steps:</p>

<p>Open a text editor and add the above-mentioned code.</p>

<p>Save the file as <i>hello.go</i></p>

<p>Open a command prompt and go to the directory where you saved the file.</p>

<p>Type <i>go run hello.go</i> and press enter to run your code. </p>

<p>If there are no errors in your code then you will be able to see <i>"Hello World"</i> printed on the screen.</p>

<p>Make sure that go compiler is in your path and that you are running it in the directory containing source file hello.go.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   /* This is my first sample program. */
   fmt.Println("Hello, World!")
}
</pre>
<p>Let us look various parts of the above program:</p>
<ol class="list">
<li><p>The first line of the program <i>package main</i> defines the package name in which this program should lie. It is a must statement as Go programs runs in packages. main package is the starting point to run the program. Each package has a path and name associated with it.</p></li>
<li><p>The next line<i>import "fmt"</i> is a preprocessor command which tell the Go compiler to include files lying in package fmt.</p></li>
<li><p>The next line <i>func main()</i> is the main function where program execution begins.</p></li>
<li><p>The next line /*...*/ will be ignored by the compiler and it has been put to add additional comments in the program. So such lines are called comments in the program. Comments are also represented using // similar to Java or C++ comments. </p></li>
<li><p>The next line <i>fmt.Println(...)</i> is another function available in Go which causes the message "Hello, World!" to be displayed on the screen. Here fmt package has exported Println method which is used to display message on the screen.</p></li>
<li><p>Notice the capital P of Println method. In Go language, a name is exported if it starts with capital letter. Exported means that a function or variable/constant is accessible to importer of the respective package.</p></li>
</ol>
<h2>Execute Go Program:</h2>
<p>Lets look at how to save the source code in a file, and how to compile and run it. Following are the simple steps:</p>
<ol class="list">
<li><p>Open a text editor and add the above-mentioned code.</p></li>
<li><p>Save the file as <i>hello.go</i></p></li>
<li><p>Open a command prompt and go to the directory where you saved the file.</p></li>
<li><p>Type <i>go run hello.go</i> and press enter to run your code. </p></li>
<li><p>If there are no errors in your code then you will be able to see <i>"Hello World"</i> printed on the screen.</p></li>
</ol>
<pre class="result">
$ go run hello.go
Hello, World!
</pre>

<title>Go Basic Syntax</title>

<h1>Go - Basic Syntax</h1>

<p>You have seen a basic structure of Go program, so it will be easy to understand other basic building blocks of the Go programming language.</p>

<h2>Tokens in Go</h2>

<p>A Go program consists of various tokens and a token is either a keyword, an identifier, a constant, a string literal, or a symbol. For example, the following Go statement consists of six tokens:</p>

<p>The individual tokens are:</p>

<h2>Line Seperator</h2>

<p>In Go program, the line seperator key is a statement terminator. That is, each individual statement don't need a special seperator like ; in C. Go compiler internally places ; as statement terminator to indicate the end of one logical entity.</p>

<p>For example, following are two different statements:</p>

<h2>Comments</h2>

<p>Comments are like helping text in your Go program and they are ignored by the compiler. They start with /* and terminates with the characters */ as shown below:</p>

<p>You cannot have comments within comments and they do not occur within a string or character literals.</p>

<h2>Identifiers</h2>

<p>A Go identifier is a name used to identify a variable, function, or any other user-defined item. An identifier starts with a letter A to Z or a to z or an underscore _ followed by zero or more letters, underscores, and digits (0 to 9).</p>

<p>identifier = letter { letter | unicode_digit } .</p>

<p>Go does not allow punctuation characters such as @, $, and % within identifiers. Go is a <b>case sensitive</b> programming language. Thus, <i>Manpower</i> and <i>manpower</i> are two different identifiers in Go. Here are some examples of acceptable identifiers:</p>

<h2>Keywords</h2>

<p>The following list shows the reserved words in Go. These reserved words may not be used as constant or variable or any other identifier names.</p>

<h2>Whitespace in Go</h2>

<p>A line containing only whitespace, possibly with a comment, is known as a blank line, and a Go compiler totally ignores it.</p>

<p>Whitespace is the term used in Go to describe blanks, tabs, newline characters and comments. Whitespace separates one part of a statement from another and enables the compiler to identify where one element in a statement, such as int, ends and the next element begins. Therefore, in the following statement:</p>

<p>There must be at least one whitespace character (usually a space) between int and age for the compiler to be able to distinguish them. On the other hand, in the following statement:</p>

<p>No whitespace characters are necessary between fruit and =, or between = and apples, although you are free to include some if you wish for readability purpose.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint">
fmt.Println("Hello, World!")
</pre>
<p>The individual tokens are:</p>
<pre class="prettyprint">
fmt
.
Println
(
"Hello, World!"
)
</pre>
<h2>Line Seperator</h2>
<p>In Go program, the line seperator key is a statement terminator. That is, each individual statement don't need a special seperator like ; in C. Go compiler internally places ; as statement terminator to indicate the end of one logical entity.</p>
<p>For example, following are two different statements:</p>
<pre class="prettyprint">
fmt.Println("Hello, World!")
fmt.Println("I am in Go Programming World!")
</pre>
<h2>Comments</h2>
<p>Comments are like helping text in your Go program and they are ignored by the compiler. They start with /* and terminates with the characters */ as shown below:</p>
<pre class="prettyprint">
/* my first program in Go */
</pre>
<p>You cannot have comments within comments and they do not occur within a string or character literals.</p>
<h2>Identifiers</h2>
<p>A Go identifier is a name used to identify a variable, function, or any other user-defined item. An identifier starts with a letter A to Z or a to z or an underscore _ followed by zero or more letters, underscores, and digits (0 to 9).</p>
<p>identifier = letter { letter | unicode_digit } .</p>
<p>Go does not allow punctuation characters such as @, $, and % within identifiers. Go is a <b>case sensitive</b> programming language. Thus, <i>Manpower</i> and <i>manpower</i> are two different identifiers in Go. Here are some examples of acceptable identifiers:</p>
<pre class="prettyprint">
mahesh   kumar   abc   move_name   a_123
myname50   _temp   j   a23b9   retVal
</pre>
<h2>Keywords</h2>
<p>The following list shows the reserved words in Go. These reserved words may not be used as constant or variable or any other identifier names.</p>
<table class="src">
<tr>
<td style="width:25%">break</td><td style="width:25%">default</td><td style="width:25%">func</td><td style="width:25%">interface</td><td style="width:25%">select</td></tr>
<tr><td>case</td><td>defer</td><td>go</td><td>map</td><td>struct</td></tr>
<tr><td>chan</td><td>else</td><td>goto</td><td>package</td><td>switch</td></tr>
<tr><td>const</td><td>fallthrough</td><td>if</td><td>range</td><td>type</td></tr>
<tr><td>continue</td><td>for</td><td>import</td><td>return</td><td>var</td></tr>
</table>
<h2>Whitespace in Go</h2>
<p>A line containing only whitespace, possibly with a comment, is known as a blank line, and a Go compiler totally ignores it.</p>
<p>Whitespace is the term used in Go to describe blanks, tabs, newline characters and comments. Whitespace separates one part of a statement from another and enables the compiler to identify where one element in a statement, such as int, ends and the next element begins. Therefore, in the following statement:</p>
<pre class="prettyprint">
var age int;
</pre>
<p>There must be at least one whitespace character (usually a space) between int and age for the compiler to be able to distinguish them. On the other hand, in the following statement:</p>
<pre class="prettyprint">
fruit = apples + oranges;   // get the total fruit
</pre>

<title>Go Data Types</title>

<h1>Go - Data Types</h1>

<p>In the Go programming language, data types refer to an extensive system used for declaring variables or functions of different types. The type of a variable determines how much space it occupies in storage and how the bit pattern stored is interpreted.</p>

<p>The types in Go can be classified as follows:</p>

<p>The array types and structure types are referred to collectively as the aggregate types. The type of a function specifies the set of all functions with the same parameter and result types. We will see basic types in the following section, whereas, other types will be covered in the upcoming chapters.</p>

<h2>Integer Types</h2>

<p>The predefine architecture-independent integer types are:</p>

<h2>Floating Types</h2>

<p>The predefine architecture-independent float types are:</p>

<p>The value of an n-bit integer is n bits and is represented using two's complement arithmetic operations.</p>

<h2>Other Numeric Types</h2>

<p>There is also a set of numeric types with implementation-specific sizes:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Go Variables</title>

<h1>Go - Variables</h1>

<p>A variable is nothing but a name given to a storage area that our programs can manipulate. Each variable in Go has a specific type, which determines the size and layout of the variable's memory; the range of values that can be stored within that memory; and the set of operations that can be applied to the variable.</p>

<p>The name of a variable can be composed of letters, digits, and the underscore character. It must begin with either a letter or an underscore. Upper and lowercase letters are distinct because Go is case-sensitive. Based on the basic types explained in previous chapter, there will be the following basic variable types:</p>

<p>Go programming language also allows to define various other types of variables, which we will cover in subsequent chapters like Enumeration, Pointer, Array, Structure, Union, etc. For this chapter, let us study only basic variable types.</p>

<h2>Variable Definition in Go:</h2>

<p>A variable definition means to tell the compiler where and how much to create the storage for the variable. A variable definition specifies a data type and contains a list of one or more variables of that type as follows:</p>

<p>Here, <b>optional_data_type</b> is a valid Go data type including byte, int, float32, complex64, boolean or any user-defined object, etc., and <b>variable_list</b> may consist of one or more identifier names separated by commas. Some valid declarations are shown here:</p>

<p>The line <b>var i, j, k;</b> both declares and defines the variables i, j and k;  which instructs the compiler to create variables named i, j and k of type int.</p>

<p>Variables can be initialized (assigned an initial value) in their declaration. The type of variable is automatically judged by the compiler based on the value passed to it. The initializer consists of an equal sign followed by a constant expression as follows:</p>

<p>Some examples are:</p>

<p>For definition without an initializer: variables with static storage duration are implicitly initialized with nil (all bytes have the value 0); the initial value of all other variables is zero value of their data type.</p>

<h2>Static type declaration</h2>

<p>A static type variable declaration provides assurance to the compiler that there is one variable existing with the given type and name so that compiler proceed for further compilation without needing complete detail about the variable. A variable declaration has its meaning at the time of compilation only, compiler needs actual variable declaration at the time of linking of the program.</p>

<h2>Example</h2>

<p>Try following example, where variable has been declared with a type, and have been defined and initialized inside the main function:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Dynamic type declaration / Type Inference</h2>

<p>A dynamic type variable declaration requires compiler to interpret the type of variable based on value passed to it. Compiler don't need a variable to have type statically as a necessary requirement.</p>

<h2>Example</h2>

<p>Try following example, where variables have been declared without any  type, and have been defined and initialized inside the main function. Notice, in case of type inference, we've initialized the variable y with <b>:=</b> operator wheree as x is initilized using <b>=</b> operator. </p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Mixed variable declaration</h2>

<p>Variables of different types can be declared in one go using type inference. </p>

<h2>Example</h2>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Lvalues and Rvalues in Go:</h2>

<p>There are two kinds of expressions in Go:</p>

<p><b>lvalue :</b> Expressions that refer to a memory location is  called "lvalue" expression. An lvalue may appear as either the left-hand or right-hand side of an assignment.</p>

<p><b>rvalue :</b> The term rvalue refers to a data value that is stored at some address in memory. An rvalue is an expression that cannot have a value assigned to it which means an rvalue may appear on the right- but not left-hand side of an assignment.</p>

<p>Variables are lvalues and so may appear on the left-hand side of an assignment. Numeric literals are rvalues and so may not be assigned and can not appear on the left-hand side. Following is a valid statement:</p>

<p>But following is not a valid statement and would generate compile-time error:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint">
var variable_list optional_data_type;
</pre>
<p>Here, <b>optional_data_type</b> is a valid Go data type including byte, int, float32, complex64, boolean or any user-defined object, etc., and <b>variable_list</b> may consist of one or more identifier names separated by commas. Some valid declarations are shown here:</p>
<pre class="prettyprint">
var    i, j, k int;
var   c, ch byte;
var  f, salary float32;
d = 42;
</pre>
<p>The line <b>var i, j, k;</b> both declares and defines the variables i, j and k;  which instructs the compiler to create variables named i, j and k of type int.</p>
<p>Variables can be initialized (assigned an initial value) in their declaration. The type of variable is automatically judged by the compiler based on the value passed to it. The initializer consists of an equal sign followed by a constant expression as follows:</p>
<pre class="prettyprint">
variable_name = value;
</pre>
<p>Some examples are:</p>
<pre class="prettyprint">
d = 3, f = 5;    // declaration of d and f. Here d and f are int 
</pre>
<p>For definition without an initializer: variables with static storage duration are implicitly initialized with nil (all bytes have the value 0); the initial value of all other variables is zero value of their data type.</p>
<h2>Static type declaration</h2>
<p>A static type variable declaration provides assurance to the compiler that there is one variable existing with the given type and name so that compiler proceed for further compilation without needing complete detail about the variable. A variable declaration has its meaning at the time of compilation only, compiler needs actual variable declaration at the time of linking of the program.</p>
<h2>Example</h2>
<p>Try following example, where variable has been declared with a type, and have been defined and initialized inside the main function:</p>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   var x float64
   x = 20.0
   fmt.Println(x)
   fmt.Printf("x is of type %T\n", x)
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
20
x is of type float64
</pre>
<h2>Dynamic type declaration / Type Inference</h2>
<p>A dynamic type variable declaration requires compiler to interpret the type of variable based on value passed to it. Compiler don't need a variable to have type statically as a necessary requirement.</p>
<h2>Example</h2>
<p>Try following example, where variables have been declared without any  type, and have been defined and initialized inside the main function. Notice, in case of type inference, we've initialized the variable y with <b>:=</b> operator wheree as x is initilized using <b>=</b> operator. </p>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   var x float64 = 20.0

   y := 42 
   fmt.Println(x)
   fmt.Println(y)
   fmt.Printf("x is of type %T\n", x)
   fmt.Printf("y is of type %T\n", y)	
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
20
42
x is of type float64
y is of type int
</pre>
<h2>Mixed variable declaration</h2>
<p>Variables of different types can be declared in one go using type inference. </p>
<h2>Example</h2>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   var a, b, c = 3, 4, "foo"  
	
   fmt.Println(a)
   fmt.Println(b)
   fmt.Println(c)
   fmt.Printf("a is of type %T\n", a)
   fmt.Printf("b is of type %T\n", b)
   fmt.Printf("c is of type %T\n", c)
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
3
4
foo
a is of type int
b is of type int
c is of type string
</pre>
<h2>Lvalues and Rvalues in Go:</h2>
<p>There are two kinds of expressions in Go:</p>
<ol class="list">
<li><p><b>lvalue :</b> Expressions that refer to a memory location is  called "lvalue" expression. An lvalue may appear as either the left-hand or right-hand side of an assignment.</p></li>
<li><p><b>rvalue :</b> The term rvalue refers to a data value that is stored at some address in memory. An rvalue is an expression that cannot have a value assigned to it which means an rvalue may appear on the right- but not left-hand side of an assignment.</p></li>
</ol>
<p>Variables are lvalues and so may appear on the left-hand side of an assignment. Numeric literals are rvalues and so may not be assigned and can not appear on the left-hand side. Following is a valid statement:</p>
<pre class="prettyprint">
x = 20.0
</pre>
<p>But following is not a valid statement and would generate compile-time error:</p>
<pre class="prettyprint">
10 = 20
</pre>

<title>Go Constants</title>

<h1>Go - Constants</h1>

<p>The constants refer to fixed values that the program may not alter during its execution. These fixed values are also called <b>literals</b>.</p>

<p>Constants can be of any of the basic data types like <i>an integer constant, a floating constant, a character constant, or a string literal</i>. There are also enumeration constants as well.</p>

<p>The <b>constants</b> are treated just like regular variables except that their values cannot be modified after their definition.</p>

<h2>Integer literals</h2>

<p>An integer literal can be a decimal, octal, or hexadecimal constant. A prefix specifies the base or radix: 0x or 0X for hexadecimal, 0 for octal, and nothing for decimal.</p>

<p>An integer literal can also have a suffix that is a combination of U and L, for unsigned and long, respectively. The suffix can be uppercase or lowercase and can be in any order.</p>

<p>Here are some examples of integer literals:</p>

<p>Following are other examples of various type of Integer literals:</p>

<h2>Floating-point literals</h2>

<p>A floating-point literal has an integer part, a decimal point, a fractional part, and an exponent part. You can represent floating point literals either in decimal form or exponential form.</p>

<p>While representing using decimal form, you must include the decimal point, the exponent, or both and while representing using exponential form, you must include the integer part, the fractional part, or both. The signed exponent is introduced by e or E.</p>

<p>Here are some examples of floating-point literals:</p>

<h2>Escape sequence</h2>

<p>There are certain characters in Go when they are preceded by a backslash they will have special meaning and they are used to represent like newline (\n) or tab (\t). Here, you have a list of some of such escape sequence codes:</p>

<p>Following is the example to show few escape sequence characters:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>String literals</h2>

<p>String literals or constants are enclosed in double quotes "". A string contains characters that are similar to character literals: plain characters, escape sequences, and universal characters.</p>

<p>You can break a long line into multiple lines using string literals and separating them using whitespaces.</p>

<p>Here are some examples of string literals. All the three forms are identical strings.</p>

<h2>The const Keyword</h2>

<p>You can use <b>const</b> prefix to declare constants with a specific type as follows:</p>

<p>Following example explains it in detail:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>Note that it is a good programming practice to define constants in CAPITALS.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint">
212         /* Legal */
215u        /* Legal */
0xFeeL      /* Legal */
078         /* Illegal: 8 is not an octal digit */
032UU       /* Illegal: cannot repeat a suffix */
</pre>
<p>Following are other examples of various type of Integer literals:</p>
<pre class="prettyprint">
85         /* decimal */
0213       /* octal */
0x4b       /* hexadecimal */
30         /* int */
30u        /* unsigned int */
30l        /* long */
30ul       /* unsigned long */
</pre>
<h2>Floating-point literals</h2>
<p>A floating-point literal has an integer part, a decimal point, a fractional part, and an exponent part. You can represent floating point literals either in decimal form or exponential form.</p>
<p>While representing using decimal form, you must include the decimal point, the exponent, or both and while representing using exponential form, you must include the integer part, the fractional part, or both. The signed exponent is introduced by e or E.</p>
<p>Here are some examples of floating-point literals:</p>
<pre class="prettyprint">
3.14159       /* Legal */
314159E-5L    /* Legal */
510E          /* Illegal: incomplete exponent */
210f          /* Illegal: no decimal or exponent */
.e55          /* Illegal: missing integer or fraction */
</pre>
<h2>Escape sequence</h2>
<p>There are certain characters in Go when they are preceded by a backslash they will have special meaning and they are used to represent like newline (\n) or tab (\t). Here, you have a list of some of such escape sequence codes:</p>
<table class="src">
<tr><th style="width:20%">Escape sequence</th><th>Meaning</th></tr>
<tr><td>\\</td><td>\ character</td></tr>
<tr><td>\'</td><td> ' character</td></tr>
<tr><td>\"</td><td>" character</td></tr>
<tr><td>\?</td><td>? character</td></tr>
<tr><td>\a</td><td>Alert or bell</td></tr>
<tr><td>\b</td><td>Backspace</td></tr>
<tr><td>\f</td><td>Form feed</td></tr>
<tr><td>\n</td><td>Newline</td></tr>
<tr><td>\r</td><td>Carriage return</td></tr>
<tr><td>\t</td><td>Horizontal tab</td></tr>
<tr><td>\v</td><td>Vertical tab</td></tr>
<tr><td>\ooo</td><td>Octal number of one to three digits</td></tr>
<tr><td>\xhh . . .</td><td>Hexadecimal number of one or more digits</td></tr>
</table>
<p>Following is the example to show few escape sequence characters:</p>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   fmt.Printf("Hello\tWorld!")
}
</pre>
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
Hello   World!
</pre>
<h2>String literals</h2>
<p>String literals or constants are enclosed in double quotes "". A string contains characters that are similar to character literals: plain characters, escape sequences, and universal characters.</p>
<p>You can break a long line into multiple lines using string literals and separating them using whitespaces.</p>
<p>Here are some examples of string literals. All the three forms are identical strings.</p>
<pre class="prettyprint">
"hello, dear"

"hello, \

dear"

"hello, " "d" "ear"
</pre>
<h2>The const Keyword</h2>
<p>You can use <b>const</b> prefix to declare constants with a specific type as follows:</p>
<pre class="prettyprint">
const variable type = value;
</pre>
<p>Following example explains it in detail:</p>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   const LENGTH int = 10
   const WIDTH int = 5   
   var area int

   area = LENGTH * WIDTH
   fmt.Printf("value of area : %d", area)   
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
value of area : 50
</pre>

<title>Go Operators</title>

<h1>Go - Operators</h1>

<p>An operator is a symbol that tells the compiler to perform specific mathematical or logical manipulations. Go language is rich in built-in operators and provides the following types of operators:</p>

<p>Arithmetic Operators</p>

<p>Relational Operators</p>

<p>Logical Operators</p>

<p>Bitwise Operators</p>

<p>Assignment Operators</p>

<p>Misc Operators</p>

<p>This tutorial will explain the arithmetic, relational, logical, bitwise, assignment and other operators one by one.</p>

<h2>Arithmetic Operators</h2>

<p>Following table shows all the arithmetic operators supported by Go language. Assume variable <b>A</b> holds 10 and variable <b>B</b> holds 20 then:</p>

<p><a href="/go/go_arithmetic_operators.htm" title="Arithmetic Operators in Go">Show Examples</a></p>

<h2>Relational Operators</h2>

<p>Following table shows all the relational operators supported by Go language. Assume variable <b>A</b> holds 10 and variable <b>B</b> holds 20, then:</p>

<p><a href="/go/go_relational_operators.htm" title="Relational Operators in Go">Show Examples</a></p>

<h2>Logical Operators</h2>

<p>Following table shows all the logical operators supported by Go language. Assume variable <b>A</b> holds 1 and variable <b>B</b> holds 0, then:</p>

<p><a href="/go/go_logical_operators.htm" title="Logical Operators in Go">Show Examples</a></p>

<h2>Bitwise Operators</h2>

<p>Bitwise operator works on bits and perform bit-by-bit operation. The truth tables for &amp;, |, and ^ are as follows:</p>

<p>Assume if A = 60; and B = 13; now in binary format they will be as follows:</p>

<p>A = 0011 1100</p>

<p>B = 0000 1101</p>

<p>-----------------</p>

<p>A&amp;B = 0000 1100</p>

<p>A|B = 0011 1101</p>

<p>A^B = 0011 0001</p>

<p>~A&nbsp; = 1100 0011</p>

<p>The Bitwise operators supported by C language are listed in the following table. Assume variable A holds 60 and variable B holds 13, then:</p>

<p><a href="/go/go_bitwise_operators.htm" title="Bitwise Operators in Go">Show Examples</a></p>

<h2>Assignment Operators</h2>

<p>There are following assignment operators supported by Go language:</p>

<p><a href="/go/go_assignment_operators.htm" title="Assignment Operators in Go">Show Examples</a></p>

<h2> Misc Operators</h2>

<p>There are few other important operators including <b>sizeof</b> and <b>? :</b>  supported by Go Language.</p>

<p><a href="/go/go_misc_operator.htm" title="Misc operators in Go">Show Examples</a></p>

<h2>Operators Precedence in Go</h2>

<p>Operator precedence determines the grouping of terms in an expression. This affects how an expression is evaluated. Certain operators have higher precedence than others; for example, the multiplication operator has higher precedence than the addition operator.</p>

<p>For example x = 7 + 3 * 2; here, x is assigned 13, not 20 because operator * has higher precedence than +, so it first gets multiplied with 3*2 and then adds into 7.</p>

<p>Here, operators with the highest precedence appear at the top of the table, those with the lowest appear at the bottom. Within an expression, higher precedence operators will be evaluated first.</p>

<p><a href="/go/go_operators_precedence.htm" title="Operators Precedence in Go">Show Examples</a></p>

<p>The following table lists all operators from highest precedence to lowest.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Go Decision Making</title>

<h1>Go - Decision Making</h1>

<p>Decision making structures require that the programmer specify one or more conditions to be evaluated or tested by the program, along with a statement or statements to be executed if the condition is determined to be true, and optionally, other statements to be executed if the condition is determined to be false.</p>

<p>Following is the general form of a typical decision making structure found in most of the programming languages:</p>

<p>Go programming language provides following types of decision making statements. Click the following links to check their detail.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Go Loops</title>

<h1>Go - Loops</h1>

<p>There may be a situation, when you need to execute a block of code several number of times. In general, statements are executed sequentially: The first statement in a function is executed first, followed by the second, and so on.</p>

<p>Programming languages provide various control structures that allow for more complicated execution paths.</p>

<p>A loop statement allows us to execute a statement or group of statements multiple times and following is the general form of a loop statement in most of the programming languages:</p>

<p>Go programming language provides the following types of loop to handle looping requirements. Click the following links to check their detail.</p>

<h2>Loop Control Statements:</h2>

<p>Loop control statements change execution from its normal sequence. When execution leaves a scope, all automatic objects that were created in that scope are destroyed.</p>

<p>C supports the following control statements. Click the following links to check their detail.</p>

<h2>The Infinite Loop:</h2>

<p>A loop becomes infinite loop if a condition never becomes false. The <b>for</b> loop is traditionally used for this purpose. Since none of the three expressions that form the for loop are required, you can make an endless loop by leaving the conditional expression empty or pass true to it.</p>

<p>When the conditional expression is absent, it is assumed to be true. You may have an initialization and increment expression, but C programmers more commonly use the for(;;) construct to signify an infinite loop.</p>

<p><b>NOTE:</b> You can terminate an infinite loop by pressing Ctrl + C keys.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint">
package main

import "fmt"

func main() {
   for true  {
       fmt.Printf("This loop will run forever.\n");
   }
}
</pre>

<title>Go Functions</title>

<h1>Go - Functions</h1>

<p>A function is a group of statements that together perform a task. Every Go program has at least one function, which is <b>main()</b>, and all the most trivial programs can define additional functions.</p>

<p>You can divide up your code into separate functions. How you divide up your code among different functions is up to you, but logically the division usually is so each function performs a specific task.</p>

<p>A function <b>declaration</b> tells the compiler about a function's name, return type, and parameters. A function <b>definition</b> provides the actual body of the function.</p>

<p>The Go standard library provides numerous built-in functions that your program can call. For example, function <b>len()</b> takes arguments of various types and return the length of the type. For example, if a string is passed to it, it will return length of the string in bytes and if an array is passed to it, it will return the array length as number of elements it have.</p>

<p>A function is known with various names like a method  or a sub-routine or a procedure, etc.</p>

<h2>Defining a Function:</h2>

<p>The general form of a function definition in Go programming language is as follows:</p>

<p>A function definition in Go programming language consists of a <i>function header</i> and a <i>function body</i>. Here are all the parts of a function:</p>

<p><b>func</b> func starts the declaration of a function.</p>

<p><b>Function Name:</b> This is the actual name of the function. The function name and the parameter list together constitute the function signature.</p>

<p><b>Parameters:</b> A parameter is like a placeholder. When a function is invoked, you pass a value to the parameter. This value is referred to as actual parameter or argument. The parameter list refers to the type, order, and number of the parameters of a function. Parameters are optional; that is, a function may contain no parameters.</p>

<p><b>Return Type</b>: A function may return a list of values. The <b>return_types</b> is the list of data types of the values the function returns. Some functions perform the desired operations without returning a value. In this case, the return_type is the not required.</p>

<p><b>Function Body:</b> The function body contains a collection of statements that define what the function does.</p>

<h2>Example:</h2>

<p>Following is the source code for a function called <b>max()</b>. This function takes two parameters num1 and num2 and returns the maximum between the two:</p>

<h2>Calling a Function:</h2>

<p>While creating a Go function, you give a definition of what the function has to do. To use a function, you will have to call that function to perform the defined task.</p>

<p>When a program calls a function, program control is transferred to the called function. A called function performs defined task and when its return statement is executed or when its function-ending closing brace is reached, it returns program control back to the main program.</p>

<p>To call a function, you simply need to pass the required parameters along with function name, and if function returns a value, then you can store returned value. For example:</p>

<p>I kept max() function along with main() function and compiled the source code. While running final executable, it would produce the following result:</p>

<h2>Returning multiple values from Function</h2>

<p>A Go function can return multiple values. For example:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Function Arguments:</h2>

<p>If a function is to use arguments, it must declare variables that accept the values of the arguments. These variables are called the <b>formal parameters</b> of the function.</p>

<p>The formal parameters behave like other local variables inside the function and are created upon entry into the function and destroyed upon exit.</p>

<p>While calling a function, there are two ways that arguments can be passed to a function:</p>

<p>By default, Go uses <b>call by value</b> to pass arguments. In general, this means that code within a function cannot alter the arguments used to call the function and above mentioned example while calling max() function used the same method.</p>

<h2>Function Usage:</h2>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint">
func function_name( [parameter list] ) [return_types]
{
   body of the function
}
</pre>
<p>A function definition in Go programming language consists of a <i>function header</i> and a <i>function body</i>. Here are all the parts of a function:</p>
<ul class="list">
<li><p><b>func</b> func starts the declaration of a function.</p></li>
<li><p><b>Function Name:</b> This is the actual name of the function. The function name and the parameter list together constitute the function signature.</p></li>
<li><p><b>Parameters:</b> A parameter is like a placeholder. When a function is invoked, you pass a value to the parameter. This value is referred to as actual parameter or argument. The parameter list refers to the type, order, and number of the parameters of a function. Parameters are optional; that is, a function may contain no parameters.</p></li>
<li><p><b>Return Type</b>: A function may return a list of values. The <b>return_types</b> is the list of data types of the values the function returns. Some functions perform the desired operations without returning a value. In this case, the return_type is the not required.</p></li>
<li><p><b>Function Body:</b> The function body contains a collection of statements that define what the function does.</p></li>
</ul>
<h2>Example:</h2>
<p>Following is the source code for a function called <b>max()</b>. This function takes two parameters num1 and num2 and returns the maximum between the two:</p>
<pre class="prettyprint">
/* function returning the max between two numbers */
func max(num1, num2 int) int
{
   /* local variable declaration */
   result int

   if (num1 &gt; num2) {
      result = num1
   } else {
      result = num2
   }
   return result 
}
</pre>
<h2>Calling a Function:</h2>
<p>While creating a Go function, you give a definition of what the function has to do. To use a function, you will have to call that function to perform the defined task.</p>
<p>When a program calls a function, program control is transferred to the called function. A called function performs defined task and when its return statement is executed or when its function-ending closing brace is reached, it returns program control back to the main program.</p>
<p>To call a function, you simply need to pass the required parameters along with function name, and if function returns a value, then you can store returned value. For example:</p>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   /* local variable definition */
   var a int = 100
   var b int = 200
   var ret int

   /* calling a function to get max value */
   ret = max(a, b)

   fmt.Printf( "Max value is : %d\n", ret )
}

/* function returning the max between two numbers */
func max(num1, num2 int) int {
   /* local variable declaration */
   var result int

   if (num1 &gt; num2) {
      result = num1
   } else {
      result = num2
   }
   return result 
}
</pre>
<p>I kept max() function along with main() function and compiled the source code. While running final executable, it would produce the following result:</p>
<pre class="result">
Max value is : 200
</pre>
<h2>Returning multiple values from Function</h2>
<p>A Go function can return multiple values. For example:</p>
<pre class="prettyprint tryit">
package main

import "fmt"

func swap(x, y string) (string, string) {
   return y, x
}

func main() {
   a, b := swap("Mahesh", "Kumar")
   fmt.Println(a, b)
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
Kumar Mahesh
</pre>

<title>Go Scope Rules</title>

<h1>Go - Scope Rules</h1>

<p>A scope in any programming is a region of the program where a defined variable can have its existence and beyond that variable can not be accessed. There are three places where variables can be declared in C programming language:</p>

<p>Inside a function or a block which is called <b>local</b> variables,</p>

<p>Outside of all functions which is called <b>global</b> variables.</p>

<p>In the definition of function parameters which is called <b>formal</b> parameters.</p>

<p>Let us explain what are <b>local</b> and <b>global</b> variables and <b>formal</b> parameters.</p>

<h2>Local Variables</h2>

<p>Variables that are declared inside a function or block are called local variables. They can be used only by statements that are inside that function or block of code. Local variables are not known to functions outside their own. Following is the example using local variables. Here all the variables a, b and c are local to main() function.</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Global Variables</h2>

<p>Global variables are defined outside of a function, usually on top of the program. The global variables will hold their value throughout the lifetime of your program and they can be accessed inside any of the functions defined for the program.</p>

<p>A global variable can be accessed by any function. That is, a global variable is available for use throughout your entire program after its declaration. Following is the example using global and local variables:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>A program can have same name for local and global variables but value of local variable inside a function will take preference. Following is an example:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Formal Parameters</h2>

<p>Function parameters, formal parameters, are treated as local variables with-in that function and they will take preference over the global variables. Following is an example:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Initializing Local and Global Variables</h2>

<p>When a local variable as Global variables are initialized to their corresponding 0 value. Pointer is initialized to nil.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   /* local variable declaration */
   var a, b, c int 

   /* actual initialization */
   a = 10
   b = 20
   c = a + b

   fmt.Printf ("value of a = %d, b = %d and c = %d\n", a, b, c)
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
value of a = 10, b = 20 and c = 30
</pre>
<h2>Global Variables</h2>
<p>Global variables are defined outside of a function, usually on top of the program. The global variables will hold their value throughout the lifetime of your program and they can be accessed inside any of the functions defined for the program.</p>
<p>A global variable can be accessed by any function. That is, a global variable is available for use throughout your entire program after its declaration. Following is the example using global and local variables:</p>
<pre class="prettyprint tryit">
package main

import "fmt"
 
/* global variable declaration */
var g int
 
func main() {

   /* local variable declaration */
   var a, b int

   /* actual initialization */
   a = 10
   b = 20
   g = a + b

   fmt.Printf("value of a = %d, b = %d and g = %d\n", a, b, g)
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
value of a = 10, b = 20 and g = 30
</pre>
<p>A program can have same name for local and global variables but value of local variable inside a function will take preference. Following is an example:</p>
<pre class="prettyprint tryit">
package main

import "fmt"
 
/* global variable declaration */
var g int = 20
 
func main() {
   /* local variable declaration */
   var g int = 10
 
   fmt.Printf ("value of g = %d\n",  g)
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
value of g = 10
</pre>
<h2>Formal Parameters</h2>
<p>Function parameters, formal parameters, are treated as local variables with-in that function and they will take preference over the global variables. Following is an example:</p>
<pre class="prettyprint tryit">
package main

import "fmt"
 
/* global variable declaration */
var a int = 20;
 
func main() {
   /* local variable declaration in main function */
   var a int = 10
   var b int = 20
   var c int = 0

   fmt.Printf("value of a in main() = %d\n",  a);
   c = sum( a, b);
   fmt.Printf("value of c in main() = %d\n",  c);
}

/* function to add two integers */
func sum(a, b int) int {
   fmt.Printf("value of a in sum() = %d\n",  a);
   fmt.Printf("value of b in sum() = %d\n",  b);

   return a + b;
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
value of a in main() = 10
value of a in sum() = 10
value of b in sum() = 20
value of c in main() = 30
</pre>

<title>Go Arrays</title>

<h1>Go - Arrays</h1>

<p>Go programming language provides a data structure called <b>the array</b>, which can store a fixed-size sequential collection of elements of the same type. An array is used to store a collection of data, but it is often more useful to think of an array as a collection of variables of the same type.</p>

<p>Instead of declaring individual variables, such as number0, number1, ..., and number99, you declare one array variable such as numbers and use numbers[0], numbers[1], and ..., numbers[99] to represent individual variables. A specific element in an array is accessed by an index. </p>

<p>All arrays consist of contiguous memory locations. The lowest address corresponds to the first element and the highest address to the last element.</p>

<h2>Declaring Arrays</h2>

<p>To declare an array in Go, a programmer specifies the type of the elements and the number of elements required by an array as follows:</p>

<p>This is called a <i>single-dimensional</i> array. The <b>arraySize</b> must be an integer constant greater than zero and <b>type</b> can be any valid Go data type. For example, to declare a 10-element array called <b>balance</b> of type float32, use this statement:</p>

<p>Now <i>balance</i> is avariable array which is sufficient to hold upto 10 float numbers.</p>

<h2>Initializing Arrays</h2>

<p>You can initialize array in Go either one by one or using a single statement as follows:</p>

<p>The number of values between braces { } can not be larger than the number of elements that we declare for the array between square brackets [ ].</p>

<p>If you omit the size of the array, an array just big enough to hold the initialization is created.  Therefore, if you write:</p>

<p>You will create exactly the same array as you did in the previous example. Following is an example to assign a single element of the array:</p>

<p>The above statement assigns element number 5th in the array with a value of 50.0. All arrays have 0 as the index of their first element which is also called base index and last index of an array will be total size of the array minus 1. Following is the pictorial representation  of the same array we discussed above:</p>

<h2>Accessing Array Elements</h2>

<p>An element is accessed by indexing the array name. This is done by placing the index of the element within square brackets after the name of the array. For example:</p>

<p>The above statement will take 10th element from the array and assign the value to salary variable. Following is an example which will use all the above mentioned three concepts viz. declaration, assignment and accessing arrays:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Go Arrays in Detail</h2>

<p>Arrays are important to C and should need lots of more details. There are following few important concepts related to array which should be clear to a C programmer:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint">
var variable_name [SIZE] variable_type
</pre>
<p>This is called a <i>single-dimensional</i> array. The <b>arraySize</b> must be an integer constant greater than zero and <b>type</b> can be any valid Go data type. For example, to declare a 10-element array called <b>balance</b> of type float32, use this statement:</p>
<pre class="prettyprint">
var balance [10] float32
</pre>
<p>Now <i>balance</i> is avariable array which is sufficient to hold upto 10 float numbers.</p>
<h2>Initializing Arrays</h2>
<p>You can initialize array in Go either one by one or using a single statement as follows:</p>
<pre class="prettyprint">
var balance = [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}
</pre>
<p>The number of values between braces { } can not be larger than the number of elements that we declare for the array between square brackets [ ].</p>
<p>If you omit the size of the array, an array just big enough to hold the initialization is created.  Therefore, if you write:</p>
<pre class="prettyprint">
var balance = []float32{1000.0, 2.0, 3.4, 7.0, 50.0}
</pre>
<p>You will create exactly the same array as you did in the previous example. Following is an example to assign a single element of the array:</p>
<pre class="prettyprint">
balance[4] = 50.0
</pre>
<p>The above statement assigns element number 5th in the array with a value of 50.0. All arrays have 0 as the index of their first element which is also called base index and last index of an array will be total size of the array minus 1. Following is the pictorial representation  of the same array we discussed above:</p>
<img src="/go/images/array_presentation.jpg" alt="Array Presentation" />
<h2>Accessing Array Elements</h2>
<p>An element is accessed by indexing the array name. This is done by placing the index of the element within square brackets after the name of the array. For example:</p>
<pre class="prettyprint">
float32 salary = balance[9]
</pre>
<p>The above statement will take 10th element from the array and assign the value to salary variable. Following is an example which will use all the above mentioned three concepts viz. declaration, assignment and accessing arrays:</p>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   var n [10]int /* n is an array of 10 integers */
   var i,j int

   /* initialize elements of array n to 0 */         
   for i = 0; i &lt; 10; i++ {
      n[i] = i + 100 /* set element at location i to i + 100 */
   }

   /* output each array element's value */
   for j = 0; j &lt; 10; j++ {
      fmt.Printf("Element[%d] = %d\n", j, n[j] )
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
Element[0] = 100
Element[1] = 101
Element[2] = 102
Element[3] = 103
Element[4] = 104
Element[5] = 105
Element[6] = 106
Element[7] = 107
Element[8] = 108
Element[9] = 109
</pre>

<title>Go Pointers</title>

<h1>Go - Pointers</h1>

<p>Pointers in Go are easy and fun to learn. Some Go programming tasks are performed more easily with pointers, and other tasks, such as call by reference, cannot be performed without using pointers. So it becomes necessary to learn pointers to become a perfect Go programmer. Let's start learning them in simple and easy steps.</p>

<p>As you know, every variable is a memory location and every memory location has its address defined which can be accessed using ampersand (&amp;) operator, which denotes an address in memory. Consider the following example, which will print the address of the variables defined:</p>

<p>When the above code is compiled and executed, it produces result something as follows:</p>

<p>So you understood what is memory address and how to access it, so base of the concept is over. Now let us see what is a pointer.</p>

<h2>What Are Pointers?</h2>

<p>A <b>pointer</b> is a variable whose value is the address of another variable, i.e., direct address of the memory location. Like any variable or constant, you must declare a pointer before you can use it to store any variable address. The general form of a pointer variable declaration is:</p>

<p>Here, <b>type</b> is the pointer's base type; it must be a valid C data type and <b>var-name</b> is the name of the pointer variable. The asterisk * you used to declare a pointer is the same asterisk that you use for multiplication. However, in this statement the asterisk is being used to designate a variable as a pointer. Following are the valid pointer declaration:</p>

<p>The actual data type of the value of all pointers, whether integer, float, or otherwise, is the same, a long hexadecimal number that represents a memory address. The only difference between pointers of different data types is the data type of the variable or constant that the pointer points to.</p>

<h2>How to use Pointers?</h2>

<p>There are few important operations, which we will do with the help of pointers very frequently. <b>(a)</b> we define a pointer variable <b>(b)</b> assign the address of a variable to a pointer and <b>(c)</b> finally access the value at the address available in the pointer variable. This is done by using unary operator <b>*</b> that returns the value of the variable located at the address specified by its operand. Following example makes use of these operations:</p>

<p>When the above code is compiled and executed, it produces result something as follows:</p>

<h2>nil Pointers in Go</h2>

<p>Go compiler assign a Nil value to a pointer variable in case you do not have exact address to be assigned. This is done at the time of variable declaration. A pointer that is assigned nil is called a <b>nil</b> pointer.</p>

<p>The nil pointer is a constant with a value of zero defined in several standard libraries. Consider the following program:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>On most of the operating systems, programs are not permitted to access memory at address 0 because that memory is reserved by the operating system. However, the memory address 0 has special significance; it signals that the pointer is not intended to point to an accessible memory location. But by convention, if a pointer contains the nil (zero) value, it is assumed to point to nothing.</p>

<p>To check for a nil pointer you can use an if statement as follows:</p>

<h2>Go Pointers in Detail:</h2>

<p>Pointers have many but easy concepts and they are very important to Go programming. There are following few important pointer concepts which should be clear to a Go programmer:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   var a int = 10   

   fmt.Printf("Address of a variable: %x\n", &amp;a  )
}
</pre>
<p>When the above code is compiled and executed, it produces result something as follows:</p>
<pre class="result">
Address of a variable: 10328000
</pre>
<p>So you understood what is memory address and how to access it, so base of the concept is over. Now let us see what is a pointer.</p>
<h2>What Are Pointers?</h2>
<p>A <b>pointer</b> is a variable whose value is the address of another variable, i.e., direct address of the memory location. Like any variable or constant, you must declare a pointer before you can use it to store any variable address. The general form of a pointer variable declaration is:</p>
<pre class="prettyprint">
var var_name *var-type
</pre>
<p>Here, <b>type</b> is the pointer's base type; it must be a valid C data type and <b>var-name</b> is the name of the pointer variable. The asterisk * you used to declare a pointer is the same asterisk that you use for multiplication. However, in this statement the asterisk is being used to designate a variable as a pointer. Following are the valid pointer declaration:</p>
<pre class="prettyprint">
var ip *int        /* pointer to an integer */
var fp *float32    /* pointer to a float */
</pre>
<p>The actual data type of the value of all pointers, whether integer, float, or otherwise, is the same, a long hexadecimal number that represents a memory address. The only difference between pointers of different data types is the data type of the variable or constant that the pointer points to.</p>
<h2>How to use Pointers?</h2>
<p>There are few important operations, which we will do with the help of pointers very frequently. <b>(a)</b> we define a pointer variable <b>(b)</b> assign the address of a variable to a pointer and <b>(c)</b> finally access the value at the address available in the pointer variable. This is done by using unary operator <b>*</b> that returns the value of the variable located at the address specified by its operand. Following example makes use of these operations:</p>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   var a int= 20   /* actual variable declaration */
   var ip *int        /* pointer variable declaration */

   ip = &amp;a  /* store address of a in pointer variable*/

   fmt.Printf("Address of a variable: %x\n", &amp;a  )

   /* address stored in pointer variable */
   fmt.Printf("Address stored in ip variable: %x\n", ip )

   /* access the value using the pointer */
   fmt.Printf("Value of *ip variable: %d\n", *ip )
}
</pre>
<p>When the above code is compiled and executed, it produces result something as follows:</p>
<pre class="result">
Address of var variable: 10328000
Address stored in ip variable: 10328000
Value of *ip variable: 20
</pre>
<h2>nil Pointers in Go</h2>
<p>Go compiler assign a Nil value to a pointer variable in case you do not have exact address to be assigned. This is done at the time of variable declaration. A pointer that is assigned nil is called a <b>nil</b> pointer.</p>
<p>The nil pointer is a constant with a value of zero defined in several standard libraries. Consider the following program:</p>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   var  ptr *int

   fmt.Printf("The value of ptr is : %x\n", ptr  )
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
The value of ptr is 0
</pre>
<p>On most of the operating systems, programs are not permitted to access memory at address 0 because that memory is reserved by the operating system. However, the memory address 0 has special significance; it signals that the pointer is not intended to point to an accessible memory location. But by convention, if a pointer contains the nil (zero) value, it is assumed to point to nothing.</p>
<p>To check for a nil pointer you can use an if statement as follows:</p>
<pre class="prettyprint">
if(ptr != nil)     /* succeeds if p is not nil */
if(ptr == nil)    /* succeeds if p is null */
</pre>

<title>Go Structures</title>

<h1>Go - Structures</h1>

<p>Go arrays allow you to define type of variables that can hold several data items of the same kind but <b>structure</b> is another user defined data type available in Go programming, which allows you to combine data items of different kinds.</p><p>Structures are used to represent a record, Suppose you want to keep track of your books in a library. You might want to track the following attributes about each book:</p>

<p>Title</p>

<p>Author</p>

<p>Subject</p>

<p>Book ID</p>

<h2>Defining a Structure</h2>

<p>To define a structure, you must use <b>type</b> and <b>struct</b> statements. The struct statement defines a new data type, with more than one member for your program. type statement binds a name with the type which is struct in our case. The format of the struct statement is this:</p>

<p>Once a structure type is defined, it can be used to declare variables of that type using following syntax.</p>

<h2>Accessing Structure Members</h2>

<p>To access any member of a structure, we use the <b>member access operator (.)</b>. The member access operator is coded as a period between the structure variable name and the structure member that we wish to access. You would use <b>struct</b> keyword to define variables of structure type. Following is the example to explain usage of structure:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Structures as Function Arguments</h2>

<p>You can pass a structure as a function argument in very similar way as you pass any other variable or pointer. You would access structure variables in the similar way as you have accessed in the above example:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Pointers to Structures</h2>

<p>You can define pointers to structures in very similar way as you define pointer to any other variable as follows:</p>

<p>Now, you can store the address of a structure variable in the above defined pointer variable. To find the address of a structure variable, place the &amp; operator before the structure's name as follows:</p>

<p>To access the members of a structure using a pointer to that structure, you must use the "." operator as follows:</p>

<p>Let us re-write above example using structure pointer, hope this will be easy for you to understand the concept:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
type struct_variable_type struct {
   member definition;
   member definition;
   ...
   member definition;
}
</pre>
<p>Once a structure type is defined, it can be used to declare variables of that type using following syntax.</p>
<pre class="prettyprint notranslate">
variable_name := structure_variable_type {value1, value2...valuen}
</pre>
<h2>Accessing Structure Members</h2><p>To access any member of a structure, we use the <b>member access operator (.)</b>. The member access operator is coded as a period between the structure variable name and the structure member that we wish to access. You would use <b>struct</b> keyword to define variables of structure type. Following is the example to explain usage of structure:</p>
<pre class="prettyprint notranslate tryit">
package main

import "fmt"

type Books struct {
   title string
   author string
   subject string
   book_id int
}

func main() {
   var Book1 Books        /* Declare Book1 of type Book */
   var Book2 Books        /* Declare Book2 of type Book */
 
   /* book 1 specification */
   Book1.title = "Go Programming"
   Book1.author = "Mahesh Kumar"
   Book1.subject = "Go Programming Tutorial"
   Book1.book_id = 6495407

   /* book 2 specification */
   Book2.title = "Telecom Billing"
   Book2.author = "Zara Ali"
   Book2.subject = "Telecom Billing Tutorial"
   Book2.book_id = 6495700
 
   /* print Book1 info */
   fmt.Printf( "Book 1 title : %s\n", Book1.title)
   fmt.Printf( "Book 1 author : %s\n", Book1.author)
   fmt.Printf( "Book 1 subject : %s\n", Book1.subject)
   fmt.Printf( "Book 1 book_id : %d\n", Book1.book_id)

   /* print Book2 info */
   fmt.Printf( "Book 2 title : %s\n", Book2.title)
   fmt.Printf( "Book 2 author : %s\n", Book2.author)
   fmt.Printf( "Book 2 subject : %s\n", Book2.subject)
   fmt.Printf( "Book 2 book_id : %d\n", Book2.book_id)
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Book 1 title : Go Programming
Book 1 author : Mahesh Kumar
Book 1 subject : Go Programming Tutorial
Book 1 book_id : 6495407
Book 2 title : Telecom Billing
Book 2 author : Zara Ali
Book 2 subject : Telecom Billing Tutorial
Book 2 book_id : 6495700
</pre>
<h2>Structures as Function Arguments</h2>
<p>You can pass a structure as a function argument in very similar way as you pass any other variable or pointer. You would access structure variables in the similar way as you have accessed in the above example:</p>
<pre class="prettyprint notranslate tryit">
package main

import "fmt"

type Books struct {
   title string
   author string
   subject string
   book_id int
}

func main() {
   var Book1 Books        /* Declare Book1 of type Book */
   var Book2 Books        /* Declare Book2 of type Book */
 
   /* book 1 specification */
   Book1.title = "Go Programming"
   Book1.author = "Mahesh Kumar"
   Book1.subject = "Go Programming Tutorial"
   Book1.book_id = 6495407

   /* book 2 specification */
   Book2.title = "Telecom Billing"
   Book2.author = "Zara Ali"
   Book2.subject = "Telecom Billing Tutorial"
   Book2.book_id = 6495700
 
   /* print Book1 info */
   printBook(Book1)

   /* print Book2 info */
   printBook(Book2)
}
func printBook( book Books ) {
   fmt.Printf( "Book title : %s\n", book.title);
   fmt.Printf( "Book author : %s\n", book.author);
   fmt.Printf( "Book subject : %s\n", book.subject);
   fmt.Printf( "Book book_id : %d\n", book.book_id);
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Book title : Go Programming
Book author : Mahesh Kumar
Book subject : Go Programming Tutorial
Book book_id : 6495407
Book title : Telecom Billing
Book author : Zara Ali
Book subject : Telecom Billing Tutorial
Book book_id : 6495700
</pre>
<h2>Pointers to Structures</h2>
<p>You can define pointers to structures in very similar way as you define pointer to any other variable as follows:</p>
<pre class="prettyprint notranslate">
var struct_pointer *Books
</pre>
<p>Now, you can store the address of a structure variable in the above defined pointer variable. To find the address of a structure variable, place the &amp; operator before the structure's name as follows:</p>
<pre class="prettyprint notranslate">
struct_pointer = &amp;Book1;
</pre>
<p>To access the members of a structure using a pointer to that structure, you must use the "." operator as follows:</p>
<pre class="prettyprint notranslate">
struct_pointer.title;
</pre>
<p>Let us re-write above example using structure pointer, hope this will be easy for you to understand the concept:</p>
<pre class="prettyprint notranslate tryit">
package main

import "fmt"

type Books struct {
   title string
   author string
   subject string
   book_id int
}

func main() {
   var Book1 Books        /* Declare Book1 of type Book */
   var Book2 Books        /* Declare Book2 of type Book */
 
   /* book 1 specification */
   Book1.title = "Go Programming"
   Book1.author = "Mahesh Kumar"
   Book1.subject = "Go Programming Tutorial"
   Book1.book_id = 6495407

   /* book 2 specification */
   Book2.title = "Telecom Billing"
   Book2.author = "Zara Ali"
   Book2.subject = "Telecom Billing Tutorial"
   Book2.book_id = 6495700
 
   /* print Book1 info */
   printBook(&amp;Book1)

   /* print Book2 info */
   printBook(&amp;Book2)
}
func printBook( book *Books ) {
   fmt.Printf( "Book title : %s\n", book.title);
   fmt.Printf( "Book author : %s\n", book.author);
   fmt.Printf( "Book subject : %s\n", book.subject);
   fmt.Printf( "Book book_id : %d\n", book.book_id);
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Book title : Go Programming
Book author : Mahesh Kumar
Book subject : Go Programming Tutorial
Book book_id : 6495407
Book title : Telecom Billing
Book author : Zara Ali
Book subject : Telecom Billing Tutorial
Book book_id : 6495700
</pre>

<title>Go Slices</title>

<h1>Go - Slices</h1>

<p>Go Slice is an abstraction over Go Array. As Go Array allows you to define type of variables that can hold several data items of the same kind but it do not provide any inbuilt method to increase size of it dynamically or get a sub-array of its own. Slices covers this limitation. It provides many utility functions required on Array and is widely used in Go programming.</p>

<h2>Defining a slice</h2>

<p>To define a slice, you can declare it as an array without specifying size or use <b>make</b> function to create the one.</p>

<h2>len() and cap() functions</h2>

<p>As slice is an abstraction over array. It actually uses array as an underlying structure.<b>len()</b> function returns the elements presents in the slice where <b>cap()</b> function returns the capacity of slice as how many elements it can be accomodate. Following is the example to explain usage of slice:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Nil slice</h2>

<p>If a slice is declared with no inputs the by default, it is initialized as nil. Its length and capacity are zero. Following is an example:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>sub-slicing</h2>

<p>Slice allows lower-bound and upper bound to be specified to get the subslice of it using<b>[lower-bound:upper-bound]</b>. Following is the example:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>append() and copy() functions</h2>

<p>Slice allows increasing the capacity of a slice using <b>append()</b> function.Using <b>copy()</b> function, contents of a source slice are copied to destination slice. Following is the example:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint">
var numbers []int /* a slice of unspecified size */
/* numbers == []int{0,0,0,0,0}*/
numbers = make([]int,5,5) /* a slice of length 5 and capacity 5*/
</pre>
<h2>len() and cap() functions</h2>
<p>As slice is an abstraction over array. It actually uses array as an underlying structure.<b>len()</b> function returns the elements presents in the slice where <b>cap()</b> function returns the capacity of slice as how many elements it can be accomodate. Following is the example to explain usage of slice:</p>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   var numbers = make([]int,3,5)
   
   printSlice(numbers)
}

func printSlice(x []int){
   fmt.Printf("len=%d cap=%d slice=%v\n",len(x),cap(x),x)
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
len=3 cap=5 slice=[0 0 0]
</pre>
<h2>Nil slice</h2>
<p>If a slice is declared with no inputs the by default, it is initialized as nil. Its length and capacity are zero. Following is an example:</p>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   var numbers []int
   
   printSlice(numbers)
   
   if(numbers == nil){
      fmt.Printf("slice is nil")
   }
}

func printSlice(x []int){
   fmt.Printf("len=%d cap=%d slice=%v\n",len(x),cap(x),x)
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
len=0 cap=0 slice=[]
slice is nil
</pre>
<h2>sub-slicing</h2>
<p>Slice allows lower-bound and upper bound to be specified to get the subslice of it using<b>[lower-bound:upper-bound]</b>. Following is the example:</p>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   /* create a slice */
   numbers := []int{0,1,2,3,4,5,6,7,8}   
   printSlice(numbers)
   
   /* print the original slice */
   fmt.Println("numbers ==", numbers)
   
   /* print the sub slice starting from index 1(included) to index 4(excluded)*/
   fmt.Println("numbers[1:4] ==", numbers[1:4])
   
   /* missing lower bound implies 0*/
   fmt.Println("numbers[:3] ==", numbers[:3])
   
   /* missing upper bound implies len(s)*/
   fmt.Println("numbers[4:] ==", numbers[4:])
   
   numbers1 := make([]int,0,5)
   printSlice(numbers1)
   
   /* print the sub slice starting from index 0(included) to index 2(excluded) */
   number2 := numbers[:2]
   printSlice(number2)
   
   /* print the sub slice starting from index 2(included) to index 5(excluded) */
   number3 := numbers[2:5]
   printSlice(number3)
   
}

func printSlice(x []int){
   fmt.Printf("len=%d cap=%d slice=%v\n",len(x),cap(x),x)
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
len=9 cap=9 slice=[0 1 2 3 4 5 6 7 8]
numbers == [0 1 2 3 4 5 6 7 8]
numbers[1:4] == [1 2 3]
numbers[:3] == [0 1 2]
numbers[4:] == [4 5 6 7 8]
len=0 cap=5 slice=[]
len=2 cap=9 slice=[0 1]
len=3 cap=7 slice=[2 3 4]
</pre>
<h2>append() and copy() functions</h2>
<p>Slice allows increasing the capacity of a slice using <b>append()</b> function.Using <b>copy()</b> function, contents of a source slice are copied to destination slice. Following is the example:</p>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   var numbers []int
   printSlice(numbers)
   
   /* append allows nil slice */
   numbers = append(numbers, 0)
   printSlice(numbers)
   
   /* add one element to slice*/
   numbers = append(numbers, 1)
   printSlice(numbers)
   
   /* add more than one element at a time*/
   numbers = append(numbers, 2,3,4)
   printSlice(numbers)
   
   /* create a slice numbers1 with double the capacity of earlier slice*/
   numbers1 := make([]int, len(numbers), (cap(numbers))*2)
   
   /* copy content of numbers to numbers1 */
   copy(numbers1,numbers)
   printSlice(numbers1)   
}

func printSlice(x []int){
   fmt.Printf("len=%d cap=%d slice=%v\n",len(x),cap(x),x)
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
len=0 cap=0 slice=[]
len=1 cap=2 slice=[0]
len=2 cap=2 slice=[0 1]
len=5 cap=8 slice=[0 1 2 3 4]
len=5 cap=16 slice=[0 1 2 3 4]
</pre>

<title>Go Range</title>

<h1>Go - Range</h1>

<p>The <b>range</b> keyword is used in <b>for</b> loop to iterate over items of an array, slice, channel or map. With array and slices, it returns the index of the item as integer. With maps, it returns the key of the next key-value pair. Range either returns one value or two. If only one value is used on the left of a range expression, it is the 1st value in the following table.</p>

<h2>Example</h2>

<p>Following is the example:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   /* create a slice */
   numbers := []int{0,1,2,3,4,5,6,7,8} 
   
   /* print the numbers */
   for i:= range numbers {
      fmt.Println("Slice item",i,"is",numbers[i])
   }
   
   /* create a map*/
   countryCapitalMap := map[string] string {"France":"Paris","Italy":"Rome","Japan":"Tokyo"}
   
   /* print map using keys*/
   for country := range countryCapitalMap {
      fmt.Println("Capital of",country,"is",countryCapitalMap[country])
   }
   
   /* print map using key-value*/
   for country,capital := range countryCapitalMap {
      fmt.Println("Capital of",country,"is",capital)
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
Slice item 0 is 0
Slice item 1 is 1
Slice item 2 is 2
Slice item 3 is 3
Slice item 4 is 4
Slice item 5 is 5
Slice item 6 is 6
Slice item 7 is 7
Slice item 8 is 8
Capital of France is Paris
Capital of Italy is Rome
Capital of Japan is Tokyo
Capital of France is Paris
Capital of Italy is Rome
Capital of Japan is Tokyo
</pre>

<title>Go Maps</title>

<h1>Go - Maps</h1>

<p>Go provides another important data type map which maps unique keys to values. A key is an object that you use to retrieve a value at a later date. Given a key and a value, you can strore the value in a Map object. After value is stored, you can retrieve it by using its key.</p>

<h2>Defining a map</h2>

<p>You must use <b>make</b> function to create a map.</p>

<h2>Example</h2>

<p>Following example illustrates creation and usage of map.</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>delete() function</h2>

<p>delete() function is used to delete an entry from the map. It requires map and corresponding key which is to be deleted. Following is the example:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint">
/* declare a variable, by default map will be nil*/
var map_variable map[key_data_type]value_data_type

/* define the map as nil map can not be assigned any value*/
map_variable = make(map[key_data_type]value_data_type)
</pre>
<h2>Example</h2>
<p>Following example illustrates creation and usage of map.</p>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   var countryCapitalMap map[string]string
   /* create a map*/
   countryCapitalMap = make(map[string]string)
   
   /* insert key-value pairs in the map*/
   countryCapitalMap["France"] = "Paris"
   countryCapitalMap["Italy"] = "Rome"
   countryCapitalMap["Japan"] = "Tokyo"
   countryCapitalMap["India"] = "New Delhi"
   
   /* print map using keys*/
   for country := range countryCapitalMap {
      fmt.Println("Capital of",country,"is",countryCapitalMap[country])
   }
   
   /* test if entry is present in the map or not*/
   capital, ok := countryCapitalMap["United States"]
   /* if ok is true, entry is present otherwise entry is absent*/
   if(ok){
      fmt.Println("Capital of United States is", capital)  
   }else {
      fmt.Println("Capital of United States is not present") 
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
Capital of India is New Delhi
Capital of France is Paris
Capital of Italy is Rome
Capital of Japan is Tokyo
Capital of United States is not present
</pre>
<h2>delete() function</h2>
<p>delete() function is used to delete an entry from the map. It requires map and corresponding key which is to be deleted. Following is the example:</p>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {   
   /* create a map*/
   countryCapitalMap := map[string] string {"France":"Paris","Italy":"Rome","Japan":"Tokyo","India":"New Delhi"}
   
   fmt.Println("Original map")   
   
   /* print map */
   for country := range countryCapitalMap {
      fmt.Println("Capital of",country,"is",countryCapitalMap[country])
   }
   
   /* delete an entry */
   delete(countryCapitalMap,"France");
   fmt.Println("Entry for France is deleted")  
   
   fmt.Println("Updated map")   
   
   /* print map */
   for country := range countryCapitalMap {
      fmt.Println("Capital of",country,"is",countryCapitalMap[country])
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
Original Map
Capital of France is Paris
Capital of Italy is Rome
Capital of Japan is Tokyo
Capital of India is New Delhi
Entry for France is deleted
Updated Map
Capital of India is New Delhi
Capital of Italy is Rome
Capital of Japan is Tokyo
</pre>

<title>Go Recursion</title>

<h1>Go - Recursion</h1>

<p>Recursion is the process of repeating items in a self-similar way. Same applies in programming languages as well where if a programming allows you to call a function inside the same function that is called recursive call of the function as follows.</p>

<p>The Go programming language supports recursion, i.e., a function to call itself. But while using recursion, programmers need to be careful to define an exit condition from the function, otherwise it will go in infinite loop.</p>

<p>Recursive function are very useful to solve many mathematical problems like to calculate factorial of a number, generating Fibonacci series, etc.</p>

<h2>Number Factorial</h2>

<p>Following is an example, which calculates factorial for a given number using a recursive function:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Fibonacci Series</h2>

<p>Following is another example, which generates Fibonacci series for a given number using a recursive function:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
func recursion() {
   recursion() /* function calls itself */
}

func main() {
   recursion()
}
</pre>
<p>The Go programming language supports recursion, i.e., a function to call itself. But while using recursion, programmers need to be careful to define an exit condition from the function, otherwise it will go in infinite loop.</p>
<p>Recursive function are very useful to solve many mathematical problems like to calculate factorial of a number, generating Fibonacci series, etc.</p>
<h2>Number Factorial</h2>
<p>Following is an example, which calculates factorial for a given number using a recursive function:</p>
<pre class="prettyprint notranslate tryit">
package main

import "fmt"

func factorial(i int)int {
   if(i &lt;= 1) {
      return 1
   }
   return i * factorial(i - 1)
}

func main() { 
   var i int = 15
   fmt.Printf("Factorial of %d is %d", i, factorial(i))
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Factorial of 15 is 2004310016
</pre>
<h2>Fibonacci Series</h2>
<p>Following is another example, which generates Fibonacci series for a given number using a recursive function:</p>
<pre class="prettyprint notranslate tryit">
package main

import "fmt"

func fibonaci(i int) (ret int) {
   if i == 0 {
      return 0
   }
   
   if i == 1 {
      return 1
   }
    
   return fibonaci(i-1) + fibonaci(i-2)
}

func main() {
   var i int
   for i = 0; i &lt; 10; i++ {
      fmt.Printf("%d ", fibonaci(i))
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
0 1 1 2 3 5 8 13 21 34 
</pre>

<title>Go Type Casting</title>

<h1>Go - Type Casting</h1>

<p>Type casting is a way to convert a variable from one data type to another data type. For example, if you want to store a long value into a simple integer then you can type cast long to int. You can convert values from one type to another using the <b>cast operator</b> as following:</p>

<h2>Example</h2>

<p>Consider the following example where the cast operator causes the divison of one integer variable by another to be performed as a floating number operation.</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint">
type_name(expression)
</pre>
<h2>Example</h2>
<p>Consider the following example where the cast operator causes the divison of one integer variable by another to be performed as a floating number operation.</p>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   var sum int = 17
   var count int = 5
   var mean float32
   
   mean = float32(sum)/float32(count)
   fmt.Printf("Value of mean : %f\n",mean)
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
Value of mean : 3.400000
</pre>

<title>Go Interfaces</title>

<h1>Go - Interfaces</h1>

<p>Go programming provides another data type called interfaces which represents a set of method signatures. struct data type implements these interfaces to have metho definitions for the method signature of the interfaces.</p>

<h2>Syntax</h2>

<h2>Example</h2>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint">
/* define an interface */
type interface_name interface {
   method_name1 [return_type]
   method_name2 [return_type]
   method_name3 [return_type]
   ...
   method_namen [return_type]
}

/* define a struct */
type struct_name struct {
   /* variables */
}

/* implement interface methods*/
func (struct_name_variable struct_name) method_name1() [return_type] {
   /* method implementation */
}
...
func (struct_name_variable struct_name) method_namen() [return_type] {
   /* method implementation */
}
</pre>
<h2>Example</h2>
<pre class="prettyprint tryit">
package main

import (
   "fmt"
   "math"
)

/* define an interface */
type Shape interface {
   area() float64
}

/* define a circle */
type Circle struct {
   x,y,radius float64
}

/* define a rectangle */
type Rectangle struct {
   width, height float64
}

/* define a method for circle (implementation of Shape.area())*/
func(circle Circle) area() float64 {
   return math.Pi * circle.radius * circle.radius
}

/* define a method for rectangle (implementation of Shape.area())*/
func(rect Rectangle) area() float64 {
   return rect.width * rect.height
}

/* define a method for shape */
func getArea(shape Shape) float64 {
   return shape.area()
}

func main() {
   circle := Circle{x:0,y:0,radius:5}
   rectangle := Rectangle {width:10, height:5}
   
   fmt.Printf("Circle area: %f\n",getArea(circle))
   fmt.Printf("Rectangle area: %f\n",getArea(rectangle))
}

</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
Circle area: 78.539816
Rectangle area: 50.000000
</pre>

<title>Go Error Handling</title>

<h1>Go - Error Handling</h1>

<p>Go programming provides a pretty simple error handling framework with inbuit error interface type of following declaration:</p>

<p>Functions normally return error as last return value. Use <b>errors.New</b> to construct a basic error message as following:</p>

<p>Use return value and error message.</p>

<h2>Example</h2>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint">
type error interface {
   Error() string
}
</pre>
<p>Functions normally return error as last return value. Use <b>errors.New</b> to construct a basic error message as following:</p>
<pre class="prettyprint">
func Sqrt(value float64)(float64, error) {
   if(value &lt; 0){
      return 0, errors.New("Math: negative number passed to Sqrt")
   }
   return math.Sqrt(value)
}
</pre>
<p>Use return value and error message.</p>
<pre class="prettyprint">
result, err:= Sqrt(-1)

if err != nil {
   fmt.Println(err)
}
</pre>
<h2>Example</h2>
<pre class="prettyprint tryit">
package main

import "errors"
import "fmt"
import "math"

func Sqrt(value float64)(float64, error) {
   if(value &lt; 0){
      return 0, errors.New("Math: negative number passed to Sqrt")
   }
   return math.Sqrt(value), nil
}

func main() {
   result, err:= Sqrt(-1)

   if err != nil {
      fmt.Println(err)
   }else {
      fmt.Println(result)
   }
   
   result, err = Sqrt(9)

   if err != nil {
      fmt.Println(err)
   }else {
      fmt.Println(result)
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
Math: negative number passed to Sqrt
3
</pre>

<title>Go Questions and Answers - TutorialsPoing</title>

<h1>Go Questions and Answers</h1>

<p><b>Go Questions and Answers</b> has been designed with a special intention of helping students and professionals preparing for various <b>Certification Exams</b> and <b>Job Interviews</b>. This section provides a useful collection of sample Interview Questions and  Multiple Choice Questions (MCQs) and their answers with appropriate explanations.</p>

<p>This section provides a huge collection of Go Interview Questions with their answers hidden in a box to challenge you to have a go at them before discovering the correct answer.</p>

<p>This section provides a great collection of Go Multiple Choice Questions (MCQs) on a single page along with their correct answers and explanation. If you select the right option, it turns green; else red.</p>

<p>If you are preparing to appear for a Java and Go related certification exam, then this section is a must for you. This section simulates a real online test along with a given timer which challenges you to complete the test within a given time-frame. Finally you can check your overall test score and how you fared among millions of other candidates who attended this online test.</p>

<p>This section provides various mock tests that you can download at your local machine and solve offline. Every mock test is supplied with a mock test key to let you verify the final score and grade yourself.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Go Quick Guide</title>

<h1>Go - Quick Guide</h1>

<h1>Go - Overview</h1>

<p>Go is a general-purpose language designed with systems programming in mind.It was initially developed at Google in year 2007 by Robert Griesemer, Rob Pike, and Ken Thompson. It is strongly and statically typed, provides inbuilt support for garbage collection and supports concurrent programming. Programs are constructed using packages, for efficient management of dependencies. Go programming implementations use a traditional compile and link model to generate executable binaries.</p>

<p>The Go programming language was announced in November 2009 and is used in some of the Google's production systems</p>

<h2>Design Principles</h2>

<p>Support for environment adopting patterns similar to dynamic languages. For example type inference (x := 0 is valid declaration of a variable x of type int)</p>

<p>Compilation time is fast.</p>

<p>InBuilt concurrency support: light-weight processes (via goroutines), channels, select statement.</p>

<p>Conciseness, Simplicity, and Safety</p>

<p>Support for Interfaces and Type embedding.</p>

<p>Production of statically linked native binaries without external dependencies.</p>

<h2>Features excluded intentionally</h2>

<p>To keep language simple and concise, following features commonly available in similar languages are ommitted.</p>

<p>No support for type inheritance</p>

<p>No support for method or operator overloading</p>

<p>No support for circular dependencies among packages</p>

<p>No support for pointer arithmetic</p>

<p>No support for assertions</p>

<p>No support for generic programming</p>

<h2>Go Programs</h2>

<p>A Go program can vary from 3 lines to millions of lines and it should be written into one or more text files with extension ".go"; for example, hello.go. You can use "vi", "vim" or any other text editor to write your Go program into a file.</p>

<p>This tutorial assumes that you know how to edit a text file and how to write source code inside a program file.</p>

<h1>Go - Environment Setup</h1>

<h2>Try it Option Online</h2>

<p>You really do not need to set up your own environment to start learning Go programming language. Reason is very simple, we already have set up Go Programming environment online, so that you can compile and execute all the available examples online at the same time when you are doing your theory work. This gives you confidence in what you are reading and to check the result with different options. Feel free to modify any example and execute it online.</p>

<p>Try following example using <b>Try it</b> option available at the top right corner of the below sample code box:</p>

<p>For most of the examples given in this tutorial, you will find <b>Try it</b> option, so just make use of it and enjoy your learning.</p>

<h2>Local Environment Setup</h2>

<p>If you are still willing to set up your environment for Go programming language, you need the following two softwares available on your computer, (a) Text Editor and (b) The Go Compiler.</p>

<h2>Text Editor</h2>

<p>This will be used to type your program. Examples of few editors include Windows Notepad, OS Edit command, Brief, Epsilon, EMACS, and vim or vi.</p>

<p>Name and version of text editor can vary on different operating systems. For example, Notepad will be used on Windows, and vim or vi can be used on windows as well as Linux or UNIX.</p>

<p>The files you create with your editor are called source files and contain program source code. The source files for Go programs are typically named with the extension "<b>.go</b>".</p>

<p>Before starting your programming, make sure you have one text editor in place and you have enough experience to write a computer program, save it in a file, compile it and finally execute it.</p>

<h2>The Go Compiler</h2>

<p>The source code written in source file is the human readable source for your program. It needs to be "compiled", to turn into machine language so that your CPU can actually execute the program as per instructions given.</p>

<p>This Go programming language compiler will be used to compile your source code into final executable program. I assume you have basic knowledge about a programming language compiler.</p>

<p>Go distribution comes as a binary installable for FreeBSD (release 8 and above), Linux, Mac OS X (Snow Leopard and above), and Windows operating systems with the 32-bit (386) and 64-bit (amd64) x86 processor architectures. </p>

<p>Following section guides you on how to install Go binary distribution on various OS.</p>

<h2>Download Go archive</h2>

<p>Download latest version of Go installable archive file  from <a target="_blank" rel="nofollow" href="https://golang.org/dl/">Go Downloads</a>. At the time of writing this tutorial, I downloaded <i>go1.4.windows-amd64.msi</i> and copied it into C:\&gt;go folder.</p>

<h2>Installation on UNIX/Linux/Mac OS X, and FreeBSD</h2>

<p>Extract the download archive into /usr/local, creating a Go tree in /usr/local/go. For example:</p>

<p>tar -C /usr/local -xzf go1.4.linux-amd64.tar.gz</p>

<p>Add /usr/local/go/bin to the PATH environment variable.</p>

<h2>Installation on Windows</h2>

<p>Use the MSI file and follow the prompts to install the Go tools. By default, the installer uses the Go distribution in c:\Go. The installer should set the c:\Go\bin directory in window's PATH environment variable. Restart any open command prompts for the change to take effect.</p>

<h2>Verify installation</h2>

<p>Create a go file named test.go in <b>C:\>Go_WorkSpace</b>.</p>

<p><i>File: test.go</i></p>

<p>Now run the test.go to see the result:</p>

<p>Verify the Output</p>

<h1>Go - Program Structure</h1>

<p>Before we study basic building blocks of the Go programming language, let us look a bare minimum Go program structure so that we can take it as a reference in upcoming chapters.</p>

<h2>Go Hello World Example</h2>

<p>A Go program basically consists of the following parts:</p>

<p>Package Declaration</p>

<p>Import Packages</p>

<p>Functions</p>

<p>Variables</p>

<p>Statements &amp; Expressions</p>

<p>Comments</p>

<p>Let us look at a simple code that would print the words "Hello World":</p>

<p>Let us look various parts of the above program:</p>

<p>The first line of the program <i>package main</i> defines the package name in which this program should lie. It is a must statement as Go programs runs in packages. main package is the starting point to run the program. Each package has a path and name associated with it.</p>

<p>The next line<i>import "fmt"</i> is a preprocessor command which tell the Go compiler to include files lying in package fmt.</p>

<p>The next line <i>func main()</i> is the main function where program execution begins.</p>

<p>The next line /*...*/ will be ignored by the compiler and it has been put to add additional comments in the program. So such lines are called comments in the program. Comments are also represented using // similar to Java or C++ comments. </p>

<p>The next line <i>fmt.Println(...)</i> is another function available in Go which causes the message "Hello, World!" to be displayed on the screen. Here fmt package has exported Println method which is used to display message on the screen.</p>

<p>Notice the capital P of Println method. In Go language, a name is exported if it starts with capital letter. Exported means that a function or variable/constant is accessible to importer of the respective package.</p>

<h2>Execute Go Program:</h2>

<p>Lets look at how to save the source code in a file, and how to compile and run it. Following are the simple steps:</p>

<p>Open a text editor and add the above-mentioned code.</p>

<p>Save the file as <i>hello.go</i></p>

<p>Open a command prompt and go to the directory where you saved the file.</p>

<p>Type <i>go run hello.go</i> and press enter to run your code. </p>

<p>If there are no errors in your code then you will be able to see <i>"Hello World"</i> printed on the screen.</p>

<p>Make sure that go compiler is in your path and that you are running it in the directory containing source file hello.go.</p>

<h1>Go - Basic Syntax</h1>

<p>You have seen a basic structure of Go program, so it will be easy to understand other basic building blocks of the Go programming language.</p>

<h2>Tokens in Go</h2>

<p>A Go program consists of various tokens and a token is either a keyword, an identifier, a constant, a string literal, or a symbol. For example, the following Go statement consists of six tokens:</p>

<p>The individual tokens are:</p>

<h2>Line Seperator</h2>

<p>In Go program, the line seperator key is a statement terminator. That is, each individual statement don't need a special seperator like ; in C. Go compiler internally places ; as statement terminator to indicate the end of one logical entity.</p>

<p>For example, following are two different statements:</p>

<h2>Comments</h2>

<p>Comments are like helping text in your Go program and they are ignored by the compiler. They start with /* and terminates with the characters */ as shown below:</p>

<p>You cannot have comments within comments and they do not occur within a string or character literals.</p>

<h2>Identifiers</h2>

<p>A Go identifier is a name used to identify a variable, function, or any other user-defined item. An identifier starts with a letter A to Z or a to z or an underscore _ followed by zero or more letters, underscores, and digits (0 to 9).</p>

<p>identifier = letter { letter | unicode_digit } .</p>

<p>Go does not allow punctuation characters such as @, $, and % within identifiers. Go is a <b>case sensitive</b> programming language. Thus, <i>Manpower</i> and <i>manpower</i> are two different identifiers in Go. Here are some examples of acceptable identifiers:</p>

<h2>Keywords</h2>

<p>The following list shows the reserved words in Go. These reserved words may not be used as constant or variable or any other identifier names.</p>

<h2>Whitespace in Go</h2>

<p>A line containing only whitespace, possibly with a comment, is known as a blank line, and a Go compiler totally ignores it.</p>

<p>Whitespace is the term used in Go to describe blanks, tabs, newline characters and comments. Whitespace separates one part of a statement from another and enables the compiler to identify where one element in a statement, such as int, ends and the next element begins. Therefore, in the following statement:</p>

<p>There must be at least one whitespace character (usually a space) between int and age for the compiler to be able to distinguish them. On the other hand, in the following statement:</p>

<p>No whitespace characters are necessary between fruit and =, or between = and apples, although you are free to include some if you wish for readability purpose.</p>

<h1>Go - Data Types</h1>

<p>In the Go programming language, data types refer to an extensive system used for declaring variables or functions of different types. The type of a variable determines how much space it occupies in storage and how the bit pattern stored is interpreted.</p>

<p>The types in Go can be classified as follows:</p>

<p>The array types and structure types are referred to collectively as the aggregate types. The type of a function specifies the set of all functions with the same parameter and result types. We will see basic types in the following section, whereas, other types will be covered in the upcoming chapters.</p>

<h2>Integer Types</h2>

<p>The predefine architecture-independent integer types are:</p>

<h2>Floating Types</h2>

<p>The predefine architecture-independent float types are:</p>

<p>The value of an n-bit integer is n bits and is represented using two's complement arithmetic operations.</p>

<h2>Other Numeric Types</h2>

<p>There is also a set of numeric types with implementation-specific sizes:</p>

<h1>Go - Variables</h1>

<p>A variable is nothing but a name given to a storage area that our programs can manipulate. Each variable in Go has a specific type, which determines the size and layout of the variable's memory; the range of values that can be stored within that memory; and the set of operations that can be applied to the variable.</p>

<p>The name of a variable can be composed of letters, digits, and the underscore character. It must begin with either a letter or an underscore. Upper and lowercase letters are distinct because Go is case-sensitive. Based on the basic types explained in previous chapter, there will be the following basic variable types:</p>

<p>Go programming language also allows to define various other types of variables, which we will cover in subsequent chapters like Enumeration, Pointer, Array, Structure, Union, etc. For this chapter, let us study only basic variable types.</p>

<h2>Variable Definition in Go:</h2>

<p>A variable definition means to tell the compiler where and how much to create the storage for the variable. A variable definition specifies a data type and contains a list of one or more variables of that type as follows:</p>

<p>Here, <b>optional_data_type</b> is a valid Go data type including byte, int, float32, complex64, boolean or any user-defined object, etc., and <b>variable_list</b> may consist of one or more identifier names separated by commas. Some valid declarations are shown here:</p>

<p>The line <b>var i, j, k;</b> both declares and defines the variables i, j and k;  which instructs the compiler to create variables named i, j and k of type int.</p>

<p>Variables can be initialized (assigned an initial value) in their declaration. The type of variable is automatically judged by the compiler based on the value passed to it. The initializer consists of an equal sign followed by a constant expression as follows:</p>

<p>Some examples are:</p>

<p>For definition without an initializer: variables with static storage duration are implicitly initialized with nil (all bytes have the value 0); the initial value of all other variables is zero value of their data type.</p>

<h2>Static type declaration</h2>

<p>A static type variable declaration provides assurance to the compiler that there is one variable existing with the given type and name so that compiler proceed for further compilation without needing complete detail about the variable. A variable declaration has its meaning at the time of compilation only, compiler needs actual variable declaration at the time of linking of the program.</p>

<h2>Example</h2>

<p>Try following example, where variable has been declared with a type, and have been defined and initialized inside the main function:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Dynamic type declaration / Type Inference</h2>

<p>A dynamic type variable declaration requires compiler to interpret the type of variable based on value passed to it. Compiler don't need a variable to have type statically as a necessary requirement.</p>

<h2>Example</h2>

<p>Try following example, where variables have been declared without any  type, and have been defined and initialized inside the main function. Notice, in case of type inference, we've initialized the variable y with <b>:=</b> operator wheree as x is initilized using <b>=</b> operator. </p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Mixed variable declaration</h2>

<p>Variables of different types can be declared in one go using type inference. </p>

<h2>Example</h2>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Lvalues and Rvalues in Go:</h2>

<p>There are two kinds of expressions in Go:</p>

<p><b>lvalue :</b> Expressions that refer to a memory location is  called "lvalue" expression. An lvalue may appear as either the left-hand or right-hand side of an assignment.</p>

<p><b>rvalue :</b> The term rvalue refers to a data value that is stored at some address in memory. An rvalue is an expression that cannot have a value assigned to it which means an rvalue may appear on the right- but not left-hand side of an assignment.</p>

<p>Variables are lvalues and so may appear on the left-hand side of an assignment. Numeric literals are rvalues and so may not be assigned and can not appear on the left-hand side. Following is a valid statement:</p>

<p>But following is not a valid statement and would generate compile-time error:</p>

<h1>Go - Constants</h1>

<p>The constants refer to fixed values that the program may not alter during its execution. These fixed values are also called <b>literals</b>.</p>

<p>Constants can be of any of the basic data types like <i>an integer constant, a floating constant, a character constant, or a string literal</i>. There are also enumeration constants as well.</p>

<p>The <b>constants</b> are treated just like regular variables except that their values cannot be modified after their definition.</p>

<h2>Integer literals</h2>

<p>An integer literal can be a decimal, octal, or hexadecimal constant. A prefix specifies the base or radix: 0x or 0X for hexadecimal, 0 for octal, and nothing for decimal.</p>

<p>An integer literal can also have a suffix that is a combination of U and L, for unsigned and long, respectively. The suffix can be uppercase or lowercase and can be in any order.</p>

<p>Here are some examples of integer literals:</p>

<p>Following are other examples of various type of Integer literals:</p>

<h2>Floating-point literals</h2>

<p>A floating-point literal has an integer part, a decimal point, a fractional part, and an exponent part. You can represent floating point literals either in decimal form or exponential form.</p>

<p>While representing using decimal form, you must include the decimal point, the exponent, or both and while representing using exponential form, you must include the integer part, the fractional part, or both. The signed exponent is introduced by e or E.</p>

<p>Here are some examples of floating-point literals:</p>

<h2>Character constants</h2>

<p>Character literals are enclosed in single quotes, e.g., 'x' and can be stored in a simple variable of <b>char</b> type.</p>

<p>A character literal can be a plain character (e.g., 'x'), an escape sequence (e.g., '\t'), or a universal character (e.g., '\u02C0'). </p>

<p>There are certain characters in C when they are preceded by a backslash they will have special meaning and they are used to represent like newline (\n) or tab (\t). Here, you have a list of some of such escape sequence codes:</p>

<p>Following is the example to show few escape sequence characters:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>String literals</h2>

<p>String literals or constants are enclosed in double quotes "". A string contains characters that are similar to character literals: plain characters, escape sequences, and universal characters.</p>

<p>You can break a long line into multiple lines using string literals and separating them using whitespaces.</p>

<p>Here are some examples of string literals. All the three forms are identical strings.</p>

<h2>The const Keyword</h2>

<p>You can use <b>const</b> prefix to declare constants with a specific type as follows:</p>

<p>Following example explains it in detail:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>Note that it is a good programming practice to define constants in CAPITALS.</p>

<h1>Go - Operators</h1>

<p>An operator is a symbol that tells the compiler to perform specific mathematical or logical manipulations. Go language is rich in built-in operators and provides the following types of operators:</p>

<p>Arithmetic Operators</p>

<p>Relational Operators</p>

<p>Logical Operators</p>

<p>Bitwise Operators</p>

<p>Assignment Operators</p>

<p>Misc Operators</p>

<p>This tutorial will explain the arithmetic, relational, logical, bitwise, assignment and other operators one by one.</p>

<h2>Arithmetic Operators</h2>

<p>Following table shows all the arithmetic operators supported by Go language. Assume variable <b>A</b> holds 10 and variable <b>B</b> holds 20 then:</p>

<h2>Relational Operators</h2>

<p>Following table shows all the relational operators supported by Go language. Assume variable <b>A</b> holds 10 and variable <b>B</b> holds 20, then:</p>

<h2>Logical Operators</h2>

<p>Following table shows all the logical operators supported by Go language. Assume variable <b>A</b> holds 1 and variable <b>B</b> holds 0, then:</p>

<h2>Bitwise Operators</h2>

<p>Bitwise operator works on bits and perform bit-by-bit operation. The truth tables for &amp;, |, and ^ are as follows:</p>

<p>Assume if A = 60; and B = 13; now in binary format they will be as follows:</p>

<p>A = 0011 1100</p>

<p>B = 0000 1101</p>

<p>-----------------</p>

<p>A&amp;B = 0000 1100</p>

<p>A|B = 0011 1101</p>

<p>A^B = 0011 0001</p>

<p>~A&nbsp; = 1100 0011</p>

<p>The Bitwise operators supported by C language are listed in the following table. Assume variable A holds 60 and variable B holds 13, then:</p>

<h2>Assignment Operators</h2>

<p>There are following assignment operators supported by Go language:</p>

<h2> Misc Operators</h2>

<p>There are few other important operators including <b>sizeof</b> and <b>? :</b>  supported by Go Language.</p>

<h2>Operators Precedence in Go</h2>

<p>Operator precedence determines the grouping of terms in an expression. This affects how an expression is evaluated. Certain operators have higher precedence than others; for example, the multiplication operator has higher precedence than the addition operator.</p>

<p>For example x = 7 + 3 * 2; here, x is assigned 13, not 20 because operator * has higher precedence than +, so it first gets multiplied with 3*2 and then adds into 7.</p>

<p>Here, operators with the highest precedence appear at the top of the table, those with the lowest appear at the bottom. Within an expression, higher precedence operators will be evaluated first.</p>

<p>The following table lists all operators from highest precedence to lowest.</p>

<h1>Go - Arithmetic Operators</h1>

<p>Following table shows all the arithmetic operators supported by Go language. Assume variable <b>A</b> holds 10 and variable <b>B</b> holds 20, then:</p>

<h2>Example</h2>

<p>Try the following example to understand all the arithmetic operators available in Go programming language:</p>

<p>When you compile and execute the above program, it produces the following result:</p>

<h1>Go - Relational Operators</h1>

<p>Following table shows all the relational operators supported by Go language. Assume variable <b>A</b> holds true and variable <b>B</b> holds  then:</p>

<h2>Example</h2>

<p>Try the following example to understand all the relational  operators available in Go programming language:</p>

<p>When you compile and execute the above program it produces the following result:</p>

<h1>Go - Logical Operators</h1>

<p>Following table shows all the logical operators supported by Go language. Assume variable <b>A</b> holds true and variable <b>B</b> holds false, then:</p>

<h2>Example</h2>

<p>Try the following example to understand all the logical operators available in Go programming language:</p>

<p>When you compile and execute the above program it produces the following result:</p>

<h1>Go - Bitwise Operators</h1>

<p>The Bitwise operators supported by Go language are listed in the following table. Assume variable A holds 60 and variable B holds 13, then:</p>

<h2>Example</h2>

<p>Try the following example to understand all the bitwise operators available in Go programming language:</p>

<p>When you compile and execute the above program it produces the following result:</p>

<h1>Go - Assignment Operators</h1>

<p>There are following assignment operators supported by Go language:</p>

<h2>Example</h2>

<p>Try the following example to understand all the assignment operators available in Go programming language:</p>

<p>When you compile and execute the above program it produces the following result:</p>

<h1>Go - Miscellaneous Operators</h1>

<p>There are few other important operators including <b>&amp;</b> and <b>? :</b>  supported by Go Language.</p>

<h2>Example</h2>

<p>Try following example to understand all the miscellaneous operators available in Go programming language:</p>

<p>When you compile and execute the above program it produces the following result:</p>

<h1>Go - Operator Precedence</h1>

<p>Operator precedence determines the grouping of terms in an expression. This affects how an expression is evaluated. Certain operators have higher precedence than others; for example, the multiplication operator has higher precedence than the addition operator.</p>

<p>For example x = 7 + 3 * 2; here, x is assigned 13, not 20 because operator * has higher precedence than +, so it first gets multiplied with 3*2 and then adds into 7.</p>

<p>Here, operators with the highest precedence appear at the top of the table, those with the lowest appear at the bottom. Within an expression, higher precedence operators will be evaluated first.</p>

<h2>Example</h2>

<p>Try the following example to understand the operator precedence available in Go programming language:</p>

<p>When you compile and execute the above program it produces the following result:</p>

<h1>Go - Decision Making</h1>

<p>Decision making structures require that the programmer specify one or more conditions to be evaluated or tested by the program, along with a statement or statements to be executed if the condition is determined to be true, and optionally, other statements to be executed if the condition is determined to be false.</p>

<p>Following is the general form of a typical decision making structure found in most of the programming languages:</p>

<p>Go programming language provides following types of decision making statements. Click the following links to check their detail.</p>

<h1>Go - if statement</h1>

<p>An <b>if</b> statement consists of a boolean expression followed by one or more statements.</p>

<h2>Syntax:</h2>

<p>The syntax of an if statement in Go programming language is:</p>

<p>If the boolean expression evaluates to <b>true</b>, then the block of code inside the if statement will be executed. If  boolean expression evaluates to <b>false</b>, then the first set of code after the end of the if statement(after the closing curly brace) will be executed.</p>

<h2>Flow Diagram:</h2>

<h2>Example:</h2>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>Go - if...else statement</h1>

<p>An <b>if</b> statement can be followed by an optional <b>else</b> statement, which executes when the boolean expression is false.</p>

<h2>Syntax:</h2>

<p>The syntax of an <b>if...else</b> statement in Go programming language is:</p>

<p>If the boolean expression evaluates to <b>true</b>, then the <b>if block</b> of code will be executed, otherwise <b>else block</b> of code will be executed.</p>

<h2>Flow Diagram:</h2>

<h2>Example:</h2>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>The if...else if...else Statement</h2>

<p>An <b>if</b> statement can be followed by an optional <b>else if...else</b> statement, which is very useful to test various conditions using single if...else if statement.</p>

<p>When using if , else if , else statements there are few points to keep in mind:</p>

<p>An if can have zero or one else's and it must come after any else if's.</p>

<p>An if can have zero to many else if's and they must come before the else.</p>

<p>Once an else if succeeds, none of the remaining else if's or else's will be tested.</p>

<h2>Syntax:</h2>

<p>The syntax of an <b>if...else if...else</b> statement in Go programming language is:</p>

<h2>Example:</h2>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>Go - nested if statements</h1>

<p>It is always legal in Go programming to <b>nest</b> if-else statements, which means you can use one if or else if statement inside another if or else if statement(s).</p>

<h2>Syntax:</h2>

<p>The syntax for a <b>nested if</b>  statement is as follows:</p>

<p>You can nest <b>else if...else</b> in the similar way as you have nested <i>if</i> statement.</p>

<h2>Example:</h2>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>Go - switch statement</h1>

<p>A <b>switch</b> statement allows a variable to be tested for equality against a list of values. Each value is called a case, and the variable being switched on is checked for each <b>switch case</b>.</p>

<p>In Go programming, switch are of two types.</p>

<p><b>Expression Switch</b> - In expression switch, a case contains expressions which is compared against the value of the switch expression. </p>

<p><b>Type Switch</b> - In type switch, a case contain type which is compared against the type of a specially annotated switch expression.</p>

<h2>Expression Switch</h2>

<p>The syntax for a <b>expression switch</b> statement in Go programming language is as follows:</p>

<p>The following rules apply to a <b>switch</b> statement:</p>

<p>The <b>expression</b> used in a <b>switch</b> statement must have an integral or boolean expression, or be of a class type in which the class has a single conversion function to an integral or boolean value. If expression is not passed than default value is true.</p>

<p>You can have any number of case statements within a switch. Each case is followed by the value to be compared to and a colon.</p>

<p>The <b>constant-expression</b> for a case must be the same data type as the variable in the switch, and it must be a constant or a literal.</p>

<p>When the variable being switched on is equal to a case, the statements following that case will execute.No <b>break</b> is needed in the case statement.</p>

<p>A <b>switch</b> statement can have an optional <b>default</b> case, which must appear at the end of the switch. The default case can be used for performing a task when none of the cases is true. No <b>break</b> is needed in the default case.</p>

<h2>Flow Diagram:</h2>

<h2>Example:</h2>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Type Switch</h2>

<p>The syntax for a <b>type switch</b> statement in Go programming language is as follows:</p>

<p>The following rules apply to a <b>switch</b> statement:</p>

<p>The <b>expression</b> used in a <b>switch</b> statement must have an variable of interface{} type.</p>

<p>You can have any number of case statements within a switch. Each case is followed by the value to be compared to and a colon.</p>

<p>The <b>type</b> for a case must be the same data type as the variable in the switch, and it must be a valid data type.</p>

<p>When the variable being switched on is equal to a case, the statements following that case will execute.No <b>break</b> is needed in the case statement.</p>

<p>A <b>switch</b> statement can have an optional <b>default</b> case, which must appear at the end of the switch. The default case can be used for performing a task when none of the cases is true. No <b>break</b> is needed in the default case.</p>

<h2>Example:</h2>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>Go - select statement</h1>

<p>The syntax for a <b>select</b> statement in Go programming language is as follows:</p>

<p>The following rules apply to a <b>select</b> statement:</p>

<p>You can have any number of case statements within a select. Each case is followed by the value to be compared to and a colon.</p>

<p>The <b>type</b> for a case must be the a communication channel operation.</p>

<p>When the channel operation occured the statements following that case will execute.No <b>break</b> is needed in the case statement.</p>

<p>A <b>select</b> statement can have an optional <b>default</b> case, which must appear at the end of the select. The default case can be used for performing a task when none of the cases is true. No <b>break</b> is needed in the default case.</p>

<h2>Example:</h2>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>Go - Loops</h1>

<p>There may be a situation, when you need to execute a block of code several number of times. In general, statements are executed sequentially: The first statement in a function is executed first, followed by the second, and so on.</p>

<p>Programming languages provide various control structures that allow for more complicated execution paths.</p>

<p>A loop statement allows us to execute a statement or group of statements multiple times and following is the general form of a loop statement in most of the programming languages:</p>

<p>Go programming language provides the following types of loop to handle looping requirements. Click the following links to check their detail.</p>

<h2>Loop Control Statements:</h2>

<p>Loop control statements change execution from its normal sequence. When execution leaves a scope, all automatic objects that were created in that scope are destroyed.</p>

<p>C supports the following control statements. Click the following links to check their detail.</p>

<h2>The Infinite Loop:</h2>

<p>A loop becomes infinite loop if a condition never becomes false. The <b>for</b> loop is traditionally used for this purpose. Since none of the three expressions that form the for loop are required, you can make an endless loop by leaving the conditional expression empty or pass true to it.</p>

<p>When the conditional expression is absent, it is assumed to be true. You may have an initialization and increment expression, but C programmers more commonly use the for(;;) construct to signify an infinite loop.</p>

<p><b>NOTE:</b> You can terminate an infinite loop by pressing Ctrl + C keys.</p>

<h1>Go - for loop</h1>

<p>A <b>for</b> loop is a repetition control structure that allows you to efficiently write a loop that needs to execute a specific number of times.</p>

<h2>Syntax:</h2>

<p>The syntax of a <b>for</b> loop in Go programming language is:</p>

<p>Here is the flow of control in a for loop:</p>

<p>if <b>condition</b> is available, then for loop executes as long as condition is true.</p>

<p>The <b>init</b> step is executed first, and only once. This step allows you to declare and initialize any loop control variables. You are not required to put a statement here, as long as a semicolon appears.</p>

<p>Next, the <b>condition</b> is evaluated. If it is true, the body of the loop is executed. If it is false, the body of the loop does not execute and flow of control jumps to the next statement just after the for loop.</p>

<p>After the body of the for loop executes, the flow of control jumps back up to the <b>increment</b> statement. This statement allows you to update any loop control variables. This statement can be left blank, as long as a semicolon appears after the condition.</p>

<p>The condition is now evaluated again. If it is true, the loop executes and the process repeats itself (body of loop, then increment step, and then again condition). After the condition becomes false, the for loop terminates.</p>

<p>if <b>range</b> is available, then for loop executes for each item in the range.</p>

<h2>Flow Diagram:</h2>

<h2>Example:</h2>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>Go - nested for loops</h1>

<p>Go programming language allows to use one loop inside another loop. Following section shows few examples to illustrate the concept.</p>

<h2>Syntax:</h2>

<p>The syntax for a <b>nested for loop</b> statement in Go is as follows:</p>

<h2>Example:</h2>

<p>The following program uses a nested for loop to find the prime numbers from 2 to 100:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>Go - break statement</h1>

<p>The <b>break</b> statement in Go programming language has the following two usages:</p>

<p>When the <b>break</b> statement is encountered inside a loop, the loop is immediately terminated and program control resumes at the next statement following the loop.</p>

<p>It can be used to terminate a case in the <b>switch</b> statement.</p>

<p>If you are using nested loops (i.e., one loop inside another loop), the break statement will stop the execution of the innermost loop and start executing the next line of code after the block.</p>

<h2>Syntax:</h2>

<p>The syntax for a <b>break</b> statement in Go is as follows:</p>

<h2>Flow Diagram:</h2>

<h2>Example:</h2>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>Go - continue statement</h1>

<p>The <b>continue</b> statement in Go programming language works somewhat like the <b>break</b> statement. Instead of forcing termination, however, continue forces the next iteration of the loop to take place, skipping any code in between.</p>

<p>For the <b>for</b> loop, <b>continue</b> statement causes the conditional test and increment portions of the loop to execute.</p>

<h2>Syntax:</h2>

<p>The syntax for a <b>continue </b> statement in Go is as follows:</p>

<h2>Flow Diagram:</h2>

<h2>Example:</h2>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>Go - goto statement</h1>

<p>A <b>goto</b> statement in Go programming language provides an unconditional jump from the goto to a labeled statement in the same function.</p>

<p><b>NOTE:</b> Use of <b>goto</b> statement is highly discouraged in any programming language because it makes difficult to trace the control flow of a program, making the program hard to understand and hard to modify. Any program that uses a goto can be rewritten so that it doesn't need the goto.</p>

<h2>Syntax:</h2>

<p>The syntax for a <b>goto</b> statement in Go is as follows:</p>

<p>Here <b>label</b> can be any plain text except Go keyword and it can be set anywhere in the Go program above or below to <b>goto</b> statement.</p>

<h2>Flow Diagram:</h2>

<h2>Example:</h2>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>Go - Functions</h1>

<p>A function is a group of statements that together perform a task. Every Go program has at least one function, which is <b>main()</b>, and all the most trivial programs can define additional functions.</p>

<p>You can divide up your code into separate functions. How you divide up your code among different functions is up to you, but logically the division usually is so each function performs a specific task.</p>

<p>A function <b>declaration</b> tells the compiler about a function's name, return type, and parameters. A function <b>definition</b> provides the actual body of the function.</p>

<p>The Go standard library provides numerous built-in functions that your program can call. For example, function <b>len()</b> takes arguments of various types and return the length of the type. For example, if a string is passed to it, it will return length of the string in bytes and if an array is passed to it, it will return the array length as number of elements it have.</p>

<p>A function is known with various names like a method  or a sub-routine or a procedure, etc.</p>

<h2>Defining a Function:</h2>

<p>The general form of a function definition in Go programming language is as follows:</p>

<p>A function definition in Go programming language consists of a <i>function header</i> and a <i>function body</i>. Here are all the parts of a function:</p>

<p><b>func</b> func starts the declaration of a function.</p>

<p><b>Function Name:</b> This is the actual name of the function. The function name and the parameter list together constitute the function signature.</p>

<p><b>Parameters:</b> A parameter is like a placeholder. When a function is invoked, you pass a value to the parameter. This value is referred to as actual parameter or argument. The parameter list refers to the type, order, and number of the parameters of a function. Parameters are optional; that is, a function may contain no parameters.</p>

<p><b>Return Type</b>: A function may return a list of values. The <b>return_types</b> is the list of data types of the values the function returns. Some functions perform the desired operations without returning a value. In this case, the return_type is the not required.</p>

<p><b>Function Body:</b> The function body contains a collection of statements that define what the function does.</p>

<h2>Example:</h2>

<p>Following is the source code for a function called <b>max()</b>. This function takes two parameters num1 and num2 and returns the maximum between the two:</p>

<h2>Calling a Function:</h2>

<p>While creating a Go function, you give a definition of what the function has to do. To use a function, you will have to call that function to perform the defined task.</p>

<p>When a program calls a function, program control is transferred to the called function. A called function performs defined task and when its return statement is executed or when its function-ending closing brace is reached, it returns program control back to the main program.</p>

<p>To call a function, you simply need to pass the required parameters along with function name, and if function returns a value, then you can store returned value. For example:</p>

<p>I kept max() function along with main() function and compiled the source code. While running final executable, it would produce the following result:</p>

<h2>Returning multiple values from Function</h2>

<p>A Go function can return multiple values. For example:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Function Arguments:</h2>

<p>If a function is to use arguments, it must declare variables that accept the values of the arguments. These variables are called the <b>formal parameters</b> of the function.</p>

<p>The formal parameters behave like other local variables inside the function and are created upon entry into the function and destroyed upon exit.</p>

<p>While calling a function, there are two ways that arguments can be passed to a function:</p>

<p>By default, Go uses <b>call by value</b> to pass arguments. In general, this means that code within a function cannot alter the arguments used to call the function and above mentioned example while calling max() function used the same method.</p>

<h1>Go - Call by value</h1>

<p>The <b>call by value</b> method of passing arguments to a function copies the actual value of an argument into the formal parameter of the function. In this case, changes made to the parameter inside the function have no effect on the argument.</p>

<p>By default, Go programming language uses <i>call by value</i> method to pass arguments. In general, this means that code within a function cannot alter the arguments used to call the function. Consider the function <b>swap()</b> definition as follows.</p>

<p>Now, let us call the function <b>swap()</b> by passing actual values as in the following example:</p>

<p>Let us put above code in a single C file, compile and execute it, it will produce the following result:</p>

<p>Which shows that there is no change in the values though they had been changed inside the function.</p>

<h1>Go - Call by reference</h1>

<p>The <b>call by reference</b> method of passing arguments to a function copies the address of an argument into the formal parameter. Inside the function, the address is used to access the actual argument used in the call. This means that changes made to the parameter affect the passed argument.</p>

<p>To pass the value by reference, argument pointers are passed to the functions just like any other value. So accordingly you need to declare the function parameters as pointer types as in the following function <b>swap()</b>, which exchanges the values of the two integer variables pointed to by its arguments.</p>

<p>To check the more detail about Go - Pointers, you can check <b>Go - Pointers</b> chapter.</p>

<p>For now, let us call the function <b>swap()</b> by passing values by reference as in the following example:</p>

<p>Let us put above code in a single C file, compile and execute it, it will produce the following result:</p>

<p>Which shows that the change has reflected outside of the function as well unlike call by value where changes does not reflect outside of the function.</p>

<h1>Go - functions as values</h1>

<p>Go programming language provides flexibility to create functions on the fly and use them as values. In below example, we've initialized a variable with a function definition. Purpose of this function variable is just to use inbuilt math.sqrt() function. Following is the example:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>Go - function closure</h1>

<p>Go programming language supports anonymous functions which can acts as function closures. Anonymous functions are used when we want to define a function inline without passing any name to it. In our example, we've created a function getSequence() which will return another function. Purpose of this function is to close over a variable i of upper function to form a closure. Following is the example:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>Go - method</h1>

<p>Go programming language supports special types of functions called methods. In method declaration syntax, a "receiver" is present to represent the container of the function. This receiver can be used to call function using "." operator. Following is the example:</p>

<h2>Syntax</h2>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>Go - Scope Rules</h1>

<p>A scope in any programming is a region of the program where a defined variable can have its existence and beyond that variable can not be accessed. There are three places where variables can be declared in C programming language:</p>

<p>Inside a function or a block which is called <b>local</b> variables,</p>

<p>Outside of all functions which is called <b>global</b> variables.</p>

<p>In the definition of function parameters which is called <b>formal</b> parameters.</p>

<p>Let us explain what are <b>local</b> and <b>global</b> variables and <b>formal</b> parameters.</p>

<h2>Local Variables</h2>

<p>Variables that are declared inside a function or block are called local variables. They can be used only by statements that are inside that function or block of code. Local variables are not known to functions outside their own. Following is the example using local variables. Here all the variables a, b and c are local to main() function.</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Global Variables</h2>

<p>Global variables are defined outside of a function, usually on top of the program. The global variables will hold their value throughout the lifetime of your program and they can be accessed inside any of the functions defined for the program.</p>

<p>A global variable can be accessed by any function. That is, a global variable is available for use throughout your entire program after its declaration. Following is the example using global and local variables:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>A program can have same name for local and global variables but value of local variable inside a function will take preference. Following is an example:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Formal Parameters</h2>

<p>Function parameters, formal parameters, are treated as local variables with-in that function and they will take preference over the global variables. Following is an example:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Initializing Local and Global Variables</h2>

<p>When a local variable as Global variables are initialized to their corresponding 0 value. Pointer is initialized to nil.</p>

<h1>Go - String</h1>

<p>Strings, which are widely used in Go programming, are a readonly slice of bytes. In the Go programming language, strings are slices. The Go platform provides various libraries to manipulate strings.</p>

<p>unicode</p>

<p>regexp</p>

<p>strings</p>

<h2>Creating Strings:</h2>

<p>The most direct way to create a string is to write:</p>

<p>Whenever it encounters a string literal in your code, the compiler creates a string object with its value in this case, "Hello world!'.</p>

<p>A string literal holds a valid UTF-8 sequences called runes. A String holds arbitrary bytes.</p>

<p>This would produce the following result:</p>

<p><b>Note:</b> The string literal is immutable, so that once it is created a string literal cannot be changed.</p>

<h2>String Length:</h2>

<p>len(str) method returns the number of bytes contained in the string literal.</p>

<p>This would produce the following result:</p>

<h2>Concatenating Strings:</h2>

<p>The strings package includes a method join for concatenating multiple strings:</p>

<p>Join concatenates the elements of an array to create a single string. Second parameter is seperator which is placed between element of the array.</p>

<p>Let us look at the following example:</p>

<p>This would produce the following result:</p>

<h1>Go - Arrays</h1>

<p>Go programming language provides a data structure called <b>the array</b>, which can store a fixed-size sequential collection of elements of the same type. An array is used to store a collection of data, but it is often more useful to think of an array as a collection of variables of the same type.</p>

<p>Instead of declaring individual variables, such as number0, number1, ..., and number99, you declare one array variable such as numbers and use numbers[0], numbers[1], and ..., numbers[99] to represent individual variables. A specific element in an array is accessed by an index. </p>

<p>All arrays consist of contiguous memory locations. The lowest address corresponds to the first element and the highest address to the last element.</p>

<h2>Declaring Arrays</h2>

<p>To declare an array in Go, a programmer specifies the type of the elements and the number of elements required by an array as follows:</p>

<p>This is called a <i>single-dimensional</i> array. The <b>arraySize</b> must be an integer constant greater than zero and <b>type</b> can be any valid Go data type. For example, to declare a 10-element array called <b>balance</b> of type float32, use this statement:</p>

<p>Now <i>balance</i> is avariable array which is sufficient to hold upto 10 float numbers.</p>

<h2>Initializing Arrays</h2>

<p>You can initialize array in Go either one by one or using a single statement as follows:</p>

<p>The number of values between braces { } can not be larger than the number of elements that we declare for the array between square brackets [ ].</p>

<p>If you omit the size of the array, an array just big enough to hold the initialization is created.  Therefore, if you write:</p>

<p>You will create exactly the same array as you did in the previous example. Following is an example to assign a single element of the array:</p>

<p>The above statement assigns element number 5th in the array with a value of 50.0. All arrays have 0 as the index of their first element which is also called base index and last index of an array will be total size of the array minus 1. Following is the pictorial representation  of the same array we discussed above:</p>

<h2>Accessing Array Elements</h2>

<p>An element is accessed by indexing the array name. This is done by placing the index of the element within square brackets after the name of the array. For example:</p>

<p>The above statement will take 10th element from the array and assign the value to salary variable. Following is an example which will use all the above mentioned three concepts viz. declaration, assignment and accessing arrays:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Go Arrays in Detail</h2>

<p>Arrays are important to C and should need lots of more details. There are following few important concepts related to array which should be clear to a C programmer:</p>

<h1>Go - Multi-dimensional arrays</h1>

<p>Go programming language allows multidimensional arrays. Here is the general form of a multidimensional array declaration:</p>

<p>For example, the following declaration creates a three dimensional 5 . 10 . 4 integer array:</p>

<h2>Two-Dimensional Arrays:</h2>

<p>The simplest form of the multidimensional array is the two-dimensional array. A two-dimensional array is, in essence, a list of one-dimensional arrays. To declare a two-dimensional integer array of size x,y you would write something as follows:</p>

<p>Where <b>variable_type</b> can be any valid Go data type and <b>arrayName</b> will be a valid Go identifier. A two-dimensional array can be think as a table which will have x number of rows and y number of columns. A 2-dimensional array <b>a</b>, which contains three rows and four columns can be shown as below:</p>

<p>Thus, every element in array a is identified  by an element name of the form <b>a[ i ][ j ]</b>, where a is the name of the array, and i and j are the subscripts that uniquely identify each element in a.</p>

<h2>Initializing Two-Dimensional Arrays:</h2>

<p>Multidimensional arrays may be initialized by specifying bracketed values for each row. Following is an array with 3 rows and each row has 4 columns.</p>

<h2>Accessing Two-Dimensional Array Elements:</h2>

<p>An element in 2-dimensional array is accessed by using the subscripts, i.e., row index and column index of the array. For example:</p>

<p>The above statement will take 4th element from the 3rd row of the array. You can verify it in the above diagram. Let us check below program where we have used nested loop to handle a two dimensional array:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>As explained above, you can have arrays with any number of dimensions, although it is likely that most of the arrays you create will be of one or two dimensions.</p>

<h1>Go - Passing arrays to functions</h1>

<p>If you want to pass a single-dimension array as an argument in a function, you would have to declare function formal parameter in one of following two ways and all two declaration methods produce similar results because each tells the compiler that an integer array is going to be received. Similar way you can pass multi-dimensional  array as formal parameters.</p>

<h2>Way-1</h2>

<p>Formal parameters as a sized array as follows:</p>

<h2>Way-2</h2>

<p>Formal parameters as an unsized array as follows:</p>

<h2>Example</h2>

<p>Now, consider the following function, which will take an array as an argument along with another argument and based on the passed arguments, it will return average of the numbers passed through the array as follows:</p>

<p>Now, let us call the above function as follows:</p>

<p>When the above code is compiled together and executed, it produces the following result:</p>

<p>As you can see, the length of the array doesn't matter as far as the function is concerned because Go performs no bounds checking for the formal parameters.</p>

<h1>Go - Pointers</h1>

<p>Pointers in Go are easy and fun to learn. Some Go programming tasks are performed more easily with pointers, and other tasks, such as call by reference, cannot be performed without using pointers. So it becomes necessary to learn pointers to become a perfect Go programmer. Let's start learning them in simple and easy steps.</p>

<p>As you know, every variable is a memory location and every memory location has its address defined which can be accessed using ampersand (&amp;) operator, which denotes an address in memory. Consider the following example, which will print the address of the variables defined:</p>

<p>When the above code is compiled and executed, it produces result something as follows:</p>

<p>So you understood what is memory address and how to access it, so base of the concept is over. Now let us see what is a pointer.</p>

<h2>What Are Pointers?</h2>

<p>A <b>pointer</b> is a variable whose value is the address of another variable, i.e., direct address of the memory location. Like any variable or constant, you must declare a pointer before you can use it to store any variable address. The general form of a pointer variable declaration is:</p>

<p>Here, <b>type</b> is the pointer's base type; it must be a valid C data type and <b>var-name</b> is the name of the pointer variable. The asterisk * you used to declare a pointer is the same asterisk that you use for multiplication. However, in this statement the asterisk is being used to designate a variable as a pointer. Following are the valid pointer declaration:</p>

<p>The actual data type of the value of all pointers, whether integer, float, or otherwise, is the same, a long hexadecimal number that represents a memory address. The only difference between pointers of different data types is the data type of the variable or constant that the pointer points to.</p>

<h2>How to use Pointers?</h2>

<p>There are few important operations, which we will do with the help of pointers very frequently. <b>(a)</b> we define a pointer variable <b>(b)</b> assign the address of a variable to a pointer and <b>(c)</b> finally access the value at the address available in the pointer variable. This is done by using unary operator <b>*</b> that returns the value of the variable located at the address specified by its operand. Following example makes use of these operations:</p>

<p>When the above code is compiled and executed, it produces result something as follows:</p>

<h2>nil Pointers in Go</h2>

<p>Go compiler assign a Nil value to a pointer variable in case you do not have exact address to be assigned. This is done at the time of variable declaration. A pointer that is assigned nil is called a <b>nil</b> pointer.</p>

<p>The nil pointer is a constant with a value of zero defined in several standard libraries. Consider the following program:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>On most of the operating systems, programs are not permitted to access memory at address 0 because that memory is reserved by the operating system. However, the memory address 0 has special significance; it signals that the pointer is not intended to point to an accessible memory location. But by convention, if a pointer contains the nil (zero) value, it is assumed to point to nothing.</p>

<p>To check for a nil pointer you can use an if statement as follows:</p>

<h2>Go Pointers in Detail:</h2>

<p>Pointers have many but easy concepts and they are very important to Go programming. There are following few important pointer concepts which should be clear to a Go programmer:</p>

<h1>Go - Array of pointers</h1>

<p>Before we understand the concept of arrays of pointers, let us consider the following example, which makes use of an array of 3 integers: </p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>There may be a situation when we want to maintain an array, which can store pointers to an int or string or any other data type available. Following is the declaration of an array of pointers to an integer:</p>

<p>This declares <b>ptr</b> as an array of MAX integer pointers. Thus, each element in ptr, now holds a pointer to an int value. Following example makes use of three integers, which will be stored in an array of pointers as follows:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>Go - Pointer to pointer</h1>

<p>A pointer to a pointer is a form of multiple indirection, or a chain of pointers. Normally, a pointer contains the address of a variable. When we define a pointer to a pointer, the first pointer contains the address of the second pointer, which points to the location that contains the actual value as shown below.</p>

<p>A variable that is a pointer to a pointer must be declared as such. This is done by placing an additional asterisk in front of its name. For example, following is the declaration to declare a  pointer to a pointer of type int:</p>

<p>When a target value is indirectly pointed to by a pointer to a pointer, accessing that value requires that the asterisk operator be applied twice, as is shown below in the example:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>Go - Passing pointers to functions</h1>

<p>Go programming language allows you to pass a pointer to a function. To do so, simply declare the function parameter as a pointer type.</p>

<p>Following a simple example where we passed two pointers to a function and change the value inside the function which reflects back in the calling function:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>Go - Structures</h1>

<p>Go arrays allow you to define type of variables that can hold several data items of the same kind but <b>structure</b> is another user defined data type available in Go programming, which allows you to combine data items of different kinds.</p><p>Structures are used to represent a record, Suppose you want to keep track of your books in a library. You might want to track the following attributes about each book:</p>

<p>Title</p>

<p>Author</p>

<p>Subject</p>

<p>Book ID</p>

<h2>Defining a Structure</h2>

<p>To define a structure, you must use <b>type</b> and <b>struct</b> statements. The struct statement defines a new data type, with more than one member for your program. type statement binds a name with the type which is struct in our case. The format of the struct statement is this:</p>

<p>Once a structure type is defined, it can be used to declare variables of that type using following syntax.</p>

<h2>Accessing Structure Members</h2>

<p>To access any member of a structure, we use the <b>member access operator (.)</b>. The member access operator is coded as a period between the structure variable name and the structure member that we wish to access. You would use <b>struct</b> keyword to define variables of structure type. Following is the example to explain usage of structure:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Structures as Function Arguments</h2>

<p>You can pass a structure as a function argument in very similar way as you pass any other variable or pointer. You would access structure variables in the similar way as you have accessed in the above example:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Pointers to Structures</h2>

<p>You can define pointers to structures in very similar way as you define pointer to any other variable as follows:</p>

<p>Now, you can store the address of a structure variable in the above defined pointer variable. To find the address of a structure variable, place the &amp; operator before the structure's name as follows:</p>

<p>To access the members of a structure using a pointer to that structure, you must use the "." operator as follows:</p>

<p>Let us re-write above example using structure pointer, hope this will be easy for you to understand the concept:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>Go - Slices</h1>

<p>Go Slice is an abstraction over Go Array. As Go Array allows you to define type of variables that can hold several data items of the same kind but it do not provide any inbuilt method to increase size of it dynamically or get a sub-array of its own. Slices covers this limitation. It provides many utility functions required on Array and is widely used in Go programming.</p>

<h2>Defining a slice</h2>

<p>To define a slice, you can declare it as an array without specifying size or use <b>make</b> function to create the one.</p>

<h2>len() and cap() functions</h2>

<p>As slice is an abstraction over array. It actually uses array as an underlying structure.<b>len()</b> function returns the elements presents in the slice where <b>cap()</b> function returns the capacity of slice as how many elements it can be accomodate. Following is the example to explain usage of slice:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Nil slice</h2>

<p>If a slice is declared with no inputs the by default, it is initialized as nil. Its length and capacity are zero. Following is an example:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>sub-slicing</h2>

<p>Slice allows lower-bound and upper bound to be specified to get the subslice of it using<b>[lower-bound:upper-bound]</b>. Following is the example:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>append() and copy() functions</h2>

<p>Slice allows increasing the capacity of a slice using <b>append()</b> function.Using <b>copy()</b> function, contents of a source slice are copied to destination slice. Following is the example:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>Go - Range</h1>

<p>The <b>range</b> keyword is used in <b>for</b> loop to iterate over items of an array, slice, channel or map. With array and slices, it returns the index of the item as integer. With maps, it returns the key of the next key-value pair. Range either returns one value or two. If only one value is used on the left of a range expression, it is the 1st value in the following table.</p>

<h2>Example</h2>

<p>Following is the example:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>Go - Maps</h1>

<p>Go provides another important data type map which maps unique keys to values. A key is an object that you use to retrieve a value at a later date. Given a key and a value, you can strore the value in a Map object. After value is stored, you can retrieve it by using its key.</p>

<h2>Defining a map</h2>

<p>You must use <b>make</b> function to create a map.</p>

<h2>Example</h2>

<p>Following example illustrates creation and usage of map.</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>delete() function</h2>

<p>delete() function is used to delete an entry from the map. It requires map and corresponding key which is to be deleted. Following is the example:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>Go - Recursion</h1>

<p>Recursion is the process of repeating items in a self-similar way. Same applies in programming languages as well where if a programming allows you to call a function inside the same function that is called recursive call of the function as follows.</p>

<p>The Go programming language supports recursion, i.e., a function to call itself. But while using recursion, programmers need to be careful to define an exit condition from the function, otherwise it will go in infinite loop.</p>

<p>Recursive function are very useful to solve many mathematical problems like to calculate factorial of a number, generating Fibonacci series, etc.</p>

<h2>Number Factorial</h2>

<p>Following is an example, which calculates factorial for a given number using a recursive function:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h2>Fibonacci Series</h2>

<p>Following is another example, which generates Fibonacci series for a given number using a recursive function:</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>Go - Type Casting</h1>

<p>Type casting is a way to convert a variable from one data type to another data type. For example, if you want to store a long value into a simple integer then you can type cast long to int. You can convert values from one type to another using the <b>cast operator</b> as following:</p>

<h2>Example</h2>

<p>Consider the following example where the cast operator causes the divison of one integer variable by another to be performed as a floating number operation.</p>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>Go - Interfaces</h1>

<p>Go programming provides another data type called interfaces which represents a set of method signatures. struct data type implements these interfaces to have metho definitions for the method signature of the interfaces.</p>

<h2>Syntax</h2>

<h2>Example</h2>

<p>When the above code is compiled and executed, it produces the following result:</p>

<h1>Go - Error Handling</h1>

<p>Go programming provides a pretty simple error handling framework with inbuit error interface type of following declaration:</p>

<p>Functions normally return error as last return value. Use <b>errors.New</b> to construct a basic error message as following:</p>

<p>Use return value and error message.</p>

<h2>Example</h2>

<p>When the above code is compiled and executed, it produces the following result:</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   fmt.Println("Hello, World!")
}
</pre>
<p>For most of the examples given in this tutorial, you will find <b>Try it</b> option, so just make use of it and enjoy your learning.</p>
</blockquote>
<h2>Local Environment Setup</h2>
<p>If you are still willing to set up your environment for Go programming language, you need the following two softwares available on your computer, (a) Text Editor and (b) The Go Compiler.</p>
<h2>Text Editor</h2>
<p>This will be used to type your program. Examples of few editors include Windows Notepad, OS Edit command, Brief, Epsilon, EMACS, and vim or vi.</p>
<p>Name and version of text editor can vary on different operating systems. For example, Notepad will be used on Windows, and vim or vi can be used on windows as well as Linux or UNIX.</p>
<p>The files you create with your editor are called source files and contain program source code. The source files for Go programs are typically named with the extension "<b>.go</b>".</p>
<p>Before starting your programming, make sure you have one text editor in place and you have enough experience to write a computer program, save it in a file, compile it and finally execute it.</p>
<h2>The Go Compiler</h2>
<p>The source code written in source file is the human readable source for your program. It needs to be "compiled", to turn into machine language so that your CPU can actually execute the program as per instructions given.</p>
<p>This Go programming language compiler will be used to compile your source code into final executable program. I assume you have basic knowledge about a programming language compiler.</p>
<p>Go distribution comes as a binary installable for FreeBSD (release 8 and above), Linux, Mac OS X (Snow Leopard and above), and Windows operating systems with the 32-bit (386) and 64-bit (amd64) x86 processor architectures. </p>
<p>Following section guides you on how to install Go binary distribution on various OS.</p>
<h2>Download Go archive</h2>
<p>Download latest version of Go installable archive file  from <a target="_blank" rel="nofollow" href="https://golang.org/dl/">Go Downloads</a>. At the time of writing this tutorial, I downloaded <i>go1.4.windows-amd64.msi</i> and copied it into C:\&gt;go folder.</p>
<table class="src">
<tr><th style="width:20%">OS</th><th>Archive name</th></tr>
<tr><td>Windows</td><td>go1.4.windows-amd64.msi</td></tr>
<tr><td>Linux</td><td>go1.4.linux-amd64.tar.gz</td></tr>
<tr><td>Mac</td><td>go1.4.darwin-amd64-osx10.8.pkg</td></tr>
<tr><td>FreeBSD</td><td>go1.4.freebsd-amd64.tar.gz</td></tr>
</table>
<h2>Installation on UNIX/Linux/Mac OS X, and FreeBSD</h2>
<p>Extract the download archive into /usr/local, creating a Go tree in /usr/local/go. For example:</p>
<p>tar -C /usr/local -xzf go1.4.linux-amd64.tar.gz</p>
<p>Add /usr/local/go/bin to the PATH environment variable.</p>
<table class="src">
<tr><th style="width:20%">OS</th><th>Output</th></tr>
<tr><td>Linux</td><td>export PATH=$PATH:/usr/local/go/bin</td></tr>
<tr><td>Mac</td><td>export PATH=$PATH:/usr/local/go/bin</td></tr>
<tr><td>FreeBSD</td><td>export PATH=$PATH:/usr/local/go/bin</td></tr>
</table>
<h2>Installation on Windows</h2>
<p>Use the MSI file and follow the prompts to install the Go tools. By default, the installer uses the Go distribution in c:\Go. The installer should set the c:\Go\bin directory in window's PATH environment variable. Restart any open command prompts for the change to take effect.</p>
<h2>Verify installation</h2>
<p>Create a go file named test.go in <b>C:\>Go_WorkSpace</b>.</p>
<p><i>File: test.go</i></p>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   fmt.Println("Hello, World!")
}
</pre>
<p>Now run the test.go to see the result:</p>
<pre class="prettyprint notranslate">
C:\Go_WorkSpace>go run test.go
</pre>
<p>Verify the Output</p>
<pre class="result notranslate">
Hello, World!
</pre>
<h1>Go - Program Structure</h1>
<p>Before we study basic building blocks of the Go programming language, let us look a bare minimum Go program structure so that we can take it as a reference in upcoming chapters.</p>
<h2>Go Hello World Example</h2>
<p>A Go program basically consists of the following parts:</p>
<ul class="list">
<li><p>Package Declaration</p></li>
<li><p>Import Packages</p></li>
<li><p>Functions</p></li>
<li><p>Variables</p></li>
<li><p>Statements &amp; Expressions</p></li>
<li><p>Comments</p></li>
</ul>
<p>Let us look at a simple code that would print the words "Hello World":</p>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   /* This is my first sample program. */
   fmt.Println("Hello, World!")
}
</pre>
<p>Let us look various parts of the above program:</p>
<ol class="list">
<li><p>The first line of the program <i>package main</i> defines the package name in which this program should lie. It is a must statement as Go programs runs in packages. main package is the starting point to run the program. Each package has a path and name associated with it.</p></li>
<li><p>The next line<i>import "fmt"</i> is a preprocessor command which tell the Go compiler to include files lying in package fmt.</p></li>
<li><p>The next line <i>func main()</i> is the main function where program execution begins.</p></li>
<li><p>The next line /*...*/ will be ignored by the compiler and it has been put to add additional comments in the program. So such lines are called comments in the program. Comments are also represented using // similar to Java or C++ comments. </p></li>
<li><p>The next line <i>fmt.Println(...)</i> is another function available in Go which causes the message "Hello, World!" to be displayed on the screen. Here fmt package has exported Println method which is used to display message on the screen.</p></li>
<li><p>Notice the capital P of Println method. In Go language, a name is exported if it starts with capital letter. Exported means that a function or variable/constant is accessible to importer of the respective package.</p></li>
</ol>
<h2>Execute Go Program:</h2>
<p>Lets look at how to save the source code in a file, and how to compile and run it. Following are the simple steps:</p>
<ol class="list">
<li><p>Open a text editor and add the above-mentioned code.</p></li>
<li><p>Save the file as <i>hello.go</i></p></li>
<li><p>Open a command prompt and go to the directory where you saved the file.</p></li>
<li><p>Type <i>go run hello.go</i> and press enter to run your code. </p></li>
<li><p>If there are no errors in your code then you will be able to see <i>"Hello World"</i> printed on the screen.</p></li>
</ol>
<pre class="result">
$ go run hello.go
Hello, World!
</pre>
<p>Make sure that go compiler is in your path and that you are running it in the directory containing source file hello.go.</p>
<h1>Go - Basic Syntax</h1>
<p>You have seen a basic structure of Go program, so it will be easy to understand other basic building blocks of the Go programming language.</p>
<h2>Tokens in Go</h2>
<p>A Go program consists of various tokens and a token is either a keyword, an identifier, a constant, a string literal, or a symbol. For example, the following Go statement consists of six tokens:</p>
<pre class="prettyprint">
fmt.Println("Hello, World!")
</pre>
<p>The individual tokens are:</p>
<pre class="prettyprint">
fmt
.
Println
(
"Hello, World!"
)
</pre>
<h2>Line Seperator</h2>
<p>In Go program, the line seperator key is a statement terminator. That is, each individual statement don't need a special seperator like ; in C. Go compiler internally places ; as statement terminator to indicate the end of one logical entity.</p>
<p>For example, following are two different statements:</p>
<pre class="prettyprint">
fmt.Println("Hello, World!")
fmt.Println("I am in Go Programming World!")
</pre>
<h2>Comments</h2>
<p>Comments are like helping text in your Go program and they are ignored by the compiler. They start with /* and terminates with the characters */ as shown below:</p>
<pre class="prettyprint">
/* my first program in Go */
</pre>
<p>You cannot have comments within comments and they do not occur within a string or character literals.</p>
<h2>Identifiers</h2>
<p>A Go identifier is a name used to identify a variable, function, or any other user-defined item. An identifier starts with a letter A to Z or a to z or an underscore _ followed by zero or more letters, underscores, and digits (0 to 9).</p>
<p>identifier = letter { letter | unicode_digit } .</p>
<p>Go does not allow punctuation characters such as @, $, and % within identifiers. Go is a <b>case sensitive</b> programming language. Thus, <i>Manpower</i> and <i>manpower</i> are two different identifiers in Go. Here are some examples of acceptable identifiers:</p>
<pre class="prettyprint">
mahesh   kumar   abc   move_name   a_123
myname50   _temp   j   a23b9   retVal
</pre>
<h2>Keywords</h2>
<p>The following list shows the reserved words in Go. These reserved words may not be used as constant or variable or any other identifier names.</p>
<table class="src">
<tr>
<td style="width:25%">break</td><td style="width:25%">default</td><td style="width:25%">func</td><td style="width:25%">interface</td><td style="width:25%">select</td></tr>
<tr><td>case</td><td>defer</td><td>go</td><td>map</td><td>struct</td></tr>
<tr><td>chan</td><td>else</td><td>goto</td><td>package</td><td>switch</td></tr>
<tr><td>const</td><td>fallthrough</td><td>if</td><td>range</td><td>type</td></tr>
<tr><td>continue</td><td>for</td><td>import</td><td>return</td><td>var</td></tr>
</table>
<h2>Whitespace in Go</h2>
<p>A line containing only whitespace, possibly with a comment, is known as a blank line, and a Go compiler totally ignores it.</p>
<p>Whitespace is the term used in Go to describe blanks, tabs, newline characters and comments. Whitespace separates one part of a statement from another and enables the compiler to identify where one element in a statement, such as int, ends and the next element begins. Therefore, in the following statement:</p>
<pre class="prettyprint">
var age int;
</pre>
<p>There must be at least one whitespace character (usually a space) between int and age for the compiler to be able to distinguish them. On the other hand, in the following statement:</p>
<pre class="prettyprint">
fruit = apples + oranges;   // get the total fruit
</pre>
<p>No whitespace characters are necessary between fruit and =, or between = and apples, although you are free to include some if you wish for readability purpose.</p>
<h1>Go - Data Types</h1>
<p>In the Go programming language, data types refer to an extensive system used for declaring variables or functions of different types. The type of a variable determines how much space it occupies in storage and how the bit pattern stored is interpreted.</p>
<p>The types in Go can be classified as follows:</p>
<table class="src">
<tr><th>S.N.</th><th>Types and Description</th></tr>
<tr><td>1</td><td><b>Boolean Types</b><br>They are boolean types and consists of the two predefined constants: (a) true (b) false</td></tr>
<tr><td>2</td><td><b>Numeric Types</b><br>They are again arithmetic types and they represents a) integer types or b) floating point values throughout the program.</td></tr>
<tr><td>3</td><td><b>string types:</b><br>A string type represents the set of string values. Its value is a sequence of bytes. Strings are immutable types that is once created, it is not possible to change the contents of a string. The predeclared string type is string.</td></tr>
<tr><td>4</td><td><b>Derived types:</b><br>They include (a) Pointer types, (b) Array types, (c) Structure types, (d) Union types and (e) Function types f) Slice types g) Function types h) Interface types i) Map types j) Channel Types</td></tr>
</table>
</table>
<p>The array types and structure types are referred to collectively as the aggregate types. The type of a function specifies the set of all functions with the same parameter and result types. We will see basic types in the following section, whereas, other types will be covered in the upcoming chapters.</p>
<h2>Integer Types</h2>
<p>The predefine architecture-independent integer types are:</p>
<table class="src">
<tr><th>S.N.</th><th>Types and Description</th></tr>
<tr><td>1</td><td><b>uint8</b><br/>Unsigned  8-bit integers (0 to 255)</td></tr>
<tr><td>2</td><td><b>uint16</b><br/>Unsigned 16-bit integers (0 to 65535)</td></tr>
<tr><td>3</td><td><b>uint32</b><br/>Unsigned 32-bit integers (0 to 4294967295)</td></tr>
<tr><td>4</td><td><b>uint64</b><br/>Unsigned 64-bit integers (0 to 18446744073709551615)</td></tr>
<tr><td>5</td><td><b>int8</b><br/>Signed  8-bit integers (-128 to 127)</td></tr>
<tr><td>6</td><td><b>int16</b><br/>Signed 16-bit integers (-32768 to 32767)</td></tr>
<tr><td>7</td><td><b>int32</b><br/>Signed 32-bit integers (-2147483648 to 2147483647)</td></tr>
<tr><td>8</td><td><b>int64</b><br/>Signed 64-bit integers (-9223372036854775808 to 9223372036854775807)</td></tr>
</table>
<h2>Floating Types</h2>
<p>The predefine architecture-independent float types are:</p>
<table class="src">
<tr><th>S.N.</th><th>Types and Description</th></tr>
<tr><td>1</td><td><b>float32</b><br/>IEEE-754 32-bit floating-point numbers</td></tr>
<tr><td>2</td><td><b>float64</b><br/>IEEE-754 64-bit floating-point numbers</td></tr>
<tr><td>3</td><td><b>complex64</b><br/>Complex numbers with float32 real and imaginary parts</td></tr>
<tr><td>4</td><td><b>complex128</b><br/>Complex numbers with float64 real and imaginary parts</td></tr>
</table>
<p>The value of an n-bit integer is n bits and is represented using two's complement arithmetic operations.</p>
<h2>Other Numeric Types</h2>
<p>There is also a set of numeric types with implementation-specific sizes:</p>
<table class="src">
<tr><th>S.N.</th><th>Types and Description</th></tr>
<tr><td>1</td><td><b>byte</b><br/>same as uint8</td></tr>
<tr><td>2</td><td><b>rune</b><br/>same as int32</td></tr>
<tr><td>3</td><td><b>uint</b><br/>32 or 64 bits</td></tr>
<tr><td>4</td><td><b>int</b><br/>same size as uint</td></tr>
<tr><td>5</td><td><b>uintptr</b><br/>an unsigned integer to store the uninterpreted bits of a pointer value</td></tr>
</table>
<h1>Go - Variables</h1>
<p>A variable is nothing but a name given to a storage area that our programs can manipulate. Each variable in Go has a specific type, which determines the size and layout of the variable's memory; the range of values that can be stored within that memory; and the set of operations that can be applied to the variable.</p>
<p>The name of a variable can be composed of letters, digits, and the underscore character. It must begin with either a letter or an underscore. Upper and lowercase letters are distinct because Go is case-sensitive. Based on the basic types explained in previous chapter, there will be the following basic variable types:</p>
<table class="src">
<tr><th style="width:20%">Type</th><th>Description</th></tr>
<tr><td>byte</td><td>Typically a single octet(one byte). This is an byte type.</td></tr>
<tr><td>int</td><td>The most natural size of integer for the machine.</td></tr>
<tr><td>float32</td><td>A single-precision floating point value.</td></tr>
</table>
<p>Go programming language also allows to define various other types of variables, which we will cover in subsequent chapters like Enumeration, Pointer, Array, Structure, Union, etc. For this chapter, let us study only basic variable types.</p>
<h2>Variable Definition in Go:</h2>
<p>A variable definition means to tell the compiler where and how much to create the storage for the variable. A variable definition specifies a data type and contains a list of one or more variables of that type as follows:</p>
<pre class="prettyprint">
var variable_list optional_data_type;
</pre>
<p>Here, <b>optional_data_type</b> is a valid Go data type including byte, int, float32, complex64, boolean or any user-defined object, etc., and <b>variable_list</b> may consist of one or more identifier names separated by commas. Some valid declarations are shown here:</p>
<pre class="prettyprint">
var    i, j, k int;
var   c, ch byte;
var  f, salary float32;
d = 42;
</pre>
<p>The line <b>var i, j, k;</b> both declares and defines the variables i, j and k;  which instructs the compiler to create variables named i, j and k of type int.</p>
<p>Variables can be initialized (assigned an initial value) in their declaration. The type of variable is automatically judged by the compiler based on the value passed to it. The initializer consists of an equal sign followed by a constant expression as follows:</p>
<pre class="prettyprint">
variable_name = value;
</pre>
<p>Some examples are:</p>
<pre class="prettyprint">
d = 3, f = 5;    // declaration of d and f. Here d and f are int 
</pre>
<p>For definition without an initializer: variables with static storage duration are implicitly initialized with nil (all bytes have the value 0); the initial value of all other variables is zero value of their data type.</p>
<h2>Static type declaration</h2>
<p>A static type variable declaration provides assurance to the compiler that there is one variable existing with the given type and name so that compiler proceed for further compilation without needing complete detail about the variable. A variable declaration has its meaning at the time of compilation only, compiler needs actual variable declaration at the time of linking of the program.</p>
<h2>Example</h2>
<p>Try following example, where variable has been declared with a type, and have been defined and initialized inside the main function:</p>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   var x float64
   x = 20.0
   fmt.Println(x)
   fmt.Printf("x is of type %T\n", x)
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
20
x is of type float64
</pre>
<h2>Dynamic type declaration / Type Inference</h2>
<p>A dynamic type variable declaration requires compiler to interpret the type of variable based on value passed to it. Compiler don't need a variable to have type statically as a necessary requirement.</p>
<h2>Example</h2>
<p>Try following example, where variables have been declared without any  type, and have been defined and initialized inside the main function. Notice, in case of type inference, we've initialized the variable y with <b>:=</b> operator wheree as x is initilized using <b>=</b> operator. </p>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   var x float64 = 20.0

   y := 42 
   fmt.Println(x)
   fmt.Println(y)
   fmt.Printf("x is of type %T\n", x)
   fmt.Printf("y is of type %T\n", y)	
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
20
42
x is of type float64
y is of type int
</pre>
<h2>Mixed variable declaration</h2>
<p>Variables of different types can be declared in one go using type inference. </p>
<h2>Example</h2>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   var a, b, c = 3, 4, "foo"  
	
   fmt.Println(a)
   fmt.Println(b)
   fmt.Println(c)
   fmt.Printf("a is of type %T\n", a)
   fmt.Printf("b is of type %T\n", b)
   fmt.Printf("c is of type %T\n", c)
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
3
4
foo
a is of type int
b is of type int
c is of type string
</pre>
<h2>Lvalues and Rvalues in Go:</h2>
<p>There are two kinds of expressions in Go:</p>
<ol class="list">
<li><p><b>lvalue :</b> Expressions that refer to a memory location is  called "lvalue" expression. An lvalue may appear as either the left-hand or right-hand side of an assignment.</p></li>
<li><p><b>rvalue :</b> The term rvalue refers to a data value that is stored at some address in memory. An rvalue is an expression that cannot have a value assigned to it which means an rvalue may appear on the right- but not left-hand side of an assignment.</p></li>
</ol>
<p>Variables are lvalues and so may appear on the left-hand side of an assignment. Numeric literals are rvalues and so may not be assigned and can not appear on the left-hand side. Following is a valid statement:</p>
<pre class="prettyprint">
x = 20.0
</pre>
<p>But following is not a valid statement and would generate compile-time error:</p>
<pre class="prettyprint">
10 = 20
</pre>
<h1>Go - Constants</h1>
<p>The constants refer to fixed values that the program may not alter during its execution. These fixed values are also called <b>literals</b>.</p>
<p>Constants can be of any of the basic data types like <i>an integer constant, a floating constant, a character constant, or a string literal</i>. There are also enumeration constants as well.</p>
<p>The <b>constants</b> are treated just like regular variables except that their values cannot be modified after their definition.</p>
<h2>Integer literals</h2>
<p>An integer literal can be a decimal, octal, or hexadecimal constant. A prefix specifies the base or radix: 0x or 0X for hexadecimal, 0 for octal, and nothing for decimal.</p>
<p>An integer literal can also have a suffix that is a combination of U and L, for unsigned and long, respectively. The suffix can be uppercase or lowercase and can be in any order.</p>
<p>Here are some examples of integer literals:</p>
<pre class="prettyprint">
212         /* Legal */
215u        /* Legal */
0xFeeL      /* Legal */
078         /* Illegal: 8 is not an octal digit */
032UU       /* Illegal: cannot repeat a suffix */
</pre>
<p>Following are other examples of various type of Integer literals:</p>
<pre class="prettyprint">
85         /* decimal */
0213       /* octal */
0x4b       /* hexadecimal */
30         /* int */
30u        /* unsigned int */
30l        /* long */
30ul       /* unsigned long */
</pre>
<h2>Floating-point literals</h2>
<p>A floating-point literal has an integer part, a decimal point, a fractional part, and an exponent part. You can represent floating point literals either in decimal form or exponential form.</p>
<p>While representing using decimal form, you must include the decimal point, the exponent, or both and while representing using exponential form, you must include the integer part, the fractional part, or both. The signed exponent is introduced by e or E.</p>
<p>Here are some examples of floating-point literals:</p>
<pre class="prettyprint">
3.14159       /* Legal */
314159E-5L    /* Legal */
510E          /* Illegal: incomplete exponent */
210f          /* Illegal: no decimal or exponent */
.e55          /* Illegal: missing integer or fraction */
</pre>
<h2>Character constants</h2>
<p>Character literals are enclosed in single quotes, e.g., 'x' and can be stored in a simple variable of <b>char</b> type.</p>
<p>A character literal can be a plain character (e.g., 'x'), an escape sequence (e.g., '\t'), or a universal character (e.g., '\u02C0'). </p>
<p>There are certain characters in C when they are preceded by a backslash they will have special meaning and they are used to represent like newline (\n) or tab (\t). Here, you have a list of some of such escape sequence codes:</p>
<table class="src">
<tr><th style="width:20%">Escape sequence</th><th>Meaning</th></tr>
<tr><td>\\</td><td>\ character</td></tr>
<tr><td>\'</td><td> ' character</td></tr>
<tr><td>\"</td><td>" character</td></tr>
<tr><td>\?</td><td>? character</td></tr>
<tr><td>\a</td><td>Alert or bell</td></tr>
<tr><td>\b</td><td>Backspace</td></tr>
<tr><td>\f</td><td>Form feed</td></tr>
<tr><td>\n</td><td>Newline</td></tr>
<tr><td>\r</td><td>Carriage return</td></tr>
<tr><td>\t</td><td>Horizontal tab</td></tr>
<tr><td>\v</td><td>Vertical tab</td></tr>
<tr><td>\ooo</td><td>Octal number of one to three digits</td></tr>
<tr><td>\xhh . . .</td><td>Hexadecimal number of one or more digits</td></tr>
</table>
<p>Following is the example to show few escape sequence characters:</p>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   fmt.Printf("Hello\tWorld!")
}
</pre>
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
Hello   World!
</pre>
<h2>String literals</h2>
<p>String literals or constants are enclosed in double quotes "". A string contains characters that are similar to character literals: plain characters, escape sequences, and universal characters.</p>
<p>You can break a long line into multiple lines using string literals and separating them using whitespaces.</p>
<p>Here are some examples of string literals. All the three forms are identical strings.</p>
<pre class="prettyprint">
"hello, dear"

"hello, \

dear"

"hello, " "d" "ear"
</pre>
<h2>The const Keyword</h2>
<p>You can use <b>const</b> prefix to declare constants with a specific type as follows:</p>
<pre class="prettyprint">
const variable type = value;
</pre>
<p>Following example explains it in detail:</p>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   const LENGTH int = 10
   const WIDTH int = 5   
   var area int

   area = LENGTH * WIDTH
   fmt.Printf("value of area : %d", area)   
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
value of area : 50
</pre>
<p>Note that it is a good programming practice to define constants in CAPITALS.</p>
<h1>Go - Operators</h1>
<p>An operator is a symbol that tells the compiler to perform specific mathematical or logical manipulations. Go language is rich in built-in operators and provides the following types of operators:</p>
<ul class="list">
<li><p>Arithmetic Operators</p></li>
<li><p>Relational Operators</p></li>
<li><p>Logical Operators</p></li>
<li><p>Bitwise Operators</p></li>
<li><p>Assignment Operators</p></li>
<li><p>Misc Operators</p></li>
</ul>
<p>This tutorial will explain the arithmetic, relational, logical, bitwise, assignment and other operators one by one.</p>
<h2>Arithmetic Operators</h2>
<p>Following table shows all the arithmetic operators supported by Go language. Assume variable <b>A</b> holds 10 and variable <b>B</b> holds 20 then:</p>
<table class="src">
<tr><th style="width:10%">Operator</th><th style="width:55%;">Description</th><th>Example</th></tr>
<tr><td>+</td><td>Adds two operands</td><td> A + B will give 30</td></tr>
<tr><td>-</td><td>Subtracts second operand from the first</td><td> A - B will give -10</td></tr>
<tr><td>*</td><td>Multiplies both operands</td><td> A * B will give 200</td></tr>
<tr><td>/</td><td>Divides numerator by de-numerator</td><td> B / A will give 2</td></tr>
<tr><td>%</td><td>Modulus Operator and remainder of after an integer division</td><td> B % A will give 0</td></tr>
<tr><td>++</td><td>Increments operator increases integer value by one</td><td> A++ will give 11</td></tr>
<tr><td>--</td><td>Decrements operator decreases integer value by one</td><td> A-- will give 9</td></tr>
</table>
<h2>Relational Operators</h2>
<p>Following table shows all the relational operators supported by Go language. Assume variable <b>A</b> holds 10 and variable <b>B</b> holds 20, then:</p>
<table class="src">
<tr><th style="width:10%">Operator</th><th style="width:55%;">Description</th><th>Example</th></tr>
<tr><td>==</td><td> Checks if the values of two operands are equal or not, if yes then condition becomes true.</td><td> (A == B) is not true. </td></tr>
<tr><td>!=</td><td> Checks if the values of two operands are equal or not, if values are not equal then condition becomes true.</td><td> (A != B) is true. </td></tr>
<tr><td>&gt;</td><td> Checks if the value of left  operand is greater than the value of right operand, if yes then condition becomes true.</td><td> (A &gt; B) is not true. </td></tr>
<tr><td>&lt;</td><td> Checks if the value of left  operand is less than the value of right operand, if yes then condition becomes true.</td><td> (A &lt; B) is true. </td></tr>
<tr><td>&gt;=</td><td> Checks if the value of left  operand is greater than or equal to the value of right operand, if yes then condition becomes true.</td><td> (A &gt;= B) is not true. </td></tr>
<tr><td>&lt;=</td><td> Checks if the value of left  operand is less than or equal to the value of right operand, if yes then condition becomes true.</td><td> (A &lt;= B) is true. </td></tr>
</table>
<h2>Logical Operators</h2>
<p>Following table shows all the logical operators supported by Go language. Assume variable <b>A</b> holds 1 and variable <b>B</b> holds 0, then:</p>
<table class="src">
<tr><th style="width:10%">Operator</th><th style="width:55%;">Description</th><th>Example</th></tr>
<tr><td>&amp;&amp;</td><td> Called Logical AND  operator. If both the operands are non-zero, then condition becomes true.</td><td> (A &amp;&amp; B) is false. </td></tr>
<tr><td>||</td><td>Called Logical OR Operator.  If any of the two operands is non-zero, then condition becomes true.</td><td> (A || B) is true. </td></tr>
<tr><td>!</td><td>Called Logical NOT Operator.  Use to reverses the logical state of its operand. If a condition is true then Logical NOT operator will make false.</td><td> !(A &amp;&amp; B) is true. </td></tr>
</table>
<h2>Bitwise Operators</h2>
<p>Bitwise operator works on bits and perform bit-by-bit operation. The truth tables for &amp;, |, and ^ are as follows:</p>
<table class="src">
<tr><th style="width:20%">p</th><th style="width:20%">q</th><th style="width:20%">p &amp; q</th><th style="width:20%">p | q</th><th style="width:20%">p ^ q</th></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td></tr>
<tr><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td></tr>
</table>
<p>Assume if A = 60; and B = 13; now in binary format they will be as follows:</p>
<p>A = 0011 1100</p>
<p>B = 0000 1101</p>
<p>-----------------</p>
<p>A&amp;B = 0000 1100</p>
<p>A|B = 0011 1101</p>
<p>A^B = 0011 0001</p>
<p>~A&nbsp; = 1100 0011</p>
<p>The Bitwise operators supported by C language are listed in the following table. Assume variable A holds 60 and variable B holds 13, then:</p>
<table class="src">
<tr><th style="width:10%">Operator</th><th style="width:55%;">Description</th><th>Example</th></tr>
<tr><td>&amp;</td><td> Binary AND Operator copies a bit to the result if it exists in both operands. </td><td> (A &amp; B) will give 12, which is 0000 1100</td></tr>
<tr><td>|</td><td> Binary OR Operator copies a bit if it exists in either operand. </td><td> (A | B) will give 61, which is 0011 1101</td></tr>
<tr><td>^</td><td> Binary XOR Operator copies the bit if it is set in one operand but not both. </td><td> (A ^ B) will give 49, which is 0011 0001</td></tr>
<tr><td>&lt;&lt;</td><td> Binary Left Shift Operator. The left operands value is moved left by the number of bits specified by the right operand. </td><td> A &lt;&lt; 2 will give 240 which is 1111 0000</td></tr>
<tr><td>&gt;&gt;</td><td> Binary Right Shift Operator. The left operands value is moved right by the number of bits specified by the right operand. </td><td> A &gt;&gt; 2 will give 15 which is 0000 1111</td></tr>
</table>
<h2>Assignment Operators</h2>
<p>There are following assignment operators supported by Go language:</p>
<table class="src">
<tr><th style="width:10%">Operator</th><th style="width:55%;">Description</th><th>Example</th></tr>
<tr><td>=</td><td>Simple assignment operator, Assigns values from right side operands to left side operand</td><td> C = A + B will assign value of A + B into C</td></tr>
<tr><td>+=</td><td>Add AND assignment operator, It adds right operand to the left operand and assign the result to left operand</td><td> C += A is equivalent to C = C + A</td></tr>
<tr><td>-=</td><td>Subtract AND assignment operator, It subtracts right operand from the left operand and assign the result to left operand</td><td> C -= A is equivalent to C = C - A</td></tr>
<tr><td>*=</td><td>Multiply AND assignment operator, It multiplies right operand with the left operand and assign the result to left operand</td><td> C *= A is equivalent to C = C * A</td></tr>
<tr><td>/=</td><td>Divide AND assignment operator, It divides left operand with the right operand and assign the result to left operand</td><td> C /= A is equivalent to C = C / A</td></tr>
<tr><td>%=</td><td>Modulus AND assignment operator, It takes modulus using two operands and assign the result to  left operand</td><td> C %= A is equivalent to C = C % A</td></tr>
<tr><td>&lt;&lt;=</td><td>Left shift AND assignment operator </td><td> C &lt;&lt;= 2 is same as  C = C &lt;&lt; 2</td></tr>
<tr><td>&gt;&gt;=</td><td>Right shift AND assignment operator </td><td> C &gt;&gt;= 2 is same as  C = C &gt;&gt; 2</td></tr>
<tr><td>&amp;=</td><td>Bitwise AND assignment operator</td><td> C &amp;= 2 is same as  C = C &amp; 2</td></tr>
<tr><td>^=</td><td>bitwise exclusive OR and assignment operator</td><td> C ^= 2 is same as  C = C ^ 2</td></tr>
<tr><td>|=</td><td>bitwise inclusive OR and assignment operator</td><td> C |= 2 is same as  C = C | 2</td></tr>
</table>
<h2> Misc Operators</h2>
<p>There are few other important operators including <b>sizeof</b> and <b>? :</b>  supported by Go Language.</p>
<table class="src">
<tr><th style="width:10%">Operator</th><th style="width:55%;">Description</th><th>Example</th></tr>
<tr>
<td>&amp;</td><td>Returns the address of an variable.</td><td>&amp;a; will give actual address of the variable.</td>
</tr>
<tr>
<td>*</td><td>Pointer to a variable.</td><td>*a; will pointer to a variable.</td>
</tr>
</table>
<h2>Operators Precedence in Go</h2>
<p>Operator precedence determines the grouping of terms in an expression. This affects how an expression is evaluated. Certain operators have higher precedence than others; for example, the multiplication operator has higher precedence than the addition operator.</p>
<p>For example x = 7 + 3 * 2; here, x is assigned 13, not 20 because operator * has higher precedence than +, so it first gets multiplied with 3*2 and then adds into 7.</p>
 <p>Here, operators with the highest precedence appear at the top of the table, those with the lowest appear at the bottom. Within an expression, higher precedence operators will be evaluated first.</p>
 <p>The following table lists all operators from highest precedence to lowest.</p>
<table class="table table-bordered">
<tbody><tr>
<th>Method</th>
<th style="width:25%;">Operator</th>
<th>Description</th>
</tr>
<!--<tr>
<td>Yes</td>
<td>::</td>
<td>Constant resolution operator</td>
</tr>-->
<!--<tr>
<td>Yes</td>
<td>[ ] [ ]=</td>
<td>Element reference, element set</td>
</tr>-->
<tr>
<td>Yes</td>
<td>* / % &gt;&gt; &lt;&lt; &amp; </td>
<td>Multiply, divide, modulo, Right and left bitwise shift, Bitwise 'AND'</td>
</tr>
<tr>
<td>Yes</td>
<td>+ - | ^</td>
<td>Addition and subtraction, regular `OR', Bitwise exclusive `OR'</td>
</tr>
<tr>
<td>Yes</td>
<td>&lt;= &lt; &gt; &gt;= == !=</td>
<td>Comparison operators, Equality and pattern match operators (!= may not be defined as methods)</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&amp;&amp;</td>
<td>Logical 'AND'</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>||</td>
<td>Logical 'OR'</td>
</tr>
<!--<tr>
<td>&nbsp;</td>
<td>.. ...</td>
<td>Range (inclusive and exclusive)</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>?&nbsp;:</td>
<td>Ternary if-then-else</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>= %= { /= -= += |= &amp;= &gt;&gt;= &lt;&lt;= *= &amp;&amp;= ||= **=</td>
<td>Assignment</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>defined?</td>
<td>Check if specified symbol defined</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>not</td>
<td>Logical negation</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>or and</td>
<td>Logical composition</td>
</tr>-->
</tbody></table>
<!--<table class="src">
<tr> <th>Category&nbsp;</th> <th>Operator&nbsp;</th><th>Associativity&nbsp;</th> </tr> 
<tr> <td>Postfix&nbsp;</td><td>() [] -&gt; .  ++   - - &nbsp;</td> <td>Left to right&nbsp;</td> </tr>
<tr> <td>Unary&nbsp;</td> <td>+  -   !  ~  ++  - -   (type)*  &amp;  sizeof&nbsp;</td> <td>Right to left&nbsp;</td></tr> 
<tr> <td>Multiplicative &nbsp;</td> <td>*  /  %&nbsp;</td><td>Left to right&nbsp;</td> </tr> 
<tr> <td>Additive &nbsp;</td><td>+  -&nbsp;</td> <td>Left to right&nbsp;</td> </tr>
<tr> <td>Shift &nbsp;</td> <td>&lt;&lt; &gt;&gt;&nbsp;</td> <td>Left to right&nbsp;</td> </tr> 
<tr> <td>Relational &nbsp;</td><td>&lt; &lt;=  &gt; &gt;=&nbsp;</td> <td>Left to right&nbsp;</td> </tr>
<tr> <td>Equality &nbsp;</td> <td>==  !=&nbsp;</td> <td>Left to right&nbsp;</td> </tr> 
<tr> <td>Bitwise AND&nbsp;</td><td>&amp;&nbsp;</td> <td>Left to right&nbsp;</td> </tr> 
<tr> <td>Bitwise XOR&nbsp;</td> <td>^&nbsp;</td> <td>Left to right&nbsp;</td></tr> 
<tr> <td>Bitwise OR&nbsp;</td> <td>|&nbsp;</td> <td>Left to right&nbsp;</td></tr> 
<tr> <td>Logical AND&nbsp;</td><td>&amp;&amp;&nbsp;</td> <td>Left to right&nbsp;</td></tr>
<tr><td>Logical OR&nbsp;</td> <td>||&nbsp;</td> <td>Left to right&nbsp;</td></tr> 
<tr> <td>Conditional&nbsp;</td><td>?:&nbsp;</td> <td>Right to left&nbsp;</td> </tr>
<tr><td>Assignment&nbsp;</td> <td>=  +=  -=  *=  /=  %=&gt;&gt;=  &lt;&lt;=  &amp;=  ^=   |=&nbsp;</td><td>Right to left&nbsp;</td></tr>
<tr> <td>Comma&nbsp;</td> <td>,&nbsp;</td> <td>Left to right&nbsp;</td></tr> 
</table>-->
<h1>Go - Arithmetic Operators</h1>
<p>Following table shows all the arithmetic operators supported by Go language. Assume variable <b>A</b> holds 10 and variable <b>B</b> holds 20, then:</p>
<table class="src">
<tr><th style="width:10%">Operator</th><th style="width:55%;">Description</th><th>Example</th></tr>
<tr><td>+</td><td>Adds two operands</td><td> A + B will give 30</td></tr>
<tr><td>-</td><td>Subtracts second operand from the first</td><td> A - B will give -10</td></tr>
<tr><td>*</td><td>Multiplies both operands</td><td> A * B will give 200</td></tr>
<tr><td>/</td><td>Divides numerator by de-numerator</td><td> B / A will give 2</td></tr>
<tr><td>%</td><td>Modulus Operator and remainder of after an integer division</td><td> B % A will give 0</td></tr>
<tr><td>++</td><td>Increments operator increases integer value by one</td><td> A++ will give 11</td></tr>
<tr><td>--</td><td>Decrements operator decreases integer value by one</td><td> A-- will give 9</td></tr>
</table>
<h2>Example</h2>
<p>Try the following example to understand all the arithmetic operators available in Go programming language:</p>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {

   var a int = 21
   var b int = 10
   var c int

   c = a + b
   fmt.Printf("Line 1 - Value of c is %d\n", c )
   c = a - b
   fmt.Printf("Line 2 - Value of c is %d\n", c )
   c = a * b
   fmt.Printf("Line 3 - Value of c is %d\n", c )
   c = a / b
   fmt.Printf("Line 4 - Value of c is %d\n", c )
   c = a % b
   fmt.Printf("Line 5 - Value of c is %d\n", c )
   a++
   fmt.Printf("Line 6 - Value of a is %d\n", a )
   a--
   fmt.Printf("Line 7 - Value of a is %d\n", a )
}
</pre>
<p>When you compile and execute the above program, it produces the following result:</p>
<pre class="result">
Line 1 - Value of c is 31
Line 2 - Value of c is 11
Line 3 - Value of c is 210
Line 4 - Value of c is 2
Line 5 - Value of c is 1
Line 6 - Value of a is 22
Line 7 - Value of a is 21
</pre>
<h1>Go - Relational Operators</h1>
<p>Following table shows all the relational operators supported by Go language. Assume variable <b>A</b> holds true and variable <b>B</b> holds  then:</p>
<table class="src">
<tr><th style="width:10%">Operator</th><th style="width:55%;">Description</th><th>Example</th></tr>
<tr><td>==</td><td> Checks if the values of two operands are equal or not, if yes then condition becomes true.</td><td> (A == B) is not true. </td></tr>
<tr><td>!=</td><td> Checks if the values of two operands are equal or not, if values are not equal then condition becomes true.</td><td> (A != B) is true. </td></tr>
<tr><td>&gt;</td><td> Checks if the value of left  operand is greater than the value of right operand, if yes then condition becomes true.</td><td> (A &gt; B) is not true. </td></tr>
<tr><td>&lt;</td><td> Checks if the value of left  operand is less than the value of right operand, if yes then condition becomes true.</td><td> (A &lt; B) is true. </td></tr>
<tr><td>&gt;=</td><td> Checks if the value of left  operand is greater than or equal to the value of right operand, if yes then condition becomes true.</td><td> (A &gt;= B) is not true. </td></tr>
<tr><td>&lt;=</td><td> Checks if the value of left  operand is less than or equal to the value of right operand, if yes then condition becomes true.</td><td> (A &lt;= B) is true. </td></tr>
</table>
<h2>Example</h2>
<p>Try the following example to understand all the relational  operators available in Go programming language:</p>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   var a int = 21
   var b int = 10

   if( a == b ) {
      fmt.Printf("Line 1 - a is equal to b\n" )
   } else {
      fmt.Printf("Line 1 - a is not equal to b\n" )
   }
   if ( a &lt; b ) {
      fmt.Printf("Line 2 - a is less than b\n" )
   } else {
      fmt.Printf("Line 2 - a is not less than b\n" )
   } 
   
   if ( a &gt; b ) {
      fmt.Printf("Line 3 - a is greater than b\n" )
   } else {
      fmt.Printf("Line 3 - a is not greater than b\n" )
   }
   /* Lets change value of a and b */
   a = 5
   b = 20
   if ( a &lt;= b ) {
      fmt.Printf("Line 4 - a is either less than or equal to  b\n" )
   }
   if ( b &gt;= a ) {
      fmt.Printf("Line 5 - b is either greater than  or equal to b\n" )
   }
}
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="result">
Line 1 - a is not equal to b
Line 2 - a is not less than b
Line 3 - a is greater than b
Line 4 - a is either less than or equal to  b
Line 5 - b is either greater than  or equal to b
</pre>
<h1>Go - Logical Operators</h1>
<p>Following table shows all the logical operators supported by Go language. Assume variable <b>A</b> holds true and variable <b>B</b> holds false, then:</p>
<table class="src">
<tr><th style="width:10%">Operator</th><th style="width:55%;">Description</th><th>Example</th></tr>
<tr><td>&amp;&amp;</td><td> Called Logical AND  operator. If both the operands are false, then condition becomes false.</td><td> (A &amp;&amp; B) is false. </td></tr>
<tr><td>||</td><td>Called Logical OR Operator.  If any of the two operands is true, then condition becomes true.</td><td> (A || B) is true. </td></tr>
<tr><td>!</td><td>Called Logical NOT Operator.  Use to reverses the logical state of its operand. If a condition is true then Logical NOT operator will make false.</td><td> !(A &amp;&amp; B) is true. </td></tr>
</table>
<h2>Example</h2>
<p>Try the following example to understand all the logical operators available in Go programming language:</p>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   var a bool = true
   var b bool = false
   if ( a &amp;&amp; b ) {
      fmt.Printf("Line 1 - Condition is true\n" )
   }
   if ( a || b ) {
      fmt.Printf("Line 2 - Condition is true\n" )
   }
   /* lets change the value of  a and b */
   a = false
   b = true
   if ( a &amp;&amp; b ) {
      fmt.Printf("Line 3 - Condition is true\n" )
   } else {
      fmt.Printf("Line 3 - Condition is not true\n" )
   }
   if ( !(a &amp;&amp; b) ) {
      fmt.Printf("Line 4 - Condition is true\n" )
   }
}
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="result">
Line 2 - Condition is true
Line 3 - Condition is not true
Line 4 - Condition is true
</pre>
<h1>Go - Bitwise Operators</h1>
<p>The Bitwise operators supported by Go language are listed in the following table. Assume variable A holds 60 and variable B holds 13, then:</p>
<table class="src">
<tr><th style="width:10%">Operator</th><th style="width:55%;">Description</th><th>Example</th></tr>
<tr><td>&amp;</td><td> Binary AND Operator copies a bit to the result if it exists in both operands. </td><td> (A &amp; B) will give 12 which is 0000 1100</td></tr>
<tr><td>|</td><td> Binary OR Operator copies a bit if it exists in either operand. </td><td> (A | B) will give 61 which is 0011 1101</td></tr>
<tr><td>^</td><td> Binary XOR Operator copies the bit if it is set in one operand but not both. </td><td> (A ^ B) will give 49 which is 0011 0001</td></tr>
<tr><td>&lt;&lt;</td><td> Binary Left Shift Operator. The left operands value is moved left by the number of bits specified by the right operand. </td><td> A &lt;&lt; 2 will give 240 which is 1111 0000</td></tr>
<tr><td>&gt;&gt;</td><td> Binary Right Shift Operator. The left operands value is moved right by the number of bits specified by the right operand. </td><td> A &gt;&gt; 2 will give 15 which is 0000 1111</td></tr>
</table>
<h2>Example</h2>
<p>Try the following example to understand all the bitwise operators available in Go programming language:</p>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {

   var a uint = 60	/* 60 = 0011 1100 */  
   var b uint = 13	/* 13 = 0000 1101 */
   var c uint = 0          

   c = a &amp; b       /* 12 = 0000 1100 */ 
   fmt.Printf("Line 1 - Value of c is %d\n", c )

   c = a | b       /* 61 = 0011 1101 */
   fmt.Printf("Line 2 - Value of c is %d\n", c )

   c = a ^ b       /* 49 = 0011 0001 */
   fmt.Printf("Line 3 - Value of c is %d\n", c )

   c = a &lt;&lt; 2     /* 240 = 1111 0000 */
   fmt.Printf("Line 4 - Value of c is %d\n", c )

   c = a &gt;&gt; 2     /* 15 = 0000 1111 */
   fmt.Printf("Line 5 - Value of c is %d\n", c )
}
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="result">
Line 1 - Value of c is 12
Line 2 - Value of c is 61
Line 3 - Value of c is 49
Line 4 - Value of c is 240
Line 5 - Value of c is 15
</pre>
<h1>Go - Assignment Operators</h1>
<p>There are following assignment operators supported by Go language:</p>
<table class="src">
<tr><th style="width:10%">Operator</th><th style="width:55%;">Description</th><th>Example</th></tr>
<tr><td>=</td><td>Simple assignment operator, Assigns values from right side operands to left side operand</td><td> C = A + B will assign value of A + B into C</td></tr>
<tr><td>+=</td><td>Add AND assignment operator, It adds right operand to the left operand and assign the result to left operand</td><td> C += A is equivalent to C = C + A</td></tr>
<tr><td>-=</td><td>Subtract AND assignment operator, It subtracts right operand from the left operand and assign the result to left operand</td><td> C -= A is equivalent to C = C - A</td></tr>
<tr><td>*=</td><td>Multiply AND assignment operator, It multiplies right operand with the left operand and assign the result to left operand</td><td> C *= A is equivalent to C = C * A</td></tr>
<tr><td>/=</td><td>Divide AND assignment operator, It divides left operand with the right operand and assign the result to left operand</td><td> C /= A is equivalent to C = C / A</td></tr>
<tr><td>&lt;&lt;=</td><td>Left shift AND assignment operator </td><td> C &lt;&lt;= 2 is same as  C = C &lt;&lt; 2</td></tr>
<tr><td>&gt;&gt;=</td><td>Right shift AND assignment operator </td><td> C &gt;&gt;= 2 is same as  C = C &gt;&gt; 2</td></tr>
<tr><td>&amp;=</td><td>Bitwise AND assignment operator</td><td> C &amp;= 2 is same as  C = C &amp; 2</td></tr>
<tr><td>^=</td><td>bitwise exclusive OR and assignment operator</td><td> C ^= 2 is same as  C = C ^ 2</td></tr>
<tr><td>|=</td><td>bitwise inclusive OR and assignment operator</td><td> C |= 2 is same as  C = C | 2</td></tr>
</table>
<h2>Example</h2>
<p>Try the following example to understand all the assignment operators available in Go programming language:</p>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   var a int = 21
   var c int

   c =  a
   fmt.Printf("Line 1 - =  Operator Example, Value of c = %d\n", c )

   c +=  a
   fmt.Printf("Line 2 - += Operator Example, Value of c = %d\n", c )

   c -=  a
   fmt.Printf("Line 3 - -= Operator Example, Value of c = %d\n", c )

   c *=  a
   fmt.Printf("Line 4 - *= Operator Example, Value of c = %d\n", c )

   c /=  a
   fmt.Printf("Line 5 - /= Operator Example, Value of c = %d\n", c )

   c  = 200; 

   c &lt;&lt;=  2
   fmt.Printf("Line 6 - &lt;&lt;= Operator Example, Value of c = %d\n", c )

   c &gt;&gt;=  2
   fmt.Printf("Line 7 - &gt;&gt;= Operator Example, Value of c = %d\n", c )

   c &amp;=  2
   fmt.Printf("Line 8 - &amp;= Operator Example, Value of c = %d\n", c )

   c ^=  2
   fmt.Printf("Line 9 - ^= Operator Example, Value of c = %d\n", c )

   c |=  2
   fmt.Printf("Line 10 - |= Operator Example, Value of c = %d\n", c )

}
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="result">
Line 1 - =  Operator Example, Value of c = 21
Line 2 - += Operator Example, Value of c = 42
Line 3 - -= Operator Example, Value of c = 21
Line 4 - *= Operator Example, Value of c = 441
Line 5 - /= Operator Example, Value of c = 21
Line 6 - <<= Operator Example, Value of c = 800
Line 7 - >>= Operator Example, Value of c = 200
Line 8 - &= Operator Example, Value of c = 0
Line 9 - ^= Operator Example, Value of c = 2
Line 10 - |= Operator Example, Value of c = 2
</pre>
<h1>Go - Miscellaneous Operators</h1>
<p>There are few other important operators including <b>&amp;</b> and <b>? :</b>  supported by Go Language.</p>
<table class="src">
<tr><th style="width:10%">Operator</th><th style="width:45%;">Description</th><th>Example</th></tr>
<tr>
<td>&amp;</td><td>Returns the address of an variable.</td><td>&amp;a; will give actaul address of the variable.</td>
</tr>
<tr>
<td>*</td><td>Pointer to a variable.</td><td>*a; will pointer to a variable.</td>
</tr>
</table>
<h2>Example</h2>
<p>Try following example to understand all the miscellaneous operators available in Go programming language:</p>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   var a int = 4
   var b int32
   var c float32
   var ptr *int

   /* example of type operator */
   fmt.Printf("Line 1 - Type of variable a = %T\n", a );
   fmt.Printf("Line 2 - Type of variable b = %T\n", b );
   fmt.Printf("Line 3 - Type of variable c= %T\n", c );

   /* example of &amp; and * operators */
   ptr = &a	/* 'ptr' now contains the address of 'a'*/
   fmt.Printf("value of a is  %d\n", a);
   fmt.Printf("*ptr is %d.\n", *ptr);
}
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="result">
Line 1 - Type of variable a = int
Line 2 - Type of variable b = int32
Line 3 - Type of variable c= float32
value of a is  4
*ptr is 4.
</pre>
<h1>Go - Operator Precedence</h1>
<p>Operator precedence determines the grouping of terms in an expression. This affects how an expression is evaluated. Certain operators have higher precedence than others; for example, the multiplication operator has higher precedence than the addition operator.</p>
<p>For example x = 7 + 3 * 2; here, x is assigned 13, not 20 because operator * has higher precedence than +, so it first gets multiplied with 3*2 and then adds into 7.</p>
 <p>Here, operators with the highest precedence appear at the top of the table, those with the lowest appear at the bottom. Within an expression, higher precedence operators will be evaluated first.</p>
<table class="src">
<tr> <th>Category&nbsp;</th> <th>Operator&nbsp;</th><th>Associativity&nbsp;</th> </tr> 
<tr> <td>Postfix&nbsp;</td><td>() [] -&gt; .  ++   - - &nbsp;</td> <td>Left to right&nbsp;</td> </tr>
<tr> <td>Unary&nbsp;</td> <td>+  -   !  ~  ++  - -   (type)*  &amp;  sizeof&nbsp;</td> <td>Right to left&nbsp;</td></tr> 
<tr> <td>Multiplicative &nbsp;</td> <td>*  /  %&nbsp;</td><td>Left to right&nbsp;</td> </tr> 
<tr> <td>Additive &nbsp;</td><td>+  -&nbsp;</td> <td>Left to right&nbsp;</td> </tr>
<tr> <td>Shift &nbsp;</td> <td>&lt;&lt; &gt;&gt;&nbsp;</td> <td>Left to right&nbsp;</td> </tr> 
<tr> <td>Relational &nbsp;</td><td>&lt; &lt;=  &gt; &gt;=&nbsp;</td> <td>Left to right&nbsp;</td> </tr>
<tr> <td>Equality &nbsp;</td> <td>==  !=&nbsp;</td> <td>Left to right&nbsp;</td> </tr> 
<tr> <td>Bitwise AND&nbsp;</td><td>&amp;&nbsp;</td> <td>Left to right&nbsp;</td> </tr> 
<tr> <td>Bitwise XOR&nbsp;</td> <td>^&nbsp;</td> <td>Left to right&nbsp;</td></tr> 
<tr> <td>Bitwise OR&nbsp;</td> <td>|&nbsp;</td> <td>Left to right&nbsp;</td></tr> 
<tr> <td>Logical AND&nbsp;</td><td>&amp;&amp;&nbsp;</td> <td>Left to right&nbsp;</td></tr>
<tr><td>Logical OR&nbsp;</td> <td>||&nbsp;</td> <td>Left to right&nbsp;</td></tr> 
<tr> <td>Conditional&nbsp;</td><td>?:&nbsp;</td> <td>Right to left&nbsp;</td> </tr>
<tr><td>Assignment&nbsp;</td> <td>=  +=  -=  *=  /=  %=&gt;&gt;=  &lt;&lt;=  &amp;=  ^=   |=&nbsp;</td><td>Right to left&nbsp;</td></tr>
<tr> <td>Comma&nbsp;</td> <td>,&nbsp;</td> <td>Left to right&nbsp;</td></tr> 
</table>
<h2>Example</h2>
<p>Try the following example to understand the operator precedence available in Go programming language:</p>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   var a int = 20
   var b int = 10
   var c int = 15
   var d int = 5
   var e int;

   e = (a + b) * c / d;      // ( 30 * 15 ) / 5
   fmt.Printf("Value of (a + b) * c / d is : %d\n",  e );

   e = ((a + b) * c) / d;    // (30 * 15 ) / 5
   fmt.Printf("Value of ((a + b) * c) / d is  : %d\n" ,  e );

   e = (a + b) * (c / d);   // (30) * (15/5)
   fmt.Printf("Value of (a + b) * (c / d) is  : %d\n",  e );

   e = a + (b * c) / d;     //  20 + (150/5)
   fmt.Printf("Value of a + (b * c) / d is  : %d\n" ,  e );  
}
</pre>
<p>When you compile and execute the above program it produces the following result:</p>
<pre class="result">
Value of (a + b) * c / d is : 90
Value of ((a + b) * c) / d is  : 90
Value of (a + b) * (c / d) is  : 90
Value of a + (b * c) / d is  : 50
</pre>
<h1>Go - Decision Making</h1>
<p>Decision making structures require that the programmer specify one or more conditions to be evaluated or tested by the program, along with a statement or statements to be executed if the condition is determined to be true, and optionally, other statements to be executed if the condition is determined to be false.</p>
<p>Following is the general form of a typical decision making structure found in most of the programming languages:</p>
<img src="/go/images/decision_making.jpg" alt="Decision making statements in Go" />
<p>Go programming language provides following types of decision making statements. Click the following links to check their detail.</p>
<table class="src">
<tr><th style="width:35%">Statement</th><th>Description</th></tr>
<tr><td><b>if statement</b></td><td>An <b>if statement</b> consists of a boolean expression followed by one or more statements.</td></tr>
<tr><td><b>if...else statement</b></td><td>An <b>if statement</b> can be followed by an optional <b>else statement</b>, which executes when the boolean expression is false.</td></tr>
<tr><td><b>nested if statements</b></td><td>You can use one <b>if</b> or <b>else if</b> statement inside another <b>if</b> or <b>else if</b> statement(s).</td></tr>
<tr><td><b>switch statement</b></td><td>A <b>switch</b> statement allows a variable to be tested for equality against a list of values.</td></tr>
<tr><td><b>select statement</b></td><td>A <b>select</b> statement is similar to <b>switch</b> statement with difference as case statements refers to channel communications.</td></tr>
</table>
<h1>Go - if statement</h1>
<p>An <b>if</b> statement consists of a boolean expression followed by one or more statements.</p>
<h2>Syntax:</h2>
<p>The syntax of an if statement in Go programming language is:</p>
<pre class="prettyprint">
if(boolean_expression)
{
   /* statement(s) will execute if the boolean expression is true */
}
</pre>
<p>If the boolean expression evaluates to <b>true</b>, then the block of code inside the if statement will be executed. If  boolean expression evaluates to <b>false</b>, then the first set of code after the end of the if statement(after the closing curly brace) will be executed.</p>
<h2>Flow Diagram:</h2>
<img src="/go/images/if_statement.jpg" alt="Go if statement" />
<h2>Example:</h2>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   /* local variable definition */
   var a int = 10
 
   /* check the boolean condition using if statement */
   if( a &lt; 20 ) {
       /* if condition is true then print the following */
       fmt.Printf("a is less than 20\n" )
   }
   fmt.Printf("value of a is : %d\n", a)
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
a is less than 20;
value of a is : 10
</pre>
<h1>Go - if...else statement</h1>
<p>An <b>if</b> statement can be followed by an optional <b>else</b> statement, which executes when the boolean expression is false.</p>
<h2>Syntax:</h2>
<p>The syntax of an <b>if...else</b> statement in Go programming language is:</p>
<pre class="prettyprint">
if(boolean_expression)
{
   /* statement(s) will execute if the boolean expression is true */
}
else
{
  /* statement(s) will execute if the boolean expression is false */
}
</pre>
<p>If the boolean expression evaluates to <b>true</b>, then the <b>if block</b> of code will be executed, otherwise <b>else block</b> of code will be executed.</p>
<h2>Flow Diagram:</h2>
<img src="/go/images/if_else_statement.jpg" alt="Go if...else statement" />
<h2>Example:</h2>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   /* local variable definition */
   var a int = 100;
 
   /* check the boolean condition */
   if( a &lt; 20 ) {
       /* if condition is true then print the following */
       fmt.Printf("a is less than 20\n" );
   } else {
       /* if condition is false then print the following */
       fmt.Printf("a is not less than 20\n" );
   }
   fmt.Printf("value of a is : %d\n", a);

}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
a is not less than 20;
value of a is : 100
</pre>
<h2>The if...else if...else Statement</h2>
<p>An <b>if</b> statement can be followed by an optional <b>else if...else</b> statement, which is very useful to test various conditions using single if...else if statement.</p>
<p>When using if , else if , else statements there are few points to keep in mind:</p>
<ul class="list">
<li><p>An if can have zero or one else's and it must come after any else if's.</p></li>
<li><p>An if can have zero to many else if's and they must come before the else.</p></li>
<li><p>Once an else if succeeds, none of the remaining else if's or else's will be tested.</p></li>
</ul>
<h2>Syntax:</h2>
<p>The syntax of an <b>if...else if...else</b> statement in Go programming language is:</p>
<pre class="prettyprint">
if(boolean_expression 1)
{
   /* Executes when the boolean expression 1 is true */
}
else if( boolean_expression 2)
{
   /* Executes when the boolean expression 2 is true */
}
else if( boolean_expression 3)
{
   /* Executes when the boolean expression 3 is true */
}
else 
{
   /* executes when the none of the above condition is true */
}
</pre>
<h2>Example:</h2>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   /* local variable definition */
   var a int = 100
 
   /* check the boolean condition */
   if( a == 10 ) {
       /* if condition is true then print the following */
       fmt.Printf("Value of a is 10\n" )
   } else if( a == 20 ) {
       /* if else if condition is true */
       fmt.Printf("Value of a is 20\n" )
   } else if( a == 30 ) {
       /* if else if condition is true  */
       fmt.Printf("Value of a is 30\n" )
   } else {
       /* if none of the conditions is true */
       fmt.Printf("None of the values is matching\n" )
   }
   fmt.Printf("Exact value of a is: %d\n", a )
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
None of the values is matching
Exact value of a is: 100
</pre>
<h1>Go - nested if statements</h1>
<p>It is always legal in Go programming to <b>nest</b> if-else statements, which means you can use one if or else if statement inside another if or else if statement(s).</p>
<h2>Syntax:</h2>
<p>The syntax for a <b>nested if</b>  statement is as follows:</p>
<pre class="prettyprint">
if( boolean_expression 1)
{
   /* Executes when the boolean expression 1 is true */
   if(boolean_expression 2)
   {
      /* Executes when the boolean expression 2 is true */
   }
}
</pre>
<p>You can nest <b>else if...else</b> in the similar way as you have nested <i>if</i> statement.</p>
<h2>Example:</h2>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   /* local variable definition */
   var a int = 100
   var b int = 200
 
   /* check the boolean condition */
   if( a == 100 ) {
       /* if condition is true then check the following */
       if( b == 200 )  {
          /* if condition is true then print the following */
          fmt.Printf("Value of a is 100 and b is 200\n" );
       }
   }
   fmt.Printf("Exact value of a is : %d\n", a );
   fmt.Printf("Exact value of b is : %d\n", b );
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
Value of a is 100 and b is 200
Exact value of a is : 100
Exact value of b is : 200
</pre>
<h1>Go - switch statement</h1>
<p>A <b>switch</b> statement allows a variable to be tested for equality against a list of values. Each value is called a case, and the variable being switched on is checked for each <b>switch case</b>.</p>
<p>In Go programming, switch are of two types.</p>
<ul class="list">
<li><p><b>Expression Switch</b> - In expression switch, a case contains expressions which is compared against the value of the switch expression. </p></li>
<li><p><b>Type Switch</b> - In type switch, a case contain type which is compared against the type of a specially annotated switch expression.</p></li>
</ul>
<h2>Expression Switch</h2>
<p>The syntax for a <b>expression switch</b> statement in Go programming language is as follows:</p>
<pre class="prettyprint">
switch(boolean-expression or integral type){
    case boolean-expression or integral type  :
       statement(s);      
    case boolean-expression or integral type  :
       statement(s); 
    /* you can have any number of case statements */
    default : /* Optional */
       statement(s);
}
</pre>
<p>The following rules apply to a <b>switch</b> statement:</p>
<ul class="list">
<li><p>The <b>expression</b> used in a <b>switch</b> statement must have an integral or boolean expression, or be of a class type in which the class has a single conversion function to an integral or boolean value. If expression is not passed than default value is true.</p></li>
<li><p>You can have any number of case statements within a switch. Each case is followed by the value to be compared to and a colon.</p></li>
<li><p>The <b>constant-expression</b> for a case must be the same data type as the variable in the switch, and it must be a constant or a literal.</p></li>
<li><p>When the variable being switched on is equal to a case, the statements following that case will execute.No <b>break</b> is needed in the case statement.</p></li>
<li><p>A <b>switch</b> statement can have an optional <b>default</b> case, which must appear at the end of the switch. The default case can be used for performing a task when none of the cases is true. No <b>break</b> is needed in the default case.</p></li>
</ul>
<h2>Flow Diagram:</h2>
<img src="/go/images/switch_statement.jpg" alt="switch statement in Go" />
<h2>Example:</h2>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   /* local variable definition */
   var grade string = "B"
   var marks int = 90

   switch marks {
      case 90: grade = "A"
      case 80: grade = "B"
      case 50,60,70 : grade = "C"
      default: grade = "D"  
   }

   switch {
      case grade == "A" :
         fmt.Printf("Excellent!\n" )     
      case grade == "B", grade == "C" :
         fmt.Printf("Well done\n" )      
      case grade == "D" :
         fmt.Printf("You passed\n" )      
      case grade == "F":
         fmt.Printf("Better try again\n" )
      default:
         fmt.Printf("Invalid grade\n" );
   }
   fmt.Printf("Your grade is  %s\n", grade );      
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
Well done
Excellent!
Your grade is  A
</pre>
<h2>Type Switch</h2>
<p>The syntax for a <b>type switch</b> statement in Go programming language is as follows:</p>
<pre class="prettyprint">
switch x.(type){
    case type:
       statement(s);      
    case type:
       statement(s); 
    /* you can have any number of case statements */
    default: /* Optional */
       statement(s);
}
</pre>
<p>The following rules apply to a <b>switch</b> statement:</p>
<ul class="list">
<li><p>The <b>expression</b> used in a <b>switch</b> statement must have an variable of interface{} type.</p></li>
<li><p>You can have any number of case statements within a switch. Each case is followed by the value to be compared to and a colon.</p></li>
<li><p>The <b>type</b> for a case must be the same data type as the variable in the switch, and it must be a valid data type.</p></li>
<li><p>When the variable being switched on is equal to a case, the statements following that case will execute.No <b>break</b> is needed in the case statement.</p></li>
<li><p>A <b>switch</b> statement can have an optional <b>default</b> case, which must appear at the end of the switch. The default case can be used for performing a task when none of the cases is true. No <b>break</b> is needed in the default case.</p></li>
</ul>
<h2>Example:</h2>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   var x interface{}
     
   switch i := x.(type) {
      case nil:	  
         fmt.Printf("type of x :%T",i)                
      case int:	  
         fmt.Printf("x is int")                       
      case float64:
         fmt.Printf("x is float64")           
      case func(int) float64:
         fmt.Printf("x is func(int)")                      
      case bool, string:
         fmt.Printf("x is bool or string")       
      default:
         fmt.Printf("don't know the type")     
   }   
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
type of x :&lt;nil&gt;
</pre>
<h1>Go - select statement</h1>
<p>The syntax for a <b>select</b> statement in Go programming language is as follows:</p>
<pre class="prettyprint">
select {
    case communication clause  :
       statement(s);      
    case communication clause  :
       statement(s); 
    /* you can have any number of case statements */
    default : /* Optional */
       statement(s);
}
</pre>

<p>The following rules apply to a <b>select</b> statement:</p>
<ul class="list">
<li><p>You can have any number of case statements within a select. Each case is followed by the value to be compared to and a colon.</p></li>
<li><p>The <b>type</b> for a case must be the a communication channel operation.</p></li>
<li><p>When the channel operation occured the statements following that case will execute.No <b>break</b> is needed in the case statement.</p></li>
<li><p>A <b>select</b> statement can have an optional <b>default</b> case, which must appear at the end of the select. The default case can be used for performing a task when none of the cases is true. No <b>break</b> is needed in the default case.</p></li>
</ul>
<h2>Example:</h2>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   var c1, c2, c3 chan int
   var i1, i2 int
   select {
      case i1 = &lt;-c1:
         fmt.Printf("received ", i1, " from c1\n")
      case c2 &lt;- i2:
         fmt.Printf("sent ", i2, " to c2\n")
      case i3, ok := (&lt;-c3):  // same as: i3, ok := &lt;-c3
         if ok {
            fmt.Printf("received ", i3, " from c3\n")
         } else {
            fmt.Printf("c3 is closed\n")
         }
      default:
         fmt.Printf("no communication\n")
   }    
}   
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
no communication
</pre>
<h1>Go - Loops</h1>
<p>There may be a situation, when you need to execute a block of code several number of times. In general, statements are executed sequentially: The first statement in a function is executed first, followed by the second, and so on.</p>
<p>Programming languages provide various control structures that allow for more complicated execution paths.</p>
<p>A loop statement allows us to execute a statement or group of statements multiple times and following is the general form of a loop statement in most of the programming languages:</p>
<img src="/go/images/loop_architecture.jpg" alt="Loop Architecture" />
<p>Go programming language provides the following types of loop to handle looping requirements. Click the following links to check their detail.</p>
<table class="src">
<tr><th style="width:30%">Loop Type</th><th>Description</th></tr>
<tr><td><b>for loop</b></td><td>Execute a sequence of statements multiple times and abbreviates the code that manages the loop variable.</td></tr>
<tr><td><b>nested loops</b></td><td>You can use one or more for loop inside any for loop.</td></tr>
</table>
<h2>Loop Control Statements:</h2>
<p>Loop control statements change execution from its normal sequence. When execution leaves a scope, all automatic objects that were created in that scope are destroyed.</p>
<p>C supports the following control statements. Click the following links to check their detail.</p>
<table class="src">
<tr><th style="width:30%">Control Statement</th><th>Description</th></tr>
<tr><td><b>break statement</b></td><td>Terminates the <b>for loop</b> or <b>switch</b> statement and transfers execution to the statement immediately following the for loop or switch.</td></tr>
<tr><td><b>continue statement</b></td><td>Causes the loop to skip the remainder of its body and immediately retest its condition prior to reiterating.</td></tr>
<tr><td><b>goto statement</b></td><td>Transfers control to the labeled statement.</td></tr>
</table>
<h2>The Infinite Loop:</h2>
<p>A loop becomes infinite loop if a condition never becomes false. The <b>for</b> loop is traditionally used for this purpose. Since none of the three expressions that form the for loop are required, you can make an endless loop by leaving the conditional expression empty or pass true to it.</p>
<pre class="prettyprint">
package main

import "fmt"

func main() {
   for true  {
       fmt.Printf("This loop will run forever.\n");
   }
}
</pre>
<p>When the conditional expression is absent, it is assumed to be true. You may have an initialization and increment expression, but C programmers more commonly use the for(;;) construct to signify an infinite loop.</p>
<p><b>NOTE:</b> You can terminate an infinite loop by pressing Ctrl + C keys.</p>
<h1>Go - for loop</h1>
<p>A <b>for</b> loop is a repetition control structure that allows you to efficiently write a loop that needs to execute a specific number of times.</p>
<h2>Syntax:</h2>
<p>The syntax of a <b>for</b> loop in Go programming language is:</p>
<pre class="prettyprint">
for [condition |  ( init; condition; increment ) | Range]
{
   statement(s);
}
</pre>
<p>Here is the flow of control in a for loop:</p>
<ol class="list">
<li><p>if <b>condition</b> is available, then for loop executes as long as condition is true.</p></li>
<li><p>if for clause that is <b>( init; condition; increment )</b> is present then
<ol class="list">
<li><p>The <b>init</b> step is executed first, and only once. This step allows you to declare and initialize any loop control variables. You are not required to put a statement here, as long as a semicolon appears.</p></li>
<li><p>Next, the <b>condition</b> is evaluated. If it is true, the body of the loop is executed. If it is false, the body of the loop does not execute and flow of control jumps to the next statement just after the for loop.</p></li>
<li><p>After the body of the for loop executes, the flow of control jumps back up to the <b>increment</b> statement. This statement allows you to update any loop control variables. This statement can be left blank, as long as a semicolon appears after the condition.</p></li>
<li><p>The condition is now evaluated again. If it is true, the loop executes and the process repeats itself (body of loop, then increment step, and then again condition). After the condition becomes false, the for loop terminates.</p></li>
</ol>
</p></li>
<li><p>if <b>range</b> is available, then for loop executes for each item in the range.</p></li>
</ol>
<h2>Flow Diagram:</h2>
<img src="/go/images/go_for_loop.jpg" alt="for loop in Go" />
<h2>Example:</h2>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   
   var b int = 15
   var a int

   numbers := [6]int{1, 2, 3, 5} 

   /* for loop execution */
   for a := 0; a &lt; 10; a++ {
      fmt.Printf("value of a: %d\n", a)
   }

   for a &lt; b {
      a++
      fmt.Printf("value of a: %d\n", a)
      }

   for i,x:= range numbers {
      fmt.Printf("value of x = %d at %d\n", x,i)
   }   
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
value of a: 0
value of a: 1
value of a: 2
value of a: 3
value of a: 4
value of a: 5
value of a: 6
value of a: 7
value of a: 8
value of a: 9
value of a: 1
value of a: 2
value of a: 3
value of a: 4
value of a: 5
value of a: 6
value of a: 7
value of a: 8
value of a: 9
value of a: 10
value of a: 11
value of a: 12
value of a: 13
value of a: 14
value of a: 15
value of x = 1 at 0
value of x = 2 at 1
value of x = 3 at 2
value of x = 5 at 3
value of x = 0 at 4
value of x = 0 at 5
</pre>
<h1>Go - nested for loops</h1>
<p>Go programming language allows to use one loop inside another loop. Following section shows few examples to illustrate the concept.</p>
<h2>Syntax:</h2>
<p>The syntax for a <b>nested for loop</b> statement in Go is as follows:</p>
<pre class="prettyprint">
for [condition |  ( init; condition; increment ) | Range]
{
   for [condition |  ( init; condition; increment ) | Range]
   {
      statement(s);
   }
   statement(s);
}
</pre>
<h2>Example:</h2>
<p>The following program uses a nested for loop to find the prime numbers from 2 to 100:</p>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   /* local variable definition */
   var i, j int

   for i=2; i &lt; 100; i++ {
      for j=2; j &lt;= (i/j); j++ {
         if(i%j==0) {
            break; // if factor found, not prime
         }
      }
      if(j &gt; (i/j)) {
         fmt.Printf("%d is prime\n", i);
      }
   }  
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
2 is prime
3 is prime
5 is prime
7 is prime
11 is prime
13 is prime
17 is prime
19 is prime
23 is prime
29 is prime
31 is prime
37 is prime
41 is prime
43 is prime
47 is prime
53 is prime
59 is prime
61 is prime
67 is prime
71 is prime
73 is prime
79 is prime
83 is prime
89 is prime
97 is prime
</pre>
<h1>Go - break statement</h1>
<p>The <b>break</b> statement in Go programming language has the following two usages:</p>
<ol class="list">
<li><p>When the <b>break</b> statement is encountered inside a loop, the loop is immediately terminated and program control resumes at the next statement following the loop.</p></li>
<li><p>It can be used to terminate a case in the <b>switch</b> statement.</p></li>
</ol>
<p>If you are using nested loops (i.e., one loop inside another loop), the break statement will stop the execution of the innermost loop and start executing the next line of code after the block.</p>
<h2>Syntax:</h2>
<p>The syntax for a <b>break</b> statement in Go is as follows:</p>
<pre class="prettyprint">
break;
</pre>
<h2>Flow Diagram:</h2>
<img src="/go/images/go_break_statement.jpg" alt="Go break statement" />
<h2>Example:</h2>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   /* local variable definition */
   var a int = 10

   /* for loop execution */
   for a &lt; 20 {
      fmt.Printf("value of a: %d\n", a);
      a++;
      if a &gt; 15 {
         /* terminate the loop using break statement */
         break;
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
value of a: 10
value of a: 11
value of a: 12
value of a: 13
value of a: 14
value of a: 15
</pre>
<h1>Go - continue statement</h1>
<p>The <b>continue</b> statement in Go programming language works somewhat like the <b>break</b> statement. Instead of forcing termination, however, continue forces the next iteration of the loop to take place, skipping any code in between.</p>
<p>For the <b>for</b> loop, <b>continue</b> statement causes the conditional test and increment portions of the loop to execute.</p>
<h2>Syntax:</h2>
<p>The syntax for a <b>continue </b> statement in Go is as follows:</p>
<pre class="prettyprint">
continue;
</pre>
<h2>Flow Diagram:</h2>
<img src="/go/images/go_continue_statement.jpg" alt="Go continue statement" />
<h2>Example:</h2>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   /* local variable definition */
   var a int = 10

   /* do loop execution */
   for a &lt; 20 {
      if a == 15 {
         /* skip the iteration */
         a = a + 1;
         continue;
      }
      fmt.Printf("value of a: %d\n", a);
      a++;     
   }  
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
value of a: 10
value of a: 11
value of a: 12
value of a: 13
value of a: 14
value of a: 16
value of a: 17
value of a: 18
value of a: 19
</pre>
<h1>Go - goto statement</h1>
<p>A <b>goto</b> statement in Go programming language provides an unconditional jump from the goto to a labeled statement in the same function.</p>
<p><b>NOTE:</b> Use of <b>goto</b> statement is highly discouraged in any programming language because it makes difficult to trace the control flow of a program, making the program hard to understand and hard to modify. Any program that uses a goto can be rewritten so that it doesn't need the goto.</p>
<h2>Syntax:</h2>
<p>The syntax for a <b>goto</b> statement in Go is as follows:</p>
<pre class="prettyprint">
goto label;
..
.
label: statement;
</pre>
<p>Here <b>label</b> can be any plain text except Go keyword and it can be set anywhere in the Go program above or below to <b>goto</b> statement.</p>
<h2>Flow Diagram:</h2>
<img src="/go/images/go_goto_statement.jpg" alt="Go goto statement" />
<h2>Example:</h2>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   /* local variable definition */
   var a int = 10

   /* do loop execution */
   LOOP: for a &lt; 20 {
      if a == 15 {
         /* skip the iteration */
         a = a + 1
         goto LOOP
      }
      fmt.Printf("value of a: %d\n", a)
      a++     
   }  
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
value of a: 10
value of a: 11
value of a: 12
value of a: 13
value of a: 14
value of a: 16
value of a: 17
value of a: 18
value of a: 19
</pre>
<h1>Go - Functions</h1>
<p>A function is a group of statements that together perform a task. Every Go program has at least one function, which is <b>main()</b>, and all the most trivial programs can define additional functions.</p>
<p>You can divide up your code into separate functions. How you divide up your code among different functions is up to you, but logically the division usually is so each function performs a specific task.</p>
<p>A function <b>declaration</b> tells the compiler about a function's name, return type, and parameters. A function <b>definition</b> provides the actual body of the function.</p>
<p>The Go standard library provides numerous built-in functions that your program can call. For example, function <b>len()</b> takes arguments of various types and return the length of the type. For example, if a string is passed to it, it will return length of the string in bytes and if an array is passed to it, it will return the array length as number of elements it have.</p>
<p>A function is known with various names like a method  or a sub-routine or a procedure, etc.</p>
<h2>Defining a Function:</h2>
<p>The general form of a function definition in Go programming language is as follows:</p>
<pre class="prettyprint">
func function_name( [parameter list] ) [return_types]
{
   body of the function
}
</pre>
<p>A function definition in Go programming language consists of a <i>function header</i> and a <i>function body</i>. Here are all the parts of a function:</p>
<ul class="list">
<li><p><b>func</b> func starts the declaration of a function.</p></li>
<li><p><b>Function Name:</b> This is the actual name of the function. The function name and the parameter list together constitute the function signature.</p></li>
<li><p><b>Parameters:</b> A parameter is like a placeholder. When a function is invoked, you pass a value to the parameter. This value is referred to as actual parameter or argument. The parameter list refers to the type, order, and number of the parameters of a function. Parameters are optional; that is, a function may contain no parameters.</p></li>
<li><p><b>Return Type</b>: A function may return a list of values. The <b>return_types</b> is the list of data types of the values the function returns. Some functions perform the desired operations without returning a value. In this case, the return_type is the not required.</p></li>
<li><p><b>Function Body:</b> The function body contains a collection of statements that define what the function does.</p></li>
</ul>
<h2>Example:</h2>
<p>Following is the source code for a function called <b>max()</b>. This function takes two parameters num1 and num2 and returns the maximum between the two:</p>
<pre class="prettyprint">
/* function returning the max between two numbers */
func max(num1, num2 int) int
{
   /* local variable declaration */
   result int

   if (num1 &gt; num2) {
      result = num1
   } else {
      result = num2
   }
   return result 
}
</pre>
<h2>Calling a Function:</h2>
<p>While creating a Go function, you give a definition of what the function has to do. To use a function, you will have to call that function to perform the defined task.</p>
<p>When a program calls a function, program control is transferred to the called function. A called function performs defined task and when its return statement is executed or when its function-ending closing brace is reached, it returns program control back to the main program.</p>
<p>To call a function, you simply need to pass the required parameters along with function name, and if function returns a value, then you can store returned value. For example:</p>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   /* local variable definition */
   var a int = 100
   var b int = 200
   var ret int

   /* calling a function to get max value */
   ret = max(a, b)

   fmt.Printf( "Max value is : %d\n", ret )
}

/* function returning the max between two numbers */
func max(num1, num2 int) int {
   /* local variable declaration */
   var result int

   if (num1 &gt; num2) {
      result = num1
   } else {
      result = num2
   }
   return result 
}
</pre>
<p>I kept max() function along with main() function and compiled the source code. While running final executable, it would produce the following result:</p>
<pre class="result">
Max value is : 200
</pre>
<h2>Returning multiple values from Function</h2>
<p>A Go function can return multiple values. For example:</p>
<pre class="prettyprint tryit">
package main

import "fmt"

func swap(x, y string) (string, string) {
   return y, x
}

func main() {
   a, b := swap("Mahesh", "Kumar")
   fmt.Println(a, b)
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
Kumar Mahesh
</pre>
<h2>Function Arguments:</h2>
<p>If a function is to use arguments, it must declare variables that accept the values of the arguments. These variables are called the <b>formal parameters</b> of the function.</p>
<p>The formal parameters behave like other local variables inside the function and are created upon entry into the function and destroyed upon exit.</p>
<p>While calling a function, there are two ways that arguments can be passed to a function:</p>
<table class="src">
<tr><th style = "width:30%">Call Type</th><th>Description</th></tr>
<tr><td> <b>Call by value</b></td><td>This method copies the actual value of an argument into the formal parameter of the function. In this case, changes made to the parameter inside the function have no effect on the argument. </td> </tr>
<tr><td> <b>Call by reference</b></td><td>This method copies the address of an argument into the formal parameter. Inside the function, the address is used to access the actual argument used in the call. This means that changes made to the parameter affect the argument.</td> </tr>
</table>
<p>By default, Go uses <b>call by value</b> to pass arguments. In general, this means that code within a function cannot alter the arguments used to call the function and above mentioned example while calling max() function used the same method.</p>
<h1>Go - Call by value</h1>
<p>The <b>call by value</b> method of passing arguments to a function copies the actual value of an argument into the formal parameter of the function. In this case, changes made to the parameter inside the function have no effect on the argument.</p>
<p>By default, Go programming language uses <i>call by value</i> method to pass arguments. In general, this means that code within a function cannot alter the arguments used to call the function. Consider the function <b>swap()</b> definition as follows.</p>
<pre class="prettyprint" id="support">
/* function definition to swap the values */
func swap(int x, int y) int {
   var temp int

   temp = x /* save the value of x */
   x = y    /* put y into x */
   y = temp /* put temp into y */

   return temp;
}
</pre>
<p>Now, let us call the function <b>swap()</b> by passing actual values as in the following example:</p>
<pre class="prettyprint tryit" title="support">
package main

import "fmt"

func main() {
   /* local variable definition */
   var a int = 100
   var b int = 200

   fmt.Printf("Before swap, value of a : %d\n", a )
   fmt.Printf("Before swap, value of b : %d\n", b )

   /* calling a function to swap the values */
   swap(a, b)

   fmt.Printf("After swap, value of a : %d\n", a )
   fmt.Printf("After swap, value of b : %d\n", b )
}
func swap(x, y int) int {
   var temp int

   temp = x /* save the value of x */
   x = y    /* put y into x */
   y = temp /* put temp into y */

   return temp;
}
</pre>
<p>Let us put above code in a single C file, compile and execute it, it will produce the following result:</p>
<pre class="result">
Before swap, value of a :100
Before swap, value of b :200
After swap, value of a :100
After swap, value of b :200
</pre>
<p>Which shows that there is no change in the values though they had been changed inside the function.</p>
<h1>Go - Call by reference</h1>
<p>The <b>call by reference</b> method of passing arguments to a function copies the address of an argument into the formal parameter. Inside the function, the address is used to access the actual argument used in the call. This means that changes made to the parameter affect the passed argument.</p>
<p>To pass the value by reference, argument pointers are passed to the functions just like any other value. So accordingly you need to declare the function parameters as pointer types as in the following function <b>swap()</b>, which exchanges the values of the two integer variables pointed to by its arguments.</p>
<pre class="prettyprint" id="support">
/* function definition to swap the values */
func swap(x *int, y *int) {
   var temp int
   temp = *x    /* save the value at address x */
   *x = *y      /* put y into x */
   *y = temp    /* put temp into y */
}
</pre>
<p>To check the more detail about Go - Pointers, you can check <b>Go - Pointers</b> chapter.</p>
<p>For now, let us call the function <b>swap()</b> by passing values by reference as in the following example:</p>
<pre class="prettyprint tryit" title="support">
package main

import "fmt"

func main() {
   /* local variable definition */
   var a int = 100
   var b int= 200

   fmt.Printf("Before swap, value of a : %d\n", a )
   fmt.Printf("Before swap, value of b : %d\n", b )

   /* calling a function to swap the values.
   * &amp;a indicates pointer to a ie. address of variable a and 
   * &amp;b indicates pointer to b ie. address of variable b.
   */
   swap(&amp;a, &amp;b)

   fmt.Printf("After swap, value of a : %d\n", a )
   fmt.Printf("After swap, value of b : %d\n", b )
}

func swap(x *int, y *int) {
   var temp int
   temp = *x    /* save the value at address x */
   *x = *y    /* put y into x */
   *y = temp    /* put temp into y */
}
</pre>
<p>Let us put above code in a single C file, compile and execute it, it will produce the following result:</p>
<pre class="result">
Before swap, value of a :100
Before swap, value of b :200
After swap, value of a :200
After swap, value of b :100
</pre>
<p>Which shows that the change has reflected outside of the function as well unlike call by value where changes does not reflect outside of the function.</p>
<h1>Go - functions as values</h1>
<p>Go programming language provides flexibility to create functions on the fly and use them as values. In below example, we've initialized a variable with a function definition. Purpose of this function variable is just to use inbuilt math.sqrt() function. Following is the example:</p>
<pre class="prettyprint tryit">
package main

import (
   "fmt"
   "math"
)

func main(){
   /* declare a function variable */
   getSquareRoot := func(x float64) float64 {
      return math.Sqrt(x)
   }

   /* use the function */
   fmt.Println(getSquareRoot(9))

}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
3
</pre>
<h1>Go - function closure</h1>
<p>Go programming language supports anonymous functions which can acts as function closures. Anonymous functions are used when we want to define a function inline without passing any name to it. In our example, we've created a function getSequence() which will return another function. Purpose of this function is to close over a variable i of upper function to form a closure. Following is the example:</p>
<pre class="prettyprint tryit">
package main

import "fmt"

func getSequence() func() int {
   i:=0
   return func() int {
      i+=1
	  return i  
   }
}

func main(){
   /* nextNumber is now a function with i as 0 */
   nextNumber := getSequence()  

   /* invoke nextNumber to increase i by 1 and return the same */
   fmt.Println(nextNumber())
   fmt.Println(nextNumber())
   fmt.Println(nextNumber())
   
   /* create a new sequence and see the result, i is 0 again*/
   nextNumber1 := getSequence()  
   fmt.Println(nextNumber1())
   fmt.Println(nextNumber1())
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
1
2
3
1
2
</pre>
<h1>Go - method</h1>
<p>Go programming language supports special types of functions called methods. In method declaration syntax, a "receiver" is present to represent the container of the function. This receiver can be used to call function using "." operator. Following is the example:</p>
<h2>Syntax</h2>
<pre class="prettyprint notranslate">
func (variable_name variable_data_type) function_name() [return_type]{
   /* function body*/
}
</pre>

<pre class="prettyprint notranslate tryit">
package main

import (
   "fmt"
   "math"
)

/* define a circle */
type Circle struct {
   x,y,radius float64
}

/* define a method for circle */
func(circle Circle) area() float64 {
   return math.Pi * circle.radius * circle.radius
}

func main(){
   circle := Circle{x:0, y:0, radius:5}
   fmt.Printf("Circle area: %f", circle.area())
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result notranslate">
Circle area: 78.539816
</pre>
<h1>Go - Scope Rules</h1>
<p>A scope in any programming is a region of the program where a defined variable can have its existence and beyond that variable can not be accessed. There are three places where variables can be declared in C programming language:</p>
<ol class="list">
<li><p>Inside a function or a block which is called <b>local</b> variables,</p></li>
<li><p>Outside of all functions which is called <b>global</b> variables.</p></li>
<li><p>In the definition of function parameters which is called <b>formal</b> parameters.</p></li>
</ol>
<p>Let us explain what are <b>local</b> and <b>global</b> variables and <b>formal</b> parameters.</p>
<h2>Local Variables</h2>
<p>Variables that are declared inside a function or block are called local variables. They can be used only by statements that are inside that function or block of code. Local variables are not known to functions outside their own. Following is the example using local variables. Here all the variables a, b and c are local to main() function.</p>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   /* local variable declaration */
   var a, b, c int 

   /* actual initialization */
   a = 10
   b = 20
   c = a + b

   fmt.Printf ("value of a = %d, b = %d and c = %d\n", a, b, c)
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
value of a = 10, b = 20 and c = 30
</pre>
<h2>Global Variables</h2>
<p>Global variables are defined outside of a function, usually on top of the program. The global variables will hold their value throughout the lifetime of your program and they can be accessed inside any of the functions defined for the program.</p>
<p>A global variable can be accessed by any function. That is, a global variable is available for use throughout your entire program after its declaration. Following is the example using global and local variables:</p>
<pre class="prettyprint tryit">
package main

import "fmt"
 
/* global variable declaration */
var g int
 
func main() {

   /* local variable declaration */
   var a, b int

   /* actual initialization */
   a = 10
   b = 20
   g = a + b

   fmt.Printf("value of a = %d, b = %d and g = %d\n", a, b, g)
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
value of a = 10, b = 20 and c = 30
</pre>
<p>A program can have same name for local and global variables but value of local variable inside a function will take preference. Following is an example:</p>
<pre class="prettyprint tryit">
package main

import "fmt"
 
/* global variable declaration */
var g int = 20
 
func main() {
   /* local variable declaration */
   var g int = 10
 
   fmt.Printf ("value of g = %d\n",  g)
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
value of g = 10
</pre>
<h2>Formal Parameters</h2>
<p>Function parameters, formal parameters, are treated as local variables with-in that function and they will take preference over the global variables. Following is an example:</p>
<pre class="prettyprint tryit">
package main

import "fmt"
 
/* global variable declaration */
var a int = 20;
 
func main() {
   /* local variable declaration in main function */
   var a int = 10
   var b int = 20
   var c int = 0

   fmt.Printf("value of a in main() = %d\n",  a);
   c = sum( a, b);
   fmt.Printf("value of c in main() = %d\n",  c);
}

/* function to add two integers */
func sum(a, b int) int {
   fmt.Printf("value of a in sum() = %d\n",  a);
   fmt.Printf("value of b in sum() = %d\n",  b);

   return a + b;
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
value of a in main() = 10
value of a in sum() = 10
value of b in sum() = 20
value of c in main() = 30
</pre>
<h2>Initializing Local and Global Variables</h2>
<p>When a local variable as Global variables are initialized to their corresponding 0 value. Pointer is initialized to nil.</p>
<table class="src">
<tr><th style="width:30%">Data Type</th><th>Initial Default Value</th></tr>
<tr><td>int</td><td>0</td></tr>
<tr><td>float32</td><td>0</td></tr>
<tr><td>pointer</td><td>nil</td></tr>
</table>
<h1>Go - String</h1>
<p>Strings, which are widely used in Go programming, are a readonly slice of bytes. In the Go programming language, strings are slices. The Go platform provides various libraries to manipulate strings.</p>
<ul class="list">
<li><p>unicode</p></li>
<li><p>regexp</p></li>
<li><p>strings</p></li>
</ul>
<h2>Creating Strings:</h2>
<p>The most direct way to create a string is to write:</p>
<pre class="prettyprint notranslate">
var greeting = "Hello world!"
</pre>
<p>Whenever it encounters a string literal in your code, the compiler creates a string object with its value in this case, "Hello world!'.</p>
<p>A string literal holds a valid UTF-8 sequences called runes. A String holds arbitrary bytes.</p>
<pre class="prettyprint tryit">
package main
import "fmt"
func main() {
   var greeting =  "Hello world!"
   
   fmt.Printf("normal string: ")
   fmt.Printf("%s", greeting)
   fmt.Printf("\n")
   fmt.Printf("hex bytes: ")
   for i := 0; i &lt; len(greeting); i++ {
       fmt.Printf("%x ", greeting[i])
   }
   fmt.Printf("\n")
   
   const sampleText = "\xbd\xb2\x3d\xbc\x20\xe2\x8c\x98" 
   /*q flag escapes unprintable characters, with + flag it escapses non-ascii characters as well 
     to make output unambigous  */
   fmt.Printf("quoted string: ")
   fmt.Printf("%+q", sampleText)
   fmt.Printf("\n")  
}
</pre>
<p>This would produce the following result:</p>
<pre class="result">
normal string: Hello world!
hex bytes: 48 65 6c 6c 6f 20 77 6f 72 6c 64 21 
quoted string: "\xbd\xb2=\xbc \u2318"
</pre>
<p><b>Note:</b> The string literal is immutable, so that once it is created a string literal cannot be changed.</p>
<h2>String Length:</h2>
<p>len(str) method returns the number of bytes contained in the string literal.</p>
<pre class="prettyprint tryit">
package main
import "fmt"
func main() {
   var greeting =  "Hello world!"
   
   fmt.Printf("String Length is: ")
   fmt.Println(len(greeting))  
}
</pre>
<p>This would produce the following result:</p>
<pre class="result">
String Length is : 12
</pre>
<h2>Concatenating Strings:</h2>
<p>The strings package includes a method join for concatenating multiple strings:</p>
<pre class="prettyprint notranslate">
strings.Join(sample, " ")
</pre>
<p>Join concatenates the elements of an array to create a single string. Second parameter is seperator which is placed between element of the array.</p>
<p>Let us look at the following example:</p>
<pre class="prettyprint tryit">
package main
import (
 "fmt"
 "strings"
)
func main() {
   greetings :=  []string{"Hello","world!"}   
   fmt.Println(strings.Join(greetings, " "))
}
</pre>
<p>This would produce the following result:</p>
<pre class="result">
Hello world!
</pre>
<h1>Go - Arrays</h1>
<p>Go programming language provides a data structure called <b>the array</b>, which can store a fixed-size sequential collection of elements of the same type. An array is used to store a collection of data, but it is often more useful to think of an array as a collection of variables of the same type.</p>
<p>Instead of declaring individual variables, such as number0, number1, ..., and number99, you declare one array variable such as numbers and use numbers[0], numbers[1], and ..., numbers[99] to represent individual variables. A specific element in an array is accessed by an index. </p>
<p>All arrays consist of contiguous memory locations. The lowest address corresponds to the first element and the highest address to the last element.</p>
<img src="/go/images/arrays.jpg" alt="Arrays in Go" />
<h2>Declaring Arrays</h2>
<p>To declare an array in Go, a programmer specifies the type of the elements and the number of elements required by an array as follows:</p>
<pre class="prettyprint">
var variable_name [SIZE] variable_type
</pre>
<p>This is called a <i>single-dimensional</i> array. The <b>arraySize</b> must be an integer constant greater than zero and <b>type</b> can be any valid Go data type. For example, to declare a 10-element array called <b>balance</b> of type float32, use this statement:</p>
<pre class="prettyprint">
var balance [10] float32
</pre>
<p>Now <i>balance</i> is avariable array which is sufficient to hold upto 10 float numbers.</p>
<h2>Initializing Arrays</h2>
<p>You can initialize array in Go either one by one or using a single statement as follows:</p>
<pre class="prettyprint">
var balance = [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}
</pre>
<p>The number of values between braces { } can not be larger than the number of elements that we declare for the array between square brackets [ ].</p>
<p>If you omit the size of the array, an array just big enough to hold the initialization is created.  Therefore, if you write:</p>
<pre class="prettyprint">
var balance = []float32{1000.0, 2.0, 3.4, 7.0, 50.0}
</pre>
<p>You will create exactly the same array as you did in the previous example. Following is an example to assign a single element of the array:</p>
<pre class="prettyprint">
balance[4] = 50.0
</pre>
<p>The above statement assigns element number 5th in the array with a value of 50.0. All arrays have 0 as the index of their first element which is also called base index and last index of an array will be total size of the array minus 1. Following is the pictorial representation  of the same array we discussed above:</p>
<img src="/go/images/array_presentation.jpg" alt="Array Presentation" />
<h2>Accessing Array Elements</h2>
<p>An element is accessed by indexing the array name. This is done by placing the index of the element within square brackets after the name of the array. For example:</p>
<pre class="prettyprint">
float32 salary = balance[9]
</pre>
<p>The above statement will take 10th element from the array and assign the value to salary variable. Following is an example which will use all the above mentioned three concepts viz. declaration, assignment and accessing arrays:</p>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   var n [10]int /* n is an array of 10 integers */
   var i,j int

   /* initialize elements of array n to 0 */         
   for i = 0; i &lt; 10; i++ {
      n[i] = i + 100 /* set element at location i to i + 100 */
   }

   /* output each array element's value */
   for j = 0; j &lt; 10; j++ {
      fmt.Printf("Element[%d] = %d\n", j, n[j] )
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
Element[0] = 100
Element[1] = 101
Element[2] = 102
Element[3] = 103
Element[4] = 104
Element[5] = 105
Element[6] = 106
Element[7] = 107
Element[8] = 108
Element[9] = 109
</pre>
<h2>Go Arrays in Detail</h2>
<p>Arrays are important to C and should need lots of more details. There are following few important concepts related to array which should be clear to a C programmer:</p>
<table class="src">
<tr><th style="width:30%">Concept</th><th>Description</th></tr>
<tr><td> <b>Multi-dimensional arrays</b></td><td>Go supports multidimensional arrays. The simplest form of the multidimensional array is the two-dimensional array.</td> </tr>
<tr><td> <b>Passing arrays to functions</b></td><td>You can pass to the function a pointer to an array by specifying the array's name without an index.</td> </tr>
</table>
<h1>Go - Multi-dimensional arrays</h1>
<p>Go programming language allows multidimensional arrays. Here is the general form of a multidimensional array declaration:</p>
<pre class="prettyprint">
var variable_name [SIZE1][SIZE2]...[SIZEN] variable_type
</pre>
<p>For example, the following declaration creates a three dimensional 5 . 10 . 4 integer array:</p>
<pre class="prettyprint">
var threedim [5][10][4]int
</pre>
<h2>Two-Dimensional Arrays:</h2>
<p>The simplest form of the multidimensional array is the two-dimensional array. A two-dimensional array is, in essence, a list of one-dimensional arrays. To declare a two-dimensional integer array of size x,y you would write something as follows:</p>
<pre class="prettyprint">
var arrayName [ x ][ y ] variable_type
</pre>
<p>Where <b>variable_type</b> can be any valid Go data type and <b>arrayName</b> will be a valid Go identifier. A two-dimensional array can be think as a table which will have x number of rows and y number of columns. A 2-dimensional array <b>a</b>, which contains three rows and four columns can be shown as below:</p>
<img src="/go/images/two_dimensional_arrays.jpg" alt="Two Dimensional Arrays in Go" />
<p>Thus, every element in array a is identified  by an element name of the form <b>a[ i ][ j ]</b>, where a is the name of the array, and i and j are the subscripts that uniquely identify each element in a.</p>
<h2>Initializing Two-Dimensional Arrays:</h2>
<p>Multidimensional arrays may be initialized by specifying bracketed values for each row. Following is an array with 3 rows and each row has 4 columns.</p>
<pre class="prettyprint">
a = [3][4]int{  
 {0, 1, 2, 3} ,   /*  initializers for row indexed by 0 */
 {4, 5, 6, 7} ,   /*  initializers for row indexed by 1 */
 {8, 9, 10, 11}   /*  initializers for row indexed by 2 */
}
</pre>
<h2>Accessing Two-Dimensional Array Elements:</h2>
<p>An element in 2-dimensional array is accessed by using the subscripts, i.e., row index and column index of the array. For example:</p>
<pre class="prettyprint">
int val = a[2][3]
</pre>
<p>The above statement will take 4th element from the 3rd row of the array. You can verify it in the above diagram. Let us check below program where we have used nested loop to handle a two dimensional array:</p>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   /* an array with 5 rows and 2 columns*/
   var a = [5][2]int{ {0,0}, {1,2}, {2,4}, {3,6},{4,8}}
   var i, j int

   /* output each array element's value */
   for  i = 0; i &lt; 5; i++ {
      for j = 0; j &lt; 2; j++ {
         fmt.Printf("a[%d][%d] = %d\n", i,j, a[i][j] )
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
a[0][0]: 0
a[0][1]: 0
a[1][0]: 1
a[1][1]: 2
a[2][0]: 2
a[2][1]: 4
a[3][0]: 3
a[3][1]: 6
a[4][0]: 4
a[4][1]: 8
</pre>
<p>As explained above, you can have arrays with any number of dimensions, although it is likely that most of the arrays you create will be of one or two dimensions.</p>
<h1>Go - Passing arrays to functions</h1>
<p>If you want to pass a single-dimension array as an argument in a function, you would have to declare function formal parameter in one of following two ways and all two declaration methods produce similar results because each tells the compiler that an integer array is going to be received. Similar way you can pass multi-dimensional  array as formal parameters.</p>
<h2>Way-1</h2>
<p>Formal parameters as a sized array as follows:</p>
<pre class="prettyprint">
void myFunction(param [10]int)
{
.
.
.
}
</pre>
<h2>Way-2</h2>
<p>Formal parameters as an unsized array as follows:</p>
<pre class="prettyprint">
void myFunction(param []int)
{
.
.
.
}
</pre>
<h2>Example</h2>
<p>Now, consider the following function, which will take an array as an argument along with another argument and based on the passed arguments, it will return average of the numbers passed through the array as follows:</p>
<pre class="prettyprint">
func getAverage(arr []int, int size) float32
{
   var i int
   var avg, sum float32  

   for i = 0; i &lt; size; ++i {
      sum += arr[i]
   }

   avg = sum / size

   return avg;
}

</pre>
<p>Now, let us call the above function as follows:</p>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   /* an int array with 5 elements */
   var  balance = []int {1000, 2, 3, 17, 50}
   var avg float32

   /* pass array as an argument */
   avg = getAverage( balance, 5 )

   /* output the returned value */
   fmt.Printf( "Average value is: %f ", avg )
}
func getAverage(arr []int, size int) float32 {
   var i,sum int
   var avg float32  

   for i = 0; i &lt; size;i++ {
      sum += arr[i]
   }

   avg = float32(sum / size)

   return avg
}
</pre>
<p>When the above code is compiled together and executed, it produces the following result:</p>
<pre class="result">
Average value is: 214.400000
</pre>
<p>As you can see, the length of the array doesn't matter as far as the function is concerned because Go performs no bounds checking for the formal parameters.</p>
<h1>Go - Pointers</h1>
<p>Pointers in Go are easy and fun to learn. Some Go programming tasks are performed more easily with pointers, and other tasks, such as call by reference, cannot be performed without using pointers. So it becomes necessary to learn pointers to become a perfect Go programmer. Let's start learning them in simple and easy steps.</p>
<p>As you know, every variable is a memory location and every memory location has its address defined which can be accessed using ampersand (&amp;) operator, which denotes an address in memory. Consider the following example, which will print the address of the variables defined:</p>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   var a int = 10   

   fmt.Printf("Address of a variable: %x\n", &amp;a  )
}
</pre>
<p>When the above code is compiled and executed, it produces result something as follows:</p>
<pre class="result">
Address of a variable: 10328000
</pre>
<p>So you understood what is memory address and how to access it, so base of the concept is over. Now let us see what is a pointer.</p>
<h2>What Are Pointers?</h2>
<p>A <b>pointer</b> is a variable whose value is the address of another variable, i.e., direct address of the memory location. Like any variable or constant, you must declare a pointer before you can use it to store any variable address. The general form of a pointer variable declaration is:</p>
<pre class="prettyprint">
var var_name *var-type
</pre>
<p>Here, <b>type</b> is the pointer's base type; it must be a valid C data type and <b>var-name</b> is the name of the pointer variable. The asterisk * you used to declare a pointer is the same asterisk that you use for multiplication. However, in this statement the asterisk is being used to designate a variable as a pointer. Following are the valid pointer declaration:</p>
<pre class="prettyprint">
var ip *int        /* pointer to an integer */
var fp *float32    /* pointer to a float */
</pre>
<p>The actual data type of the value of all pointers, whether integer, float, or otherwise, is the same, a long hexadecimal number that represents a memory address. The only difference between pointers of different data types is the data type of the variable or constant that the pointer points to.</p>
<h2>How to use Pointers?</h2>
<p>There are few important operations, which we will do with the help of pointers very frequently. <b>(a)</b> we define a pointer variable <b>(b)</b> assign the address of a variable to a pointer and <b>(c)</b> finally access the value at the address available in the pointer variable. This is done by using unary operator <b>*</b> that returns the value of the variable located at the address specified by its operand. Following example makes use of these operations:</p>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   var a int= 20   /* actual variable declaration */
   var ip *int        /* pointer variable declaration */

   ip = &amp;a  /* store address of a in pointer variable*/

   fmt.Printf("Address of a variable: %x\n", &amp;a  )

   /* address stored in pointer variable */
   fmt.Printf("Address stored in ip variable: %x\n", ip )

   /* access the value using the pointer */
   fmt.Printf("Value of *ip variable: %d\n", *ip )
}
</pre>
<p>When the above code is compiled and executed, it produces result something as follows:</p>
<pre class="result">
Address of var variable: 10328000
Address stored in ip variable: 10328000
Value of *ip variable: 20
</pre>
<h2>nil Pointers in Go</h2>
<p>Go compiler assign a Nil value to a pointer variable in case you do not have exact address to be assigned. This is done at the time of variable declaration. A pointer that is assigned nil is called a <b>nil</b> pointer.</p>
<p>The nil pointer is a constant with a value of zero defined in several standard libraries. Consider the following program:</p>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   var  ptr *int

   fmt.Printf("The value of ptr is : %x\n", ptr  )
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
The value of ptr is 0
</pre>
<p>On most of the operating systems, programs are not permitted to access memory at address 0 because that memory is reserved by the operating system. However, the memory address 0 has special significance; it signals that the pointer is not intended to point to an accessible memory location. But by convention, if a pointer contains the nil (zero) value, it is assumed to point to nothing.</p>
<p>To check for a nil pointer you can use an if statement as follows:</p>
<pre class="prettyprint">
if(ptr != nil)     /* succeeds if p is not nil */
if(ptr == nil)    /* succeeds if p is null */
</pre>
<h2>Go Pointers in Detail:</h2>
<p>Pointers have many but easy concepts and they are very important to Go programming. There are following few important pointer concepts which should be clear to a Go programmer:</p>
<table class="src">
<tr><th style="width:35%">Concept</th><th>Description</th></tr>
<tr><td> <b>Go  - Array of pointers</b></td><td>You can define arrays to hold a number of pointers.</td> </tr>
<tr><td> <b>Go - Pointer to pointer</b></td><td>Go allows you to have pointer on a pointer and so on.</td> </tr>
<tr><td> <b>Passing pointers to functions in Go</b></td><td>Passing an argument by reference or by address both enable the passed argument to be changed in the calling function by the called function.</td> </tr>
</table>
<h1>Go - Array of pointers</h1>
<p>Before we understand the concept of arrays of pointers, let us consider the following example, which makes use of an array of 3 integers: </p>
<pre class="prettyprint tryit">
package main

import "fmt"
 
const MAX int = 3
 
func main() {

   a := []int{10,100,200}
   var i int

   for i = 0; i &lt; MAX; i++ {
      fmt.Printf("Value of a[%d] = %d\n", i, a[i] )
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
Value of a[0] = 10
Value of a[1] = 100
Value of a2] = 200
</pre>
<p>There may be a situation when we want to maintain an array, which can store pointers to an int or string or any other data type available. Following is the declaration of an array of pointers to an integer:</p>
<pre class="prettyprint">
var ptr [MAX]*int;
</pre>
<p>This declares <b>ptr</b> as an array of MAX integer pointers. Thus, each element in ptr, now holds a pointer to an int value. Following example makes use of three integers, which will be stored in an array of pointers as follows:</p>
<pre class="prettyprint tryit">
package main

import "fmt"
 
const MAX int = 3
 
func main() {
   a := []int{10,100,200}
   var i int
   var ptr [MAX]*int;

   for  i = 0; i &lt; MAX; i++ {
      ptr[i] = &amp;a[i] /* assign the address of integer. */
   }

   for  i = 0; i &lt; MAX; i++ {
      fmt.Printf("Value of a[%d] = %d\n", i,*ptr[i] )
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
Value of a[0] = 10
Value of a[1] = 100
Value of a[2] = 200
</pre>
<h1>Go - Pointer to pointer</h1>
<p>A pointer to a pointer is a form of multiple indirection, or a chain of pointers. Normally, a pointer contains the address of a variable. When we define a pointer to a pointer, the first pointer contains the address of the second pointer, which points to the location that contains the actual value as shown below.</p>
<img src="/go/images/pointer_to_pointer.jpg" alt="Pointer to Pointer in Go" />
<p>A variable that is a pointer to a pointer must be declared as such. This is done by placing an additional asterisk in front of its name. For example, following is the declaration to declare a  pointer to a pointer of type int:</p>
<pre class="prettyprint">
var ptr **int;
</pre>
<p>When a target value is indirectly pointed to by a pointer to a pointer, accessing that value requires that the asterisk operator be applied twice, as is shown below in the example:</p>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {

   var a int
   var ptr *int
   var pptr **int

   a = 3000

   /* take the address of var */
   ptr = &amp;a

   /* take the address of ptr using address of operator &amp; */
   pptr = &amp;ptr

   /* take the value using pptr */
   fmt.Printf("Value of a = %d\n", a )
   fmt.Printf("Value available at *ptr = %d\n", *ptr )
   fmt.Printf("Value available at **pptr = %d\n", **pptr)
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
Value of var = 3000
Value available at *ptr = 3000
Value available at **pptr = 3000
</pre>
<h1>Go - Passing pointers to functions</h1>
<p>Go programming language allows you to pass a pointer to a function. To do so, simply declare the function parameter as a pointer type.</p>
<p>Following a simple example where we passed two pointers to a function and change the value inside the function which reflects back in the calling function:</p>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   /* local variable definition */
   var a int = 100
   var b int= 200

   fmt.Printf("Before swap, value of a : %d\n", a )
   fmt.Printf("Before swap, value of b : %d\n", b )

   /* calling a function to swap the values.
   * &amp;a indicates pointer to a ie. address of variable a and 
   * &amp;b indicates pointer to b ie. address of variable b.
   */
   swap(&amp;a, &amp;b);

   fmt.Printf("After swap, value of a : %d\n", a )
   fmt.Printf("After swap, value of b : %d\n", b )
}

func swap(x *int, y *int) {
   var temp int
   temp = *x    /* save the value at address x */
   *x = *y      /* put y into x */
   *y = temp    /* put temp into y */
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
Before swap, value of a :100
Before swap, value of b :200
After swap, value of a :200
After swap, value of b :100
</pre>
<h1>Go - Structures</h1>
<p>Go arrays allow you to define type of variables that can hold several data items of the same kind but <b>structure</b> is another user defined data type available in Go programming, which allows you to combine data items of different kinds.</p><p>Structures are used to represent a record, Suppose you want to keep track of your books in a library. You might want to track the following attributes about each book:</p>
<ul class="list">
<li><p>Title</p></li>
<li><p>Author</p></li>
<li><p>Subject</p></li>
<li><p>Book ID</p></li>
</ul>
<h2>Defining a Structure</h2>
<p>To define a structure, you must use <b>type</b> and <b>struct</b> statements. The struct statement defines a new data type, with more than one member for your program. type statement binds a name with the type which is struct in our case. The format of the struct statement is this:</p><pre class="prettyprint">
type struct_variable_type struct {
   member definition;
   member definition;
   ...
   member definition;
}
</pre>
<p>Once a structure type is defined, it can be used to declare variables of that type using following syntax.</p>
<pre class="prettyprint">
variable_name := structure_variable_type {value1, value2...valuen}
</pre>
<h2>Accessing Structure Members</h2><p>To access any member of a structure, we use the <b>member access operator (.)</b>. The member access operator is coded as a period between the structure variable name and the structure member that we wish to access. You would use <b>struct</b> keyword to define variables of structure type. Following is the example to explain usage of structure:</p>
<pre class="prettyprint tryit">
package main

import "fmt"

type Books struct {
   title string
   author string
   subject string
   book_id int
}

func main() {
   var Book1 Books        /* Declare Book1 of type Book */
   var Book2 Books        /* Declare Book2 of type Book */
 
   /* book 1 specification */
   Book1.title = "Go Programming"
   Book1.author = "Mahesh Kumar"
   Book1.subject = "Go Programming Tutorial"
   Book1.book_id = 6495407

   /* book 2 specification */
   Book2.title = "Telecom Billing"
   Book2.author = "Zara Ali"
   Book2.subject = "Telecom Billing Tutorial"
   Book2.book_id = 6495700
 
   /* print Book1 info */
    fmt.Printf( "Book 1 title : %s\n", Book1.title)
    fmt.Printf( "Book 1 author : %s\n", Book1.author)
    fmt.Printf( "Book 1 subject : %s\n", Book1.subject)
    fmt.Printf( "Book 1 book_id : %d\n", Book1.book_id)

   /* print Book2 info */
    fmt.Printf( "Book 2 title : %s\n", Book2.title)
    fmt.Printf( "Book 2 author : %s\n", Book2.author)
    fmt.Printf( "Book 2 subject : %s\n", Book2.subject)
    fmt.Printf( "Book 2 book_id : %d\n", Book2.book_id)
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
Book 1 title : Go Programming
Book 1 author : Mahesh Kumar
Book 1 subject : Go Programming Tutorial
Book 1 book_id : 6495407
Book 2 title : Telecom Billing
Book 2 author : Zara Ali
Book 2 subject : Telecom Billing Tutorial
Book 2 book_id : 6495700
</pre>
<h2>Structures as Function Arguments</h2>
<p>You can pass a structure as a function argument in very similar way as you pass any other variable or pointer. You would access structure variables in the similar way as you have accessed in the above example:</p>
<pre class="prettyprint tryit">
package main

import "fmt"

type Books struct {
   title string
   author string
   subject string
   book_id int
}

func main() {
   var Book1 Books        /* Declare Book1 of type Book */
   var Book2 Books        /* Declare Book2 of type Book */
 
   /* book 1 specification */
   Book1.title = "Go Programming"
   Book1.author = "Mahesh Kumar"
   Book1.subject = "Go Programming Tutorial"
   Book1.book_id = 6495407

   /* book 2 specification */
   Book2.title = "Telecom Billing"
   Book2.author = "Zara Ali"
   Book2.subject = "Telecom Billing Tutorial"
   Book2.book_id = 6495700
 
   /* print Book1 info */
   printBook(Book1)

   /* print Book2 info */
   printBook(Book2)
}
func printBook( book Books ) {
    fmt.Printf( "Book title : %s\n", book.title);
    fmt.Printf( "Book author : %s\n", book.author);
    fmt.Printf( "Book subject : %s\n", book.subject);
    fmt.Printf( "Book book_id : %d\n", book.book_id);
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
Book title : Go Programming
Book author : Mahesh Kumar
Book subject : Go Programming Tutorial
Book book_id : 6495407
Book title : Telecom Billing
Book author : Zara Ali
Book subject : Telecom Billing Tutorial
Book book_id : 6495700
</pre>
<h2>Pointers to Structures</h2>
<p>You can define pointers to structures in very similar way as you define pointer to any other variable as follows:</p>
<pre class="prettyprint">
var struct_pointer *Books
</pre>
<p>Now, you can store the address of a structure variable in the above defined pointer variable. To find the address of a structure variable, place the &amp; operator before the structure's name as follows:</p>
<pre class="prettyprint">
struct_pointer = &amp;Book1;
</pre>
<p>To access the members of a structure using a pointer to that structure, you must use the "." operator as follows:</p>
<pre class="prettyprint">
struct_pointer.title;
</pre>
<p>Let us re-write above example using structure pointer, hope this will be easy for you to understand the concept:</p>
<pre class="prettyprint tryit">
package main

import "fmt"

type Books struct {
   title string
   author string
   subject string
   book_id int
}

func main() {
   var Book1 Books        /* Declare Book1 of type Book */
   var Book2 Books        /* Declare Book2 of type Book */
 
   /* book 1 specification */
   Book1.title = "Go Programming"
   Book1.author = "Mahesh Kumar"
   Book1.subject = "Go Programming Tutorial"
   Book1.book_id = 6495407

   /* book 2 specification */
   Book2.title = "Telecom Billing"
   Book2.author = "Zara Ali"
   Book2.subject = "Telecom Billing Tutorial"
   Book2.book_id = 6495700
 
   /* print Book1 info */
   printBook(&amp;Book1)

   /* print Book2 info */
   printBook(&amp;Book2)
}
func printBook( book *Books ) {
    fmt.Printf( "Book title : %s\n", book.title);
    fmt.Printf( "Book author : %s\n", book.author);
    fmt.Printf( "Book subject : %s\n", book.subject);
    fmt.Printf( "Book book_id : %d\n", book.book_id);
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
Book title : Go Programming
Book author : Mahesh Kumar
Book subject : Go Programming Tutorial
Book book_id : 6495407
Book title : Telecom Billing
Book author : Zara Ali
Book subject : Telecom Billing Tutorial
Book book_id : 6495700
</pre>
<h1>Go - Slices</h1>
<p>Go Slice is an abstraction over Go Array. As Go Array allows you to define type of variables that can hold several data items of the same kind but it do not provide any inbuilt method to increase size of it dynamically or get a sub-array of its own. Slices covers this limitation. It provides many utility functions required on Array and is widely used in Go programming.</p>
<h2>Defining a slice</h2>
<p>To define a slice, you can declare it as an array without specifying size or use <b>make</b> function to create the one.</p>
<pre class="prettyprint">
var numbers []int /* a slice of unspecified size */
/* numbers == []int{0,0,0,0,0}*/
numbers = make([]int,5,5) /* a slice of length 5 and capacity 5*/
</pre>
<h2>len() and cap() functions</h2>
<p>As slice is an abstraction over array. It actually uses array as an underlying structure.<b>len()</b> function returns the elements presents in the slice where <b>cap()</b> function returns the capacity of slice as how many elements it can be accomodate. Following is the example to explain usage of slice:</p>
<pre class="prettyprint tryit">
package main

import "fmt"

func main {
   var numbers = make([]int,3,5)
   
   printSlice(numbers)
}

func printSlice(x []int){
    fmt.Printf("len=%d cap=%d slice=%v\n",len(x),cap(x),x)
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
len=3 cap=5 slice=[0 0 0]
</pre>
<h2>Nil slice</h2>
<p>If a slice is declared with no inputs the by default, it is initialized as nil. Its length and capacity are zero. Following is an example:</p>
<pre class="prettyprint tryit">
package main

import "fmt"

func main {
   var numbers []int
   
   printSlice(numbers)
   
   if(numbers == nil){
       fmt.Printf("slice is nil")
   }
}

func printSlice(x []int){
    fmt.Printf("len=%d cap=%d slice=%v\n",len(x),cap(x),x)
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
len=0 cap=0 slice=[]
slice is nil
</pre>
<h2>sub-slicing</h2>
<p>Slice allows lower-bound and upper bound to be specified to get the subslice of it using<b>[lower-bound:upper-bound]</b>. Following is the example:</p>
<pre class="prettyprint tryit">
package main

import "fmt"

func main {
   /* create a slice */
   numbers := []int{0,1,2,3,4,5,6,7,8}   
   printSlice(numbers)
   
   /* print the original slice */
   fmt.Println("numbers ==", numbers)
   
   /* print the sub slice starting from index 1(included) to index 4(excluded)*/
   fmt.Println("numbers[1:4] ==", numbers[1:4])
   
   /* missing lower bound implies 0*/
   fmt.Println("numbers[:3] ==", numbers[:3])
   
   /* missing upper bound implies len(s)*/
   fmt.Println("numbers[4:] ==", numbers[4:])
   
   numbers1 := make([]int,0,5)
   printSlice(numbers1)
   
   /* print the sub slice starting from index 0(included) to index 2(excluded) */
   number2 := numbers[:2]
   printSlice(number2)
   
   /* print the sub slice starting from index 2(included) to index 5(excluded) */
   number3 := numbers[2:5]
   printSlice(number3)
   
}

func printSlice(x []int){
    fmt.Printf("len=%d cap=%d slice=%v\n",len(x),cap(x),x)
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
len=9 cap=9 slice=[0 1 2 3 4 5 6 7 8]
numbers == [0 1 2 3 4 5 6 7 8]
numbers[1:4] == [1 2 3]
numbers[:3] == [0 1 2]
numbers[4:] == [4 5 6 7 8]
len=0 cap=5 slice=[]
len=2 cap=9 slice=[0 1]
len=3 cap=7 slice=[2 3 4]
</pre>
<h2>append() and copy() functions</h2>
<p>Slice allows increasing the capacity of a slice using <b>append()</b> function.Using <b>copy()</b> function, contents of a source slice are copied to destination slice. Following is the example:</p>
<pre class="prettyprint tryit">
package main

import "fmt"

func main {
   var numbers []int
   printSlice(numbers)
   
   /* append allows nil slice */
   numbers = append(numbers, 0)
   printSlice(numbers)
   
   /* add one element to slice*/
   numbers = append(numbers, 1)
   printSlice(numbers)
   
   /* add more than one element at a time*/
   numbers = append(numbers, 2,3,4)
   printSlice(numbers)
   
   /* create a slice numbers1 with double the capacity of earlier slice*/
   numbers1 := make([]int, len(numbers), (cap(numbers))*2)
   
   /* copy content of numbers to numbers1 */
   copy(numbers1,numbers)
   printSlice(numbers1)   
}

func printSlice(x []int){
    fmt.Printf("len=%d cap=%d slice=%v\n",len(x),cap(x),x)
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
len=0 cap=0 slice=[]
len=1 cap=2 slice=[0]
len=2 cap=2 slice=[0 1]
len=5 cap=8 slice=[0 1 2 3 4]
len=5 cap=16 slice=[0 1 2 3 4]
</pre>
<h1>Go - Range</h1>
<p>The <b>range</b> keyword is used in <b>for</b> loop to iterate over items of an array, slice, channel or map. With array and slices, it returns the index of the item as integer. With maps, it returns the key of the next key-value pair. Range either returns one value or two. If only one value is used on the left of a range expression, it is the 1st value in the following table.</p>
<table class="src">
<tr><th>Range expression</th><th>1st Value</th><th>2nd Value(Optional)</th></tr>
<tr><td>Array or slice a [n]E</td><td>index i int</td><td>a[i] E</td></tr>
<tr><td>String s string type</td><td>index i int</td><td>rune int</td></tr>
<tr><td>map m map[K]V</td><td>key k K</td><td>value m[k] V</td></tr>
<tr><td>channel c chan E</td><td>element e E</td><td>none</td></tr>
</table>
<h2>Example</h2>
<p>Following is the example:</p>
<pre class="prettyprint tryit">
package main

import "fmt"

func main {
   /* create a slice */
   numbers := []int{0,1,2,3,4,5,6,7,8} 
   
   /* print the numbers */
   for i:= range numbers {
      fmt.Println("Slice item",i,"is",numbers[i])
   }
   
   /* create a map*/
   coutryCapitalMap := map[string] string {"France":"Paris","Italy":"Rome","Japan":"Tokyo"}
   
   /* print map using keys*/
   for country := range countryCapitalMap {
      fmt.Println("Capital of",country,"is",countryCapitalMap[country])
   }
   
   /* print map using key-value*/
   for country,capital := range countryCapitalMap {
      fmt.Println("Capital of",country,"is",capital)
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
Slice item 0 is 0
Slice item 1 is 1
Slice item 2 is 2
Slice item 3 is 3
Slice item 4 is 4
Slice item 5 is 5
Slice item 6 is 6
Slice item 7 is 7
Slice item 8 is 8
Capital of France is Paris
Capital of Italy is Rome
Capital of Japan is Tokyo
Capital of France is Paris
Capital of Italy is Rome
Capital of Japan is Tokyo
</pre>
<h1>Go - Maps</h1>
<p>Go provides another important data type map which maps unique keys to values. A key is an object that you use to retrieve a value at a later date. Given a key and a value, you can strore the value in a Map object. After value is stored, you can retrieve it by using its key.</p>
<h2>Defining a map</h2>
<p>You must use <b>make</b> function to create a map.</p>
<pre class="prettyprint">
/* declare a variable, by default map will be nil*/
var map_variable map[key_data_type]value_data_type

/* define the map as nil map can not be assigned any value*/
map_variable = make(map[key_data_type]value_data_type)
</pre>
<h2>Example</h2>
<p>Following example illustrates creation and usage of map.</p>
<pre class="prettyprint tryit">
package main

import "fmt"

func main {
   var coutryCapitalMap map[string]string
   /* create a map*/
   coutryCapitalMap = make(map[string]string)
   
   /* insert key-value pairs in the map*/
   countryCapitalMap["France"] = "Paris"
   countryCapitalMap["Italy"] = "Rome"
   countryCapitalMap["Japan"] = "Tokyo"
   countryCapitalMap["India"] = "New Delhi"
   
   /* print map using keys*/
   for country := range countryCapitalMap {
      fmt.Println("Capital of",country,"is",countryCapitalMap[country])
   }
   
   /* test if entry is present in the map or not*/
   captial, ok := countryCapitalMap["United States"]
   /* if ok is true, entry is present otherwise entry is absent*/
   if(ok){
      fmt.Println("Capital of United States is", capital)  
   }else {
      fmt.Println("Capital of United States is not present") 
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
Capital of India is New Delhi
Capital of France is Paris
Capital of Italy is Rome
Capital of Japan is Tokyo
Capital of United States is not present
</pre>
<h2>delete() function</h2>
<p>delete() function is used to delete an entry from the map. It requires map and corresponding key which is to be deleted. Following is the example:</p>
<pre class="prettyprint tryit">
package main

import "fmt"

func main {   
   /* create a map*/
   coutryCapitalMap := map[string] string {"France":"Paris","Italy":"Rome","Japan":"Tokyo","India":"New Delhi"}
   
   fmt.Println("Original map")   
   
   /* print map */
   for country := range countryCapitalMap {
      fmt.Println("Capital of",country,"is",countryCapitalMap[country])
   }
   
   /* delete an entry */
   delete(countryCapitalMap,"France");
   fmt.Println("Entry for France is deleted")  
   
   fmt.Println("Updated map")   
   
   /* print map */
   for country := range countryCapitalMap {
      fmt.Println("Capital of",country,"is",countryCapitalMap[country])
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
Original Map
Capital of France is Paris
Capital of Italy is Rome
Capital of Japan is Tokyo
Capital of India is New Delhi
Entry for France is deleted
Updated Map
Capital of India is New Delhi
Capital of Italy is Rome
Capital of Japan is Tokyo
</pre>
<h1>Go - Recursion</h1>
<p>Recursion is the process of repeating items in a self-similar way. Same applies in programming languages as well where if a programming allows you to call a function inside the same function that is called recursive call of the function as follows.</p>
<pre class="prettyprint">
func recursion() {
   recursion() /* function calls itself */
}

func main() {
   recursion()
}
</pre>
<p>The Go programming language supports recursion, i.e., a function to call itself. But while using recursion, programmers need to be careful to define an exit condition from the function, otherwise it will go in infinite loop.</p>
<p>Recursive function are very useful to solve many mathematical problems like to calculate factorial of a number, generating Fibonacci series, etc.</p>
<h2>Number Factorial</h2>
<p>Following is an example, which calculates factorial for a given number using a recursive function:</p>
<pre class="prettyprint tryit">
package main

import "fmt"

func factorial(i int)int {
   if(i &lt;= 1) {
      return 1
   }
   return i * factorial(i - 1)
}

func main() { 
   var i int = 15
   fmt.Printf("Factorial of %d is %d", i, factorial(i))
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
Factorial of 15 is 2004310016
</pre>
<h2>Fibonacci Series</h2>
<p>Following is another example, which generates Fibonacci series for a given number using a recursive function:</p>
<pre class="prettyprint tryit">
package main

import "fmt"

func fibonaci(i int) (ret int) {
   if i == 0 {
      return 0
   }
   
   if i == 1 {
      return 1
   }
    
   return fibonaci(i-1) + fibonaci(i-2)
}

func main() {
   var i int
   for i = 0; i &lt; 10; i++ {
      fmt.Printf("%d ", fibonaci(i))
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
0 1 1 2 3 5 8 13 21 34 
</pre>
<h1>Go - Type Casting</h1>
<p>Type casting is a way to convert a variable from one data type to another data type. For example, if you want to store a long value into a simple integer then you can type cast long to int. You can convert values from one type to another using the <b>cast operator</b> as following:</p>
<pre class="prettyprint">
type_name(expression)
</pre>
<h2>Example</h2>
<p>Consider the following example where the cast operator causes the divison of one integer variable by another to be performed as a floating number operation.</p>
<pre class="prettyprint tryit">
package main

import "fmt"

func main() {
   var sum int = 17
   var count int = 5
   var mean float32
   
   maen = float32(sum)/float32(count)
   fmt.Printf("Value of mean : %f\n",mean)
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
Value of mean : 3.400000
</pre>
<h1>Go - Interfaces</h1>
<p>Go programming provides another data type called interfaces which represents a set of method signatures. struct data type implements these interfaces to have metho definitions for the method signature of the interfaces.</p>
<h2>Syntax</h2>
<pre class="prettyprint">
/* define an interface */
type interface_name interface {
   method_name1 [return_type]
   method_name2 [return_type]
   method_name3 [return_type]
   ...
   method_namen [return_type]
}

/* define a struct */
type struct_name struct {
   /* variables */
}

/* implement interface methods*/
func (struct_name_variable struct_name) method_name1() [return_type] {
   /* method implementation */
}
...
func (struct_name_variable struct_name) method_namen() [return_type] {
   /* method implementation */
}
</pre>
<h2>Example</h2>
<pre class="prettyprint tryit">
package main

import (
   "fmt"
   "math"
)

/* define an interface */
type Shape interface {
   area() float64
}

/* define a circle */
type Circle struct {
   x,y,radius float64
}

/* define a rectangle */
type Rectangle struct {
   width, height float64
}

/* define a method for circle (implementation of Shape.area())*/
func(circle Circle) area() float64 {
   return math.Pi * circle.radius * circle.radius
}

/* define a method for rectangle (implementation of Shape.area())*/
func(rect Rectangle) area() float64 {
   return rect.width * rect.height
}

/* define a method for shape */
func getArea(shape Shape) float64 {
   return shape.area()
}

func main() {
   circle := Circle{x:0,y:0,radius:5}
   rectangle := Rectangle {width:10, height:5}
   
   fmt.Printf("Circle area: %f\n",getArea(circle))
   fmt.Printf("Rectangle area: %f\n",getArea(rectangle))
}

</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
Circle area: 78.539816
Rectangle area: 50.000000
</pre>
<h1>Go - Error Handling</h1>
<p>Go programming provides a pretty simple error handling framework with inbuit error interface type of following declaration:</p>
<pre class="prettyprint">
type error interface {
   Error() string
}
</pre>
<p>Functions normally return error as last return value. Use <b>errors.New</b> to construct a basic error message as following:</p>
<pre class="prettyprint">
func Sqrt(value float64)(float64, error) {
   if(value &lt; 0){
      return 0, errors.New("Math: negative number passed to Sqrt")
   }
   return math.Sqrt(value)
}
</pre>
<p>Use return value and error message.</p>
<pre class="prettyprint">
result, err:= Sqrt(-1)

if err != nil {
   fmt.Println(err)
}
</pre>
<h2>Example</h2>
<pre class="prettyprint tryit">
package main

import "errors"
import "fmt"
import "math"

func Sqrt(value float64)(float64, error) {
   if(value &lt; 0){
      return 0, errors.New("Math: negative number passed to Sqrt")
   }
   return math.Sqrt(value), nil
}

func main() {
   result, err:= Sqrt(-1)

   if err != nil {
      fmt.Println(err)
   }else {
      fmt.Println(result)
   }
   
   result, err = Sqrt(9)

   if err != nil {
      fmt.Println(err)
   }else {
      fmt.Println(result)
   }
}
</pre>
<p>When the above code is compiled and executed, it produces the following result:</p>
<pre class="result">
Math: negative number passed to Sqrt
3
</pre>

<title>Go Useful Resources</title>

<h1>Go - Useful Resources</h1>

<p>If you want to list down your website, book or any other resource on this page then please contact at webmaster@tutorialspoint.com</p>

<h2>Websites on Go Programming language</h2>

<p><a target="_blank" rel="nofollow" href="http://golang.org/">Go</a> - Go programming language official home page</p>

<p><a target="_blank" rel="nofollow" href="http://en.wikipedia.org/wiki/Go_%28programming_language%29">Go programming language - Wiki</a> - This site details the basics of Go programming language.</p>

<h2>Books on Go Programming language</h2>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Discuss Go</title>

<h1>Discuss Go</h1>

<p>Go language, is a programming language initially developed at Google in year 2007 by Robert Griesemer, Rob Pike, and Ken Thompson. Go programming language is a statically-typed language with syntax similar to that of C. It provides garbage collection, type safety, dynamic-typing capability, many advanced built-in types such as variable length arrays and key-value maps. It also provides a rich standard library. The Go programming language was announced in November 2009 and is used in some of the Google's production systems.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

</body></html>