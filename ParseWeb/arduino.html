<!DOCTYPE html><html><body><title>Arduino Tutorial</title>

<h1>Arduino Tutorial</h1>

<p>Arduino is a prototype platform (open-source) based on an easy-to-use hardware and software. It consists of a circuit board, which can be programed (referred to as a microcontroller) and a ready-made software called Arduino IDE (Integrated Development Environment), which is used to write and upload the computer code to the physical board.</p>

<p>Arduino provides a standard form factor that breaks the functions of the micro-controller into a more accessible package.</p>

<h1>Audience</h1>

<p>This tutorial is intended for enthusiastic students or hobbyists. With Arduino, one can get to know the basics of micro-controllers and sensors very quickly and can start building prototype with very little investment.</p>

<p>This tutorial is intended to make you comfortable in getting started with Arduino and its various functions.</p>

<h1>Prerequisites</h1>

<p>Before you start proceeding with this tutorial, we assume that you are already familiar with the basics of C and C++. If you are not well aware of these concepts, then we will suggest you go through our short tutorials on C and C++. A basic understanding of microcontrollers and electronics is also expected.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Arduino Overview</title>

<h1>Arduino - Overview</h1>

<p>Arduino is a prototype platform (open-source) based on an easy-to-use hardware and software. It consists of a circuit board, which can be programed (referred to as a microcontroller) and a ready-made software called Arduino IDE (Integrated Development Environment), which is used to write and upload the computer code to the physical board.</p>

<p>The key features are &minus;</p>

<p>Arduino boards are able to read analog or digital input signals from different sensors and turn it into an output such as activating a motor, turning LED on/off, connect to the cloud and many other actions.</p>

<p>You can control your board functions by sending a set of instructions to the microcontroller on the board via Arduino IDE (referred to as uploading software).</p>

<p>Unlike most previous programmable circuit boards, Arduino does not need an extra piece of hardware (called a programmer) in order to load a new code onto the board. You can simply use a USB cable.</p>

<p>Additionally, the Arduino IDE uses a simplified version of C++, making it easier to learn to program.</p>

<p>Finally, Arduino provides a standard form factor that breaks the functions of the micro-controller into a more accessible package.</p>

<h2>Board Types</h2>

<p>Various kinds of Arduino boards are available depending on different microcontrollers used. However, all Arduino boards have one thing in common: they are programed through the Arduino IDE.</p>

<p>The differences are based on the number of inputs and outputs (the number of sensors, LEDs, and buttons you can use on a single board), speed, operating voltage, form factor etc. Some boards are designed to be embedded and have no programming interface (hardware), which you would need to buy separately. Some can run directly from a 3.7V battery, others need at least 5V.</p>

<p>Here is a list of different Arduino boards available.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Arduino Board Description</title>

<h1>Arduino - Board Description</h1>

<p>In this chapter, we will learn about the different components on the Arduino board. We will study the Arduino UNO board because it is the most popular board in the Arduino board family. In addition, it is the best board to get started with electronics and coding. Some boards look a bit different from the one given below, but most Arduinos have majority of these components in common.</p>

<p><b>Power USB</b></p>

<p>Arduino board can be powered by using the USB cable from your computer. All you need to do is connect the USB cable to the USB connection (1).</p>

<p><b>Power (Barrel Jack)</b></p>

<p>Arduino boards can be powered directly from the AC mains power supply by connecting it to the Barrel Jack (2).</p>

<p><b>Voltage Regulator</b></p>

<p>The function of the voltage regulator is to control the voltage given to the Arduino board and stabilize the DC voltages used by the processor and other elements.</p>

<p><b>Crystal Oscillator</b></p>

<p>The crystal oscillator helps Arduino in dealing with time issues. How does Arduino calculate time? The answer is, by using the crystal oscillator. The number printed on top of the Arduino crystal is 16.000H9H. It tells us that the frequency is 16,000,000 Hertz or 16 MHz.</p>

<p><b>Arduino Reset</b></p>

<p>You can reset your Arduino board, i.e., start your program from the beginning. You can reset the UNO board in two ways. First, by using the reset button (17) on the board. Second, you can connect an external reset button to the Arduino pin labelled RESET (5).</p>

<p><b>Pins (3.3, 5, GND, Vin)</b></p>

<p>3.3V (6) &minus; Supply 3.3 output volt</p>

<p>5V (7) &minus; Supply 5 output volt</p>

<p>Most of the components used with Arduino board works fine with 3.3 volt and 5 volt.</p>

<p>GND (8)(Ground) &minus; There are several GND pins on the Arduino, any of which can be used to ground your circuit.</p>

<p>Vin (9) &minus; This pin also can be used to power the Arduino board from an external power source, like AC mains power supply.</p>

<p><b>Analog pins</b></p>

<p>The Arduino UNO board has five analog input pins A0 through A5. These pins can read the signal from an analog sensor like the humidity sensor or temperature sensor and convert it into a digital value that can be read by the microprocessor.</p>

<p><b>Main microcontroller</b></p>

<p>Each Arduino board has its own microcontroller (11). You can assume it as the brain of your board. The main IC (integrated circuit) on the Arduino is slightly different from board to board. The microcontrollers are usually of the ATMEL Company. You must know what IC your board has before loading up a new program from the Arduino IDE. This information is available on the top of the IC. For more details about the IC construction and functions, you can refer to the data sheet.</p>

<p><b>ICSP pin</b></p>

<p>Mostly, ICSP (12) is an AVR, a tiny programming header for the Arduino consisting of MOSI, MISO, SCK, RESET, VCC, and GND. It is often referred to as an SPI (Serial Peripheral Interface), which could be considered as an "expansion" of the output. Actually, you are slaving the output device to the master of the SPI bus.</p>

<p><b>Power LED indicator</b></p>

<p>This LED should light up when you plug your Arduino into a power source to indicate that your board is powered up correctly. If this light does not turn on, then there is something wrong with the connection.</p>

<p><b>TX and RX LEDs</b></p>

<p>On your board, you will find two labels: TX (transmit) and RX (receive). They appear in two places on the Arduino UNO board. First, at the digital pins 0 and 1, to indicate the pins responsible for serial communication. Second, the TX and RX led (13). The TX led flashes with different speed while sending the serial data. The speed of flashing depends on the baud rate used by the board. RX flashes during the receiving process.</p>

<p><b>Digital I/O</b></p>

<p>The Arduino UNO board has 14 digital I/O pins (15) (of which 6 provide PWM (Pulse Width Modulation) output. These pins can be configured to work as input digital pins to read logic values (0 or 1) or as digital output pins to drive different modules like LEDs, relays, etc. The pins labeled “~” can be used to generate PWM.</p>

<p><b>AREF</b></p>

<p>AREF stands for Analog Reference. It is sometimes, used to set an external reference voltage (between 0 and 5 Volts) as the upper limit for the analog input pins.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Arduino Installation</title>

<h1>Arduino - Installation</h1>

<p>After learning about the main parts of the Arduino UNO board, we are ready to learn how to set up the Arduino IDE. Once we learn this, we will be ready to upload our program on the Arduino board.</p>

<p>In this section, we will learn in easy steps, how to set up the Arduino IDE on our computer and prepare the board to receive the program via USB cable.</p>

<p><b>Step 1</b> &minus; First you must have your Arduino board (you can choose your favorite board) and a USB cable. In case you use Arduino UNO, Arduino Duemilanove, Nano, Arduino Mega 2560, or Diecimila, you will need a standard USB cable (A plug to B plug), the kind you would connect to a USB printer as shown in the following image.</p>

<p>In case you use Arduino Nano, you will need an A to Mini-B cable instead as shown in the following image.</p>

<p><b>Step 2 &minus; Download Arduino IDE Software.</b></p>

<p>You can get different versions of Arduino IDE from the <a href="https://www.arduino.cc/en/Main/Software" rel="nofollow" target="_blank">Download page</a> on the Arduino Official website. You must select your software, which is compatible with your operating system (Windows, IOS, or Linux). After your file download is complete, unzip the file.</p>

<p><b>Step 3 &minus; Power up your board.</b></p>

<p>The Arduino Uno, Mega, Duemilanove and Arduino Nano automatically draw power from either, the USB connection to the computer or an external power supply. If you are using an Arduino Diecimila, you have to make sure that the board is configured to draw power from the USB connection. The power source is selected with a jumper, a small piece of plastic that fits onto two of the three pins between the USB and power jacks. Check that it is on the two pins closest to the USB port.</p>

<p>Connect the Arduino board to your computer using the USB cable. The green power LED (labeled PWR) should glow.</p>

<p><b>Step 4 &minus; Launch Arduino IDE.</b></p>

<p>After your Arduino IDE software is downloaded, you need to unzip the folder. Inside the folder, you can find the application icon with an infinity label (application.exe). Double-click the icon to start the IDE.</p>

<p><b>Step 5 &minus; Open your first project.</b></p>

<p>Once the software starts, you have two options &minus;</p>

<p>To create a new project, select File &rarr; <b>New</b>.</p>

<p>To open an existing project example, select File &rarr; Example &rarr; Basics &rarr; Blink.</p>

<p>Here, we are selecting just one of the examples with the name <b>Blink</b>. It turns the LED on and off with some time delay. You can select any other example from the list.</p>

<p><b>Step 6 &minus; Select your Arduino board.</b></p>

<p>To avoid any error while uploading your program to the board, you must select the correct Arduino board name, which matches with the board connected to your computer.</p>

<p>Go to Tools &rarr; Board and select your board.</p>

<p>Here, we have selected Arduino Uno board according to our tutorial, but you must select the name matching the board that you are using.</p>

<p><b>Step 7 &minus; Select your serial port.</b></p>

<p>Select the serial device of the Arduino board. Go to <b>Tools &rarr; Serial Port</b> menu. This is likely to be COM3 or higher (COM1 and COM2 are usually reserved for hardware serial ports). To find out, you can disconnect your Arduino board and re-open the menu, the entry that disappears should be of the Arduino board. Reconnect the board and select that serial port.</p>

<p><b>Step 8 &minus; Upload the program to your board.</b></p>

<p>Before explaining how we can upload our program to the board, we must demonstrate the function of each symbol appearing in the Arduino IDE toolbar.</p>

<p>Now, simply click the "Upload" button in the environment. Wait a few seconds; you will see the RX and TX LEDs on the board, flashing. If the upload is successful, the message "Done uploading" will appear in the status bar.</p>

<p><b>Note</b> &minus; If you have an Arduino Mini, NG, or other board, you need to press the reset button physically on the board, immediately before clicking the upload button on the Arduino Software.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Arduino Program Structure</title>

<h1>Arduino - Program Structure</h1>

<p>In this chapter, we will study in depth, the Arduino program structure and we will learn more new terminologies used in the Arduino world. The Arduino software is open-source. The source code for the Java environment is released under the GPL and the C/C++ microcontroller libraries are under the LGPL.</p>

<p><b>Sketch</b> &minus; The first new terminology is the Arduino program called “<b>sketch</b>”.</p>

<h2>Structure</h2>

<p>Arduino programs can be divided in three main parts: <b>Structure, Values</b> (variables and constants), and <b>Functions</b>. In this tutorial, we will learn about the Arduino software program, step by step, and how we can write the program without any syntax or compilation error.</p>

<p>Let us start with the <b>Structure</b>. Software structure consist of two main functions &minus;</p>

<p><b>PURPOSE</b> &minus; The <b>setup()</b> function is called when a sketch starts. Use it to initialize the variables, pin modes, start using libraries, etc. The setup function will only run once, after each power up or reset of the Arduino board.</p>

<p><b>INPUT</b> &minus;      -</p>

<p><b>OUTPUT</b> &minus;     -</p>

<p><b>RETURN</b> &minus;     -</p>

<p><b>PURPOSE</b> &minus; After creating a <b>setup()</b> function, which initializes and sets the initial values, the <b>loop()</b> function does precisely what its name suggests, and loops consecutively, allowing your program to change and respond. Use it to actively control the Arduino board.</p>

<p><b>INPUT</b> &minus;      -</p>

<p><b>OUTPUT</b> &minus;     -</p>

<p><b>RETURN</b> &minus;     -</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
Void setup ( ) {

}
</pre>
<ul class="list">
<li><p><b>PURPOSE</b> &minus; The <b>setup()</b> function is called when a sketch starts. Use it to initialize the variables, pin modes, start using libraries, etc. The setup function will only run once, after each power up or reset of the Arduino board.</p></li>
<li><p><b>INPUT</b> &minus;      -</p></li>
<li><p><b>OUTPUT</b> &minus;     -</p></li>
<li><p><b>RETURN</b> &minus;     -</p></li>
</ul>
<pre class="result notranslate">
Void Loop ( ) {

}
</pre>

<title>Arduino Data Types</title>

<h1>Arduino - Data Types</h1>

<p>Data types in C refers to an extensive system used for declaring variables or functions of different types. The type of a variable determines how much space it occupies in the storage and how the bit pattern stored is interpreted.</p>

<p>The following table provides all the data types that you will use during Arduino programming.</p>

<h2>void</h2>

<p>The void keyword is used only in function declarations. It indicates that the function is expected to return no information to the function from which it was called.</p>

<h3>Example</h3>

<h2>Boolean</h2>

<p>A Boolean holds one of two values, true or false. Each Boolean variable occupies one byte of memory.</p>

<h3>Example</h3>

<h2>Char</h2>

<p>A data type that takes up one byte of memory that stores a character value. Character literals are written in single quotes like this: 'A' and for multiple characters, strings use double quotes: "ABC".</p>

<p>However, characters are stored as numbers. You can see the specific encoding in the <a href="https://www.arduino.cc/en/Reference/ASCIIchart" rel="nofollow" target="_blank">ASCII chart</a>. This means that it is possible to do arithmetic operations on characters, in which the ASCII value of the character is used. For example, 'A' + 1 has the value 66, since the ASCII value of the capital letter A is 65.</p>

<h3>Example</h3>

<p></p>

<h2>unsigned char</h2>

<p><b>Unsigned char</b> is an unsigned data type that occupies one byte of memory. The unsigned char data type encodes numbers from 0 to 255.</p>

<h3>Example</h3>

<h2>byte</h2>

<p>A byte stores an 8-bit unsigned number, from 0 to 255.</p>

<h3>Example</h3>

<h2>int</h2>

<p>Integers are the primary data-type for number storage. int stores a 16-bit (2-byte) value. This yields a range of -32,768 to 32,767 (minimum value of -2&#94;15 and a maximum value of (2&#94;15) - 1).</p>

<p>The <b>int</b> size varies from board to board. On the Arduino Due, for example, an <b>int</b> stores a 32-bit (4-byte) value. This yields a range of -2,147,483,648 to 2,147,483,647 (minimum value of -2&#94;31 and a maximum value of (2&#94;31) - 1).</p>

<h3>Example</h3>

<h2>Unsigned int</h2>

<p>Unsigned ints (unsigned integers) are the same as int in the way that they store a 2 byte value. Instead of storing negative numbers, however, they only store positive values, yielding a useful range of 0 to 65,535 (2&#94;16) - 1). The Due stores a 4 byte (32-bit) value, ranging from 0 to 4,294,967,295 (2&#94;32 - 1).</p>

<h3>Example</h3>

<h2>Word</h2>

<p>On the Uno and other ATMEGA based boards, a word stores a 16-bit unsigned number. On the Due and Zero, it stores a 32-bit unsigned number.</p>

<h3>Example</h3>

<h2>Long</h2>

<p>Long variables are extended size variables for number storage, and store 32 bits (4 bytes), from 2,147,483,648 to 2,147,483,647.</p>

<h3>Example</h3>

<h2>unsigned long</h2>

<p>Unsigned long variables are extended size variables for number storage and store 32 bits (4 bytes). Unlike standard longs, unsigned longs will not store negative numbers, making their range from 0 to 4,294,967,295 (2&#94;32 - 1).</p>

<h3>Example</h3>

<h2>short</h2>

<p>A short is a 16-bit data-type. On all Arduinos (ATMega and ARM based), a short stores a 16-bit (2-byte) value. This yields a range of -32,768 to 32,767 (minimum value of -2&#94;15 and a maximum value of (2&#94;15) - 1).</p>

<h3>Example</h3>

<h2>float</h2>

<p>Data type for floating-point number is a number that has a decimal point. Floating-point numbers are often used to approximate the analog and continuous values because they have greater resolution than integers.</p>

<p>Floating-point numbers can be as large as 3.4028235E+38 and as low as 3.4028235E+38. They are stored as 32 bits (4 bytes) of information.</p>

<h3>Example</h3>

<h2>double</h2>

<p>On the Uno and other ATMEGA based boards, Double precision floating-point number occupies four bytes. That is, the double implementation is exactly the same as the float, with no gain in precision. On the Arduino Due, doubles have 8-byte (64 bit) precision.</p>

<h3>Example</h3>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
Void Loop ( ) {
   // rest of the code
}
</pre>
<h2>Boolean</h2>
<p>A Boolean holds one of two values, true or false. Each Boolean variable occupies one byte of memory.</p>
<h3>Example</h3>
<pre class="result notranslate">
boolean val = false ; // declaration of variable with type boolean and initialize it with false
boolean state = true ; // declaration of variable with type boolean and initialize it with true
</pre>
<h2>Char</h2>
<p>A data type that takes up one byte of memory that stores a character value. Character literals are written in single quotes like this: 'A' and for multiple characters, strings use double quotes: "ABC".</p>
<p>However, characters are stored as numbers. You can see the specific encoding in the <a href="https://www.arduino.cc/en/Reference/ASCIIchart" rel="nofollow" target="_blank">ASCII chart</a>. This means that it is possible to do arithmetic operations on characters, in which the ASCII value of the character is used. For example, 'A' + 1 has the value 66, since the ASCII value of the capital letter A is 65.</p>
<h3>Example</h3>
<pre class="result notranslate">
Char chr_a = ‘a’ ;//declaration of variable with type char and initialize it with character a
Char chr_c = 97 ;//declaration of variable with type char and initialize it with character 97
</pre>
<p></p>
<img src="/arduino/images/ascii_char_table.jpg" alt="ASCII Char Table" />
<h2>unsigned char</h2>
<p><b>Unsigned char</b> is an unsigned data type that occupies one byte of memory. The unsigned char data type encodes numbers from 0 to 255.</p>
<h3>Example</h3>
<pre class="result notranslate">
Unsigned Char chr_y = 121 ; // declaration of variable with type Unsigned char and initialize it with character y
</pre>
<h2>byte</h2>
<p>A byte stores an 8-bit unsigned number, from 0 to 255.</p>
<h3>Example</h3>
<pre class="result notranslate">
byte m = 25 ;//declaration of variable with type byte and initialize it with 25
</pre>
<h2>int</h2>
<p>Integers are the primary data-type for number storage. int stores a 16-bit (2-byte) value. This yields a range of -32,768 to 32,767 (minimum value of -2&#94;15 and a maximum value of (2&#94;15) - 1).</p>
<p>The <b>int</b> size varies from board to board. On the Arduino Due, for example, an <b>int</b> stores a 32-bit (4-byte) value. This yields a range of -2,147,483,648 to 2,147,483,647 (minimum value of -2&#94;31 and a maximum value of (2&#94;31) - 1).</p>
<h3>Example</h3>
<pre class="result notranslate">
int counter = 32 ;// declaration of variable with type int and initialize it with 32
</pre>
<h2>Unsigned int</h2>
<p>Unsigned ints (unsigned integers) are the same as int in the way that they store a 2 byte value. Instead of storing negative numbers, however, they only store positive values, yielding a useful range of 0 to 65,535 (2&#94;16) - 1). The Due stores a 4 byte (32-bit) value, ranging from 0 to 4,294,967,295 (2&#94;32 - 1).</p>
<h3>Example</h3>
<pre class="result notranslate">
Unsigned int counter = 60 ; // declaration of variable with 
   type unsigned int and initialize it with 60
</pre>
<h2>Word</h2>
<p>On the Uno and other ATMEGA based boards, a word stores a 16-bit unsigned number. On the Due and Zero, it stores a 32-bit unsigned number.</p>
<h3>Example</h3>
<pre class="result notranslate">
word w = 1000 ;//declaration of variable with type word and initialize it with 1000
</pre>
<h2>Long</h2>
<p>Long variables are extended size variables for number storage, and store 32 bits (4 bytes), from 2,147,483,648 to 2,147,483,647.</p>
<h3>Example</h3>
<pre class="result notranslate">
Long velocity = 102346 ;//declaration of variable with type Long and initialize it with 102346
</pre>
<h2>unsigned long</h2>
<p>Unsigned long variables are extended size variables for number storage and store 32 bits (4 bytes). Unlike standard longs, unsigned longs will not store negative numbers, making their range from 0 to 4,294,967,295 (2&#94;32 - 1).</p>
<h3>Example</h3>
<pre class="result notranslate">
Unsigned Long velocity = 101006 ;// declaration of variable with 
   type Unsigned Long and initialize it with 101006
</pre>
<h2>short</h2>
<p>A short is a 16-bit data-type. On all Arduinos (ATMega and ARM based), a short stores a 16-bit (2-byte) value. This yields a range of -32,768 to 32,767 (minimum value of -2&#94;15 and a maximum value of (2&#94;15) - 1).</p>
<h3>Example</h3>
<pre class="result notranslate">
short val = 13 ;//declaration of variable with type short and initialize it with 13
</pre>
<h2>float</h2>
<p>Data type for floating-point number is a number that has a decimal point. Floating-point numbers are often used to approximate the analog and continuous values because they have greater resolution than integers.</p>
<p>Floating-point numbers can be as large as 3.4028235E+38 and as low as 3.4028235E+38. They are stored as 32 bits (4 bytes) of information.</p>
<h3>Example</h3>
<pre class="result notranslate">
float num = 1.352;//declaration of variable with type float and initialize it with 1.352
</pre>
<h2>double</h2>
<p>On the Uno and other ATMEGA based boards, Double precision floating-point number occupies four bytes. That is, the double implementation is exactly the same as the float, with no gain in precision. On the Arduino Due, doubles have 8-byte (64 bit) precision.</p>
<h3>Example</h3>
<pre class="result notranslate">
double num = 45.352 ;// declaration of variable with type double and initialize it with 45.352
</pre>

<title>Arduino Variables and Constants</title>

<h1>Arduino - Variables &amp; Constants</h1>

<p>Before we start explaining the variable types, a very important subject we need to make sure, you fully understand is called the <b>variable scope</b>.</p>

<h2>What is Variable Scope?</h2>

<p>Variables in C programming language, which Arduino uses, have a property called scope. A scope is a region of the program and there are three places where variables can be declared. They are &minus;</p>

<h3>Local Variables</h3>

<p>Variables that are declared inside a function or block are local variables. They can be used only by the statements that are inside that function or block of code. Local variables are not known to function outside their own. Following is the example using local variables &minus;</p>

<h3>Global Variables</h3>

<p>Global variables are defined outside of all the functions, usually at the top of the program. The global variables will hold their value throughout the life-time of your program.</p>

<p>A global variable can be accessed by any function. That is, a global variable is available for use throughout your entire program after its declaration.</p>

<p>The following example uses global and local variables &minus;</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
Void setup () {

}

Void loop () {
   int x , y ;
   int z ; Local variable declaration
   x = 0;
   y = 0; actual initialization
   z = 10;
}
</pre>
<h3>Global Variables</h3>
<p>Global variables are defined outside of all the functions, usually at the top of the program. The global variables will hold their value throughout the life-time of your program.</p>
<p>A global variable can be accessed by any function. That is, a global variable is available for use throughout your entire program after its declaration.</p>
<p>The following example uses global and local variables &minus;</p>
<pre class="prettyprint notranslate">
Int T , S ;
float c = 0 ; Global variable declaration

Void setup () {

}

Void loop () {
   int x , y ;
   int z ; Local variable declaration
   x = 0;
   y = 0; actual initialization
   z = 10;
}
</pre>

<title>Arduino Operators</title>

<h1>Arduino - Operators</h1>

<p>An operator is a symbol that tells the compiler to perform specific mathematical or logical functions. C language is rich in built-in operators and provides the following types of operators &minus;</p>

<h2>Arithmetic Operators</h2>

<p>Assume variable A holds 10 and variable B holds 20 then &minus;</p>

<p><a href="/arduino/arduino_arithmetic_operators.htm">Show Example</a></p>

<h2>Comparison Operators</h2>

<p>Assume variable A holds 10 and variable B holds 20 then &minus;</p>

<p><a href="/arduino/arduino_comparison_operators.htm">Show Example</a></p>

<h2>Boolean Operators</h2>

<p>Assume variable A holds 10 and variable B holds 20 then &minus;</p>

<p><a href="/arduino/arduino_boolean_operators.htm">Show Example</a></p>

<h2>Bitwise Operators</h2>

<p>Assume variable A holds 60 and variable B holds 13 then &minus;</p>

<p><a href="/arduino/arduino_bitwise_operators.htm">Show Example</a></p>

<h2>Compound Operators</h2>

<p>Assume variable A holds 10 and variable B holds 20 then &minus;</p>

<p><a href="/arduino/arduino_compound_operators.htm">Show Example</a></p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Arduino Control Statements</title>

<h1>Arduino - Control Statements</h1>

<p>Decision making structures require that the programmer specify one or more conditions to be evaluated or tested by the program. It should be along with a statement or statements to be executed if the condition is determined to be true, and optionally, other statements to be executed if the condition is determined to be false.</p>

<p>Following is the general form of a typical decision making structure found in most of the programming languages &minus;</p>

<p>Control Statements are elements in Source Code that control the flow of program execution. They are &minus;</p>

<p><a href="/arduino/arduino_if_statement.htm">If statement</a></p>

<p>It takes an expression in parenthesis and a statement or block of statements. If the expression is true then the statement or block of statements gets executed otherwise these statements are skipped.</p>

<p><a href="/arduino/arduino_if_else_statement.htm">If …else statement</a></p>

<p>An <b>if</b> statement can be followed by an optional else statement, which executes when the expression is false.</p>

<p><a href="/arduino/arduino_if_else_if_else_statement.htm">If…else if …else statement</a></p>

<p>The <b>if</b> statement can be followed by an optional <b>else if...else</b> statement, which is very useful to test various conditions using single if...else if statement.</p>

<p><a href="/arduino/arduino_switch_case_statement.htm">switch case statement</a></p>

<p>Similar to the if statements, <b>switch...case</b> controls the flow of programs by allowing the programmers to specify different codes that should be executed in various conditions.</p>

<p><a href="/arduino/arduino_conditional_operator.htm">Conditional Operator ? :</a></p>

<p>The conditional operator ? : is the only ternary operator in C.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Arduino Loops</title>

<h1>Arduino - Loops</h1>

<p>Programming languages provide various control structures that allow for more complicated execution paths.</p>

<p>A loop statement allows us to execute a statement or group of statements multiple times and following is the general form of a loop statement in most of the programming languages &minus;</p>

<p>C programming language provides the following types of loops to handle looping requirements.</p>

<p><a href="/arduino/arduino_while_loop.htm">while loop</a></p>

<p>while loops will loop continuously, and infinitely, until the expression inside the parenthesis, () becomes false. Something must change the tested variable, or the while loop will never exit.</p>

<p><a href="/arduino/arduino_do_while_loop.htm">do…while loop</a></p>

<p>The <b>do…while</b> loop is similar to the while loop. In the while loop, the loop-continuation condition is tested at the beginning of the loop before performed the body of the loop.</p>

<p><a href="/arduino/arduino_for_loop.htm">for loop</a></p>

<p>A <b>for loop</b> executes statements a predetermined number of times. The control expression for the loop is initialized, tested and manipulated entirely within the for loop parentheses.</p>

<p><a href="/arduino/arduino_nested_loop.htm">Nested Loop</a></p>

<p>C language allows you to use one loop inside another loop. The following example illustrates the concept.</p>

<p><a href="/arduino/arduino_infinite_loop.htm">Infinite loop</a></p>

<p>It is the loop having no terminating condition, so the loop becomes infinite.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Arduino Functions</title>

<h1>Arduino - Functions</h1>

<p>Functions allow structuring the programs in segments of code to perform individual tasks. The typical case for creating a function is when one needs to perform the same action multiple times in a program.</p>

<p>Standardizing code fragments into functions has several advantages &minus;</p>

<p>Functions help the programmer stay organized. Often this helps to conceptualize the program.</p>

<p>Functions codify one action in one place so that the function only has to be thought about and debugged once.</p>

<p>This also reduces chances for errors in modification, if the code needs to be changed.</p>

<p>Functions make the whole sketch smaller and more compact because sections of code are reused many times.</p>

<p>They make it easier to reuse code in other programs by making it modular, and using functions often makes the code more readable.</p>

<p>There are two required functions in an Arduino sketch or a program i.e. setup () and loop(). Other functions must be created outside the brackets of these two functions.</p>

<p>The most common syntax to define a function is &minus;</p>

<h2>Function Declaration</h2>

<p>A function is declared outside any other functions, above or below the loop function.</p>

<p>We can declare the function in two different ways &minus;</p>

<p>The first way is just writing the part of the function called <b>a function prototype</b> above the loop function, which consists of &minus;</p>

<p>Function prototype must be followed by a semicolon ( ; ).</p>

<p>The following example shows the demonstration of the function declaration using the first method.</p>

<h3>Example</h3>

<p>The second part, which is called the function definition or declaration, must be declared below the loop function, which consists of &minus;</p>

<p>The following example demonstrates the declaration of function using the second method.</p>

<h3>Example</h3>

<p>The second method just declares the function above the loop function.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
int sum_func (int x, int y) // function declaration {
   int z = 0;
   z = x+y ;
   return z; // return the value
}

void setup () {
   Statements // group of statements
}

Void loop () {
   int result = 0 ;
   result = Sum_func (5,6) ; // function call
}
</pre>
<p>The second part, which is called the function definition or declaration, must be declared below the loop function, which consists of &minus;</p>
<ul class="list">
<li>Function return type</li>
<li>Function name</li>
<li>Function argument type, here you must add the argument name</li>
<li>The function body (statements inside the function executing when the function is called)</li>
</ul>
<p>The following example demonstrates the declaration of function using the second method.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
int sum_func (int , int ) ; // function prototype

void setup () {
   Statements // group of statements
}

Void loop () {
   int result = 0 ;
   result = Sum_func (5,6) ; // function call
}

int sum_func (int x, int y) // function declaration {
   int z = 0;
   z = x+y ;
   return z; // return the value
}
</pre>

<title>Arduino Strings</title>

<h1>Arduino - Strings</h1>

<p>Strings are used to store text. They can be used to display text on an LCD or in the Arduino IDE Serial Monitor window. Strings are also useful for storing the user input. For example, the characters that a user types on a keypad connected to the Arduino.</p>

<p>There are two types of strings in Arduino programming &minus;</p>

<p>In this chapter, we will learn Strings, objects and the use of strings in Arduino sketches. By the end of the chapter, you will learn which type of string to use in a sketch.</p>

<h2>String Character Arrays</h2>

<p>The first type of string that we will learn is the string that is a series of characters of the type <b>char</b>. In the previous chapter, we learned what an array is; a consecutive series of the same type of variable stored in memory. A string is an array of char variables.</p>

<p>A string is a special array that has one extra element at the end of the string, which always has the value of 0 (zero). This is known as a "null terminated string".</p>

<h3>String Character Array Example</h3>

<p>This example will show how to make a string and print it to the serial monitor window.</p>

<p><b>Example</b></p>

<p>The following example shows what a string is made up of; a character array with printable characters and 0 as the last element of the array to show that this is where the string ends. The string can be printed out to the Arduino IDE Serial Monitor window by using <b>Serial.println()</b> and passing the name of the string.</p>

<p>This same example can be written in a more convenient way as shown below &minus;</p>

<p><b>Example</b></p>

<p>In this sketch, the compiler calculates the size of the string array and also automatically null terminates the string with a zero. An array that is six elements long and consists of five characters followed by a zero is created exactly the same way as in the previous sketch.</p>

<h2>Manipulating String Arrays</h2>

<p>We can alter a string array within a sketch as shown in the following sketch.</p>

<h3>Example</h3>

<h3>Result</h3>

<p>The sketch works in the following way.</p>

<h3>Creating and Printing the String</h3>

<p>In the sketch given above, a new string is created and then printed for display in the Serial Monitor window.</p>

<h3>Shortening the String</h3>

<p>The string is shortened by replacing the 14th character in the string with a null terminating zero (2). This is element number 13 in the string array counting from 0.</p>

<p>When the string is printed, all the characters are printed up to the new null terminating zero. The other characters do not disappear; they still exist in the memory and the string array is still the same size. The only difference is that any function that works with strings will only see the string up to the first null terminator.</p>

<h3>Changing a Word in the String</h3>

<p>Finally, the sketch replaces the word "cake" with "tea" (3). It first has to replace the null terminator at like[13] with a space so that the string is restored to the originally created format.</p>

<p>New characters overwrite "cak" of the word "cake" with the word "tea". This is done by overwriting individual characters. The 'e' of "cake" is replaced with a new null terminating character. The result is that the string is actually terminated with two null characters, the original one at the end of the string and the new one that replaces the 'e' in "cake". This makes no difference when the new string is printed because the function that prints the string stops printing the string characters when it encounters the first null terminator.</p>

<h2>Functions to Manipulate String Arrays</h2>

<p>The previous sketch manipulated the string in a manual way by accessing individual characters in the string. To make it easier to manipulate string arrays, you can write your own functions to do so, or use some of the string functions from the <b>C</b> language library.</p>

<p><b>String()</b></p>

<p>The String class, part of the core as of version 0019, allows you to use and manipulate strings of text in more complex ways than character arrays do. You can concatenate Strings, append to them, search for and replace substrings, and more. It takes more memory than a simple character array, but it is also more useful.</p>

<p>For reference, character arrays are referred to as strings with a small ‘s’, and instances of the String class are referred to as Strings with a capital S. Note that constant strings, specified in "double quotes" are treated as char arrays, not instances of the String class</p>

<p><b>charAt()</b></p>

<p>Access a particular character of the String.</p>

<p><b>compareTo()</b></p>

<p>Compares two Strings, testing whether one comes before or after the other, or whether they are equal. The strings are compared character by character, using the ASCII values of the characters. That means, for example, 'a' comes before 'b' but after 'A'. Numbers come before letters.</p>

<p><b>concat()</b></p>

<p>Appends the parameter to a String.</p>

<p><b>c_str()</b></p>

<p>Converts the contents of a string as a C-style, null-terminated string. Note that this gives direct access to the internal String buffer and should be used with care. In particular, you should never modify the string through the pointer returned. When you modify the String object, or when it is destroyed, any pointer previously returned by c_str() becomes invalid and should not be used any longer.</p>

<p><b>endsWith()</b></p>

<p>Tests whether or not a String ends with the characters of another String.</p>

<p><b>equals()</b></p>

<p>Compares two strings for equality. The comparison is case-sensitive, meaning the String "hello" is not equal to the String "HELLO".</p>

<p><b>equalsIgnoreCase()</b></p>

<p>Compares two strings for equality. The comparison is not case-sensitive, meaning the String("hello") is equal to the String("HELLO").</p>

<p><b>getBytes()</b></p>

<p>Copies the string's characters to the supplied buffer.</p>

<p><b>indexOf()</b></p>

<p>Locates a character or String within another String. By default, it searches from the beginning of the String, but can also start from a given index, allowing to locate all instances of the character or String.</p>

<p><b>lastIndexOf()</b></p>

<p>Locates a character or String within another String. By default, it searches from the end of the String, but can also work backwards from a given index, allowing to locate all instances of the character or String.</p>

<p><b>length()</b></p>

<p>Returns the length of the String, in characters. (Note that this does not include a trailing null character.)</p>

<p><b>remove()</b></p>

<p>Modify in place, a string removing chars from the provided index to the end of the string or from the provided index to index plus count.</p>

<p><b>replace()</b></p>

<p>The String replace() function allows you to replace all instances of a given character with another character. You can also use replace to replace substrings of a string with a different substring.</p>

<p><b>reserve()</b></p>

<p>The String reserve() function allows you to allocate a buffer in memory for manipulating strings.</p>

<p><b>setCharAt()</b></p>

<p>Sets a character of the String. Has no effect on indices outside the existing length of the String.</p>

<p><b>startsWith()</b></p>

<p>Tests whether or not a String starts with the characters of another String.</p>

<p><b>toCharArray()</b></p>

<p>Copies the string's characters to the supplied buffer.</p>

<p><b>substring()</b></p>

<p>Get a substring of a String. The starting index is inclusive (the corresponding character is included in the substring), but the optional ending index is exclusive (the corresponding character is not included in the substring). If the ending index is omitted, the substring continues to the end of the String.</p>

<p><b>toInt()</b></p>

<p>Converts a valid String to an integer. The input string should start with an integer number. If the string contains non-integer numbers, the function will stop performing the conversion.</p>

<p><b>toFloat()</b></p>

<p>Converts a valid String to a float. The input string should start with a digit. If the string contains non-digit characters, the function will stop performing the conversion. For example, the strings "123.45", "123", and "123fish" are converted to 123.45, 123.00, and 123.00 respectively. Note that "123.456" is approximated with 123.46. Note too that floats have only 6-7 decimal digits of precision and that longer strings might be truncated.</p>

<p><b>toLowerCase()</b></p>

<p>Get a lower-case version of a String. As of 1.0, toLowerCase() modifies the string in place rather than returning a new.</p>

<p><b>toUpperCase()</b></p>

<p>Get an upper-case version of a String. As of 1.0, toUpperCase() modifies the string in place rather than returning a new one.</p>

<p><b>trim()</b></p>

<p>Get a version of the String with any leading and trailing whitespace removed. As of 1.0, trim() modifies the string in place rather than returning a new one.</p>

<p>The next sketch uses some C string functions.</p>

<h3>Example</h3>

<h3>Result</h3>

<p>The sketch works in the following way.</p>

<h3>Print the String</h3>

<p>The newly created string is printed to the Serial Monitor window as done in previous sketches.</p>

<h3>Get the Length of the String</h3>

<p>The strlen() function is used to get the length of the string. The length of the string is for the printable characters only and does not include the null terminator.</p>

<p>The string contains 17 characters, so we see 17 printed in the Serial Monitor window.</p>

<h3>Get the Length of the Array</h3>

<p>The operator sizeof() is used to get the length of the array that contains the string. The length includes the null terminator, so the length is one more than the length of the string.</p>

<p>sizeof() looks like a function, but technically is an operator. It is not a part of the C string library, but was used in the sketch to show the difference between the size of the array and the size of the string (or string length).</p>

<h3>Copy a String</h3>

<p>The strcpy() function is used to copy the str[] string to the out_num[] array. The strcpy() function copies the second string passed to it into the first string. A copy of the string now exists in the out_num[] array, but only takes up 18 elements of the array, so we still have 22 free char elements in the array. These free elements are found after the string in memory.</p>

<p>The string was copied to the array so that we would have some extra space in the array to use in the next part of the sketch, which is adding a string to the end of a string.</p>

<h3>Append a String to a String (Concatenate)</h3>

<p>The sketch joins one string to another, which is known as concatenation. This is done using the strcat() function. The strcat() function puts the second string passed to it onto the end of the first string passed to it.</p>

<p>After concatenation, the length of the string is printed to show the new string length. The length of the array is then printed to show that we have a 25-character long string in a 40 element long array.</p>

<p>Remember that the 25-character long string actually takes up 26 characters of the array because of the null terminating zero.</p>

<h2>Array Bounds</h2>

<p>When working with strings and arrays, it is very important to work within the bounds of strings or arrays. In the example sketch, an array was created, which was 40 characters long, in order to allocate the memory that could be used to manipulate strings.</p>

<p>If the array was made too small and we tried to copy a string that is bigger than the array to it, the string would be copied over the end of the array. The memory beyond the end of the array could contain other important data used in the sketch, which would then be overwritten by our string. If the memory beyond the end of the string is overrun, it could crash the sketch or cause unexpected behavior.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
void setup() {
   char my_str[6]; // an array big enough for a 5 character string
   Serial.begin(9600);
   my_str[0] = 'H'; // the string consists of 5 characters
   my_str[1] = 'e';
   my_str[2] = 'l';
   my_str[3] = 'l';
   my_str[4] = 'o';
   my_str[5] = 0; // 6th array element is a null terminator
   Serial.println(my_str);
}

void loop() { 

}
</pre>
<p>The following example shows what a string is made up of; a character array with printable characters and 0 as the last element of the array to show that this is where the string ends. The string can be printed out to the Arduino IDE Serial Monitor window by using <b>Serial.println()</b> and passing the name of the string.</p>
<p>This same example can be written in a more convenient way as shown below &minus;</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
void setup() {
   char my_str[] = "Hello";
   Serial.begin(9600);
   Serial.println(my_str);
}

void loop() {

}
</pre>
<p>In this sketch, the compiler calculates the size of the string array and also automatically null terminates the string with a zero. An array that is six elements long and consists of five characters followed by a zero is created exactly the same way as in the previous sketch.</p>
<h2>Manipulating String Arrays</h2>
<p>We can alter a string array within a sketch as shown in the following sketch.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
void setup() {
   char like[] = "I like coffee and cake"; // create a string
   Serial.begin(9600);
   // (1) print the string
   Serial.println(like);
   // (2) delete part of the string
   like[13] = 0;
   Serial.println(like);
   // (3) substitute a word into the string
   like[13] = ' '; // replace the null terminator with a space
   like[18] = 't'; // insert the new word
   like[19] = 'e';
   like[20] = 'a';
   like[21] = 0; // terminate the string
   Serial.println(like);
}

void loop() {

}
</pre>
<h3>Result</h3>
<pre class="result notranslate">
I like coffee and cake
I like coffee
I like coffee and tea
</pre>
<p>The sketch works in the following way.</p>
<h3>Creating and Printing the String</h3>
<p>In the sketch given above, a new string is created and then printed for display in the Serial Monitor window.</p>
<h3>Shortening the String</h3>
<p>The string is shortened by replacing the 14th character in the string with a null terminating zero (2). This is element number 13 in the string array counting from 0.</p>
<p>When the string is printed, all the characters are printed up to the new null terminating zero. The other characters do not disappear; they still exist in the memory and the string array is still the same size. The only difference is that any function that works with strings will only see the string up to the first null terminator.</p>
<h3>Changing a Word in the String</h3>
<p>Finally, the sketch replaces the word "cake" with "tea" (3). It first has to replace the null terminator at like[13] with a space so that the string is restored to the originally created format.</p>
<p>New characters overwrite "cak" of the word "cake" with the word "tea". This is done by overwriting individual characters. The 'e' of "cake" is replaced with a new null terminating character. The result is that the string is actually terminated with two null characters, the original one at the end of the string and the new one that replaces the 'e' in "cake". This makes no difference when the new string is printed because the function that prints the string stops printing the string characters when it encounters the first null terminator.</p>
<h2>Functions to Manipulate String Arrays</h2>
<p>The previous sketch manipulated the string in a manual way by accessing individual characters in the string. To make it easier to manipulate string arrays, you can write your own functions to do so, or use some of the string functions from the <b>C</b> language library.</p>
<section class="toggle">
<label><i class="icon icon-minus"></i><i class="icon icon-plus"></i>Given below is the list Functions to Manipulate String Arrays</label>
<div class="toggle-content" style="display: none;">
<table class="table table-bordered">
<tr>
<th>S.No.</th>
<th style="text-align:center;">Functions &amp; Description</th>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">1</td>
<td>
<p><b>String()</b></p>
<p>The String class, part of the core as of version 0019, allows you to use and manipulate strings of text in more complex ways than character arrays do. You can concatenate Strings, append to them, search for and replace substrings, and more. It takes more memory than a simple character array, but it is also more useful.</p>
<p>For reference, character arrays are referred to as strings with a small ‘s’, and instances of the String class are referred to as Strings with a capital S. Note that constant strings, specified in "double quotes" are treated as char arrays, not instances of the String class</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">2</td>
<td>
<p><b>charAt()</b></p>
<p>Access a particular character of the String.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">3</td>
<td>
<p><b>compareTo()</b></p>
<p>Compares two Strings, testing whether one comes before or after the other, or whether they are equal. The strings are compared character by character, using the ASCII values of the characters. That means, for example, 'a' comes before 'b' but after 'A'. Numbers come before letters.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">4</td>
<td>
<p><b>concat()</b></p>
<p>Appends the parameter to a String.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">5</td>
<td>
<p><b>c_str()</b></p>
<p>Converts the contents of a string as a C-style, null-terminated string. Note that this gives direct access to the internal String buffer and should be used with care. In particular, you should never modify the string through the pointer returned. When you modify the String object, or when it is destroyed, any pointer previously returned by c_str() becomes invalid and should not be used any longer.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">6</td>
<td>
<p><b>endsWith()</b></p>
<p>Tests whether or not a String ends with the characters of another String.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">7</td>
<td>
<p><b>equals()</b></p>
<p>Compares two strings for equality. The comparison is case-sensitive, meaning the String "hello" is not equal to the String "HELLO".</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">8</td>
<td>
<p><b>equalsIgnoreCase()</b></p>
<p>Compares two strings for equality. The comparison is not case-sensitive, meaning the String("hello") is equal to the String("HELLO").</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">9</td>
<td>
<p><b>getBytes()</b></p>
<p>Copies the string's characters to the supplied buffer.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">10</td>
<td>
<p><b>indexOf()</b></p>
<p>Locates a character or String within another String. By default, it searches from the beginning of the String, but can also start from a given index, allowing to locate all instances of the character or String.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">11</td>
<td>
<p><b>lastIndexOf()</b></p>
<p>Locates a character or String within another String. By default, it searches from the end of the String, but can also work backwards from a given index, allowing to locate all instances of the character or String.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">12</td>
<td>
<p><b>length()</b></p>
<p>Returns the length of the String, in characters. (Note that this does not include a trailing null character.)</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">13</td>
<td>
<p><b>remove()</b></p>
<p>Modify in place, a string removing chars from the provided index to the end of the string or from the provided index to index plus count.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">14</td>
<td>
<p><b>replace()</b></p>
<p>The String replace() function allows you to replace all instances of a given character with another character. You can also use replace to replace substrings of a string with a different substring.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">15</td>
<td>
<p><b>reserve()</b></p>
<p>The String reserve() function allows you to allocate a buffer in memory for manipulating strings.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">16</td>
<td>
<p><b>setCharAt()</b></p>
<p>Sets a character of the String. Has no effect on indices outside the existing length of the String.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">17</td>
<td>
<p><b>startsWith()</b></p>
<p>Tests whether or not a String starts with the characters of another String.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">18</td>
<td>
<p><b>toCharArray()</b></p>
<p>Copies the string's characters to the supplied buffer.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">19</td>
<td>
<p><b>substring()</b></p>
<p>Get a substring of a String. The starting index is inclusive (the corresponding character is included in the substring), but the optional ending index is exclusive (the corresponding character is not included in the substring). If the ending index is omitted, the substring continues to the end of the String.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">20</td>
<td>
<p><b>toInt()</b></p>
<p>Converts a valid String to an integer. The input string should start with an integer number. If the string contains non-integer numbers, the function will stop performing the conversion.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">21</td>
<td>
<p><b>toFloat()</b></p>
<p>Converts a valid String to a float. The input string should start with a digit. If the string contains non-digit characters, the function will stop performing the conversion. For example, the strings "123.45", "123", and "123fish" are converted to 123.45, 123.00, and 123.00 respectively. Note that "123.456" is approximated with 123.46. Note too that floats have only 6-7 decimal digits of precision and that longer strings might be truncated.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">22</td>
<td>
<p><b>toLowerCase()</b></p>
<p>Get a lower-case version of a String. As of 1.0, toLowerCase() modifies the string in place rather than returning a new.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">23</td>
<td>
<p><b>toUpperCase()</b></p>
<p>Get an upper-case version of a String. As of 1.0, toUpperCase() modifies the string in place rather than returning a new one.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">24</td>
<td>
<p><b>trim()</b></p>
<p>Get a version of the String with any leading and trailing whitespace removed. As of 1.0, trim() modifies the string in place rather than returning a new one.</p>
</td>
</tr>
</table>
</div>
</section>
<p>The next sketch uses some C string functions.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
void setup() {
   char str[] = "This is my string"; // create a string
   char out_str[40]; // output from string functions placed here
   int num; // general purpose integer
   Serial.begin(9600);

   // (1) print the string
   Serial.println(str);

   // (2) get the length of the string (excludes null terminator)
   num = strlen(str);
   Serial.print("String length is: ");
   Serial.println(num);

   // (3) get the length of the array (includes null terminator)
   num = sizeof(str); // sizeof() is not a C string function
   Serial.print("Size of the array: ");
   Serial.println(num);

   // (4) copy a string
   strcpy(out_str, str);
   Serial.println(out_str);

   // (5) add a string to the end of a string (append)
   strcat(out_str, " sketch.");
   Serial.println(out_str);
   num = strlen(out_str);
   Serial.print("String length is: ");
   Serial.println(num);
   num = sizeof(out_str);
   Serial.print("Size of the array out_str[]: ");
   Serial.println(num);
}

void loop() {

}
</pre>
<h3>Result</h3>
<pre class="result notranslate">
This is my string
String length is: 17
Size of the array: 18
This is my string
This is my string sketch.
String length is: 25
Size of the array out_str[]: 40
</pre>

<title>Arduino String Object</title>

<h1>Arduino - String Object</h1>

<p>The second type of string used in Arduino programming is the String Object.</p>

<h2>What is an Object?</h2>

<p>An object is a construct that contains both data and functions. A String object can be created just like a variable and assigned a value or string. The String object contains functions (which are called "methods" in object oriented programming (OOP)) which operate on the string data contained in the String object.</p>

<p>The following sketch and explanation will make it clear what an object is and how the String object is used.</p>

<h3>Example</h3>

<h3>Result</h3>

<p>A string object is created and assigned a value (or string) at the top of the sketch.</p>

<p>This creates a String object with the name <b>my_str</b> and gives it a value of "This is my string.".</p>

<p>This can be compared to creating a variable and assigning a value to it such as an integer &minus;</p>

<p>The sketch works in the following way.</p>

<h3>Printing the String</h3>

<p>The string can be printed to the Serial Monitor window just like a character array string.</p>

<h3>Convert the String to Upper-case</h3>

<p>The string object my_str that was created, has a number of functions or methods that can be operated on it. These methods are invoked by using the objects name followed by the dot operator (.) and then the name of the function to use.</p>

<p>The <b>toUpperCase()</b> function operates on the string contained in the <b>my_str</b> object which is of type String and converts the string data (or text) that the object contains to upper-case characters. A list of the functions that the String class contains can be found in the Arduino String reference. Technically, String is called a class and is used to create String objects.</p>

<h3>Overwrite a String</h3>

<p>The assignment operator is used to assign a new string to the <b>my_str</b> object that replaces the old string</p>

<p>The assignment operator cannot be used on character array strings, but works on String objects only.</p>

<h3>Replacing a Word in the String</h3>

<p>The replace() function is used to replace the first string passed to it by the second string passed to it. replace() is another function that is built into the String class and so is available to use on the String object my_str.</p>

<h3>Getting the Length of the String</h3>

<p>Getting the length of the string is easily done by using length(). In the example sketch, the result returned by length() is passed directly to Serial.println() without using an intermediate variable.</p>

<h2>When to Use a String Object</h2>

<p>A String object is much easier to use than a string character array. The object has built-in functions that can perform a number of operations on strings.</p>

<p>The main disadvantage of using the String object is that it uses a lot of memory and can quickly use up the Arduinos RAM memory, which may cause Arduino to hang, crash or behave unexpectedly. If a sketch on an Arduino is small and limits the use of objects, then there should be no problems.</p>

<p>Character array strings are more difficult to use and you may need to write your own functions to operate on these types of strings. The advantage is that you have control on the size of the string arrays that you make, so you can keep the arrays small to save memory.</p>

<p>You need to make sure that you do not write beyond the end of the array bounds with string arrays. The String object does not have this problem and will take care of the string bounds for you, provided there is enough memory for it to operate on. The String object can try to write to memory that does not exist when it runs out of memory, but will never write over the end of the string that it is operating on.</p>

<h3>Where Strings are Used</h3>

<p>In this chapter we studied about the strings, how they behave in memory and their operations.</p>

<p>The practical uses of strings will be covered in the next part of this course when we study how to get user input from the Serial Monitor window and save the input in a string.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
void setup() { 
   String my_str = "This is my string.";
   Serial.begin(9600);

   // (1) print the string
   Serial.println(my_str);

   // (2) change the string to upper-case
   my_str.toUpperCase();
   Serial.println(my_str);

   // (3) overwrite the string
   my_str = "My new string.";
   Serial.println(my_str);

   // (4) replace a word in the string
   my_str.replace("string", "Arduino sketch");
   Serial.println(my_str);

   // (5) get the length of the string
   Serial.print("String length is: ");
   Serial.println(my_str.length());
}

void loop() { 

}
</pre>
<h3>Result</h3>
<pre class="result notranslate">
This is my string.
THIS IS MY STRING.
My new string.
My new Arduino sketch.
String length is: 22
</pre>
<p>A string object is created and assigned a value (or string) at the top of the sketch.</p>
<pre class="result notranslate">
String my_str = "This is my string." ;
</pre>
<p>This creates a String object with the name <b>my_str</b> and gives it a value of "This is my string.".</p>
<p>This can be compared to creating a variable and assigning a value to it such as an integer &minus;</p>
<pre class="result notranslate">
int my_var = 102;
</pre>
<p>The sketch works in the following way.</p>
<h3>Printing the String</h3>
<p>The string can be printed to the Serial Monitor window just like a character array string.</p>
<h3>Convert the String to Upper-case</h3>
<p>The string object my_str that was created, has a number of functions or methods that can be operated on it. These methods are invoked by using the objects name followed by the dot operator (.) and then the name of the function to use.</p>
<pre class="result notranslate">
my_str.toUpperCase();
</pre>
<p>The <b>toUpperCase()</b> function operates on the string contained in the <b>my_str</b> object which is of type String and converts the string data (or text) that the object contains to upper-case characters. A list of the functions that the String class contains can be found in the Arduino String reference. Technically, String is called a class and is used to create String objects.</p>
<h3>Overwrite a String</h3>
<p>The assignment operator is used to assign a new string to the <b>my_str</b> object that replaces the old string</p>
<pre class="result notranslate">
my_str = "My new string." ;
</pre>

<title>Arduino Time</title>

<h1>Arduino - Time</h1>

<p>Arduino provides four different time manipulation functions. They are &minus;</p>

<p><a href="/arduino/arduino_delay_function.htm">delay () function</a></p>

<p>The way the <b>delay()</b> function works is pretty simple. It accepts a single integer (or number) argument. This number represents the time (measured in milliseconds).</p>

<p><a href="/arduino/arduino_delaymicroseconds_function.htm">delayMicroseconds () function</a></p>

<p>The <b>delayMicroseconds()</b> function accepts a single integer (or number) argument. There are a thousand microseconds in a millisecond, and a million microseconds in a second.</p>

<p><a href="/arduino/arduino_millis_function.htm">millis () function</a></p>

<p>This function is used to return the number of milliseconds at the time, the Arduino board begins running the current program.</p>

<p><a href="/arduino/arduino_micros_function.htm">micros () function</a></p>

<p>The micros() function returns the number of microseconds from the time, the Arduino board begins running the current program. This number overflows i.e. goes back to zero after approximately 70 minutes.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Arduino Arrays</title>

<h1>Arduino - Arrays</h1>

<p>An array is a consecutive group of memory locations that are of the same type. To refer to a particular location or element in the array, we specify the name of the array and the position number of the particular element in the array.</p>

<p>The illustration given below shows an integer array called C that contains 11 elements. You refer to any one of these elements by giving the array name followed by the particular element’s position number in square brackets ([]). The position number is more formally called a subscript or index (this number specifies the number of elements from the beginning of the array). The first element has subscript 0 (zero) and is sometimes called the zeros element.</p>

<p>Thus, the elements of array C are C[0] (pronounced “C sub zero”), C[1], C[2] and so on. The highest subscript in array C is 10, which is 1 less than the number of elements in the array (11). Array names follow the same conventions as other variable names.</p>

<p>A subscript must be an integer or integer expression (using any integral type). If a program uses an expression as a subscript, then the program evaluates the expression to determine the subscript. For example, if we assume that variable a is equal to 5 and that variable b is equal to 6, then the statement adds 2 to array element C[11].</p>

<p>A subscripted array name is an lvalue, it can be used on the left side of an assignment, just as non-array variable names can.</p>

<p>Let us examine array C in the given figure, more closely. The name of the entire array is C. Its 11 elements are referred to as C[0] to C[10]. The value of C[0] is -45, the value of C[1] is 6, the value of C[2] is 0, the value of C[7] is 62, and the value of C[10] is 78.</p>

<p>To print the sum of the values contained in the first three elements of array C, we would write &minus;</p>

<p>To divide the value of C[6] by 2 and assign the result to the variable x, we would write &minus;</p>

<h2>Declaring Arrays</h2>

<p>Arrays occupy space in memory. To specify the type of the elements and the number of elements required by an array, use a declaration of the form &minus;</p>

<p>The compiler reserves the appropriate amount of memory. (Recall that a declaration, which reserves memory is more properly known as a definition). The arraySize must be an integer constant greater than zero. For example, to tell the compiler to reserve 11 elements for integer array C, use the declaration &minus;</p>

<p>Arrays can be declared to contain values of any non-reference data type. For example, an array of type string can be used to store character strings.</p>

<h2>Examples Using Arrays</h2>

<p>This section gives many examples that demonstrate how to declare, initialize and manipulate arrays.</p>

<h3>Example 1: Declaring an Array and using a Loop to Initialize the Array’s Elements</h3>

<p>The program declares a 10-element integer array <b>n</b>. Lines a–b use a <b>For</b> statement to initialize the array elements to zeros. Like other automatic variables, automatic arrays are not implicitly initialized to zero. The first output statement (line c) displays the column headings for the columns printed in the subsequent for statement (lines d–e), which prints the array in tabular format.</p>

<p><b>Example</b></p>

<p><b>Result</b> &minus; It will produce the following result &minus;</p>

<h3>Example 2: Initializing an Array in a Declaration with an Initializer List</h3>

<p>The elements of an array can also be initialized in the array declaration by following the array name with an equal-to sign and a brace-delimited comma-separated list of initializers. The program uses an initializer list to initialize an integer array with 10 values (line a) and prints the array in tabular format (lines b–c).</p>

<p><b>Example</b></p>

<p><b>Result</b> &minus; It will produce the following result &minus;</p>

<h3>Example 3: Summing the Elements of an Array</h3>

<p>Often, the elements of an array represent a series of values to be used in a calculation. For example, if the elements of an array represent exam grades, a professor may wish to total the elements of the array and use that sum to calculate the class average for the exam. The program sums the values contained in the 10-element integer array <b>a</b>.</p>

<p><b>Example</b></p>

<p><b>Result</b> &minus; It will produce the following result &minus;</p>

<p>Arrays are important to Arduino and should need a lot more attention. The following important concepts related to array should be clear to a Arduino &minus;</p>

<p>To pass an array argument to a function, specify the name of the array without any brackets.</p>

<p>Arrays with two dimensions (i.e., subscripts) often represent tables of values consisting of information arranged in rows and columns.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
Serial.print (C[ 0 ] + C[ 1 ] + C[ 2 ] );
</pre>
<p>To divide the value of C[6] by 2 and assign the result to the variable x, we would write &minus;</p>
<pre class="result notranslate">
x = C[ 6 ] / 2;
</pre>
<h2>Declaring Arrays</h2>
<p>Arrays occupy space in memory. To specify the type of the elements and the number of elements required by an array, use a declaration of the form &minus;</p>
<pre class="result notranslate">
type arrayName [ arraySize ] ;
</pre>
<p>The compiler reserves the appropriate amount of memory. (Recall that a declaration, which reserves memory is more properly known as a definition). The arraySize must be an integer constant greater than zero. For example, to tell the compiler to reserve 11 elements for integer array C, use the declaration &minus;</p>
<pre class="result notranslate">
int C[ 12 ]; // C is an array of 12 integers
</pre>
<p>Arrays can be declared to contain values of any non-reference data type. For example, an array of type string can be used to store character strings.</p>
<h2>Examples Using Arrays</h2>
<p>This section gives many examples that demonstrate how to declare, initialize and manipulate arrays.</p>
<h3>Example 1: Declaring an Array and using a Loop to Initialize the Array’s Elements</h3>
<p>The program declares a 10-element integer array <b>n</b>. Lines a–b use a <b>For</b> statement to initialize the array elements to zeros. Like other automatic variables, automatic arrays are not implicitly initialized to zero. The first output statement (line c) displays the column headings for the columns printed in the subsequent for statement (lines d–e), which prints the array in tabular format.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
int n[ 10 ] ; // n is an array of 10 integers

void setup () {

}

void loop () {
   for ( int i = 0; i &lt; 10; ++i ) // initialize elements of array n to 0 {
      n[ i ] = 0; // set element at location i to 0
      Serial.print (i) ;
      Serial.print (‘\r’) ;
   }
   for ( int j = 0; j &lt; 10; ++j ) // output each array element's value {
      Serial.print (n[j]) ;
      Serial.print (‘\r’) ;
   } 
}
</pre>
<p><b>Result</b> &minus; It will produce the following result &minus;</p>
<pre class="result notranslate">
<table class="table table-bordered" style="width:40% !important; margin:auto;" >
<tr>
<th style="text-align:center;">Element</th>
<th style="text-align:center;">Value</th>
</tr>
<tr>
<td>
<p class="ex1" style="text-align:center;">0</p>
<p class="ex1" style="text-align:center;">1</p>
<p class="ex1" style="text-align:center;">2</p>
<p class="ex1" style="text-align:center;">3</p>
<p class="ex1" style="text-align:center;">4</p>
<p class="ex1" style="text-align:center;">5</p>
<p class="ex1" style="text-align:center;">6</p>
<p class="ex1" style="text-align:center;">7</p>
<p class="ex1" style="text-align:center;">8</p>
<p class="ex1" style="text-align:center;">9</p>
</td>
<td>
<p class="ex1" style="text-align:center;">0</p>
<p class="ex1" style="text-align:center;">0</p>
<p class="ex1" style="text-align:center;">0</p>
<p class="ex1" style="text-align:center;">0</p>
<p class="ex1" style="text-align:center;">0</p>
<p class="ex1" style="text-align:center;">0</p>
<p class="ex1" style="text-align:center;">0</p>
<p class="ex1" style="text-align:center;">0</p>
<p class="ex1" style="text-align:center;">0</p>
<p class="ex1" style="text-align:center;">0</p>
</td>
</tr>
</table>
</pre>
<h3>Example 2: Initializing an Array in a Declaration with an Initializer List</h3>
<p>The elements of an array can also be initialized in the array declaration by following the array name with an equal-to sign and a brace-delimited comma-separated list of initializers. The program uses an initializer list to initialize an integer array with 10 values (line a) and prints the array in tabular format (lines b–c).</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
// n is an array of 10 integers
int n[ 10 ] = { 32, 27, 64, 18, 95, 14, 90, 70, 60, 37 } ;

void setup () {

}

void loop () {
   for ( int i = 0; i &lt; 10; ++i ) // initialize elements of array n to 0 {
      Serial.print (i) ;
      Serial.print (‘\r’) ;
   }
   for ( int j = 0; j &lt; 10; ++j ) // output each array element's value {
      Serial.print (n[j]) ;
      Serial.print (‘\r’) ;
   } 
}
</pre>
<p><b>Result</b> &minus; It will produce the following result &minus;</p>
<pre class="result notranslate">
<table class="table table-bordered" style="width:40% !important; margin:auto;" >
<tr>
<th style="text-align:center;">Element</th>
<th style="text-align:center;">Value</th>
</tr>
<tr>
<td>
<p class="ex1" style="text-align:center;">0</p>
<p class="ex1" style="text-align:center;">1</p>
<p class="ex1" style="text-align:center;">2</p>
<p class="ex1" style="text-align:center;">3</p>
<p class="ex1" style="text-align:center;">4</p>
<p class="ex1" style="text-align:center;">5</p>
<p class="ex1" style="text-align:center;">6</p>
<p class="ex1" style="text-align:center;">7</p>
<p class="ex1" style="text-align:center;">8</p>
<p class="ex1" style="text-align:center;">9</p>
</td>
<td>
<p class="ex1" style="text-align:center;">32</p>
<p class="ex1" style="text-align:center;">27</p>
<p class="ex1" style="text-align:center;">64</p>
<p class="ex1" style="text-align:center;">18</p>
<p class="ex1" style="text-align:center;">95</p>
<p class="ex1" style="text-align:center;">14</p>
<p class="ex1" style="text-align:center;">90</p>
<p class="ex1" style="text-align:center;">70</p>
<p class="ex1" style="text-align:center;">60</p>
<p class="ex1" style="text-align:center;">37</p>
</td>
</tr>
</table>
</pre>
<h3>Example 3: Summing the Elements of an Array</h3>
<p>Often, the elements of an array represent a series of values to be used in a calculation. For example, if the elements of an array represent exam grades, a professor may wish to total the elements of the array and use that sum to calculate the class average for the exam. The program sums the values contained in the 10-element integer array <b>a</b>.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
const int arraySize = 10; // constant variable indicating size of array
int a[ arraySize ] = { 87, 68, 94, 100, 83, 78, 85, 91, 76, 87 };
int total = 0;

void setup () {

}
void loop () {
   // sum contents of array a
   for ( int i = 0; i &lt; arraySize; ++i )
      total += a[ i ];
   Serial.print (“Total of array elements : ”) ;
   Serial.print(total) ;
}
</pre>
<p><b>Result</b> &minus; It will produce the following result &minus;</p>
<pre class="result notranslate">
Total of array elements: 849
</pre>

<title>Arduino I/O Functions</title>

<h1>Arduino - I/O Functions</h1>

<p>The pins on the Arduino board can be configured as either inputs or outputs. We will explain the functioning of the pins in those modes. It is important to note that a majority of Arduino analog pins, may be configured, and used, in exactly the same manner as digital pins.</p>

<h2>Pins Configured as INPUT</h2>

<p>Arduino pins are by default configured as inputs, so they do not need to be explicitly declared as inputs with <b>pinMode()</b> when you are using them as inputs. Pins configured this way are said to be in a high-impedance state. Input pins make extremely small demands on the circuit that they are sampling, equivalent to a series resistor of 100 megaohm in front of the pin.</p>

<p>This means that it takes very little current to switch the input pin from one state to another. This makes the pins useful for such tasks as implementing a capacitive touch sensor or reading an LED as a photodiode.</p>

<p>Pins configured as pinMode(pin, INPUT) with nothing connected to them, or with wires connected to them that are not connected to other circuits, report seemingly random changes in pin state, picking up electrical noise from the environment, or capacitively coupling the state of a nearby pin.</p>

<h2>Pull-up Resistors</h2>

<p>Pull-up resistors are often useful to steer an input pin to a known state if no input is present. This can be done by adding a pull-up resistor (to &plus;5V), or a pull-down resistor (resistor to ground) on the input. A 10K resistor is a good value for a pull-up or pull-down resistor.</p>

<h3>Using Built-in Pull-up Resistor with Pins Configured as Input</h3>

<p>There are 20,000 pull-up resistors built into the Atmega chip that can be accessed from software. These built-in pull-up resistors are accessed by setting the <b>pinMode()</b> as INPUT_PULLUP. This effectively inverts the behavior of the INPUT mode, where HIGH means the sensor is OFF and LOW means the sensor is ON. The value of this pull-up depends on the microcontroller used. On most AVR-based boards, the value is guaranteed to be between 20kΩ and 50kΩ. On the Arduino Due, it is between 50kΩ and 150kΩ. For the exact value, consult the datasheet of the microcontroller on your board.</p>

<p>When connecting a sensor to a pin configured with INPUT_PULLUP, the other end should be connected to the ground. In case of a simple switch, this causes the pin to read HIGH when the switch is open and LOW when the switch is pressed. The pull-up resistors provide enough current to light an LED dimly connected to a pin configured as an input. If LEDs in a project seem to be working, but very dimly, this is likely what is going on.</p>

<p>Same registers (internal chip memory locations) that control whether a pin is HIGH or LOW control the pull-up resistors. Consequently, a pin that is configured to have pull-up resistors turned on when the pin is in INPUTmode, will have the pin configured as HIGH if the pin is then switched to an OUTPUT mode with pinMode(). This works in the other direction as well, and an output pin that is left in a HIGH state will have the pull-up resistor set if switched to an input with pinMode().</p>

<p><b>Example</b></p>

<h2>Pins Configured as OUTPUT</h2>

<p>Pins configured as OUTPUT with pinMode() are said to be in a low-impedance state. This means that they can provide a substantial amount of current to other circuits. Atmega pins can source (provide positive current) or sink (provide negative current) up to 40 mA (milliamps) of current to other devices/circuits. This is enough current to brightly light up an LED (do not forget the series resistor), or run many sensors but not enough current to run relays, solenoids, or motors.</p>

<p>Attempting to run high current devices from the output pins, can damage or destroy the output transistors in the pin, or damage the entire Atmega chip. Often, this results in a "dead" pin in the microcontroller but the remaining chips still function adequately. For this reason, it is a good idea to connect the OUTPUT pins to other devices through 470Ω or 1k resistors, unless maximum current drawn from the pins is required for a particular application.</p>

<h2>pinMode() Function</h2>

<p>The pinMode() function is used to configure a specific pin to behave either as an input or an output. It is possible to enable the internal pull-up resistors with the mode INPUT_PULLUP. Additionally, the INPUT mode explicitly disables the internal pull-ups.</p>

<h3>pinMode() Function Syntax</h3>

<p><b>pin</b> &minus; the number of the pin whose mode you wish to set</p>

<p><b>mode</b> &minus; INPUT, OUTPUT, or INPUT_PULLUP.</p>

<p><b>Example</b></p>

<h2>digitalWrite() Function</h2>

<p>The <b>digitalWrite()</b> function is used to write a HIGH or a LOW value to a digital pin. If the pin has been configured as an OUTPUT with <a href="https://www.arduino.cc/en/Reference/PinMode" rel="nofollow" target="_blank">pinMode()</a>, its voltage will be set to the corresponding value: 5V (or 3.3V on 3.3V boards) for HIGH, 0V (ground) for LOW. If the pin is configured as an INPUT, digitalWrite() will enable (HIGH) or disable (LOW) the internal pullup on the input pin. It is recommended to set the <a href="https://www.arduino.cc/en/Reference/PinMode" rel="nofollow" target="_blank">pinMode()</a> to INPUT_PULLUP to enable the internal pull-up resistor.</p>

<p>If you do not set the pinMode() to OUTPUT, and connect an LED to a pin, when calling digitalWrite(HIGH), the LED may appear dim. Without explicitly setting pinMode(), digitalWrite() will have enabled the internal pull-up resistor, which acts like a large current-limiting resistor.</p>

<h3>digitalWrite() Function Syntax</h3>

<p><b>pin</b> &minus; the number of the pin whose mode you wish to set</p>

<p><b>value</b> &minus; HIGH, or LOW.</p>

<p><b>Example</b></p>

<h2>analogRead( ) function</h2>

<p>Arduino is able to detect whether there is a voltage applied to one of its pins and report it through the digitalRead() function. There is a difference between an on/off sensor (which detects the presence of an object) and an analog sensor, whose value continuously changes. In order to read this type of sensor, we need a different type of pin.</p>

<p>In the lower-right part of the Arduino board, you will see six pins marked “Analog In”. These special pins not only tell whether there is a voltage applied to them, but also its value. By using the <b>analogRead()</b> function, we can read the voltage applied to one of the pins.</p>

<p>This function returns a number between 0 and 1023, which represents voltages between 0 and 5 volts. For example, if there is a voltage of 2.5 V applied to pin number 0, analogRead(0) returns 512.</p>

<h3>analogRead() function Syntax</h3>

<p><b>pin</b> &minus; the number of the analog input pin to read from (0 to 5 on most boards, 0 to 7 on the Mini and Nano, 0 to 15 on the Mega)</p>

<p><b>Example</b></p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
pinMode(3,INPUT) ; // set pin to input without using built in pull up resistor
pinMode(5,INPUT_PULLUP) ; // set pin to input using built in pull up resistor
</pre>
<h2>Pins Configured as OUTPUT</h2>
<p>Pins configured as OUTPUT with pinMode() are said to be in a low-impedance state. This means that they can provide a substantial amount of current to other circuits. Atmega pins can source (provide positive current) or sink (provide negative current) up to 40 mA (milliamps) of current to other devices/circuits. This is enough current to brightly light up an LED (do not forget the series resistor), or run many sensors but not enough current to run relays, solenoids, or motors.</p>
<p>Attempting to run high current devices from the output pins, can damage or destroy the output transistors in the pin, or damage the entire Atmega chip. Often, this results in a "dead" pin in the microcontroller but the remaining chips still function adequately. For this reason, it is a good idea to connect the OUTPUT pins to other devices through 470Ω or 1k resistors, unless maximum current drawn from the pins is required for a particular application.</p>
<h2>pinMode() Function</h2>
<p>The pinMode() function is used to configure a specific pin to behave either as an input or an output. It is possible to enable the internal pull-up resistors with the mode INPUT_PULLUP. Additionally, the INPUT mode explicitly disables the internal pull-ups.</p>
<h3>pinMode() Function Syntax</h3>
<pre class="result notranslate">
Void setup () {
   pinMode (pin , mode);
}
</pre>
<ul class="list">
<li><p><b>pin</b> &minus; the number of the pin whose mode you wish to set</p></li>
<li><p><b>mode</b> &minus; INPUT, OUTPUT, or INPUT_PULLUP.</p></li>
</ul>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
int button = 5 ; // button connected to pin 5
int LED = 6; // LED connected to pin 6

void setup () {
   pinMode(button , INPUT_PULLUP); 
   // set the digital pin as input with pull-up resistor
   pinMode(button , OUTPUT); // set the digital pin as output
}

void setup () {
   If (digitalRead(button ) == LOW) // if button pressed {
      digitalWrite(LED,HIGH); // turn on led
      delay(500); // delay for 500 ms
      digitalWrite(LED,LOW); // turn off led
      delay(500); // delay for 500 ms
   }
}
</pre>
<h2>digitalWrite() Function</h2>
<p>The <b>digitalWrite()</b> function is used to write a HIGH or a LOW value to a digital pin. If the pin has been configured as an OUTPUT with <a href="https://www.arduino.cc/en/Reference/PinMode" rel="nofollow" target="_blank">pinMode()</a>, its voltage will be set to the corresponding value: 5V (or 3.3V on 3.3V boards) for HIGH, 0V (ground) for LOW. If the pin is configured as an INPUT, digitalWrite() will enable (HIGH) or disable (LOW) the internal pullup on the input pin. It is recommended to set the <a href="https://www.arduino.cc/en/Reference/PinMode" rel="nofollow" target="_blank">pinMode()</a> to INPUT_PULLUP to enable the internal pull-up resistor.</p>
<p>If you do not set the pinMode() to OUTPUT, and connect an LED to a pin, when calling digitalWrite(HIGH), the LED may appear dim. Without explicitly setting pinMode(), digitalWrite() will have enabled the internal pull-up resistor, which acts like a large current-limiting resistor.</p>
<h3>digitalWrite() Function Syntax</h3>
<pre class="result notranslate">
Void loop() {
   digitalWrite (pin ,value);
}
</pre>
<ul class="list">
<li><p><b>pin</b> &minus; the number of the pin whose mode you wish to set</p></li>
<li><p><b>value</b> &minus; HIGH, or LOW.</p></li>
</ul>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
int LED = 6; // LED connected to pin 6

void setup () {
   pinMode(LED, OUTPUT); // set the digital pin as output
}

void setup () { 
   digitalWrite(LED,HIGH); // turn on led
   delay(500); // delay for 500 ms
   digitalWrite(LED,LOW); // turn off led
   delay(500); // delay for 500 ms
}
</pre>
<h2>analogRead( ) function</h2>
<p>Arduino is able to detect whether there is a voltage applied to one of its pins and report it through the digitalRead() function. There is a difference between an on/off sensor (which detects the presence of an object) and an analog sensor, whose value continuously changes. In order to read this type of sensor, we need a different type of pin.</p>
<p>In the lower-right part of the Arduino board, you will see six pins marked “Analog In”. These special pins not only tell whether there is a voltage applied to them, but also its value. By using the <b>analogRead()</b> function, we can read the voltage applied to one of the pins.</p>
<p>This function returns a number between 0 and 1023, which represents voltages between 0 and 5 volts. For example, if there is a voltage of 2.5 V applied to pin number 0, analogRead(0) returns 512.</p>
<h3>analogRead() function Syntax</h3>
<pre class="result notranslate">
analogRead(pin);
</pre>
<ul class="list">
<li><p><b>pin</b> &minus; the number of the analog input pin to read from (0 to 5 on most boards, 0 to 7 on the Mini and Nano, 0 to 15 on the Mega)</p></li>
</ul>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
int analogPin = 3;//potentiometer wiper (middle terminal) 
   // connected to analog pin 3 
int val = 0; // variable to store the value read

void setup() {
   Serial.begin(9600); // setup serial
} 

void loop() {
   val = analogRead(analogPin); // read the input pin
   Serial.println(val); // debug value
}
</pre>

<title>Arduino Advanced I/O Function</title>

<h1>Arduino - Advanced I/O Function</h1>

<p>In this chapter, we will learn some advanced Input and Output Functions.</p>

<h2>analogReference() Function</h2>

<p>Configures the reference voltage used for analog input (i.e. the value used as the top of the input range). The options are &minus;</p>

<p><b>DEFAULT</b> &minus; The default analog reference of 5 volts (on 5V Arduino boards) or 3.3 volts (on 3.3V Arduino boards)</p>

<p><b>INTERNAL</b> &minus; An built-in reference, equal to 1.1 volts on the ATmega168 or ATmega328 and 2.56 volts on the ATmega8 (not available on the Arduino Mega)</p>

<p><b>INTERNAL1V1</b> &minus; A built-in 1.1V reference (Arduino Mega only)</p>

<p><b>INTERNAL2V56</b> &minus; A built-in 2.56V reference (Arduino Mega only)</p>

<p><b>EXTERNAL</b> &minus; The voltage applied to the AREF pin (0 to 5V only) is used as the reference</p>

<h3>analogReference() Function Syntax</h3>

<p><b>type</b> &minus; can use any type of the follow (DEFAULT, INTERNAL, INTERNAL1V1, INTERNAL2V56, EXTERNAL)</p>

<p>Do not use anything less than 0V or more than 5V for external reference voltage on the AREF pin. If you are using an external reference on the AREF pin, you must set the analog reference to EXTERNAL before calling the <b>analogRead()</b> function. Otherwise, you will short the active reference voltage (internally generated) and the AREF pin, possibly damaging the microcontroller on your Arduino board.</p>

<p>Alternatively, you can connect the external reference voltage to the AREF pin through a 5K resistor, allowing you to switch between external and internal reference voltages.</p>

<p>Note that the resistor will alter the voltage that is used as the reference because there is an internal 32K resistor on the AREF pin. The two act as a voltage divider. For example, 2.5V applied through the resistor will yield 2.5 * 32 / (32 &plus; 5) = ~2.2V at the AREF pin.</p>

<p><b>Example</b></p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
analogReference (type);
</pre>
<p><b>type</b> &minus; can use any type of the follow (DEFAULT, INTERNAL, INTERNAL1V1, INTERNAL2V56, EXTERNAL)</p>
<p>Do not use anything less than 0V or more than 5V for external reference voltage on the AREF pin. If you are using an external reference on the AREF pin, you must set the analog reference to EXTERNAL before calling the <b>analogRead()</b> function. Otherwise, you will short the active reference voltage (internally generated) and the AREF pin, possibly damaging the microcontroller on your Arduino board.</p>
<img src="/arduino/images/microcontroller.jpg" alt="MicroController" />
<p>Alternatively, you can connect the external reference voltage to the AREF pin through a 5K resistor, allowing you to switch between external and internal reference voltages.</p>
<p>Note that the resistor will alter the voltage that is used as the reference because there is an internal 32K resistor on the AREF pin. The two act as a voltage divider. For example, 2.5V applied through the resistor will yield 2.5 * 32 / (32 &plus; 5) = ~2.2V at the AREF pin.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
int analogPin = 3;// potentiometer wiper (middle terminal) connected to analog pin 3 
int val = 0; // variable to store the read value

void setup() {
   Serial.begin(9600); // setup serial
   analogReference(EXTERNAL); // the voltage applied to the AREF pin (0 to 5V only) 
      // is used as the reference.
}

void loop() {
   val = analogRead(analogPin); // read the input pin
   Serial.println(val); // debug value
}
</pre>

<title>Arduino Character Functions</title>

<h1>Arduino - Character Functions</h1>

<p>All data is entered into computers as characters, which includes letters, digits and various special symbols. In this section, we discuss the capabilities of C++ for examining and manipulating individual characters.</p>

<p>The character-handling library includes several functions that perform useful tests and manipulations of character data. Each function receives a character, represented as an int, or EOF as an argument. Characters are often manipulated as integers.</p>

<p>Remember that EOF normally has the value –1 and that some hardware architectures do not allow negative values to be stored in char variables. Therefore, the character-handling functions manipulate characters as integers.</p>

<p>The following table summarizes the functions of the character-handling library. When using functions from the character-handling library, include the <b>&lt;cctype&gt;</b> header.</p>

<p><b>int isdigit( int c )</b></p>

<p>Returns 1 if c is a digit and 0 otherwise.</p>

<p><b>int isalpha( int c )</b></p>

<p>Returns 1 if c is a letter and 0 otherwise.</p>

<p><b>int isalnum( int c )</b></p>

<p>Returns 1 if c is a digit or a letter and 0 otherwise.</p>

<p><b>int isxdigit( int c )</b></p>

<p>Returns 1 if c is a hexadecimal digit character and 0 otherwise.</p>

<p>(See Appendix D, Number Systems, for a detailed explanation of binary, octal, decimal and hexadecimal numbers.)</p>

<p><b>int islower( int c )</b></p>

<p>Returns 1 if c is a lowercase letter and 0 otherwise.</p>

<p><b>int isupper( int c )</b></p>

<p>Returns 1 if c is an uppercase letter; 0 otherwise.</p>

<p><b>int isspace( int c )</b></p>

<p>Returns 1 if c is a white-space character—newline ('\n'), space</p>

<p>(' '), form feed ('\f'), carriage return ('\r'), horizontal tab ('\t'), or vertical tab ('\v')—and 0 otherwise.</p>

<p><b>int iscntrl( int c )</b></p>

<p>Returns 1 if c is a control character, such as newline ('\n'), form feed ('\f'), carriage return ('\r'), horizontal tab ('\t'), vertical tab ('\v'), alert ('\a'), or backspace ('\b')—and 0 otherwise.</p>

<p><b>int ispunct( int c )</b></p>

<p>Returns 1 if c is a printing character other than a space, a digit, or a letter and 0 otherwise.</p>

<p><b>int isprint( int c )</b></p>

<p>Returns 1 if c is a printing character including space (' ') and 0 otherwise.</p>

<p><b>int isgraph( int c )</b></p>

<p>Returns 1 if c is a printing character other than space (' ') and 0 otherwise.</p>

<h2>Examples</h2>

<p>The following example demonstrates the use of the functions <b>isdigit, isalpha, isalnum</b> and <b>isxdigit</b>. Function <b>isdigit</b> determines whether its argument is a digit (0–9). The function <b>isalpha</b> determines whether its argument is an uppercase letter (A-Z) or a lowercase letter (a–z). The function <b>isalnum</b> determines whether its argument is an uppercase, lowercase letter or a digit. Function <b>isxdigit</b> determines whether its argument is a hexadecimal digit (A–F, a–f, 0–9).</p>

<h3>Example 1</h3>

<h3>Result</h3>

<p>We use the conditional operator <b>(?:)</b> with each function to determine whether the string " is a " or the string " is not a " should be printed in the output for each character tested. For example, line <b>a</b> indicates that if '8' is a digit—i.e., if <b>isdigit</b> returns a true (nonzero) value—the string "8 is a " is printed. If '8' is not a digit (i.e., if <b>isdigit</b> returns 0), the string " 8 is not a " is printed.</p>

<h3>Example 2</h3>

<p>The following example demonstrates the use of the functions <b>islower</b> and <b>isupper</b>. The function <b>islower</b> determines whether its argument is a lowercase letter (a–z). Function <b>isupper</b> determines whether its argument is an uppercase letter (A–Z).</p>

<h3>Result</h3>

<h3>Example 3</h3>

<p>The following example demonstrates the use of functions <b>isspace, iscntrl, ispunct, isprint</b> and <b>isgraph</b>.</p>

<p>The function <b>isspace</b> determines whether its argument is a white-space character, such as space (' '), form feed ('\f'), newline ('\n'), carriage return ('\r'), horizontal tab ('\t') or vertical tab ('\v').</p>

<p>The function <b>iscntrl</b> determines whether its argument is a control character such as horizontal tab ('\t'), vertical tab ('\v'), form feed ('\f'), alert ('\a'), backspace ('\b'), carriage return ('\r') or newline ('\n').</p>

<p>The function <b>ispunct</b> determines whether its argument is a printing character other than a space, digit or letter, such as $, #, (, ), [, ], {, }, ;, : or %.</p>

<p>The function <b>isprint</b> determines whether its argument is a character that can be displayed on the screen (including the space character).</p>

<p>The function <b>isgraph</b> tests for the same characters as isprint, but the space character is not included.</p>

<h3>Result</h3>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
void setup () {
   Serial.begin (9600);
   Serial.print ("According to isdigit:\r");
   Serial.print (isdigit( '8' ) ? "8 is a": "8 is not a");
   Serial.print (" digit\r" );
   Serial.print (isdigit( '8' ) ?"# is a": "# is not a") ;
   Serial.print (" digit\r");
   Serial.print ("\rAccording to isalpha:\r" );
   Serial.print (isalpha('A' ) ?"A is a": "A is not a");
   Serial.print (" letter\r");
   Serial.print (isalpha('A' ) ?"b is a": "b is not a");
   Serial.print (" letter\r");
   Serial.print (isalpha('A') ?"&amp; is a": "&amp; is not a");
   Serial.print (" letter\r");
   Serial.print (isalpha( 'A' ) ?"4 is a":"4 is not a");
   Serial.print (" letter\r");
   Serial.print ("\rAccording to isalnum:\r");
   Serial.print (isalnum( 'A' ) ?"A is a" : "A is not a" );

   Serial.print (" digit or a letter\r" );
   Serial.print (isalnum( '8' ) ?"8 is a" : "8 is not a" ) ;
   Serial.print (" digit or a letter\r");
   Serial.print (isalnum( '#' ) ?"# is a" : "# is not a" );
   Serial.print (" digit or a letter\r");
   Serial.print ("\rAccording to isxdigit:\r");
   Serial.print (isxdigit( 'F' ) ?"F is a" : "F is not a" );
   Serial.print (" hexadecimal digit\r" );
   Serial.print (isxdigit( 'J' ) ?"J is a" : "J is not a" ) ;
   Serial.print (" hexadecimal digit\r" );
   Serial.print (isxdigit( '7' ) ?"7 is a" : "7 is not a" ) ;

   Serial.print (" hexadecimal digit\r" );
   Serial.print (isxdigit( '$' ) ? "$ is a" : "$ is not a" );
   Serial.print (" hexadecimal digit\r" );
   Serial.print (isxdigit( 'f' ) ? “f is a" : "f is not a");
   <!--Serial.print (" hexadecimal digit\r" );-->
}

void loop () {

}
</pre>
<h3>Result</h3>
<pre class="result notranslate">
According to isdigit:
8 is a digit
# is not a digit
According to isalpha:
A is a letter
b is a letter
&amp; is not a letter
4 is not a letter
According to isalnum:
A is a digit or a letter

8 is a digit or a letter
# is not a digit or a letter
According to isxdigit:
F is a hexadecimal digit
J is not a hexadecimal digit
7 is a hexadecimal digit

$ is not a hexadecimal digit
f is a hexadecimal digit
</pre>
<p>We use the conditional operator <b>(?:)</b> with each function to determine whether the string " is a " or the string " is not a " should be printed in the output for each character tested. For example, line <b>a</b> indicates that if '8' is a digit—i.e., if <b>isdigit</b> returns a true (nonzero) value—the string "8 is a " is printed. If '8' is not a digit (i.e., if <b>isdigit</b> returns 0), the string " 8 is not a " is printed.</p>
<h3>Example 2</h3>
<p>The following example demonstrates the use of the functions <b>islower</b> and <b>isupper</b>. The function <b>islower</b> determines whether its argument is a lowercase letter (a–z). Function <b>isupper</b> determines whether its argument is an uppercase letter (A–Z).</p>
<pre class="prettyprint notranslate">
int thisChar = 0xA0;

void setup () {
   Serial.begin (9600);
   Serial.print ("According to islower:\r") ;
   Serial.print (islower( 'p' ) ? "p is a" : "p is not a" );
   Serial.print ( " lowercase letter\r" );
   Serial.print ( islower( 'P') ? "P is a" : "P is not a") ;
   Serial.print ("lowercase letter\r");
   Serial.print (islower( '5' ) ? "5 is a" : "5 is not a" );
   Serial.print ( " lowercase letter\r" );
   Serial.print ( islower( '!' )? "! is a" : "! is not a") ;
   Serial.print ("lowercase letter\r");

   Serial.print ("\rAccording to isupper:\r") ;
   Serial.print (isupper ( 'D' ) ? "D is a" : "D is not an" );
   Serial.print ( " uppercase letter\r" );
   Serial.print ( isupper ( 'd' )? "d is a" : "d is not an") ;
   Serial.print ( " uppercase letter\r" );
   Serial.print (isupper ( '8' ) ? "8 is a" : "8 is not an" );
   Serial.print ( " uppercase letter\r" );
   Serial.print ( islower( '$' )? "$ is a" : "$ is not an") ;
   Serial.print ("uppercase letter\r ");
}

void setup () {

}
</pre>
<h3>Result</h3>
<pre class="result notranslate">
According to islower:
p is a lowercase letter
P is not a lowercase letter
5 is not a lowercase letter
! is not a lowercase letter

According to isupper:
D is an uppercase letter
d is not an uppercase letter
8 is not an uppercase letter
$ is not an uppercase letter
</pre>
<h3>Example 3</h3>
<p>The following example demonstrates the use of functions <b>isspace, iscntrl, ispunct, isprint</b> and <b>isgraph</b>.</p>
<ul class="list">
<li><p>The function <b>isspace</b> determines whether its argument is a white-space character, such as space (' '), form feed ('\f'), newline ('\n'), carriage return ('\r'), horizontal tab ('\t') or vertical tab ('\v').</p></li>
<li><p>The function <b>iscntrl</b> determines whether its argument is a control character such as horizontal tab ('\t'), vertical tab ('\v'), form feed ('\f'), alert ('\a'), backspace ('\b'), carriage return ('\r') or newline ('\n').</p></li>
<li><p>The function <b>ispunct</b> determines whether its argument is a printing character other than a space, digit or letter, such as $, #, (, ), [, ], {, }, ;, : or %.</p></li>
<li><p>The function <b>isprint</b> determines whether its argument is a character that can be displayed on the screen (including the space character).</p></li>
<li><p>The function <b>isgraph</b> tests for the same characters as isprint, but the space character is not included.</p></li>
</ul>
<pre class="prettyprint notranslate">
void setup () {
   Serial.begin (9600);
   Serial.print ( " According to isspace:\rNewline ") ;
   Serial.print (isspace( '\n' )? " is a" : " is not a" );
   Serial.print ( " whitespace character\rHorizontal tab") ;
   Serial.print (isspace( '\t' )? " is a" : " is not a" );
   Serial.print ( " whitespace character\n") ;
   Serial.print (isspace('%')? " % is a" : " % is not a" );
   
   Serial.print ( " \rAccording to iscntrl:\rNewline") ;
   Serial.print ( iscntrl( '\n' )?"is a" : " is not a" ) ;
   Serial.print (" control character\r");
   Serial.print (iscntrl( '$' ) ? " $ is a" : " $ is not a" );
   Serial.print (" control character\r");
   Serial.print ("\rAccording to ispunct:\r");
   Serial.print (ispunct(';' ) ?"; is a" : "; is not a" ) ;
   Serial.print (" punctuation character\r");
   Serial.print (ispunct('Y' ) ?"Y is a" : "Y is not a" ) ;
   Serial.print ("punctuation character\r");
   Serial.print (ispunct('#' ) ?"# is a" : "# is not a" ) ;
   Serial.print ("punctuation character\r");

   Serial.print ( "\r According to isprint:\r");
   Serial.print (isprint('$' ) ?"$ is a" : "$ is not a" );
   Serial.print (" printing character\rAlert ");
   Serial.print (isprint('\a' ) ?" is a" : " is not a" );
   Serial.print (" printing character\rSpace ");
   Serial.print (isprint(' ' ) ?" is a" : " is not a" );
   Serial.print (" printing character\r");
   
   Serial.print ("\r According to isgraph:\r");
   Serial.print (isgraph ('Q' ) ?"Q is a" : "Q is not a" );
   Serial.print ("printing character other than a space\rSpace ");
   Serial.print (isgraph (' ') ?" is a" : " is not a" );
   Serial.print ("printing character other than a space ");
}

void loop () {

}
</pre>
<h3>Result</h3>
<pre class="result notranslate">
According to isspace:
Newline is a whitespace character
Horizontal tab is a whitespace character
% is not a whitespace character
According to iscntrl:
Newline is a control character
$ is not a control character
According to ispunct:
; is a punctuation character
Y is not a punctuation character
# is a punctuation character
According to isprint:
$ is a printing character
Alert is not a printing character
Space is a printing character
According to isgraph:
Q is a printing character other than a space
Space is not a printing character other than a space
</pre>

<title>Arduino Math Library</title>

<h1>Arduino - Math Library</h1>

<p>The Arduino Math library (math.h) includes a number of useful mathematical functions for manipulating floating-point numbers.</p>

<h2>Library Macros</h2>

<p>Following are the macros defined in the header math.h &minus;</p>

<p>1.4426950408889634074</p>

<p>/* log_2 e */</p>

<p>0.31830988618379067154</p>

<p>/* 1/pi */</p>

<p>0.63661977236758134308</p>

<p>/* 2/pi */</p>

<p>1.12837916709551257390</p>

<p>/* 2/sqrt(pi) */</p>

<p>2.30258509299404568402</p>

<p>/* log_e 10 */</p>

<p>0.69314718055994530942</p>

<p>/* log_e 2 */</p>

<p>0.43429448190325182765</p>

<p>/* log_10 e */</p>

<p>3.14159265358979323846</p>

<p>/* pi */</p>

<p>3.3V1.57079632679489661923</p>

<p>/* pi/2 */</p>

<p>0.78539816339744830962</p>

<p>/* pi/4 */</p>

<p>0.70710678118654752440</p>

<p>/* 1/sqrt(2) */</p>

<p>1.41421356237309504880</p>

<p>/* sqrt(2) */</p>

<h2>Library Functions</h2>

<p>The following functions are defined in the header <b>math.h</b> &minus;</p>

<p><b>double acos (double __x)</b></p>

<p>The acos() function computes the principal value of the arc cosine of __x. The returned value is in the range [0, pi] radians. A domain error occurs for arguments not in the range [-1, +1].</p>

<p><b>double asin (double __x)</b></p>

<p>The asin() function computes the principal value of the arc sine of __x. The returned value is in the range [-pi/2, pi/2] radians. A domain error occurs for arguments not in the range [-1, +1].</p>

<p><b>double atan (double __x)</b></p>

<p>The atan() function computes the principal value of the arc tangent of __x. The returned value is in the range [-pi/2, pi/2] radians.</p>

<p><b>double atan2 (double __y, double __x)</b></p>

<p>The atan2() function computes the principal value of the arc tangent of __y / __x, using the signs of both arguments to determine the quadrant of the return value. The returned value is in the range [-pi, +pi] radians.</p>

<p><b>double cbrt (double __x)</b></p>

<p>The cbrt() function returns the cube root of __x.</p>

<p><b>double ceil (double __x)</b></p>

<p>The ceil() function returns the smallest integral value greater than or equal to __x, expressed as a floating-point number.</p>

<p><b>static double copysign (double __x, double __y)</b></p>

<p>The copysign() function returns __x but with the sign of __y. They work even if __x or __y are NaN or zero.</p>

<p><b>double cos(double __x)</b></p>

<p>The cos() function returns the cosine of __x, measured in radians.</p>

<p><b>double cosh (double __x)</b></p>

<p>The cosh() function returns the hyperbolic cosine of __x.</p>

<p><b>double exp (double __x)</b></p>

<p>The exp() function returns the exponential value of __x.</p>

<p><b>double fabs (double __x)</b></p>

<p>The fabs() function computes the absolute value of a floating-point number __x.</p>

<p><b>double fdim (double __x, double __y)</b></p>

<p>The fdim() function returns max(__x - __y, 0). If __x or __y or both are NaN, NaN is returned.</p>

<p><b>double floor (double __x)</b></p>

<p>The floor() function returns the largest integral value less than or equal to __x, expressed as a floating-point number.</p>

<p><b>double fma (double __x, double __y, double __z)</b></p>

<p>The fma() function performs floating-point multiply-add. This is the operation (__x * __y) + __z, but the intermediate result is not rounded to the destination type. This can sometimes improve the precision of a calculation.</p>

<p><b>double fmax (double __x, double __y)</b></p>

<p>The fmax() function returns the greater of the two values __x and __y. If an argument is NaN, the other argument is returned. If both the arguments are NaN, NaN is returned.</p>

<p><b>double fmin (double __x, double __y)</b></p>

<p>The fmin() function returns the lesser of the two values __x and __y. If an argument is NaN, the other argument is returned. If both the arguments are NaN, NaN is returned.</p>

<p><b>double fmod (double __x, double__y)</b></p>

<p>The function fmod() returns the floating-point remainder of __x / __y.</p>

<p><b>double frexp (double __x, int * __pexp)</b></p>

<p>The frexp() function breaks a floating-point number into a normalized fraction and an integral power of 2. It stores the integer in the int object pointed to by __pexp. If __x is a normal float point number, the frexp() function returns the value v, such that v has a magnitude in the interval [1/2, 1) or zero, and __x equals v times 2 raised to the power __pexp. If __x is zero, both parts of the result are zero. If __x is not a finite number, the frexp() returns __x as is and stores 0 by __pexp.</p>

<p><b>Note</b> &minus; This implementation permits a zero pointer as a directive to skip a storing the exponent.</p>

<p><b>double hypot (double __x, double__y)</b></p>

<p>The hypot() function returns sqrt(__x*__x + __y*__y). This is the length of the hypotenuse of a right triangle with sides of length __x and __y, or the distance of the point (__x, __y) from the origin. Using this function instead of the direct formula is wise, since the error is much smaller. No underflow with small __x and __y. No overflow if result is in range.</p>

<p><b>static int isfinite (double __x)</b></p>

<p>The isfinite() function returns a nonzero value if __x is finite: not plus or minus infinity, and not <b>NaN</b>.</p>

<p><b>int isinf (double __x)</b></p>

<p>The function isinf() returns 1 if the argument __x is positive infinity, -1 if __x is negative infinity, and 0 otherwise.</p>

<p><b>Note</b> &minus; The GCC 4.3 can replace this function with inline code that returns the 1 value for both infinities (gcc bug #35509).</p>

<p><b>int isnan (double __x)</b></p>

<p>The function isnan() returns 1 if the argument __x represents a "not-a-number" (<b>NaN</b>) object, otherwise 0.</p>

<p><b>double ldexp (double __x, int __exp )</b></p>

<p>The ldexp() function multiplies a floating-point number by an integral power of 2. It returns the value of __x times 2 raised to the power __exp.</p>

<p><b>double log (double __x)</b></p>

<p>The log() function returns the natural logarithm of argument __x.</p>

<p><b>double log10(double __x)</b></p>

<p>The log10() function returns the logarithm of argument __x to base 10.</p>

<p><b>long lrint (double __x)</b></p>

<p>The lrint() function rounds __x to the nearest integer, rounding the halfway cases to the even integer direction. (That is both 1.5 and 2.5 values are rounded to 2). This function is similar to rint() function, but it differs in type of return value and in that an overflow is possible.</p>

<p><b>Returns</b></p>

<p>The rounded long integer value. If __x is not a finite number or an overflow, this realization returns the LONG_MIN value (0x80000000).</p>

<p><b>long lround (double __x)</b></p>

<p>The lround() function rounds __x to the nearest integer, but rounds halfway cases away from zero (instead of to the nearest even integer). This function is similar to round() function, but it differs in type of return value and in that an overflow is possible.</p>

<p><b>Returns</b></p>

<p>The rounded long integer value. If __x is not a finite number or an overflow was, this realization returns the LONG_MIN value (0x80000000).</p>

<p><b>double modf (double __x, double * __iptr )</b></p>

<p>The modf() function breaks the argument __x into integral and fractional parts, each of which has the same sign as the argument. It stores the integral part as a double in the object pointed to by __iptr.</p>

<p>The modf() function returns the signed fractional part of __x.</p>

<p><b>Note</b> &minus; This implementation skips writing by zero pointer. However, the GCC 4.3 can replace this function with inline code that does not permit to use NULL address for the avoiding of storing.</p>

<p><b>float modff (float __x, float * __iptr)</b></p>

<p>The alias for modf().</p>

<p><b>double pow (double __x, double __y)</b></p>

<p>The function pow() returns the value of __x to the exponent __y.</p>

<p><b>double round (double __x)</b></p>

<p>The round() function rounds __x to the nearest integer, but rounds halfway cases away from zero (instead of to the nearest even integer). Overflow is impossible.</p>

<p><b>Returns</b></p>

<p>The rounded value. If __x is an integral or infinite, __x itself is returned. If __x is <b>NaN</b>, then <b>NaN</b> is returned.</p>

<p><b>int signbit (double __x)</b></p>

<p>The signbit() function returns a nonzero value if the value of __x has its sign bit set. This is not the same as `__x &lt; 0.0', because IEEE 754 floating point allows zero to be signed. The comparison `-0.0 &lt; 0.0' is false, but `signbit (-0.0)' will return a nonzero value.</p>

<p><b>double sin (double __x)</b></p>

<p>The sin() function returns the sine of __x, measured in radians.</p>

<p><b>double sinh (double __x)</b></p>

<p>The sinh() function returns the hyperbolic sine of __x.</p>

<p><b>double sqrt (double __x)</b></p>

<p>The sqrt() function returns the non-negative square root of __x.</p>

<p><b>double square (double __x)</b></p>

<p>The function square() returns __x * __x.</p>

<p><b>Note</b> &minus; This function does not belong to the C standard definition.</p>

<p><b>double tan (double __x)</b></p>

<p>The tan() function returns the tangent of __x, measured in radians.</p>

<p><b>double tanh ( double __x)</b></p>

<p>The tanh() function returns the hyperbolic tangent of __x.</p>

<p><b>double trunc (double __x)</b></p>

<p>The trunc() function rounds __x to the nearest integer not larger in absolute value.</p>

<h2>Example</h2>

<p>The following example shows how to use the most common math.h library functions &minus;</p>

<h3>Result</h3>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
double double__x = 45.45 ;
double double__y = 30.20 ;

void setup() {
   Serial.begin(9600);
   Serial.print("cos num = ");
   Serial.println (cos (double__x) ); // returns cosine of x
   Serial.print("absolute value of num = ");
   Serial.println (fabs (double__x) ); // absolute value of a float
   Serial.print("floating point modulo = ");
   Serial.println (fmod (double__x, double__y)); // floating point modulo
   Serial.print("sine of num = ");
   Serial.println (sin (double__x) ) ;// returns sine of x
   Serial.print("square root of num : ");
   Serial.println ( sqrt (double__x) );// returns square root of x
   Serial.print("tangent of num : ");
   Serial.println ( tan (double__x) ); // returns tangent of x
   Serial.print("exponential value of num : ");
   Serial.println ( exp (double__x) ); // function returns the exponential value of x.
   Serial.print("cos num : ");

   Serial.println (atan (double__x) ); // arc tangent of x
   Serial.print("tangent of num : ");
   Serial.println (atan2 (double__y, double__x) );// arc tangent of y/x
   Serial.print("arc tangent of num : ");
   Serial.println (log (double__x) ) ; // natural logarithm of x
   Serial.print("cos num : ");
   Serial.println ( log10 (double__x)); // logarithm of x to base 10.
   Serial.print("logarithm of num to base 10 : ");
   Serial.println (pow (double__x, double__y) );// x to power of y
   Serial.print("power of num : ");
   Serial.println (square (double__x)); // square of x
}

void loop() {

}
</pre>
<h3>Result</h3>
<pre class="result notranslate">
cos num = 0.10
absolute value of num = 45.45
floating point modulo =15.25
sine of num = 0.99
square root of num : 6.74
tangent of num : 9.67
exponential value of num : ovf
cos num : 1.55
tangent of num : 0.59
arc tangent of num : 3.82
cos num : 1.66
logarithm of num to base 10 : inf
power of num : 2065.70
</pre>

<title>Arduino Trigonometric Functions</title>

<h1>Arduino - Trigonometric Functions</h1>

<p>You need to use Trigonometry practically like calculating the distance for moving object or angular speed. Arduino provides traditional trigonometric functions (sin, cos, tan, asin, acos, atan) that can be summarized by writing their prototypes. Math.h contains the trigonometry function's prototype.</p>

<h2>Trigonometric Exact Syntax</h2>

<h3>Example</h3>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
double sin(double x); //returns sine of x radians
double cos(double y); //returns cosine of y radians
double tan(double x); //returns the tangent of x radians
double acos(double x); //returns A, the angle corresponding to cos (A) = x
double asin(double x); //returns A, the angle corresponding to sin (A) = x
double atan(double x); //returns A, the angle corresponding to tan (A) = x
</pre>
<h3>Example</h3>
<pre class="prettyprint notranslate">
double sine = sin(2); // approximately 0.90929737091
double cosine = cos(2); // approximately -0.41614685058
double tangent = tan(2); // approximately -2.18503975868
</pre>

<title>Arduino Due and Zero</title>

<h1>Arduino - Due &amp; Zero</h1>

<p>The Arduino Due is a microcontroller board based on the Atmel SAM3X8E ARM Cortex-M3 CPU. It is the first Arduino board based on a 32-bit ARM core microcontroller.</p>

<p>Important features &minus;</p>

<h3>Characteristics of the Arduino Due Board</h3>

<h3>Communication</h3>

<p>Unlike most Arduino boards, the Arduino Due board runs at 3.3V. The maximum voltage that the I/O pins can tolerate is 3.3V. Applying voltages higher than 3.3V to any I/O pin could damage the board.</p>

<p>The board contains everything needed to support the microcontroller. You can simply connect it to a computer with a micro-USB cable or power it with an AC-to-DC adapter or battery to get started. The Due is compatible with all Arduino shields that work at 3.3V.</p>

<h2>Arduino Zero</h2>

<p>The Zero is a simple and powerful 32-bit extension of the platform established by the UNO. The Zero board expands the family by providing increased performance, enabling a variety of project opportunities for devices, and acts as a great educational tool for learning about 32-bit application development.</p>

<p>Important features are &minus;</p>

<p>The Zero applications span from smart IoT devices, wearable technology, high-tech automation, to crazy robotics.</p>

<p>The board is powered by Atmel’s SAMD21 MCU, which features a 32-bit ARM Cortex&reg; M0+ core.</p>

<p>One of its most important features is Atmel’s Embedded Debugger (EDBG), which provides a full debug interface without the need for additional hardware, significantly increasing the ease-of-use for software debugging.</p>

<p>EDBG also supports a virtual COM port that can be used for device and bootloader programming.</p>

<h3>Characteristics of the Arduino Zero board</h3>

<p>Unlike most Arduino and Genuino boards, the Zero runs at 3.3V. The maximum voltage that the I/O pins can tolerate is 3.3V. Applying voltages higher than 3.3V to any I/O pin could damage the board.</p>

<p>The board contains everything needed to support the microcontroller. You can simply connect it to a computer with a micro-USB cable or power it with an AC-to-DC adapter or a battery to get started. The Zero is compatible with all the shields that work at 3.3V.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Arduino Pulse Width Modulation</title>

<h1>Arduino - Pulse Width Modulation</h1>

<p>Pulse Width Modulation or PWM is a common technique used to vary the width of the pulses in a pulse-train. PWM has many applications such as controlling servos and speed controllers, limiting the effective power of motors and LEDs.</p>

<h2>Basic Principle of PWM</h2>

<p>Pulse width modulation is basically, a square wave with a varying high and low time. A basic PWM signal is shown in the following figure.</p>

<p>There are various terms associated with PWM &minus;</p>

<p><b>On-Time</b> &minus; Duration of time signal is high.</p>

<p><b>Off-Time</b> &minus; Duration of time signal is low.</p>

<p><b>Period</b> &minus; It is represented as the sum of on-time and off-time of PWM signal.</p>

<p><b>Duty Cycle</b> &minus; It is represented as the percentage of time signal that remains on during the period of the PWM signal.</p>

<h3>Period</h3>

<p>As shown in the figure, T<sub>on</sub> denotes the on-time and T<sub>off</sub> denotes the off-time of signal. Period is the sum of both on and off times and is calculated as shown in the following equation &minus;</p>

<h3>Duty Cycle</h3>

<p>Duty cycle is calculated as the on-time of the period of time. Using the period calculated above, duty cycle is calculated as &minus;</p>

<h2>analogWrite() Function</h2>

<p>The <b>analogWrite()</b> function writes an analog value (PWM wave) to a pin. It can be used to light a LED at varying brightness or drive a motor at various speeds. After a call of the analogWrite() function, the pin will generate a steady square wave of the specified duty cycle until the next call to analogWrite() or a call to digitalRead() or digitalWrite() on the same pin. The frequency of the PWM signal on most pins is approximately 490 Hz. On the Uno and similar boards, pins 5 and 6 have a frequency of approximately 980 Hz. Pins 3 and 11 on the Leonardo also run at 980 Hz.</p>

<p>On most Arduino boards (those with the ATmega168 or ATmega328), this function works on pins 3, 5, 6, 9, 10, and 11. On the Arduino Mega, it works on pins 2 - 13 and 44 - 46. Older Arduino boards with an ATmega8 only support <b>analogWrite()</b> on pins 9, 10, and 11.</p>

<p>The Arduino Due supports <b>analogWrite()</b> on pins 2 through 13, and pins DAC0 and DAC1. Unlike the PWM pins, DAC0 and DAC1 are Digital to Analog converters, and act as true analog outputs.</p>

<p>You do not need to call pinMode() to set the pin as an output before calling analogWrite().</p>

<h3>analogWrite() Function Syntax</h3>

<p><b>value</b> &minus; the duty cycle: between 0 (always off) and 255 (always on).</p>

<p><b>Example</b></p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
analogWrite ( pin , value ) ;
</pre>
<p><b>value</b> &minus; the duty cycle: between 0 (always off) and 255 (always on).</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
int ledPin = 9; // LED connected to digital pin 9
int analogPin = 3; // potentiometer connected to analog pin 3
int val = 0; // variable to store the read value

void setup() {
   pinMode(ledPin, OUTPUT); // sets the pin as output
}

void loop() {
   val = analogRead(analogPin); // read the input pin
   analogWrite(ledPin, (val / 4)); // analogRead values go from 0 to 1023, 
      // analogWrite values from 0 to 255
}
</pre>

<title>Arduino Random Numbers</title>

<h1>Arduino - Random Numbers</h1>

<p>To generate random numbers, you can use Arduino random number functions. We have two functions &minus;</p>

<h2>randomSeed (seed)</h2>

<p>The function randomSeed(seed) resets Arduino’s pseudorandom number generator. Although the distribution of the numbers returned by random() is essentially random, the sequence is predictable. You should reset the generator to some random value. If you have an unconnected analog pin, it might pick up random noise from the surrounding environment. These may be radio waves, cosmic rays, electromagnetic interference from cell phones, fluorescent lights and so on.</p>

<h3>Example</h3>

<h2>random( )</h2>

<p>The random function generates pseudo-random numbers. Following is the syntax.</p>

<h3>random( ) Statements Syntax</h3>

<h3>Example</h3>

<p>Let us now refresh our knowledge on some of the basic concepts such as bits and bytes.</p>

<h2>Bits</h2>

<p>A bit is just a binary digit.</p>

<p>The binary system uses two digits, 0 and 1.</p>

<p>Similar to the decimal number system, in which digits of a number do not have the same value, the ‘significance’ of a bit depends on its position in the binary number. For example, digits in the decimal number 666 are the same, but have different values.</p>

<h2>Bytes</h2>

<p>A byte consists of eight bits.</p>

<p>If a bit is a digit, it is logical that bytes represent numbers.</p>

<p>All mathematical operations can be performed upon them.</p>

<p>The digits in a byte do not have the same significance either.</p>

<p>The leftmost bit has the greatest value called the Most Significant Bit (MSB).</p>

<p>The rightmost bit has the least value and is therefore, called the Least Significant Bit (LSB).</p>

<p>Since eight zeros and ones of one byte can be combined in 256 different ways, the largest decimal number that can be represented by one byte is 255 (one combination represents a zero).</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
randomSeed(analogRead(5)); // randomize using noise from analog pin 5
</pre>
<h2>random( )</h2>
<p>The random function generates pseudo-random numbers. Following is the syntax.</p>
<h3>random( ) Statements Syntax</h3>
<pre class="result notranslate">
long random(max) // it generate random numbers from 0 to max
long random(min, max) // it generate random numbers from min to max
</pre>
<h3>Example</h3>
<pre class="prettyprint notranslate">
long randNumber;

void setup() {
   Serial.begin(9600);
   // if analog input pin 0 is unconnected, random analog
   // noise will cause the call to randomSeed() to generate
   // different seed numbers each time the sketch runs.
   // randomSeed() will then shuffle the random function.
   randomSeed(analogRead(0));
}

void loop() {
   // print a random number from 0 to 299
   Serial.print("random1=");
   randNumber = random(300);
   Serial.println(randNumber); // print a random number from 0to 299
   Serial.print("random2=");
   randNumber = random(10, 20);// print a random number from 10 to 19
   Serial.println (randNumber);
   delay(50);
}
</pre>

<title>Arduino Interrupts</title>

<h1>Arduino - Interrupts</h1>

<p>Interrupts stop the current work of Arduino such that some other work can be done.</p>

<p>Suppose you are sitting at home, chatting with someone. Suddenly the telephone rings. You stop chatting, and pick up the telephone to speak to the caller. When you have finished your telephonic conversation, you go back to chatting with the person before the telephone rang.</p>

<p>Similarly, you can think of the main routine as chatting to someone, the telephone ringing causes you to stop chatting. The interrupt service routine is the process of talking on the telephone. When the telephone conversation ends, you then go back to your main routine of chatting. This example explains exactly how an interrupt causes a processor to act.</p>

<p>The main program is running and performing some function in a circuit. However, when an interrupt occurs the main program halts while another routine is carried out. When this routine finishes, the processor goes back to the main routine again.</p>

<h3>Important features</h3>

<p>Here are some important features about interrupts &minus;</p>

<p>Interrupts can come from various sources. In this case, we are using a hardware interrupt that is triggered by a state change on one of the digital pins.</p>

<p>Most Arduino designs have two hardware interrupts (referred to as "interrupt0" and "interrupt1") hard-wired to digital I/O pins 2 and 3, respectively.</p>

<p>The Arduino Mega has six hardware interrupts including the additional interrupts ("interrupt2" through "interrupt5") on pins 21, 20, 19, and 18.</p>

<p>You can define a routine using a special function called as “Interrupt Service Routine” (usually known as ISR).</p>

<p>You can define the routine and specify conditions at the rising edge, falling edge or both. At these specific conditions, the interrupt would be serviced.</p>

<p>It is possible to have that function executed automatically, each time an event happens on an input pin.</p>

<h2>Types of Interrupts</h2>

<p>There are two types of interrupts &minus;</p>

<p><b>Hardware Interrupts</b> &minus; They occur in response to an external event, such as an external interrupt pin going high or low.</p>

<p><b>Software Interrupts</b> &minus; They occur in response to an instruction sent in software. The only type of interrupt that the “Arduino language” supports is the attachInterrupt() function.</p>

<h3>Using Interrupts in Arduino</h3>

<p>Interrupts are very useful in Arduino programs as it helps in solving timing problems. A good application of an interrupt is reading a rotary encoder or observing a user input. Generally, an ISR should be as short and fast as possible. If your sketch uses multiple ISRs, only one can run at a time. Other interrupts will be executed after the current one finishes in an order that depends on the priority they have.</p>

<p>Typically, global variables are used to pass data between an ISR and the main program. To make sure variables shared between an ISR and the main program are updated correctly, declare them as volatile.</p>

<h3>attachInterrupt Statement Syntax</h3>

<p>The following three constants are predefined as valid values &minus;</p>

<p><b>LOW</b> to trigger the interrupt whenever the pin is low.</p>

<p><b>CHANGE</b> to trigger the interrupt whenever the pin changes value.</p>

<p><b>FALLING</b> whenever the pin goes from high to low.</p>

<p><b>Example</b></p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
attachInterrupt(digitalPinToInterrupt(pin),ISR,mode);//recommended for arduino board
attachInterrupt(pin, ISR, mode) ; //recommended Arduino Due, Zero only
//argument pin: the pin number
//argument ISR: the ISR to call when the interrupt occurs; 
   //this function must take no parameters and return nothing. 
   //This function is sometimes referred to as an interrupt service routine.
//argument mode: defines when the interrupt should be triggered.
</pre>
<p>The following three constants are predefined as valid values &minus;</p>
<ul class="list">
<li><p><b>LOW</b> to trigger the interrupt whenever the pin is low.</p></li>
<li><p><b>CHANGE</b> to trigger the interrupt whenever the pin changes value.</p></li>
<li><p><b>FALLING</b> whenever the pin goes from high to low.</p></li>
</ul>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
int pin = 2; //define interrupt pin to 2
volatile int state = LOW; // To make sure variables shared between an ISR
//the main program are updated correctly,declare them as volatile.

void setup() {
   pinMode(13, OUTPUT); //set pin 13 as output
   attachInterrupt(digitalPinToInterrupt(pin), blink, CHANGE);
   //interrupt at pin 2 blink ISR when pin to change the value
} 
void loop() { 
   digitalWrite(13, state); //pin 13 equal the state value
} 

void blink() { 
   //ISR function
   state = !state; //toggle the state when the interrupt occurs
}
</pre>

<title>Arduino Communication</title>

<h1>Arduino - Communication</h1>

<p>Hundreds of communication protocols have been defined to achieve this data exchange. Each protocol can be categorized into one of the two categories: parallel or serial.</p>

<h2>Parallel Communication</h2>

<p>Parallel connection between the Arduino and peripherals via input/output ports is the ideal solution for shorter distances up to several meters. However, in other cases when it is necessary to establish communication between two devices for longer distances it is not possible to use parallel connection. Parallel interfaces transfer multiple bits at the same time. They usually require buses of data - transmitting across eight, sixteen, or more wires. Data is transferred in huge, crashing waves of 1’s and 0’s.</p>

<h3>Advantages and Drawbacks of Parallel Communication</h3>

<p>Parallel communication certainly has its advantages. It is faster than serial, straightforward, and relatively easy to implement. However, it requires many input/output (I/O) ports and lines. If you have ever had to move a project from a basic Arduino Uno to a Mega, you know that the I/O lines on a microprocessor can be precious and few. Therefore, we prefer serial communication, sacrificing potential speed for pin real estate.</p>

<h2>Serial Communication Modules</h2>

<p>Today, most Arduino boards are built with several different systems for serial communication as standard equipment.</p>

<p>Which of these systems are used depends on the following factors &minus;</p>

<p>One of the most important things concerning serial communication is the <b>Protocol</b>, which should be strictly observed. It is a set of rules, which must be applied such that the devices can correctly interpret data they mutually exchange. Fortunately, Arduino automatically takes care of this, so that the work of the programmer/user is reduced to simple write (data to be sent) and read (received data).</p>

<h2>Types of Serial Communications</h2>

<p>Serial communication can be further classified as &minus;</p>

<p><b>Synchronous</b> &minus; Devices that are synchronized use the same clock and their timing is in synchronization with each other.</p>

<p><b>Asynchronous</b> &minus; Devices that are asynchronous have their own clocks and are triggered by the output of the previous state.</p>

<p>It is easy to find out if a device is synchronous or not. If the same clock is given to all the connected devices, then they are synchronous. If there is no clock line, it is asynchronous.</p>

<p>For example, UART (Universal Asynchronous Receiver Transmitter) module is asynchronous.</p>

<p>The asynchronous serial protocol has a number of built-in rules. These rules are nothing but mechanisms that help ensure robust and error-free data transfers. These mechanisms, which we get for eschewing the external clock signal, are &minus;</p>

<h3>Synchronization Bits</h3>

<p>The synchronization bits are two or three special bits transferred with each packet of data. They are the start bit and the stop bit(s). True to their name, these bits mark the beginning and the end of a packet respectively.</p>

<p>There is always only one start bit, but the number of stop bits is configurable to either one or two (though it is normally left at one).</p>

<p>The start bit is always indicated by an idle data line going from 1 to 0, while the stop bit(s) will transition back to the idle state by holding the line at 1.</p>

<h3>Data Bits</h3>

<p>The amount of data in each packet can be set to any size from 5 to 9 bits. Certainly, the standard data size is your basic 8-bit byte, but other sizes have their uses. A 7-bit data packet can be more efficient than 8, especially if you are just transferring 7-bit ASCII characters.</p>

<h3>Parity Bits</h3>

<p>The user can select whether there should be a parity bit or not, and if yes, whether the parity should be odd or even. The parity bit is 0 if the number of 1’s among the data bits is even. Odd parity is just the opposite.</p>

<h3>Baud Rate</h3>

<p>The term baud rate is used to denote the number of bits transferred per second [bps]. Note that it refers to bits, not bytes. It is usually required by the protocol that each byte is transferred along with several control bits. It means that one byte in serial data stream may consist of 11 bits. For example, if the baud rate is 300 bps then maximum 37 and minimum 27 bytes may be transferred per second.</p>

<h2>Arduino UART</h2>

<p>The following code will make Arduino send hello world when it starts up.</p>

<p>After the Arduino sketch has been uploaded to Arduino, open the Serial monitor <img class="inline" src="/arduino/images/search.jpg" alt="Search" /> at the top right section of Arduino IDE.</p>

<p>Type anything into the top box of the Serial Monitor and press send or enter on your keyboard. This will send a series of bytes to the Arduino.</p>

<p>The following code returns whatever it receives as an input.</p>

<p>The following code will make Arduino deliver output depending on the input provided.</p>

<p>Notice that <b>Serial.print</b> and <b>Serial.println</b> will send back the actual ASCII code, whereas <b>Serial.write</b> will send back the actual text. See ASCII codes for more information.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
void setup() {
   Serial.begin(9600); //set up serial library baud rate to 9600
   Serial.println("hello world"); //print hello world
}

void loop() {

}
</pre>
<p>After the Arduino sketch has been uploaded to Arduino, open the Serial monitor <img class="inline" src="/arduino/images/search.jpg" alt="Search" /> at the top right section of Arduino IDE.</p>
<p>Type anything into the top box of the Serial Monitor and press send or enter on your keyboard. This will send a series of bytes to the Arduino.</p>
<p>The following code returns whatever it receives as an input.</p>
<p>The following code will make Arduino deliver output depending on the input provided.</p>
<pre class="prettyprint notranslate">
void setup() {
   Serial.begin(9600); //set up serial library baud rate to 9600
}

void loop() {
   if(Serial.available()) //if number of bytes (characters) available for reading from { 
      serial port
      Serial.print("I received:"); //print I received
      Serial.write(Serial.read()); //send what you read
   }
}
</pre>

<title>Arduino Inter Integrated Circuit</title>

<h1>Arduino - Inter Integrated Circuit</h1>

<p>Inter-integrated circuit (I2C) is a system for serial data exchange between the microcontrollers and specialized integrated circuits of a new generation. It is used when the distance between them is short (receiver and transmitter are usually on the same printed board). Connection is established via two conductors. One is used for data transfer and the other is used for synchronization (clock signal).</p>

<p>As seen in the following figure, one device is always a master. It performs addressing of one slave chip before the communication starts. In this way, one microcontroller can communicate with 112 different devices. Baud rate is usually 100 Kb/sec (standard mode) or 10 Kb/sec (slow baud rate mode). Systems with the baud rate of 3.4 Mb/sec have recently appeared. The distance between devices, which communicate over an I2C bus is limited to several meters.</p>

<h2>Board I2C Pins</h2>

<p>The I2C bus consists of two signals &minus; SCL and SDA. SCL is the clock signal, and SDA is the data signal. The current bus master always generates the clock signal. Some slave devices may force the clock low at times to delay the master sending more data (or to require more time to prepare data before the master attempts to clock it out). This is known as “clock stretching”.</p>

<p>Following are the pins for different Arduino boards &minus;</p>

<h2>Arduino I2C</h2>

<p>We have two modes - master code and slave code - to connect two Arduino boards using I2C. They are &minus;</p>

<h2>Master Transmitter / Slave Receiver</h2>

<p>Let us now see what is master transmitter and slave receiver.</p>

<h3>Master Transmitter</h3>

<p>The following functions are used to initialize the Wire library and join the I2C bus as a master or slave. This is normally called only once.</p>

<p><b>Wire.begin(address)</b> &minus; Address is the 7-bit slave address in our case as the master is not specified and it will join the bus as a master.</p>

<p><b>Wire.beginTransmission(address)</b> &minus; Begin a transmission to the I2C slave device with the given address.</p>

<p><b>Wire.write(value)</b> &minus; Queues bytes for transmission from a master to slave device (in-between calls to beginTransmission() and endTransmission()).</p>

<p><b>Wire.endTransmission()</b> &minus; Ends a transmission to a slave device that was begun by beginTransmission() and transmits the bytes that were queued by wire.write().</p>

<p><b>Example</b></p>

<h3>Slave Receiver</h3>

<p>The following functions are used &minus;</p>

<p><b>Wire.begin(address)</b> &minus; Address is the 7-bit slave address.</p>

<p><b>Wire.onReceive(received data handler)</b> &minus; Function to be called when a slave device receives data from the master.</p>

<p><b>Wire.available()</b> &minus; Returns the number of bytes available for retrieval with Wire.read().This should be called inside the Wire.onReceive() handler.</p>

<p><b>Example</b></p>

<h2>Master Receiver / Slave Transmitter</h2>

<p>Let us now see what is master receiver and slave transmitter.</p>

<h3>Master Receiver</h3>

<p>The Master, is programmed to request, and then read bytes of data that are sent from the uniquely addressed Slave Arduino.</p>

<p>The following function is used &minus;</p>

<p><b>Wire.requestFrom(address,number of bytes)</b> &minus; Used by the master to request bytes from a slave device. The bytes may then be retrieved with the functions wire.available() and wire.read() functions.</p>

<p><b>Example</b></p>

<h3>Slave Transmitter</h3>

<p>The following function is used.</p>

<p><b>Wire.onRequest(handler)</b> &minus; A function is called when a master requests data from this slave device.</p>

<p><b>Example</b></p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
#include &lt;Wire.h&gt; //include wire library

void setup() //this will run only once { 
   Wire.begin(); // join i2c bus as master
} 

short age = 0; 

void loop() {   
   Wire.beginTransmission(2); 
   // transmit to device #2
   Wire.write("age is = ");
   Wire.write(age); // sends one byte
   Wire.endTransmission(); // stop transmitting
   delay(1000); 
}
</pre>
<h3>Slave Receiver</h3>
<p>The following functions are used &minus;</p>
<ul class="list">
<li><p><b>Wire.begin(address)</b> &minus; Address is the 7-bit slave address.</p></li>
<li><p><b>Wire.onReceive(received data handler)</b> &minus; Function to be called when a slave device receives data from the master.</p></li>
<li><p><b>Wire.available()</b> &minus; Returns the number of bytes available for retrieval with Wire.read().This should be called inside the Wire.onReceive() handler.</p></li>
</ul>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
#include &lt;Wire.h&gt; //include wire library

void setup() {  //this will run only once
   Wire.begin(2); // join i2c bus with address #2
   Wire.onReceive(receiveEvent); // call receiveEvent when the master send any thing 
   Serial.begin(9600); // start serial for output to print what we receive 
}

void loop() {   
   delay(250); 
}

//-----this function will execute whenever data is received from master-----//

void receiveEvent(int howMany) { 
   while (Wire.available()&gt;1) // loop through all but the last {
      char c = Wire.read(); // receive byte as a character
      Serial.print(c); // print the character
   }
}
</pre>
<h2>Master Receiver / Slave Transmitter</h2>
<p>Let us now see what is master receiver and slave transmitter.</p>
<h3>Master Receiver</h3>
<p>The Master, is programmed to request, and then read bytes of data that are sent from the uniquely addressed Slave Arduino.</p>
<p>The following function is used &minus;</p>
<p><b>Wire.requestFrom(address,number of bytes)</b> &minus; Used by the master to request bytes from a slave device. The bytes may then be retrieved with the functions wire.available() and wire.read() functions.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
#include &lt;Wire.h&gt; //include wire library void setup() { 
   Wire.begin(); // join i2c bus (address optional for master) 
   Serial.begin(9600); // start serial for output
} 

void loop() { 
   Wire.requestFrom(2, 1); // request 1 bytes from slave device #2
   while (Wire.available()) // slave may send less than requested {
      char c = Wire.read(); // receive a byte as character
      Serial.print(c); // print the character
   } 
   delay(500); 
}
</pre>
<h3>Slave Transmitter</h3>
<p>The following function is used.</p>
<p><b>Wire.onRequest(handler)</b> &minus; A function is called when a master requests data from this slave device.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
#include &lt;Wire.h&gt; 

void setup() { 
   Wire.begin(2); // join i2c bus with address #2
   Wire.onRequest(requestEvent); // register event
} 

Byte x = 0;

void loop() { 
   delay(100); 
} 

// function that executes whenever data is requested by master
// this function is registered as an event, see setup()

void requestEvent() { 
   Wire.write(x); // respond with message of 1 bytes as expected by master
   x++; 
}
</pre>

<title>Arduino Serial Peripheral Interface</title>

<h1>Arduino - Serial Peripheral Interface</h1>

<p>A Serial Peripheral Interface (SPI) bus is a system for serial communication, which uses up to four conductors, commonly three. One conductor is used for data receiving, one for data sending, one for synchronization and one alternatively for selecting a device to communicate with. It is a full duplex connection, which means that the data is sent and received simultaneously. The maximum baud rate is higher than that in the I2C communication system.</p>

<h2>Board SPI Pins</h2>

<p>SPI uses the following four wires &minus;</p>

<p><b>SCK</b> &minus; This is the serial clock driven by the master.</p>

<p><b>MOSI</b> &minus; This is the master output / slave input driven by the master.</p>

<p><b>MISO</b> &minus; This is the master input / slave output driven by the master.</p>

<p><b>SS</b> &minus; This is the slave-selection wire.</p>

<p>The following functions are used. You have to include the SPI.h.</p>

<p><b>SPI.begin()</b> &minus; Initializes the SPI bus by setting SCK, MOSI, and SS to outputs, pulling SCK and MOSI low, and SS high.</p>

<p><b>SPI.setClockDivider(divider)</b> &minus; To set the SPI clock divider relative to the system clock. On AVR based boards, the dividers available are 2, 4, 8, 16, 32, 64 or 128. The default setting is SPI_CLOCK_DIV4, which sets the SPI clock to one-quarter of the frequency of the system clock (5 Mhz for the boards at 20 MHz).</p>

<p><b>Divider</b> &minus; It could be (SPI_CLOCK_DIV2, SPI_CLOCK_DIV4, SPI_CLOCK_DIV8, SPI_CLOCK_DIV16, SPI_CLOCK_DIV32, SPI_CLOCK_DIV64, SPI_CLOCK_DIV128).</p>

<p><b>SPI.transfer(val)</b> &minus; SPI transfer is based on a simultaneous send and receive: the received data is returned in receivedVal.</p>

<p><b>SPI.beginTransaction(SPISettings(speedMaximum, dataOrder, dataMode))</b> &minus; speedMaximum is the clock, dataOrder(MSBFIRST or LSBFIRST), dataMode(SPI_MODE0, SPI_MODE1, SPI_MODE2, or SPI_MODE3).</p>

<p>We have four modes of operation in SPI as follows &minus;</p>

<p><b>Mode 0 (the default)</b> &minus; Clock is normally low (CPOL = 0), and the data is sampled on the transition from low to high (leading edge) (CPHA = 0).</p>

<p><b>Mode 1</b> &minus; Clock is normally low (CPOL = 0), and the data is sampled on the transition from high to low (trailing edge) (CPHA = 1).</p>

<p><b>Mode 2</b> &minus; Clock is normally high (CPOL = 1), and the data is sampled on the transition from high to low (leading edge) (CPHA = 0).</p>

<p><b>Mode 3</b> &minus; Clock is normally high (CPOL = 1), and the data is sampled on the transition from low to high (trailing edge) (CPHA = 1).</p>

<p><b>SPI.attachInterrupt(handler)</b> &minus; Function to be called when a slave device receives data from the master.</p>

<p>Now, we will connect two Arduino UNO boards together; one as a master and the other as a slave.</p>

<p>The ground is common. Following is the diagrammatic representation of the connection between both the boards &minus;</p>

<p>Let us see examples of SPI as Master and SPI as Slave.</p>

<h2>SPI as MASTER</h2>

<h3>Example</h3>

<h2>SPI as SLAVE</h2>

<h3>Example</h3>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
#include &lt;SPI.h&gt;

void setup (void) {
   Serial.begin(115200); //set baud rate to 115200 for usart
   digitalWrite(SS, HIGH); // disable Slave Select
   SPI.begin ();
   SPI.setClockDivider(SPI_CLOCK_DIV8);//divide the clock by 8
}

void loop (void) {
   char c;
   digitalWrite(SS, LOW); // enable Slave Select
   // send test string
   for (const char * p = "Hello, world!\r" ; c = *p; p++) {
      SPI.transfer (c);
      Serial.print(c);
   }
   digitalWrite(SS, HIGH); // disable Slave Select
   delay(2000);
}
</pre>
<h2>SPI as SLAVE</h2>
<h3>Example</h3>
<pre class="prettyprint notranslate">
#include &lt;SPI.h&gt;
char buff [50];
volatile byte indx;
volatile boolean process;

void setup (void) {
   Serial.begin (115200);
   pinMode(MISO, OUTPUT); // have to send on master in so it set as output
   SPCR |= _BV(SPE); // turn on SPI in slave mode
   indx = 0; // buffer empty
   process = false;
   SPI.attachInterrupt(); // turn on interrupt
}
ISR (SPI_STC_vect) // SPI interrupt routine { 
   byte c = SPDR; // read byte from SPI Data Register
   if (indx &lt; sizeof buff) {
      buff [indx++] = c; // save data in the next index in the array buff
      if (c == '\r') //check for the end of the word
      process = true;
   }
}

void loop (void) {
   if (process) {
      process = false; //reset the process
      Serial.println (buff); //print the array on serial monitor
      indx= 0; //reset button to zero
   }
}
</pre>

<title>Arduino Blinking LED</title>

<h1>Arduino - Blinking LED</h1>

<p>LEDs are small, powerful lights that are used in many different applications. To start, we will work on blinking an LED, the Hello World of microcontrollers. It is as simple as turning a light on and off. Establishing this important baseline will give you a solid foundation as we work towards experiments that are more complex.</p>

<h2>Components Required</h2>

<p>You will need the following components &minus;</p>

<h2>Procedure</h2>

<p>Follow the circuit diagram and hook up the components on the breadboard as shown in the image given below.</p>

<p><b>Note</b> &minus; To find out the polarity of an LED, look at it closely. The shorter of the two legs, towards the flat edge of the bulb indicates the negative terminal.</p>

<p>Components like resistors need to have their terminals bent into 90° angles in order to fit the breadboard sockets properly. You can also cut the terminals shorter.</p>

<h2>Sketch</h2>

<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open the new sketch File by clicking New.</p>

<h2>Arduino Code</h2>

<h2>Code to Note</h2>

<p><b>pinMode(2, OUTPUT)</b> &minus; Before you can use one of Arduino’s pins, you need to tell Arduino Uno R3 whether it is an INPUT or OUTPUT. We use a built-in “function” called pinMode() to do this.</p>

<p><b>digitalWrite(2, HIGH)</b> &minus; When you are using a pin as an OUTPUT, you can command it to be HIGH (output 5 volts), or LOW (output 0 volts).</p>

<h2>Result</h2>

<p>You should see your LED turn on and off. If the required output is not seen, make sure you have assembled the circuit correctly, and verified and uploaded the code to your board.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
/*
   Blink
   Turns on an LED on for one second, then off for one second, repeatedly.
*/

// the setup function runs once when you press reset or power the board

void setup() {  // initialize digital pin 13 as an output.
   pinMode(2, OUTPUT);
}

// the loop function runs over and over again forever

void loop() {
   digitalWrite(2, HIGH); // turn the LED on (HIGH is the voltage level)
   delay(1000); // wait for a second
   digitalWrite(2, LOW); // turn the LED off by making the voltage LOW
   delay(1000); // wait for a second
}
</pre>

<title>Arduino Fading LED</title>

<h1>Arduino - Fading LED</h1>

<p>This example demonstrates the use of the analogWrite() function in fading an LED off. AnalogWrite uses pulse width modulation (PWM), turning a digital pin on and off very quickly with different ratios between on and off, to create a fading effect.</p>

<h2>Components Required</h2>

<p>You will need the following components &minus;</p>

<h2>Procedure</h2>

<p>Follow the circuit diagram and hook up the components on the breadboard as shown in the image given below.</p>

<p><b>Note</b> &minus; To find out the polarity of an LED, look at it closely. The shorter of the two legs, towards the flat edge of the bulb indicates the negative terminal.</p>

<p>Components like resistors need to have their terminals bent into 90° angles in order to fit the breadboard sockets properly. You can also cut the terminals shorter.</p>

<h2>Sketch</h2>

<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open the new sketch File by clicking New.</p>

<h2>Arduino Code</h2>

<h2>Code to Note</h2>

<p>After declaring pin 9 as your LED pin, there is nothing to do in the setup() function of your code. The analogWrite() function that you will be using in the main loop of your code requires two arguments: One, telling the function which pin to write to and the other indicating what PWM value to write.</p>

<p>In order to fade the LED off and on, gradually increase the PWM values from 0 (all the way off) to 255 (all the way on), and then back to 0, to complete the cycle. In the sketch given above, the PWM value is set using a variable called brightness. Each time through the loop, it increases by the value of the variable <b>fadeAmount</b>.</p>

<p>If brightness is at either extreme of its value (either 0 or 255), then fadeAmount is changed to its negative. In other words, if fadeAmount is 5, then it is set to -5. If it is -5, then it is set to 5. The next time through the loop, this change causes brightness to change direction as well.</p>

<p><b>analogWrite()</b> can change the PWM value very fast, so the delay at the end of the sketch controls the speed of the fade. Try changing the value of the delay and see how it changes the fading effect.</p>

<h2>Result</h2>

<p>You should see your LED brightness change gradually.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
/*
   Fade
   This example shows how to fade an LED on pin 9 using the analogWrite() function.

   The analogWrite() function uses PWM, so if you want to change the pin you're using, be
   sure to use another PWM capable pin. On most Arduino, the PWM pins are identified with
   a "~" sign, like ~3, ~5, ~6, ~9, ~10 and ~11.
*/

int led = 9; // the PWM pin the LED is attached to
int brightness = 0; // how bright the LED is
int fadeAmount = 5; // how many points to fade the LED by
// the setup routine runs once when you press reset:

void setup() {
   // declare pin 9 to be an output:
   pinMode(led, OUTPUT);
}

// the loop routine runs over and over again forever:

void loop() {
   // set the brightness of pin 9:
   analogWrite(led, brightness);
   // change the brightness for next time through the loop:
   brightness = brightness + fadeAmount;
   // reverse the direction of the fading at the ends of the fade:
   if (brightness == 0 || brightness == 255) {
      fadeAmount = -fadeAmount ;
   }
   // wait for 30 milliseconds to see the dimming effect
   delay(300);
}
</pre>

<title>Arduino Reading Analog Voltage</title>

<h1>Arduino - Reading Analog Voltage</h1>

<p>This example will show you how to read an analog input on analog pin 0. The input is converted from analogRead() into voltage, and printed out to the serial monitor of the Arduino Software (IDE).</p>

<h2>Components Required</h2>

<p>You will need the following components &minus;</p>

<h2>Procedure</h2>

<p>Follow the circuit diagram and hook up the components on the breadboard as shown in the image given below.</p>

<h2>Potentiometer</h2>

<p>A potentiometer (or pot) is a simple electro-mechanical transducer. It converts rotary or linear motion from the input operator into a change of resistance. This change is (or can be) used to control anything from the volume of a hi-fi system to the direction of a huge container ship.</p>

<p>The pot as we know it was originally known as a rheostat (essentially a variable wirewound resistor). The variety of available pots is now quite astonishing, and it can be very difficult for the beginner (in particular) to work out which type is suitable for a given task. A few different pot types, which can all be used for the same task makes the job harder.</p>

<p>The image on the left shows the standard schematic symbol of a pot. The image on the right is the potentiometer.</p>

<h2>Sketch</h2>

<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open a new sketch File by clicking New.</p>

<h2>Arduino Code</h2>

<h2>Code to Note</h2>

<p>In the program or sketch given below, the first thing that you do in the setup function is begin serial communications, at 9600 bits per second, between your board and your computer with the line &minus;</p>

<p>In the main loop of your code, you need to establish a variable to store the resistance value (which will be between 0 and 1023, perfect for an int datatype) coming from your potentiometer &minus;</p>

<p>To change the values from 0-1023 to a range that corresponds to the voltage, the pin is reading, you need to create another variable, a float, and do a little calculation. To scale the numbers between 0.0 and 5.0, divide 5.0 by 1023.0 and multiply that by sensorValue &minus;</p>

<p>Finally, you need to print this information to your serial window. You can do this with the command Serial.println() in your last line of code &minus;</p>

<p>Now, open Serial Monitor in the Arduino IDE by clicking the icon on the right side of the top green bar or pressing Ctrl+Shift+M.</p>

<h2>Result</h2>

<p>You will see a steady stream of numbers ranging from 0.0 - 5.0. As you turn the pot, the values will change, corresponding to the voltage at pin A0.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
/*
   ReadAnalogVoltage
   Reads an analog input on pin 0, converts it to voltage, 
   and prints the result to the serial monitor.
   Graphical representation is available using serial plotter (Tools &gt; Serial Plotter menu)
   Attach the center pin of a potentiometer to pin A0, and the outside pins to +5V and ground.
*/

// the setup routine runs once when you press reset:

void setup() {
   // initialize serial communication at 9600 bits per second:
   Serial.begin(9600);
}

// the loop routine runs over and over again forever:

void loop() {
   // read the input on analog pin 0:
   int sensorValue = analogRead(A0);
   // Convert the analog reading (which goes from 0 - 1023) to a voltage (0 - 5V):
   float voltage = sensorValue * (5.0 / 1023.0);
   // print out the value you read:
   Serial.println(voltage);
}
</pre>
<h2>Code to Note</h2>
<p>In the program or sketch given below, the first thing that you do in the setup function is begin serial communications, at 9600 bits per second, between your board and your computer with the line &minus;</p>
<pre class="result notranslate">
Serial.begin(9600);
</pre>
<p>In the main loop of your code, you need to establish a variable to store the resistance value (which will be between 0 and 1023, perfect for an int datatype) coming from your potentiometer &minus;</p>
<pre class="result notranslate">
int sensorValue = analogRead(A0);
</pre>
<p>To change the values from 0-1023 to a range that corresponds to the voltage, the pin is reading, you need to create another variable, a float, and do a little calculation. To scale the numbers between 0.0 and 5.0, divide 5.0 by 1023.0 and multiply that by sensorValue &minus;</p>
<pre class="result notranslate">
float voltage= sensorValue * (5.0 / 1023.0);
</pre>
<p>Finally, you need to print this information to your serial window. You can do this with the command Serial.println() in your last line of code &minus;</p>
<pre class="result notranslate">
Serial.println(voltage)
</pre>

<title>Arduino LED Bar Graph</title>

<h1>Arduino - LED Bar Graph</h1>

<p>This example shows you how to read an analog input at analog pin 0, convert the values from analogRead() into voltage, and print it out to the serial monitor of the Arduino Software (IDE).</p>

<h2>Components Required</h2>

<p>You will need the following components &minus;</p>

<h2>Procedure</h2>

<p>Follow the circuit diagram and hook up the components on the breadboard as shown in the image given below.</p>

<p></p>

<h2>Sketch</h2>

<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open a new sketch File by clicking New.</p>

<h2>10 Segment LED Bar Graph</h2>

<p>These 10-segment bar graph LEDs have many uses. With a compact footprint, simple hookup, they are easy for prototype or finished products. Essentially, they are 10 individual blue LEDs housed together, each with an individual anode and cathode connection.</p>

<p>They are also available in yellow, red, and green colors.</p>

<p><b>Note</b> &minus; The pin out on these bar graphs may vary from what is listed on the datasheet. Rotating the device 180 degrees will correct the change, making pin 11 the first pin in line.</p>

<h2>Arduino Code</h2>

<h2>Code to Note</h2>

<p>The sketch works like this: first, you read the input. You map the input value to the output range, in this case ten LEDs. Then you set up a <b>for-loop</b> to iterate over the outputs. If the output's number in the series is lower than the mapped input range, you turn it on. If not, you turn it off.</p>

<h2>Result</h2>

<p>You will see the LED turn ON one by one when the value of analog reading increases and turn OFF one by one while the reading is decreasing.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
/*
   LED bar graph
   Turns on a series of LEDs based on the value of an analog sensor. 
   This is a simple way to make a bar graph display. 
   Though this graph uses 8LEDs, you can use any number by
      changing the LED count and the pins in the array.
   This method can be used to control any series of digital
      outputs that depends on an analog input.
*/

// these constants won't change:
const int analogPin = A0; // the pin that the potentiometer is attached to
const int ledCount = 8; // the number of LEDs in the bar graph
int ledPins[] = {2, 3, 4, 5, 6, 7, 8, 9}; // an array of pin numbers to which LEDs are attached

void setup() {
   // loop over the pin array and set them all to output:
   for (int thisLed = 0; thisLed &lt; ledCount; thisLed++) {
      pinMode(ledPins[thisLed], OUTPUT);
   }
}

void loop() {
   // read the potentiometer:
   int sensorReading = analogRead(analogPin);
   // map the result to a range from 0 to the number of LEDs:
   int ledLevel = map(sensorReading, 0, 1023, 0, ledCount);
   // loop over the LED array:
   for (int thisLed = 0; thisLed &lt; ledCount; thisLed++) {
      // if the array element's index is less than ledLevel,
      // turn the pin for this element on:
      if (thisLed &lt; ledLevel) {
         digitalWrite(ledPins[thisLed], HIGH);
      }else { // turn off all pins higher than the ledLevel:
         digitalWrite(ledPins[thisLed], LOW);
      }
   }
} 
</pre>

<title>Arduino Keyboard Logout</title>

<h1>Arduino - Keyboard Logout</h1>

<p>This example uses the Keyboard library to log you out of your user session on your computer when pin 2 on the ARDUINO UNO is pulled to ground. The sketch simulates the keypress in sequence of two or three keys at the same time and after a short delay, it releases them.</p>

<p><b>Warning</b> &minus; When you use the <b>Keyboard.print()</b> command, Arduino takes over your computer's keyboard. To ensure you do not lose control of your computer while running a sketch with this function, set up a reliable control system before you call Keyboard.print(). This sketch is designed to only send a Keyboard command after a pin has been pulled to ground.</p>

<h2>Components Required</h2>

<p>You will need the following components &minus;</p>

<h2>Procedure</h2>

<p>Follow the circuit diagram and hook up the components on the breadboard as shown in the image below.</p>

<h2>Sketch</h2>

<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open a new sketch File by clicking New.</p>

<p>For this example, you need to use Arduino IDE 1.6.7</p>

<p><b>Note</b> &minus; You must include the keyboard library in your Arduino library file. Copy and paste the keypad library file inside the file with the name libraries (highlighted) as shown in the following screenshot.</p>

<h2>Arduino Code</h2>

<h2>Code to Note</h2>

<p>Before you upload the program to your board, make sure you assign the correct OS you are currently using to the platform variable.</p>

<p>While the sketch is running, pressing the button will connect pin 2 to the ground and the board will send the logout sequence to the USB connected PC.</p>

<h2>Result</h2>

<p>When you connect pin 2 to the ground, it performs a logout operation.</p>

<p>It uses the following keyboard combinations to logout &minus;</p>

<p>On <b>Windows</b>, CTRL-ALT-DEL followed by ALT-l</p>

<p>On <b>Ubuntu</b>, CTRL-ALT-DEL, and ENTER</p>

<p>On <b>OSX</b>, CMD-SHIFT-q</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
/*
   Keyboard logout
   This sketch demonstrates the Keyboard library.
   When you connect pin 2 to ground, it performs a logout.
   It uses keyboard combinations to do this, as follows:
   On Windows, CTRL-ALT-DEL followed by ALT-l
   On Ubuntu, CTRL-ALT-DEL, and ENTER
   On OSX, CMD-SHIFT-q
   To wake: Spacebar.
   Circuit:
   * Arduino Leonardo or Micro
   * wire to connect D2 to ground.
*/

#define OSX 0
#define WINDOWS 1
#define UBUNTU 2

#include "Keyboard.h"

// change this to match your platform:
int platform = WINDOWS;

void setup() {
   // make pin 2 an input and turn on the
   // pullup resistor so it goes high unless
   // connected to ground:
   
   pinMode(2, INPUT_PULLUP);
   Keyboard.begin();
}

void loop() {
   while (digitalRead(2) == HIGH) {
      // do nothing until pin 2 goes low
      delay(500);
   }
   
   delay(1000);
   
   switch (platform) {
      case OSX:
      Keyboard.press(KEY_LEFT_GUI);
	  
      // Shift-Q logs out:
      Keyboard.press(KEY_LEFT_SHIFT);
      Keyboard.press('Q');
      delay(100);
	  
      // enter:
      Keyboard.write(KEY_RETURN);
      break;
	  
      case WINDOWS:
      // CTRL-ALT-DEL:
      Keyboard.press(KEY_LEFT_CTRL);
      Keyboard.press(KEY_LEFT_ALT);
      Keyboard.press(KEY_DELETE);
      delay(100);
      Keyboard.releaseAll();
	  
      //ALT-l:
      delay(2000);
      Keyboard.press(KEY_LEFT_ALT);
      Keyboard.press('l');
      Keyboard.releaseAll();
      break;
	  
      case UBUNTU:
      // CTRL-ALT-DEL:
      Keyboard.press(KEY_LEFT_CTRL);
      Keyboard.press(KEY_LEFT_ALT);
      Keyboard.press(KEY_DELETE);
	  
      delay(1000);
      Keyboard.releaseAll();
	  
      // Enter to confirm logout:
      Keyboard.write(KEY_RETURN);
      break;
   }
   
   // do nothing:
   while (true);
}

Keyboard.releaseAll();

   // enter:
      Keyboard.write(KEY_RETURN);
      break;
      case WINDOWS:
	  
   // CTRL-ALT-DEL:
      Keyboard.press(KEY_LEFT_CTRL);
      Keyboard.press(KEY_LEFT_ALT);
      Keyboard.press(KEY_DELETE);
      delay(100);
      Keyboard.releaseAll();
	  
   //ALT-l:
      delay(2000);
      Keyboard.press(KEY_LEFT_ALT);
      Keyboard.press('l');
      Keyboard.releaseAll();
      break;
	  
   case UBUNTU:
      // CTRL-ALT-DEL:
      Keyboard.press(KEY_LEFT_CTRL);
      Keyboard.press(KEY_LEFT_ALT);
      Keyboard.press(KEY_DELETE);
      delay(1000);
      Keyboard.releaseAll();
	  
      // Enter to confirm logout:
      Keyboard.write(KEY_RETURN);
      break;
   }
   
// do nothing:
   while (true);
}
</pre>

<title>Arduino Keyboard Message</title>

<h1>Arduino - Keyboard Message</h1>

<p>In this example, when the button is pressed, a text string is sent to the computer as keyboard input. The string reports the number of times the button is pressed. Once you have the Leonardo programmed and wired up, open your favorite text editor to see the results.</p>

<p><b>Warning</b> &minus; When you use the <b>Keyboard.print()</b> command, the Arduino takes over your computer's keyboard. To ensure you do not lose control of your computer while running a sketch with this function, set up a reliable control system before you call <b>Keyboard.print()</b>. This sketch includes a pushbutton to toggle the keyboard, so that it only runs after the button is pressed.</p>

<h2>Components Required</h2>

<p>You will need the following components &minus;</p>

<h2>Procedure</h2>

<p>Follow the circuit diagram and hook up the components on the breadboard as shown in the image given below.</p>

<h2>Sketch</h2>

<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open a new sketch File by clicking New.</p>

<h2>Arduino Code</h2>

<h2>Code to Note</h2>

<p>Attach one terminal of the pushbutton to pin 4 on Arduino. Attach the other pin to 5V. Use the resistor as a pull-down, providing a reference to the ground, by attaching it from pin 4 to the ground.</p>

<p>Once you have programmed your board, unplug the USB cable, open a text editor and put the text cursor in the typing area. Connect the board to your computer through USB again and press the button to write in the document.</p>

<h2>Result</h2>

<p>By using any text editor, it will display the text sent via Arduino.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
/*
   Keyboard Message test For the Arduino Leonardo and Micro,
      Sends a text string when a button is pressed.
   The circuit:
   * pushbutton attached from pin 4 to +5V
   * 10-kilohm resistor attached from pin 4 to ground
*/

#include "Keyboard.h"
const int buttonPin = 4; // input pin for pushbutton
int previousButtonState = HIGH; // for checking the state of a pushButton
int counter = 0; // button push counter

void setup() {
   pinMode(buttonPin, INPUT); // make the pushButton pin an input:
   Keyboard.begin(); // initialize control over the keyboard:
}

void loop() {
   int buttonState = digitalRead(buttonPin); // read the pushbutton:
   if ((buttonState != previousButtonState)&amp;&amp; (buttonState == HIGH)) // and it's currently pressed: {
      // increment the button counter
      counter++;
      // type out a message
      Keyboard.print("You pressed the button ");
      Keyboard.print(counter);
      Keyboard.println(" times.");
   }
   // save the current button state for comparison next time:
   previousButtonState = buttonState;
}
</pre>

<title>Arduino Mouse Button Control</title>

<h1>Arduino - Mouse Button Control</h1>

<p>Using the Mouse library, you can control a computer's onscreen cursor with an Arduino Leonardo, Micro, or Due.</p>

<p>This particular example uses five pushbuttons to move the onscreen cursor. Four of the buttons are directional (up, down, left, right) and one is for a left mouse click. Cursor movement from Arduino is always relative. Every time an input is read, the cursor's position is updated relative to its current position.</p>

<p>Whenever one of the directional buttons is pressed, Arduino will move the mouse, mapping a HIGH input to a range of 5 in the appropriate direction.</p>

<p>The fifth button is for controlling a left-click from the mouse. When the button is released, the computer will recognize the event.</p>

<h2>Components Required</h2>

<p>You will need the following components &minus;</p>

<h2>Procedure</h2>

<p>Follow the circuit diagram and hook up the components on the breadboard as shown in the image below.</p>

<h2>Sketch</h2>

<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open a new sketch File by clicking New.</p>

<p>For this example, you need to use Arduino IDE 1.6.7</p>

<h2>Arduino Code</h2>

<h2>Code to Note</h2>

<p>Connect your board to your computer with a micro-USB cable. The buttons are connected to digital inputs from pins 2 to 6. Make sure you use 10k pull-down resistors.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
/*
   Button Mouse Control
   For Leonardo and Due boards only .Controls the mouse from 
   five pushbuttons on an Arduino Leonardo, Micro or Due.
   Hardware:
   * 5 pushbuttons attached to D2, D3, D4, D5, D6
   The mouse movement is always relative. This sketch reads
   four pushbuttons, and uses them to set the movement of the mouse.
   WARNING: When you use the Mouse.move() command, the Arduino takes
   over your mouse! Make sure you have control before you use the mouse commands.
*/

#include "Mouse.h"
// set pin numbers for the five buttons:
const int upButton = 2;
const int downButton = 3;
const int leftButton = 4;
const int rightButton = 5;
const int mouseButton = 6;
int range = 5; // output range of X or Y movement; affects movement speed
int responseDelay = 10; // response delay of the mouse, in ms

void setup() {
   // initialize the buttons' inputs:
   pinMode(upButton, INPUT);
   pinMode(downButton, INPUT);
   pinMode(leftButton, INPUT);
   pinMode(rightButton, INPUT);
   pinMode(mouseButton, INPUT);
   // initialize mouse control:
   Mouse.begin();
}

void loop() {
   // read the buttons:
   int upState = digitalRead(upButton);
   int downState = digitalRead(downButton);
   int rightState = digitalRead(rightButton);
   int leftState = digitalRead(leftButton);
   int clickState = digitalRead(mouseButton);
   // calculate the movement distance based on the button states:
   int xDistance = (leftState - rightState) * range;
   int yDistance = (upState - downState) * range;
   // if X or Y is non-zero, move:
   if ((xDistance != 0) || (yDistance != 0)) {
      Mouse.move(xDistance, yDistance, 0);
   }

   // if the mouse button is pressed:
   if (clickState == HIGH) {
      // if the mouse is not pressed, press it:
      if (!Mouse.isPressed(MOUSE_LEFT)) {
         Mouse.press(MOUSE_LEFT);
      }
   } else {                           // else the mouse button is not pressed:
      // if the mouse is pressed, release it:
      if (Mouse.isPressed(MOUSE_LEFT)) {
         Mouse.release(MOUSE_LEFT);
      }
   }
   // a delay so the mouse does not move too fast:
   delay(responseDelay);
}
</pre>

<title>Arduino Keyboard Serial</title>

<h1>Arduino - Keyboard Serial</h1>

<p>This example listens for a byte coming from the serial port. When received, the board sends a keystroke back to the computer. The sent keystroke is one higher than what is received, so if you send an "a" from the serial monitor, you will receive a "b" from the board connected to the computer. A "1" will return a "2" and so on.</p>

<p><b>Warning</b> &minus; When you use the <b>Keyboard.print()</b> command, the Leonardo, Micro or Due board takes over your computer's keyboard. To ensure you do not lose control of your computer while running a sketch with this function, set up a reliable control system before you call Keyboard.print(). This sketch is designed to only send a Keyboard command after the board has received a byte over the serial port.</p>

<h2>Components Required</h2>

<p>You will need the following components &minus;</p>

<h2>Procedure</h2>

<p>Just connect your board to the computer using USB cable.</p>

<h2>Sketch</h2>

<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open a new sketch File by clicking New.</p>

<p><b>Notes</b> &minus; You must include the keypad library in your Arduino library file. Copy and paste the keypad library file inside the file with the name ‘libraries’ highlighted with yellow color.</p>

<h2>Arduino Code</h2>

<h2>Code to Note</h2>

<p>Once programed, open your serial monitor and send a byte. The board will reply with a keystroke, that is one number higher.</p>

<h2>Result</h2>

<p>The board will reply with a keystroke that is one number higher on Arduino IDE serial monitor when you send a byte.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
/*
   Keyboard test
   For the Arduino Leonardo, Micro or Due Reads
      a byte from the serial port, sends a keystroke back. 
   The sent keystroke is one higher than what's received, e.g. if you send a, you get b, send
      A you get B, and so forth.
   The circuit:
   * none
*/

#include "Keyboard.h"

void setup() {
   // open the serial port:
   Serial.begin(9600);
   // initialize control over the keyboard:
   Keyboard.begin();
}

void loop() {
   // check for incoming serial data:
   if (Serial.available() &gt; 0) {
      // read incoming serial data:
      char inChar = Serial.read();
      // Type the next ASCII value from what you received:
      Keyboard.write(inChar + 1);
   }
}
</pre>

<title>Arduino Humidity Sensor</title>

<h1>Arduino - Humidity Sensor</h1>

<p>In this section, we will learn how to interface our Arduino board with different sensors. We will discuss the following sensors &minus;</p>

<h2>Humidity Sensor (DHT22)</h2>

<p>The DHT-22 (also named as AM2302) is a digital-output, relative humidity, and temperature sensor. It uses a capacitive humidity sensor and a thermistor to measure the surrounding air, and sends a digital signal on the data pin.</p>

<p>In this example, you will learn how to use this sensor with Arduino UNO. The room temperature and humidity will be printed to the serial monitor.</p>

<h2>The DHT-22 Sensor</h2>

<p>The connections are simple. The first pin on the left to 3-5V power, the second pin to the data input pin and the right-most pin to the ground.</p>

<h2>Technical Details</h2>

<p><b>Power</b> &minus; 3-5V</p>

<p><b>Max Current</b> &minus; 2.5mA</p>

<p><b>Humidity</b> &minus; 0-100%, 2-5% accuracy</p>

<p><b>Temperature</b> &minus; 40 to 80°C, ±0.5°C accuracy</p>

<h2>Components Required</h2>

<p>You will need the following components &minus;</p>

<h2>Procedure</h2>

<p>Follow the circuit diagram and hook up the components on the breadboard as shown in the image below.</p>

<p></p>

<h2>Sketch</h2>

<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open a new sketch File by clicking New.</p>

<h2>Arduino Code</h2>

<h2>Code to Note</h2>

<p>DHT22 sensor has four terminals (V<sub>cc</sub>, DATA, NC, GND), which are connected to the board as follows &minus;</p>

<p>Once hardware connections are done, you need to add DHT22 library to your Arduino library file as described earlier.</p>

<h2>Result</h2>

<p>You will see the temperature and humidity display on serial port monitor which is updated every 2 seconds.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
// Example testing sketch for various DHT humidity/temperature sensors

#include "DHT.h"
#define DHTPIN 2 // what digital pin we're connected to
// Uncomment whatever type you're using!
//#define DHTTYPE DHT11 // DHT 11
#define DHTTYPE DHT22 // DHT 22 (AM2302), AM2321
//#define DHTTYPE DHT21 // DHT 21 (AM2301)
// Connect pin 1 (on the left) of the sensor to +5V
// NOTE: If using a board with 3.3V logic like an Arduino Due connect pin 1
// to 3.3V instead of 5V!
// Connect pin 2 of the sensor to whatever your DHTPIN is
// Connect pin 4 (on the right) of the sensor to GROUND
// Connect a 10K resistor from pin 2 (data) to pin 1 (power) of the sensor
// Initialize DHT sensor.
// Note that older versions of this library took an optional third parameter to
// tweak the timings for faster processors. This parameter is no longer needed
// as the current DHT reading algorithm adjusts itself to work on faster procs.
DHT dht(DHTPIN, DHTTYPE);

void setup() {
   Serial.begin(9600);
   Serial.println("DHTxx test!");
   dht.begin();
}

void loop() {
   delay(2000); // Wait a few seconds between measurements
   float h = dht.readHumidity();
   // Reading temperature or humidity takes about 250 milliseconds!
   float t = dht.readTemperature();
   // Read temperature as Celsius (the default)
   float f = dht.readTemperature(true);
   // Read temperature as Fahrenheit (isFahrenheit = true)
   // Check if any reads failed and exit early (to try again).
   if (isnan(h) || isnan(t) || isnan(f)) {
      Serial.println("Failed to read from DHT sensor!");
      return;
   }
   
   // Compute heat index in Fahrenheit (the default)
   float hif = dht.computeHeatIndex(f, h);
   // Compute heat index in Celsius (isFahreheit = false)
   float hic = dht.computeHeatIndex(t, h, false);
   Serial.print ("Humidity: ");
   Serial.print (h);
   Serial.print (" %\t");
   Serial.print ("Temperature: ");
   Serial.print (t);
   Serial.print (" *C ");
   Serial.print (f);
   Serial.print (" *F\t");
   Serial.print ("Heat index: ");
   Serial.print (hic);
   Serial.print (" *C ");
   Serial.print (hif);
   Serial.println (" *F");
}
</pre>

<title>Arduino Temperature Sensor</title>

<h1>Arduino - Temperature Sensor</h1>

<p>The Temperature Sensor LM35 series are precision integrated-circuit temperature devices with an output voltage linearly proportional to the Centigrade temperature.</p>

<p>The LM35 device has an advantage over linear temperature sensors calibrated in Kelvin, as the user is not required to subtract a large constant voltage from the output to obtain convenient Centigrade scaling. The LM35 device does not require any external calibration or trimming to provide typical accuracies of ±¼°C at room temperature and ±¾°C over a full −55°C to 150°C temperature range.</p>

<h2>Technical Specifications</h2>

<h2>Components Required</h2>

<p>You will need the following components &minus;</p>

<h2>Procedure</h2>

<p>Follow the circuit diagram and hook up the components on the breadboard as shown in the image given below.</p>

<h2>Sketch</h2>

<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open a new sketch File by clicking New.</p>

<h2>Arduino Code</h2>

<h2>Code to Note</h2>

<p>LM35 sensor has three terminals - V<sub>s</sub>, V<sub>out</sub> and GND. We will connect the sensor as follows &minus;</p>

<p>The Analog to Digital Converter (ADC) converts analog values into a digital approximation based on the formula ADC Value = sample * 1024 / reference voltage (&plus;5v). So with a &plus;5 volt reference, the digital approximation will be equal to input voltage * 205.</p>

<h2>Result</h2>

<p>You will see the temperature display on the serial port monitor which is updated every second.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
float temp;
int tempPin = 0;

void setup() {
   Serial.begin(9600);
}

void loop() {
   temp = analogRead(tempPin);
   // read analog volt from sensor and save to variable temp
   temp = temp * 0.48828125;
   // convert the analog volt to its temperature equivalent
   Serial.print("TEMPERATURE = ");
   Serial.print(temp); // display temperature value
   Serial.print("*C");
   Serial.println();
   delay(1000); // update sensor reading each one second
}
</pre>

<title>Arduino Water Detector / Sensor</title>

<h1>Arduino - Water Detector / Sensor</h1>

<p>Water sensor brick is designed for water detection, which can be widely used in sensing rainfall, water level, and even liquid leakage.</p>

<p>Connecting a water sensor to an Arduino is a great way to detect a leak, spill, flood, rain, etc. It can be used to detect the presence, the level, the volume and/or the absence of water. While this could be used to remind you to water your plants, there is a better Grove sensor for that. The sensor has an array of exposed traces, which read LOW when water is detected.</p>

<p>In this chapter, we will connect the water sensor to Digital Pin 8 on Arduino, and will enlist the very handy LED to help identify when the water sensor comes into contact with a source of water.</p>

<h2>Components Required</h2>

<p>You will need the following components &minus;</p>

<h2>Procedure</h2>

<p>Follow the circuit diagram and hook up the components on the breadboard as shown in the image given below.</p>

<h2>Sketch</h2>

<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open a new sketch File by clicking on New.</p>

<h2>Arduino Code</h2>

<h2>Code to Note</h2>

<p>Water sensor has three terminals - S, V<sub>out</sub>(&plus;), and GND (-). Connect the sensor as follows &minus;</p>

<p>When the sensor detects water, pin 8 on Arduino becomes LOW and then the LED on Arduino is turned ON.</p>

<h2>Result</h2>

<p>You will see the indication LED turn ON when the sensor detects water.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
#define Grove_Water_Sensor 8 // Attach Water sensor to Arduino Digital Pin 8
#define LED 9 // Attach an LED to Digital Pin 9 (or use onboard LED)

void setup() {
   pinMode(Grove_Water_Sensor, INPUT); // The Water Sensor is an Input
   pinMode(LED, OUTPUT); // The LED is an Output
}

void loop() {
   /* The water sensor will switch LOW when water is detected.
   Get the Arduino to illuminate the LED and activate the buzzer
   when water is detected, and switch both off when no water is present */
   if( digitalRead(Grove_Water_Sensor) == LOW) {
      digitalWrite(LED,HIGH);
   }else {
      digitalWrite(LED,LOW);
   }
}
</pre>

<title>Arduino PIR Sensor</title>

<h1>Arduino - PIR Sensor</h1>

<p>PIR sensors allow you to sense motion. They are used to detect whether a human has moved in or out of the sensor’s range. They are commonly found in appliances and gadgets used at home or for businesses. They are often referred to as PIR, "Passive Infrared", "Pyroelectric", or "IR motion" sensors.</p>

<p>Following are the advantages of PIR Sensors &minus;</p>

<p>PIRs are made of pyroelectric sensors, a round metal can with a rectangular crystal in the center, which can detect levels of infrared radiation. Everything emits low-level radiation, and the hotter something is, the more radiation is emitted. The sensor in a motion detector is split in two halves. This is to detect motion (change) and not average IR levels. The two halves are connected so that they cancel out each other. If one-half sees more or less IR radiation than the other, the output will swing high or low.</p>

<p>PIRs have adjustable settings and have a header installed in the 3-pin ground/out/power pads.</p>

<p>For many basic projects or products that need to detect when a person has left or entered the area, PIR sensors are great. Note that PIRs do not tell you the number of people around or their closeness to the sensor. The lens is often fixed to a certain sweep at a distance and they are sometimes set off by the pets in the house.</p>

<h2>Components Required</h2>

<p>You will need the following components &minus;</p>

<h2>Procedure</h2>

<p>Follow the circuit diagram and make the connections as shown in the image below.</p>

<h2>Sketch</h2>

<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open a new sketch File by clicking New.</p>

<h2>Arduino Code</h2>

<h2>Code to Note</h2>

<p>PIR sensor has three terminals - V<sub>cc</sub>, OUT and GND. Connect the sensor as follows &minus;</p>

<p>You can adjust the sensor sensitivity and delay time via two variable resistors located at the bottom of the sensor board.</p>

<p>Once the sensor detects any motion, Arduino will send a message via the serial port to say that a motion is detected. The PIR sense motion will delay for certain time to check if there is a new motion. If there is no motion detected, Arduino will send a new message saying that the motion has ended.</p>

<h2>Result</h2>

<p>You will see a message on your serial port if a motion is detected and another message when the motion stops.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
#define pirPin 2
int calibrationTime = 30;
long unsigned int lowIn;
long unsigned int pause = 5000;
boolean lockLow = true;
boolean takeLowTime;
int PIRValue = 0;

void setup() {
   Serial.begin(9600);
   pinMode(pirPin, INPUT);
}

void loop() {
   PIRSensor();
}

void PIRSensor() {
   if(digitalRead(pirPin) == HIGH) {
      if(lockLow) {
         PIRValue = 1;
         lockLow = false;
         Serial.println("Motion detected.");
         delay(50);
      }
      takeLowTime = true;
   }
   if(digitalRead(pirPin) == LOW) {
      if(takeLowTime){
         lowIn = millis();takeLowTime = false;
      }
      if(!lockLow &amp;&amp; millis() - lowIn &gt; pause) {
         PIRValue = 0;
         lockLow = true;
         Serial.println("Motion ended.");
         delay(50);
      }
   }
}
</pre>

<title>Arduino Ultrasonic Sensor</title>

<h1>Arduino - Ultrasonic Sensor</h1>

<p>The HC-SR04 ultrasonic sensor uses SONAR to determine the distance of an object just like the bats do. It offers excellent non-contact range detection with high accuracy and stable readings in an easy-to-use package from 2 cm to 400 cm or 1” to 13 feet.</p>

<p>The operation is not affected by sunlight or black material, although acoustically, soft materials like cloth can be difficult to detect. It comes complete with ultrasonic transmitter and receiver module.</p>

<p></p>

<h2>Technical Specifications</h2>

<h2>Components Required</h2>

<p>You will need the following components &minus;</p>

<h2>Procedure</h2>

<p>Follow the circuit diagram and make the connections as shown in the image given below.</p>

<h2>Sketch</h2>

<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open a new sketch File by clicking New.</p>

<h2>Arduino Code</h2>

<h2>Code to Note</h2>

<p>The Ultrasonic sensor has four terminals - &plus;5V, Trigger, Echo, and GND connected as follows &minus;</p>

<p>In our program, we have displayed the distance measured by the sensor in inches and cm via the serial port.</p>

<h2>Result</h2>

<p>You will see the distance measured by sensor in inches and cm on Arduino serial monitor.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
const int pingPin = 7; // Trigger Pin of Ultrasonic Sensor
const int echoPin = 6; // Echo Pin of Ultrasonic Sensor

void setup() {
   Serial.begin(9600); // Starting Serial Terminal
}

void loop() {
   long duration, inches, cm;
   pinMode(pingPin, OUTPUT);
   digitalWrite(pingPin, LOW);
   delayMicroseconds(2);
   digitalWrite(pingPin, HIGH);
   delayMicroseconds(10);
   digitalWrite(pingPin, LOW);
   pinMode(echoPin, INPUT);
   duration = pulseIn(echoPin, HIGH);
   inches = microsecondsToInches(duration);
   cm = microsecondsToCentimeters(duration);
   Serial.print(inches);
   Serial.print("in, ");
   Serial.print(cm);
   Serial.print("cm");
   Serial.println();
   delay(100);
}

long microsecondsToInches(long microseconds) {
   return microseconds / 74 / 2;
}

long microsecondsToCentimeters(long microseconds) {
   return microseconds / 29 / 2;
}
</pre>

<title>Arduino Connecting Switch</title>

<h1>Arduino - Connecting Switch</h1>

<p>Pushbuttons or switches connect two open terminals in a circuit. This example turns on the LED on pin 2 when you press the pushbutton switch connected to pin 8.</p>

<h2>Pull-down Resistor</h2>

<p>Pull-down resistors are used in electronic logic circuits to ensure that inputs to Arduino settle at expected logic levels if external devices are disconnected or are at high-impedance. As nothing is connected to an input pin, it does not mean that it is a logical zero. Pull down resistors are connected between the ground and the appropriate pin on the device.</p>

<p>An example of a pull-down resistor in a digital circuit is shown in the following figure. A pushbutton switch is connected between the supply voltage and a microcontroller pin. In such a circuit, when the switch is closed, the micro-controller input is at a logical high value, but when the switch is open, the pull-down resistor pulls the input voltage down to the ground (logical zero value), preventing an undefined state at the input.</p>

<p>The pull-down resistor must have a larger resistance than the impedance of the logic circuit, or else it might pull the voltage down too much and the input voltage at the pin would remain at a constant logical low value, regardless of the switch position.</p>

<h2>Components Required</h2>

<p>You will need the following components &minus;</p>

<h2>Procedure</h2>

<p>Follow the circuit diagram and make the connections as shown in the image given below.</p>

<h2>Sketch</h2>

<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open a new sketch File by clicking on New.</p>

<h2>Arduino Code</h2>

<h2>Code to Note</h2>

<p>When the switch is open, (pushbutton is not pressed), there is no connection between the two terminals of the pushbutton, so the pin is connected to the ground (through the pull-down resistor) and we read a LOW. When the switch is closed (pushbutton is pressed), it makes a connection between its two terminals, connecting the pin to 5 volts, so that we read a HIGH.</p>

<h2>Result</h2>

<p>LED is turned ON when the pushbutton is pressed and OFF when it is released.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
// constants won't change. They're used here to
// set pin numbers:
const int buttonPin = 8; // the number of the pushbutton pin
const int ledPin = 2; // the number of the LED pin
// variables will change:
int buttonState = 0; // variable for reading the pushbutton status

void setup() {
   // initialize the LED pin as an output:
   pinMode(ledPin, OUTPUT);
   // initialize the pushbutton pin as an input:
   pinMode(buttonPin, INPUT);
}

void loop() {
   // read the state of the pushbutton value:
   buttonState = digitalRead(buttonPin);
   // check if the pushbutton is pressed.
   // if it is, the buttonState is HIGH:
   if (buttonState == HIGH) {
      // turn LED on:
      digitalWrite(ledPin, HIGH);
   } else {
      // turn LED off:
      digitalWrite(ledPin, LOW);
   }
}
</pre>

<title>Arduino DC Motor</title>

<h1>Arduino - DC Motor</h1>

<p>In this chapter, we will interface different types of motors with the Arduino board (UNO) and show you how to connect the motor and drive it from your board.</p>

<p>There are three different type of motors &minus;</p>

<p>A DC motor (Direct Current motor) is the most common type of motor. DC motors normally have just two leads, one positive and one negative. If you connect these two leads directly to a battery, the motor will rotate. If you switch the leads, the motor will rotate in the opposite direction.</p>

<p><b>Warning</b> &minus; Do not drive the motor directly from Arduino board pins. This may damage the board. Use a driver Circuit or an IC.</p>

<p>We will divide this chapter into three parts &minus;</p>

<h3>Components Required</h3>

<p>You will need the following components &minus;</p>

<h3>Procedure</h3>

<p>Follow the circuit diagram and make the connections as shown in the image given below.</p>

<h3>Precautions</h3>

<p>Take the following precautions while making the connections.</p>

<p>First, make sure that the transistor is connected in the right way. The flat side of the transistor should face the Arduino board as shown in the arrangement.</p>

<p>Second, the striped end of the diode should be towards the +5V power line according to the arrangement shown in the image.</p>

<h3>Spin ControlArduino Code</h3>

<h3>Code to Note</h3>

<p>The transistor acts like a switch, controlling the power to the motor. Arduino pin 3 is used to turn the transistor on and off and is given the name 'motorPin' in the sketch.</p>

<h3>Result</h3>

<p>Motor will spin in full speed when the Arduino pin number 3 goes high.</p>

<h2>Motor Speed Control</h2>

<p>Following is the schematic diagram of a DC motor, connected to the Arduino board.</p>

<h3>Arduino Code</h3>

<h3>Code to Note</h3>

<p>The transistor acts like a switch, controlling the power of the motor. Arduino pin 3 is used to turn the transistor on and off and is given the name 'motorPin' in the sketch.</p>

<p>When the program starts, it prompts you to give the values to control the speed of the motor. You need to enter a value between 0 and 255 in the Serial Monitor.</p>

<p>In the 'loop' function, the command 'Serial.parseInt' is used to read the number entered as text in the Serial Monitor and convert it into an 'int'. You can type any number here. The 'if' statement in the next line simply does an analog write with this number, if the number is between 0 and 255.</p>

<h3>Result</h3>

<p>The DC motor will spin with different speeds according to the value (0 to 250) received via the serial port.</p>

<h2>Spin Direction Control</h2>

<p>To control the direction of the spin of DC motor, without interchanging the leads, you can use a circuit called an <b>H-Bridge</b>. An H-bridge is an electronic circuit that can drive the motor in both directions. H-bridges are used in many different applications. One of the most common application is to control motors in robots. It is called an H-bridge because it uses four transistors connected in such a way that the schematic diagram looks like an "H."</p>

<p>We will be using the L298 H-Bridge IC here. The L298 can control the speed and direction of DC motors and stepper motors, and can control two motors simultaneously. Its current rating is 2A for each motor. At these currents, however, you will need to use heat sinks.</p>

<h3>Components Required</h3>

<p>You will need the following components &minus;</p>

<h3>Procedure</h3>

<p>Following is the schematic diagram of the DC motor interface to Arduino Uno board.</p>

<p>The above diagram shows how to connect the L298 IC to control two motors. There are three input pins for each motor, Input1 (IN1), Input2 (IN2), and Enable1 (EN1) for Motor1 and Input3, Input4, and Enable2 for Motor2.</p>

<p>Since we will be controlling only one motor in this example, we will connect the Arduino to IN1 (pin 5), IN2 (pin 7), and Enable1 (pin 6) of the L298 IC. Pins 5 and 7 are digital, i.e. ON or OFF inputs, while pin 6 needs a pulse-width modulated (PWM) signal to control the motor speed.</p>

<p>The following table shows which direction the motor will turn based on the digital values of IN1 and IN2.</p>

<p>Pin IN1 of the IC L298 is connected to pin 8 of Arduino while IN2 is connected to pin 9. These two digital pins of Arduino control the direction of the motor. The EN A pin of IC is connected to the PWM pin 2 of Arduino. This will control the speed of the motor.</p>

<p>To set the values of Arduino pins 8 and 9, we have used the digitalWrite() function, and to set the value of pin 2, we have to use the analogWrite() function.</p>

<h3>Connection Steps</h3>

<h3>Arduino Code</h3>

<h3>Result</h3>

<p>The motor will run first in the clockwise (CW) direction for 3 seconds and then counter-clockwise (CCW) for 3 seconds.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
int motorPin = 3;

void setup() {

}

void loop() {
   digitalWrite(motorPin, HIGH);
}
</pre>
<h3>Code to Note</h3>
<p>The transistor acts like a switch, controlling the power to the motor. Arduino pin 3 is used to turn the transistor on and off and is given the name 'motorPin' in the sketch.</p>
<h3>Result</h3>
<p>Motor will spin in full speed when the Arduino pin number 3 goes high.</p>
<h2>Motor Speed Control</h2>
<p>Following is the schematic diagram of a DC motor, connected to the Arduino board.</p>
<img src="/arduino/images/motor_speed_control.jpg" alt="Motor Speed Control" />
<h3>Arduino Code</h3>
<pre class="prettyprint notranslate">
int motorPin = 9;

void setup() {
   pinMode(motorPin, OUTPUT);
   Serial.begin(9600);
   while (! Serial);
   Serial.println("Speed 0 to 255");
}

void loop() {
   if (Serial.available()) {
      int speed = Serial.parseInt();
      if (speed &gt;= 0 &amp;&amp; speed &lt;= 255) {
         analogWrite(motorPin, speed);
      }
   }
}
</pre>
<h3>Code to Note</h3>
<p>The transistor acts like a switch, controlling the power of the motor. Arduino pin 3 is used to turn the transistor on and off and is given the name 'motorPin' in the sketch.</p>
<p>When the program starts, it prompts you to give the values to control the speed of the motor. You need to enter a value between 0 and 255 in the Serial Monitor.</p>
<img src="/arduino/images/command_window.jpg" alt="Command Window" />
<p>In the 'loop' function, the command 'Serial.parseInt' is used to read the number entered as text in the Serial Monitor and convert it into an 'int'. You can type any number here. The 'if' statement in the next line simply does an analog write with this number, if the number is between 0 and 255.</p>
<h3>Result</h3>
<p>The DC motor will spin with different speeds according to the value (0 to 250) received via the serial port.</p>
<h2>Spin Direction Control</h2>
<p>To control the direction of the spin of DC motor, without interchanging the leads, you can use a circuit called an <b>H-Bridge</b>. An H-bridge is an electronic circuit that can drive the motor in both directions. H-bridges are used in many different applications. One of the most common application is to control motors in robots. It is called an H-bridge because it uses four transistors connected in such a way that the schematic diagram looks like an "H."</p>
<p>We will be using the L298 H-Bridge IC here. The L298 can control the speed and direction of DC motors and stepper motors, and can control two motors simultaneously. Its current rating is 2A for each motor. At these currents, however, you will need to use heat sinks.</p>
<img src="/arduino/images/spin_direction_control.jpg" alt="Spin Direction Control" />
<h3>Components Required</h3>
<p>You will need the following components &minus;</p>
<ul class="list">
<li>1 &times; L298 bridge IC</li>
<li>1 &times; DC motor</li>
<li>1 &times; Arduino UNO</li>
<li>1 &times; breadboard</li>
<li>10 &times; jumper wires</li>
</ul>
<h3>Procedure</h3>
<p>Following is the schematic diagram of the DC motor interface to Arduino Uno board.</p>
<img src="/arduino/images/spin_direction_control_connections.jpg" alt="Spin Direction Control Connections" />
<p>The above diagram shows how to connect the L298 IC to control two motors. There are three input pins for each motor, Input1 (IN1), Input2 (IN2), and Enable1 (EN1) for Motor1 and Input3, Input4, and Enable2 for Motor2.</p>
<p>Since we will be controlling only one motor in this example, we will connect the Arduino to IN1 (pin 5), IN2 (pin 7), and Enable1 (pin 6) of the L298 IC. Pins 5 and 7 are digital, i.e. ON or OFF inputs, while pin 6 needs a pulse-width modulated (PWM) signal to control the motor speed.</p>
<p>The following table shows which direction the motor will turn based on the digital values of IN1 and IN2.</p>
<table class="table table-bordered" style="text-align:center;">
<tr>
<th style="text-align:center;">IN1</th>
<th style="text-align:center;">IN2</th>
<th style="text-align:center;">Motor Behavior</th>
</tr>
<tr>
<td></td>
<td></td>
<td>BRAKE</td>
</tr>
<tr>
<td>1</td>
<td></td>
<td>FORWARD</td>
</tr>
<tr>
<td></td>
<td>1</td>
<td>BACKWARD</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>BRAKE</td>
</tr>
</table>
<p>Pin IN1 of the IC L298 is connected to pin 8 of Arduino while IN2 is connected to pin 9. These two digital pins of Arduino control the direction of the motor. The EN A pin of IC is connected to the PWM pin 2 of Arduino. This will control the speed of the motor.</p>
<p>To set the values of Arduino pins 8 and 9, we have used the digitalWrite() function, and to set the value of pin 2, we have to use the analogWrite() function.</p>
<h3>Connection Steps</h3>
<ul class="list">
<li>Connect 5V and the ground of the IC to 5V and the ground of Arduino, respectively.</li>
<li>Connect the motor to pins 2 and 3 of the IC.</li>
<li>Connect IN1 of the IC to pin 8 of Arduino.</li>
<li>Connect IN2 of the IC to pin 9 of Arduino.</li>
<li>Connect EN1 of IC to pin 2 of Arduino.</li>
<li>Connect SENS A pin of IC to the ground.</li>
<li>Connect Arduino using Arduino USB cable and upload the program to Arduino using Arduino IDE software.</li>
<li>Provide power to Arduino board using power supply, battery, or USB cable.</li>
</ul>
<h3>Arduino Code</h3>
<pre class="prettyprint notranslate">
const int pwm = 2 ; //initializing pin 2 as pwm
const int in_1 = 8 ;
const int in_2 = 9 ;
//For providing logic to L298 IC to choose the direction of the DC motor

void setup() {
   pinMode(pwm,OUTPUT) ; //we have to set PWM pin as output
   pinMode(in_1,OUTPUT) ; //Logic pins are also set as output
   pinMode(in_2,OUTPUT) ;
}

void loop() {
   //For Clock wise motion , in_1 = High , in_2 = Low
   digitalWrite(in_1,HIGH) ;
   digitalWrite(in_2,LOW) ;
   analogWrite(pwm,255) ;
   /* setting pwm of the motor to 255 we can change the speed of rotation
   by changing pwm input but we are only using arduino so we are using highest
   value to driver the motor */
   //Clockwise for 3 secs
   delay(3000) ;
   //For brake
   digitalWrite(in_1,HIGH) ;
   digitalWrite(in_2,HIGH) ;
   delay(1000) ;
   //For Anti Clock-wise motion - IN_1 = LOW , IN_2 = HIGH
   digitalWrite(in_1,LOW) ;
   digitalWrite(in_2,HIGH) ;
   delay(3000) ;
   //For brake
   digitalWrite(in_1,HIGH) ;
   digitalWrite(in_2,HIGH) ;
   delay(1000) ;
}
</pre>

<title>Arduino Servo Motor</title>

<h1>Arduino - Servo Motor</h1>

<p>A Servo Motor is a small device that has an output shaft. This shaft can be positioned to specific angular positions by sending the servo a coded signal. As long as the coded signal exists on the input line, the servo will maintain the angular position of the shaft. If the coded signal changes, the angular position of the shaft changes. In practice, servos are used in radio-controlled airplanes to position control surfaces like the elevators and rudders. They are also used in radio-controlled cars, puppets, and of course, robots.</p>

<p>Servos are extremely useful in robotics. The motors are small, have built-in control circuitry, and are extremely powerful for their size. A standard servo such as the Futaba S-148 has 42 oz/inches of torque, which is strong for its size. It also draws power proportional to the mechanical load. A lightly loaded servo, therefore, does not consume much energy.</p>

<p>The guts of a servo motor is shown in the following picture. You can see the control circuitry, the motor, a set of gears, and the case. You can also see the 3 wires that connect to the outside world. One is for power (+5volts), ground, and the white wire is the control wire.</p>

<h2>Working of a Servo Motor</h2>

<p>The servo motor has some control circuits and a potentiometer (a variable resistor, aka pot) connected to the output shaft. In the picture above, the pot can be seen on the right side of the circuit board. This pot allows the control circuitry to monitor the current angle of the servo motor.</p>

<p>If the shaft is at the correct angle, then the motor shuts off. If the circuit finds that the angle is not correct, it will turn the motor until it is at a desired angle. The output shaft of the servo is capable of traveling somewhere around 180 degrees. Usually, it is somewhere in the 210-degree range, however, it varies depending on the manufacturer. A normal servo is used to control an angular motion of 0 to 180 degrees. It is mechanically not capable of turning any farther due to a mechanical stop built on to the main output gear.</p>

<p>The power applied to the motor is proportional to the distance it needs to travel. So, if the shaft needs to turn a large distance, the motor will run at full speed. If it needs to turn only a small amount, the motor will run at a slower speed. This is called <b>proportional control</b>.</p>

<h2>How Do You Communicate the Angle at Which the Servo Should Turn?</h2>

<p>The control wire is used to communicate the angle. The angle is determined by the duration of a pulse that is applied to the control wire. This is called <b>Pulse Coded Modulation</b>. The servo expects to see a pulse every 20 milliseconds (.02 seconds). The length of the pulse will determine how far the motor turns. A 1.5 millisecond pulse, for example, will make the motor turn to the 90-degree position (often called as the neutral position). If the pulse is shorter than 1.5 milliseconds, then the motor will turn the shaft closer to 0 degrees. If the pulse is longer than 1.5 milliseconds, the shaft turns closer to 180 degrees.</p>

<h2>Components Required</h2>

<p>You will need the following components &minus;</p>

<h2>Procedure</h2>

<p>Follow the circuit diagram and make the connections as shown in the image given below.</p>

<h2>Sketch</h2>

<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open a new sketch File by clicking on New.</p>

<h2>Arduino Code</h2>

<h2>Code to Note</h2>

<p>Servo motors have three terminals - power, ground, and signal. The power wire is typically red, and should be connected to the 5V pin on the Arduino. The ground wire is typically black or brown and should be connected to one terminal of ULN2003 IC (10 -16). To protect your Arduino board from damage, you will need some driver IC to do that. Here we have used ULN2003 IC to drive the servo motor. The signal pin is typically yellow or orange and should be connected to Arduino pin number 9.</p>

<h2>Connecting the Potentiometer</h2>

<p>A voltage divider/potential divider are resistors in a series circuit that scale the output voltage to a particular ratio of the input voltage applied. Following is the circuit diagram &minus;</p>

<p>$$V_{out} = (V_{in} \times R_{2})/ (R_{1} + R_{2})$$</p>

<p>V<sub>out</sub> is the output potential, which depends on the applied input voltage (V<sub>in</sub>) and resistors (R<sub>1</sub> and R<sub>2</sub>) in the series. It means that the current flowing through R<sub>1</sub> will also flow through R<sub>2</sub> without being divided. In the above equation, as the value of R<sub>2</sub> changes, the V<sub>out</sub> scales accordingly with respect to the input voltage, V<sub>in</sub>.</p>

<p>Typically, a potentiometer is a potential divider, which can scale the output voltage of the circuit based on the value of the variable resistor, which is scaled using the knob. It has three pins: GND, Signal, and +5V as shown in the diagram below &minus;</p>

<h2>Result</h2>

<p>By changing the pot’s NOP position, servo motor will change its angle.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
/* Controlling a servo position using a potentiometer (variable resistor) */

#include &lt;Servo.h&gt;
   Servo myservo; // create servo object to control a servo
   int potpin = 0; // analog pin used to connect the potentiometer
   int val; // variable to read the value from the analog pin

void setup() {
   myservo.attach(9); // attaches the servo on pin 9 to the servo object
}

void loop() {
   val = analogRead(potpin);
   // reads the value of the potentiometer (value between 0 and 1023)
   val = map(val, 0, 1023, 0, 180);
   // scale it to use it with the servo (value between 0 and 180)
   myservo.write(val); // sets the servo position according to the scaled value
   delay(15);
}
</pre>

<title>Arduino Stepper Motor</title>

<h1>Arduino - Stepper Motor</h1>

<p>A Stepper Motor or a step motor is a brushless, synchronous motor, which divides a full rotation into a number of steps. Unlike a brushless DC motor, which rotates continuously when a fixed DC voltage is applied to it, a step motor rotates in discrete step angles.</p>

<p>The Stepper Motors therefore are manufactured with steps per revolution of 12, 24, 72, 144, 180, and 200, resulting in stepping angles of 30, 15, 5, 2.5, 2, and 1.8 degrees per step. The stepper motor can be controlled with or without feedback.</p>

<p>Imagine a motor on an RC airplane. The motor spins very fast in one direction or another. You can vary the speed with the amount of power given to the motor, but you cannot tell the propeller to stop at a specific position.</p>

<p>Now imagine a printer. There are lots of moving parts inside a printer, including motors. One such motor acts as the paper feed, spinning rollers that move the piece of paper as ink is being printed on it. This motor needs to be able to move the paper an exact distance to be able to print the next line of text or the next line of an image.</p>

<p>There is another motor attached to a threaded rod that moves the print head back and forth. Again, that threaded rod needs to be moved an exact amount to print one letter after another. This is where the stepper motors come in handy.</p>

<h2>How a Stepper Motor Works?</h2>

<p>A regular DC motor spins in only direction whereas a Stepper motor can spin in precise increments.</p>

<p>Stepper motors can turn an exact amount of degrees (or steps) as desired. This gives you total control over the motor, allowing you to move it to an exact location and hold that position. It does so by powering the coils inside the motor for very short periods of time. The disadvantage is that you have to power the motor all the time to keep it in the position that you desire.</p>

<p>All you need to know for now is that, to move a stepper motor, you tell it to move a certain number of steps in one direction or the other, and tell it the speed at which to step in that direction. There are numerous varieties of stepper motors. The methods described here can be used to infer how to use other motors and drivers which are not mentioned in this tutorial. However, it is always recommended that you consult the datasheets and guides of the motors and drivers specific to the models you have.</p>

<h2>Components Required</h2>

<p>You will need the following components &minus;</p>

<h2>Procedure</h2>

<p>Follow the circuit diagram and make the connections as shown in the image given below.</p>

<h2>Sketch</h2>

<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open a new sketch File by clicking New.</p>

<h2>Arduino Code</h2>

<h2>Code to Note</h2>

<p>This program drives a unipolar or bipolar stepper motor. The motor is attached to digital pins 8 - 11 of Arduino.</p>

<h2>Result</h2>

<p>The motor will take one revolution in one direction, then one revolution in the other direction.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
/* Stepper Motor Control */

#include &lt;Stepper.h&gt;
const int stepsPerRevolution = 90;
// change this to fit the number of steps per revolution
// for your motor
// initialize the stepper library on pins 8 through 11:
Stepper myStepper(stepsPerRevolution, 8, 9, 10, 11);

void setup() {
   // set the speed at 60 rpm:
   myStepper.setSpeed(5);
   // initialize the serial port:
   Serial.begin(9600);
}

void loop() {
   // step one revolution in one direction:
   Serial.println("clockwise");
   myStepper.step(stepsPerRevolution);
   delay(500);
   // step one revolution in the other direction:
   Serial.println("counterclockwise");
   myStepper.step(-stepsPerRevolution);
   delay(500);
}
</pre>

<title>Arduino Tone Library</title>

<h1>Arduino - Tone Library</h1>

<p>In this chapter, we will use the Arduino Tone Library. It is nothing but an Arduino Library, which produces square-wave of a specified frequency (and 50% duty cycle) on any Arduino pin. A duration can optionally be specified, otherwise the wave continues until the stop() function is called. The pin can be connected to a piezo buzzer or a speaker to play the tones.</p>

<p><b>Warning</b> &minus; Do not connect the pin directly to any audio input. The voltage is considerably higher than the standard line level voltages, and can damage sound card inputs, etc. You can use a voltage divider to bring the voltage down.</p>

<h2>Components Required</h2>

<p>You will need the following components &minus;</p>

<h2>Procedure</h2>

<p>Follow the circuit diagram and make the connections as shown in the image given below.</p>

<h2>Sketch</h2>

<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open a new sketch File by clicking New.</p>

<p>To make the pitches.h file, either click the button just below the serial monitor icon and choose "New Tab", or use Ctrl+Shift+N.</p>

<p>Then paste the following code &minus;</p>

<p>Save the above given code as <b>pitches.h</b></p>

<h2>Arduino Code</h2>

<h2>Code to Note</h2>

<p>The code uses an extra file, pitches.h. This file contains all the pitch values for typical notes. For example, NOTE_C4 is middle C. NOTE_FS4 is F sharp, and so forth. This note table was originally written by Brett Hagman, on whose work the tone() command was based. You may find it useful whenever you want to make musical notes.</p>

<h2>Result</h2>

<p>You will hear musical notes saved in the pitches.h. file.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
/*************************************************
* Public Constants
*************************************************/

#define NOTE_B0 31
#define NOTE_C1 33
#define NOTE_CS1 35
#define NOTE_D1 37
#define NOTE_DS1 39
#define NOTE_E1 41
#define NOTE_F1 44
#define NOTE_FS1 46
#define NOTE_G1 49
#define NOTE_GS1 52
#define NOTE_A1 55
#define NOTE_AS1 58
#define NOTE_B1 62
#define NOTE_C2 65
#define NOTE_CS2 69
#define NOTE_D2 73
#define NOTE_DS2 78
#define NOTE_E2 82
#define NOTE_F2 87
#define NOTE_FS2 93
#define NOTE_G2 98
#define NOTE_GS2 104
#define NOTE_A2 110
#define NOTE_AS2 117
#define NOTE_B2 123
#define NOTE_C3 131
#define NOTE_CS3 139
#define NOTE_D3 147
#define NOTE_DS3 156
#define NOTE_E3 165
#define NOTE_F3 175
#define NOTE_FS3 185
#define NOTE_G3 196
#define NOTE_GS3 208
#define NOTE_A3 220
#define NOTE_AS3 233
#define NOTE_B3 247
#define NOTE_C4 262
#define NOTE_CS4 277
#define NOTE_D4 294
#define NOTE_DS4 311
#define NOTE_E4 330
#define NOTE_F4 349
#define NOTE_FS4 370
#define NOTE_G4 392
#define NOTE_GS4 415
#define NOTE_A4 440
#define NOTE_AS4 466
#define NOTE_B4 494
#define NOTE_C5 523
#define NOTE_CS5 554
#define NOTE_D5 587
#define NOTE_DS5 622
#define NOTE_E5 659
#define NOTE_F5 698
#define NOTE_FS5 740
#define NOTE_G5 784
#define NOTE_GS5 831
#define NOTE_A5 880
#define NOTE_AS5 932
#define NOTE_B5 988
#define NOTE_C6 1047
#define NOTE_CS6 1109
#define NOTE_D6 1175
#define NOTE_DS6 1245
#define NOTE_E6 1319
#define NOTE_F6 1397
#define NOTE_FS6 1480
#define NOTE_G6 1568
#define NOTE_GS6 1661
#define NOTE_A6 1760
#define NOTE_AS6 1865
#define NOTE_B6 1976
#define NOTE_C7 2093
#define NOTE_CS7 2217
#define NOTE_D7 2349
#define NOTE_DS7 2489
#define NOTE_E7 2637
#define NOTE_F7 2794
#define NOTE_FS7 2960
#define NOTE_G7 3136
#define NOTE_GS7 3322
#define NOTE_A7 3520
#define NOTE_AS7 3729
#define NOTE_B7 3951
#define NOTE_C8 4186
#define NOTE_CS8 4435
#define NOTE_D8 4699
#define NOTE_DS8 4978
</pre>
<p>Save the above given code as <b>pitches.h</b></p>
<h2>Arduino Code</h2>
<pre class="prettyprint notranslate">
#include "pitches.h"
// notes in the melody:
int melody[] = {
NOTE_C4, NOTE_G3,NOTE_G3, NOTE_GS3, NOTE_G3,0, NOTE_B3, NOTE_C4};
// note durations: 4 = quarter note, 8 = eighth note, etc.:

int noteDurations[] = {
   4, 8, 8, 4,4,4,4,4 
};

void setup() {
   // iterate over the notes of the melody:
   for (int thisNote = 0; thisNote &lt; 8; thisNote++) {
      // to calculate the note duration, take one second
      // divided by the note type.
      //e.g. quarter note = 1000 / 4, eighth note = 1000/8, etc.
      int noteDuration = 1000/noteDurations[thisNote];
      tone(8, melody[thisNote],noteDuration);
      //pause for the note's duration plus 30 ms:
      delay(noteDuration +30);
   }
}

void loop() {
   // no need to repeat the melody.
}
</pre>

<title>Arduino Wireless Communication</title>

<h1>Arduino - Wireless Communication</h1>

<p>The wireless transmitter and receiver modules work at 315 Mhz. They can easily fit into a breadboard and work well with microcontrollers to create a very simple wireless data link. With one pair of transmitter and receiver, the modules will only work communicating data one-way, however, you would need two pairs (of different frequencies) to act as a transmitter/receiver pair.</p>

<p><b>Note</b> &minus; These modules are indiscriminate and receive a fair amount of noise. Both the transmitter and receiver work at common frequencies and do not have IDs.</p>

<h2>Receiver Module Specifications</h2>

<h2>Transmitter Module Specifications</h2>

<h2>Components Required</h2>

<p>You will need the following components &minus;</p>

<h2>Procedure</h2>

<p>Follow the circuit diagram and make the connections as shown in the image given below.</p>

<h2>Sketch</h2>

<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open a new sketch File by clicking New.</p>

<p><b>Note</b> &minus; You must include the keypad library in your Arduino library file. Copy and paste the VirtualWire.lib file in the libraries folder as highlighted in the screenshot given below.</p>

<h2>Arduino Code for Transmitter</h2>

<h2>Code to Note</h2>

<p>This is a simple code. First, it will send character '1' and after two seconds it will send character '0' and so on.</p>

<h2>Arduino Code for Receiver</h2>

<h2>Code to Note</h2>

<p>The LED connected to pin number 5 on the Arduino board is turned ON when character '1' is received and turned OFF when character '0' received.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
//simple Tx on pin D12
#include &lt;VirtualWire.h&gt;
char *controller;

void setup() {
   pinMode(13,OUTPUT);
   vw_set_ptt_inverted(true);
   vw_set_tx_pin(12);
   vw_setup(4000);// speed of data transfer Kbps
}

void loop() {
   controller="1" ;
   vw_send((uint8_t *)controller, strlen(controller));
   vw_wait_tx(); // Wait until the whole message is gone
   digitalWrite(13,1);
   delay(2000);
   controller="0" ;
   vw_send((uint8_t *)controller, strlen(controller));
   vw_wait_tx(); // Wait until the whole message is gone
   digitalWrite(13,0);
   delay(2000);
}
</pre>
<h2>Code to Note</h2>
<p>This is a simple code. First, it will send character '1' and after two seconds it will send character '0' and so on.</p>
<h2>Arduino Code for Receiver</h2>
<pre class="prettyprint notranslate">
//simple Rx on pin D12
#include &lt;VirtualWire.h&gt;

void setup() {
   vw_set_ptt_inverted(true); // Required for DR3100
   vw_set_rx_pin(12);
   vw_setup(4000); // Bits per sec
   pinMode(5, OUTPUT);
   vw_rx_start(); // Start the receiver PLL running
}

void loop() {
   uint8_t buf[VW_MAX_MESSAGE_LEN];
   uint8_t buflen = VW_MAX_MESSAGE_LEN;
   if (vw_get_message(buf, &amp;buflen)) // Non-blocking {
      if(buf[0]=='1') {
         digitalWrite(5,1);
      }
      if(buf[0]=='0') {
         digitalWrite(5,0);
      }
   }
}
</pre>

<title>Arduino Network Communication</title>

<h1>Arduino - Network Communication</h1>

<p>The CC3000 WiFi module from Texas Instruments is a small silver package, which finally brings easy-to-use, affordable WiFi functionality to your Arduino projects.</p>

<p>It uses SPI for communication (not UART!) so you can push data as fast as you want or as slow as you want. It has a proper interrupt system with IRQ pin so you can have asynchronous connections. It supports 802.11b/g, open/WEP/WPA/WPA2 security, TKIP & AES. A built-in TCP/IP stack with a "BSD socket" interface supports TCP and UDP in both the client and the server mode.</p>

<h2>Components Required</h2>

<p>You will need the following components &minus;</p>

<p>For this project, you just need the usual Arduino IDE, the Adafruit’s CC3000 library, and the CC3000 MDNS library. We are also going to use the aREST library to send commands to the relay via WiFi.</p>

<h2>Procedure</h2>

<p>Follow the circuit diagram and make the connections as shown in the image given below.</p>

<p>The hardware configuration for this project is very easy.</p>

<p>Let us now connect the relay.</p>

<p>After placing the relay on the breadboard, you can start identifying the two important parts on your relay: the coil part which commands the relay, and the switch part where we will attach the LED.</p>

<p>You also have to place the rectifier diode (anode connected to the ground pin) over the pins of the coil to protect your circuit when the relay is switching.</p>

<p>Connect the +5V of Arduino board to the common pin of the relay’s switch.</p>

<p>Finally, connect one of the other pin of the switch (usually, the one which is not connected when the relay is off) to the LED in series with the 220 Ohm resistor, and connect the other side of the LED to the ground of Arduino board.</p>

<h2>Testing Individual Components</h2>

<p>You can test the relay with the following sketch &minus;</p>

<h2>Code to Note</h2>

<p>The code is self-explanatory. You can just upload it to the board and the relay will switch states every second, and the LED will switch ON and OFF accordingly.</p>

<h2>Adding WiFi Connectivity</h2>

<p>Let us now control the relay wirelessly using the CC3000 WiFi chip. The software for this project is based on the TCP protocol. However, for this project, Arduino board will be running a small web server, so we can “listen” for commands coming from the computer. We will first take care of Arduino sketch, and then we will see how to write the server-side code and create a nice interface.</p>

<p>First, the Arduino sketch. The goal here is to connect to your WiFi network, create a web server, check if there are incoming TCP connections, and then change the state of the relay accordingly.</p>

<h2>Important Parts of the Code</h2>

<p>You need to define inside the code what is specific to your configuration, i.e. Wi-Fi name and password, and the port for TCP communications (we have used 80 here).</p>

<p>We can then create the CC3000 instance, server and aREST instance &minus;</p>

<p>In the setup() part of the sketch, we can now connect the CC3000 chip to the network &minus;</p>

<p>How will the computer know where to send the data? One way would be to run the sketch once, then get the IP address of the CC3000 board, and modify the server code again. However, we can do better, and that is where the CC3000 MDNS library comes into play. We will assign a fixed name to our CC3000 board with this library, so we can write down this name directly into the server code.</p>

<p>This is done with the following piece of code &minus;</p>

<p>We also need to listen for incoming connections.</p>

<p>Next, we will code the loop() function of the sketch that will be continuously executed. We first have to update the mDNS server.</p>

<p>The server running on Arduino board will wait for the incoming connections and handle the requests.</p>

<p>It is now quite easy to test the projects via WiFi. Make sure you updated the sketch with your own WiFi name and password, and upload the sketch to your Arduino board. Open your Arduino IDE serial monitor, and look for the IP address of your board.</p>

<p>Let us assume for the rest here that it is something like 192.168.1.103.</p>

<p>Then, simply go to your favorite web browser, and type &minus;</p>

<p>192.168.1.103/digital/8/1</p>

<p>You should see that your relay automatically turns ON.</p>

<h2>Building the Relay Interface</h2>

<p>We will now code the interface of the project. There will be two parts here: an HTML file containing the interface, and a client-side Javascript file to handle the clicks on the interface. The interface here is based on the <b>aREST.js</b> project, which was made to easily control WiFi devices from your computer.</p>

<p>Let us first see the HTML file, called interface.html. The first part consists importing all the required libraries for the interface &minus;</p>

<p>Then, we define two buttons inside the interface, one to turn the relay on, and the other to turn it off again.</p>

<p>Now, we also need a client-side Javascript file to handle the clicks on the buttons. We will also create a device that we will link to the mDNS name of our Arduino device. If you changed this in Arduino code, you will need to modify it here as well.</p>

<p>The complete code for this project can be found on the <b>GitHub</b> repository. Go into the interface folder, and simply open the HTML file with your favorite browser. You should see something similar inside your browser &minus;</p>

<p>Try to click a button on the web interface; it should change the state of the relay nearly instantly.</p>

<p>If you managed to get it working, bravo! You just built a Wi-Fi-controlled light switch. Of course, you can control much more than lights with this project. Just make sure your relay supports the power required for the device you want to control, and you are good to go.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="prettyprint notranslate">
const int relay_pin = 8; // Relay pin

void setup() {
   Serial.begin(9600);
   pinMode(relay_pin,OUTPUT);
}

void loop() {
   // Activate relay
   digitalWrite(relay_pin, HIGH);
   // Wait for 1 second
   delay(1000);
   // Deactivate relay
   digitalWrite(relay_pin, LOW);
   // Wait for 1 second
   delay(1000);
}
</pre>
<h2>Code to Note</h2>
<p>The code is self-explanatory. You can just upload it to the board and the relay will switch states every second, and the LED will switch ON and OFF accordingly.</p>
<h2>Adding WiFi Connectivity</h2>
<p>Let us now control the relay wirelessly using the CC3000 WiFi chip. The software for this project is based on the TCP protocol. However, for this project, Arduino board will be running a small web server, so we can “listen” for commands coming from the computer. We will first take care of Arduino sketch, and then we will see how to write the server-side code and create a nice interface.</p>
<p>First, the Arduino sketch. The goal here is to connect to your WiFi network, create a web server, check if there are incoming TCP connections, and then change the state of the relay accordingly.</p>
<h2>Important Parts of the Code</h2>
<pre class="prettyprint notranslate">
#include &lt;Adafruit_CC3000.h&gt;
#include &lt;SPI.h&gt;
#include &lt;CC3000_MDNS.h&gt;
#include &lt;Ethernet.h&gt;
#include &lt;aREST.h&gt;
</pre>
<p>You need to define inside the code what is specific to your configuration, i.e. Wi-Fi name and password, and the port for TCP communications (we have used 80 here).</p>
<pre class="prettyprint notranslate">
// WiFi network (change with your settings!)
   #define WLAN_SSID "yourNetwork" // cannot be longer than 32 characters!
   #define WLAN_PASS "yourPassword"
   #define WLAN_SECURITY WLAN_SEC_WPA2 // This can be WLAN_SEC_UNSEC, WLAN_SEC_WEP, 
   // WLAN_SEC_WPA or WLAN_SEC_WPA2

// The port to listen for incoming TCP connections
   #define LISTEN_PORT 80
</pre>
<p>We can then create the CC3000 instance, server and aREST instance &minus;</p>
<pre class="prettyprint notranslate">
// Server instance
   Adafruit_CC3000_Server restServer(LISTEN_PORT); // DNS responder instance
   MDNSResponder mdns; // Create aREST instance
   aREST rest = aREST();
</pre>
<p>In the setup() part of the sketch, we can now connect the CC3000 chip to the network &minus;</p>
<pre class="result notranslate">
cc3000.connectToAP(WLAN_SSID, WLAN_PASS, WLAN_SECURITY);
</pre>
<p>How will the computer know where to send the data? One way would be to run the sketch once, then get the IP address of the CC3000 board, and modify the server code again. However, we can do better, and that is where the CC3000 MDNS library comes into play. We will assign a fixed name to our CC3000 board with this library, so we can write down this name directly into the server code.</p>
<p>This is done with the following piece of code &minus;</p>
<pre class="prettyprint notranslate">
if (!mdns.begin("arduino", cc3000)) {
   while(1);
}
</pre>
<p>We also need to listen for incoming connections.</p>
<pre class="result notranslate">
restServer.begin();
</pre>
<p>Next, we will code the loop() function of the sketch that will be continuously executed. We first have to update the mDNS server.</p>
<pre class="result notranslate">
mdns.update();
</pre>
<p>The server running on Arduino board will wait for the incoming connections and handle the requests.</p>
<pre class="result notranslate">
Adafruit_CC3000_ClientRef client = restServer.available();
rest.handle(client);
</pre>
<p>It is now quite easy to test the projects via WiFi. Make sure you updated the sketch with your own WiFi name and password, and upload the sketch to your Arduino board. Open your Arduino IDE serial monitor, and look for the IP address of your board.</p>
<p>Let us assume for the rest here that it is something like 192.168.1.103.</p>
<p>Then, simply go to your favorite web browser, and type &minus;</p>
<p>192.168.1.103/digital/8/1</p>
<p>You should see that your relay automatically turns ON.</p>
<h2>Building the Relay Interface</h2>
<p>We will now code the interface of the project. There will be two parts here: an HTML file containing the interface, and a client-side Javascript file to handle the clicks on the interface. The interface here is based on the <b>aREST.js</b> project, which was made to easily control WiFi devices from your computer.</p>
<p>Let us first see the HTML file, called interface.html. The first part consists importing all the required libraries for the interface &minus;</p>
<pre class="prettyprint notranslate">
&lt;head&gt;
   &lt;meta charset = utf-8 /&gt;
   &lt;title&gt; Relay Control &lt;/title&gt;
   &lt;link rel = "stylesheet" type = "text/css" 
      href = "https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css"&gt;
   &lt;link rel="stylesheet" type = "text/css" href = "style.css"&gt;
   &lt;script type = "text/javascript" 
      src = "https://code.jquery.com/jquery-2.1.4.min.js"&gt;&lt;/script&gt;
   &lt;script type = "text/javascript" 
      src = "https://cdn.rawgit.com/Foliotek/AjaxQ/master/ajaxq.js"&gt;&lt;/script&gt;
   &lt;script type = "text/javascript" 
      src = "https://cdn.rawgit.com/marcoschwartz/aREST.js/master/aREST.js"&gt;&lt;/script&gt;
   &lt;script type = "text/javascript" 
      src = "script.js"&gt;&lt;/script&gt;
&lt;/head&gt;
</pre>
<p>Then, we define two buttons inside the interface, one to turn the relay on, and the other to turn it off again.</p>
<pre class="prettyprint notranslate">
&lt;div class = 'container'&gt;
   &lt;h1&gt;Relay Control&lt;/h1&gt;
   &lt;div class = 'row'&gt;
      &lt;div class = "col-md-1"&gt;Relay&lt;/div&gt;
      &lt;div class = "col-md-2"&gt;
         &lt;button id = 'on' class = 'btn btn-block btn-success'&gt;On&lt;/button&gt;
      &lt;/div&gt;
      &lt;div class = "col-md-2"&gt;
         &lt;button id = 'off' class = 'btn btn-block btn-danger'&gt;On&lt;/button&gt;
      &lt;/div&gt;
   &lt;/div&gt;
&lt;/div&gt;
</pre>
<p>Now, we also need a client-side Javascript file to handle the clicks on the buttons. We will also create a device that we will link to the mDNS name of our Arduino device. If you changed this in Arduino code, you will need to modify it here as well.</p>
<pre class="prettyprint notranslate">
// Create device
var device = new Device("arduino.local");
// Button

$('#on').click(function() {
   device.digitalWrite(8, 1);
});

$('#off').click(function() {
   device.digitalWrite(8, 0);
});
</pre>

<title>Arduino Quick Guide</title>

<h1>Arduino - Quick Guide</h1>

<h1>Arduino - Overview</h1>

<p>Arduino is a prototype platform (open-source) based on an easy-to-use hardware and software. It consists of a circuit board, which can be programed (referred to as a microcontroller) and a ready-made software called Arduino IDE (Integrated Development Environment), which is used to write and upload the computer code to the physical board.</p>

<p>The key features are &minus;</p>

<p>Arduino boards are able to read analog or digital input signals from different sensors and turn it into an output such as activating a motor, turning LED on/off, connect to the cloud and many other actions.</p>

<p>You can control your board functions by sending a set of instructions to the microcontroller on the board via Arduino IDE (referred to as uploading software).</p>

<p>Unlike most previous programmable circuit boards, Arduino does not need an extra piece of hardware (called a programmer) in order to load a new code onto the board. You can simply use a USB cable.</p>

<p>Additionally, the Arduino IDE uses a simplified version of C++, making it easier to learn to program.</p>

<p>Finally, Arduino provides a standard form factor that breaks the functions of the micro-controller into a more accessible package.</p>

<h2>Board Types</h2>

<p>Various kinds of Arduino boards are available depending on different microcontrollers used. However, all Arduino boards have one thing in common: they are programed through the Arduino IDE.</p>

<p>The differences are based on the number of inputs and outputs (the number of sensors, LEDs, and buttons you can use on a single board), speed, operating voltage, form factor etc. Some boards are designed to be embedded and have no programming interface (hardware), which you would need to buy separately. Some can run directly from a 3.7V battery, others need at least 5V.</p>

<p>Here is a list of different Arduino boards available.</p>

<h1>Arduino - Board Description</h1>

<p>In this chapter, we will learn about the different components on the Arduino board. We will study the Arduino UNO board because it is the most popular board in the Arduino board family. In addition, it is the best board to get started with electronics and coding. Some boards look a bit different from the one given below, but most Arduinos have majority of these components in common.</p>

<p><b>Power USB</b></p>

<p>Arduino board can be powered by using the USB cable from your computer. All you need to do is connect the USB cable to the USB connection (1).</p>

<p><b>Power (Barrel Jack)</b></p>

<p>Arduino boards can be powered directly from the AC mains power supply by connecting it to the Barrel Jack (2).</p>

<p><b>Voltage Regulator</b></p>

<p>The function of the voltage regulator is to control the voltage given to the Arduino board and stabilize the DC voltages used by the processor and other elements.</p>

<p><b>Crystal Oscillator</b></p>

<p>The crystal oscillator helps Arduino in dealing with time issues. How does Arduino calculate time? The answer is, by using the crystal oscillator. The number printed on top of the Arduino crystal is 16.000H9H. It tells us that the frequency is 16,000,000 Hertz or 16 MHz.</p>

<p><b>Arduino Reset</b></p>

<p>You can reset your Arduino board, i.e., start your program from the beginning. You can reset the UNO board in two ways. First, by using the reset button (17) on the board. Second, you can connect an external reset button to the Arduino pin labelled RESET (5).</p>

<p><b>Pins (3.3, 5, GND, Vin)</b></p>

<p>3.3V (6) &minus; Supply 3.3 output volt</p>

<p>5V (7) &minus; Supply 5 output volt</p>

<p>Most of the components used with Arduino board works fine with 3.3 volt and 5 volt.</p>

<p>GND (8)(Ground) &minus; There are several GND pins on the Arduino, any of which can be used to ground your circuit.</p>

<p>Vin (9) &minus; This pin also can be used to power the Arduino board from an external power source, like AC mains power supply.</p>

<p><b>Analog pins</b></p>

<p>The Arduino UNO board has five analog input pins A0 through A5. These pins can read the signal from an analog sensor like the humidity sensor or temperature sensor and convert it into a digital value that can be read by the microprocessor.</p>

<p><b>Main microcontroller</b></p>

<p>Each Arduino board has its own microcontroller (11). You can assume it as the brain of your board. The main IC (integrated circuit) on the Arduino is slightly different from board to board. The microcontrollers are usually of the ATMEL Company. You must know what IC your board has before loading up a new program from the Arduino IDE. This information is available on the top of the IC. For more details about the IC construction and functions, you can refer to the data sheet.</p>

<p><b>ICSP pin</b></p>

<p>Mostly, ICSP (12) is an AVR, a tiny programming header for the Arduino consisting of MOSI, MISO, SCK, RESET, VCC, and GND. It is often referred to as an SPI (Serial Peripheral Interface), which could be considered as an "expansion" of the output. Actually, you are slaving the output device to the master of the SPI bus.</p>

<p><b>Power LED indicator</b></p>

<p>This LED should light up when you plug your Arduino into a power source to indicate that your board is powered up correctly. If this light does not turn on, then there is something wrong with the connection.</p>

<p><b>TX and RX LEDs</b></p>

<p>On your board, you will find two labels: TX (transmit) and RX (receive). They appear in two places on the Arduino UNO board. First, at the digital pins 0 and 1, to indicate the pins responsible for serial communication. Second, the TX and RX led (13). The TX led flashes with different speed while sending the serial data. The speed of flashing depends on the baud rate used by the board. RX flashes during the receiving process.</p>

<p><b>Digital I/O</b></p>

<p>The Arduino UNO board has 14 digital I/O pins (15) (of which 6 provide PWM (Pulse Width Modulation) output. These pins can be configured to work as input digital pins to read logic values (0 or 1) or as digital output pins to drive different modules like LEDs, relays, etc. The pins labeled “~” can be used to generate PWM.</p>

<p><b>AREF</b></p>

<p>AREF stands for Analog Reference. It is sometimes, used to set an external reference voltage (between 0 and 5 Volts) as the upper limit for the analog input pins.</p>

<h1>Arduino - Installation</h1>

<p>After learning about the main parts of the Arduino UNO board, we are ready to learn how to set up the Arduino IDE. Once we learn this, we will be ready to upload our program on the Arduino board.</p>

<p>In this section, we will learn in easy steps, how to set up the Arduino IDE on our computer and prepare the board to receive the program via USB cable.</p>

<p><b>Step 1</b> &minus; First you must have your Arduino board (you can choose your favorite board) and a USB cable. In case you use Arduino UNO, Arduino Duemilanove, Nano, Arduino Mega 2560, or Diecimila, you will need a standard USB cable (A plug to B plug), the kind you would connect to a USB printer as shown in the following image.</p>

<p>In case you use Arduino Nano, you will need an A to Mini-B cable instead as shown in the following image.</p>

<p><b>Step 2 &minus; Download Arduino IDE Software.</b></p>

<p>You can get different versions of Arduino IDE from the <a href="https://www.arduino.cc/en/Main/Software" rel="nofollow" target="_blank">Download page</a> on the Arduino Official website. You must select your software, which is compatible with your operating system (Windows, IOS, or Linux). After your file download is complete, unzip the file.</p>

<p><b>Step 3 &minus; Power up your board.</b></p>

<p>The Arduino Uno, Mega, Duemilanove and Arduino Nano automatically draw power from either, the USB connection to the computer or an external power supply. If you are using an Arduino Diecimila, you have to make sure that the board is configured to draw power from the USB connection. The power source is selected with a jumper, a small piece of plastic that fits onto two of the three pins between the USB and power jacks. Check that it is on the two pins closest to the USB port.</p>

<p>Connect the Arduino board to your computer using the USB cable. The green power LED (labeled PWR) should glow.</p>

<p><b>Step 4 &minus; Launch Arduino IDE.</b></p>

<p>After your Arduino IDE software is downloaded, you need to unzip the folder. Inside the folder, you can find the application icon with an infinity label (application.exe). Double-click the icon to start the IDE.</p>

<p><b>Step 5 &minus; Open your first project.</b></p>

<p>Once the software starts, you have two options &minus;</p>

<p>To create a new project, select File &rarr; <b>New</b>.</p>

<p>To open an existing project example, select File &rarr; Example &rarr; Basics &rarr; Blink.</p>

<p>Here, we are selecting just one of the examples with the name <b>Blink</b>. It turns the LED on and off with some time delay. You can select any other example from the list.</p>

<p><b>Step 6 &minus; Select your Arduino board.</b></p>

<p>To avoid any error while uploading your program to the board, you must select the correct Arduino board name, which matches with the board connected to your computer.</p>

<p>Go to Tools &rarr; Board and select your board.</p>

<p>Here, we have selected Arduino Uno board according to our tutorial, but you must select the name matching the board that you are using.</p>

<p><b>Step 7 &minus; Select your serial port.</b></p>

<p>Select the serial device of the Arduino board. Go to <b>Tools &rarr; Serial Port</b> menu. This is likely to be COM3 or higher (COM1 and COM2 are usually reserved for hardware serial ports). To find out, you can disconnect your Arduino board and re-open the menu, the entry that disappears should be of the Arduino board. Reconnect the board and select that serial port.</p>

<p><b>Step 8 &minus; Upload the program to your board.</b></p>

<p>Before explaining how we can upload our program to the board, we must demonstrate the function of each symbol appearing in the Arduino IDE toolbar.</p>

<p>Now, simply click the "Upload" button in the environment. Wait a few seconds; you will see the RX and TX LEDs on the board, flashing. If the upload is successful, the message "Done uploading" will appear in the status bar.</p>

<p><b>Note</b> &minus; If you have an Arduino Mini, NG, or other board, you need to press the reset button physically on the board, immediately before clicking the upload button on the Arduino Software.</p>

<h1>Arduino - Program Structure</h1>

<p>In this chapter, we will study in depth, the Arduino program structure and we will learn more new terminologies used in the Arduino world. The Arduino software is open-source. The source code for the Java environment is released under the GPL and the C/C++ microcontroller libraries are under the LGPL.</p>

<p><b>Sketch</b> &minus; The first new terminology is the Arduino program called “<b>sketch</b>”.</p>

<h2>Structure</h2>

<p>Arduino programs can be divided in three main parts: <b>Structure, Values</b> (variables and constants), and <b>Functions</b>. In this tutorial, we will learn about the Arduino software program, step by step, and how we can write the program without any syntax or compilation error.</p>

<p>Let us start with the <b>Structure</b>. Software structure consist of two main functions &minus;</p>

<p><b>PURPOSE</b> &minus; The <b>setup()</b> function is called when a sketch starts. Use it to initialize the variables, pin modes, start using libraries, etc. The setup function will only run once, after each power up or reset of the Arduino board.</p>

<p><b>INPUT</b> &minus;      -</p>

<p><b>OUTPUT</b> &minus;     -</p>

<p><b>RETURN</b> &minus;     -</p>

<p><b>PURPOSE</b> &minus; After creating a <b>setup()</b> function, which initializes and sets the initial values, the <b>loop()</b> function does precisely what its name suggests, and loops consecutively, allowing your program to change and respond. Use it to actively control the Arduino board.</p>

<p><b>INPUT</b> &minus;      -</p>

<p><b>OUTPUT</b> &minus;     -</p>

<p><b>RETURN</b> &minus;     -</p>

<h1>Arduino - Data Types</h1>

<p>Data types in C refers to an extensive system used for declaring variables or functions of different types. The type of a variable determines how much space it occupies in the storage and how the bit pattern stored is interpreted.</p>

<p>The following table provides all the data types that you will use during Arduino programming.</p>

<h2>void</h2>

<p>The void keyword is used only in function declarations. It indicates that the function is expected to return no information to the function from which it was called.</p>

<h3>Example</h3>

<h2>Boolean</h2>

<p>A Boolean holds one of two values, true or false. Each Boolean variable occupies one byte of memory.</p>

<h3>Example</h3>

<h2>Char</h2>

<p>A data type that takes up one byte of memory that stores a character value. Character literals are written in single quotes like this: 'A' and for multiple characters, strings use double quotes: "ABC".</p>

<p>However, characters are stored as numbers. You can see the specific encoding in the <a href="https://www.arduino.cc/en/Reference/ASCIIchart" rel="nofollow" target="_blank">ASCII chart</a>. This means that it is possible to do arithmetic operations on characters, in which the ASCII value of the character is used. For example, 'A' + 1 has the value 66, since the ASCII value of the capital letter A is 65.</p>

<h3>Example</h3>

<p></p>

<h2>unsigned char</h2>

<p><b>Unsigned char</b> is an unsigned data type that occupies one byte of memory. The unsigned char data type encodes numbers from 0 to 255.</p>

<h3>Example</h3>

<h2>byte</h2>

<p>A byte stores an 8-bit unsigned number, from 0 to 255.</p>

<h3>Example</h3>

<h2>int</h2>

<p>Integers are the primary data-type for number storage. int stores a 16-bit (2-byte) value. This yields a range of -32,768 to 32,767 (minimum value of -2&#94;15 and a maximum value of (2&#94;15) - 1).</p>

<p>The <b>int</b> size varies from board to board. On the Arduino Due, for example, an <b>int</b> stores a 32-bit (4-byte) value. This yields a range of -2,147,483,648 to 2,147,483,647 (minimum value of -2&#94;31 and a maximum value of (2&#94;31) - 1).</p>

<h3>Example</h3>

<h2>Unsigned int</h2>

<p>Unsigned ints (unsigned integers) are the same as int in the way that they store a 2 byte value. Instead of storing negative numbers, however, they only store positive values, yielding a useful range of 0 to 65,535 (2&#94;16) - 1). The Due stores a 4 byte (32-bit) value, ranging from 0 to 4,294,967,295 (2&#94;32 - 1).</p>

<h3>Example</h3>

<h2>Word</h2>

<p>On the Uno and other ATMEGA based boards, a word stores a 16-bit unsigned number. On the Due and Zero, it stores a 32-bit unsigned number.</p>

<h3>Example</h3>

<h2>Long</h2>

<p>Long variables are extended size variables for number storage, and store 32 bits (4 bytes), from 2,147,483,648 to 2,147,483,647.</p>

<h3>Example</h3>

<h2>unsigned long</h2>

<p>Unsigned long variables are extended size variables for number storage and store 32 bits (4 bytes). Unlike standard longs, unsigned longs will not store negative numbers, making their range from 0 to 4,294,967,295 (2&#94;32 - 1).</p>

<h3>Example</h3>

<h2>short</h2>

<p>A short is a 16-bit data-type. On all Arduinos (ATMega and ARM based), a short stores a 16-bit (2-byte) value. This yields a range of -32,768 to 32,767 (minimum value of -2&#94;15 and a maximum value of (2&#94;15) - 1).</p>

<h3>Example</h3>

<h2>float</h2>

<p>Data type for floating-point number is a number that has a decimal point. Floating-point numbers are often used to approximate the analog and continuous values because they have greater resolution than integers.</p>

<p>Floating-point numbers can be as large as 3.4028235E+38 and as low as 3.4028235E+38. They are stored as 32 bits (4 bytes) of information.</p>

<h3>Example</h3>

<h2>double</h2>

<p>On the Uno and other ATMEGA based boards, Double precision floating-point number occupies four bytes. That is, the double implementation is exactly the same as the float, with no gain in precision. On the Arduino Due, doubles have 8-byte (64 bit) precision.</p>

<h3>Example</h3>

<h1>Arduino - Variables &amp; Constants</h1>

<p>Before we start explaining the variable types, a very important subject we need to make sure, you fully understand is called the <b>variable scope</b>.</p>

<h2>What is Variable Scope?</h2>

<p>Variables in C programming language, which Arduino uses, have a property called scope. A scope is a region of the program and there are three places where variables can be declared. They are &minus;</p>

<h3>Local Variables</h3>

<p>Variables that are declared inside a function or block are local variables. They can be used only by the statements that are inside that function or block of code. Local variables are not known to function outside their own. Following is the example using local variables &minus;</p>

<h3>Global Variables</h3>

<p>Global variables are defined outside of all the functions, usually at the top of the program. The global variables will hold their value throughout the life-time of your program.</p>

<p>A global variable can be accessed by any function. That is, a global variable is available for use throughout your entire program after its declaration.</p>

<p>The following example uses global and local variables &minus;</p>

<h1>Arduino - Operators</h1>

<p>An operator is a symbol that tells the compiler to perform specific mathematical or logical functions. C language is rich in built-in operators and provides the following types of operators &minus;</p>

<h2>Arithmetic Operators</h2>

<p>Assume variable A holds 10 and variable B holds 20 then &minus;</p>

<p><a href="/arduino/arduino_arithmetic_operators.htm">Show Example</a></p>

<h2>Comparison Operators</h2>

<p>Assume variable A holds 10 and variable B holds 20 then &minus;</p>

<p><a href="/arduino/arduino_comparison_operators.htm">Show Example</a></p>

<h2>Boolean Operators</h2>

<p>Assume variable A holds 10 and variable B holds 20 then &minus;</p>

<p><a href="/arduino/arduino_boolean_operators.htm">Show Example</a></p>

<h2>Bitwise Operators</h2>

<p>Assume variable A holds 60 and variable B holds 13 then &minus;</p>

<p><a href="/arduino/arduino_bitwise_operators.htm">Show Example</a></p>

<h2>Compound Operators</h2>

<p>Assume variable A holds 10 and variable B holds 20 then &minus;</p>

<p><a href="/arduino/arduino_compound_operators.htm">Show Example</a></p>

<h1>Arduino - Control Statements</h1>

<p>Decision making structures require that the programmer specify one or more conditions to be evaluated or tested by the program. It should be along with a statement or statements to be executed if the condition is determined to be true, and optionally, other statements to be executed if the condition is determined to be false.</p>

<p>Following is the general form of a typical decision making structure found in most of the programming languages &minus;</p>

<p>Control Statements are elements in Source Code that control the flow of program execution. They are &minus;</p>

<p><a href="/arduino/arduino_if_statement.htm">If statement</a></p>

<p>It takes an expression in parenthesis and a statement or block of statements. If the expression is true then the statement or block of statements gets executed otherwise these statements are skipped.</p>

<p><a href="/arduino/arduino_if_else_statement.htm">If …else statement</a></p>

<p>An <b>if</b> statement can be followed by an optional else statement, which executes when the expression is false.</p>

<p><a href="/arduino/arduino_if_else_if_else_statement.htm">If…else if …else statement</a></p>

<p>The <b>if</b> statement can be followed by an optional <b>else if...else</b> statement, which is very useful to test various conditions using single if...else if statement.</p>

<p><a href="/arduino/arduino_switch_case_statement.htm">switch case statement</a></p>

<p>Similar to the if statements, <b>switch...case</b> controls the flow of programs by allowing the programmers to specify different codes that should be executed in various conditions.</p>

<p><a href="/arduino/arduino_conditional_operator.htm">Conditional Operator ? :</a></p>

<p>The conditional operator ? : is the only ternary operator in C.</p>

<h1>Arduino - Loops</h1>

<p>Programming languages provide various control structures that allow for more complicated execution paths.</p>

<p>A loop statement allows us to execute a statement or group of statements multiple times and following is the general form of a loop statement in most of the programming languages &minus;</p>

<p>C programming language provides the following types of loops to handle looping requirements.</p>

<p><a href="/arduino/arduino_while_loop.htm">while loop</a></p>

<p>while loops will loop continuously, and infinitely, until the expression inside the parenthesis, () becomes false. Something must change the tested variable, or the while loop will never exit.</p>

<p><a href="/arduino/arduino_do_while_loop.htm">do…while loop</a></p>

<p>The <b>do…while</b> loop is similar to the while loop. In the while loop, the loop-continuation condition is tested at the beginning of the loop before performed the body of the loop.</p>

<p><a href="/arduino/arduino_for_loop.htm">for loop</a></p>

<p>A <b>for loop</b> executes statements a predetermined number of times. The control expression for the loop is initialized, tested and manipulated entirely within the for loop parentheses.</p>

<p><a href="/arduino/arduino_nested_loop.htm">Nested Loop</a></p>

<p>C language allows you to use one loop inside another loop. The following example illustrates the concept.</p>

<p><a href="/arduino/arduino_infinite_loop.htm">Infinite loop</a></p>

<p>It is the loop having no terminating condition, so the loop becomes infinite.</p>

<h1>Arduino - Functions</h1>

<p>Functions allow structuring the programs in segments of code to perform individual tasks. The typical case for creating a function is when one needs to perform the same action multiple times in a program.</p>

<p>Standardizing code fragments into functions has several advantages &minus;</p>

<p>Functions help the programmer stay organized. Often this helps to conceptualize the program.</p>

<p>Functions codify one action in one place so that the function only has to be thought about and debugged once.</p>

<p>This also reduces chances for errors in modification, if the code needs to be changed.</p>

<p>Functions make the whole sketch smaller and more compact because sections of code are reused many times.</p>

<p>They make it easier to reuse code in other programs by making it modular, and using functions often makes the code more readable.</p>

<p>There are two required functions in an Arduino sketch or a program i.e. setup () and loop(). Other functions must be created outside the brackets of these two functions.</p>

<p>The most common syntax to define a function is &minus;</p>

<h2>Function Declaration</h2>

<p>A function is declared outside any other functions, above or below the loop function.</p>

<p>We can declare the function in two different ways &minus;</p>

<p>The first way is just writing the part of the function called <b>a function prototype</b> above the loop function, which consists of &minus;</p>

<p>Function prototype must be followed by a semicolon ( ; ).</p>

<p>The following example shows the demonstration of the function declaration using the first method.</p>

<h3>Example</h3>

<p>The second part, which is called the function definition or declaration, must be declared below the loop function, which consists of &minus;</p>

<p>The following example demonstrates the declaration of function using the second method.</p>

<h3>Example</h3>

<p>The second method just declares the function above the loop function.</p>

<h1>Arduino - Strings</h1>

<p>Strings are used to store text. They can be used to display text on an LCD or in the Arduino IDE Serial Monitor window. Strings are also useful for storing the user input. For example, the characters that a user types on a keypad connected to the Arduino.</p>

<p>There are two types of strings in Arduino programming &minus;</p>

<p>In this chapter, we will learn Strings, objects and the use of strings in Arduino sketches. By the end of the chapter, you will learn which type of string to use in a sketch.</p>

<h2>String Character Arrays</h2>

<p>The first type of string that we will learn is the string that is a series of characters of the type <b>char</b>. In the previous chapter, we learned what an array is; a consecutive series of the same type of variable stored in memory. A string is an array of char variables.</p>

<p>A string is a special array that has one extra element at the end of the string, which always has the value of 0 (zero). This is known as a "null terminated string".</p>

<h3>String Character Array Example</h3>

<p>This example will show how to make a string and print it to the serial monitor window.</p>

<p><b>Example</b></p>

<p>The following example shows what a string is made up of; a character array with printable characters and 0 as the last element of the array to show that this is where the string ends. The string can be printed out to the Arduino IDE Serial Monitor window by using <b>Serial.println()</b> and passing the name of the string.</p>

<p>This same example can be written in a more convenient way as shown below &minus;</p>

<p><b>Example</b></p>

<p>In this sketch, the compiler calculates the size of the string array and also automatically null terminates the string with a zero. An array that is six elements long and consists of five characters followed by a zero is created exactly the same way as in the previous sketch.</p>

<h2>Manipulating String Arrays</h2>

<p>We can alter a string array within a sketch as shown in the following sketch.</p>

<h3>Example</h3>

<h3>Result</h3>

<p>The sketch works in the following way.</p>

<h3>Creating and Printing the String</h3>

<p>In the sketch given above, a new string is created and then printed for display in the Serial Monitor window.</p>

<h3>Shortening the String</h3>

<p>The string is shortened by replacing the 14th character in the string with a null terminating zero (2). This is element number 13 in the string array counting from 0.</p>

<p>When the string is printed, all the characters are printed up to the new null terminating zero. The other characters do not disappear; they still exist in the memory and the string array is still the same size. The only difference is that any function that works with strings will only see the string up to the first null terminator.</p>

<h3>Changing a Word in the String</h3>

<p>Finally, the sketch replaces the word "cake" with "tea" (3). It first has to replace the null terminator at like[13] with a space so that the string is restored to the originally created format.</p>

<p>New characters overwrite "cak" of the word "cake" with the word "tea". This is done by overwriting individual characters. The 'e' of "cake" is replaced with a new null terminating character. The result is that the string is actually terminated with two null characters, the original one at the end of the string and the new one that replaces the 'e' in "cake". This makes no difference when the new string is printed because the function that prints the string stops printing the string characters when it encounters the first null terminator.</p>

<h2>Functions to Manipulate String Arrays</h2>

<p>The previous sketch manipulated the string in a manual way by accessing individual characters in the string. To make it easier to manipulate string arrays, you can write your own functions to do so, or use some of the string functions from the <b>C</b> language library.</p>

<p><b>String()</b></p>

<p>The String class, part of the core as of version 0019, allows you to use and manipulate strings of text in more complex ways than character arrays do. You can concatenate Strings, append to them, search for and replace substrings, and more. It takes more memory than a simple character array, but it is also more useful.</p>

<p>For reference, character arrays are referred to as strings with a small ‘s’, and instances of the String class are referred to as Strings with a capital S. Note that constant strings, specified in "double quotes" are treated as char arrays, not instances of the String class</p>

<p><b>charAt()</b></p>

<p>Access a particular character of the String.</p>

<p><b>compareTo()</b></p>

<p>Compares two Strings, testing whether one comes before or after the other, or whether they are equal. The strings are compared character by character, using the ASCII values of the characters. That means, for example, 'a' comes before 'b' but after 'A'. Numbers come before letters.</p>

<p><b>concat()</b></p>

<p>Appends the parameter to a String.</p>

<p><b>c_str()</b></p>

<p>Converts the contents of a string as a C-style, null-terminated string. Note that this gives direct access to the internal String buffer and should be used with care. In particular, you should never modify the string through the pointer returned. When you modify the String object, or when it is destroyed, any pointer previously returned by c_str() becomes invalid and should not be used any longer.</p>

<p><b>endsWith()</b></p>

<p>Tests whether or not a String ends with the characters of another String.</p>

<p><b>equals()</b></p>

<p>Compares two strings for equality. The comparison is case-sensitive, meaning the String "hello" is not equal to the String "HELLO".</p>

<p><b>equalsIgnoreCase()</b></p>

<p>Compares two strings for equality. The comparison is not case-sensitive, meaning the String("hello") is equal to the String("HELLO").</p>

<p><b>getBytes()</b></p>

<p>Copies the string's characters to the supplied buffer.</p>

<p><b>indexOf()</b></p>

<p>Locates a character or String within another String. By default, it searches from the beginning of the String, but can also start from a given index, allowing to locate all instances of the character or String.</p>

<p><b>lastIndexOf()</b></p>

<p>Locates a character or String within another String. By default, it searches from the end of the String, but can also work backwards from a given index, allowing to locate all instances of the character or String.</p>

<p><b>length()</b></p>

<p>Returns the length of the String, in characters. (Note that this does not include a trailing null character.)</p>

<p><b>remove()</b></p>

<p>Modify in place, a string removing chars from the provided index to the end of the string or from the provided index to index plus count.</p>

<p><b>replace()</b></p>

<p>The String replace() function allows you to replace all instances of a given character with another character. You can also use replace to replace substrings of a string with a different substring.</p>

<p><b>reserve()</b></p>

<p>The String reserve() function allows you to allocate a buffer in memory for manipulating strings.</p>

<p><b>setCharAt()</b></p>

<p>Sets a character of the String. Has no effect on indices outside the existing length of the String.</p>

<p><b>startsWith()</b></p>

<p>Tests whether or not a String starts with the characters of another String.</p>

<p><b>toCharArray()</b></p>

<p>Copies the string's characters to the supplied buffer.</p>

<p><b>substring()</b></p>

<p>Get a substring of a String. The starting index is inclusive (the corresponding character is included in the substring), but the optional ending index is exclusive (the corresponding character is not included in the substring). If the ending index is omitted, the substring continues to the end of the String.</p>

<p><b>toInt()</b></p>

<p>Converts a valid String to an integer. The input string should start with an integer number. If the string contains non-integer numbers, the function will stop performing the conversion.</p>

<p><b>toFloat()</b></p>

<p>Converts a valid String to a float. The input string should start with a digit. If the string contains non-digit characters, the function will stop performing the conversion. For example, the strings "123.45", "123", and "123fish" are converted to 123.45, 123.00, and 123.00 respectively. Note that "123.456" is approximated with 123.46. Note too that floats have only 6-7 decimal digits of precision and that longer strings might be truncated.</p>

<p><b>toLowerCase()</b></p>

<p>Get a lower-case version of a String. As of 1.0, toLowerCase() modifies the string in place rather than returning a new.</p>

<p><b>toUpperCase()</b></p>

<p>Get an upper-case version of a String. As of 1.0, toUpperCase() modifies the string in place rather than returning a new one.</p>

<p><b>trim()</b></p>

<p>Get a version of the String with any leading and trailing whitespace removed. As of 1.0, trim() modifies the string in place rather than returning a new one.</p>

<p>The next sketch uses some C string functions.</p>

<h3>Example</h3>

<h3>Result</h3>

<p>The sketch works in the following way.</p>

<h3>Print the String</h3>

<p>The newly created string is printed to the Serial Monitor window as done in previous sketches.</p>

<h3>Get the Length of the String</h3>

<p>The strlen() function is used to get the length of the string. The length of the string is for the printable characters only and does not include the null terminator.</p>

<p>The string contains 17 characters, so we see 17 printed in the Serial Monitor window.</p>

<h3>Get the Length of the Array</h3>

<p>The operator sizeof() is used to get the length of the array that contains the string. The length includes the null terminator, so the length is one more than the length of the string.</p>

<p>sizeof() looks like a function, but technically is an operator. It is not a part of the C string library, but was used in the sketch to show the difference between the size of the array and the size of the string (or string length).</p>

<h3>Copy a String</h3>

<p>The strcpy() function is used to copy the str[] string to the out_num[] array. The strcpy() function copies the second string passed to it into the first string. A copy of the string now exists in the out_num[] array, but only takes up 18 elements of the array, so we still have 22 free char elements in the array. These free elements are found after the string in memory.</p>

<p>The string was copied to the array so that we would have some extra space in the array to use in the next part of the sketch, which is adding a string to the end of a string.</p>

<h3>Append a String to a String (Concatenate)</h3>

<p>The sketch joins one string to another, which is known as concatenation. This is done using the strcat() function. The strcat() function puts the second string passed to it onto the end of the first string passed to it.</p>

<p>After concatenation, the length of the string is printed to show the new string length. The length of the array is then printed to show that we have a 25-character long string in a 40 element long array.</p>

<p>Remember that the 25-character long string actually takes up 26 characters of the array because of the null terminating zero.</p>

<h2>Array Bounds</h2>

<p>When working with strings and arrays, it is very important to work within the bounds of strings or arrays. In the example sketch, an array was created, which was 40 characters long, in order to allocate the memory that could be used to manipulate strings.</p>

<p>If the array was made too small and we tried to copy a string that is bigger than the array to it, the string would be copied over the end of the array. The memory beyond the end of the array could contain other important data used in the sketch, which would then be overwritten by our string. If the memory beyond the end of the string is overrun, it could crash the sketch or cause unexpected behavior.</p>

<h1>Arduino - String Object</h1>

<p>The second type of string used in Arduino programming is the String Object.</p>

<h2>What is an Object?</h2>

<p>An object is a construct that contains both data and functions. A String object can be created just like a variable and assigned a value or string. The String object contains functions (which are called "methods" in object oriented programming (OOP)) which operate on the string data contained in the String object.</p>

<p>The following sketch and explanation will make it clear what an object is and how the String object is used.</p>

<h3>Example</h3>

<h3>Result</h3>

<p>A string object is created and assigned a value (or string) at the top of the sketch.</p>

<p>This creates a String object with the name <b>my_str</b> and gives it a value of "This is my string.".</p>

<p>This can be compared to creating a variable and assigning a value to it such as an integer &minus;</p>

<p>The sketch works in the following way.</p>

<h3>Printing the String</h3>

<p>The string can be printed to the Serial Monitor window just like a character array string.</p>

<h3>Convert the String to Upper-case</h3>

<p>The string object my_str that was created, has a number of functions or methods that can be operated on it. These methods are invoked by using the objects name followed by the dot operator (.) and then the name of the function to use.</p>

<p>The <b>toUpperCase()</b> function operates on the string contained in the <b>my_str</b> object which is of type String and converts the string data (or text) that the object contains to upper-case characters. A list of the functions that the String class contains can be found in the Arduino String reference. Technically, String is called a class and is used to create String objects.</p>

<h3>Overwrite a String</h3>

<p>The assignment operator is used to assign a new string to the <b>my_str</b> object that replaces the old string</p>

<p>The assignment operator cannot be used on character array strings, but works on String objects only.</p>

<h3>Replacing a Word in the String</h3>

<p>The replace() function is used to replace the first string passed to it by the second string passed to it. replace() is another function that is built into the String class and so is available to use on the String object my_str.</p>

<h3>Getting the Length of the String</h3>

<p>Getting the length of the string is easily done by using length(). In the example sketch, the result returned by length() is passed directly to Serial.println() without using an intermediate variable.</p>

<h2>When to Use a String Object</h2>

<p>A String object is much easier to use than a string character array. The object has built-in functions that can perform a number of operations on strings.</p>

<p>The main disadvantage of using the String object is that it uses a lot of memory and can quickly use up the Arduinos RAM memory, which may cause Arduino to hang, crash or behave unexpectedly. If a sketch on an Arduino is small and limits the use of objects, then there should be no problems.</p>

<p>Character array strings are more difficult to use and you may need to write your own functions to operate on these types of strings. The advantage is that you have control on the size of the string arrays that you make, so you can keep the arrays small to save memory.</p>

<p>You need to make sure that you do not write beyond the end of the array bounds with string arrays. The String object does not have this problem and will take care of the string bounds for you, provided there is enough memory for it to operate on. The String object can try to write to memory that does not exist when it runs out of memory, but will never write over the end of the string that it is operating on.</p>

<h3>Where Strings are Used</h3>

<p>In this chapter we studied about the strings, how they behave in memory and their operations.</p>

<p>The practical uses of strings will be covered in the next part of this course when we study how to get user input from the Serial Monitor window and save the input in a string.</p>

<h1>Arduino - Time</h1>

<p>Arduino provides four different time manipulation functions. They are &minus;</p>

<p><a href="/arduino/arduino_delay_function.htm">delay () function</a></p>

<p>The way the <b>delay()</b> function works is pretty simple. It accepts a single integer (or number) argument. This number represents the time (measured in milliseconds).</p>

<p><a href="/arduino/arduino_delaymicroseconds_function.htm">delayMicroseconds () function</a></p>

<p>The <b>delayMicroseconds()</b> function accepts a single integer (or number) argument. There are a thousand microseconds in a millisecond, and a million microseconds in a second.</p>

<p><a href="/arduino/arduino_millis_function.htm">millis () function</a></p>

<p>This function is used to return the number of milliseconds at the time, the Arduino board begins running the current program.</p>

<p><a href="/arduino/arduino_micros_function.htm">micros () function</a></p>

<p>The micros() function returns the number of microseconds from the time, the Arduino board begins running the current program. This number overflows i.e. goes back to zero after approximately 70 minutes.</p>

<h1>Arduino - Arrays</h1>

<p>An array is a consecutive group of memory locations that are of the same type. To refer to a particular location or element in the array, we specify the name of the array and the position number of the particular element in the array.</p>

<p>The illustration given below shows an integer array called C that contains 11 elements. You refer to any one of these elements by giving the array name followed by the particular element’s position number in square brackets ([]). The position number is more formally called a subscript or index (this number specifies the number of elements from the beginning of the array). The first element has subscript 0 (zero) and is sometimes called the zeros element.</p>

<p>Thus, the elements of array C are C[0] (pronounced “C sub zero”), C[1], C[2] and so on. The highest subscript in array C is 10, which is 1 less than the number of elements in the array (11). Array names follow the same conventions as other variable names.</p>

<p>A subscript must be an integer or integer expression (using any integral type). If a program uses an expression as a subscript, then the program evaluates the expression to determine the subscript. For example, if we assume that variable a is equal to 5 and that variable b is equal to 6, then the statement adds 2 to array element C[11].</p>

<p>A subscripted array name is an lvalue, it can be used on the left side of an assignment, just as non-array variable names can.</p>

<p>Let us examine array C in the given figure, more closely. The name of the entire array is C. Its 11 elements are referred to as C[0] to C[10]. The value of C[0] is -45, the value of C[1] is 6, the value of C[2] is 0, the value of C[7] is 62, and the value of C[10] is 78.</p>

<p>To print the sum of the values contained in the first three elements of array C, we would write &minus;</p>

<p>To divide the value of C[6] by 2 and assign the result to the variable x, we would write &minus;</p>

<h2>Declaring Arrays</h2>

<p>Arrays occupy space in memory. To specify the type of the elements and the number of elements required by an array, use a declaration of the form &minus;</p>

<p>The compiler reserves the appropriate amount of memory. (Recall that a declaration, which reserves memory is more properly known as a definition). The arraySize must be an integer constant greater than zero. For example, to tell the compiler to reserve 11 elements for integer array C, use the declaration &minus;</p>

<p>Arrays can be declared to contain values of any non-reference data type. For example, an array of type string can be used to store character strings.</p>

<h2>Examples Using Arrays</h2>

<p>This section gives many examples that demonstrate how to declare, initialize and manipulate arrays.</p>

<h3>Example 1: Declaring an Array and using a Loop to Initialize the Array’s Elements</h3>

<p>The program declares a 10-element integer array <b>n</b>. Lines a–b use a <b>For</b> statement to initialize the array elements to zeros. Like other automatic variables, automatic arrays are not implicitly initialized to zero. The first output statement (line c) displays the column headings for the columns printed in the subsequent for statement (lines d–e), which prints the array in tabular format.</p>

<p><b>Example</b></p>

<p><b>Result</b> &minus; It will produce the following result &minus;</p>

<h3>Example 2: Initializing an Array in a Declaration with an Initializer List</h3>

<p>The elements of an array can also be initialized in the array declaration by following the array name with an equal-to sign and a brace-delimited comma-separated list of initializers. The program uses an initializer list to initialize an integer array with 10 values (line a) and prints the array in tabular format (lines b–c).</p>

<p><b>Example</b></p>

<p><b>Result</b> &minus; It will produce the following result &minus;</p>

<h3>Example 3: Summing the Elements of an Array</h3>

<p>Often, the elements of an array represent a series of values to be used in a calculation. For example, if the elements of an array represent exam grades, a professor may wish to total the elements of the array and use that sum to calculate the class average for the exam. The program sums the values contained in the 10-element integer array <b>a</b>.</p>

<p><b>Example</b></p>

<p><b>Result</b> &minus; It will produce the following result &minus;</p>

<p>Arrays are important to Arduino and should need a lot more attention. The following important concepts related to array should be clear to a Arduino &minus;</p>

<p>To pass an array argument to a function, specify the name of the array without any brackets.</p>

<p>Arrays with two dimensions (i.e., subscripts) often represent tables of values consisting of information arranged in rows and columns.</p>

<h1>Arduino - I/O Functions</h1>

<p>The pins on the Arduino board can be configured as either inputs or outputs. We will explain the functioning of the pins in those modes. It is important to note that a majority of Arduino analog pins, may be configured, and used, in exactly the same manner as digital pins.</p>

<h2>Pins Configured as INPUT</h2>

<p>Arduino pins are by default configured as inputs, so they do not need to be explicitly declared as inputs with <b>pinMode()</b> when you are using them as inputs. Pins configured this way are said to be in a high-impedance state. Input pins make extremely small demands on the circuit that they are sampling, equivalent to a series resistor of 100 megaohm in front of the pin.</p>

<p>This means that it takes very little current to switch the input pin from one state to another. This makes the pins useful for such tasks as implementing a capacitive touch sensor or reading an LED as a photodiode.</p>

<p>Pins configured as pinMode(pin, INPUT) with nothing connected to them, or with wires connected to them that are not connected to other circuits, report seemingly random changes in pin state, picking up electrical noise from the environment, or capacitively coupling the state of a nearby pin.</p>

<h2>Pull-up Resistors</h2>

<p>Pull-up resistors are often useful to steer an input pin to a known state if no input is present. This can be done by adding a pull-up resistor (to &plus;5V), or a pull-down resistor (resistor to ground) on the input. A 10K resistor is a good value for a pull-up or pull-down resistor.</p>

<h3>Using Built-in Pull-up Resistor with Pins Configured as Input</h3>

<p>There are 20,000 pull-up resistors built into the Atmega chip that can be accessed from software. These built-in pull-up resistors are accessed by setting the <b>pinMode()</b> as INPUT_PULLUP. This effectively inverts the behavior of the INPUT mode, where HIGH means the sensor is OFF and LOW means the sensor is ON. The value of this pull-up depends on the microcontroller used. On most AVR-based boards, the value is guaranteed to be between 20kΩ and 50kΩ. On the Arduino Due, it is between 50kΩ and 150kΩ. For the exact value, consult the datasheet of the microcontroller on your board.</p>

<p>When connecting a sensor to a pin configured with INPUT_PULLUP, the other end should be connected to the ground. In case of a simple switch, this causes the pin to read HIGH when the switch is open and LOW when the switch is pressed. The pull-up resistors provide enough current to light an LED dimly connected to a pin configured as an input. If LEDs in a project seem to be working, but very dimly, this is likely what is going on.</p>

<p>Same registers (internal chip memory locations) that control whether a pin is HIGH or LOW control the pull-up resistors. Consequently, a pin that is configured to have pull-up resistors turned on when the pin is in INPUTmode, will have the pin configured as HIGH if the pin is then switched to an OUTPUT mode with pinMode(). This works in the other direction as well, and an output pin that is left in a HIGH state will have the pull-up resistor set if switched to an input with pinMode().</p>

<p><b>Example</b></p>

<h2>Pins Configured as OUTPUT</h2>

<p>Pins configured as OUTPUT with pinMode() are said to be in a low-impedance state. This means that they can provide a substantial amount of current to other circuits. Atmega pins can source (provide positive current) or sink (provide negative current) up to 40 mA (milliamps) of current to other devices/circuits. This is enough current to brightly light up an LED (do not forget the series resistor), or run many sensors but not enough current to run relays, solenoids, or motors.</p>

<p>Attempting to run high current devices from the output pins, can damage or destroy the output transistors in the pin, or damage the entire Atmega chip. Often, this results in a "dead" pin in the microcontroller but the remaining chips still function adequately. For this reason, it is a good idea to connect the OUTPUT pins to other devices through 470Ω or 1k resistors, unless maximum current drawn from the pins is required for a particular application.</p>

<h2>pinMode() Function</h2>

<p>The pinMode() function is used to configure a specific pin to behave either as an input or an output. It is possible to enable the internal pull-up resistors with the mode INPUT_PULLUP. Additionally, the INPUT mode explicitly disables the internal pull-ups.</p>

<h3>pinMode() Function Syntax</h3>

<p><b>pin</b> &minus; the number of the pin whose mode you wish to set</p>

<p><b>mode</b> &minus; INPUT, OUTPUT, or INPUT_PULLUP.</p>

<p><b>Example</b></p>

<h2>digitalWrite() Function</h2>

<p>The <b>digitalWrite()</b> function is used to write a HIGH or a LOW value to a digital pin. If the pin has been configured as an OUTPUT with <a href="https://www.arduino.cc/en/Reference/PinMode" rel="nofollow" target="_blank">pinMode()</a>, its voltage will be set to the corresponding value: 5V (or 3.3V on 3.3V boards) for HIGH, 0V (ground) for LOW. If the pin is configured as an INPUT, digitalWrite() will enable (HIGH) or disable (LOW) the internal pullup on the input pin. It is recommended to set the <a href="https://www.arduino.cc/en/Reference/PinMode" rel="nofollow" target="_blank">pinMode()</a> to INPUT_PULLUP to enable the internal pull-up resistor.</p>

<p>If you do not set the pinMode() to OUTPUT, and connect an LED to a pin, when calling digitalWrite(HIGH), the LED may appear dim. Without explicitly setting pinMode(), digitalWrite() will have enabled the internal pull-up resistor, which acts like a large current-limiting resistor.</p>

<h3>digitalWrite() Function Syntax</h3>

<p><b>pin</b> &minus; the number of the pin whose mode you wish to set</p>

<p><b>value</b> &minus; HIGH, or LOW.</p>

<p><b>Example</b></p>

<h2>analogRead( ) function</h2>

<p>Arduino is able to detect whether there is a voltage applied to one of its pins and report it through the digitalRead() function. There is a difference between an on/off sensor (which detects the presence of an object) and an analog sensor, whose value continuously changes. In order to read this type of sensor, we need a different type of pin.</p>

<p>In the lower-right part of the Arduino board, you will see six pins marked “Analog In”. These special pins not only tell whether there is a voltage applied to them, but also its value. By using the <b>analogRead()</b> function, we can read the voltage applied to one of the pins.</p>

<p>This function returns a number between 0 and 1023, which represents voltages between 0 and 5 volts. For example, if there is a voltage of 2.5 V applied to pin number 0, analogRead(0) returns 512.</p>

<h3>analogRead() function Syntax</h3>

<p><b>pin</b> &minus; the number of the analog input pin to read from (0 to 5 on most boards, 0 to 7 on the Mini and Nano, 0 to 15 on the Mega)</p>

<p><b>Example</b></p>

<h1>Arduino - Advanced I/O Function</h1>

<p>In this chapter, we will learn some advanced Input and Output Functions.</p>

<h2>analogReference() Function</h2>

<p>Configures the reference voltage used for analog input (i.e. the value used as the top of the input range). The options are &minus;</p>

<p><b>DEFAULT</b> &minus; The default analog reference of 5 volts (on 5V Arduino boards) or 3.3 volts (on 3.3V Arduino boards)</p>

<p><b>INTERNAL</b> &minus; An built-in reference, equal to 1.1 volts on the ATmega168 or ATmega328 and 2.56 volts on the ATmega8 (not available on the Arduino Mega)</p>

<p><b>INTERNAL1V1</b> &minus; A built-in 1.1V reference (Arduino Mega only)</p>

<p><b>INTERNAL2V56</b> &minus; A built-in 2.56V reference (Arduino Mega only)</p>

<p><b>EXTERNAL</b> &minus; The voltage applied to the AREF pin (0 to 5V only) is used as the reference</p>

<h3>analogReference() Function Syntax</h3>

<p><b>type</b> &minus; can use any type of the follow (DEFAULT, INTERNAL, INTERNAL1V1, INTERNAL2V56, EXTERNAL)</p>

<p>Do not use anything less than 0V or more than 5V for external reference voltage on the AREF pin. If you are using an external reference on the AREF pin, you must set the analog reference to EXTERNAL before calling the <b>analogRead()</b> function. Otherwise, you will short the active reference voltage (internally generated) and the AREF pin, possibly damaging the microcontroller on your Arduino board.</p>

<p>Alternatively, you can connect the external reference voltage to the AREF pin through a 5K resistor, allowing you to switch between external and internal reference voltages.</p>

<p>Note that the resistor will alter the voltage that is used as the reference because there is an internal 32K resistor on the AREF pin. The two act as a voltage divider. For example, 2.5V applied through the resistor will yield 2.5 * 32 / (32 &plus; 5) = ~2.2V at the AREF pin.</p>

<p><b>Example</b></p>

<h1>Arduino - Character Functions</h1>

<p>All data is entered into computers as characters, which includes letters, digits and various special symbols. In this section, we discuss the capabilities of C++ for examining and manipulating individual characters.</p>

<p>The character-handling library includes several functions that perform useful tests and manipulations of character data. Each function receives a character, represented as an int, or EOF as an argument. Characters are often manipulated as integers.</p>

<p>Remember that EOF normally has the value –1 and that some hardware architectures do not allow negative values to be stored in char variables. Therefore, the character-handling functions manipulate characters as integers.</p>

<p>The following table summarizes the functions of the character-handling library. When using functions from the character-handling library, include the <b>&lt;cctype&gt;</b> header.</p>

<p><b>int isdigit( int c )</b></p>

<p>Returns 1 if c is a digit and 0 otherwise.</p>

<p><b>int isalpha( int c )</b></p>

<p>Returns 1 if c is a letter and 0 otherwise.</p>

<p><b>int isalnum( int c )</b></p>

<p>Returns 1 if c is a digit or a letter and 0 otherwise.</p>

<p><b>int isxdigit( int c )</b></p>

<p>Returns 1 if c is a hexadecimal digit character and 0 otherwise.</p>

<p>(See Appendix D, Number Systems, for a detailed explanation of binary, octal, decimal and hexadecimal numbers.)</p>

<p><b>int islower( int c )</b></p>

<p>Returns 1 if c is a lowercase letter and 0 otherwise.</p>

<p><b>int isupper( int c )</b></p>

<p>Returns 1 if c is an uppercase letter; 0 otherwise.</p>

<p><b>int isspace( int c )</b></p>

<p>Returns 1 if c is a white-space character—newline ('\n'), space</p>

<p>(' '), form feed ('\f'), carriage return ('\r'), horizontal tab ('\t'), or vertical tab ('\v')—and 0 otherwise.</p>

<p><b>int iscntrl( int c )</b></p>

<p>Returns 1 if c is a control character, such as newline ('\n'), form feed ('\f'), carriage return ('\r'), horizontal tab ('\t'), vertical tab ('\v'), alert ('\a'), or backspace ('\b')—and 0 otherwise.</p>

<p><b>int ispunct( int c )</b></p>

<p>Returns 1 if c is a printing character other than a space, a digit, or a letter and 0 otherwise.</p>

<p><b>int isprint( int c )</b></p>

<p>Returns 1 if c is a printing character including space (' ') and 0 otherwise.</p>

<p><b>int isgraph( int c )</b></p>

<p>Returns 1 if c is a printing character other than space (' ') and 0 otherwise.</p>

<h2>Examples</h2>

<p>The following example demonstrates the use of the functions <b>isdigit, isalpha, isalnum</b> and <b>isxdigit</b>. Function <b>isdigit</b> determines whether its argument is a digit (0–9). The function <b>isalpha</b> determines whether its argument is an uppercase letter (A-Z) or a lowercase letter (a–z). The function <b>isalnum</b> determines whether its argument is an uppercase, lowercase letter or a digit. Function <b>isxdigit</b> determines whether its argument is a hexadecimal digit (A–F, a–f, 0–9).</p>

<h3>Example 1</h3>

<h3>Result</h3>

<p>We use the conditional operator <b>(?:)</b> with each function to determine whether the string " is a " or the string " is not a " should be printed in the output for each character tested. For example, line <b>a</b> indicates that if '8' is a digit—i.e., if <b>isdigit</b> returns a true (nonzero) value—the string "8 is a " is printed. If '8' is not a digit (i.e., if <b>isdigit</b> returns 0), the string " 8 is not a " is printed.</p>

<h3>Example 2</h3>

<p>The following example demonstrates the use of the functions <b>islower</b> and <b>isupper</b>. The function <b>islower</b> determines whether its argument is a lowercase letter (a–z). Function <b>isupper</b> determines whether its argument is an uppercase letter (A–Z).</p>

<h3>Result</h3>

<h3>Example 3</h3>

<p>The following example demonstrates the use of functions <b>isspace, iscntrl, ispunct, isprint</b> and <b>isgraph</b>.</p>

<p>The function <b>isspace</b> determines whether its argument is a white-space character, such as space (' '), form feed ('\f'), newline ('\n'), carriage return ('\r'), horizontal tab ('\t') or vertical tab ('\v').</p>

<p>The function <b>iscntrl</b> determines whether its argument is a control character such as horizontal tab ('\t'), vertical tab ('\v'), form feed ('\f'), alert ('\a'), backspace ('\b'), carriage return ('\r') or newline ('\n').</p>

<p>The function <b>ispunct</b> determines whether its argument is a printing character other than a space, digit or letter, such as $, #, (, ), [, ], {, }, ;, : or %.</p>

<p>The function <b>isprint</b> determines whether its argument is a character that can be displayed on the screen (including the space character).</p>

<p>The function <b>isgraph</b> tests for the same characters as isprint, but the space character is not included.</p>

<h3>Result</h3>

<h1>Arduino - Math Library</h1>

<p>The Arduino Math library (math.h) includes a number of useful mathematical functions for manipulating floating-point numbers.</p>

<h2>Library Macros</h2>

<p>Following are the macros defined in the header math.h &minus;</p>

<p>1.4426950408889634074</p>

<p>/* log_2 e */</p>

<p>0.31830988618379067154</p>

<p>/* 1/pi */</p>

<p>0.63661977236758134308</p>

<p>/* 2/pi */</p>

<p>1.12837916709551257390</p>

<p>/* 2/sqrt(pi) */</p>

<p>2.30258509299404568402</p>

<p>/* log_e 10 */</p>

<p>0.69314718055994530942</p>

<p>/* log_e 2 */</p>

<p>0.43429448190325182765</p>

<p>/* log_10 e */</p>

<p>3.14159265358979323846</p>

<p>/* pi */</p>

<p>3.3V1.57079632679489661923</p>

<p>/* pi/2 */</p>

<p>0.78539816339744830962</p>

<p>/* pi/4 */</p>

<p>0.70710678118654752440</p>

<p>/* 1/sqrt(2) */</p>

<p>1.41421356237309504880</p>

<p>/* sqrt(2) */</p>

<h2>Library Functions</h2>

<p>The following functions are defined in the header <b>math.h</b> &minus;</p>

<p><b>double acos (double __x)</b></p>

<p>The acos() function computes the principal value of the arc cosine of __x. The returned value is in the range [0, pi] radians. A domain error occurs for arguments not in the range [-1, +1].</p>

<p><b>double asin (double __x)</b></p>

<p>The asin() function computes the principal value of the arc sine of __x. The returned value is in the range [-pi/2, pi/2] radians. A domain error occurs for arguments not in the range [-1, +1].</p>

<p><b>double atan (double __x)</b></p>

<p>The atan() function computes the principal value of the arc tangent of __x. The returned value is in the range [-pi/2, pi/2] radians.</p>

<p><b>double atan2 (double __y, double __x)</b></p>

<p>The atan2() function computes the principal value of the arc tangent of __y / __x, using the signs of both arguments to determine the quadrant of the return value. The returned value is in the range [-pi, +pi] radians.</p>

<p><b>double cbrt (double __x)</b></p>

<p>The cbrt() function returns the cube root of __x.</p>

<p><b>double ceil (double __x)</b></p>

<p>The ceil() function returns the smallest integral value greater than or equal to __x, expressed as a floating-point number.</p>

<p><b>static double copysign (double __x, double __y)</b></p>

<p>The copysign() function returns __x but with the sign of __y. They work even if __x or __y are NaN or zero.</p>

<p><b>double cos(double __x)</b></p>

<p>The cos() function returns the cosine of __x, measured in radians.</p>

<p><b>double cosh (double __x)</b></p>

<p>The cosh() function returns the hyperbolic cosine of __x.</p>

<p><b>double exp (double __x)</b></p>

<p>The exp() function returns the exponential value of __x.</p>

<p><b>double fabs (double __x)</b></p>

<p>The fabs() function computes the absolute value of a floating-point number __x.</p>

<p><b>double fdim (double __x, double __y)</b></p>

<p>The fdim() function returns max(__x - __y, 0). If __x or __y or both are NaN, NaN is returned.</p>

<p><b>double floor (double __x)</b></p>

<p>The floor() function returns the largest integral value less than or equal to __x, expressed as a floating-point number.</p>

<p><b>double fma (double __x, double __y, double __z)</b></p>

<p>The fma() function performs floating-point multiply-add. This is the operation (__x * __y) + __z, but the intermediate result is not rounded to the destination type. This can sometimes improve the precision of a calculation.</p>

<p><b>double fmax (double __x, double __y)</b></p>

<p>The fmax() function returns the greater of the two values __x and __y. If an argument is NaN, the other argument is returned. If both the arguments are NaN, NaN is returned.</p>

<p><b>double fmin (double __x, double __y)</b></p>

<p>The fmin() function returns the lesser of the two values __x and __y. If an argument is NaN, the other argument is returned. If both the arguments are NaN, NaN is returned.</p>

<p><b>double fmod (double __x, double__y)</b></p>

<p>The function fmod() returns the floating-point remainder of __x / __y.</p>

<p><b>double frexp (double __x, int * __pexp)</b></p>

<p>The frexp() function breaks a floating-point number into a normalized fraction and an integral power of 2. It stores the integer in the int object pointed to by __pexp. If __x is a normal float point number, the frexp() function returns the value v, such that v has a magnitude in the interval [1/2, 1) or zero, and __x equals v times 2 raised to the power __pexp. If __x is zero, both parts of the result are zero. If __x is not a finite number, the frexp() returns __x as is and stores 0 by __pexp.</p>

<p><b>Note</b> &minus; This implementation permits a zero pointer as a directive to skip a storing the exponent.</p>

<p><b>double hypot (double __x, double__y)</b></p>

<p>The hypot() function returns sqrt(__x*__x + __y*__y). This is the length of the hypotenuse of a right triangle with sides of length __x and __y, or the distance of the point (__x, __y) from the origin. Using this function instead of the direct formula is wise, since the error is much smaller. No underflow with small __x and __y. No overflow if result is in range.</p>

<p><b>static int isfinite (double __x)</b></p>

<p>The isfinite() function returns a nonzero value if __x is finite: not plus or minus infinity, and not <b>NaN</b>.</p>

<p><b>int isinf (double __x)</b></p>

<p>The function isinf() returns 1 if the argument __x is positive infinity, -1 if __x is negative infinity, and 0 otherwise.</p>

<p><b>Note</b> &minus; The GCC 4.3 can replace this function with inline code that returns the 1 value for both infinities (gcc bug #35509).</p>

<p><b>int isnan (double __x)</b></p>

<p>The function isnan() returns 1 if the argument __x represents a "not-a-number" (<b>NaN</b>) object, otherwise 0.</p>

<p><b>double ldexp (double __x, int __exp )</b></p>

<p>The ldexp() function multiplies a floating-point number by an integral power of 2. It returns the value of __x times 2 raised to the power __exp.</p>

<p><b>double log (double __x)</b></p>

<p>The log() function returns the natural logarithm of argument __x.</p>

<p><b>double log10(double __x)</b></p>

<p>The log10() function returns the logarithm of argument __x to base 10.</p>

<p><b>long lrint (double __x)</b></p>

<p>The lrint() function rounds __x to the nearest integer, rounding the halfway cases to the even integer direction. (That is both 1.5 and 2.5 values are rounded to 2). This function is similar to rint() function, but it differs in type of return value and in that an overflow is possible.</p>

<p><b>Returns</b></p>

<p>The rounded long integer value. If __x is not a finite number or an overflow, this realization returns the LONG_MIN value (0x80000000).</p>

<p><b>long lround (double __x)</b></p>

<p>The lround() function rounds __x to the nearest integer, but rounds halfway cases away from zero (instead of to the nearest even integer). This function is similar to round() function, but it differs in type of return value and in that an overflow is possible.</p>

<p><b>Returns</b></p>

<p>The rounded long integer value. If __x is not a finite number or an overflow was, this realization returns the LONG_MIN value (0x80000000).</p>

<p><b>double modf (double __x, double * __iptr )</b></p>

<p>The modf() function breaks the argument __x into integral and fractional parts, each of which has the same sign as the argument. It stores the integral part as a double in the object pointed to by __iptr.</p>

<p>The modf() function returns the signed fractional part of __x.</p>

<p><b>Note</b> &minus; This implementation skips writing by zero pointer. However, the GCC 4.3 can replace this function with inline code that does not permit to use NULL address for the avoiding of storing.</p>

<p><b>float modff (float __x, float * __iptr)</b></p>

<p>The alias for modf().</p>

<p><b>double pow (double __x, double __y)</b></p>

<p>The function pow() returns the value of __x to the exponent __y.</p>

<p><b>double round (double __x)</b></p>

<p>The round() function rounds __x to the nearest integer, but rounds halfway cases away from zero (instead of to the nearest even integer). Overflow is impossible.</p>

<p><b>Returns</b></p>

<p>The rounded value. If __x is an integral or infinite, __x itself is returned. If __x is <b>NaN</b>, then <b>NaN</b> is returned.</p>

<p><b>int signbit (double __x)</b></p>

<p>The signbit() function returns a nonzero value if the value of __x has its sign bit set. This is not the same as `__x &lt; 0.0', because IEEE 754 floating point allows zero to be signed. The comparison `-0.0 &lt; 0.0' is false, but `signbit (-0.0)' will return a nonzero value.</p>

<p><b>double sin (double __x)</b></p>

<p>The sin() function returns the sine of __x, measured in radians.</p>

<p><b>double sinh (double __x)</b></p>

<p>The sinh() function returns the hyperbolic sine of __x.</p>

<p><b>double sqrt (double __x)</b></p>

<p>The sqrt() function returns the non-negative square root of __x.</p>

<p><b>double square (double __x)</b></p>

<p>The function square() returns __x * __x.</p>

<p><b>Note</b> &minus; This function does not belong to the C standard definition.</p>

<p><b>double tan (double __x)</b></p>

<p>The tan() function returns the tangent of __x, measured in radians.</p>

<p><b>double tanh ( double __x)</b></p>

<p>The tanh() function returns the hyperbolic tangent of __x.</p>

<p><b>double trunc (double __x)</b></p>

<p>The trunc() function rounds __x to the nearest integer not larger in absolute value.</p>

<h2>Example</h2>

<p>The following example shows how to use the most common math.h library functions &minus;</p>

<h3>Result</h3>

<h1>Arduino - Trigonometric Functions</h1>

<p>You need to use Trigonometry practically like calculating the distance for moving object or angular speed. Arduino provides traditional trigonometric functions (sin, cos, tan, asin, acos, atan) that can be summarized by writing their prototypes. Math.h contains the trigonometry function's prototype.</p>

<h2>Trigonometric Exact Syntax</h2>

<h3>Example</h3>

<h1>Arduino - Due &amp; Zero</h1>

<p>The Arduino Due is a microcontroller board based on the Atmel SAM3X8E ARM Cortex-M3 CPU. It is the first Arduino board based on a 32-bit ARM core microcontroller.</p>

<p>Important features &minus;</p>

<h3>Characteristics of the Arduino Due Board</h3>

<h3>Communication</h3>

<p>Unlike most Arduino boards, the Arduino Due board runs at 3.3V. The maximum voltage that the I/O pins can tolerate is 3.3V. Applying voltages higher than 3.3V to any I/O pin could damage the board.</p>

<p>The board contains everything needed to support the microcontroller. You can simply connect it to a computer with a micro-USB cable or power it with an AC-to-DC adapter or battery to get started. The Due is compatible with all Arduino shields that work at 3.3V.</p>

<h2>Arduino Zero</h2>

<p>The Zero is a simple and powerful 32-bit extension of the platform established by the UNO. The Zero board expands the family by providing increased performance, enabling a variety of project opportunities for devices, and acts as a great educational tool for learning about 32-bit application development.</p>

<p>Important features are &minus;</p>

<p>The Zero applications span from smart IoT devices, wearable technology, high-tech automation, to crazy robotics.</p>

<p>The board is powered by Atmel’s SAMD21 MCU, which features a 32-bit ARM Cortex&reg; M0+ core.</p>

<p>One of its most important features is Atmel’s Embedded Debugger (EDBG), which provides a full debug interface without the need for additional hardware, significantly increasing the ease-of-use for software debugging.</p>

<p>EDBG also supports a virtual COM port that can be used for device and bootloader programming.</p>

<h3>Characteristics of the Arduino Zero board</h3>

<p>Unlike most Arduino and Genuino boards, the Zero runs at 3.3V. The maximum voltage that the I/O pins can tolerate is 3.3V. Applying voltages higher than 3.3V to any I/O pin could damage the board.</p>

<p>The board contains everything needed to support the microcontroller. You can simply connect it to a computer with a micro-USB cable or power it with an AC-to-DC adapter or a battery to get started. The Zero is compatible with all the shields that work at 3.3V.</p>

<h1>Arduino - Pulse Width Modulation</h1>

<p>Pulse Width Modulation or PWM is a common technique used to vary the width of the pulses in a pulse-train. PWM has many applications such as controlling servos and speed controllers, limiting the effective power of motors and LEDs.</p>

<h2>Basic Principle of PWM</h2>

<p>Pulse width modulation is basically, a square wave with a varying high and low time. A basic PWM signal is shown in the following figure.</p>

<p>There are various terms associated with PWM &minus;</p>

<p><b>On-Time</b> &minus; Duration of time signal is high.</p>

<p><b>Off-Time</b> &minus; Duration of time signal is low.</p>

<p><b>Period</b> &minus; It is represented as the sum of on-time and off-time of PWM signal.</p>

<p><b>Duty Cycle</b> &minus; It is represented as the percentage of time signal that remains on during the period of the PWM signal.</p>

<h3>Period</h3>

<p>As shown in the figure, T<sub>on</sub> denotes the on-time and T<sub>off</sub> denotes the off-time of signal. Period is the sum of both on and off times and is calculated as shown in the following equation &minus;</p>

<h3>Duty Cycle</h3>

<p>Duty cycle is calculated as the on-time of the period of time. Using the period calculated above, duty cycle is calculated as &minus;</p>

<h2>analogWrite() Function</h2>

<p>The <b>analogWrite()</b> function writes an analog value (PWM wave) to a pin. It can be used to light a LED at varying brightness or drive a motor at various speeds. After a call of the analogWrite() function, the pin will generate a steady square wave of the specified duty cycle until the next call to analogWrite() or a call to digitalRead() or digitalWrite() on the same pin. The frequency of the PWM signal on most pins is approximately 490 Hz. On the Uno and similar boards, pins 5 and 6 have a frequency of approximately 980 Hz. Pins 3 and 11 on the Leonardo also run at 980 Hz.</p>

<p>On most Arduino boards (those with the ATmega168 or ATmega328), this function works on pins 3, 5, 6, 9, 10, and 11. On the Arduino Mega, it works on pins 2 - 13 and 44 - 46. Older Arduino boards with an ATmega8 only support <b>analogWrite()</b> on pins 9, 10, and 11.</p>

<p>The Arduino Due supports <b>analogWrite()</b> on pins 2 through 13, and pins DAC0 and DAC1. Unlike the PWM pins, DAC0 and DAC1 are Digital to Analog converters, and act as true analog outputs.</p>

<p>You do not need to call pinMode() to set the pin as an output before calling analogWrite().</p>

<h3>analogWrite() Function Syntax</h3>

<p><b>value</b> &minus; the duty cycle: between 0 (always off) and 255 (always on).</p>

<p><b>Example</b></p>

<h1>Arduino - Random Numbers</h1>

<p>To generate random numbers, you can use Arduino random number functions. We have two functions &minus;</p>

<h2>randomSeed (seed)</h2>

<p>The function randomSeed(seed) resets Arduino’s pseudorandom number generator. Although the distribution of the numbers returned by random() is essentially random, the sequence is predictable. You should reset the generator to some random value. If you have an unconnected analog pin, it might pick up random noise from the surrounding environment. These may be radio waves, cosmic rays, electromagnetic interference from cell phones, fluorescent lights and so on.</p>

<h3>Example</h3>

<h2>random( )</h2>

<p>The random function generates pseudo-random numbers. Following is the syntax.</p>

<h3>random( ) Statements Syntax</h3>

<h3>Example</h3>

<p>Let us now refresh our knowledge on some of the basic concepts such as bits and bytes.</p>

<h2>Bits</h2>

<p>A bit is just a binary digit.</p>

<p>The binary system uses two digits, 0 and 1.</p>

<p>Similar to the decimal number system, in which digits of a number do not have the same value, the ‘significance’ of a bit depends on its position in the binary number. For example, digits in the decimal number 666 are the same, but have different values.</p>

<h2>Bytes</h2>

<p>A byte consists of eight bits.</p>

<p>If a bit is a digit, it is logical that bytes represent numbers.</p>

<p>All mathematical operations can be performed upon them.</p>

<p>The digits in a byte do not have the same significance either.</p>

<p>The leftmost bit has the greatest value called the Most Significant Bit (MSB).</p>

<p>The rightmost bit has the least value and is therefore, called the Least Significant Bit (LSB).</p>

<p>Since eight zeros and ones of one byte can be combined in 256 different ways, the largest decimal number that can be represented by one byte is 255 (one combination represents a zero).</p>

<h1>Arduino - Interrupts</h1>

<p>Interrupts stop the current work of Arduino such that some other work can be done.</p>

<p>Suppose you are sitting at home, chatting with someone. Suddenly the telephone rings. You stop chatting, and pick up the telephone to speak to the caller. When you have finished your telephonic conversation, you go back to chatting with the person before the telephone rang.</p>

<p>Similarly, you can think of the main routine as chatting to someone, the telephone ringing causes you to stop chatting. The interrupt service routine is the process of talking on the telephone. When the telephone conversation ends, you then go back to your main routine of chatting. This example explains exactly how an interrupt causes a processor to act.</p>

<p>The main program is running and performing some function in a circuit. However, when an interrupt occurs the main program halts while another routine is carried out. When this routine finishes, the processor goes back to the main routine again.</p>

<h3>Important features</h3>

<p>Here are some important features about interrupts &minus;</p>

<p>Interrupts can come from various sources. In this case, we are using a hardware interrupt that is triggered by a state change on one of the digital pins.</p>

<p>Most Arduino designs have two hardware interrupts (referred to as "interrupt0" and "interrupt1") hard-wired to digital I/O pins 2 and 3, respectively.</p>

<p>The Arduino Mega has six hardware interrupts including the additional interrupts ("interrupt2" through "interrupt5") on pins 21, 20, 19, and 18.</p>

<p>You can define a routine using a special function called as “Interrupt Service Routine” (usually known as ISR).</p>

<p>You can define the routine and specify conditions at the rising edge, falling edge or both. At these specific conditions, the interrupt would be serviced.</p>

<p>It is possible to have that function executed automatically, each time an event happens on an input pin.</p>

<h2>Types of Interrupts</h2>

<p>There are two types of interrupts &minus;</p>

<p><b>Hardware Interrupts</b> &minus; They occur in response to an external event, such as an external interrupt pin going high or low.</p>

<p><b>Software Interrupts</b> &minus; They occur in response to an instruction sent in software. The only type of interrupt that the “Arduino language” supports is the attachInterrupt() function.</p>

<h3>Using Interrupts in Arduino</h3>

<p>Interrupts are very useful in Arduino programs as it helps in solving timing problems. A good application of an interrupt is reading a rotary encoder or observing a user input. Generally, an ISR should be as short and fast as possible. If your sketch uses multiple ISRs, only one can run at a time. Other interrupts will be executed after the current one finishes in an order that depends on the priority they have.</p>

<p>Typically, global variables are used to pass data between an ISR and the main program. To make sure variables shared between an ISR and the main program are updated correctly, declare them as volatile.</p>

<h3>attachInterrupt Statement Syntax</h3>

<p>The following three constants are predefined as valid values &minus;</p>

<p><b>LOW</b> to trigger the interrupt whenever the pin is low.</p>

<p><b>CHANGE</b> to trigger the interrupt whenever the pin changes value.</p>

<p><b>FALLING</b> whenever the pin goes from high to low.</p>

<p><b>Example</b></p>

<h1>Arduino - Communication</h1>

<p>Hundreds of communication protocols have been defined to achieve this data exchange. Each protocol can be categorized into one of the two categories: parallel or serial.</p>

<h2>Parallel Communication</h2>

<p>Parallel connection between the Arduino and peripherals via input/output ports is the ideal solution for shorter distances up to several meters. However, in other cases when it is necessary to establish communication between two devices for longer distances it is not possible to use parallel connection. Parallel interfaces transfer multiple bits at the same time. They usually require buses of data - transmitting across eight, sixteen, or more wires. Data is transferred in huge, crashing waves of 1’s and 0’s.</p>

<h3>Advantages and Drawbacks of Parallel Communication</h3>

<p>Parallel communication certainly has its advantages. It is faster than serial, straightforward, and relatively easy to implement. However, it requires many input/output (I/O) ports and lines. If you have ever had to move a project from a basic Arduino Uno to a Mega, you know that the I/O lines on a microprocessor can be precious and few. Therefore, we prefer serial communication, sacrificing potential speed for pin real estate.</p>

<h2>Serial Communication Modules</h2>

<p>Today, most Arduino boards are built with several different systems for serial communication as standard equipment.</p>

<p>Which of these systems are used depends on the following factors &minus;</p>

<p>One of the most important things concerning serial communication is the <b>Protocol</b>, which should be strictly observed. It is a set of rules, which must be applied such that the devices can correctly interpret data they mutually exchange. Fortunately, Arduino automatically takes care of this, so that the work of the programmer/user is reduced to simple write (data to be sent) and read (received data).</p>

<h2>Types of Serial Communications</h2>

<p>Serial communication can be further classified as &minus;</p>

<p><b>Synchronous</b> &minus; Devices that are synchronized use the same clock and their timing is in synchronization with each other.</p>

<p><b>Asynchronous</b> &minus; Devices that are asynchronous have their own clocks and are triggered by the output of the previous state.</p>

<p>It is easy to find out if a device is synchronous or not. If the same clock is given to all the connected devices, then they are synchronous. If there is no clock line, it is asynchronous.</p>

<p>For example, UART (Universal Asynchronous Receiver Transmitter) module is asynchronous.</p>

<p>The asynchronous serial protocol has a number of built-in rules. These rules are nothing but mechanisms that help ensure robust and error-free data transfers. These mechanisms, which we get for eschewing the external clock signal, are &minus;</p>

<h3>Synchronization Bits</h3>

<p>The synchronization bits are two or three special bits transferred with each packet of data. They are the start bit and the stop bit(s). True to their name, these bits mark the beginning and the end of a packet respectively.</p>

<p>There is always only one start bit, but the number of stop bits is configurable to either one or two (though it is normally left at one).</p>

<p>The start bit is always indicated by an idle data line going from 1 to 0, while the stop bit(s) will transition back to the idle state by holding the line at 1.</p>

<h3>Data Bits</h3>

<p>The amount of data in each packet can be set to any size from 5 to 9 bits. Certainly, the standard data size is your basic 8-bit byte, but other sizes have their uses. A 7-bit data packet can be more efficient than 8, especially if you are just transferring 7-bit ASCII characters.</p>

<h3>Parity Bits</h3>

<p>The user can select whether there should be a parity bit or not, and if yes, whether the parity should be odd or even. The parity bit is 0 if the number of 1’s among the data bits is even. Odd parity is just the opposite.</p>

<h3>Baud Rate</h3>

<p>The term baud rate is used to denote the number of bits transferred per second [bps]. Note that it refers to bits, not bytes. It is usually required by the protocol that each byte is transferred along with several control bits. It means that one byte in serial data stream may consist of 11 bits. For example, if the baud rate is 300 bps then maximum 37 and minimum 27 bytes may be transferred per second.</p>

<h2>Arduino UART</h2>

<p>The following code will make Arduino send hello world when it starts up.</p>

<p>After the Arduino sketch has been uploaded to Arduino, open the Serial monitor <img class="inline" src="/arduino/images/search.jpg" alt="Search" /> at the top right section of Arduino IDE.</p>

<p>Type anything into the top box of the Serial Monitor and press send or enter on your keyboard. This will send a series of bytes to the Arduino.</p>

<p>The following code returns whatever it receives as an input.</p>

<p>The following code will make Arduino deliver output depending on the input provided.</p>

<p>Notice that <b>Serial.print</b> and <b>Serial.println</b> will send back the actual ASCII code, whereas <b>Serial.write</b> will send back the actual text. See ASCII codes for more information.</p>

<h1>Arduino - Inter Integrated Circuit</h1>

<p>Inter-integrated circuit (I2C) is a system for serial data exchange between the microcontrollers and specialized integrated circuits of a new generation. It is used when the distance between them is short (receiver and transmitter are usually on the same printed board). Connection is established via two conductors. One is used for data transfer and the other is used for synchronization (clock signal).</p>

<p>As seen in the following figure, one device is always a master. It performs addressing of one slave chip before the communication starts. In this way, one microcontroller can communicate with 112 different devices. Baud rate is usually 100 Kb/sec (standard mode) or 10 Kb/sec (slow baud rate mode). Systems with the baud rate of 3.4 Mb/sec have recently appeared. The distance between devices, which communicate over an I2C bus is limited to several meters.</p>

<h2>Board I2C Pins</h2>

<p>The I2C bus consists of two signals &minus; SCL and SDA. SCL is the clock signal, and SDA is the data signal. The current bus master always generates the clock signal. Some slave devices may force the clock low at times to delay the master sending more data (or to require more time to prepare data before the master attempts to clock it out). This is known as “clock stretching”.</p>

<p>Following are the pins for different Arduino boards &minus;</p>

<h2>Arduino I2C</h2>

<p>We have two modes - master code and slave code - to connect two Arduino boards using I2C. They are &minus;</p>

<h2>Master Transmitter / Slave Receiver</h2>

<p>Let us now see what is master transmitter and slave receiver.</p>

<h3>Master Transmitter</h3>

<p>The following functions are used to initialize the Wire library and join the I2C bus as a master or slave. This is normally called only once.</p>

<p><b>Wire.begin(address)</b> &minus; Address is the 7-bit slave address in our case as the master is not specified and it will join the bus as a master.</p>

<p><b>Wire.beginTransmission(address)</b> &minus; Begin a transmission to the I2C slave device with the given address.</p>

<p><b>Wire.write(value)</b> &minus; Queues bytes for transmission from a master to slave device (in-between calls to beginTransmission() and endTransmission()).</p>

<p><b>Wire.endTransmission()</b> &minus; Ends a transmission to a slave device that was begun by beginTransmission() and transmits the bytes that were queued by wire.write().</p>

<p><b>Example</b></p>

<h3>Slave Receiver</h3>

<p>The following functions are used &minus;</p>

<p><b>Wire.begin(address)</b> &minus; Address is the 7-bit slave address.</p>

<p><b>Wire.onReceive(received data handler)</b> &minus; Function to be called when a slave device receives data from the master.</p>

<p><b>Wire.available()</b> &minus; Returns the number of bytes available for retrieval with Wire.read().This should be called inside the Wire.onReceive() handler.</p>

<p><b>Example</b></p>

<h2>Master Receiver / Slave Transmitter</h2>

<p>Let us now see what is master receiver and slave transmitter.</p>

<h3>Master Receiver</h3>

<p>The Master, is programmed to request, and then read bytes of data that are sent from the uniquely addressed Slave Arduino.</p>

<p>The following function is used &minus;</p>

<p><b>Wire.requestFrom(address,number of bytes)</b> &minus; Used by the master to request bytes from a slave device. The bytes may then be retrieved with the functions wire.available() and wire.read() functions.</p>

<p><b>Example</b></p>

<h3>Slave Transmitter</h3>

<p>The following function is used.</p>

<p><b>Wire.onRequest(handler)</b> &minus; A function is called when a master requests data from this slave device.</p>

<p><b>Example</b></p>

<h1>Arduino - Serial Peripheral Interface</h1>

<p>A Serial Peripheral Interface (SPI) bus is a system for serial communication, which uses up to four conductors, commonly three. One conductor is used for data receiving, one for data sending, one for synchronization and one alternatively for selecting a device to communicate with. It is a full duplex connection, which means that the data is sent and received simultaneously. The maximum baud rate is higher than that in the I2C communication system.</p>

<h2>Board SPI Pins</h2>

<p>SPI uses the following four wires &minus;</p>

<p><b>SCK</b> &minus; This is the serial clock driven by the master.</p>

<p><b>MOSI</b> &minus; This is the master output / slave input driven by the master.</p>

<p><b>MISO</b> &minus; This is the master input / slave output driven by the master.</p>

<p><b>SS</b> &minus; This is the slave-selection wire.</p>

<p>The following functions are used. You have to include the SPI.h.</p>

<p><b>SPI.begin()</b> &minus; Initializes the SPI bus by setting SCK, MOSI, and SS to outputs, pulling SCK and MOSI low, and SS high.</p>

<p><b>SPI.setClockDivider(divider)</b> &minus; To set the SPI clock divider relative to the system clock. On AVR based boards, the dividers available are 2, 4, 8, 16, 32, 64 or 128. The default setting is SPI_CLOCK_DIV4, which sets the SPI clock to one-quarter of the frequency of the system clock (5 Mhz for the boards at 20 MHz).</p>

<p><b>Divider</b> &minus; It could be (SPI_CLOCK_DIV2, SPI_CLOCK_DIV4, SPI_CLOCK_DIV8, SPI_CLOCK_DIV16, SPI_CLOCK_DIV32, SPI_CLOCK_DIV64, SPI_CLOCK_DIV128).</p>

<p><b>SPI.transfer(val)</b> &minus; SPI transfer is based on a simultaneous send and receive: the received data is returned in receivedVal.</p>

<p><b>SPI.beginTransaction(SPISettings(speedMaximum, dataOrder, dataMode))</b> &minus; speedMaximum is the clock, dataOrder(MSBFIRST or LSBFIRST), dataMode(SPI_MODE0, SPI_MODE1, SPI_MODE2, or SPI_MODE3).</p>

<p>We have four modes of operation in SPI as follows &minus;</p>

<p><b>Mode 0 (the default)</b> &minus; Clock is normally low (CPOL = 0), and the data is sampled on the transition from low to high (leading edge) (CPHA = 0).</p>

<p><b>Mode 1</b> &minus; Clock is normally low (CPOL = 0), and the data is sampled on the transition from high to low (trailing edge) (CPHA = 1).</p>

<p><b>Mode 2</b> &minus; Clock is normally high (CPOL = 1), and the data is sampled on the transition from high to low (leading edge) (CPHA = 0).</p>

<p><b>Mode 3</b> &minus; Clock is normally high (CPOL = 1), and the data is sampled on the transition from low to high (trailing edge) (CPHA = 1).</p>

<p><b>SPI.attachInterrupt(handler)</b> &minus; Function to be called when a slave device receives data from the master.</p>

<p>Now, we will connect two Arduino UNO boards together; one as a master and the other as a slave.</p>

<p>The ground is common. Following is the diagrammatic representation of the connection between both the boards &minus;</p>

<p>Let us see examples of SPI as Master and SPI as Slave.</p>

<h2>SPI as MASTER</h2>

<h3>Example</h3>

<h2>SPI as SLAVE</h2>

<h3>Example</h3>

<h1>Arduino - Blinking LED</h1>

<p>LEDs are small, powerful lights that are used in many different applications. To start, we will work on blinking an LED, the Hello World of microcontrollers. It is as simple as turning a light on and off. Establishing this important baseline will give you a solid foundation as we work towards experiments that are more complex.</p>

<h2>Components Required</h2>

<p>You will need the following components &minus;</p>

<h2>Procedure</h2>

<p>Follow the circuit diagram and hook up the components on the breadboard as shown in the image given below.</p>

<p><b>Note</b> &minus; To find out the polarity of an LED, look at it closely. The shorter of the two legs, towards the flat edge of the bulb indicates the negative terminal.</p>

<p>Components like resistors need to have their terminals bent into 90° angles in order to fit the breadboard sockets properly. You can also cut the terminals shorter.</p>

<h2>Sketch</h2>

<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open the new sketch File by clicking New.</p>

<h2>Arduino Code</h2>

<h2>Code to Note</h2>

<p><b>pinMode(2, OUTPUT)</b> &minus; Before you can use one of Arduino’s pins, you need to tell Arduino Uno R3 whether it is an INPUT or OUTPUT. We use a built-in “function” called pinMode() to do this.</p>

<p><b>digitalWrite(2, HIGH)</b> &minus; When you are using a pin as an OUTPUT, you can command it to be HIGH (output 5 volts), or LOW (output 0 volts).</p>

<h2>Result</h2>

<p>You should see your LED turn on and off. If the required output is not seen, make sure you have assembled the circuit correctly, and verified and uploaded the code to your board.</p>

<h1>Arduino - Fading LED</h1>

<p>This example demonstrates the use of the analogWrite() function in fading an LED off. AnalogWrite uses pulse width modulation (PWM), turning a digital pin on and off very quickly with different ratios between on and off, to create a fading effect.</p>

<h2>Components Required</h2>

<p>You will need the following components &minus;</p>

<h2>Procedure</h2>

<p>Follow the circuit diagram and hook up the components on the breadboard as shown in the image given below.</p>

<p><b>Note</b> &minus; To find out the polarity of an LED, look at it closely. The shorter of the two legs, towards the flat edge of the bulb indicates the negative terminal.</p>

<p>Components like resistors need to have their terminals bent into 90° angles in order to fit the breadboard sockets properly. You can also cut the terminals shorter.</p>

<h2>Sketch</h2>

<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open the new sketch File by clicking New.</p>

<h2>Arduino Code</h2>

<h2>Code to Note</h2>

<p>After declaring pin 9 as your LED pin, there is nothing to do in the setup() function of your code. The analogWrite() function that you will be using in the main loop of your code requires two arguments: One, telling the function which pin to write to and the other indicating what PWM value to write.</p>

<p>In order to fade the LED off and on, gradually increase the PWM values from 0 (all the way off) to 255 (all the way on), and then back to 0, to complete the cycle. In the sketch given above, the PWM value is set using a variable called brightness. Each time through the loop, it increases by the value of the variable <b>fadeAmount</b>.</p>

<p>If brightness is at either extreme of its value (either 0 or 255), then fadeAmount is changed to its negative. In other words, if fadeAmount is 5, then it is set to -5. If it is -5, then it is set to 5. The next time through the loop, this change causes brightness to change direction as well.</p>

<p><b>analogWrite()</b> can change the PWM value very fast, so the delay at the end of the sketch controls the speed of the fade. Try changing the value of the delay and see how it changes the fading effect.</p>

<h2>Result</h2>

<p>You should see your LED brightness change gradually.</p>

<h1>Arduino - Reading Analog Voltage</h1>

<p>This example will show you how to read an analog input on analog pin 0. The input is converted from analogRead() into voltage, and printed out to the serial monitor of the Arduino Software (IDE).</p>

<h2>Components Required</h2>

<p>You will need the following components &minus;</p>

<h2>Procedure</h2>

<p>Follow the circuit diagram and hook up the components on the breadboard as shown in the image given below.</p>

<h2>Potentiometer</h2>

<p>A potentiometer (or pot) is a simple electro-mechanical transducer. It converts rotary or linear motion from the input operator into a change of resistance. This change is (or can be) used to control anything from the volume of a hi-fi system to the direction of a huge container ship.</p>

<p>The pot as we know it was originally known as a rheostat (essentially a variable wirewound resistor). The variety of available pots is now quite astonishing, and it can be very difficult for the beginner (in particular) to work out which type is suitable for a given task. A few different pot types, which can all be used for the same task makes the job harder.</p>

<p>The image on the left shows the standard schematic symbol of a pot. The image on the right is the potentiometer.</p>

<h2>Sketch</h2>

<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open a new sketch File by clicking New.</p>

<h2>Arduino Code</h2>

<h2>Code to Note</h2>

<p>In the program or sketch given below, the first thing that you do in the setup function is begin serial communications, at 9600 bits per second, between your board and your computer with the line &minus;</p>

<p>In the main loop of your code, you need to establish a variable to store the resistance value (which will be between 0 and 1023, perfect for an int datatype) coming from your potentiometer &minus;</p>

<p>To change the values from 0-1023 to a range that corresponds to the voltage, the pin is reading, you need to create another variable, a float, and do a little calculation. To scale the numbers between 0.0 and 5.0, divide 5.0 by 1023.0 and multiply that by sensorValue &minus;</p>

<p>Finally, you need to print this information to your serial window. You can do this with the command Serial.println() in your last line of code &minus;</p>

<p>Now, open Serial Monitor in the Arduino IDE by clicking the icon on the right side of the top green bar or pressing Ctrl+Shift+M.</p>

<h2>Result</h2>

<p>You will see a steady stream of numbers ranging from 0.0 - 5.0. As you turn the pot, the values will change, corresponding to the voltage at pin A0.</p>

<h1>Arduino - LED Bar Graph</h1>

<p>This example shows you how to read an analog input at analog pin 0, convert the values from analogRead() into voltage, and print it out to the serial monitor of the Arduino Software (IDE).</p>

<h2>Components Required</h2>

<p>You will need the following components &minus;</p>

<h2>Procedure</h2>

<p>Follow the circuit diagram and hook up the components on the breadboard as shown in the image given below.</p>

<p></p>

<h2>Sketch</h2>

<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open a new sketch File by clicking New.</p>

<h2>10 Segment LED Bar Graph</h2>

<p>These 10-segment bar graph LEDs have many uses. With a compact footprint, simple hookup, they are easy for prototype or finished products. Essentially, they are 10 individual blue LEDs housed together, each with an individual anode and cathode connection.</p>

<p>They are also available in yellow, red, and green colors.</p>

<p><b>Note</b> &minus; The pin out on these bar graphs may vary from what is listed on the datasheet. Rotating the device 180 degrees will correct the change, making pin 11 the first pin in line.</p>

<h2>Arduino Code</h2>

<h2>Code to Note</h2>

<p>The sketch works like this: first, you read the input. You map the input value to the output range, in this case ten LEDs. Then you set up a <b>for-loop</b> to iterate over the outputs. If the output's number in the series is lower than the mapped input range, you turn it on. If not, you turn it off.</p>

<h2>Result</h2>

<p>You will see the LED turn ON one by one when the value of analog reading increases and turn OFF one by one while the reading is decreasing.</p>

<h1>Arduino - Keyboard Logout</h1>

<p>This example uses the Keyboard library to log you out of your user session on your computer when pin 2 on the ARDUINO UNO is pulled to ground. The sketch simulates the keypress in sequence of two or three keys at the same time and after a short delay, it releases them.</p>

<p><b>Warning</b> &minus; When you use the <b>Keyboard.print()</b> command, Arduino takes over your computer's keyboard. To ensure you do not lose control of your computer while running a sketch with this function, set up a reliable control system before you call Keyboard.print(). This sketch is designed to only send a Keyboard command after a pin has been pulled to ground.</p>

<h2>Components Required</h2>

<p>You will need the following components &minus;</p>

<h2>Procedure</h2>

<p>Follow the circuit diagram and hook up the components on the breadboard as shown in the image below.</p>

<h2>Sketch</h2>

<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open a new sketch File by clicking New.</p>

<p>For this example, you need to use Arduino IDE 1.6.7</p>

<p><b>Note</b> &minus; You must include the keyboard library in your Arduino library file. Copy and paste the keypad library file inside the file with the name libraries (highlighted) as shown in the following screenshot.</p>

<h2>Arduino Code</h2>

<h2>Code to Note</h2>

<p>Before you upload the program to your board, make sure you assign the correct OS you are currently using to the platform variable.</p>

<p>While the sketch is running, pressing the button will connect pin 2 to the ground and the board will send the logout sequence to the USB connected PC.</p>

<h2>Result</h2>

<p>When you connect pin 2 to the ground, it performs a logout operation.</p>

<p>It uses the following keyboard combinations to logout &minus;</p>

<p>On <b>Windows</b>, CTRL-ALT-DEL followed by ALT-l</p>

<p>On <b>Ubuntu</b>, CTRL-ALT-DEL, and ENTER</p>

<p>On <b>OSX</b>, CMD-SHIFT-q</p>

<h1>Arduino - Keyboard Message</h1>

<p>In this example, when the button is pressed, a text string is sent to the computer as keyboard input. The string reports the number of times the button is pressed. Once you have the Leonardo programmed and wired up, open your favorite text editor to see the results.</p>

<p><b>Warning</b> &minus; When you use the <b>Keyboard.print()</b> command, the Arduino takes over your computer's keyboard. To ensure you do not lose control of your computer while running a sketch with this function, set up a reliable control system before you call <b>Keyboard.print()</b>. This sketch includes a pushbutton to toggle the keyboard, so that it only runs after the button is pressed.</p>

<h2>Components Required</h2>

<p>You will need the following components &minus;</p>

<h2>Procedure</h2>

<p>Follow the circuit diagram and hook up the components on the breadboard as shown in the image given below.</p>

<h2>Sketch</h2>

<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open a new sketch File by clicking New.</p>

<h2>Arduino Code</h2>

<h2>Code to Note</h2>

<p>Attach one terminal of the pushbutton to pin 4 on Arduino. Attach the other pin to 5V. Use the resistor as a pull-down, providing a reference to the ground, by attaching it from pin 4 to the ground.</p>

<p>Once you have programmed your board, unplug the USB cable, open a text editor and put the text cursor in the typing area. Connect the board to your computer through USB again and press the button to write in the document.</p>

<h2>Result</h2>

<p>By using any text editor, it will display the text sent via Arduino.</p>

<h1>Arduino - Mouse Button Control</h1>

<p>Using the Mouse library, you can control a computer's onscreen cursor with an Arduino Leonardo, Micro, or Due.</p>

<p>This particular example uses five pushbuttons to move the onscreen cursor. Four of the buttons are directional (up, down, left, right) and one is for a left mouse click. Cursor movement from Arduino is always relative. Every time an input is read, the cursor's position is updated relative to its current position.</p>

<p>Whenever one of the directional buttons is pressed, Arduino will move the mouse, mapping a HIGH input to a range of 5 in the appropriate direction.</p>

<p>The fifth button is for controlling a left-click from the mouse. When the button is released, the computer will recognize the event.</p>

<h2>Components Required</h2>

<p>You will need the following components &minus;</p>

<h2>Procedure</h2>

<p>Follow the circuit diagram and hook up the components on the breadboard as shown in the image below.</p>

<h2>Sketch</h2>

<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open a new sketch File by clicking New.</p>

<p>For this example, you need to use Arduino IDE 1.6.7</p>

<h2>Arduino Code</h2>

<h2>Code to Note</h2>

<p>Connect your board to your computer with a micro-USB cable. The buttons are connected to digital inputs from pins 2 to 6. Make sure you use 10k pull-down resistors.</p>

<h1>Arduino - Keyboard Serial</h1>

<p>This example listens for a byte coming from the serial port. When received, the board sends a keystroke back to the computer. The sent keystroke is one higher than what is received, so if you send an "a" from the serial monitor, you will receive a "b" from the board connected to the computer. A "1" will return a "2" and so on.</p>

<p><b>Warning</b> &minus; When you use the <b>Keyboard.print()</b> command, the Leonardo, Micro or Due board takes over your computer's keyboard. To ensure you do not lose control of your computer while running a sketch with this function, set up a reliable control system before you call Keyboard.print(). This sketch is designed to only send a Keyboard command after the board has received a byte over the serial port.</p>

<h2>Components Required</h2>

<p>You will need the following components &minus;</p>

<h2>Procedure</h2>

<p>Just connect your board to the computer using USB cable.</p>

<h2>Sketch</h2>

<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open a new sketch File by clicking New.</p>

<p><b>Notes</b> &minus; You must include the keypad library in your Arduino library file. Copy and paste the keypad library file inside the file with the name ‘libraries’ highlighted with yellow color.</p>

<h2>Arduino Code</h2>

<h2>Code to Note</h2>

<p>Once programed, open your serial monitor and send a byte. The board will reply with a keystroke, that is one number higher.</p>

<h2>Result</h2>

<p>The board will reply with a keystroke that is one number higher on Arduino IDE serial monitor when you send a byte.</p>

<h1>Arduino - Humidity Sensor</h1>

<p>In this section, we will learn how to interface our Arduino board with different sensors. We will discuss the following sensors &minus;</p>

<h2>Humidity Sensor (DHT22)</h2>

<p>The DHT-22 (also named as AM2302) is a digital-output, relative humidity, and temperature sensor. It uses a capacitive humidity sensor and a thermistor to measure the surrounding air, and sends a digital signal on the data pin.</p>

<p>In this example, you will learn how to use this sensor with Arduino UNO. The room temperature and humidity will be printed to the serial monitor.</p>

<h2>The DHT-22 Sensor</h2>

<p>The connections are simple. The first pin on the left to 3-5V power, the second pin to the data input pin and the right-most pin to the ground.</p>

<h2>Technical Details</h2>

<p><b>Power</b> &minus; 3-5V</p>

<p><b>Max Current</b> &minus; 2.5mA</p>

<p><b>Humidity</b> &minus; 0-100%, 2-5% accuracy</p>

<p><b>Temperature</b> &minus; 40 to 80°C, ±0.5°C accuracy</p>

<h2>Components Required</h2>

<p>You will need the following components &minus;</p>

<h2>Procedure</h2>

<p>Follow the circuit diagram and hook up the components on the breadboard as shown in the image below.</p>

<p></p>

<h2>Sketch</h2>

<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open a new sketch File by clicking New.</p>

<h2>Arduino Code</h2>

<h2>Code to Note</h2>

<p>DHT22 sensor has four terminals (V<sub>cc</sub>, DATA, NC, GND), which are connected to the board as follows &minus;</p>

<p>Once hardware connections are done, you need to add DHT22 library to your Arduino library file as described earlier.</p>

<h2>Result</h2>

<p>You will see the temperature and humidity display on serial port monitor which is updated every 2 seconds.</p>

<h1>Arduino - Temperature Sensor</h1>

<p>The Temperature Sensor LM35 series are precision integrated-circuit temperature devices with an output voltage linearly proportional to the Centigrade temperature.</p>

<p>The LM35 device has an advantage over linear temperature sensors calibrated in Kelvin, as the user is not required to subtract a large constant voltage from the output to obtain convenient Centigrade scaling. The LM35 device does not require any external calibration or trimming to provide typical accuracies of ±¼°C at room temperature and ±¾°C over a full −55°C to 150°C temperature range.</p>

<h2>Technical Specifications</h2>

<h2>Components Required</h2>

<p>You will need the following components &minus;</p>

<h2>Procedure</h2>

<p>Follow the circuit diagram and hook up the components on the breadboard as shown in the image given below.</p>

<h2>Sketch</h2>

<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open a new sketch File by clicking New.</p>

<h2>Arduino Code</h2>

<h2>Code to Note</h2>

<p>LM35 sensor has three terminals - V<sub>s</sub>, V<sub>out</sub> and GND. We will connect the sensor as follows &minus;</p>

<p>The Analog to Digital Converter (ADC) converts analog values into a digital approximation based on the formula ADC Value = sample * 1024 / reference voltage (&plus;5v). So with a &plus;5 volt reference, the digital approximation will be equal to input voltage * 205.</p>

<h2>Result</h2>

<p>You will see the temperature display on the serial port monitor which is updated every second.</p>

<h1>Arduino - Water Detector / Sensor</h1>

<p>Water sensor brick is designed for water detection, which can be widely used in sensing rainfall, water level, and even liquid leakage.</p>

<p>Connecting a water sensor to an Arduino is a great way to detect a leak, spill, flood, rain, etc. It can be used to detect the presence, the level, the volume and/or the absence of water. While this could be used to remind you to water your plants, there is a better Grove sensor for that. The sensor has an array of exposed traces, which read LOW when water is detected.</p>

<p>In this chapter, we will connect the water sensor to Digital Pin 8 on Arduino, and will enlist the very handy LED to help identify when the water sensor comes into contact with a source of water.</p>

<h2>Components Required</h2>

<p>You will need the following components &minus;</p>

<h2>Procedure</h2>

<p>Follow the circuit diagram and hook up the components on the breadboard as shown in the image given below.</p>

<h2>Sketch</h2>

<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open a new sketch File by clicking on New.</p>

<h2>Arduino Code</h2>

<h2>Code to Note</h2>

<p>Water sensor has three terminals - S, V<sub>out</sub>(&plus;), and GND (-). Connect the sensor as follows &minus;</p>

<p>When the sensor detects water, pin 8 on Arduino becomes LOW and then the LED on Arduino is turned ON.</p>

<h2>Result</h2>

<p>You will see the indication LED turn ON when the sensor detects water.</p>

<h1>Arduino - PIR Sensor</h1>

<p>PIR sensors allow you to sense motion. They are used to detect whether a human has moved in or out of the sensor’s range. They are commonly found in appliances and gadgets used at home or for businesses. They are often referred to as PIR, "Passive Infrared", "Pyroelectric", or "IR motion" sensors.</p>

<p>Following are the advantages of PIR Sensors &minus;</p>

<p>PIRs are made of pyroelectric sensors, a round metal can with a rectangular crystal in the center, which can detect levels of infrared radiation. Everything emits low-level radiation, and the hotter something is, the more radiation is emitted. The sensor in a motion detector is split in two halves. This is to detect motion (change) and not average IR levels. The two halves are connected so that they cancel out each other. If one-half sees more or less IR radiation than the other, the output will swing high or low.</p>

<p>PIRs have adjustable settings and have a header installed in the 3-pin ground/out/power pads.</p>

<p>For many basic projects or products that need to detect when a person has left or entered the area, PIR sensors are great. Note that PIRs do not tell you the number of people around or their closeness to the sensor. The lens is often fixed to a certain sweep at a distance and they are sometimes set off by the pets in the house.</p>

<h2>Components Required</h2>

<p>You will need the following components &minus;</p>

<h2>Procedure</h2>

<p>Follow the circuit diagram and make the connections as shown in the image below.</p>

<h2>Sketch</h2>

<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open a new sketch File by clicking New.</p>

<h2>Arduino Code</h2>

<h2>Code to Note</h2>

<p>PIR sensor has three terminals - V<sub>cc</sub>, OUT and GND. Connect the sensor as follows &minus;</p>

<p>You can adjust the sensor sensitivity and delay time via two variable resistors located at the bottom of the sensor board.</p>

<p>Once the sensor detects any motion, Arduino will send a message via the serial port to say that a motion is detected. The PIR sense motion will delay for certain time to check if there is a new motion. If there is no motion detected, Arduino will send a new message saying that the motion has ended.</p>

<h2>Result</h2>

<p>You will see a message on your serial port if a motion is detected and another message when the motion stops.</p>

<h1>Arduino - Ultrasonic Sensor</h1>

<p>The HC-SR04 ultrasonic sensor uses SONAR to determine the distance of an object just like the bats do. It offers excellent non-contact range detection with high accuracy and stable readings in an easy-to-use package from 2 cm to 400 cm or 1” to 13 feet.</p>

<p>The operation is not affected by sunlight or black material, although acoustically, soft materials like cloth can be difficult to detect. It comes complete with ultrasonic transmitter and receiver module.</p>

<p></p>

<h2>Technical Specifications</h2>

<h2>Components Required</h2>

<p>You will need the following components &minus;</p>

<h2>Procedure</h2>

<p>Follow the circuit diagram and make the connections as shown in the image given below.</p>

<h2>Sketch</h2>

<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open a new sketch File by clicking New.</p>

<h2>Arduino Code</h2>

<h2>Code to Note</h2>

<p>The Ultrasonic sensor has four terminals - &plus;5V, Trigger, Echo, and GND connected as follows &minus;</p>

<p>In our program, we have displayed the distance measured by the sensor in inches and cm via the serial port.</p>

<h2>Result</h2>

<p>You will see the distance measured by sensor in inches and cm on Arduino serial monitor.</p>

<h1>Arduino - Connecting Switch</h1>

<p>Pushbuttons or switches connect two open terminals in a circuit. This example turns on the LED on pin 2 when you press the pushbutton switch connected to pin 8.</p>

<h2>Pull-down Resistor</h2>

<p>Pull-down resistors are used in electronic logic circuits to ensure that inputs to Arduino settle at expected logic levels if external devices are disconnected or are at high-impedance. As nothing is connected to an input pin, it does not mean that it is a logical zero. Pull down resistors are connected between the ground and the appropriate pin on the device.</p>

<p>An example of a pull-down resistor in a digital circuit is shown in the following figure. A pushbutton switch is connected between the supply voltage and a microcontroller pin. In such a circuit, when the switch is closed, the micro-controller input is at a logical high value, but when the switch is open, the pull-down resistor pulls the input voltage down to the ground (logical zero value), preventing an undefined state at the input.</p>

<p>The pull-down resistor must have a larger resistance than the impedance of the logic circuit, or else it might pull the voltage down too much and the input voltage at the pin would remain at a constant logical low value, regardless of the switch position.</p>

<h2>Components Required</h2>

<p>You will need the following components &minus;</p>

<h2>Procedure</h2>

<p>Follow the circuit diagram and make the connections as shown in the image given below.</p>

<h2>Sketch</h2>

<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open a new sketch File by clicking on New.</p>

<h2>Arduino Code</h2>

<h2>Code to Note</h2>

<p>When the switch is open, (pushbutton is not pressed), there is no connection between the two terminals of the pushbutton, so the pin is connected to the ground (through the pull-down resistor) and we read a LOW. When the switch is closed (pushbutton is pressed), it makes a connection between its two terminals, connecting the pin to 5 volts, so that we read a HIGH.</p>

<h2>Result</h2>

<p>LED is turned ON when the pushbutton is pressed and OFF when it is released.</p>

<h1>Arduino - DC Motor</h1>

<p>In this chapter, we will interface different types of motors with the Arduino board (UNO) and show you how to connect the motor and drive it from your board.</p>

<p>There are three different type of motors &minus;</p>

<p>A DC motor (Direct Current motor) is the most common type of motor. DC motors normally have just two leads, one positive and one negative. If you connect these two leads directly to a battery, the motor will rotate. If you switch the leads, the motor will rotate in the opposite direction.</p>

<p><b>Warning</b> &minus; Do not drive the motor directly from Arduino board pins. This may damage the board. Use a driver Circuit or an IC.</p>

<p>We will divide this chapter into three parts &minus;</p>

<h3>Components Required</h3>

<p>You will need the following components &minus;</p>

<h3>Procedure</h3>

<p>Follow the circuit diagram and make the connections as shown in the image given below.</p>

<h3>Precautions</h3>

<p>Take the following precautions while making the connections.</p>

<p>First, make sure that the transistor is connected in the right way. The flat side of the transistor should face the Arduino board as shown in the arrangement.</p>

<p>Second, the striped end of the diode should be towards the +5V power line according to the arrangement shown in the image.</p>

<h3>Spin ControlArduino Code</h3>

<h3>Code to Note</h3>

<p>The transistor acts like a switch, controlling the power to the motor. Arduino pin 3 is used to turn the transistor on and off and is given the name 'motorPin' in the sketch.</p>

<h3>Result</h3>

<p>Motor will spin in full speed when the Arduino pin number 3 goes high.</p>

<h2>Motor Speed Control</h2>

<p>Following is the schematic diagram of a DC motor, connected to the Arduino board.</p>

<h3>Arduino Code</h3>

<h3>Code to Note</h3>

<p>The transistor acts like a switch, controlling the power of the motor. Arduino pin 3 is used to turn the transistor on and off and is given the name 'motorPin' in the sketch.</p>

<p>When the program starts, it prompts you to give the values to control the speed of the motor. You need to enter a value between 0 and 255 in the Serial Monitor.</p>

<p>In the 'loop' function, the command 'Serial.parseInt' is used to read the number entered as text in the Serial Monitor and convert it into an 'int'. You can type any number here. The 'if' statement in the next line simply does an analog write with this number, if the number is between 0 and 255.</p>

<h3>Result</h3>

<p>The DC motor will spin with different speeds according to the value (0 to 250) received via the serial port.</p>

<h2>Spin Direction Control</h2>

<p>To control the direction of the spin of DC motor, without interchanging the leads, you can use a circuit called an <b>H-Bridge</b>. An H-bridge is an electronic circuit that can drive the motor in both directions. H-bridges are used in many different applications. One of the most common application is to control motors in robots. It is called an H-bridge because it uses four transistors connected in such a way that the schematic diagram looks like an "H."</p>

<p>We will be using the L298 H-Bridge IC here. The L298 can control the speed and direction of DC motors and stepper motors, and can control two motors simultaneously. Its current rating is 2A for each motor. At these currents, however, you will need to use heat sinks.</p>

<h3>Components Required</h3>

<p>You will need the following components &minus;</p>

<h3>Procedure</h3>

<p>Following is the schematic diagram of the DC motor interface to Arduino Uno board.</p>

<p>The above diagram shows how to connect the L298 IC to control two motors. There are three input pins for each motor, Input1 (IN1), Input2 (IN2), and Enable1 (EN1) for Motor1 and Input3, Input4, and Enable2 for Motor2.</p>

<p>Since we will be controlling only one motor in this example, we will connect the Arduino to IN1 (pin 5), IN2 (pin 7), and Enable1 (pin 6) of the L298 IC. Pins 5 and 7 are digital, i.e. ON or OFF inputs, while pin 6 needs a pulse-width modulated (PWM) signal to control the motor speed.</p>

<p>The following table shows which direction the motor will turn based on the digital values of IN1 and IN2.</p>

<p>Pin IN1 of the IC L298 is connected to pin 8 of Arduino while IN2 is connected to pin 9. These two digital pins of Arduino control the direction of the motor. The EN A pin of IC is connected to the PWM pin 2 of Arduino. This will control the speed of the motor.</p>

<p>To set the values of Arduino pins 8 and 9, we have used the digitalWrite() function, and to set the value of pin 2, we have to use the analogWrite() function.</p>

<h3>Connection Steps</h3>

<h3>Arduino Code</h3>

<h3>Result</h3>

<p>The motor will run first in the clockwise (CW) direction for 3 seconds and then counter-clockwise (CCW) for 3 seconds.</p>

<h1>Arduino - Servo Motor</h1>

<p>A Servo Motor is a small device that has an output shaft. This shaft can be positioned to specific angular positions by sending the servo a coded signal. As long as the coded signal exists on the input line, the servo will maintain the angular position of the shaft. If the coded signal changes, the angular position of the shaft changes. In practice, servos are used in radio-controlled airplanes to position control surfaces like the elevators and rudders. They are also used in radio-controlled cars, puppets, and of course, robots.</p>

<p>Servos are extremely useful in robotics. The motors are small, have built-in control circuitry, and are extremely powerful for their size. A standard servo such as the Futaba S-148 has 42 oz/inches of torque, which is strong for its size. It also draws power proportional to the mechanical load. A lightly loaded servo, therefore, does not consume much energy.</p>

<p>The guts of a servo motor is shown in the following picture. You can see the control circuitry, the motor, a set of gears, and the case. You can also see the 3 wires that connect to the outside world. One is for power (+5volts), ground, and the white wire is the control wire.</p>

<h2>Working of a Servo Motor</h2>

<p>The servo motor has some control circuits and a potentiometer (a variable resistor, aka pot) connected to the output shaft. In the picture above, the pot can be seen on the right side of the circuit board. This pot allows the control circuitry to monitor the current angle of the servo motor.</p>

<p>If the shaft is at the correct angle, then the motor shuts off. If the circuit finds that the angle is not correct, it will turn the motor until it is at a desired angle. The output shaft of the servo is capable of traveling somewhere around 180 degrees. Usually, it is somewhere in the 210-degree range, however, it varies depending on the manufacturer. A normal servo is used to control an angular motion of 0 to 180 degrees. It is mechanically not capable of turning any farther due to a mechanical stop built on to the main output gear.</p>

<p>The power applied to the motor is proportional to the distance it needs to travel. So, if the shaft needs to turn a large distance, the motor will run at full speed. If it needs to turn only a small amount, the motor will run at a slower speed. This is called <b>proportional control</b>.</p>

<h2>How Do You Communicate the Angle at Which the Servo Should Turn?</h2>

<p>The control wire is used to communicate the angle. The angle is determined by the duration of a pulse that is applied to the control wire. This is called <b>Pulse Coded Modulation</b>. The servo expects to see a pulse every 20 milliseconds (.02 seconds). The length of the pulse will determine how far the motor turns. A 1.5 millisecond pulse, for example, will make the motor turn to the 90-degree position (often called as the neutral position). If the pulse is shorter than 1.5 milliseconds, then the motor will turn the shaft closer to 0 degrees. If the pulse is longer than 1.5 milliseconds, the shaft turns closer to 180 degrees.</p>

<h2>Components Required</h2>

<p>You will need the following components &minus;</p>

<h2>Procedure</h2>

<p>Follow the circuit diagram and make the connections as shown in the image given below.</p>

<h2>Sketch</h2>

<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open a new sketch File by clicking on New.</p>

<h2>Arduino Code</h2>

<h2>Code to Note</h2>

<p>Servo motors have three terminals - power, ground, and signal. The power wire is typically red, and should be connected to the 5V pin on the Arduino. The ground wire is typically black or brown and should be connected to one terminal of ULN2003 IC (10 -16). To protect your Arduino board from damage, you will need some driver IC to do that. Here we have used ULN2003 IC to drive the servo motor. The signal pin is typically yellow or orange and should be connected to Arduino pin number 9.</p>

<h2>Connecting the Potentiometer</h2>

<p>A voltage divider/potential divider are resistors in a series circuit that scale the output voltage to a particular ratio of the input voltage applied. Following is the circuit diagram &minus;</p>

<p>$$V_{out} = (V_{in} \times R_{2})/ (R_{1} + R_{2})$$</p>

<p>V<sub>out</sub> is the output potential, which depends on the applied input voltage (V<sub>in</sub>) and resistors (R<sub>1</sub> and R<sub>2</sub>) in the series. It means that the current flowing through R<sub>1</sub> will also flow through R<sub>2</sub> without being divided. In the above equation, as the value of R<sub>2</sub> changes, the V<sub>out</sub> scales accordingly with respect to the input voltage, V<sub>in</sub>.</p>

<p>Typically, a potentiometer is a potential divider, which can scale the output voltage of the circuit based on the value of the variable resistor, which is scaled using the knob. It has three pins: GND, Signal, and +5V as shown in the diagram below &minus;</p>

<h2>Result</h2>

<p>By changing the pot’s NOP position, servo motor will change its angle.</p>

<h1>Arduino - Stepper Motor</h1>

<p>A Stepper Motor or a step motor is a brushless, synchronous motor, which divides a full rotation into a number of steps. Unlike a brushless DC motor, which rotates continuously when a fixed DC voltage is applied to it, a step motor rotates in discrete step angles.</p>

<p>The Stepper Motors therefore are manufactured with steps per revolution of 12, 24, 72, 144, 180, and 200, resulting in stepping angles of 30, 15, 5, 2.5, 2, and 1.8 degrees per step. The stepper motor can be controlled with or without feedback.</p>

<p>Imagine a motor on an RC airplane. The motor spins very fast in one direction or another. You can vary the speed with the amount of power given to the motor, but you cannot tell the propeller to stop at a specific position.</p>

<p>Now imagine a printer. There are lots of moving parts inside a printer, including motors. One such motor acts as the paper feed, spinning rollers that move the piece of paper as ink is being printed on it. This motor needs to be able to move the paper an exact distance to be able to print the next line of text or the next line of an image.</p>

<p>There is another motor attached to a threaded rod that moves the print head back and forth. Again, that threaded rod needs to be moved an exact amount to print one letter after another. This is where the stepper motors come in handy.</p>

<h2>How a Stepper Motor Works?</h2>

<p>A regular DC motor spins in only direction whereas a Stepper motor can spin in precise increments.</p>

<p>Stepper motors can turn an exact amount of degrees (or steps) as desired. This gives you total control over the motor, allowing you to move it to an exact location and hold that position. It does so by powering the coils inside the motor for very short periods of time. The disadvantage is that you have to power the motor all the time to keep it in the position that you desire.</p>

<p>All you need to know for now is that, to move a stepper motor, you tell it to move a certain number of steps in one direction or the other, and tell it the speed at which to step in that direction. There are numerous varieties of stepper motors. The methods described here can be used to infer how to use other motors and drivers which are not mentioned in this tutorial. However, it is always recommended that you consult the datasheets and guides of the motors and drivers specific to the models you have.</p>

<h2>Components Required</h2>

<p>You will need the following components &minus;</p>

<h2>Procedure</h2>

<p>Follow the circuit diagram and make the connections as shown in the image given below.</p>

<h2>Sketch</h2>

<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open a new sketch File by clicking New.</p>

<h2>Arduino Code</h2>

<h2>Code to Note</h2>

<p>This program drives a unipolar or bipolar stepper motor. The motor is attached to digital pins 8 - 11 of Arduino.</p>

<h2>Result</h2>

<p>The motor will take one revolution in one direction, then one revolution in the other direction.</p>

<h1>Arduino - Tone Library</h1>

<p>In this chapter, we will use the Arduino Tone Library. It is nothing but an Arduino Library, which produces square-wave of a specified frequency (and 50% duty cycle) on any Arduino pin. A duration can optionally be specified, otherwise the wave continues until the stop() function is called. The pin can be connected to a piezo buzzer or a speaker to play the tones.</p>

<p><b>Warning</b> &minus; Do not connect the pin directly to any audio input. The voltage is considerably higher than the standard line level voltages, and can damage sound card inputs, etc. You can use a voltage divider to bring the voltage down.</p>

<h2>Components Required</h2>

<p>You will need the following components &minus;</p>

<h2>Procedure</h2>

<p>Follow the circuit diagram and make the connections as shown in the image given below.</p>

<h2>Sketch</h2>

<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open a new sketch File by clicking New.</p>

<p>To make the pitches.h file, either click the button just below the serial monitor icon and choose "New Tab", or use Ctrl+Shift+N.</p>

<p>Then paste the following code &minus;</p>

<p>Save the above given code as <b>pitches.h</b></p>

<h2>Arduino Code</h2>

<h2>Code to Note</h2>

<p>The code uses an extra file, pitches.h. This file contains all the pitch values for typical notes. For example, NOTE_C4 is middle C. NOTE_FS4 is F sharp, and so forth. This note table was originally written by Brett Hagman, on whose work the tone() command was based. You may find it useful whenever you want to make musical notes.</p>

<h2>Result</h2>

<p>You will hear musical notes saved in the pitches.h. file.</p>

<h1>Arduino - Wireless Communication</h1>

<p>The wireless transmitter and receiver modules work at 315 Mhz. They can easily fit into a breadboard and work well with microcontrollers to create a very simple wireless data link. With one pair of transmitter and receiver, the modules will only work communicating data one-way, however, you would need two pairs (of different frequencies) to act as a transmitter/receiver pair.</p>

<p><b>Note</b> &minus; These modules are indiscriminate and receive a fair amount of noise. Both the transmitter and receiver work at common frequencies and do not have IDs.</p>

<h2>Receiver Module Specifications</h2>

<h2>Transmitter Module Specifications</h2>

<h2>Components Required</h2>

<p>You will need the following components &minus;</p>

<h2>Procedure</h2>

<p>Follow the circuit diagram and make the connections as shown in the image given below.</p>

<h2>Sketch</h2>

<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open a new sketch File by clicking New.</p>

<p><b>Note</b> &minus; You must include the keypad library in your Arduino library file. Copy and paste the VirtualWire.lib file in the libraries folder as highlighted in the screenshot given below.</p>

<h2>Arduino Code for Transmitter</h2>

<h2>Code to Note</h2>

<p>This is a simple code. First, it will send character '1' and after two seconds it will send character '0' and so on.</p>

<h2>Arduino Code for Receiver</h2>

<h2>Code to Note</h2>

<p>The LED connected to pin number 5 on the Arduino board is turned ON when character '1' is received and turned OFF when character '0' received.</p>

<h1>Arduino - Network Communication</h1>

<p>The CC3000 WiFi module from Texas Instruments is a small silver package, which finally brings easy-to-use, affordable WiFi functionality to your Arduino projects.</p>

<p>It uses SPI for communication (not UART!) so you can push data as fast as you want or as slow as you want. It has a proper interrupt system with IRQ pin so you can have asynchronous connections. It supports 802.11b/g, open/WEP/WPA/WPA2 security, TKIP & AES. A built-in TCP/IP stack with a "BSD socket" interface supports TCP and UDP in both the client and the server mode.</p>

<h2>Components Required</h2>

<p>You will need the following components &minus;</p>

<p>For this project, you just need the usual Arduino IDE, the Adafruit’s CC3000 library, and the CC3000 MDNS library. We are also going to use the aREST library to send commands to the relay via WiFi.</p>

<h2>Procedure</h2>

<p>Follow the circuit diagram and make the connections as shown in the image given below.</p>

<p>The hardware configuration for this project is very easy.</p>

<p>Let us now connect the relay.</p>

<p>After placing the relay on the breadboard, you can start identifying the two important parts on your relay: the coil part which commands the relay, and the switch part where we will attach the LED.</p>

<p>You also have to place the rectifier diode (anode connected to the ground pin) over the pins of the coil to protect your circuit when the relay is switching.</p>

<p>Connect the +5V of Arduino board to the common pin of the relay’s switch.</p>

<p>Finally, connect one of the other pin of the switch (usually, the one which is not connected when the relay is off) to the LED in series with the 220 Ohm resistor, and connect the other side of the LED to the ground of Arduino board.</p>

<h2>Testing Individual Components</h2>

<p>You can test the relay with the following sketch &minus;</p>

<h2>Code to Note</h2>

<p>The code is self-explanatory. You can just upload it to the board and the relay will switch states every second, and the LED will switch ON and OFF accordingly.</p>

<h2>Adding WiFi Connectivity</h2>

<p>Let us now control the relay wirelessly using the CC3000 WiFi chip. The software for this project is based on the TCP protocol. However, for this project, Arduino board will be running a small web server, so we can “listen” for commands coming from the computer. We will first take care of Arduino sketch, and then we will see how to write the server-side code and create a nice interface.</p>

<p>First, the Arduino sketch. The goal here is to connect to your WiFi network, create a web server, check if there are incoming TCP connections, and then change the state of the relay accordingly.</p>

<h2>Important Parts of the Code</h2>

<p>You need to define inside the code what is specific to your configuration, i.e. Wi-Fi name and password, and the port for TCP communications (we have used 80 here).</p>

<p>We can then create the CC3000 instance, server and aREST instance &minus;</p>

<p>In the setup() part of the sketch, we can now connect the CC3000 chip to the network &minus;</p>

<p>How will the computer know where to send the data? One way would be to run the sketch once, then get the IP address of the CC3000 board, and modify the server code again. However, we can do better, and that is where the CC3000 MDNS library comes into play. We will assign a fixed name to our CC3000 board with this library, so we can write down this name directly into the server code.</p>

<p>This is done with the following piece of code &minus;</p>

<p>We also need to listen for incoming connections.</p>

<p>Next, we will code the loop() function of the sketch that will be continuously executed. We first have to update the mDNS server.</p>

<p>The server running on Arduino board will wait for the incoming connections and handle the requests.</p>

<p>It is now quite easy to test the projects via WiFi. Make sure you updated the sketch with your own WiFi name and password, and upload the sketch to your Arduino board. Open your Arduino IDE serial monitor, and look for the IP address of your board.</p>

<p>Let us assume for the rest here that it is something like 192.168.1.103.</p>

<p>Then, simply go to your favorite web browser, and type &minus;</p>

<p>192.168.1.103/digital/8/1</p>

<p>You should see that your relay automatically turns ON.</p>

<h2>Building the Relay Interface</h2>

<p>We will now code the interface of the project. There will be two parts here: an HTML file containing the interface, and a client-side Javascript file to handle the clicks on the interface. The interface here is based on the <b>aREST.js</b> project, which was made to easily control WiFi devices from your computer.</p>

<p>Let us first see the HTML file, called interface.html. The first part consists importing all the required libraries for the interface &minus;</p>

<p>Then, we define two buttons inside the interface, one to turn the relay on, and the other to turn it off again.</p>

<p>Now, we also need a client-side Javascript file to handle the clicks on the buttons. We will also create a device that we will link to the mDNS name of our Arduino device. If you changed this in Arduino code, you will need to modify it here as well.</p>

<p>The complete code for this project can be found on the <b>GitHub</b> repository. Go into the interface folder, and simply open the HTML file with your favorite browser. You should see something similar inside your browser &minus;</p>

<p>Try to click a button on the web interface; it should change the state of the relay nearly instantly.</p>

<p>If you managed to get it working, bravo! You just built a Wi-Fi-controlled light switch. Of course, you can control much more than lights with this project. Just make sure your relay supports the power required for the device you want to control, and you are good to go.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<pre class="result notranslate">
Void setup ( ) {

}
</pre>
<ul class="list">
<li><p><b>PURPOSE</b> &minus; The <b>setup()</b> function is called when a sketch starts. Use it to initialize the variables, pin modes, start using libraries, etc. The setup function will only run once, after each power up or reset of the Arduino board.</p></li>
<li><p><b>INPUT</b> &minus;      -</p></li>
<li><p><b>OUTPUT</b> &minus;     -</p></li>
<li><p><b>RETURN</b> &minus;     -</p></li>
</ul>
<pre class="result notranslate">
Void Loop ( ) {

}
</pre>
<ul class="list">
<li><p><b>PURPOSE</b> &minus; After creating a <b>setup()</b> function, which initializes and sets the initial values, the <b>loop()</b> function does precisely what its name suggests, and loops consecutively, allowing your program to change and respond. Use it to actively control the Arduino board.</p></li>
<li><p><b>INPUT</b> &minus;      -</p></li>
<li><p><b>OUTPUT</b> &minus;     -</p></li>
<li><p><b>RETURN</b> &minus;     -</p></li>
</ul>
<h1>Arduino - Data Types</h1>
<p>Data types in C refers to an extensive system used for declaring variables or functions of different types. The type of a variable determines how much space it occupies in the storage and how the bit pattern stored is interpreted.</p>
<p>The following table provides all the data types that you will use during Arduino programming.</p>
<table class="table table-bordered" style="text-align:center;">
<tr>
<td>void</td>
<td>Boolean</td>
<td>char</td>
<td>Unsigned char</td>
<td>byte</td>
<td>int</td>
<td>Unsigned int</td>
<td>word</td>
</tr>
<tr>
<td>long</td>
<td>Unsigned long</td>
<td>short</td>
<td>float</td>
<td>double</td>
<td>array</td>
<td>String-char array</td>
<td>String-object</td>
</tr>
</table>
<h2>void</h2>
<p>The void keyword is used only in function declarations. It indicates that the function is expected to return no information to the function from which it was called.</p>
<h3>Example</h3>
<pre class="result notranslate">
Void Loop ( ) {
   // rest of the code
}
</pre>
<h2>Boolean</h2>
<p>A Boolean holds one of two values, true or false. Each Boolean variable occupies one byte of memory.</p>
<h3>Example</h3>
<pre class="result notranslate">
boolean val = false ; // declaration of variable with type boolean and initialize it with false
boolean state = true ; // declaration of variable with type boolean and initialize it with true
</pre>
<h2>Char</h2>
<p>A data type that takes up one byte of memory that stores a character value. Character literals are written in single quotes like this: 'A' and for multiple characters, strings use double quotes: "ABC".</p>
<p>However, characters are stored as numbers. You can see the specific encoding in the <a href="https://www.arduino.cc/en/Reference/ASCIIchart" rel="nofollow" target="_blank">ASCII chart</a>. This means that it is possible to do arithmetic operations on characters, in which the ASCII value of the character is used. For example, 'A' + 1 has the value 66, since the ASCII value of the capital letter A is 65.</p>
<h3>Example</h3>
<pre class="result notranslate">
Char chr_a = ‘a’ ;//declaration of variable with type char and initialize it with character a
Char chr_c = 97 ;//declaration of variable with type char and initialize it with character 97
</pre>
<p></p>
<img src="/arduino/images/ascii_char_table.jpg" alt="ASCII Char Table" />
<h2>unsigned char</h2>
<p><b>Unsigned char</b> is an unsigned data type that occupies one byte of memory. The unsigned char data type encodes numbers from 0 to 255.</p>
<h3>Example</h3>
<pre class="result notranslate">
Unsigned Char chr_y = 121 ; // declaration of variable with type Unsigned char and initialize it with character y
</pre>
<h2>byte</h2>
<p>A byte stores an 8-bit unsigned number, from 0 to 255.</p>
<h3>Example</h3>
<pre class="result notranslate">
byte m = 25 ;//declaration of variable with type byte and initialize it with 25
</pre>
<h2>int</h2>
<p>Integers are the primary data-type for number storage. int stores a 16-bit (2-byte) value. This yields a range of -32,768 to 32,767 (minimum value of -2&#94;15 and a maximum value of (2&#94;15) - 1).</p>
<p>The <b>int</b> size varies from board to board. On the Arduino Due, for example, an <b>int</b> stores a 32-bit (4-byte) value. This yields a range of -2,147,483,648 to 2,147,483,647 (minimum value of -2&#94;31 and a maximum value of (2&#94;31) - 1).</p>
<h3>Example</h3>
<pre class="result notranslate">
int counter = 32 ;// declaration of variable with type int and initialize it with 32
</pre>
<h2>Unsigned int</h2>
<p>Unsigned ints (unsigned integers) are the same as int in the way that they store a 2 byte value. Instead of storing negative numbers, however, they only store positive values, yielding a useful range of 0 to 65,535 (2&#94;16) - 1). The Due stores a 4 byte (32-bit) value, ranging from 0 to 4,294,967,295 (2&#94;32 - 1).</p>
<h3>Example</h3>
<pre class="result notranslate">
Unsigned int counter = 60 ; // declaration of variable with 
   type unsigned int and initialize it with 60
</pre>
<h2>Word</h2>
<p>On the Uno and other ATMEGA based boards, a word stores a 16-bit unsigned number. On the Due and Zero, it stores a 32-bit unsigned number.</p>
<h3>Example</h3>
<pre class="result notranslate">
word w = 1000 ;//declaration of variable with type word and initialize it with 1000
</pre>
<h2>Long</h2>
<p>Long variables are extended size variables for number storage, and store 32 bits (4 bytes), from 2,147,483,648 to 2,147,483,647.</p>
<h3>Example</h3>
<pre class="result notranslate">
Long velocity = 102346 ;//declaration of variable with type Long and initialize it with 102346
</pre>
<h2>unsigned long</h2>
<p>Unsigned long variables are extended size variables for number storage and store 32 bits (4 bytes). Unlike standard longs, unsigned longs will not store negative numbers, making their range from 0 to 4,294,967,295 (2&#94;32 - 1).</p>
<h3>Example</h3>
<pre class="result notranslate">
Unsigned Long velocity = 101006 ;// declaration of variable with 
   type Unsigned Long and initialize it with 101006
</pre>
<h2>short</h2>
<p>A short is a 16-bit data-type. On all Arduinos (ATMega and ARM based), a short stores a 16-bit (2-byte) value. This yields a range of -32,768 to 32,767 (minimum value of -2&#94;15 and a maximum value of (2&#94;15) - 1).</p>
<h3>Example</h3>
<pre class="result notranslate">
short val = 13 ;//declaration of variable with type short and initialize it with 13
</pre>
<h2>float</h2>
<p>Data type for floating-point number is a number that has a decimal point. Floating-point numbers are often used to approximate the analog and continuous values because they have greater resolution than integers.</p>
<p>Floating-point numbers can be as large as 3.4028235E+38 and as low as 3.4028235E+38. They are stored as 32 bits (4 bytes) of information.</p>
<h3>Example</h3>
<pre class="result notranslate">
float num = 1.352;//declaration of variable with type float and initialize it with 1.352
</pre>
<h2>double</h2>
<p>On the Uno and other ATMEGA based boards, Double precision floating-point number occupies four bytes. That is, the double implementation is exactly the same as the float, with no gain in precision. On the Arduino Due, doubles have 8-byte (64 bit) precision.</p>
<h3>Example</h3>
<pre class="result notranslate">
double num = 45.352 ;// declaration of variable with type double and initialize it with 45.352
</pre>
<h1>Arduino - Variables &amp; Constants</h1>
<p>Before we start explaining the variable types, a very important subject we need to make sure, you fully understand is called the <b>variable scope</b>.</p>
<h2>What is Variable Scope?</h2>
<p>Variables in C programming language, which Arduino uses, have a property called scope. A scope is a region of the program and there are three places where variables can be declared. They are &minus;</p>
<ul class="list">
<li>Inside a function or a block, which is called <b>local variables</b>.</li>
<li>In the definition of function parameters, which is called <b>formal parameters</b>.</li>
<li>Outside of all functions, which is called <b>global variables</b>.</li>
</ul>
<h3>Local Variables</h3>
<p>Variables that are declared inside a function or block are local variables. They can be used only by the statements that are inside that function or block of code. Local variables are not known to function outside their own. Following is the example using local variables &minus;</p>
<pre class="prettyprint notranslate">
Void setup () {

}

Void loop () {
   int x , y ;
   int z ; Local variable declaration
   x = 0;
   y = 0; actual initialization
   z = 10;
}
</pre>
<h3>Global Variables</h3>
<p>Global variables are defined outside of all the functions, usually at the top of the program. The global variables will hold their value throughout the life-time of your program.</p>
<p>A global variable can be accessed by any function. That is, a global variable is available for use throughout your entire program after its declaration.</p>
<p>The following example uses global and local variables &minus;</p>
<pre class="prettyprint notranslate">
Int T , S ;
float c = 0 ; Global variable declaration

Void setup () {

}

Void loop () {
   int x , y ;
   int z ; Local variable declaration
   x = 0;
   y = 0; actual initialization
   z = 10;
}
</pre>
<h1>Arduino - Operators</h1>
<p>An operator is a symbol that tells the compiler to perform specific mathematical or logical functions. C language is rich in built-in operators and provides the following types of operators &minus;</p>
<ul class="list">
<li>Arithmetic Operators</li>
<li>Comparison Operators</li>
<li>Boolean Operators</li>
<li>Bitwise Operators</li>
<li>Compound Operators</li>
</ul>
<h2>Arithmetic Operators</h2>
<p>Assume variable A holds 10 and variable B holds 20 then &minus;</p>
<p><a href="/arduino/arduino_arithmetic_operators.htm">Show Example</a></p>
<table class="table table-bordered">
<tr>
<th style="text-align:center;">Operator name</th>
<th style="text-align:center;">Operator simple</th>
<th style="text-align:center;">Description</th>
<th style="text-align:center;">Example</th>
</tr>
<tr>
<td style="vertical-align:middle;">assignment operator</td>
<td style="vertical-align:middle; text-align:center;">=</td>
<td style="vertical-align:middle;">Stores the value to the right of the equal sign in the variable to the left of the equal sign.</td>
<td style="vertical-align:middle;">A = B</td>
</tr>
<tr>
<td style="vertical-align:middle;">addition</td>
<td style="vertical-align:middle; text-align:center;">&plus;</td>
<td style="vertical-align:middle;">Adds two operands</td>
<td style="vertical-align:middle;">A &plus; B will give 30</td>
</tr>
<tr>
<td style="vertical-align:middle;">subtraction</td>
<td style="vertical-align:middle; text-align:center;">-</td>
<td style="vertical-align:middle;">Subtracts second operand from the first</td>
<td style="vertical-align:middle;">A - B will give -10</td>
</tr>
<tr>
<td style="vertical-align:middle;">multiplication</td>
<td style="vertical-align:middle; text-align:center;">*</td>
<td style="vertical-align:middle;">Multiply both operands</td>
<td style="vertical-align:middle;">A * B will give 200</td>
</tr>
<tr>
<td style="vertical-align:middle;">division</td>
<td style="vertical-align:middle; text-align:center;">/</td>
<td style="vertical-align:middle;">Divide numerator by denominator</td>
<td style="vertical-align:middle;">B / A will give 2</td>
</tr>
<tr>
<td style="vertical-align:middle;">modulo</td>
<td style="vertical-align:middle; text-align:center;">%</td>
<td style="vertical-align:middle;">Modulus Operator and remainder of after an integer division</td>
<td style="vertical-align:middle;">B % A will give 0</td>
</tr>
</table>
<h2>Comparison Operators</h2>
<p>Assume variable A holds 10 and variable B holds 20 then &minus;</p>
<p><a href="/arduino/arduino_comparison_operators.htm">Show Example</a></p>
<table class="table table-bordered">
<tr>
<th style="text-align:center;">Operator name</th>
<th style="text-align:center;">Operator simple</th>
<th style="text-align:center;">Description</th>
<th style="text-align:center;">Example</th>
</tr>
<tr>
<td style="vertical-align:middle;">equal to</td>
<td style="vertical-align:middle; text-align:center;">==</td>
<td style="vertical-align:middle;">Checks if the value of two operands is equal or not, if yes then condition becomes true.</td>
<td style="vertical-align:middle;">(A == B) is not true</td>
</tr>
<tr>
<td style="vertical-align:middle;">not equal to</td>
<td style="vertical-align:middle; text-align:center;">!=</td>
<td style="vertical-align:middle;">Checks if the value of two operands is equal or not, if values are not equal then condition becomes true.</td>
<td style="vertical-align:middle;">(A != B) is true</td>
</tr>
<tr>
<td style="vertical-align:middle;">less than</td>
<td style="vertical-align:middle; text-align:center;">&lt;</td>
<td style="vertical-align:middle;">Checks if the value of left operand is less than the value of right operand, if yes then condition becomes true.</td>
<td style="vertical-align:middle;">(A &lt; B) is true</td>
</tr>
<tr>
<td style="vertical-align:middle;">greater than</td>
<td style="vertical-align:middle; text-align:center;">&gt;</td>
<td style="vertical-align:middle;">Checks if the value of left operand is greater than the value of right operand, if yes then condition becomes true.</td>
<td style="vertical-align:middle;">(A &gt; B) is not true</td>
</tr>
<tr>
<td style="vertical-align:middle;">less than or equal to</td>
<td style="vertical-align:middle; text-align:center;">&lt;=</td>
<td style="vertical-align:middle;">Checks if the value of left operand is less than or equal to the value of right operand, if yes then condition becomes true.</td>
<td style="vertical-align:middle;">(A &lt;= B) is true</td>
</tr>
<tr>
<td style="vertical-align:middle;">greater than or equal to</td>
<td style="vertical-align:middle; text-align:center;">&gt;=</td>
<td style="vertical-align:middle;">Checks if the value of left operand is greater than or equal to the value of right operand, if yes then condition becomes true.</td>
<td style="vertical-align:middle;">(A &gt;= B) is not true</td>
</tr>
</table>
<h2>Boolean Operators</h2>
<p>Assume variable A holds 10 and variable B holds 20 then &minus;</p>
<p><a href="/arduino/arduino_boolean_operators.htm">Show Example</a></p>
<table class="table table-bordered">
<tr>
<th style="text-align:center;">Operator name</th>
<th style="text-align:center;">Operator simple</th>
<th style="text-align:center;">Description</th>
<th style="text-align:center;">Example</th>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">and</td>
<td style="vertical-align:middle; text-align:center;">&amp;&amp;</td>
<td style="vertical-align:middle;">Called Logical AND operator. If both the operands are non-zero then then condition becomes true.</td>
<td style="vertical-align:middle;">(A &amp;&amp; B) is true</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">or</td>
<td style="vertical-align:middle; text-align:center;">||</td>
<td style="vertical-align:middle;">Called Logical OR Operator. If any of the two operands is non-zero then then condition becomes true.</td>
<td style="vertical-align:middle;">(A || B) is true</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">not</td>
<td style="vertical-align:middle; text-align:center;">!</td>
<td style="vertical-align:middle;">Called Logical NOT Operator. Use to reverses the logical state of its operand. If a condition is true then Logical NOT operator will make false.</td>
<td style="vertical-align:middle;">!(A &amp;&amp; B) is false</td>
</tr>
</table>
<h2>Bitwise Operators</h2>
<p>Assume variable A holds 60 and variable B holds 13 then &minus;</p>
<p><a href="/arduino/arduino_bitwise_operators.htm">Show Example</a></p>
<table class="table table-bordered">
<tr>
<th style="text-align:center;">Operator name</th>
<th style="text-align:center;">Operator simple</th>
<th style="text-align:center;">Description</th>
<th style="text-align:center;">Example</th>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">and</td>
<td style="vertical-align:middle; text-align:center;">&amp;</td>
<td style="vertical-align:middle;">Binary AND Operator copies a bit to the result if it exists in both operands.</td>
<td style="vertical-align:middle;">(A &amp; B) will give 12 which is 0000 1100</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">or</td>
<td style="vertical-align:middle; text-align:center;">|</td>
<td style="vertical-align:middle;">Binary OR Operator copies a bit if it exists in either operand</td>
<td style="vertical-align:middle;">(A | B) will give 61 which is 0011 1101</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">xor</td>
<td style="vertical-align:middle; text-align:center;">^</td>
<td style="vertical-align:middle;">Binary XOR Operator copies the bit if it is set in one operand but not both.</td>
<td style="vertical-align:middle;">(A ^ B) will give 49 which is 0011 0001</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">not</td>
<td style="vertical-align:middle; text-align:center;">~</td>
<td style="vertical-align:middle;">Binary Ones Complement Operator is unary and has the effect of 'flipping' bits.</td>
<td style="vertical-align:middle;">(~A ) will give -60 which is 1100 0011</td>
</tr>
<tr>
<td style="vertical-align:middle;">shift left</td>
<td style="vertical-align:middle; text-align:center;">&lt;&lt;</td>
<td style="vertical-align:middle;">Binary Left Shift Operator. The left operands value is moved left by the number of bits specified by the right operand.</td>
<td style="vertical-align:middle;">A &lt;&lt; 2 will give 240 which is 1111 0000</td>
</tr>
<tr>
<td style="vertical-align:middle;">shift right</td>
<td style="vertical-align:middle; text-align:center;">&gt;&gt;</td>
<td style="vertical-align:middle;">Binary Right Shift Operator. The left operands value is moved right by the number of bits specified by the right operand.</td>
<td style="vertical-align:middle;">A &gt;&gt; 2 will give 15 which is 0000 1111</td>
</tr>
</table>
<h2>Compound Operators</h2>
<p>Assume variable A holds 10 and variable B holds 20 then &minus;</p>
<p><a href="/arduino/arduino_compound_operators.htm">Show Example</a></p>
<table class="table table-bordered">
<tr>
<th style="text-align:center;">Operator name</th>
<th style="text-align:center;">Operator simple</th>
<th style="text-align:center;">Description</th>
<th style="text-align:center;">Example</th>
</tr>
<tr>
<td style="vertical-align:middle;">increment</td>
<td style="vertical-align:middle; text-align:center;">&plus;&plus;</td>
<td style="vertical-align:middle;">Increment operator, increases integer value by one</td>
<td style="vertical-align:middle;">A&plus;&plus; will give 11</td>
</tr>
<tr>
<td style="vertical-align:middle;">decrement</td>
<td style="vertical-align:middle; text-align:center;">--</td>
<td style="vertical-align:middle;">Decrement operator, decreases integer value by one</td>
<td style="vertical-align:middle;">A-- will give 9</td>
</tr>
<tr>
<td style="vertical-align:middle;">compound addition</td>
<td style="vertical-align:middle; text-align:center;">&plus;=</td>
<td style="vertical-align:middle;">Add AND assignment operator. It adds right operand to the left operand and assign the result to left operand</td>
<td style="vertical-align:middle;">B &plus;= A is equivalent to B = B&plus; A</td>
</tr>
<tr>
<td style="vertical-align:middle;">compound subtraction</td>
<td style="vertical-align:middle; text-align:center;">-=</td>
<td style="vertical-align:middle;">Subtract AND assignment operator. It subtracts right operand from the left operand and assign the result to left operand</td>
<td style="vertical-align:middle;">B -= A is equivalent to B = B - A</td>
</tr>
<tr>
<td style="vertical-align:middle;">compound multiplication</td>
<td style="vertical-align:middle; text-align:center;">*=</td>
<td style="vertical-align:middle;">Multiply AND assignment operator. It multiplies right operand with the left operand and assign the result to left operand</td>
<td style="vertical-align:middle;">B*= A is equivalent to B = B* A</td>
</tr>
<tr>
<td style="vertical-align:middle;">compound division</td>
<td style="vertical-align:middle; text-align:center;">/=</td>
<td style="vertical-align:middle;">Divide AND assignment operator. It divides left operand with the right operand and assign the result to left operand</td>
<td style="vertical-align:middle;">B /= A is equivalent to B = B / A</td>
</tr>
<tr>
<td style="vertical-align:middle;">compound modulo</td>
<td style="vertical-align:middle; text-align:center;">%=</td>
<td style="vertical-align:middle;">Modulus AND assignment operator. It takes modulus using two operands and assign the result to left operand</td>
<td style="vertical-align:middle;">B %= A is equivalent to B = B % A</td>
</tr>
<tr>
<td style="vertical-align:middle;">compound bitwise or</td>
<td style="vertical-align:middle; text-align:center;">|=</td>
<td style="vertical-align:middle;">bitwise inclusive OR and assignment operator</td>
<td style="vertical-align:middle;">A |= 2 is same as A = A | 2</td>
</tr>
<tr>
<td style="vertical-align:middle;">compound bitwise and</td>
<td style="vertical-align:middle; text-align:center;">&amp;=</td>
<td style="vertical-align:middle;">Bitwise AND assignment operator</td>
<td style="vertical-align:middle;">A &amp;= 2 is same as A = A &amp; 2</td>
</tr>
</table>
<h1>Arduino - Control Statements</h1>
<p>Decision making structures require that the programmer specify one or more conditions to be evaluated or tested by the program. It should be along with a statement or statements to be executed if the condition is determined to be true, and optionally, other statements to be executed if the condition is determined to be false.</p>
<p>Following is the general form of a typical decision making structure found in most of the programming languages &minus;</p>
<img src="/arduino/images/decision_making.jpg" alt="Decision Making" />
<p>Control Statements are elements in Source Code that control the flow of program execution. They are &minus;</p>
<table class="table table-bordered">
<tr>
<th>S.NO.</th>
<th style="text-align:center">Control Statement &amp; Description</th>
</tr>
<tr>
<td style="text-align:center; vertical-align:middle;">1</td>
<td>
<p><a href="/arduino/arduino_if_statement.htm">If statement</a></p>
<p>It takes an expression in parenthesis and a statement or block of statements. If the expression is true then the statement or block of statements gets executed otherwise these statements are skipped.</p>
</td>
</tr>
<tr>
<td style="text-align:center; vertical-align:middle;">2</td>
<td>
<p><a href="/arduino/arduino_if_else_statement.htm">If …else statement</a></p>
<p>An <b>if</b> statement can be followed by an optional else statement, which executes when the expression is false.</p>
</td>
</tr>
<tr>
<td style="text-align:center; vertical-align:middle;">3</td>
<td>
<p><a href="/arduino/arduino_if_else_if_else_statement.htm">If…else if …else statement</a></p>
<p>The <b>if</b> statement can be followed by an optional <b>else if...else</b> statement, which is very useful to test various conditions using single if...else if statement.</p>
</td>
</tr>
<tr>
<td style="text-align:center; vertical-align:middle;">4</td>
<td>
<p><a href="/arduino/arduino_switch_case_statement.htm">switch case statement</a></p>
<p>Similar to the if statements, <b>switch...case</b> controls the flow of programs by allowing the programmers to specify different codes that should be executed in various conditions.</p>
</td>
</tr>
<tr>
<td style="text-align:center; vertical-align:middle;">5</td>
<td>
<p><a href="/arduino/arduino_conditional_operator.htm">Conditional Operator ? :</a></p>
<p>The conditional operator ? : is the only ternary operator in C.</p>
</td>
</tr>
</table>
<h1>Arduino - Loops</h1>
<p>Programming languages provide various control structures that allow for more complicated execution paths.</p>
<p>A loop statement allows us to execute a statement or group of statements multiple times and following is the general form of a loop statement in most of the programming languages &minus;</p>
<img src="/arduino/images/loop_architecture.jpg" alt="Loop Architecture" />
<p>C programming language provides the following types of loops to handle looping requirements.</p>
<table class="table table-bordered">
<tr>
<th>S.NO.</th>
<th style="text-align:center;">Loop &amp; Description</th>
</tr>
<tr>
<td style="text-align:center; vertical-align:middle;">1</td>
<td>
<p><a href="/arduino/arduino_while_loop.htm">while loop</a></p>
<p>while loops will loop continuously, and infinitely, until the expression inside the parenthesis, () becomes false. Something must change the tested variable, or the while loop will never exit.</p>
</td>
</tr>
<tr>
<td style="text-align:center; vertical-align:middle;">2</td>
<td>
<p><a href="/arduino/arduino_do_while_loop.htm">do…while loop</a></p>
<p>The <b>do…while</b> loop is similar to the while loop. In the while loop, the loop-continuation condition is tested at the beginning of the loop before performed the body of the loop.</p>
</td>
</tr>
<tr>
<td style="text-align:center; vertical-align:middle;">3</td>
<td>
<p><a href="/arduino/arduino_for_loop.htm">for loop</a></p>
<p>A <b>for loop</b> executes statements a predetermined number of times. The control expression for the loop is initialized, tested and manipulated entirely within the for loop parentheses.</p>
</td>
</tr>
<tr>
<td style="text-align:center; vertical-align:middle;">4</td>
<td>
<p><a href="/arduino/arduino_nested_loop.htm">Nested Loop</a></p>
<p>C language allows you to use one loop inside another loop. The following example illustrates the concept.</p>
</td>
</tr>
<tr>
<td style="text-align:center; vertical-align:middle;">5</td>
<td>
<p><a href="/arduino/arduino_infinite_loop.htm">Infinite loop</a></p>
<p>It is the loop having no terminating condition, so the loop becomes infinite.</p>
</td>
</tr>
</table>
<h1>Arduino - Functions</h1>
<p>Functions allow structuring the programs in segments of code to perform individual tasks. The typical case for creating a function is when one needs to perform the same action multiple times in a program.</p>
<p>Standardizing code fragments into functions has several advantages &minus;</p>
<ul class="list">
<li><p>Functions help the programmer stay organized. Often this helps to conceptualize the program.</p></li>
<li><p>Functions codify one action in one place so that the function only has to be thought about and debugged once.</p></li>
<li><p>This also reduces chances for errors in modification, if the code needs to be changed.</p></li>
<li><p>Functions make the whole sketch smaller and more compact because sections of code are reused many times.</p></li>
<li><p>They make it easier to reuse code in other programs by making it modular, and using functions often makes the code more readable.</p></li>
</ul>
<p>There are two required functions in an Arduino sketch or a program i.e. setup () and loop(). Other functions must be created outside the brackets of these two functions.</p>
<p>The most common syntax to define a function is &minus;</p>
<img src="/arduino/images/function.jpg" alt="Function" />
<h2>Function Declaration</h2>
<p>A function is declared outside any other functions, above or below the loop function.</p>
<p>We can declare the function in two different ways &minus;</p>
<p>The first way is just writing the part of the function called <b>a function prototype</b> above the loop function, which consists of &minus;</p>
<ul class="list">
<li>Function return type</li>
<li>Function name</li>
<li>Function argument type, no need to write the argument name</li>
</ul>
<p>Function prototype must be followed by a semicolon ( ; ).</p>
<p>The following example shows the demonstration of the function declaration using the first method.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
int sum_func (int x, int y) // function declaration {
   int z = 0;
   z = x+y ;
   return z; // return the value
}

void setup () {
   Statements // group of statements
}

Void loop () {
   int result = 0 ;
   result = Sum_func (5,6) ; // function call
}
</pre>
<p>The second part, which is called the function definition or declaration, must be declared below the loop function, which consists of &minus;</p>
<ul class="list">
<li>Function return type</li>
<li>Function name</li>
<li>Function argument type, here you must add the argument name</li>
<li>The function body (statements inside the function executing when the function is called)</li>
</ul>
<p>The following example demonstrates the declaration of function using the second method.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
int sum_func (int , int ) ; // function prototype

void setup () {
   Statements // group of statements
}

Void loop () {
   int result = 0 ;
   result = Sum_func (5,6) ; // function call
}

int sum_func (int x, int y) // function declaration {
   int z = 0;
   z = x+y ;
   return z; // return the value
}
</pre>
<p>The second method just declares the function above the loop function.</p>
<h1>Arduino - Strings</h1>
<p>Strings are used to store text. They can be used to display text on an LCD or in the Arduino IDE Serial Monitor window. Strings are also useful for storing the user input. For example, the characters that a user types on a keypad connected to the Arduino.</p>
<p>There are two types of strings in Arduino programming &minus;</p>
<ul class="list">
<li>Arrays of characters, which are the same as the strings used in C programming.</li>
<li>The Arduino String, which lets us use a string object in a sketch.</li>
</ul>
<p>In this chapter, we will learn Strings, objects and the use of strings in Arduino sketches. By the end of the chapter, you will learn which type of string to use in a sketch.</p>
<h2>String Character Arrays</h2>
<p>The first type of string that we will learn is the string that is a series of characters of the type <b>char</b>. In the previous chapter, we learned what an array is; a consecutive series of the same type of variable stored in memory. A string is an array of char variables.</p>
<p>A string is a special array that has one extra element at the end of the string, which always has the value of 0 (zero). This is known as a "null terminated string".</p>
<h3>String Character Array Example</h3>
<p>This example will show how to make a string and print it to the serial monitor window.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
void setup() {
   char my_str[6]; // an array big enough for a 5 character string
   Serial.begin(9600);
   my_str[0] = 'H'; // the string consists of 5 characters
   my_str[1] = 'e';
   my_str[2] = 'l';
   my_str[3] = 'l';
   my_str[4] = 'o';
   my_str[5] = 0; // 6th array element is a null terminator
   Serial.println(my_str);
}

void loop() { 

}
</pre>
<p>The following example shows what a string is made up of; a character array with printable characters and 0 as the last element of the array to show that this is where the string ends. The string can be printed out to the Arduino IDE Serial Monitor window by using <b>Serial.println()</b> and passing the name of the string.</p>
<p>This same example can be written in a more convenient way as shown below &minus;</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
void setup() {
   char my_str[] = "Hello";
   Serial.begin(9600);
   Serial.println(my_str);
}

void loop() {

}
</pre>
<p>In this sketch, the compiler calculates the size of the string array and also automatically null terminates the string with a zero. An array that is six elements long and consists of five characters followed by a zero is created exactly the same way as in the previous sketch.</p>
<h2>Manipulating String Arrays</h2>
<p>We can alter a string array within a sketch as shown in the following sketch.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
void setup() {
   char like[] = "I like coffee and cake"; // create a string
   Serial.begin(9600);
   // (1) print the string
   Serial.println(like);
   // (2) delete part of the string
   like[13] = 0;
   Serial.println(like);
   // (3) substitute a word into the string
   like[13] = ' '; // replace the null terminator with a space
   like[18] = 't'; // insert the new word
   like[19] = 'e';
   like[20] = 'a';
   like[21] = 0; // terminate the string
   Serial.println(like);
}

void loop() {

}
</pre>
<h3>Result</h3>
<pre class="result notranslate">
I like coffee and cake
I like coffee
I like coffee and tea
</pre>
<p>The sketch works in the following way.</p>
<h3>Creating and Printing the String</h3>
<p>In the sketch given above, a new string is created and then printed for display in the Serial Monitor window.</p>
<h3>Shortening the String</h3>
<p>The string is shortened by replacing the 14th character in the string with a null terminating zero (2). This is element number 13 in the string array counting from 0.</p>
<p>When the string is printed, all the characters are printed up to the new null terminating zero. The other characters do not disappear; they still exist in the memory and the string array is still the same size. The only difference is that any function that works with strings will only see the string up to the first null terminator.</p>
<h3>Changing a Word in the String</h3>
<p>Finally, the sketch replaces the word "cake" with "tea" (3). It first has to replace the null terminator at like[13] with a space so that the string is restored to the originally created format.</p>
<p>New characters overwrite "cak" of the word "cake" with the word "tea". This is done by overwriting individual characters. The 'e' of "cake" is replaced with a new null terminating character. The result is that the string is actually terminated with two null characters, the original one at the end of the string and the new one that replaces the 'e' in "cake". This makes no difference when the new string is printed because the function that prints the string stops printing the string characters when it encounters the first null terminator.</p>
<h2>Functions to Manipulate String Arrays</h2>
<p>The previous sketch manipulated the string in a manual way by accessing individual characters in the string. To make it easier to manipulate string arrays, you can write your own functions to do so, or use some of the string functions from the <b>C</b> language library.</p>
<section class="toggle">
<label><i class="icon icon-minus"></i><i class="icon icon-plus"></i>Given below is the list Functions to Manipulate String Arrays</label>
<div class="toggle-content" style="display: none;">
<table class="table table-bordered">
<tr>
<th>S.No.</th>
<th style="text-align:center;">Functions &amp; Description</th>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">1</td>
<td>
<p><b>String()</b></p>
<p>The String class, part of the core as of version 0019, allows you to use and manipulate strings of text in more complex ways than character arrays do. You can concatenate Strings, append to them, search for and replace substrings, and more. It takes more memory than a simple character array, but it is also more useful.</p>
<p>For reference, character arrays are referred to as strings with a small ‘s’, and instances of the String class are referred to as Strings with a capital S. Note that constant strings, specified in "double quotes" are treated as char arrays, not instances of the String class</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">2</td>
<td>
<p><b>charAt()</b></p>
<p>Access a particular character of the String.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">3</td>
<td>
<p><b>compareTo()</b></p>
<p>Compares two Strings, testing whether one comes before or after the other, or whether they are equal. The strings are compared character by character, using the ASCII values of the characters. That means, for example, 'a' comes before 'b' but after 'A'. Numbers come before letters.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">4</td>
<td>
<p><b>concat()</b></p>
<p>Appends the parameter to a String.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">5</td>
<td>
<p><b>c_str()</b></p>
<p>Converts the contents of a string as a C-style, null-terminated string. Note that this gives direct access to the internal String buffer and should be used with care. In particular, you should never modify the string through the pointer returned. When you modify the String object, or when it is destroyed, any pointer previously returned by c_str() becomes invalid and should not be used any longer.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">6</td>
<td>
<p><b>endsWith()</b></p>
<p>Tests whether or not a String ends with the characters of another String.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">7</td>
<td>
<p><b>equals()</b></p>
<p>Compares two strings for equality. The comparison is case-sensitive, meaning the String "hello" is not equal to the String "HELLO".</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">8</td>
<td>
<p><b>equalsIgnoreCase()</b></p>
<p>Compares two strings for equality. The comparison is not case-sensitive, meaning the String("hello") is equal to the String("HELLO").</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">9</td>
<td>
<p><b>getBytes()</b></p>
<p>Copies the string's characters to the supplied buffer.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">10</td>
<td>
<p><b>indexOf()</b></p>
<p>Locates a character or String within another String. By default, it searches from the beginning of the String, but can also start from a given index, allowing to locate all instances of the character or String.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">11</td>
<td>
<p><b>lastIndexOf()</b></p>
<p>Locates a character or String within another String. By default, it searches from the end of the String, but can also work backwards from a given index, allowing to locate all instances of the character or String.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">12</td>
<td>
<p><b>length()</b></p>
<p>Returns the length of the String, in characters. (Note that this does not include a trailing null character.)</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">13</td>
<td>
<p><b>remove()</b></p>
<p>Modify in place, a string removing chars from the provided index to the end of the string or from the provided index to index plus count.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">14</td>
<td>
<p><b>replace()</b></p>
<p>The String replace() function allows you to replace all instances of a given character with another character. You can also use replace to replace substrings of a string with a different substring.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">15</td>
<td>
<p><b>reserve()</b></p>
<p>The String reserve() function allows you to allocate a buffer in memory for manipulating strings.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">16</td>
<td>
<p><b>setCharAt()</b></p>
<p>Sets a character of the String. Has no effect on indices outside the existing length of the String.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">17</td>
<td>
<p><b>startsWith()</b></p>
<p>Tests whether or not a String starts with the characters of another String.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">18</td>
<td>
<p><b>toCharArray()</b></p>
<p>Copies the string's characters to the supplied buffer.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">19</td>
<td>
<p><b>substring()</b></p>
<p>Get a substring of a String. The starting index is inclusive (the corresponding character is included in the substring), but the optional ending index is exclusive (the corresponding character is not included in the substring). If the ending index is omitted, the substring continues to the end of the String.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">20</td>
<td>
<p><b>toInt()</b></p>
<p>Converts a valid String to an integer. The input string should start with an integer number. If the string contains non-integer numbers, the function will stop performing the conversion.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">21</td>
<td>
<p><b>toFloat()</b></p>
<p>Converts a valid String to a float. The input string should start with a digit. If the string contains non-digit characters, the function will stop performing the conversion. For example, the strings "123.45", "123", and "123fish" are converted to 123.45, 123.00, and 123.00 respectively. Note that "123.456" is approximated with 123.46. Note too that floats have only 6-7 decimal digits of precision and that longer strings might be truncated.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">22</td>
<td>
<p><b>toLowerCase()</b></p>
<p>Get a lower-case version of a String. As of 1.0, toLowerCase() modifies the string in place rather than returning a new.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">23</td>
<td>
<p><b>toUpperCase()</b></p>
<p>Get an upper-case version of a String. As of 1.0, toUpperCase() modifies the string in place rather than returning a new one.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">24</td>
<td>
<p><b>trim()</b></p>
<p>Get a version of the String with any leading and trailing whitespace removed. As of 1.0, trim() modifies the string in place rather than returning a new one.</p>
</td>
</tr>
</table>
</div>
</section>
<p>The next sketch uses some C string functions.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
void setup() {
   char str[] = "This is my string"; // create a string
   char out_str[40]; // output from string functions placed here
   int num; // general purpose integer
   Serial.begin(9600);

   // (1) print the string
   Serial.println(str);

   // (2) get the length of the string (excludes null terminator)
   num = strlen(str);
   Serial.print("String length is: ");
   Serial.println(num);

   // (3) get the length of the array (includes null terminator)
   num = sizeof(str); // sizeof() is not a C string function
   Serial.print("Size of the array: ");
   Serial.println(num);

   // (4) copy a string
   strcpy(out_str, str);
   Serial.println(out_str);

   // (5) add a string to the end of a string (append)
   strcat(out_str, " sketch.");
   Serial.println(out_str);
   num = strlen(out_str);
   Serial.print("String length is: ");
   Serial.println(num);
   num = sizeof(out_str);
   Serial.print("Size of the array out_str[]: ");
   Serial.println(num);
}

void loop() {

}
</pre>
<h3>Result</h3>
<pre class="result notranslate">
This is my string
String length is: 17
Size of the array: 18
This is my string
This is my string sketch.
String length is: 25
Size of the array out_str[]: 40
</pre>
<p>The sketch works in the following way.</p>
<h3>Print the String</h3>
<p>The newly created string is printed to the Serial Monitor window as done in previous sketches.</p>
<h3>Get the Length of the String</h3>
<p>The strlen() function is used to get the length of the string. The length of the string is for the printable characters only and does not include the null terminator.</p>
<p>The string contains 17 characters, so we see 17 printed in the Serial Monitor window.</p>
<h3>Get the Length of the Array</h3>
<p>The operator sizeof() is used to get the length of the array that contains the string. The length includes the null terminator, so the length is one more than the length of the string.</p>
<p>sizeof() looks like a function, but technically is an operator. It is not a part of the C string library, but was used in the sketch to show the difference between the size of the array and the size of the string (or string length).</p>
<h3>Copy a String</h3>
<p>The strcpy() function is used to copy the str[] string to the out_num[] array. The strcpy() function copies the second string passed to it into the first string. A copy of the string now exists in the out_num[] array, but only takes up 18 elements of the array, so we still have 22 free char elements in the array. These free elements are found after the string in memory.</p>
<p>The string was copied to the array so that we would have some extra space in the array to use in the next part of the sketch, which is adding a string to the end of a string.</p>
<h3>Append a String to a String (Concatenate)</h3>
<p>The sketch joins one string to another, which is known as concatenation. This is done using the strcat() function. The strcat() function puts the second string passed to it onto the end of the first string passed to it.</p>
<p>After concatenation, the length of the string is printed to show the new string length. The length of the array is then printed to show that we have a 25-character long string in a 40 element long array.</p>
<p>Remember that the 25-character long string actually takes up 26 characters of the array because of the null terminating zero.</p>
<h2>Array Bounds</h2>
<p>When working with strings and arrays, it is very important to work within the bounds of strings or arrays. In the example sketch, an array was created, which was 40 characters long, in order to allocate the memory that could be used to manipulate strings.</p>
<p>If the array was made too small and we tried to copy a string that is bigger than the array to it, the string would be copied over the end of the array. The memory beyond the end of the array could contain other important data used in the sketch, which would then be overwritten by our string. If the memory beyond the end of the string is overrun, it could crash the sketch or cause unexpected behavior.</p>
<h1>Arduino - String Object</h1>
<p>The second type of string used in Arduino programming is the String Object.</p>
<h2>What is an Object?</h2>
<p>An object is a construct that contains both data and functions. A String object can be created just like a variable and assigned a value or string. The String object contains functions (which are called "methods" in object oriented programming (OOP)) which operate on the string data contained in the String object.</p>
<p>The following sketch and explanation will make it clear what an object is and how the String object is used.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
void setup() { 
   String my_str = "This is my string.";
   Serial.begin(9600);

   // (1) print the string
   Serial.println(my_str);

   // (2) change the string to upper-case
   my_str.toUpperCase();
   Serial.println(my_str);

   // (3) overwrite the string
   my_str = "My new string.";
   Serial.println(my_str);

   // (4) replace a word in the string
   my_str.replace("string", "Arduino sketch");
   Serial.println(my_str);

   // (5) get the length of the string
   Serial.print("String length is: ");
   Serial.println(my_str.length());
}

void loop() { 

}
</pre>
<h3>Result</h3>
<pre class="result notranslate">
This is my string.
THIS IS MY STRING.
My new string.
My new Arduino sketch.
String length is: 22
</pre>
<p>A string object is created and assigned a value (or string) at the top of the sketch.</p>
<pre class="result notranslate">
String my_str = "This is my string." ;
</pre>
<p>This creates a String object with the name <b>my_str</b> and gives it a value of "This is my string.".</p>
<p>This can be compared to creating a variable and assigning a value to it such as an integer &minus;</p>
<pre class="result notranslate">
int my_var = 102;
</pre>
<p>The sketch works in the following way.</p>
<h3>Printing the String</h3>
<p>The string can be printed to the Serial Monitor window just like a character array string.</p>
<h3>Convert the String to Upper-case</h3>
<p>The string object my_str that was created, has a number of functions or methods that can be operated on it. These methods are invoked by using the objects name followed by the dot operator (.) and then the name of the function to use.</p>
<pre class="result notranslate">
my_str.toUpperCase();
</pre>
<p>The <b>toUpperCase()</b> function operates on the string contained in the <b>my_str</b> object which is of type String and converts the string data (or text) that the object contains to upper-case characters. A list of the functions that the String class contains can be found in the Arduino String reference. Technically, String is called a class and is used to create String objects.</p>
<h3>Overwrite a String</h3>
<p>The assignment operator is used to assign a new string to the <b>my_str</b> object that replaces the old string</p>
<pre class="result notranslate">
my_str = "My new string." ;
</pre>
<p>The assignment operator cannot be used on character array strings, but works on String objects only.</p>
<h3>Replacing a Word in the String</h3>
<p>The replace() function is used to replace the first string passed to it by the second string passed to it. replace() is another function that is built into the String class and so is available to use on the String object my_str.</p>
<h3>Getting the Length of the String</h3>
<p>Getting the length of the string is easily done by using length(). In the example sketch, the result returned by length() is passed directly to Serial.println() without using an intermediate variable.</p>
<h2>When to Use a String Object</h2>
<p>A String object is much easier to use than a string character array. The object has built-in functions that can perform a number of operations on strings.</p>
<p>The main disadvantage of using the String object is that it uses a lot of memory and can quickly use up the Arduinos RAM memory, which may cause Arduino to hang, crash or behave unexpectedly. If a sketch on an Arduino is small and limits the use of objects, then there should be no problems.</p>
<p>Character array strings are more difficult to use and you may need to write your own functions to operate on these types of strings. The advantage is that you have control on the size of the string arrays that you make, so you can keep the arrays small to save memory.</p>
<p>You need to make sure that you do not write beyond the end of the array bounds with string arrays. The String object does not have this problem and will take care of the string bounds for you, provided there is enough memory for it to operate on. The String object can try to write to memory that does not exist when it runs out of memory, but will never write over the end of the string that it is operating on.</p>
<h3>Where Strings are Used</h3>
<p>In this chapter we studied about the strings, how they behave in memory and their operations.</p>
<p>The practical uses of strings will be covered in the next part of this course when we study how to get user input from the Serial Monitor window and save the input in a string.</p>
<h1>Arduino - Time</h1>
<p>Arduino provides four different time manipulation functions. They are &minus;</p>
<table class="table table-bordered">
<tr>
<th>S.No.</th>
<th style="text-align:center;">Function &amp; Description</th>
</tr>
<tr>
<td style="text-align:center; vertical-align:middle;">1</td>
<td>
<p><a href="/arduino/arduino_delay_function.htm">delay () function</a></p>
<p>The way the <b>delay()</b> function works is pretty simple. It accepts a single integer (or number) argument. This number represents the time (measured in milliseconds).</p>
</td>
</tr>
<tr>
<td style="text-align:center; vertical-align:middle;">2</td>
<td>
<p><a href="/arduino/arduino_delaymicroseconds_function.htm">delayMicroseconds () function</a></p>
<p>The <b>delayMicroseconds()</b> function accepts a single integer (or number) argument. There are a thousand microseconds in a millisecond, and a million microseconds in a second.</p>
</td>
</tr>
<tr>
<td style="text-align:center; vertical-align:middle;">3</td>
<td>
<p><a href="/arduino/arduino_millis_function.htm">millis () function</a></p>
<p>This function is used to return the number of milliseconds at the time, the Arduino board begins running the current program.</p>
</td>
</tr>
<tr>
<td style="text-align:center; vertical-align:middle;">4</td>
<td>
<p><a href="/arduino/arduino_micros_function.htm">micros () function</a></p>
<p>The micros() function returns the number of microseconds from the time, the Arduino board begins running the current program. This number overflows i.e. goes back to zero after approximately 70 minutes.</p>
</td>
</tr>
</table>
<h1>Arduino - Arrays</h1>
<p>An array is a consecutive group of memory locations that are of the same type. To refer to a particular location or element in the array, we specify the name of the array and the position number of the particular element in the array.</p>
<p>The illustration given below shows an integer array called C that contains 11 elements. You refer to any one of these elements by giving the array name followed by the particular element’s position number in square brackets ([]). The position number is more formally called a subscript or index (this number specifies the number of elements from the beginning of the array). The first element has subscript 0 (zero) and is sometimes called the zeros element.</p>
<p>Thus, the elements of array C are C[0] (pronounced “C sub zero”), C[1], C[2] and so on. The highest subscript in array C is 10, which is 1 less than the number of elements in the array (11). Array names follow the same conventions as other variable names.</p>
<img src="/arduino/images/elements_of_array.jpg" alt="Elements of Array" />
<p>A subscript must be an integer or integer expression (using any integral type). If a program uses an expression as a subscript, then the program evaluates the expression to determine the subscript. For example, if we assume that variable a is equal to 5 and that variable b is equal to 6, then the statement adds 2 to array element C[11].</p>
<p>A subscripted array name is an lvalue, it can be used on the left side of an assignment, just as non-array variable names can.</p>
<p>Let us examine array C in the given figure, more closely. The name of the entire array is C. Its 11 elements are referred to as C[0] to C[10]. The value of C[0] is -45, the value of C[1] is 6, the value of C[2] is 0, the value of C[7] is 62, and the value of C[10] is 78.</p>
<p>To print the sum of the values contained in the first three elements of array C, we would write &minus;</p>
<pre class="result notranslate">
Serial.print (C[ 0 ] + C[ 1 ] + C[ 2 ] );
</pre>
<p>To divide the value of C[6] by 2 and assign the result to the variable x, we would write &minus;</p>
<pre class="result notranslate">
x = C[ 6 ] / 2;
</pre>
<h2>Declaring Arrays</h2>
<p>Arrays occupy space in memory. To specify the type of the elements and the number of elements required by an array, use a declaration of the form &minus;</p>
<pre class="result notranslate">
type arrayName [ arraySize ] ;
</pre>
<p>The compiler reserves the appropriate amount of memory. (Recall that a declaration, which reserves memory is more properly known as a definition). The arraySize must be an integer constant greater than zero. For example, to tell the compiler to reserve 11 elements for integer array C, use the declaration &minus;</p>
<pre class="result notranslate">
int C[ 12 ]; // C is an array of 12 integers
</pre>
<p>Arrays can be declared to contain values of any non-reference data type. For example, an array of type string can be used to store character strings.</p>
<h2>Examples Using Arrays</h2>
<p>This section gives many examples that demonstrate how to declare, initialize and manipulate arrays.</p>
<h3>Example 1: Declaring an Array and using a Loop to Initialize the Array’s Elements</h3>
<p>The program declares a 10-element integer array <b>n</b>. Lines a–b use a <b>For</b> statement to initialize the array elements to zeros. Like other automatic variables, automatic arrays are not implicitly initialized to zero. The first output statement (line c) displays the column headings for the columns printed in the subsequent for statement (lines d–e), which prints the array in tabular format.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
int n[ 10 ] ; // n is an array of 10 integers

void setup () {

}

void loop () {
   for ( int i = 0; i &lt; 10; ++i ) // initialize elements of array n to 0 {
      n[ i ] = 0; // set element at location i to 0
      Serial.print (i) ;
      Serial.print (‘\r’) ;
   }
   for ( int j = 0; j &lt; 10; ++j ) // output each array element's value {
      Serial.print (n[j]) ;
      Serial.print (‘\r’) ;
   } 
}
</pre>
<p><b>Result</b> &minus; It will produce the following result &minus;</p>
<pre class="result notranslate">
<table class="table table-bordered" style="width:40% !important; margin:auto;" >
<tr>
<th style="text-align:center;">Element</th>
<th style="text-align:center;">Value</th>
</tr>
<tr>
<td>
<p class="ex1" style="text-align:center;">0</p>
<p class="ex1" style="text-align:center;">1</p>
<p class="ex1" style="text-align:center;">2</p>
<p class="ex1" style="text-align:center;">3</p>
<p class="ex1" style="text-align:center;">4</p>
<p class="ex1" style="text-align:center;">5</p>
<p class="ex1" style="text-align:center;">6</p>
<p class="ex1" style="text-align:center;">7</p>
<p class="ex1" style="text-align:center;">8</p>
<p class="ex1" style="text-align:center;">9</p>
</td>
<td>
<p class="ex1" style="text-align:center;">0</p>
<p class="ex1" style="text-align:center;">0</p>
<p class="ex1" style="text-align:center;">0</p>
<p class="ex1" style="text-align:center;">0</p>
<p class="ex1" style="text-align:center;">0</p>
<p class="ex1" style="text-align:center;">0</p>
<p class="ex1" style="text-align:center;">0</p>
<p class="ex1" style="text-align:center;">0</p>
<p class="ex1" style="text-align:center;">0</p>
<p class="ex1" style="text-align:center;">0</p>
</td>
</tr>
</table>
</pre>
<h3>Example 2: Initializing an Array in a Declaration with an Initializer List</h3>
<p>The elements of an array can also be initialized in the array declaration by following the array name with an equal-to sign and a brace-delimited comma-separated list of initializers. The program uses an initializer list to initialize an integer array with 10 values (line a) and prints the array in tabular format (lines b–c).</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
// n is an array of 10 integers
int n[ 10 ] = { 32, 27, 64, 18, 95, 14, 90, 70, 60, 37 } ;

void setup () {

}

void loop () {
   for ( int i = 0; i &lt; 10; ++i ) // initialize elements of array n to 0 {
      Serial.print (i) ;
      Serial.print (‘\r’) ;
   }
   for ( int j = 0; j &lt; 10; ++j ) // output each array element's value {
      Serial.print (n[j]) ;
      Serial.print (‘\r’) ;
   } 
}
</pre>
<p><b>Result</b> &minus; It will produce the following result &minus;</p>
<pre class="result notranslate">
<table class="table table-bordered" style="width:40% !important; margin:auto;" >
<tr>
<th style="text-align:center;">Element</th>
<th style="text-align:center;">Value</th>
</tr>
<tr>
<td>
<p class="ex1" style="text-align:center;">0</p>
<p class="ex1" style="text-align:center;">1</p>
<p class="ex1" style="text-align:center;">2</p>
<p class="ex1" style="text-align:center;">3</p>
<p class="ex1" style="text-align:center;">4</p>
<p class="ex1" style="text-align:center;">5</p>
<p class="ex1" style="text-align:center;">6</p>
<p class="ex1" style="text-align:center;">7</p>
<p class="ex1" style="text-align:center;">8</p>
<p class="ex1" style="text-align:center;">9</p>
</td>
<td>
<p class="ex1" style="text-align:center;">32</p>
<p class="ex1" style="text-align:center;">27</p>
<p class="ex1" style="text-align:center;">64</p>
<p class="ex1" style="text-align:center;">18</p>
<p class="ex1" style="text-align:center;">95</p>
<p class="ex1" style="text-align:center;">14</p>
<p class="ex1" style="text-align:center;">90</p>
<p class="ex1" style="text-align:center;">70</p>
<p class="ex1" style="text-align:center;">60</p>
<p class="ex1" style="text-align:center;">37</p>
</td>
</tr>
</table>
</pre>
<h3>Example 3: Summing the Elements of an Array</h3>
<p>Often, the elements of an array represent a series of values to be used in a calculation. For example, if the elements of an array represent exam grades, a professor may wish to total the elements of the array and use that sum to calculate the class average for the exam. The program sums the values contained in the 10-element integer array <b>a</b>.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
const int arraySize = 10; // constant variable indicating size of array
int a[ arraySize ] = { 87, 68, 94, 100, 83, 78, 85, 91, 76, 87 };
int total = 0;

void setup () {

}
void loop () {
   // sum contents of array a
   for ( int i = 0; i &lt; arraySize; ++i )
      total += a[ i ];
   Serial.print (“Total of array elements : ”) ;
   Serial.print(total) ;
}
</pre>
<p><b>Result</b> &minus; It will produce the following result &minus;</p>
<pre class="result notranslate">
Total of array elements: 849
</pre>
<p>Arrays are important to Arduino and should need a lot more attention. The following important concepts related to array should be clear to a Arduino &minus;</p>
<table class="table table-bordered">
<tr>
<th>S.NO.</th>
<th style="text-align:center;">Concept &amp; Description</th>
</tr>
<tr>
<td>1</td>
<td><a href="/arduino/arduino_passing_arrays_to_functions.htm">Passing Arrays to Functions</a>
<p>To pass an array argument to a function, specify the name of the array without any brackets.</p></td> 
</tr>
<tr>
<td>2</td>
<td><a href="/arduino/arduino_multi_dimensional_arrays.htm">Multi-Dimensional Arrays</a>
<p>Arrays with two dimensions (i.e., subscripts) often represent tables of values consisting of information arranged in rows and columns.</p></td> 
</tr>
</table>
<h1>Arduino - I/O Functions</h1>
<p>The pins on the Arduino board can be configured as either inputs or outputs. We will explain the functioning of the pins in those modes. It is important to note that a majority of Arduino analog pins, may be configured, and used, in exactly the same manner as digital pins.</p>
<h2>Pins Configured as INPUT</h2>
<p>Arduino pins are by default configured as inputs, so they do not need to be explicitly declared as inputs with <b>pinMode()</b> when you are using them as inputs. Pins configured this way are said to be in a high-impedance state. Input pins make extremely small demands on the circuit that they are sampling, equivalent to a series resistor of 100 megaohm in front of the pin.</p>
<p>This means that it takes very little current to switch the input pin from one state to another. This makes the pins useful for such tasks as implementing a capacitive touch sensor or reading an LED as a photodiode.</p>
<p>Pins configured as pinMode(pin, INPUT) with nothing connected to them, or with wires connected to them that are not connected to other circuits, report seemingly random changes in pin state, picking up electrical noise from the environment, or capacitively coupling the state of a nearby pin.</p>
<h2>Pull-up Resistors</h2>
<p>Pull-up resistors are often useful to steer an input pin to a known state if no input is present. This can be done by adding a pull-up resistor (to &plus;5V), or a pull-down resistor (resistor to ground) on the input. A 10K resistor is a good value for a pull-up or pull-down resistor.</p>
<h3>Using Built-in Pull-up Resistor with Pins Configured as Input</h3>
<p>There are 20,000 pull-up resistors built into the Atmega chip that can be accessed from software. These built-in pull-up resistors are accessed by setting the <b>pinMode()</b> as INPUT_PULLUP. This effectively inverts the behavior of the INPUT mode, where HIGH means the sensor is OFF and LOW means the sensor is ON. The value of this pull-up depends on the microcontroller used. On most AVR-based boards, the value is guaranteed to be between 20kΩ and 50kΩ. On the Arduino Due, it is between 50kΩ and 150kΩ. For the exact value, consult the datasheet of the microcontroller on your board.</p>
<p>When connecting a sensor to a pin configured with INPUT_PULLUP, the other end should be connected to the ground. In case of a simple switch, this causes the pin to read HIGH when the switch is open and LOW when the switch is pressed. The pull-up resistors provide enough current to light an LED dimly connected to a pin configured as an input. If LEDs in a project seem to be working, but very dimly, this is likely what is going on.</p>
<p>Same registers (internal chip memory locations) that control whether a pin is HIGH or LOW control the pull-up resistors. Consequently, a pin that is configured to have pull-up resistors turned on when the pin is in INPUTmode, will have the pin configured as HIGH if the pin is then switched to an OUTPUT mode with pinMode(). This works in the other direction as well, and an output pin that is left in a HIGH state will have the pull-up resistor set if switched to an input with pinMode().</p>
<p><b>Example</b></p>
<pre class="result notranslate">
pinMode(3,INPUT) ; // set pin to input without using built in pull up resistor
pinMode(5,INPUT_PULLUP) ; // set pin to input using built in pull up resistor
</pre>
<h2>Pins Configured as OUTPUT</h2>
<p>Pins configured as OUTPUT with pinMode() are said to be in a low-impedance state. This means that they can provide a substantial amount of current to other circuits. Atmega pins can source (provide positive current) or sink (provide negative current) up to 40 mA (milliamps) of current to other devices/circuits. This is enough current to brightly light up an LED (do not forget the series resistor), or run many sensors but not enough current to run relays, solenoids, or motors.</p>
<p>Attempting to run high current devices from the output pins, can damage or destroy the output transistors in the pin, or damage the entire Atmega chip. Often, this results in a "dead" pin in the microcontroller but the remaining chips still function adequately. For this reason, it is a good idea to connect the OUTPUT pins to other devices through 470Ω or 1k resistors, unless maximum current drawn from the pins is required for a particular application.</p>
<h2>pinMode() Function</h2>
<p>The pinMode() function is used to configure a specific pin to behave either as an input or an output. It is possible to enable the internal pull-up resistors with the mode INPUT_PULLUP. Additionally, the INPUT mode explicitly disables the internal pull-ups.</p>
<h3>pinMode() Function Syntax</h3>
<pre class="result notranslate">
Void setup () {
   pinMode (pin , mode);
}
</pre>
<ul class="list">
<li><p><b>pin</b> &minus; the number of the pin whose mode you wish to set</p></li>
<li><p><b>mode</b> &minus; INPUT, OUTPUT, or INPUT_PULLUP.</p></li>
</ul>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
int button = 5 ; // button connected to pin 5
int LED = 6; // LED connected to pin 6

void setup () {
   pinMode(button , INPUT_PULLUP); 
   // set the digital pin as input with pull-up resistor
   pinMode(button , OUTPUT); // set the digital pin as output
}

void setup () {
   If (digitalRead(button ) == LOW) // if button pressed {
      digitalWrite(LED,HIGH); // turn on led
      delay(500); // delay for 500 ms
      digitalWrite(LED,LOW); // turn off led
      delay(500); // delay for 500 ms
   }
}
</pre>
<h2>digitalWrite() Function</h2>
<p>The <b>digitalWrite()</b> function is used to write a HIGH or a LOW value to a digital pin. If the pin has been configured as an OUTPUT with <a href="https://www.arduino.cc/en/Reference/PinMode" rel="nofollow" target="_blank">pinMode()</a>, its voltage will be set to the corresponding value: 5V (or 3.3V on 3.3V boards) for HIGH, 0V (ground) for LOW. If the pin is configured as an INPUT, digitalWrite() will enable (HIGH) or disable (LOW) the internal pullup on the input pin. It is recommended to set the <a href="https://www.arduino.cc/en/Reference/PinMode" rel="nofollow" target="_blank">pinMode()</a> to INPUT_PULLUP to enable the internal pull-up resistor.</p>
<p>If you do not set the pinMode() to OUTPUT, and connect an LED to a pin, when calling digitalWrite(HIGH), the LED may appear dim. Without explicitly setting pinMode(), digitalWrite() will have enabled the internal pull-up resistor, which acts like a large current-limiting resistor.</p>
<h3>digitalWrite() Function Syntax</h3>
<pre class="result notranslate">
Void loop() {
   digitalWrite (pin ,value);
}
</pre>
<ul class="list">
<li><p><b>pin</b> &minus; the number of the pin whose mode you wish to set</p></li>
<li><p><b>value</b> &minus; HIGH, or LOW.</p></li>
</ul>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
int LED = 6; // LED connected to pin 6

void setup () {
   pinMode(LED, OUTPUT); // set the digital pin as output
}

void setup () { 
   digitalWrite(LED,HIGH); // turn on led
   delay(500); // delay for 500 ms
   digitalWrite(LED,LOW); // turn off led
   delay(500); // delay for 500 ms
}
</pre>
<h2>analogRead( ) function</h2>
<p>Arduino is able to detect whether there is a voltage applied to one of its pins and report it through the digitalRead() function. There is a difference between an on/off sensor (which detects the presence of an object) and an analog sensor, whose value continuously changes. In order to read this type of sensor, we need a different type of pin.</p>
<p>In the lower-right part of the Arduino board, you will see six pins marked “Analog In”. These special pins not only tell whether there is a voltage applied to them, but also its value. By using the <b>analogRead()</b> function, we can read the voltage applied to one of the pins.</p>
<p>This function returns a number between 0 and 1023, which represents voltages between 0 and 5 volts. For example, if there is a voltage of 2.5 V applied to pin number 0, analogRead(0) returns 512.</p>
<h3>analogRead() function Syntax</h3>
<pre class="result notranslate">
analogRead(pin);
</pre>
<ul class="list">
<li><p><b>pin</b> &minus; the number of the analog input pin to read from (0 to 5 on most boards, 0 to 7 on the Mini and Nano, 0 to 15 on the Mega)</p></li>
</ul>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
int analogPin = 3;//potentiometer wiper (middle terminal) 
   // connected to analog pin 3 
int val = 0; // variable to store the value read

void setup() {
   Serial.begin(9600); // setup serial
} 

void loop() {
   val = analogRead(analogPin); // read the input pin
   Serial.println(val); // debug value
}
</pre>
<h1>Arduino - Advanced I/O Function</h1>
<p>In this chapter, we will learn some advanced Input and Output Functions.</p>
<h2>analogReference() Function</h2>
<p>Configures the reference voltage used for analog input (i.e. the value used as the top of the input range). The options are &minus;</p>
<ul class="list">
<li><p><b>DEFAULT</b> &minus; The default analog reference of 5 volts (on 5V Arduino boards) or 3.3 volts (on 3.3V Arduino boards)</p></li>
<li><p><b>INTERNAL</b> &minus; An built-in reference, equal to 1.1 volts on the ATmega168 or ATmega328 and 2.56 volts on the ATmega8 (not available on the Arduino Mega)</p></li>
<li><p><b>INTERNAL1V1</b> &minus; A built-in 1.1V reference (Arduino Mega only)</p></li>
<li><p><b>INTERNAL2V56</b> &minus; A built-in 2.56V reference (Arduino Mega only)</p></li>
<li><p><b>EXTERNAL</b> &minus; The voltage applied to the AREF pin (0 to 5V only) is used as the reference</p></li>
</ul>
<h3>analogReference() Function Syntax</h3>
<pre class="result notranslate">
analogReference (type);
</pre>
<p><b>type</b> &minus; can use any type of the follow (DEFAULT, INTERNAL, INTERNAL1V1, INTERNAL2V56, EXTERNAL)</p>
<p>Do not use anything less than 0V or more than 5V for external reference voltage on the AREF pin. If you are using an external reference on the AREF pin, you must set the analog reference to EXTERNAL before calling the <b>analogRead()</b> function. Otherwise, you will short the active reference voltage (internally generated) and the AREF pin, possibly damaging the microcontroller on your Arduino board.</p>
<img src="/arduino/images/microcontroller.jpg" alt="MicroController" />
<p>Alternatively, you can connect the external reference voltage to the AREF pin through a 5K resistor, allowing you to switch between external and internal reference voltages.</p>
<p>Note that the resistor will alter the voltage that is used as the reference because there is an internal 32K resistor on the AREF pin. The two act as a voltage divider. For example, 2.5V applied through the resistor will yield 2.5 * 32 / (32 &plus; 5) = ~2.2V at the AREF pin.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
int analogPin = 3;// potentiometer wiper (middle terminal) connected to analog pin 3 
int val = 0; // variable to store the read value

void setup() {
   Serial.begin(9600); // setup serial
   analogReference(EXTERNAL); // the voltage applied to the AREF pin (0 to 5V only) 
      // is used as the reference.
}

void loop() {
   val = analogRead(analogPin); // read the input pin
   Serial.println(val); // debug value
}
</pre>
<h1>Arduino - Character Functions</h1>
<p>All data is entered into computers as characters, which includes letters, digits and various special symbols. In this section, we discuss the capabilities of C++ for examining and manipulating individual characters.</p>
<p>The character-handling library includes several functions that perform useful tests and manipulations of character data. Each function receives a character, represented as an int, or EOF as an argument. Characters are often manipulated as integers.</p>
<p>Remember that EOF normally has the value –1 and that some hardware architectures do not allow negative values to be stored in char variables. Therefore, the character-handling functions manipulate characters as integers.</p>
<p>The following table summarizes the functions of the character-handling library. When using functions from the character-handling library, include the <b>&lt;cctype&gt;</b> header.</p>
<table class="table table-bordered">
<tr>
<th>S.No.</th>
<th style="text-align:center;">Prototype &amp; Description</th>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">1</td>
<td>
<p><b>int isdigit( int c )</b></p>
<p>Returns 1 if c is a digit and 0 otherwise.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">2</td>
<td>
<p><b>int isalpha( int c )</b></p>
<p>Returns 1 if c is a letter and 0 otherwise.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">3</td>
<td>
<p><b>int isalnum( int c )</b></p>
<p>Returns 1 if c is a digit or a letter and 0 otherwise.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">4</td>
<td>
<p><b>int isxdigit( int c )</b></p>
<p>Returns 1 if c is a hexadecimal digit character and 0 otherwise.</p>
<p>(See Appendix D, Number Systems, for a detailed explanation of binary, octal, decimal and hexadecimal numbers.)</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">5</td>
<td>
<p><b>int islower( int c )</b></p>
<p>Returns 1 if c is a lowercase letter and 0 otherwise.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">6</td>
<td>
<p><b>int isupper( int c )</b></p>
<p>Returns 1 if c is an uppercase letter; 0 otherwise.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">7</td>
<td>
<p><b>int isspace( int c )</b></p>
<p>Returns 1 if c is a white-space character—newline ('\n'), space</p>
<p>(' '), form feed ('\f'), carriage return ('\r'), horizontal tab ('\t'), or vertical tab ('\v')—and 0 otherwise.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">8</td>
<td>
<p><b>int iscntrl( int c )</b></p>
<p>Returns 1 if c is a control character, such as newline ('\n'), form feed ('\f'), carriage return ('\r'), horizontal tab ('\t'), vertical tab ('\v'), alert ('\a'), or backspace ('\b')—and 0 otherwise.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">9</td>
<td>
<p><b>int ispunct( int c )</b></p>
<p>Returns 1 if c is a printing character other than a space, a digit, or a letter and 0 otherwise.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">10</td>
<td>
<p><b>int isprint( int c )</b></p>
<p>Returns 1 if c is a printing character including space (' ') and 0 otherwise.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">11</td>
<td>
<p><b>int isgraph( int c )</b></p>
<p>Returns 1 if c is a printing character other than space (' ') and 0 otherwise.</p>
</td>
</tr>
</table>
<h2>Examples</h2>
<p>The following example demonstrates the use of the functions <b>isdigit, isalpha, isalnum</b> and <b>isxdigit</b>. Function <b>isdigit</b> determines whether its argument is a digit (0–9). The function <b>isalpha</b> determines whether its argument is an uppercase letter (A-Z) or a lowercase letter (a–z). The function <b>isalnum</b> determines whether its argument is an uppercase, lowercase letter or a digit. Function <b>isxdigit</b> determines whether its argument is a hexadecimal digit (A–F, a–f, 0–9).</p>
<h3>Example 1</h3>
<pre class="prettyprint notranslate">
void setup () {
   Serial.begin (9600);
   Serial.print ("According to isdigit:\r");
   Serial.print (isdigit( '8' ) ? "8 is a": "8 is not a");
   Serial.print (" digit\r" );
   Serial.print (isdigit( '8' ) ?"# is a": "# is not a") ;
   Serial.print (" digit\r");
   Serial.print ("\rAccording to isalpha:\r" );
   Serial.print (isalpha('A' ) ?"A is a": "A is not a");
   Serial.print (" letter\r");
   Serial.print (isalpha('A' ) ?"b is a": "b is not a");
   Serial.print (" letter\r");
   Serial.print (isalpha('A') ?"&amp; is a": "&amp; is not a");
   Serial.print (" letter\r");
   Serial.print (isalpha( 'A' ) ?"4 is a":"4 is not a");
   Serial.print (" letter\r");
   Serial.print ("\rAccording to isalnum:\r");
   Serial.print (isalnum( 'A' ) ?"A is a" : "A is not a" );

   Serial.print (" digit or a letter\r" );
   Serial.print (isalnum( '8' ) ?"8 is a" : "8 is not a" ) ;
   Serial.print (" digit or a letter\r");
   Serial.print (isalnum( '#' ) ?"# is a" : "# is not a" );
   Serial.print (" digit or a letter\r");
   Serial.print ("\rAccording to isxdigit:\r");
   Serial.print (isxdigit( 'F' ) ?"F is a" : "F is not a" );
   Serial.print (" hexadecimal digit\r" );
   Serial.print (isxdigit( 'J' ) ?"J is a" : "J is not a" ) ;
   Serial.print (" hexadecimal digit\r" );
   Serial.print (isxdigit( '7' ) ?"7 is a" : "7 is not a" ) ;

   Serial.print (" hexadecimal digit\r" );
   Serial.print (isxdigit( '$' ) ? "$ is a" : "$ is not a" );
   Serial.print (" hexadecimal digit\r" );
   Serial.print (isxdigit( 'f' ) ? “f is a" : "f is not a");
   <!--Serial.print (" hexadecimal digit\r" );-->
}

void loop () {

}
</pre>
<h3>Result</h3>
<pre class="result notranslate">
According to isdigit:
8 is a digit
# is not a digit
According to isalpha:
A is a letter
b is a letter
&amp; is not a letter
4 is not a letter
According to isalnum:
A is a digit or a letter

8 is a digit or a letter
# is not a digit or a letter
According to isxdigit:
F is a hexadecimal digit
J is not a hexadecimal digit
7 is a hexadecimal digit

$ is not a hexadecimal digit
f is a hexadecimal digit
</pre>
<p>We use the conditional operator <b>(?:)</b> with each function to determine whether the string " is a " or the string " is not a " should be printed in the output for each character tested. For example, line <b>a</b> indicates that if '8' is a digit—i.e., if <b>isdigit</b> returns a true (nonzero) value—the string "8 is a " is printed. If '8' is not a digit (i.e., if <b>isdigit</b> returns 0), the string " 8 is not a " is printed.</p>
<h3>Example 2</h3>
<p>The following example demonstrates the use of the functions <b>islower</b> and <b>isupper</b>. The function <b>islower</b> determines whether its argument is a lowercase letter (a–z). Function <b>isupper</b> determines whether its argument is an uppercase letter (A–Z).</p>
<pre class="prettyprint notranslate">
int thisChar = 0xA0;

void setup () {
   Serial.begin (9600);
   Serial.print ("According to islower:\r") ;
   Serial.print (islower( 'p' ) ? "p is a" : "p is not a" );
   Serial.print ( " lowercase letter\r" );
   Serial.print ( islower( 'P') ? "P is a" : "P is not a") ;
   Serial.print ("lowercase letter\r");
   Serial.print (islower( '5' ) ? "5 is a" : "5 is not a" );
   Serial.print ( " lowercase letter\r" );
   Serial.print ( islower( '!' )? "! is a" : "! is not a") ;
   Serial.print ("lowercase letter\r");

   Serial.print ("\rAccording to isupper:\r") ;
   Serial.print (isupper ( 'D' ) ? "D is a" : "D is not an" );
   Serial.print ( " uppercase letter\r" );
   Serial.print ( isupper ( 'd' )? "d is a" : "d is not an") ;
   Serial.print ( " uppercase letter\r" );
   Serial.print (isupper ( '8' ) ? "8 is a" : "8 is not an" );
   Serial.print ( " uppercase letter\r" );
   Serial.print ( islower( '$' )? "$ is a" : "$ is not an") ;
   Serial.print ("uppercase letter\r ");
}

void setup () {

}
</pre>
<h3>Result</h3>
<pre class="result notranslate">
According to islower:
p is a lowercase letter
P is not a lowercase letter
5 is not a lowercase letter
! is not a lowercase letter

According to isupper:
D is an uppercase letter
d is not an uppercase letter
8 is not an uppercase letter
$ is not an uppercase letter
</pre>
<h3>Example 3</h3>
<p>The following example demonstrates the use of functions <b>isspace, iscntrl, ispunct, isprint</b> and <b>isgraph</b>.</p>
<ul class="list">
<li><p>The function <b>isspace</b> determines whether its argument is a white-space character, such as space (' '), form feed ('\f'), newline ('\n'), carriage return ('\r'), horizontal tab ('\t') or vertical tab ('\v').</p></li>
<li><p>The function <b>iscntrl</b> determines whether its argument is a control character such as horizontal tab ('\t'), vertical tab ('\v'), form feed ('\f'), alert ('\a'), backspace ('\b'), carriage return ('\r') or newline ('\n').</p></li>
<li><p>The function <b>ispunct</b> determines whether its argument is a printing character other than a space, digit or letter, such as $, #, (, ), [, ], {, }, ;, : or %.</p></li>
<li><p>The function <b>isprint</b> determines whether its argument is a character that can be displayed on the screen (including the space character).</p></li>
<li><p>The function <b>isgraph</b> tests for the same characters as isprint, but the space character is not included.</p></li>
</ul>
<pre class="prettyprint notranslate">
void setup () {
   Serial.begin (9600);
   Serial.print ( " According to isspace:\rNewline ") ;
   Serial.print (isspace( '\n' )? " is a" : " is not a" );
   Serial.print ( " whitespace character\rHorizontal tab") ;
   Serial.print (isspace( '\t' )? " is a" : " is not a" );
   Serial.print ( " whitespace character\n") ;
   Serial.print (isspace('%')? " % is a" : " % is not a" );
   
   Serial.print ( " \rAccording to iscntrl:\rNewline") ;
   Serial.print ( iscntrl( '\n' )?"is a" : " is not a" ) ;
   Serial.print (" control character\r");
   Serial.print (iscntrl( '$' ) ? " $ is a" : " $ is not a" );
   Serial.print (" control character\r");
   Serial.print ("\rAccording to ispunct:\r");
   Serial.print (ispunct(';' ) ?"; is a" : "; is not a" ) ;
   Serial.print (" punctuation character\r");
   Serial.print (ispunct('Y' ) ?"Y is a" : "Y is not a" ) ;
   Serial.print ("punctuation character\r");
   Serial.print (ispunct('#' ) ?"# is a" : "# is not a" ) ;
   Serial.print ("punctuation character\r");

   Serial.print ( "\r According to isprint:\r");
   Serial.print (isprint('$' ) ?"$ is a" : "$ is not a" );
   Serial.print (" printing character\rAlert ");
   Serial.print (isprint('\a' ) ?" is a" : " is not a" );
   Serial.print (" printing character\rSpace ");
   Serial.print (isprint(' ' ) ?" is a" : " is not a" );
   Serial.print (" printing character\r");
   
   Serial.print ("\r According to isgraph:\r");
   Serial.print (isgraph ('Q' ) ?"Q is a" : "Q is not a" );
   Serial.print ("printing character other than a space\rSpace ");
   Serial.print (isgraph (' ') ?" is a" : " is not a" );
   Serial.print ("printing character other than a space ");
}

void loop () {

}
</pre>
<h3>Result</h3>
<pre class="result notranslate">
According to isspace:
Newline is a whitespace character
Horizontal tab is a whitespace character
% is not a whitespace character
According to iscntrl:
Newline is a control character
$ is not a control character
According to ispunct:
; is a punctuation character
Y is not a punctuation character
# is a punctuation character
According to isprint:
$ is a printing character
Alert is not a printing character
Space is a printing character
According to isgraph:
Q is a printing character other than a space
Space is not a printing character other than a space
</pre>
<h1>Arduino - Math Library</h1>
<p>The Arduino Math library (math.h) includes a number of useful mathematical functions for manipulating floating-point numbers.</p>
<h2>Library Macros</h2>
<p>Following are the macros defined in the header math.h &minus;</p>
<section class="toggle">
<label><i class="icon icon-minus"></i><i class="icon icon-plus"></i>Given below is the list of macros defined in the header math.h</label>
<div class="toggle-content" style="display: none;">
<table style="text-align:center;" class="table table-bordered">
<tr>
<th style="text-align:center;">Macros</th>
<th style="text-align:center;">Value</th>
<th style="text-align:center;">Description</th>
</tr>
<tr>
<td style="vertical-align:middle;">M_E</td>
<td>2.7182818284590452354</td>
<td style="vertical-align:middle;">The constant e.</td>
</tr>
<tr>
<td style="vertical-align:middle;">M_LOG2E</td>
<td>
<p>1.4426950408889634074</p>
<p>/* log_2 e */</p></td>
<td style="vertical-align:middle;">The logarithm of the e to base 2</td>
</tr>
<tr>
<td style="vertical-align:middle;">M_1_PI</td>
<td><p>0.31830988618379067154</p>
<p>/* 1/pi */</p></td>
<td style="vertical-align:middle;">The constant 1/pi</td>
</tr>
<tr>
<td style="vertical-align:middle;">M_2_PI</td>
<td>
<p>0.63661977236758134308</p>
<p>/* 2/pi */</p>
</td>
<td style="vertical-align:middle;">The constant 2/pi</td>
</tr>
<tr>
<td style="vertical-align:middle;">M_2_SQRTPI</td>
<td>
<p>1.12837916709551257390</p>
<p>/* 2/sqrt(pi) */</p>
</td>
<td style="vertical-align:middle;">The constant 2/sqrt(pi)</td>
</tr>
<tr>
<td style="vertical-align:middle;">M_LN10</td>
<td><p>2.30258509299404568402</p>
<p>/* log_e 10 */</p></td>
<td style="vertical-align:middle;">The natural logarithm of the 10</td>
</tr>
<tr>
<td style="vertical-align:middle;">M_LN2</td>
<td><p>0.69314718055994530942</p>
<p>/* log_e 2 */</p></td>
<td style="vertical-align:middle;">The natural logarithm of the 2</td>
</tr>
<tr>
<td style="vertical-align:middle;">M_LOG10E</td>
<td><p>0.43429448190325182765</p>
<p>/* log_10 e */</p></td>
<td style="vertical-align:middle;">The logarithm of the e to base 10</td>
</tr>
<tr>
<td style="vertical-align:middle;">M_PI</td>
<td><p>3.14159265358979323846</p>
<p>/* pi */</p></td>
<td style="vertical-align:middle;">The constant pi</td>
</tr>
<tr>
<td style="vertical-align:middle;">M_PI_2</td>
<td><p>3.3V1.57079632679489661923</p>
<p>/* pi/2 */</p></td>
<td style="vertical-align:middle;">The constant pi/2</td>
</tr>
<tr>
<td style="vertical-align:middle;">M_PI_4</td>
<td><p>0.78539816339744830962</p>
<p>/* pi/4 */</p></td>
<td style="vertical-align:middle;">The constant pi/4</td>
</tr>
<tr>
<td style="vertical-align:middle;">M_SQRT1_2</td>
<td><p>0.70710678118654752440</p>
<p>/* 1/sqrt(2) */</p></td>
<td style="vertical-align:middle;">The constant 1/sqrt(2)</td>
</tr>
<tr>
<td style="vertical-align:middle;">M_SQRT2</td>
<td><p>1.41421356237309504880</p>
<p>/* sqrt(2) */</p></td>
<td style="vertical-align:middle;">The square root of 2</td>
</tr>
<tr>
<td style="vertical-align:middle;">acosf</td>
<td style="text-align:center;">-</td>
<td>The alias for acos() function</td>
</tr>
<tr>
<td style="vertical-align:middle;">asinf</td>
<td style="text-align:center;">-</td>
<td>The alias for asin() function</td>
</tr>
<tr>
<td style="vertical-align:middle;">atan2f</td>
<td style="text-align:center;">-</td>
<td>The alias for atan2() function</td>
</tr>
<tr>
<td style="vertical-align:middle;">cbrtf</td>
<td style="text-align:center;">-</td>
<td>The alias for cbrt() function</td>
</tr>
<tr>
<td style="vertical-align:middle;">ceilf</td>
<td style="text-align:center;">-</td>
<td>The alias for ceil() function</td>
</tr>
<tr>
<td style="vertical-align:middle;">copysignf</td>
<td style="text-align:center;">-</td>
<td>The alias for copysign() function</td>
</tr>
<tr>
<td style="vertical-align:middle;">coshf</td>
<td style="text-align:center;">-</td>
<td>The alias for cosh() function</td>
</tr>
<tr>
<td style="vertical-align:middle;">expf</td>
<td style="text-align:center;">-</td>
<td>The alias for exp() function</td>
</tr>
<tr>
<td style="vertical-align:middle;">fabsf</td>
<td style="text-align:center;">-</td>
<td>The alias for fabs() function</td>
</tr>
<tr>
<td style="vertical-align:middle;">fdimf</td>
<td style="text-align:center;">-</td>
<td>The alias for fdim() function</td>
</tr>
<tr>
<td style="vertical-align:middle;">floorf</td>
<td style="text-align:center;">-</td>
<td>The alias for floor() function</td>
</tr>
<tr>
<td style="vertical-align:middle;">fmaxf</td>
<td style="text-align:center;">-</td>
<td>The alias for fmax() function</td>
</tr>
<tr>
<td style="vertical-align:middle;">fminf</td>
<td style="text-align:center;">-</td>
<td>The alias for fmin() function</td>
</tr>
<tr>
<td style="vertical-align:middle;">fmodf</td>
<td style="text-align:center;">-</td>
<td>The alias for fmod() function</td>
</tr>
<tr>
<td style="vertical-align:middle;">frexpf</td>
<td style="text-align:center;">-</td>
<td>The alias for frexp() function</td>
</tr>
<tr>
<td style="vertical-align:middle;">hypotf</td>
<td style="text-align:center;">-</td>
<td>The alias for hypot() function</td>
</tr>
<tr>
<td style="vertical-align:middle;">INFINITY</td>
<td style="text-align:center;">-</td>
<td>INFINITY constant</td>
</tr>
<tr>
<td style="vertical-align:middle;">isfinitef</td>
<td style="text-align:center;">-</td>
<td>The alias for isfinite() function</td>
</tr>
<tr>
<td style="vertical-align:middle;">isinff</td>
<td style="text-align:center;">-</td>
<td>The alias for isinf() function</td>
</tr>
<tr>
<td style="vertical-align:middle;">isnanf</td>
<td style="text-align:center;">-</td>
<td>The alias for isnan() function</td>
</tr>
<tr>
<td style="vertical-align:middle;">ldexpf</td>
<td style="text-align:center;">-</td>
<td>The alias for ldexp() function</td>
</tr>
<tr>
<td style="vertical-align:middle;">log10f</td>
<td style="text-align:center;">-</td>
<td>The alias for log10() function</td>
</tr>
<tr>
<td style="vertical-align:middle;">logf</td>
<td style="text-align:center;">-</td>
<td>The alias for log() function</td>
</tr>
<tr>
<td style="vertical-align:middle;">lrintf</td>
<td style="text-align:center;">-</td>
<td>The alias for lrint() function</td>
</tr>
<tr>
<td style="vertical-align:middle;">lroundf</td>
<td style="text-align:center;">-</td>
<td>The alias for lround() function</td>
</tr>
</table>
</div>
</section>
<h2>Library Functions</h2>
<p>The following functions are defined in the header <b>math.h</b> &minus;</p>
<section class="toggle">
<label>Given below is the list of functions are defined in the header math.h</label>
<div class="toggle-content" style="display: none;">
<table class="table table-bordered">
<tr>
<th>S.No.</th>
<th style="text-align:center;">Library Function &amp; Description</th>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">1</td>
<td>
<p><b>double acos (double __x)</b></p>
<p>The acos() function computes the principal value of the arc cosine of __x. The returned value is in the range [0, pi] radians. A domain error occurs for arguments not in the range [-1, +1].</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">2</td>
<td>
<p><b>double asin (double __x)</b></p>
<p>The asin() function computes the principal value of the arc sine of __x. The returned value is in the range [-pi/2, pi/2] radians. A domain error occurs for arguments not in the range [-1, +1].</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">3</td>
<td>
<p><b>double atan (double __x)</b></p>
<p>The atan() function computes the principal value of the arc tangent of __x. The returned value is in the range [-pi/2, pi/2] radians.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">4</td>
<td>
<p><b>double atan2 (double __y, double __x)</b></p>
<p>The atan2() function computes the principal value of the arc tangent of __y / __x, using the signs of both arguments to determine the quadrant of the return value. The returned value is in the range [-pi, +pi] radians.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">5</td>
<td>
<p><b>double cbrt (double __x)</b></p>
<p>The cbrt() function returns the cube root of __x.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">6</td>
<td>
<p><b>double ceil (double __x)</b></p>
<p>The ceil() function returns the smallest integral value greater than or equal to __x, expressed as a floating-point number.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">7</td>
<td>
<p><b>static double copysign (double __x, double __y)</b></p>
<p>The copysign() function returns __x but with the sign of __y. They work even if __x or __y are NaN or zero.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">8</td>
<td>
<p><b>double cos(double __x)</b></p>
<p>The cos() function returns the cosine of __x, measured in radians.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">9</td>
<td>
<p><b>double cosh (double __x)</b></p>
<p>The cosh() function returns the hyperbolic cosine of __x.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">10</td>
<td>
<p><b>double exp (double __x)</b></p>
<p>The exp() function returns the exponential value of __x.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">11</td>
<td>
<p><b>double fabs (double __x)</b></p>
<p>The fabs() function computes the absolute value of a floating-point number __x.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">12</td>
<td>
<p><b>double fdim (double __x, double __y)</b></p>
<p>The fdim() function returns max(__x - __y, 0). If __x or __y or both are NaN, NaN is returned.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">13</td>
<td>
<p><b>double floor (double __x)</b></p>
<p>The floor() function returns the largest integral value less than or equal to __x, expressed as a floating-point number.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">14</td>
<td>
<p><b>double fma (double __x, double __y, double __z)</b></p>
<p>The fma() function performs floating-point multiply-add. This is the operation (__x * __y) + __z, but the intermediate result is not rounded to the destination type. This can sometimes improve the precision of a calculation.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">15</td>
<td>
<p><b>double fmax (double __x, double __y)</b></p>
<p>The fmax() function returns the greater of the two values __x and __y. If an argument is NaN, the other argument is returned. If both the arguments are NaN, NaN is returned.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">16</td>
<td>
<p><b>double fmin (double __x, double __y)</b></p>
<p>The fmin() function returns the lesser of the two values __x and __y. If an argument is NaN, the other argument is returned. If both the arguments are NaN, NaN is returned.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">17</td>
<td>
<p><b>double fmod (double __x, double__y)</b></p>
<p>The function fmod() returns the floating-point remainder of __x / __y.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">18</td>
<td>
<p><b>double frexp (double __x, int * __pexp)</b></p>
<p>The frexp() function breaks a floating-point number into a normalized fraction and an integral power of 2. It stores the integer in the int object pointed to by __pexp. If __x is a normal float point number, the frexp() function returns the value v, such that v has a magnitude in the interval [1/2, 1) or zero, and __x equals v times 2 raised to the power __pexp. If __x is zero, both parts of the result are zero. If __x is not a finite number, the frexp() returns __x as is and stores 0 by __pexp.</p>
<p><b>Note</b> &minus; This implementation permits a zero pointer as a directive to skip a storing the exponent.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">19</td>
<td>
<p><b>double hypot (double __x, double__y)</b></p>
<p>The hypot() function returns sqrt(__x*__x + __y*__y). This is the length of the hypotenuse of a right triangle with sides of length __x and __y, or the distance of the point (__x, __y) from the origin. Using this function instead of the direct formula is wise, since the error is much smaller. No underflow with small __x and __y. No overflow if result is in range.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">20</td>
<td>
<p><b>static int isfinite (double __x)</b></p>
<p>The isfinite() function returns a nonzero value if __x is finite: not plus or minus infinity, and not <b>NaN</b>.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">21</td>
<td>
<p><b>int isinf (double __x)</b></p>
<p>The function isinf() returns 1 if the argument __x is positive infinity, -1 if __x is negative infinity, and 0 otherwise.</p>
<p><b>Note</b> &minus; The GCC 4.3 can replace this function with inline code that returns the 1 value for both infinities (gcc bug #35509).</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">22</td>
<td>
<p><b>int isnan (double __x)</b></p>
<p>The function isnan() returns 1 if the argument __x represents a "not-a-number" (<b>NaN</b>) object, otherwise 0.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">23</td>
<td>
<p><b>double ldexp (double __x, int __exp )</b></p>
<p>The ldexp() function multiplies a floating-point number by an integral power of 2. It returns the value of __x times 2 raised to the power __exp.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">24</td>
<td>
<p><b>double log (double __x)</b></p>
<p>The log() function returns the natural logarithm of argument __x.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">25</td>
<td>
<p><b>double log10(double __x)</b></p>
<p>The log10() function returns the logarithm of argument __x to base 10.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">26</td>
<td>
<p><b>long lrint (double __x)</b></p>
<p>The lrint() function rounds __x to the nearest integer, rounding the halfway cases to the even integer direction. (That is both 1.5 and 2.5 values are rounded to 2). This function is similar to rint() function, but it differs in type of return value and in that an overflow is possible.</p>
<p><b>Returns</b></p>
<p>The rounded long integer value. If __x is not a finite number or an overflow, this realization returns the LONG_MIN value (0x80000000).</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">27</td>
<td>
<p><b>long lround (double __x)</b></p>
<p>The lround() function rounds __x to the nearest integer, but rounds halfway cases away from zero (instead of to the nearest even integer). This function is similar to round() function, but it differs in type of return value and in that an overflow is possible.</p>
<p><b>Returns</b></p>
<p>The rounded long integer value. If __x is not a finite number or an overflow was, this realization returns the LONG_MIN value (0x80000000).</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">28</td>
<td>
<p><b>double modf (double __x, double * __iptr )</b></p>
<p>The modf() function breaks the argument __x into integral and fractional parts, each of which has the same sign as the argument. It stores the integral part as a double in the object pointed to by __iptr.</p>
<p>The modf() function returns the signed fractional part of __x.</p>
<p><b>Note</b> &minus; This implementation skips writing by zero pointer. However, the GCC 4.3 can replace this function with inline code that does not permit to use NULL address for the avoiding of storing.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">29</td>
<td>
<p><b>float modff (float __x, float * __iptr)</b></p>
<p>The alias for modf().</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">30</td>
<td>
<p><b>double pow (double __x, double __y)</b></p>
<p>The function pow() returns the value of __x to the exponent __y.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">31</td>
<td>
<p><b>double round (double __x)</b></p>
<p>The round() function rounds __x to the nearest integer, but rounds halfway cases away from zero (instead of to the nearest even integer). Overflow is impossible.</p>
<p><b>Returns</b></p>
<p>The rounded value. If __x is an integral or infinite, __x itself is returned. If __x is <b>NaN</b>, then <b>NaN</b> is returned.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">32</td>
<td>
<p><b>int signbit (double __x)</b></p>
<p>The signbit() function returns a nonzero value if the value of __x has its sign bit set. This is not the same as `__x &lt; 0.0', because IEEE 754 floating point allows zero to be signed. The comparison `-0.0 &lt; 0.0' is false, but `signbit (-0.0)' will return a nonzero value.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">33</td>
<td>
<p><b>double sin (double __x)</b></p>
<p>The sin() function returns the sine of __x, measured in radians.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">34</td>
<td>
<p><b>double sinh (double __x)</b></p>
<p>The sinh() function returns the hyperbolic sine of __x.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">35</td>
<td>
<p><b>double sqrt (double __x)</b></p>
<p>The sqrt() function returns the non-negative square root of __x.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">36</td>
<td>
<p><b>double square (double __x)</b></p>
<p>The function square() returns __x * __x.</p>
<p><b>Note</b> &minus; This function does not belong to the C standard definition.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">37</td>
<td>
<p><b>double tan (double __x)</b></p>
<p>The tan() function returns the tangent of __x, measured in radians.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">38</td>
<td>
<p><b>double tanh ( double __x)</b></p>
<p>The tanh() function returns the hyperbolic tangent of __x.</p>
</td>
</tr>
<tr>
<td style="vertical-align:middle; text-align:center;">39</td>
<td>
<p><b>double trunc (double __x)</b></p>
<p>The trunc() function rounds __x to the nearest integer not larger in absolute value.</p>
</td>
</tr>
</table>
</div>
</section>
<h2>Example</h2>
<p>The following example shows how to use the most common math.h library functions &minus;</p>
<pre class="prettyprint notranslate">
double double__x = 45.45 ;
double double__y = 30.20 ;

void setup() {
   Serial.begin(9600);
   Serial.print("cos num = ");
   Serial.println (cos (double__x) ); // returns cosine of x
   Serial.print("absolute value of num = ");
   Serial.println (fabs (double__x) ); // absolute value of a float
   Serial.print("floating point modulo = ");
   Serial.println (fmod (double__x, double__y)); // floating point modulo
   Serial.print("sine of num = ");
   Serial.println (sin (double__x) ) ;// returns sine of x
   Serial.print("square root of num : ");
   Serial.println ( sqrt (double__x) );// returns square root of x
   Serial.print("tangent of num : ");
   Serial.println ( tan (double__x) ); // returns tangent of x
   Serial.print("exponential value of num : ");
   Serial.println ( exp (double__x) ); // function returns the exponential value of x.
   Serial.print("cos num : ");

   Serial.println (atan (double__x) ); // arc tangent of x
   Serial.print("tangent of num : ");
   Serial.println (atan2 (double__y, double__x) );// arc tangent of y/x
   Serial.print("arc tangent of num : ");
   Serial.println (log (double__x) ) ; // natural logarithm of x
   Serial.print("cos num : ");
   Serial.println ( log10 (double__x)); // logarithm of x to base 10.
   Serial.print("logarithm of num to base 10 : ");
   Serial.println (pow (double__x, double__y) );// x to power of y
   Serial.print("power of num : ");
   Serial.println (square (double__x)); // square of x
}

void loop() {

}
</pre>
<h3>Result</h3>
<pre class="result notranslate">
cos num = 0.10
absolute value of num = 45.45
floating point modulo =15.25
sine of num = 0.99
square root of num : 6.74
tangent of num : 9.67
exponential value of num : ovf
cos num : 1.55
tangent of num : 0.59
arc tangent of num : 3.82
cos num : 1.66
logarithm of num to base 10 : inf
power of num : 2065.70
</pre>
<h1>Arduino - Trigonometric Functions</h1>
<p>You need to use Trigonometry practically like calculating the distance for moving object or angular speed. Arduino provides traditional trigonometric functions (sin, cos, tan, asin, acos, atan) that can be summarized by writing their prototypes. Math.h contains the trigonometry function's prototype.</p>
<h2>Trigonometric Exact Syntax</h2>
<pre class="result notranslate">
double sin(double x); //returns sine of x radians
double cos(double y); //returns cosine of y radians
double tan(double x); //returns the tangent of x radians
double acos(double x); //returns A, the angle corresponding to cos (A) = x
double asin(double x); //returns A, the angle corresponding to sin (A) = x
double atan(double x); //returns A, the angle corresponding to tan (A) = x
</pre>
<h3>Example</h3>
<pre class="prettyprint notranslate">
double sine = sin(2); // approximately 0.90929737091
double cosine = cos(2); // approximately -0.41614685058
double tangent = tan(2); // approximately -2.18503975868
</pre>
<h1>Arduino - Due &amp; Zero</h1>
<p>The Arduino Due is a microcontroller board based on the Atmel SAM3X8E ARM Cortex-M3 CPU. It is the first Arduino board based on a 32-bit ARM core microcontroller.</p>
<p>Important features &minus;</p>
<ul class="list">
<li>It has 54 digital input/output pins (of which 12 can be used as PWM outputs)</li>
<li>12 analog inputs</li>
<li>4 UARTs (hardware serial ports)</li>
<li>84 MHz clock, an USB OTG capable connection</li>
<li>2 DAC (digital to analog), 2 TWI, a power jack, an SPI header, a JTAG header</li>
<li>Reset button and an erase button</li>
</ul>
<img src="/arduino/images/arduino_due.jpg" alt="Arduino Due" />
<h3>Characteristics of the Arduino Due Board</h3>
<table class="table table-bordered" style="text-align:center; font-size:80%;">
<tr>
<th style="text-align:center;">Operating volt</th>
<th style="text-align:center;">CPU speed</th>
<th style="text-align:center;">Analog in/out</th>
<th style="text-align:center;">Digital IO/ PWM</th>
<th style="text-align:center;">EEPROM [KB]</th>
<th style="text-align:center;">SRAM [KB]</th>
<th style="text-align:center;">Flash [KB]</th>
<th style="text-align:center;">USB</th>
<th style="text-align:center;">UART</th>
</tr>
<tr>
<td>3.3 Volt</td>
<td>84 Mhz</td>
<td>12/2</td>
<td>54/12</td>
<td>-</td>
<td>96</td>
<td>512</td>
<td>2 micro</td>
<td>4</td>
</tr>
</table>
<h3>Communication</h3>
<ul class="list">
<li>4 Hardware UARTs</li>
<li>2 I2C</li>
<li>1 CAN Interface (Automotive communication protocol)</li>
<li>1 SPI</li>
<li>1 Interface JTAG (10 pin)</li>
<li>1 USB Host (like as Leonardo)</li>
<li>1 Programming Port</li>
</ul>
<p>Unlike most Arduino boards, the Arduino Due board runs at 3.3V. The maximum voltage that the I/O pins can tolerate is 3.3V. Applying voltages higher than 3.3V to any I/O pin could damage the board.</p>
<p>The board contains everything needed to support the microcontroller. You can simply connect it to a computer with a micro-USB cable or power it with an AC-to-DC adapter or battery to get started. The Due is compatible with all Arduino shields that work at 3.3V.</p>
<h2>Arduino Zero</h2>
<p>The Zero is a simple and powerful 32-bit extension of the platform established by the UNO. The Zero board expands the family by providing increased performance, enabling a variety of project opportunities for devices, and acts as a great educational tool for learning about 32-bit application development.</p>
<p>Important features are &minus;</p>
<ul class="list">
<li><p>The Zero applications span from smart IoT devices, wearable technology, high-tech automation, to crazy robotics.</p></li>
<li><p>The board is powered by Atmel’s SAMD21 MCU, which features a 32-bit ARM Cortex&reg; M0+ core.</p></li>
<li><p>One of its most important features is Atmel’s Embedded Debugger (EDBG), which provides a full debug interface without the need for additional hardware, significantly increasing the ease-of-use for software debugging.</p></li>
<li><p>EDBG also supports a virtual COM port that can be used for device and bootloader programming.</p></li>
</ul>
<img src="/arduino/images/arduino_zero.jpg" alt="Arduino Zero" />
<h3>Characteristics of the Arduino Zero board</h3>
<table class="table table-bordered" style="text-align:center; font-size:80%;">
<tr>
<th style="text-align:center;">Operating volt</th>
<th style="text-align:center;">CPU speed</th>
<th style="text-align:center;">Analog in/out</th>
<th style="text-align:center;">Digital IO/ PWM</th>
<th style="text-align:center;">EEPROM [KB]</th>
<th style="text-align:center;">SRAM [KB]</th>
<th style="text-align:center;">Flash [KB]</th>
<th style="text-align:center;">USB</th>
<th style="text-align:center;">UART</th>
</tr>
<tr>
<td>3.3 Volt</td>
<td>48 Mhz</td>
<td>6/1</td>
<td>14/10</td>
<td>-</td>
<td>32</td>
<td>256</td>
<td>2 micro</td>
<td>2</td>
</tr>
</table>
<p>Unlike most Arduino and Genuino boards, the Zero runs at 3.3V. The maximum voltage that the I/O pins can tolerate is 3.3V. Applying voltages higher than 3.3V to any I/O pin could damage the board.</p>
<p>The board contains everything needed to support the microcontroller. You can simply connect it to a computer with a micro-USB cable or power it with an AC-to-DC adapter or a battery to get started. The Zero is compatible with all the shields that work at 3.3V.</p>
<h1>Arduino - Pulse Width Modulation</h1>
<p>Pulse Width Modulation or PWM is a common technique used to vary the width of the pulses in a pulse-train. PWM has many applications such as controlling servos and speed controllers, limiting the effective power of motors and LEDs.</p>
<h2>Basic Principle of PWM</h2>
<p>Pulse width modulation is basically, a square wave with a varying high and low time. A basic PWM signal is shown in the following figure.</p>
<img src="/arduino/images/pwm.jpg" alt="PWM" />
<p>There are various terms associated with PWM &minus;</p>
<ul class="list">
<li><p><b>On-Time</b> &minus; Duration of time signal is high.</p></li>
<li><p><b>Off-Time</b> &minus; Duration of time signal is low.</p></li>
<li><p><b>Period</b> &minus; It is represented as the sum of on-time and off-time of PWM signal.</p></li>
<li><p><b>Duty Cycle</b> &minus; It is represented as the percentage of time signal that remains on during the period of the PWM signal.</p></li>
</ul>
<h3>Period</h3>
<p>As shown in the figure, T<sub>on</sub> denotes the on-time and T<sub>off</sub> denotes the off-time of signal. Period is the sum of both on and off times and is calculated as shown in the following equation &minus;</p>
$$T_{total} = T_{on}+T_{off}$$
<h3>Duty Cycle</h3>
<p>Duty cycle is calculated as the on-time of the period of time. Using the period calculated above, duty cycle is calculated as &minus;</p>
$$D = \frac{T_{on}}{T_{on}+T_{off}} = \frac{T_{on}}{T_{total}}$$
<h2>analogWrite() Function</h2>
<p>The <b>analogWrite()</b> function writes an analog value (PWM wave) to a pin. It can be used to light a LED at varying brightness or drive a motor at various speeds. After a call of the analogWrite() function, the pin will generate a steady square wave of the specified duty cycle until the next call to analogWrite() or a call to digitalRead() or digitalWrite() on the same pin. The frequency of the PWM signal on most pins is approximately 490 Hz. On the Uno and similar boards, pins 5 and 6 have a frequency of approximately 980 Hz. Pins 3 and 11 on the Leonardo also run at 980 Hz.</p>
<p>On most Arduino boards (those with the ATmega168 or ATmega328), this function works on pins 3, 5, 6, 9, 10, and 11. On the Arduino Mega, it works on pins 2 - 13 and 44 - 46. Older Arduino boards with an ATmega8 only support <b>analogWrite()</b> on pins 9, 10, and 11.</p>
<img src="/arduino/images/uno_pwm_pins.jpg" alt="UNO PWM Pins" />
<p>The Arduino Due supports <b>analogWrite()</b> on pins 2 through 13, and pins DAC0 and DAC1. Unlike the PWM pins, DAC0 and DAC1 are Digital to Analog converters, and act as true analog outputs.</p>
<p>You do not need to call pinMode() to set the pin as an output before calling analogWrite().</p>
<h3>analogWrite() Function Syntax</h3>
<pre class="result notranslate">
analogWrite ( pin , value ) ;
</pre>
<p><b>value</b> &minus; the duty cycle: between 0 (always off) and 255 (always on).</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
int ledPin = 9; // LED connected to digital pin 9
int analogPin = 3; // potentiometer connected to analog pin 3
int val = 0; // variable to store the read value

void setup() {
   pinMode(ledPin, OUTPUT); // sets the pin as output
}

void loop() {
   val = analogRead(analogPin); // read the input pin
   analogWrite(ledPin, (val / 4)); // analogRead values go from 0 to 1023, 
      // analogWrite values from 0 to 255
}
</pre>
<h1>Arduino - Random Numbers</h1>
<p>To generate random numbers, you can use Arduino random number functions. We have two functions &minus;</p>
<ul class="list">
<li>randomSeed(seed)</li>
<li>random()</li>
</ul>
<h2>randomSeed (seed)</h2>
<p>The function randomSeed(seed) resets Arduino’s pseudorandom number generator. Although the distribution of the numbers returned by random() is essentially random, the sequence is predictable. You should reset the generator to some random value. If you have an unconnected analog pin, it might pick up random noise from the surrounding environment. These may be radio waves, cosmic rays, electromagnetic interference from cell phones, fluorescent lights and so on.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
randomSeed(analogRead(5)); // randomize using noise from analog pin 5
</pre>
<h2>random( )</h2>
<p>The random function generates pseudo-random numbers. Following is the syntax.</p>
<h3>random( ) Statements Syntax</h3>
<pre class="result notranslate">
long random(max) // it generate random numbers from 0 to max
long random(min, max) // it generate random numbers from min to max
</pre>
<h3>Example</h3>
<pre class="prettyprint notranslate">
long randNumber;

void setup() {
   Serial.begin(9600);
   // if analog input pin 0 is unconnected, random analog
   // noise will cause the call to randomSeed() to generate
   // different seed numbers each time the sketch runs.
   // randomSeed() will then shuffle the random function.
   randomSeed(analogRead(0));
}

void loop() {
   // print a random number from 0 to 299
   Serial.print("random1=");
   randNumber = random(300);
   Serial.println(randNumber); // print a random number from 0to 299
   Serial.print("random2=");
   randNumber = random(10, 20);// print a random number from 10 to 19
   Serial.println (randNumber);
   delay(50);
}
</pre>
<p>Let us now refresh our knowledge on some of the basic concepts such as bits and bytes.</p>
<h2>Bits</h2>
<p>A bit is just a binary digit.</p>
<ul class="list">
<li><p>The binary system uses two digits, 0 and 1.</p></li>
<li><p>Similar to the decimal number system, in which digits of a number do not have the same value, the ‘significance’ of a bit depends on its position in the binary number. For example, digits in the decimal number 666 are the same, but have different values.</p></li>
</ul>
<img src="/arduino/images/bits.jpg" alt="Bits" />
<h2>Bytes</h2>
<p>A byte consists of eight bits.</p>
<ul class="list">
<li><p>If a bit is a digit, it is logical that bytes represent numbers.</p></li>
<li><p>All mathematical operations can be performed upon them.</p></li>
<li><p>The digits in a byte do not have the same significance either.</p></li>
<li><p>The leftmost bit has the greatest value called the Most Significant Bit (MSB).</p></li>
<li><p>The rightmost bit has the least value and is therefore, called the Least Significant Bit (LSB).</p></li>
<li><p>Since eight zeros and ones of one byte can be combined in 256 different ways, the largest decimal number that can be represented by one byte is 255 (one combination represents a zero).</p></li>
</ul>
<h1>Arduino - Interrupts</h1>
<p>Interrupts stop the current work of Arduino such that some other work can be done.</p>
<p>Suppose you are sitting at home, chatting with someone. Suddenly the telephone rings. You stop chatting, and pick up the telephone to speak to the caller. When you have finished your telephonic conversation, you go back to chatting with the person before the telephone rang.</p>
<p>Similarly, you can think of the main routine as chatting to someone, the telephone ringing causes you to stop chatting. The interrupt service routine is the process of talking on the telephone. When the telephone conversation ends, you then go back to your main routine of chatting. This example explains exactly how an interrupt causes a processor to act.</p>
<p>The main program is running and performing some function in a circuit. However, when an interrupt occurs the main program halts while another routine is carried out. When this routine finishes, the processor goes back to the main routine again.</p>
<img src="/arduino/images/interrupt.jpg" alt="Interrupt" />
<h3>Important features</h3>
<p>Here are some important features about interrupts &minus;</p>
<ul class="list">
<li><p>Interrupts can come from various sources. In this case, we are using a hardware interrupt that is triggered by a state change on one of the digital pins.</p></li>
<li><p>Most Arduino designs have two hardware interrupts (referred to as "interrupt0" and "interrupt1") hard-wired to digital I/O pins 2 and 3, respectively.</p></li>
<li><p>The Arduino Mega has six hardware interrupts including the additional interrupts ("interrupt2" through "interrupt5") on pins 21, 20, 19, and 18.</p></li>
<li><p>You can define a routine using a special function called as “Interrupt Service Routine” (usually known as ISR).</p></li>
<li><p>You can define the routine and specify conditions at the rising edge, falling edge or both. At these specific conditions, the interrupt would be serviced.</p></li>
<li><p>It is possible to have that function executed automatically, each time an event happens on an input pin.</p></li>
</ul>
<h2>Types of Interrupts</h2>
<p>There are two types of interrupts &minus;</p>
<ul class="list">
<li><p><b>Hardware Interrupts</b> &minus; They occur in response to an external event, such as an external interrupt pin going high or low.</p></li>
<li><p><b>Software Interrupts</b> &minus; They occur in response to an instruction sent in software. The only type of interrupt that the “Arduino language” supports is the attachInterrupt() function.</p></li>
</ul>
<h3>Using Interrupts in Arduino</h3>
<p>Interrupts are very useful in Arduino programs as it helps in solving timing problems. A good application of an interrupt is reading a rotary encoder or observing a user input. Generally, an ISR should be as short and fast as possible. If your sketch uses multiple ISRs, only one can run at a time. Other interrupts will be executed after the current one finishes in an order that depends on the priority they have.</p>
<p>Typically, global variables are used to pass data between an ISR and the main program. To make sure variables shared between an ISR and the main program are updated correctly, declare them as volatile.</p>
<h3>attachInterrupt Statement Syntax</h3>
<pre class="result notranslate">
attachInterrupt(digitalPinToInterrupt(pin),ISR,mode);//recommended for arduino board
attachInterrupt(pin, ISR, mode) ; //recommended Arduino Due, Zero only
//argument pin: the pin number
//argument ISR: the ISR to call when the interrupt occurs; 
   //this function must take no parameters and return nothing. 
   //This function is sometimes referred to as an interrupt service routine.
//argument mode: defines when the interrupt should be triggered.
</pre>
<p>The following three constants are predefined as valid values &minus;</p>
<ul class="list">
<li><p><b>LOW</b> to trigger the interrupt whenever the pin is low.</p></li>
<li><p><b>CHANGE</b> to trigger the interrupt whenever the pin changes value.</p></li>
<li><p><b>FALLING</b> whenever the pin goes from high to low.</p></li>
</ul>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
int pin = 2; //define interrupt pin to 2
volatile int state = LOW; // To make sure variables shared between an ISR
//the main program are updated correctly,declare them as volatile.

void setup() {
   pinMode(13, OUTPUT); //set pin 13 as output
   attachInterrupt(digitalPinToInterrupt(pin), blink, CHANGE);
   //interrupt at pin 2 blink ISR when pin to change the value
} 
void loop() { 
   digitalWrite(13, state); //pin 13 equal the state value
} 

void blink() { 
   //ISR function
   state = !state; //toggle the state when the interrupt occurs
}
</pre>
<h1>Arduino - Communication</h1>
<p>Hundreds of communication protocols have been defined to achieve this data exchange. Each protocol can be categorized into one of the two categories: parallel or serial.</p>
<h2>Parallel Communication</h2>
<p>Parallel connection between the Arduino and peripherals via input/output ports is the ideal solution for shorter distances up to several meters. However, in other cases when it is necessary to establish communication between two devices for longer distances it is not possible to use parallel connection. Parallel interfaces transfer multiple bits at the same time. They usually require buses of data - transmitting across eight, sixteen, or more wires. Data is transferred in huge, crashing waves of 1’s and 0’s.</p>
<img src="/arduino/images/parallel_communication.jpg" alt="Parallel Communication" />
<h3>Advantages and Drawbacks of Parallel Communication</h3>
<p>Parallel communication certainly has its advantages. It is faster than serial, straightforward, and relatively easy to implement. However, it requires many input/output (I/O) ports and lines. If you have ever had to move a project from a basic Arduino Uno to a Mega, you know that the I/O lines on a microprocessor can be precious and few. Therefore, we prefer serial communication, sacrificing potential speed for pin real estate.</p>
<h2>Serial Communication Modules</h2>
<p>Today, most Arduino boards are built with several different systems for serial communication as standard equipment.</p>
<p>Which of these systems are used depends on the following factors &minus;</p>
<ul class="list">
<li>How many devices the microcontroller has to exchange data with?</li>
<li>How fast the data exchange has to be?</li>
<li>What is the distance between these devices?</li>
<li>Is it necessary to send and receive data simultaneously?</li>
</ul>
<p>One of the most important things concerning serial communication is the <b>Protocol</b>, which should be strictly observed. It is a set of rules, which must be applied such that the devices can correctly interpret data they mutually exchange. Fortunately, Arduino automatically takes care of this, so that the work of the programmer/user is reduced to simple write (data to be sent) and read (received data).</p>
<h2>Types of Serial Communications</h2>
<p>Serial communication can be further classified as &minus;</p>
<ul class="list">
<li><p><b>Synchronous</b> &minus; Devices that are synchronized use the same clock and their timing is in synchronization with each other.</p></li>
<li><p><b>Asynchronous</b> &minus; Devices that are asynchronous have their own clocks and are triggered by the output of the previous state.</p></li>
</ul>
<p>It is easy to find out if a device is synchronous or not. If the same clock is given to all the connected devices, then they are synchronous. If there is no clock line, it is asynchronous.</p>
<p>For example, UART (Universal Asynchronous Receiver Transmitter) module is asynchronous.</p>
<p>The asynchronous serial protocol has a number of built-in rules. These rules are nothing but mechanisms that help ensure robust and error-free data transfers. These mechanisms, which we get for eschewing the external clock signal, are &minus;</p>
<ul class="list">
<li>Synchronization bits</li>
<li>Data bits</li>
<li>Parity bits</li>
<li>Baud rate</li>
</ul>
<h3>Synchronization Bits</h3>
<p>The synchronization bits are two or three special bits transferred with each packet of data. They are the start bit and the stop bit(s). True to their name, these bits mark the beginning and the end of a packet respectively.</p>
<p>There is always only one start bit, but the number of stop bits is configurable to either one or two (though it is normally left at one).</p>
<p>The start bit is always indicated by an idle data line going from 1 to 0, while the stop bit(s) will transition back to the idle state by holding the line at 1.</p>
<img src="/arduino/images/synchronization_bits.jpg" alt="Synchronization Bits" />
<h3>Data Bits</h3>
<p>The amount of data in each packet can be set to any size from 5 to 9 bits. Certainly, the standard data size is your basic 8-bit byte, but other sizes have their uses. A 7-bit data packet can be more efficient than 8, especially if you are just transferring 7-bit ASCII characters.</p>
<h3>Parity Bits</h3>
<p>The user can select whether there should be a parity bit or not, and if yes, whether the parity should be odd or even. The parity bit is 0 if the number of 1’s among the data bits is even. Odd parity is just the opposite.</p>
<h3>Baud Rate</h3>
<p>The term baud rate is used to denote the number of bits transferred per second [bps]. Note that it refers to bits, not bytes. It is usually required by the protocol that each byte is transferred along with several control bits. It means that one byte in serial data stream may consist of 11 bits. For example, if the baud rate is 300 bps then maximum 37 and minimum 27 bytes may be transferred per second.</p>
<h2>Arduino UART</h2>
<p>The following code will make Arduino send hello world when it starts up.</p>
<pre class="prettyprint notranslate">
void setup() {
   Serial.begin(9600); //set up serial library baud rate to 9600
   Serial.println("hello world"); //print hello world
}

void loop() {

}
</pre>
<p>After the Arduino sketch has been uploaded to Arduino, open the Serial monitor <img class="inline" src="/arduino/images/search.jpg" alt="Search" /> at the top right section of Arduino IDE.</p>
<p>Type anything into the top box of the Serial Monitor and press send or enter on your keyboard. This will send a series of bytes to the Arduino.</p>
<p>The following code returns whatever it receives as an input.</p>
<p>The following code will make Arduino deliver output depending on the input provided.</p>
<pre class="prettyprint notranslate">
void setup() {
   Serial.begin(9600); //set up serial library baud rate to 9600
}

void loop() {
   if(Serial.available()) //if number of bytes (characters) available for reading from { 
      serial port
      Serial.print("I received:"); //print I received
      Serial.write(Serial.read()); //send what you read
   }
}
</pre>
<p>Notice that <b>Serial.print</b> and <b>Serial.println</b> will send back the actual ASCII code, whereas <b>Serial.write</b> will send back the actual text. See ASCII codes for more information.</p>
<h1>Arduino - Inter Integrated Circuit</h1>
<p>Inter-integrated circuit (I2C) is a system for serial data exchange between the microcontrollers and specialized integrated circuits of a new generation. It is used when the distance between them is short (receiver and transmitter are usually on the same printed board). Connection is established via two conductors. One is used for data transfer and the other is used for synchronization (clock signal).</p>
<p>As seen in the following figure, one device is always a master. It performs addressing of one slave chip before the communication starts. In this way, one microcontroller can communicate with 112 different devices. Baud rate is usually 100 Kb/sec (standard mode) or 10 Kb/sec (slow baud rate mode). Systems with the baud rate of 3.4 Mb/sec have recently appeared. The distance between devices, which communicate over an I2C bus is limited to several meters.</p>
<img src="/arduino/images/i2c.jpg" alt="I2C" />
<h2>Board I2C Pins</h2>
<p>The I2C bus consists of two signals &minus; SCL and SDA. SCL is the clock signal, and SDA is the data signal. The current bus master always generates the clock signal. Some slave devices may force the clock low at times to delay the master sending more data (or to require more time to prepare data before the master attempts to clock it out). This is known as “clock stretching”.</p>
<p>Following are the pins for different Arduino boards &minus;</p>
<ul class="list">
<li>Uno, Pro Mini <span style="padding-left:7%;">A4 (SDA), A5 (SCL)</span></li>
<li>Mega, Due <span style="padding-left:10%;">20 (SDA), 21 (SCL)</span></li>
<li>Leonardo, Yun <span style="padding-left:6%;">2 (SDA), 3 (SCL)</span></li>
</ul>
<h2>Arduino I2C</h2>
<p>We have two modes - master code and slave code - to connect two Arduino boards using I2C. They are &minus;</p>
<ul class="list">
<li>Master Transmitter / Slave Receiver</li>
<li>Master Receiver / Slave Transmitter</li>
</ul>
<h2>Master Transmitter / Slave Receiver</h2>
<p>Let us now see what is master transmitter and slave receiver.</p>
<h3>Master Transmitter</h3>
<p>The following functions are used to initialize the Wire library and join the I2C bus as a master or slave. This is normally called only once.</p>
<ul class="list">
<li><p><b>Wire.begin(address)</b> &minus; Address is the 7-bit slave address in our case as the master is not specified and it will join the bus as a master.</p></li>
<li><p><b>Wire.beginTransmission(address)</b> &minus; Begin a transmission to the I2C slave device with the given address.</p></li>
<li><p><b>Wire.write(value)</b> &minus; Queues bytes for transmission from a master to slave device (in-between calls to beginTransmission() and endTransmission()).</p></li>
<li><p><b>Wire.endTransmission()</b> &minus; Ends a transmission to a slave device that was begun by beginTransmission() and transmits the bytes that were queued by wire.write().</p></li>
</ul>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
#include &lt;Wire.h&gt; //include wire library

void setup() //this will run only once { 
   Wire.begin(); // join i2c bus as master
} 

short age = 0; 

void loop() {   
   Wire.beginTransmission(2); 
   // transmit to device #2
   Wire.write("age is = ");
   Wire.write(age); // sends one byte
   Wire.endTransmission(); // stop transmitting
   delay(1000); 
}
</pre>
<h3>Slave Receiver</h3>
<p>The following functions are used &minus;</p>
<ul class="list">
<li><p><b>Wire.begin(address)</b> &minus; Address is the 7-bit slave address.</p></li>
<li><p><b>Wire.onReceive(received data handler)</b> &minus; Function to be called when a slave device receives data from the master.</p></li>
<li><p><b>Wire.available()</b> &minus; Returns the number of bytes available for retrieval with Wire.read().This should be called inside the Wire.onReceive() handler.</p></li>
</ul>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
#include &lt;Wire.h&gt; //include wire library

void setup() {  //this will run only once
   Wire.begin(2); // join i2c bus with address #2
   Wire.onReceive(receiveEvent); // call receiveEvent when the master send any thing 
   Serial.begin(9600); // start serial for output to print what we receive 
}

void loop() {   
   delay(250); 
}

//-----this function will execute whenever data is received from master-----//

void receiveEvent(int howMany) { 
   while (Wire.available()&gt;1) // loop through all but the last {
      char c = Wire.read(); // receive byte as a character
      Serial.print(c); // print the character
   }
}
</pre>
<h2>Master Receiver / Slave Transmitter</h2>
<p>Let us now see what is master receiver and slave transmitter.</p>
<h3>Master Receiver</h3>
<p>The Master, is programmed to request, and then read bytes of data that are sent from the uniquely addressed Slave Arduino.</p>
<p>The following function is used &minus;</p>
<p><b>Wire.requestFrom(address,number of bytes)</b> &minus; Used by the master to request bytes from a slave device. The bytes may then be retrieved with the functions wire.available() and wire.read() functions.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
#include &lt;Wire.h&gt; //include wire library void setup() { 
   Wire.begin(); // join i2c bus (address optional for master) 
   Serial.begin(9600); // start serial for output
} 

void loop() { 
   Wire.requestFrom(2, 1); // request 1 bytes from slave device #2
   while (Wire.available()) // slave may send less than requested {
      char c = Wire.read(); // receive a byte as character
      Serial.print(c); // print the character
   } 
   delay(500); 
}
</pre>
<h3>Slave Transmitter</h3>
<p>The following function is used.</p>
<p><b>Wire.onRequest(handler)</b> &minus; A function is called when a master requests data from this slave device.</p>
<p><b>Example</b></p>
<pre class="prettyprint notranslate">
#include &lt;Wire.h&gt; 

void setup() { 
   Wire.begin(2); // join i2c bus with address #2
   Wire.onRequest(requestEvent); // register event
} 

Byte x = 0;

void loop() { 
   delay(100); 
} 

// function that executes whenever data is requested by master
// this function is registered as an event, see setup()

void requestEvent() { 
   Wire.write(x); // respond with message of 1 bytes as expected by master
   x++; 
}
</pre>
<h1>Arduino - Serial Peripheral Interface</h1>
<p>A Serial Peripheral Interface (SPI) bus is a system for serial communication, which uses up to four conductors, commonly three. One conductor is used for data receiving, one for data sending, one for synchronization and one alternatively for selecting a device to communicate with. It is a full duplex connection, which means that the data is sent and received simultaneously. The maximum baud rate is higher than that in the I2C communication system.</p>
<h2>Board SPI Pins</h2>
<p>SPI uses the following four wires &minus;</p>
<ul class="list">
<li><p><b>SCK</b> &minus; This is the serial clock driven by the master.</p></li>
<li><p><b>MOSI</b> &minus; This is the master output / slave input driven by the master.</p></li>
<li><p><b>MISO</b> &minus; This is the master input / slave output driven by the master.</p></li>
<li><p><b>SS</b> &minus; This is the slave-selection wire.</p></li>
</ul>
<p>The following functions are used. You have to include the SPI.h.</p>
<ul class="list">
<li><p><b>SPI.begin()</b> &minus; Initializes the SPI bus by setting SCK, MOSI, and SS to outputs, pulling SCK and MOSI low, and SS high.</p></li>
<li><p><b>SPI.setClockDivider(divider)</b> &minus; To set the SPI clock divider relative to the system clock. On AVR based boards, the dividers available are 2, 4, 8, 16, 32, 64 or 128. The default setting is SPI_CLOCK_DIV4, which sets the SPI clock to one-quarter of the frequency of the system clock (5 Mhz for the boards at 20 MHz).</p></li>
<li><p><b>Divider</b> &minus; It could be (SPI_CLOCK_DIV2, SPI_CLOCK_DIV4, SPI_CLOCK_DIV8, SPI_CLOCK_DIV16, SPI_CLOCK_DIV32, SPI_CLOCK_DIV64, SPI_CLOCK_DIV128).</p></li>
<li><p><b>SPI.transfer(val)</b> &minus; SPI transfer is based on a simultaneous send and receive: the received data is returned in receivedVal.</p></li>
<li><p><b>SPI.beginTransaction(SPISettings(speedMaximum, dataOrder, dataMode))</b> &minus; speedMaximum is the clock, dataOrder(MSBFIRST or LSBFIRST), dataMode(SPI_MODE0, SPI_MODE1, SPI_MODE2, or SPI_MODE3).</p></li>
</ul>
<p>We have four modes of operation in SPI as follows &minus;</p>
<ul class="list">
<li><p><b>Mode 0 (the default)</b> &minus; Clock is normally low (CPOL = 0), and the data is sampled on the transition from low to high (leading edge) (CPHA = 0).</p></li>
<li><p><b>Mode 1</b> &minus; Clock is normally low (CPOL = 0), and the data is sampled on the transition from high to low (trailing edge) (CPHA = 1).</p></li>
<li><p><b>Mode 2</b> &minus; Clock is normally high (CPOL = 1), and the data is sampled on the transition from high to low (leading edge) (CPHA = 0).</p></li>
<li><p><b>Mode 3</b> &minus; Clock is normally high (CPOL = 1), and the data is sampled on the transition from low to high (trailing edge) (CPHA = 1).</p></li>
<li><p><b>SPI.attachInterrupt(handler)</b> &minus; Function to be called when a slave device receives data from the master.</p></li>
</ul>
<p>Now, we will connect two Arduino UNO boards together; one as a master and the other as a slave.</p>
<ul class="list">
<li>(SS) : pin 10</li>
<li>(MOSI) : pin 11</li>
<li>(MISO) : pin 12</li>
<li>(SCK) : pin 13</li>
</ul>
<p>The ground is common. Following is the diagrammatic representation of the connection between both the boards &minus;</p>
<img src="/arduino/images/connection_of_boards.jpg" alt="Connection of Boards" />
<p>Let us see examples of SPI as Master and SPI as Slave.</p>
<h2>SPI as MASTER</h2>
<h3>Example</h3>
<pre class="prettyprint notranslate">
#include &lt;SPI.h&gt;

void setup (void) {
   Serial.begin(115200); //set baud rate to 115200 for usart
   digitalWrite(SS, HIGH); // disable Slave Select
   SPI.begin ();
   SPI.setClockDivider(SPI_CLOCK_DIV8);//divide the clock by 8
}

void loop (void) {
   char c;
   digitalWrite(SS, LOW); // enable Slave Select
   // send test string
   for (const char * p = "Hello, world!\r" ; c = *p; p++) {
      SPI.transfer (c);
      Serial.print(c);
   }
   digitalWrite(SS, HIGH); // disable Slave Select
   delay(2000);
}
</pre>
<h2>SPI as SLAVE</h2>
<h3>Example</h3>
<pre class="prettyprint notranslate">
#include &lt;SPI.h&gt;
char buff [50];
volatile byte indx;
volatile boolean process;

void setup (void) {
   Serial.begin (115200);
   pinMode(MISO, OUTPUT); // have to send on master in so it set as output
   SPCR |= _BV(SPE); // turn on SPI in slave mode
   indx = 0; // buffer empty
   process = false;
   SPI.attachInterrupt(); // turn on interrupt
}
ISR (SPI_STC_vect) // SPI interrupt routine { 
   byte c = SPDR; // read byte from SPI Data Register
   if (indx &lt; sizeof buff) {
      buff [indx++] = c; // save data in the next index in the array buff
      if (c == '\r') //check for the end of the word
      process = true;
   }
}

void loop (void) {
   if (process) {
      process = false; //reset the process
      Serial.println (buff); //print the array on serial monitor
      indx= 0; //reset button to zero
   }
}
</pre>
<h1>Arduino - Blinking LED</h1>
<p>LEDs are small, powerful lights that are used in many different applications. To start, we will work on blinking an LED, the Hello World of microcontrollers. It is as simple as turning a light on and off. Establishing this important baseline will give you a solid foundation as we work towards experiments that are more complex.</p>
<h2>Components Required</h2>
<p>You will need the following components &minus;</p>
<ul class="list">
<li>1 &times; Breadboard</li>
<li>1 &times; Arduino Uno R3</li>
<li>1 &times; LED</li>
<li>1 &times; 330Ω Resistor</li>
<li>2 &times; Jumper</li>
</ul>
<h2>Procedure</h2>
<p>Follow the circuit diagram and hook up the components on the breadboard as shown in the image given below.</p>
<img src="/arduino/images/breadboard.jpg" alt="Breadboard" />
<p><b>Note</b> &minus; To find out the polarity of an LED, look at it closely. The shorter of the two legs, towards the flat edge of the bulb indicates the negative terminal.</p>
<img src="/arduino/images/led.jpg" alt="LED" />
<p>Components like resistors need to have their terminals bent into 90° angles in order to fit the breadboard sockets properly. You can also cut the terminals shorter.</p>
<img src="/arduino/images/resistors.jpg" alt="Resistors" />
<h2>Sketch</h2>
<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open the new sketch File by clicking New.</p>
<img src="/arduino/images/sketch.jpg" alt="Sketch" />
<h2>Arduino Code</h2>
<pre class="prettyprint notranslate">
/*
   Blink
   Turns on an LED on for one second, then off for one second, repeatedly.
*/

// the setup function runs once when you press reset or power the board

void setup() {  // initialize digital pin 13 as an output.
   pinMode(2, OUTPUT);
}

// the loop function runs over and over again forever

void loop() {
   digitalWrite(2, HIGH); // turn the LED on (HIGH is the voltage level)
   delay(1000); // wait for a second
   digitalWrite(2, LOW); // turn the LED off by making the voltage LOW
   delay(1000); // wait for a second
}
</pre>
<h2>Code to Note</h2>
<p><b>pinMode(2, OUTPUT)</b> &minus; Before you can use one of Arduino’s pins, you need to tell Arduino Uno R3 whether it is an INPUT or OUTPUT. We use a built-in “function” called pinMode() to do this.</p>
<p><b>digitalWrite(2, HIGH)</b> &minus; When you are using a pin as an OUTPUT, you can command it to be HIGH (output 5 volts), or LOW (output 0 volts).</p>
<h2>Result</h2>
<p>You should see your LED turn on and off. If the required output is not seen, make sure you have assembled the circuit correctly, and verified and uploaded the code to your board.</p>
<h1>Arduino - Fading LED</h1>
<p>This example demonstrates the use of the analogWrite() function in fading an LED off. AnalogWrite uses pulse width modulation (PWM), turning a digital pin on and off very quickly with different ratios between on and off, to create a fading effect.</p>
<h2>Components Required</h2>
<p>You will need the following components &minus;</p>
<ul class="list">
<li>1 &times; Breadboard</li>
<li>1 &times; Arduino Uno R3</li>
<li>1 &times; LED</li>
<li>1 &times; 330Ω Resistor</li>
<li>2 &times; Jumper</li>
</ul>
<h2>Procedure</h2>
<p>Follow the circuit diagram and hook up the components on the breadboard as shown in the image given below.</p>
<img src="/arduino/images/components_on_breadboard.jpg" alt="Components on Breadboard" />
<p><b>Note</b> &minus; To find out the polarity of an LED, look at it closely. The shorter of the two legs, towards the flat edge of the bulb indicates the negative terminal.</p>
<img src="/arduino/images/led.jpg" alt="LED" />
<p>Components like resistors need to have their terminals bent into 90° angles in order to fit the breadboard sockets properly. You can also cut the terminals shorter.</p>
<img src="/arduino/images/resistors.jpg" alt="Resistors" />
<h2>Sketch</h2>
<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open the new sketch File by clicking New.</p>
<img src="/arduino/images/sketch.jpg" alt="Sketch" />
<h2>Arduino Code</h2>
<pre class="prettyprint notranslate">
/*
   Fade
   This example shows how to fade an LED on pin 9 using the analogWrite() function.

   The analogWrite() function uses PWM, so if you want to change the pin you're using, be
   sure to use another PWM capable pin. On most Arduino, the PWM pins are identified with
   a "~" sign, like ~3, ~5, ~6, ~9, ~10 and ~11.
*/

int led = 9; // the PWM pin the LED is attached to
int brightness = 0; // how bright the LED is
int fadeAmount = 5; // how many points to fade the LED by
// the setup routine runs once when you press reset:

void setup() {
   // declare pin 9 to be an output:
   pinMode(led, OUTPUT);
}

// the loop routine runs over and over again forever:

void loop() {
   // set the brightness of pin 9:
   analogWrite(led, brightness);
   // change the brightness for next time through the loop:
   brightness = brightness + fadeAmount;
   // reverse the direction of the fading at the ends of the fade:
   if (brightness == 0 || brightness == 255) {
      fadeAmount = -fadeAmount ;
   }
   // wait for 30 milliseconds to see the dimming effect
   delay(300);
}
</pre>
<h2>Code to Note</h2>
<p>After declaring pin 9 as your LED pin, there is nothing to do in the setup() function of your code. The analogWrite() function that you will be using in the main loop of your code requires two arguments: One, telling the function which pin to write to and the other indicating what PWM value to write.</p>
<p>In order to fade the LED off and on, gradually increase the PWM values from 0 (all the way off) to 255 (all the way on), and then back to 0, to complete the cycle. In the sketch given above, the PWM value is set using a variable called brightness. Each time through the loop, it increases by the value of the variable <b>fadeAmount</b>.</p>
<p>If brightness is at either extreme of its value (either 0 or 255), then fadeAmount is changed to its negative. In other words, if fadeAmount is 5, then it is set to -5. If it is -5, then it is set to 5. The next time through the loop, this change causes brightness to change direction as well.</p>
<p><b>analogWrite()</b> can change the PWM value very fast, so the delay at the end of the sketch controls the speed of the fade. Try changing the value of the delay and see how it changes the fading effect.</p>
<h2>Result</h2>
<p>You should see your LED brightness change gradually.</p>
<h1>Arduino - Reading Analog Voltage</h1>
<p>This example will show you how to read an analog input on analog pin 0. The input is converted from analogRead() into voltage, and printed out to the serial monitor of the Arduino Software (IDE).</p>
<h2>Components Required</h2>
<p>You will need the following components &minus;</p>
<ul class="list">
<li>1 &times; Breadboard</li>
<li>1 &times; Arduino Uno R3</li>
<li>1 &times; 5K variable resistor (potentiometer)</li>
<li>2 &times; Jumper</li>
</ul>
<h2>Procedure</h2>
<p>Follow the circuit diagram and hook up the components on the breadboard as shown in the image given below.</p>
<img src="/arduino/images/analog_breadboard.jpg" alt="Analog Breadboard" />
<h2>Potentiometer</h2>
<p>A potentiometer (or pot) is a simple electro-mechanical transducer. It converts rotary or linear motion from the input operator into a change of resistance. This change is (or can be) used to control anything from the volume of a hi-fi system to the direction of a huge container ship.</p>
<p>The pot as we know it was originally known as a rheostat (essentially a variable wirewound resistor). The variety of available pots is now quite astonishing, and it can be very difficult for the beginner (in particular) to work out which type is suitable for a given task. A few different pot types, which can all be used for the same task makes the job harder.</p>
<img src="/arduino/images/potentiometer.jpg" alt="Potentiometer" />
<p>The image on the left shows the standard schematic symbol of a pot. The image on the right is the potentiometer.</p>
<h2>Sketch</h2>
<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open a new sketch File by clicking New.</p>
<img src="/arduino/images/sketch.jpg" alt="Sketch" />
<h2>Arduino Code</h2>
<pre class="prettyprint notranslate">
/*
   ReadAnalogVoltage
   Reads an analog input on pin 0, converts it to voltage, 
   and prints the result to the serial monitor.
   Graphical representation is available using serial plotter (Tools &gt; Serial Plotter menu)
   Attach the center pin of a potentiometer to pin A0, and the outside pins to +5V and ground.
*/

// the setup routine runs once when you press reset:

void setup() {
   // initialize serial communication at 9600 bits per second:
   Serial.begin(9600);
}

// the loop routine runs over and over again forever:

void loop() {
   // read the input on analog pin 0:
   int sensorValue = analogRead(A0);
   // Convert the analog reading (which goes from 0 - 1023) to a voltage (0 - 5V):
   float voltage = sensorValue * (5.0 / 1023.0);
   // print out the value you read:
   Serial.println(voltage);
}
</pre>
<h2>Code to Note</h2>
<p>In the program or sketch given below, the first thing that you do in the setup function is begin serial communications, at 9600 bits per second, between your board and your computer with the line &minus;</p>
<pre class="result notranslate">
Serial.begin(9600);
</pre>
<p>In the main loop of your code, you need to establish a variable to store the resistance value (which will be between 0 and 1023, perfect for an int datatype) coming from your potentiometer &minus;</p>
<pre class="result notranslate">
int sensorValue = analogRead(A0);
</pre>
<p>To change the values from 0-1023 to a range that corresponds to the voltage, the pin is reading, you need to create another variable, a float, and do a little calculation. To scale the numbers between 0.0 and 5.0, divide 5.0 by 1023.0 and multiply that by sensorValue &minus;</p>
<pre class="result notranslate">
float voltage= sensorValue * (5.0 / 1023.0);
</pre>
<p>Finally, you need to print this information to your serial window. You can do this with the command Serial.println() in your last line of code &minus;</p>
<pre class="result notranslate">
Serial.println(voltage)
</pre>
<p>Now, open Serial Monitor in the Arduino IDE by clicking the icon on the right side of the top green bar or pressing Ctrl+Shift+M.</p>
<img src="/arduino/images/serial_monitor.jpg" alt="Serial Monitor" />
<h2>Result</h2>
<p>You will see a steady stream of numbers ranging from 0.0 - 5.0. As you turn the pot, the values will change, corresponding to the voltage at pin A0.</p>
<h1>Arduino - LED Bar Graph</h1>
<p>This example shows you how to read an analog input at analog pin 0, convert the values from analogRead() into voltage, and print it out to the serial monitor of the Arduino Software (IDE).</p>
<h2>Components Required</h2>
<p>You will need the following components &minus;</p>
<ul class="list">
<li>1 &times; Breadboard</li>
<li>1 &times; Arduino Uno R3</li>
<li>1 &times; 5k ohm variable resistor (potentiometer)</li>
<li>2 &times; Jumper</li>
<li>8 &times; LED or you can use (LED bar graph display as shown in the image below)</li>
</ul>
<h2>Procedure</h2>
<p>Follow the circuit diagram and hook up the components on the breadboard as shown in the image given below.</p>
<img src="/arduino/images/bar_breadboard.jpg" alt="Bar Breadboard" />
<p></p>
<img src="/arduino/images/connection_to_bar_breadboard.jpg" alt="Connection to Bar Breadboard" />
<h2>Sketch</h2>
<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open a new sketch File by clicking New.</p>
<img src="/arduino/images/sketch.jpg" alt="Sketch" />
<h2>10 Segment LED Bar Graph</h2>
<img src="/arduino/images/led_bar_graph.jpg" alt="LED Bar Graph" />
<p>These 10-segment bar graph LEDs have many uses. With a compact footprint, simple hookup, they are easy for prototype or finished products. Essentially, they are 10 individual blue LEDs housed together, each with an individual anode and cathode connection.</p>
<p>They are also available in yellow, red, and green colors.</p>
<p><b>Note</b> &minus; The pin out on these bar graphs may vary from what is listed on the datasheet. Rotating the device 180 degrees will correct the change, making pin 11 the first pin in line.</p>
<h2>Arduino Code</h2>
<pre class="prettyprint notranslate">
/*
   LED bar graph
   Turns on a series of LEDs based on the value of an analog sensor. 
   This is a simple way to make a bar graph display. 
   Though this graph uses 8LEDs, you can use any number by
      changing the LED count and the pins in the array.
   This method can be used to control any series of digital
      outputs that depends on an analog input.
*/

// these constants won't change:
const int analogPin = A0; // the pin that the potentiometer is attached to
const int ledCount = 8; // the number of LEDs in the bar graph
int ledPins[] = {2, 3, 4, 5, 6, 7, 8, 9}; // an array of pin numbers to which LEDs are attached

void setup() {
   // loop over the pin array and set them all to output:
   for (int thisLed = 0; thisLed &lt; ledCount; thisLed++) {
      pinMode(ledPins[thisLed], OUTPUT);
   }
}

void loop() {
   // read the potentiometer:
   int sensorReading = analogRead(analogPin);
   // map the result to a range from 0 to the number of LEDs:
   int ledLevel = map(sensorReading, 0, 1023, 0, ledCount);
   // loop over the LED array:
   for (int thisLed = 0; thisLed &lt; ledCount; thisLed++) {
      // if the array element's index is less than ledLevel,
      // turn the pin for this element on:
      if (thisLed &lt; ledLevel) {
         digitalWrite(ledPins[thisLed], HIGH);
      }else { // turn off all pins higher than the ledLevel:
         digitalWrite(ledPins[thisLed], LOW);
      }
   }
} 
</pre>
<h2>Code to Note</h2>
<p>The sketch works like this: first, you read the input. You map the input value to the output range, in this case ten LEDs. Then you set up a <b>for-loop</b> to iterate over the outputs. If the output's number in the series is lower than the mapped input range, you turn it on. If not, you turn it off.</p>
<h2>Result</h2>
<p>You will see the LED turn ON one by one when the value of analog reading increases and turn OFF one by one while the reading is decreasing.</p>
<h1>Arduino - Keyboard Logout</h1>
<p>This example uses the Keyboard library to log you out of your user session on your computer when pin 2 on the ARDUINO UNO is pulled to ground. The sketch simulates the keypress in sequence of two or three keys at the same time and after a short delay, it releases them.</p>
<p><b>Warning</b> &minus; When you use the <b>Keyboard.print()</b> command, Arduino takes over your computer's keyboard. To ensure you do not lose control of your computer while running a sketch with this function, set up a reliable control system before you call Keyboard.print(). This sketch is designed to only send a Keyboard command after a pin has been pulled to ground.</p>
<h2>Components Required</h2>
<p>You will need the following components &minus;</p>
<ul class="list">
<li>1 &times; Breadboard</li>
<li>1 &times; Arduino Leonardo, Micro, or Due board</li>
<li>1 &times; pushbutton</li>
<li>1 &times; Jumper</li>
</ul>
<h2>Procedure</h2>
<p>Follow the circuit diagram and hook up the components on the breadboard as shown in the image below.</p>
<img src="/arduino/images/keyboard_breadboard.jpg" alt="Keyboard Breadboard" />
<h2>Sketch</h2>
<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open a new sketch File by clicking New.</p>
<p>For this example, you need to use Arduino IDE 1.6.7</p>
<img src="/arduino/images/sketch.jpg" alt="Sketch" />
<p><b>Note</b> &minus; You must include the keyboard library in your Arduino library file. Copy and paste the keypad library file inside the file with the name libraries (highlighted) as shown in the following screenshot.</p>
<img src="/arduino/images/arduino_library_file.jpg" alt="Arduino library file" />
<h2>Arduino Code</h2>
<pre class="prettyprint notranslate">
/*
   Keyboard logout
   This sketch demonstrates the Keyboard library.
   When you connect pin 2 to ground, it performs a logout.
   It uses keyboard combinations to do this, as follows:
   On Windows, CTRL-ALT-DEL followed by ALT-l
   On Ubuntu, CTRL-ALT-DEL, and ENTER
   On OSX, CMD-SHIFT-q
   To wake: Spacebar.
   Circuit:
   * Arduino Leonardo or Micro
   * wire to connect D2 to ground.
*/

#define OSX 0
#define WINDOWS 1
#define UBUNTU 2

#include "Keyboard.h"

// change this to match your platform:
int platform = WINDOWS;

void setup() {
   // make pin 2 an input and turn on the
   // pullup resistor so it goes high unless
   // connected to ground:
   
   pinMode(2, INPUT_PULLUP);
   Keyboard.begin();
}

void loop() {
   while (digitalRead(2) == HIGH) {
      // do nothing until pin 2 goes low
      delay(500);
   }
   
   delay(1000);
   
   switch (platform) {
      case OSX:
      Keyboard.press(KEY_LEFT_GUI);
	  
      // Shift-Q logs out:
      Keyboard.press(KEY_LEFT_SHIFT);
      Keyboard.press('Q');
      delay(100);
	  
      // enter:
      Keyboard.write(KEY_RETURN);
      break;
	  
      case WINDOWS:
      // CTRL-ALT-DEL:
      Keyboard.press(KEY_LEFT_CTRL);
      Keyboard.press(KEY_LEFT_ALT);
      Keyboard.press(KEY_DELETE);
      delay(100);
      Keyboard.releaseAll();
	  
      //ALT-l:
      delay(2000);
      Keyboard.press(KEY_LEFT_ALT);
      Keyboard.press('l');
      Keyboard.releaseAll();
      break;
	  
      case UBUNTU:
      // CTRL-ALT-DEL:
      Keyboard.press(KEY_LEFT_CTRL);
      Keyboard.press(KEY_LEFT_ALT);
      Keyboard.press(KEY_DELETE);
	  
      delay(1000);
      Keyboard.releaseAll();
	  
      // Enter to confirm logout:
      Keyboard.write(KEY_RETURN);
      break;
   }
   
   // do nothing:
   while (true);
}

Keyboard.releaseAll();

   // enter:
      Keyboard.write(KEY_RETURN);
      break;
      case WINDOWS:
	  
   // CTRL-ALT-DEL:
      Keyboard.press(KEY_LEFT_CTRL);
      Keyboard.press(KEY_LEFT_ALT);
      Keyboard.press(KEY_DELETE);
      delay(100);
      Keyboard.releaseAll();
	  
   //ALT-l:
      delay(2000);
      Keyboard.press(KEY_LEFT_ALT);
      Keyboard.press('l');
      Keyboard.releaseAll();
      break;
	  
   case UBUNTU:
      // CTRL-ALT-DEL:
      Keyboard.press(KEY_LEFT_CTRL);
      Keyboard.press(KEY_LEFT_ALT);
      Keyboard.press(KEY_DELETE);
      delay(1000);
      Keyboard.releaseAll();
	  
      // Enter to confirm logout:
      Keyboard.write(KEY_RETURN);
      break;
   }
   
// do nothing:
   while (true);
}
</pre>
<h2>Code to Note</h2>
<p>Before you upload the program to your board, make sure you assign the correct OS you are currently using to the platform variable.</p>
<p>While the sketch is running, pressing the button will connect pin 2 to the ground and the board will send the logout sequence to the USB connected PC.</p>
<h2>Result</h2>
<p>When you connect pin 2 to the ground, it performs a logout operation.</p>
<p>It uses the following keyboard combinations to logout &minus;</p>
<ul class="list">
<li><p>On <b>Windows</b>, CTRL-ALT-DEL followed by ALT-l</p></li>
<li><p>On <b>Ubuntu</b>, CTRL-ALT-DEL, and ENTER</p></li>
<li><p>On <b>OSX</b>, CMD-SHIFT-q</p></li>
</ul>
<h1>Arduino - Keyboard Message</h1>
<p>In this example, when the button is pressed, a text string is sent to the computer as keyboard input. The string reports the number of times the button is pressed. Once you have the Leonardo programmed and wired up, open your favorite text editor to see the results.</p>
<p><b>Warning</b> &minus; When you use the <b>Keyboard.print()</b> command, the Arduino takes over your computer's keyboard. To ensure you do not lose control of your computer while running a sketch with this function, set up a reliable control system before you call <b>Keyboard.print()</b>. This sketch includes a pushbutton to toggle the keyboard, so that it only runs after the button is pressed.</p>
<h2>Components Required</h2>
<p>You will need the following components &minus;</p>
<ul class="list">
<li>1 &times; Breadboard</li>
<li>1 &times; Arduino Leonardo, Micro, or Due board</li>
<li>1 &times; momentary pushbutton</li>
<li>1 &times; 10k ohm resistor</li>
</ul>
<h2>Procedure</h2>
<p>Follow the circuit diagram and hook up the components on the breadboard as shown in the image given below.</p>
<img src="/arduino/images/keyboard_message_breadboard.jpg" alt="Keyboard Message Breadboard" />
<h2>Sketch</h2>
<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open a new sketch File by clicking New.</p>
<img src="/arduino/images/sketch.jpg" alt="Sketch" />
<h2>Arduino Code</h2>
<pre class="prettyprint notranslate">
/*
   Keyboard Message test For the Arduino Leonardo and Micro,
      Sends a text string when a button is pressed.
   The circuit:
   * pushbutton attached from pin 4 to +5V
   * 10-kilohm resistor attached from pin 4 to ground
*/

#include "Keyboard.h"
const int buttonPin = 4; // input pin for pushbutton
int previousButtonState = HIGH; // for checking the state of a pushButton
int counter = 0; // button push counter

void setup() {
   pinMode(buttonPin, INPUT); // make the pushButton pin an input:
   Keyboard.begin(); // initialize control over the keyboard:
}

void loop() {
   int buttonState = digitalRead(buttonPin); // read the pushbutton:
   if ((buttonState != previousButtonState)&amp;&amp; (buttonState == HIGH)) // and it's currently pressed: {
      // increment the button counter
      counter++;
      // type out a message
      Keyboard.print("You pressed the button ");
      Keyboard.print(counter);
      Keyboard.println(" times.");
   }
   // save the current button state for comparison next time:
   previousButtonState = buttonState;
}
</pre>
<h2>Code to Note</h2>
<p>Attach one terminal of the pushbutton to pin 4 on Arduino. Attach the other pin to 5V. Use the resistor as a pull-down, providing a reference to the ground, by attaching it from pin 4 to the ground.</p>
<p>Once you have programmed your board, unplug the USB cable, open a text editor and put the text cursor in the typing area. Connect the board to your computer through USB again and press the button to write in the document.</p>
<h2>Result</h2>
<p>By using any text editor, it will display the text sent via Arduino.</p>
<h1>Arduino - Mouse Button Control</h1>
<p>Using the Mouse library, you can control a computer's onscreen cursor with an Arduino Leonardo, Micro, or Due.</p>
<p>This particular example uses five pushbuttons to move the onscreen cursor. Four of the buttons are directional (up, down, left, right) and one is for a left mouse click. Cursor movement from Arduino is always relative. Every time an input is read, the cursor's position is updated relative to its current position.</p>
<p>Whenever one of the directional buttons is pressed, Arduino will move the mouse, mapping a HIGH input to a range of 5 in the appropriate direction.</p>
<p>The fifth button is for controlling a left-click from the mouse. When the button is released, the computer will recognize the event.</p>
<h2>Components Required</h2>
<p>You will need the following components &minus;</p>
<ul class="list">
<li>1 &times; Breadboard</li>
<li>1 &times; Arduino Leonardo, Micro or Due board</li>
<li>5 &times; 10k ohm resistor</li>
<li>5 &times; momentary pushbuttons</li>
</ul>
<h2>Procedure</h2>
<p>Follow the circuit diagram and hook up the components on the breadboard as shown in the image below.</p>
<img src="/arduino/images/mouse_button_breadboard.jpg" alt="Mouse Button Breadboard" />
<h2>Sketch</h2>
<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open a new sketch File by clicking New.</p>
<p>For this example, you need to use Arduino IDE 1.6.7</p>
<img src="/arduino/images/sketch.jpg" alt="Sketch" />
<h2>Arduino Code</h2>
<pre class="prettyprint notranslate">
/*
   Button Mouse Control
   For Leonardo and Due boards only .Controls the mouse from 
   five pushbuttons on an Arduino Leonardo, Micro or Due.
   Hardware:
   * 5 pushbuttons attached to D2, D3, D4, D5, D6
   The mouse movement is always relative. This sketch reads
   four pushbuttons, and uses them to set the movement of the mouse.
   WARNING: When you use the Mouse.move() command, the Arduino takes
   over your mouse! Make sure you have control before you use the mouse commands.
*/

#include "Mouse.h"
// set pin numbers for the five buttons:
const int upButton = 2;
const int downButton = 3;
const int leftButton = 4;
const int rightButton = 5;
const int mouseButton = 6;
int range = 5; // output range of X or Y movement; affects movement speed
int responseDelay = 10; // response delay of the mouse, in ms

void setup() {
   // initialize the buttons' inputs:
   pinMode(upButton, INPUT);
   pinMode(downButton, INPUT);
   pinMode(leftButton, INPUT);
   pinMode(rightButton, INPUT);
   pinMode(mouseButton, INPUT);
   // initialize mouse control:
   Mouse.begin();
}

void loop() {
   // read the buttons:
   int upState = digitalRead(upButton);
   int downState = digitalRead(downButton);
   int rightState = digitalRead(rightButton);
   int leftState = digitalRead(leftButton);
   int clickState = digitalRead(mouseButton);
   // calculate the movement distance based on the button states:
   int xDistance = (leftState - rightState) * range;
   int yDistance = (upState - downState) * range;
   // if X or Y is non-zero, move:
   if ((xDistance != 0) || (yDistance != 0)) {
      Mouse.move(xDistance, yDistance, 0);
   }

   // if the mouse button is pressed:
   if (clickState == HIGH) {
      // if the mouse is not pressed, press it:
      if (!Mouse.isPressed(MOUSE_LEFT)) {
         Mouse.press(MOUSE_LEFT);
      }
   } else {                           // else the mouse button is not pressed:
      // if the mouse is pressed, release it:
      if (Mouse.isPressed(MOUSE_LEFT)) {
         Mouse.release(MOUSE_LEFT);
      }
   }
   // a delay so the mouse does not move too fast:
   delay(responseDelay);
}
</pre>
<h2>Code to Note</h2>
<p>Connect your board to your computer with a micro-USB cable. The buttons are connected to digital inputs from pins 2 to 6. Make sure you use 10k pull-down resistors.</p>
<h1>Arduino - Keyboard Serial</h1>
<p>This example listens for a byte coming from the serial port. When received, the board sends a keystroke back to the computer. The sent keystroke is one higher than what is received, so if you send an "a" from the serial monitor, you will receive a "b" from the board connected to the computer. A "1" will return a "2" and so on.</p>
<p><b>Warning</b> &minus; When you use the <b>Keyboard.print()</b> command, the Leonardo, Micro or Due board takes over your computer's keyboard. To ensure you do not lose control of your computer while running a sketch with this function, set up a reliable control system before you call Keyboard.print(). This sketch is designed to only send a Keyboard command after the board has received a byte over the serial port.</p>
<h2>Components Required</h2>
<p>You will need the following components &minus;</p>
<ul class="list">
<li>1 &times; Arduino Leonardo, Micro, or Due board</li>
</ul>
<h2>Procedure</h2>
<p>Just connect your board to the computer using USB cable.</p>
<img src="/arduino/images/keyboard_serial_breadboard.jpg" alt="Keyboard Serial Breadboard" />
<h2>Sketch</h2>
<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open a new sketch File by clicking New.</p>
<img src="/arduino/images/sketch.jpg" alt="Sketch" />
<p><b>Notes</b> &minus; You must include the keypad library in your Arduino library file. Copy and paste the keypad library file inside the file with the name ‘libraries’ highlighted with yellow color.</p>
<img src="/arduino/images/arduino_library_file.jpg" alt="Arduino library file" />
<h2>Arduino Code</h2>
<pre class="prettyprint notranslate">
/*
   Keyboard test
   For the Arduino Leonardo, Micro or Due Reads
      a byte from the serial port, sends a keystroke back. 
   The sent keystroke is one higher than what's received, e.g. if you send a, you get b, send
      A you get B, and so forth.
   The circuit:
   * none
*/

#include "Keyboard.h"

void setup() {
   // open the serial port:
   Serial.begin(9600);
   // initialize control over the keyboard:
   Keyboard.begin();
}

void loop() {
   // check for incoming serial data:
   if (Serial.available() &gt; 0) {
      // read incoming serial data:
      char inChar = Serial.read();
      // Type the next ASCII value from what you received:
      Keyboard.write(inChar + 1);
   }
}
</pre>
<h2>Code to Note</h2>
<p>Once programed, open your serial monitor and send a byte. The board will reply with a keystroke, that is one number higher.</p>
<h2>Result</h2>
<p>The board will reply with a keystroke that is one number higher on Arduino IDE serial monitor when you send a byte.</p>
<h1>Arduino - Humidity Sensor</h1>
<p>In this section, we will learn how to interface our Arduino board with different sensors. We will discuss the following sensors &minus;</p>
<ul class="list">
<li>Humidity sensor (DHT22)</li>
<li>Temperature sensor (LM35)</li>
<li>Water detector sensor (Simple Water Trigger)</li>
<li>PIR SENSOR</li>
<li>ULTRASONIC SENSOR</li>
<li>GPS</li>
</ul>
<h2>Humidity Sensor (DHT22)</h2>
<p>The DHT-22 (also named as AM2302) is a digital-output, relative humidity, and temperature sensor. It uses a capacitive humidity sensor and a thermistor to measure the surrounding air, and sends a digital signal on the data pin.</p>
<p>In this example, you will learn how to use this sensor with Arduino UNO. The room temperature and humidity will be printed to the serial monitor.</p>
<h2>The DHT-22 Sensor</h2>
<img src="/arduino/images/dht22_sensor.jpg" alt="DHT-22 Sensor" />
<p>The connections are simple. The first pin on the left to 3-5V power, the second pin to the data input pin and the right-most pin to the ground.</p>
<h2>Technical Details</h2>
<ul class="list">
<li><p><b>Power</b> &minus; 3-5V</p></li>
<li><p><b>Max Current</b> &minus; 2.5mA</p></li>
<li><p><b>Humidity</b> &minus; 0-100%, 2-5% accuracy</p></li>
<li><p><b>Temperature</b> &minus; 40 to 80°C, ±0.5°C accuracy</p></li>
</ul>
<h2>Components Required</h2>
<p>You will need the following components &minus;</p>
<ul class="list">
<li>1 &times; Breadboard</li>
<li>1 &times; Arduino Uno R3</li>
<li>1 &times; DHT22</li>
<li>1 &times; 10K ohm resistor</li>
</ul>
<h2>Procedure</h2>
<p>Follow the circuit diagram and hook up the components on the breadboard as shown in the image below.</p>
<img src="/arduino/images/humidity_sensor_circuit_connection.jpg" alt="Humidity Sensor Circuit Connection" />
<p></p>
<img src="/arduino/images/humidity_sensor_breadboard.jpg" alt="Humidity Sensor Breadboard" />
<h2>Sketch</h2>
<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open a new sketch File by clicking New.</p>
<img src="/arduino/images/sketch.jpg" alt="Sketch" />
<h2>Arduino Code</h2>
<pre class="prettyprint notranslate">
// Example testing sketch for various DHT humidity/temperature sensors

#include "DHT.h"
#define DHTPIN 2 // what digital pin we're connected to
// Uncomment whatever type you're using!
//#define DHTTYPE DHT11 // DHT 11
#define DHTTYPE DHT22 // DHT 22 (AM2302), AM2321
//#define DHTTYPE DHT21 // DHT 21 (AM2301)
// Connect pin 1 (on the left) of the sensor to +5V
// NOTE: If using a board with 3.3V logic like an Arduino Due connect pin 1
// to 3.3V instead of 5V!
// Connect pin 2 of the sensor to whatever your DHTPIN is
// Connect pin 4 (on the right) of the sensor to GROUND
// Connect a 10K resistor from pin 2 (data) to pin 1 (power) of the sensor
// Initialize DHT sensor.
// Note that older versions of this library took an optional third parameter to
// tweak the timings for faster processors. This parameter is no longer needed
// as the current DHT reading algorithm adjusts itself to work on faster procs.
DHT dht(DHTPIN, DHTTYPE);

void setup() {
   Serial.begin(9600);
   Serial.println("DHTxx test!");
   dht.begin();
}

void loop() {
   delay(2000); // Wait a few seconds between measurements
   float h = dht.readHumidity();
   // Reading temperature or humidity takes about 250 milliseconds!
   float t = dht.readTemperature();
   // Read temperature as Celsius (the default)
   float f = dht.readTemperature(true);
   // Read temperature as Fahrenheit (isFahrenheit = true)
   // Check if any reads failed and exit early (to try again).
   if (isnan(h) || isnan(t) || isnan(f)) {
      Serial.println("Failed to read from DHT sensor!");
      return;
   }
   
   // Compute heat index in Fahrenheit (the default)
   float hif = dht.computeHeatIndex(f, h);
   // Compute heat index in Celsius (isFahreheit = false)
   float hic = dht.computeHeatIndex(t, h, false);
   Serial.print ("Humidity: ");
   Serial.print (h);
   Serial.print (" %\t");
   Serial.print ("Temperature: ");
   Serial.print (t);
   Serial.print (" *C ");
   Serial.print (f);
   Serial.print (" *F\t");
   Serial.print ("Heat index: ");
   Serial.print (hic);
   Serial.print (" *C ");
   Serial.print (hif);
   Serial.println (" *F");
}
</pre>
<h2>Code to Note</h2>
<p>DHT22 sensor has four terminals (V<sub>cc</sub>, DATA, NC, GND), which are connected to the board as follows &minus;</p>
<ul class="list">
<li>DATA pin to Arduino pin number 2</li>
<li>V<sub>cc</sub> pin to 5 volt of Arduino board</li>
<li>GND pin to the ground of Arduino board</li>
<li>We need to connect 10k ohm resistor (pull up resistor) between the DATA and the V<sub>cc</sub> pin</li>
</ul>
<p>Once hardware connections are done, you need to add DHT22 library to your Arduino library file as described earlier.</p>
<h2>Result</h2>
<p>You will see the temperature and humidity display on serial port monitor which is updated every 2 seconds.</p>
<h1>Arduino - Temperature Sensor</h1>
<p>The Temperature Sensor LM35 series are precision integrated-circuit temperature devices with an output voltage linearly proportional to the Centigrade temperature.</p>
<p>The LM35 device has an advantage over linear temperature sensors calibrated in Kelvin, as the user is not required to subtract a large constant voltage from the output to obtain convenient Centigrade scaling. The LM35 device does not require any external calibration or trimming to provide typical accuracies of ±¼°C at room temperature and ±¾°C over a full −55°C to 150°C temperature range.</p>
<img src="/arduino/images/lm35_device.jpg" alt="LM35 device" />
<h2>Technical Specifications</h2>
<ul class="list">
<li>Calibrated directly in Celsius (Centigrade)</li>
<li>Linear &plus; 10-mV/°C scale factor</li>
<li>0.5°C ensured accuracy (at 25°C)</li>
<li>Rated for full −55°C to 150°C range</li>
<li>Suitable for remote applications</li>
</ul>
<h2>Components Required</h2>
<p>You will need the following components &minus;</p>
<ul class="list">
<li>1 &times; Breadboard</li>
<li>1 &times; Arduino Uno R3</li>
<li>1 &times; LM35 sensor</li>
</ul>
<h2>Procedure</h2>
<p>Follow the circuit diagram and hook up the components on the breadboard as shown in the image given below.</p>
<img src="/arduino/images/temperature_sensor_circuit_connection.jpg" alt="Temperature Sensor Circuit Connection" />
<h2>Sketch</h2>
<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open a new sketch File by clicking New.</p>
<img src="/arduino/images/sketch.jpg" alt="Sketch" />
<h2>Arduino Code</h2>
<pre class="prettyprint notranslate">
float temp;
int tempPin = 0;

void setup() {
   Serial.begin(9600);
}

void loop() {
   temp = analogRead(tempPin);
   // read analog volt from sensor and save to variable temp
   temp = temp * 0.48828125;
   // convert the analog volt to its temperature equivalent
   Serial.print("TEMPERATURE = ");
   Serial.print(temp); // display temperature value
   Serial.print("*C");
   Serial.println();
   delay(1000); // update sensor reading each one second
}
</pre>
<h2>Code to Note</h2>
<p>LM35 sensor has three terminals - V<sub>s</sub>, V<sub>out</sub> and GND. We will connect the sensor as follows &minus;</p>
<ul class="list">
<li>Connect the &plus;V<sub>s</sub> to &plus;5v on your Arduino board.</li>
<li>Connect V<sub>out</sub> to Analog0 or A0 on Arduino board.</li>
<li>Connect GND with GND on Arduino.</li>
</ul>
<p>The Analog to Digital Converter (ADC) converts analog values into a digital approximation based on the formula ADC Value = sample * 1024 / reference voltage (&plus;5v). So with a &plus;5 volt reference, the digital approximation will be equal to input voltage * 205.</p>
<h2>Result</h2>
<p>You will see the temperature display on the serial port monitor which is updated every second.</p>
<h1>Arduino - Water Detector / Sensor</h1>
<p>Water sensor brick is designed for water detection, which can be widely used in sensing rainfall, water level, and even liquid leakage.</p>
<img src="/arduino/images/water_detector_sensor.jpg" alt="Water Detector / Sensor" />
<p>Connecting a water sensor to an Arduino is a great way to detect a leak, spill, flood, rain, etc. It can be used to detect the presence, the level, the volume and/or the absence of water. While this could be used to remind you to water your plants, there is a better Grove sensor for that. The sensor has an array of exposed traces, which read LOW when water is detected.</p>
<p>In this chapter, we will connect the water sensor to Digital Pin 8 on Arduino, and will enlist the very handy LED to help identify when the water sensor comes into contact with a source of water.</p>
<h2>Components Required</h2>
<p>You will need the following components &minus;</p>
<ul class="list">
<li>1 &times; Breadboard</li>
<li>1 &times; Arduino Uno R3</li>
<li>1 &times; Water Sensor</li>
<li>1 &times; led</li>
<li>1 &times; 330 ohm resistor</li>
</ul>
<h2>Procedure</h2>
<p>Follow the circuit diagram and hook up the components on the breadboard as shown in the image given below.</p>
<img src="/arduino/images/water_sensor_circuit_connection.jpg" alt="Water Sensor Circuit Connection" />
<h2>Sketch</h2>
<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open a new sketch File by clicking on New.</p>
<img src="/arduino/images/sketch.jpg" alt="Sketch" />
<h2>Arduino Code</h2>
<pre class="prettyprint notranslate">
#define Grove_Water_Sensor 8 // Attach Water sensor to Arduino Digital Pin 8
#define LED 9 // Attach an LED to Digital Pin 9 (or use onboard LED)

void setup() {
   pinMode(Grove_Water_Sensor, INPUT); // The Water Sensor is an Input
   pinMode(LED, OUTPUT); // The LED is an Output
}

void loop() {
   /* The water sensor will switch LOW when water is detected.
   Get the Arduino to illuminate the LED and activate the buzzer
   when water is detected, and switch both off when no water is present */
   if( digitalRead(Grove_Water_Sensor) == LOW) {
      digitalWrite(LED,HIGH);
   }else {
      digitalWrite(LED,LOW);
   }
}
</pre>
<h2>Code to Note</h2>
<p>Water sensor has three terminals - S, V<sub>out</sub>(&plus;), and GND (-). Connect the sensor as follows &minus;</p>
<ul class="list">
<li>Connect the &plus;V<sub>s</sub> to &plus;5v on your Arduino board.</li>
<li>Connect S to digital pin number 8 on Arduino board.</li>
<li>Connect GND with GND on Arduino.</li>
<li>Connect LED to digital pin number 9 in Arduino board.</li>
</ul>
<p>When the sensor detects water, pin 8 on Arduino becomes LOW and then the LED on Arduino is turned ON.</p>
<h2>Result</h2>
<p>You will see the indication LED turn ON when the sensor detects water.</p>
<h1>Arduino - PIR Sensor</h1>
<p>PIR sensors allow you to sense motion. They are used to detect whether a human has moved in or out of the sensor’s range. They are commonly found in appliances and gadgets used at home or for businesses. They are often referred to as PIR, "Passive Infrared", "Pyroelectric", or "IR motion" sensors.</p>
<p>Following are the advantages of PIR Sensors &minus;</p>
<ul class="list">
<li>Small in size</li>
<li>Wide lens range</li>
<li>Easy to interface</li>
<li>Inexpensive</li>
<li>Low-power</li>
<li>Easy to use</li>
<li>Do not wear out</li>
</ul>
<img src="/arduino/images/pir_sensor.jpg" alt="PIR Sensor" />
<p>PIRs are made of pyroelectric sensors, a round metal can with a rectangular crystal in the center, which can detect levels of infrared radiation. Everything emits low-level radiation, and the hotter something is, the more radiation is emitted. The sensor in a motion detector is split in two halves. This is to detect motion (change) and not average IR levels. The two halves are connected so that they cancel out each other. If one-half sees more or less IR radiation than the other, the output will swing high or low.</p>
<img src="/arduino/images/pir.jpg" alt="PIR" />
<p>PIRs have adjustable settings and have a header installed in the 3-pin ground/out/power pads.</p>
<img src="/arduino/images/pir_adjustable_settings.jpg" alt="PIR Adjustable Settings" />
<p>For many basic projects or products that need to detect when a person has left or entered the area, PIR sensors are great. Note that PIRs do not tell you the number of people around or their closeness to the sensor. The lens is often fixed to a certain sweep at a distance and they are sometimes set off by the pets in the house.</p>
<h2>Components Required</h2>
<p>You will need the following components &minus;</p>
<ul class="list">
<li>1 &times; Breadboard</li>
<li>1 &times; Arduino Uno R3</li>
<li>1 &times; PIR Sensor (MQ3)</li>
</ul>
<h2>Procedure</h2>
<p>Follow the circuit diagram and make the connections as shown in the image below.</p>
<img src="/arduino/images/pir_sensor_circuit_connection.jpg" alt="PIR Sensor Circuit Connection" />
<h2>Sketch</h2>
<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open a new sketch File by clicking New.</p>
<img src="/arduino/images/sketch.jpg" alt="Sketch" />
<h2>Arduino Code</h2>
<pre class="prettyprint notranslate">
#define pirPin 2
int calibrationTime = 30;
long unsigned int lowIn;
long unsigned int pause = 5000;
boolean lockLow = true;
boolean takeLowTime;
int PIRValue = 0;

void setup() {
   Serial.begin(9600);
   pinMode(pirPin, INPUT);
}

void loop() {
   PIRSensor();
}

void PIRSensor() {
   if(digitalRead(pirPin) == HIGH) {
      if(lockLow) {
         PIRValue = 1;
         lockLow = false;
         Serial.println("Motion detected.");
         delay(50);
      }
      takeLowTime = true;
   }
   if(digitalRead(pirPin) == LOW) {
      if(takeLowTime){
         lowIn = millis();takeLowTime = false;
      }
      if(!lockLow &amp;&amp; millis() - lowIn &gt; pause) {
         PIRValue = 0;
         lockLow = true;
         Serial.println("Motion ended.");
         delay(50);
      }
   }
}
</pre>
<h2>Code to Note</h2>
<p>PIR sensor has three terminals - V<sub>cc</sub>, OUT and GND. Connect the sensor as follows &minus;</p>
<ul class="list">
<li>Connect the &plus;V<sub>cc</sub> to &plus;5v on Arduino board.</li>
<li>Connect OUT to digital pin 2 on Arduino board.</li>
<li>Connect GND with GND on Arduino.</li>
</ul>
<p>You can adjust the sensor sensitivity and delay time via two variable resistors located at the bottom of the sensor board.</p>
<img src="/arduino/images/delay_time_adjust.jpg" alt="Delay time Adjust" />
<p>Once the sensor detects any motion, Arduino will send a message via the serial port to say that a motion is detected. The PIR sense motion will delay for certain time to check if there is a new motion. If there is no motion detected, Arduino will send a new message saying that the motion has ended.</p>
<h2>Result</h2>
<p>You will see a message on your serial port if a motion is detected and another message when the motion stops.</p>
<h1>Arduino - Ultrasonic Sensor</h1>
<p>The HC-SR04 ultrasonic sensor uses SONAR to determine the distance of an object just like the bats do. It offers excellent non-contact range detection with high accuracy and stable readings in an easy-to-use package from 2 cm to 400 cm or 1” to 13 feet.</p>
<p>The operation is not affected by sunlight or black material, although acoustically, soft materials like cloth can be difficult to detect. It comes complete with ultrasonic transmitter and receiver module.</p>
<img src="/arduino/images/ultrasonic_sensor.jpg" alt="Ultrasonic Sensor" />
<p></p>
<img src="/arduino/images/ultrasonic_sensor_radiations.jpg" alt="Ultrasonic Sensor Radiations" />
<h2>Technical Specifications</h2>
<ul class="list">
<li>Power Supply &minus; &plus;5V DC</li>
<li>Quiescent Current &minus; &lt;2mA</li>
<li>Working Current &minus; 15mA</li>
<li>Effectual Angle &minus; &lt;15°</li>
<li>Ranging Distance &minus; 2cm – 400 cm/1″ – 13ft</li>
<li>Resolution &minus; 0.3 cm</li>
<li>Measuring Angle &minus; 30 degree</li>
</ul>
<h2>Components Required</h2>
<p>You will need the following components &minus;</p>
<ul class="list">
<li>1 &times; Breadboard</li>
<li>1 &times; Arduino Uno R3</li>
<li>1 &times; ULTRASONIC Sensor (HC-SR04)</li>
</ul>
<h2>Procedure</h2>
<p>Follow the circuit diagram and make the connections as shown in the image given below.</p>
<img src="/arduino/images/ultrasonic_circuit_connection.jpg" alt="Ultrasonic Circuit Connection" />
<h2>Sketch</h2>
<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open a new sketch File by clicking New.</p>
<img src="/arduino/images/sketch.jpg" alt="Sketch" />
<h2>Arduino Code</h2>
<pre class="prettyprint notranslate">
const int pingPin = 7; // Trigger Pin of Ultrasonic Sensor
const int echoPin = 6; // Echo Pin of Ultrasonic Sensor

void setup() {
   Serial.begin(9600); // Starting Serial Terminal
}

void loop() {
   long duration, inches, cm;
   pinMode(pingPin, OUTPUT);
   digitalWrite(pingPin, LOW);
   delayMicroseconds(2);
   digitalWrite(pingPin, HIGH);
   delayMicroseconds(10);
   digitalWrite(pingPin, LOW);
   pinMode(echoPin, INPUT);
   duration = pulseIn(echoPin, HIGH);
   inches = microsecondsToInches(duration);
   cm = microsecondsToCentimeters(duration);
   Serial.print(inches);
   Serial.print("in, ");
   Serial.print(cm);
   Serial.print("cm");
   Serial.println();
   delay(100);
}

long microsecondsToInches(long microseconds) {
   return microseconds / 74 / 2;
}

long microsecondsToCentimeters(long microseconds) {
   return microseconds / 29 / 2;
}
</pre>
<h2>Code to Note</h2>
<p>The Ultrasonic sensor has four terminals - &plus;5V, Trigger, Echo, and GND connected as follows &minus;</p>
<ul class="list">
<li>Connect the &plus;5V pin to &plus;5v on your Arduino board.</li>
<li>Connect Trigger to digital pin 7 on your Arduino board.</li>
<li>Connect Echo to digital pin 6 on your Arduino board.</li>
<li>Connect GND with GND on Arduino.</li>
</ul>
<p>In our program, we have displayed the distance measured by the sensor in inches and cm via the serial port.</p>
<h2>Result</h2>
<p>You will see the distance measured by sensor in inches and cm on Arduino serial monitor.</p>
<h1>Arduino - Connecting Switch</h1>
<p>Pushbuttons or switches connect two open terminals in a circuit. This example turns on the LED on pin 2 when you press the pushbutton switch connected to pin 8.</p>
<img src="/arduino/images/connecting_switch.jpg" alt="Connecting Switch" />
<h2>Pull-down Resistor</h2>
<p>Pull-down resistors are used in electronic logic circuits to ensure that inputs to Arduino settle at expected logic levels if external devices are disconnected or are at high-impedance. As nothing is connected to an input pin, it does not mean that it is a logical zero. Pull down resistors are connected between the ground and the appropriate pin on the device.</p>
<p>An example of a pull-down resistor in a digital circuit is shown in the following figure. A pushbutton switch is connected between the supply voltage and a microcontroller pin. In such a circuit, when the switch is closed, the micro-controller input is at a logical high value, but when the switch is open, the pull-down resistor pulls the input voltage down to the ground (logical zero value), preventing an undefined state at the input.</p>
<p>The pull-down resistor must have a larger resistance than the impedance of the logic circuit, or else it might pull the voltage down too much and the input voltage at the pin would remain at a constant logical low value, regardless of the switch position.</p>
<img src="/arduino/images/pull_down_resistor.jpg" alt="Pull-down Resistor" />
<h2>Components Required</h2>
<p>You will need the following components &minus;</p>
<ul class="list">
<li>1 &times; Arduino UNO board</li>
<li>1 &times; 330 ohm resistor</li>
<li>1 &times; 4.7K ohm resistor (pull down)</li>
<li>1 &times; LED</li>
</ul>
<h2>Procedure</h2>
<p>Follow the circuit diagram and make the connections as shown in the image given below.</p>
<img src="/arduino/images/connections_of_circuit_diagram.jpg" alt="Connections of Circuit Diagram" />
<h2>Sketch</h2>
<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open a new sketch File by clicking on New.</p>
<img src="/arduino/images/sketch.jpg" alt="Sketch" />
<h2>Arduino Code</h2>
<pre class="prettyprint notranslate">
// constants won't change. They're used here to
// set pin numbers:
const int buttonPin = 8; // the number of the pushbutton pin
const int ledPin = 2; // the number of the LED pin
// variables will change:
int buttonState = 0; // variable for reading the pushbutton status

void setup() {
   // initialize the LED pin as an output:
   pinMode(ledPin, OUTPUT);
   // initialize the pushbutton pin as an input:
   pinMode(buttonPin, INPUT);
}

void loop() {
   // read the state of the pushbutton value:
   buttonState = digitalRead(buttonPin);
   // check if the pushbutton is pressed.
   // if it is, the buttonState is HIGH:
   if (buttonState == HIGH) {
      // turn LED on:
      digitalWrite(ledPin, HIGH);
   } else {
      // turn LED off:
      digitalWrite(ledPin, LOW);
   }
}
</pre>
<h2>Code to Note</h2>
<p>When the switch is open, (pushbutton is not pressed), there is no connection between the two terminals of the pushbutton, so the pin is connected to the ground (through the pull-down resistor) and we read a LOW. When the switch is closed (pushbutton is pressed), it makes a connection between its two terminals, connecting the pin to 5 volts, so that we read a HIGH.</p>
<h2>Result</h2>
<p>LED is turned ON when the pushbutton is pressed and OFF when it is released.</p>
<h1>Arduino - DC Motor</h1>
<p>In this chapter, we will interface different types of motors with the Arduino board (UNO) and show you how to connect the motor and drive it from your board.</p>
<p>There are three different type of motors &minus;</p>
<ul class="list">
<li>DC motor</li>
<li>Servo motor</li>
<li>Stepper motor</li>
</ul>
<p>A DC motor (Direct Current motor) is the most common type of motor. DC motors normally have just two leads, one positive and one negative. If you connect these two leads directly to a battery, the motor will rotate. If you switch the leads, the motor will rotate in the opposite direction.</p>
<img src="/arduino/images/dc_motor.jpg" alt="DC Motor" />
<p><b>Warning</b> &minus; Do not drive the motor directly from Arduino board pins. This may damage the board. Use a driver Circuit or an IC.</p>
<p>We will divide this chapter into three parts &minus;</p>
<ul class="list">
<li>Just make your motor spin</li>
<li>Control motor speed</li>
<li>Control the direction of the spin of DC motor</li>
</ul>
<h3>Components Required</h3>
<p>You will need the following components &minus;</p>
<ul class="list">
<li>1x Arduino UNO board</li>
<li>1x PN2222 Transistor</li>
<li>1x Small 6V DC Motor</li>
<li>1x 1N4001 diode</li>
<li>1x 270 Ω Resistor</li>
</ul>
<h3>Procedure</h3>
<p>Follow the circuit diagram and make the connections as shown in the image given below.</p>
<img src="/arduino/images/dc_motor_connections.jpg" alt="DC Motor Connections" />
<h3>Precautions</h3>
<p>Take the following precautions while making the connections.</p>
<ul class="list">
<li><p>First, make sure that the transistor is connected in the right way. The flat side of the transistor should face the Arduino board as shown in the arrangement.</p></li>
<li><p>Second, the striped end of the diode should be towards the +5V power line according to the arrangement shown in the image.</p></li>
</ul>
<h3>Spin ControlArduino Code</h3>
<pre class="prettyprint notranslate">
int motorPin = 3;

void setup() {

}

void loop() {
   digitalWrite(motorPin, HIGH);
}
</pre>
<h3>Code to Note</h3>
<p>The transistor acts like a switch, controlling the power to the motor. Arduino pin 3 is used to turn the transistor on and off and is given the name 'motorPin' in the sketch.</p>
<h3>Result</h3>
<p>Motor will spin in full speed when the Arduino pin number 3 goes high.</p>
<h2>Motor Speed Control</h2>
<p>Following is the schematic diagram of a DC motor, connected to the Arduino board.</p>
<img src="/arduino/images/motor_speed_control.jpg" alt="Motor Speed Control" />
<h3>Arduino Code</h3>
<pre class="prettyprint notranslate">
int motorPin = 9;

void setup() {
   pinMode(motorPin, OUTPUT);
   Serial.begin(9600);
   while (! Serial);
   Serial.println("Speed 0 to 255");
}

void loop() {
   if (Serial.available()) {
      int speed = Serial.parseInt();
      if (speed &gt;= 0 &amp;&amp; speed &lt;= 255) {
         analogWrite(motorPin, speed);
      }
   }
}
</pre>
<h3>Code to Note</h3>
<p>The transistor acts like a switch, controlling the power of the motor. Arduino pin 3 is used to turn the transistor on and off and is given the name 'motorPin' in the sketch.</p>
<p>When the program starts, it prompts you to give the values to control the speed of the motor. You need to enter a value between 0 and 255 in the Serial Monitor.</p>
<img src="/arduino/images/command_window.jpg" alt="Command Window" />
<p>In the 'loop' function, the command 'Serial.parseInt' is used to read the number entered as text in the Serial Monitor and convert it into an 'int'. You can type any number here. The 'if' statement in the next line simply does an analog write with this number, if the number is between 0 and 255.</p>
<h3>Result</h3>
<p>The DC motor will spin with different speeds according to the value (0 to 250) received via the serial port.</p>
<h2>Spin Direction Control</h2>
<p>To control the direction of the spin of DC motor, without interchanging the leads, you can use a circuit called an <b>H-Bridge</b>. An H-bridge is an electronic circuit that can drive the motor in both directions. H-bridges are used in many different applications. One of the most common application is to control motors in robots. It is called an H-bridge because it uses four transistors connected in such a way that the schematic diagram looks like an "H."</p>
<p>We will be using the L298 H-Bridge IC here. The L298 can control the speed and direction of DC motors and stepper motors, and can control two motors simultaneously. Its current rating is 2A for each motor. At these currents, however, you will need to use heat sinks.</p>
<img src="/arduino/images/spin_direction_control.jpg" alt="Spin Direction Control" />
<h3>Components Required</h3>
<p>You will need the following components &minus;</p>
<ul class="list">
<li>1 &times; L298 bridge IC</li>
<li>1 &times; DC motor</li>
<li>1 &times; Arduino UNO</li>
<li>1 &times; breadboard</li>
<li>10 &times; jumper wires</li>
</ul>
<h3>Procedure</h3>
<p>Following is the schematic diagram of the DC motor interface to Arduino Uno board.</p>
<img src="/arduino/images/spin_direction_control_connections.jpg" alt="Spin Direction Control Connections" />
<p>The above diagram shows how to connect the L298 IC to control two motors. There are three input pins for each motor, Input1 (IN1), Input2 (IN2), and Enable1 (EN1) for Motor1 and Input3, Input4, and Enable2 for Motor2.</p>
<p>Since we will be controlling only one motor in this example, we will connect the Arduino to IN1 (pin 5), IN2 (pin 7), and Enable1 (pin 6) of the L298 IC. Pins 5 and 7 are digital, i.e. ON or OFF inputs, while pin 6 needs a pulse-width modulated (PWM) signal to control the motor speed.</p>
<p>The following table shows which direction the motor will turn based on the digital values of IN1 and IN2.</p>
<table class="table table-bordered" style="text-align:center;">
<tr>
<th style="text-align:center;">IN1</th>
<th style="text-align:center;">IN2</th>
<th style="text-align:center;">Motor Behavior</th>
</tr>
<tr>
<td></td>
<td></td>
<td>BRAKE</td>
</tr>
<tr>
<td>1</td>
<td></td>
<td>FORWARD</td>
</tr>
<tr>
<td></td>
<td>1</td>
<td>BACKWARD</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>BRAKE</td>
</tr>
</table>
<p>Pin IN1 of the IC L298 is connected to pin 8 of Arduino while IN2 is connected to pin 9. These two digital pins of Arduino control the direction of the motor. The EN A pin of IC is connected to the PWM pin 2 of Arduino. This will control the speed of the motor.</p>
<p>To set the values of Arduino pins 8 and 9, we have used the digitalWrite() function, and to set the value of pin 2, we have to use the analogWrite() function.</p>
<h3>Connection Steps</h3>
<ul class="list">
<li>Connect 5V and the ground of the IC to 5V and the ground of Arduino, respectively.</li>
<li>Connect the motor to pins 2 and 3 of the IC.</li>
<li>Connect IN1 of the IC to pin 8 of Arduino.</li>
<li>Connect IN2 of the IC to pin 9 of Arduino.</li>
<li>Connect EN1 of IC to pin 2 of Arduino.</li>
<li>Connect SENS A pin of IC to the ground.</li>
<li>Connect Arduino using Arduino USB cable and upload the program to Arduino using Arduino IDE software.</li>
<li>Provide power to Arduino board using power supply, battery, or USB cable.</li>
</ul>
<h3>Arduino Code</h3>
<pre class="prettyprint notranslate">
const int pwm = 2 ; //initializing pin 2 as pwm
const int in_1 = 8 ;
const int in_2 = 9 ;
//For providing logic to L298 IC to choose the direction of the DC motor

void setup() {
   pinMode(pwm,OUTPUT) ; //we have to set PWM pin as output
   pinMode(in_1,OUTPUT) ; //Logic pins are also set as output
   pinMode(in_2,OUTPUT) ;
}

void loop() {
   //For Clock wise motion , in_1 = High , in_2 = Low
   digitalWrite(in_1,HIGH) ;
   digitalWrite(in_2,LOW) ;
   analogWrite(pwm,255) ;
   /* setting pwm of the motor to 255 we can change the speed of rotation
   by changing pwm input but we are only using arduino so we are using highest
   value to driver the motor */
   //Clockwise for 3 secs
   delay(3000) ;
   //For brake
   digitalWrite(in_1,HIGH) ;
   digitalWrite(in_2,HIGH) ;
   delay(1000) ;
   //For Anti Clock-wise motion - IN_1 = LOW , IN_2 = HIGH
   digitalWrite(in_1,LOW) ;
   digitalWrite(in_2,HIGH) ;
   delay(3000) ;
   //For brake
   digitalWrite(in_1,HIGH) ;
   digitalWrite(in_2,HIGH) ;
   delay(1000) ;
}
</pre>
<h3>Result</h3>
<p>The motor will run first in the clockwise (CW) direction for 3 seconds and then counter-clockwise (CCW) for 3 seconds.</p>
<h1>Arduino - Servo Motor</h1>
<p>A Servo Motor is a small device that has an output shaft. This shaft can be positioned to specific angular positions by sending the servo a coded signal. As long as the coded signal exists on the input line, the servo will maintain the angular position of the shaft. If the coded signal changes, the angular position of the shaft changes. In practice, servos are used in radio-controlled airplanes to position control surfaces like the elevators and rudders. They are also used in radio-controlled cars, puppets, and of course, robots.</p>
<img src="/arduino/images/servo_motor.jpg" alt="Servo Motor" />
<p>Servos are extremely useful in robotics. The motors are small, have built-in control circuitry, and are extremely powerful for their size. A standard servo such as the Futaba S-148 has 42 oz/inches of torque, which is strong for its size. It also draws power proportional to the mechanical load. A lightly loaded servo, therefore, does not consume much energy.</p>
<p>The guts of a servo motor is shown in the following picture. You can see the control circuitry, the motor, a set of gears, and the case. You can also see the 3 wires that connect to the outside world. One is for power (+5volts), ground, and the white wire is the control wire.</p>
<img src="/arduino/images/servo_motor_control_circuitry.jpg" alt="Servo Motor control circuitry" />
<h2>Working of a Servo Motor</h2>
<p>The servo motor has some control circuits and a potentiometer (a variable resistor, aka pot) connected to the output shaft. In the picture above, the pot can be seen on the right side of the circuit board. This pot allows the control circuitry to monitor the current angle of the servo motor.</p>
<p>If the shaft is at the correct angle, then the motor shuts off. If the circuit finds that the angle is not correct, it will turn the motor until it is at a desired angle. The output shaft of the servo is capable of traveling somewhere around 180 degrees. Usually, it is somewhere in the 210-degree range, however, it varies depending on the manufacturer. A normal servo is used to control an angular motion of 0 to 180 degrees. It is mechanically not capable of turning any farther due to a mechanical stop built on to the main output gear.</p>
<p>The power applied to the motor is proportional to the distance it needs to travel. So, if the shaft needs to turn a large distance, the motor will run at full speed. If it needs to turn only a small amount, the motor will run at a slower speed. This is called <b>proportional control</b>.</p>
<h2>How Do You Communicate the Angle at Which the Servo Should Turn?</h2>
<p>The control wire is used to communicate the angle. The angle is determined by the duration of a pulse that is applied to the control wire. This is called <b>Pulse Coded Modulation</b>. The servo expects to see a pulse every 20 milliseconds (.02 seconds). The length of the pulse will determine how far the motor turns. A 1.5 millisecond pulse, for example, will make the motor turn to the 90-degree position (often called as the neutral position). If the pulse is shorter than 1.5 milliseconds, then the motor will turn the shaft closer to 0 degrees. If the pulse is longer than 1.5 milliseconds, the shaft turns closer to 180 degrees.</p>
<img src="/arduino/images/angle_turn.jpg" alt="Angle Turn" />
<h2>Components Required</h2>
<p>You will need the following components &minus;</p>
<ul class="list">
<li>1 &times; Arduino UNO board</li>
<li>1 &times; Servo Motor</li>
<li>1 &times; ULN2003 driving IC</li>
<li>1 &times; 10 KΩ Resistor</li>
</ul>
<h2>Procedure</h2>
<p>Follow the circuit diagram and make the connections as shown in the image given below.</p>
<img src="/arduino/images/servo_motor_connections.jpg" alt="Servo Motor Connections" />
<h2>Sketch</h2>
<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open a new sketch File by clicking on New.</p>
<img src="/arduino/images/sketch.jpg" alt="Sketch" />
<h2>Arduino Code</h2>
<pre class="prettyprint notranslate">
/* Controlling a servo position using a potentiometer (variable resistor) */

#include &lt;Servo.h&gt;
   Servo myservo; // create servo object to control a servo
   int potpin = 0; // analog pin used to connect the potentiometer
   int val; // variable to read the value from the analog pin

void setup() {
   myservo.attach(9); // attaches the servo on pin 9 to the servo object
}

void loop() {
   val = analogRead(potpin);
   // reads the value of the potentiometer (value between 0 and 1023)
   val = map(val, 0, 1023, 0, 180);
   // scale it to use it with the servo (value between 0 and 180)
   myservo.write(val); // sets the servo position according to the scaled value
   delay(15);
}
</pre>
<h2>Code to Note</h2>
<p>Servo motors have three terminals - power, ground, and signal. The power wire is typically red, and should be connected to the 5V pin on the Arduino. The ground wire is typically black or brown and should be connected to one terminal of ULN2003 IC (10 -16). To protect your Arduino board from damage, you will need some driver IC to do that. Here we have used ULN2003 IC to drive the servo motor. The signal pin is typically yellow or orange and should be connected to Arduino pin number 9.</p>
<h2>Connecting the Potentiometer</h2>
<p>A voltage divider/potential divider are resistors in a series circuit that scale the output voltage to a particular ratio of the input voltage applied. Following is the circuit diagram &minus;</p>
<img src="/arduino/images/connecting_potentiometer.jpg" alt="Connecting Potentiometer" />
<p>$$V_{out} = (V_{in} \times R_{2})/ (R_{1} + R_{2})$$</p>
<p>V<sub>out</sub> is the output potential, which depends on the applied input voltage (V<sub>in</sub>) and resistors (R<sub>1</sub> and R<sub>2</sub>) in the series. It means that the current flowing through R<sub>1</sub> will also flow through R<sub>2</sub> without being divided. In the above equation, as the value of R<sub>2</sub> changes, the V<sub>out</sub> scales accordingly with respect to the input voltage, V<sub>in</sub>.</p>
<p>Typically, a potentiometer is a potential divider, which can scale the output voltage of the circuit based on the value of the variable resistor, which is scaled using the knob. It has three pins: GND, Signal, and +5V as shown in the diagram below &minus;</p>
<img src="/arduino/images/potentiometer_with_description.jpg" alt="Potentiometer with Description" />
<h2>Result</h2>
<p>By changing the pot’s NOP position, servo motor will change its angle.</p>
<h1>Arduino - Stepper Motor</h1>
<p>A Stepper Motor or a step motor is a brushless, synchronous motor, which divides a full rotation into a number of steps. Unlike a brushless DC motor, which rotates continuously when a fixed DC voltage is applied to it, a step motor rotates in discrete step angles.</p>
<p>The Stepper Motors therefore are manufactured with steps per revolution of 12, 24, 72, 144, 180, and 200, resulting in stepping angles of 30, 15, 5, 2.5, 2, and 1.8 degrees per step. The stepper motor can be controlled with or without feedback.</p>
<p>Imagine a motor on an RC airplane. The motor spins very fast in one direction or another. You can vary the speed with the amount of power given to the motor, but you cannot tell the propeller to stop at a specific position.</p>
<p>Now imagine a printer. There are lots of moving parts inside a printer, including motors. One such motor acts as the paper feed, spinning rollers that move the piece of paper as ink is being printed on it. This motor needs to be able to move the paper an exact distance to be able to print the next line of text or the next line of an image.</p>
<p>There is another motor attached to a threaded rod that moves the print head back and forth. Again, that threaded rod needs to be moved an exact amount to print one letter after another. This is where the stepper motors come in handy.</p>
<img src="/arduino/images/stepper_motor.jpg" alt="Stepper Motor" />
<h2>How a Stepper Motor Works?</h2>
<p>A regular DC motor spins in only direction whereas a Stepper motor can spin in precise increments.</p>
<p>Stepper motors can turn an exact amount of degrees (or steps) as desired. This gives you total control over the motor, allowing you to move it to an exact location and hold that position. It does so by powering the coils inside the motor for very short periods of time. The disadvantage is that you have to power the motor all the time to keep it in the position that you desire.</p>
<p>All you need to know for now is that, to move a stepper motor, you tell it to move a certain number of steps in one direction or the other, and tell it the speed at which to step in that direction. There are numerous varieties of stepper motors. The methods described here can be used to infer how to use other motors and drivers which are not mentioned in this tutorial. However, it is always recommended that you consult the datasheets and guides of the motors and drivers specific to the models you have.</p>
<img src="/arduino/images/inner_stepper_motor.jpg" alt="Inner Stepper Motor" />
<h2>Components Required</h2>
<p>You will need the following components &minus;</p>
<ul class="list">
<li>1 &times; Arduino UNO board</li>
<li>1 &times; small bipolar stepper Motor as shown in the image given below</li>
<li>1 &times; LM298 driving IC</li>
</ul>
<img src="/arduino/images/lm298_driving_ic.jpg" alt="LM298 driving IC" />
<h2>Procedure</h2>
<p>Follow the circuit diagram and make the connections as shown in the image given below.</p>
<img src="/arduino/images/stepper_motor_connections.jpg" alt="Stepper Motor Connections" />
<h2>Sketch</h2>
<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open a new sketch File by clicking New.</p>
<img src="/arduino/images/sketch.jpg" alt="Sketch" />
<h2>Arduino Code</h2>
<pre class="prettyprint notranslate">
/* Stepper Motor Control */

#include &lt;Stepper.h&gt;
const int stepsPerRevolution = 90;
// change this to fit the number of steps per revolution
// for your motor
// initialize the stepper library on pins 8 through 11:
Stepper myStepper(stepsPerRevolution, 8, 9, 10, 11);

void setup() {
   // set the speed at 60 rpm:
   myStepper.setSpeed(5);
   // initialize the serial port:
   Serial.begin(9600);
}

void loop() {
   // step one revolution in one direction:
   Serial.println("clockwise");
   myStepper.step(stepsPerRevolution);
   delay(500);
   // step one revolution in the other direction:
   Serial.println("counterclockwise");
   myStepper.step(-stepsPerRevolution);
   delay(500);
}
</pre>
<h2>Code to Note</h2>
<p>This program drives a unipolar or bipolar stepper motor. The motor is attached to digital pins 8 - 11 of Arduino.</p>
<h2>Result</h2>
<p>The motor will take one revolution in one direction, then one revolution in the other direction.</p>
<h1>Arduino - Tone Library</h1>
<p>In this chapter, we will use the Arduino Tone Library. It is nothing but an Arduino Library, which produces square-wave of a specified frequency (and 50% duty cycle) on any Arduino pin. A duration can optionally be specified, otherwise the wave continues until the stop() function is called. The pin can be connected to a piezo buzzer or a speaker to play the tones.</p>
<p><b>Warning</b> &minus; Do not connect the pin directly to any audio input. The voltage is considerably higher than the standard line level voltages, and can damage sound card inputs, etc. You can use a voltage divider to bring the voltage down.</p>
<h2>Components Required</h2>
<p>You will need the following components &minus;</p>
<ul class="list">
<li>1 &times; 8-ohm speaker</li>
<li>1 &times; 1k resistor</li>
<li>1 &times; Arduino UNO board</li>
</ul>
<h2>Procedure</h2>
<p>Follow the circuit diagram and make the connections as shown in the image given below.</p>
<img src="/arduino/images/tone_library_connections.jpg" alt="Tone Library Connections" />
<h2>Sketch</h2>
<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open a new sketch File by clicking New.</p>
<img src="/arduino/images/sketch.jpg" alt="Sketch" />
<p>To make the pitches.h file, either click the button just below the serial monitor icon and choose "New Tab", or use Ctrl+Shift+N.</p>
<img src="/arduino/images/new_tab.jpg" alt="New Tab" />
<p>Then paste the following code &minus;</p>
<pre class="prettyprint notranslate">
/*************************************************
* Public Constants
*************************************************/

#define NOTE_B0 31
#define NOTE_C1 33
#define NOTE_CS1 35
#define NOTE_D1 37
#define NOTE_DS1 39
#define NOTE_E1 41
#define NOTE_F1 44
#define NOTE_FS1 46
#define NOTE_G1 49
#define NOTE_GS1 52
#define NOTE_A1 55
#define NOTE_AS1 58
#define NOTE_B1 62
#define NOTE_C2 65
#define NOTE_CS2 69
#define NOTE_D2 73
#define NOTE_DS2 78
#define NOTE_E2 82
#define NOTE_F2 87
#define NOTE_FS2 93
#define NOTE_G2 98
#define NOTE_GS2 104
#define NOTE_A2 110
#define NOTE_AS2 117
#define NOTE_B2 123
#define NOTE_C3 131
#define NOTE_CS3 139
#define NOTE_D3 147
#define NOTE_DS3 156
#define NOTE_E3 165
#define NOTE_F3 175
#define NOTE_FS3 185
#define NOTE_G3 196
#define NOTE_GS3 208
#define NOTE_A3 220
#define NOTE_AS3 233
#define NOTE_B3 247
#define NOTE_C4 262
#define NOTE_CS4 277
#define NOTE_D4 294
#define NOTE_DS4 311
#define NOTE_E4 330
#define NOTE_F4 349
#define NOTE_FS4 370
#define NOTE_G4 392
#define NOTE_GS4 415
#define NOTE_A4 440
#define NOTE_AS4 466
#define NOTE_B4 494
#define NOTE_C5 523
#define NOTE_CS5 554
#define NOTE_D5 587
#define NOTE_DS5 622
#define NOTE_E5 659
#define NOTE_F5 698
#define NOTE_FS5 740
#define NOTE_G5 784
#define NOTE_GS5 831
#define NOTE_A5 880
#define NOTE_AS5 932
#define NOTE_B5 988
#define NOTE_C6 1047
#define NOTE_CS6 1109
#define NOTE_D6 1175
#define NOTE_DS6 1245
#define NOTE_E6 1319
#define NOTE_F6 1397
#define NOTE_FS6 1480
#define NOTE_G6 1568
#define NOTE_GS6 1661
#define NOTE_A6 1760
#define NOTE_AS6 1865
#define NOTE_B6 1976
#define NOTE_C7 2093
#define NOTE_CS7 2217
#define NOTE_D7 2349
#define NOTE_DS7 2489
#define NOTE_E7 2637
#define NOTE_F7 2794
#define NOTE_FS7 2960
#define NOTE_G7 3136
#define NOTE_GS7 3322
#define NOTE_A7 3520
#define NOTE_AS7 3729
#define NOTE_B7 3951
#define NOTE_C8 4186
#define NOTE_CS8 4435
#define NOTE_D8 4699
#define NOTE_DS8 4978
</pre>
<p>Save the above given code as <b>pitches.h</b></p>
<h2>Arduino Code</h2>
<pre class="prettyprint notranslate">
#include "pitches.h"
// notes in the melody:
int melody[] = {
NOTE_C4, NOTE_G3,NOTE_G3, NOTE_GS3, NOTE_G3,0, NOTE_B3, NOTE_C4};
// note durations: 4 = quarter note, 8 = eighth note, etc.:

int noteDurations[] = {
   4, 8, 8, 4,4,4,4,4 
};

void setup() {
   // iterate over the notes of the melody:
   for (int thisNote = 0; thisNote &lt; 8; thisNote++) {
      // to calculate the note duration, take one second
      // divided by the note type.
      //e.g. quarter note = 1000 / 4, eighth note = 1000/8, etc.
      int noteDuration = 1000/noteDurations[thisNote];
      tone(8, melody[thisNote],noteDuration);
      //pause for the note's duration plus 30 ms:
      delay(noteDuration +30);
   }
}

void loop() {
   // no need to repeat the melody.
}
</pre>
<h2>Code to Note</h2>
<p>The code uses an extra file, pitches.h. This file contains all the pitch values for typical notes. For example, NOTE_C4 is middle C. NOTE_FS4 is F sharp, and so forth. This note table was originally written by Brett Hagman, on whose work the tone() command was based. You may find it useful whenever you want to make musical notes.</p>
<h2>Result</h2>
<p>You will hear musical notes saved in the pitches.h. file.</p>
<h1>Arduino - Wireless Communication</h1>
<p>The wireless transmitter and receiver modules work at 315 Mhz. They can easily fit into a breadboard and work well with microcontrollers to create a very simple wireless data link. With one pair of transmitter and receiver, the modules will only work communicating data one-way, however, you would need two pairs (of different frequencies) to act as a transmitter/receiver pair.</p>
<p><b>Note</b> &minus; These modules are indiscriminate and receive a fair amount of noise. Both the transmitter and receiver work at common frequencies and do not have IDs.</p>
<img src="/arduino/images/wireless_communication.jpg" alt="Wireless Communication" />
<h2>Receiver Module Specifications</h2>
<ul class="list">
<li>Product Model &minus; MX-05V</li>
<li>Operating voltage &minus; DC5V</li>
<li>Quiescent Current &minus; 4mA</li>
<li>Receiving frequency &minus; 315Mhz</li>
<li>Receiver sensitivity &minus; -105DB</li>
<li>Size &minus; 30 * 14 * 7mm</li>
</ul>
<h2>Transmitter Module Specifications</h2>
<ul class="list">
<li>Product Model &minus; MX-FS-03V</li>
<li>Launch distance &minus; 20-200 meters (different voltage, different results)</li>
<li>Operating voltage &minus; 3.5-12V</li>
<li>Dimensions &minus; 19 * 19mm</li>
<li>Operating mode &minus; AM</li>
<li>Transfer rate &minus; 4KB / S</li>
<li>Transmitting power &minus; 10mW</li>
<li>Transmitting frequency &minus; 315Mhz</li>
<li>An external antenna &minus; 25cm ordinary multi-core or single-core line</li>
<li>Pinout from left &rarr; right &minus; (DATA; V<sub>CC</sub>; GND)</li>
</ul>
<h2>Components Required</h2>
<p>You will need the following components &minus;</p>
<ul class="list">
<li>2 &times; Arduino UNO board</li>
<li>1 &times; Rf link transmitter</li>
<li>1 &times; Rf link receiver</li>
</ul>
<h2>Procedure</h2>
<p>Follow the circuit diagram and make the connections as shown in the image given below.</p>
<img src="/arduino/images/wireless_communication_connections.jpg" alt="Wireless Communication Connections" />
<h2>Sketch</h2>
<p>Open the Arduino IDE software on your computer. Coding in the Arduino language will control your circuit. Open a new sketch File by clicking New.</p>
<img src="/arduino/images/sketch.jpg" alt="Sketch" />
<p><b>Note</b> &minus; You must include the keypad library in your Arduino library file. Copy and paste the VirtualWire.lib file in the libraries folder as highlighted in the screenshot given below.</p>
<img src="/arduino/images/arduino_library_file.jpg" alt="Arduino library file" />
<h2>Arduino Code for Transmitter</h2>
<pre class="prettyprint notranslate">
//simple Tx on pin D12
#include &lt;VirtualWire.h&gt;
char *controller;

void setup() {
   pinMode(13,OUTPUT);
   vw_set_ptt_inverted(true);
   vw_set_tx_pin(12);
   vw_setup(4000);// speed of data transfer Kbps
}

void loop() {
   controller="1" ;
   vw_send((uint8_t *)controller, strlen(controller));
   vw_wait_tx(); // Wait until the whole message is gone
   digitalWrite(13,1);
   delay(2000);
   controller="0" ;
   vw_send((uint8_t *)controller, strlen(controller));
   vw_wait_tx(); // Wait until the whole message is gone
   digitalWrite(13,0);
   delay(2000);
}
</pre>
<h2>Code to Note</h2>
<p>This is a simple code. First, it will send character '1' and after two seconds it will send character '0' and so on.</p>
<h2>Arduino Code for Receiver</h2>
<pre class="prettyprint notranslate">
//simple Rx on pin D12
#include &lt;VirtualWire.h&gt;

void setup() {
   vw_set_ptt_inverted(true); // Required for DR3100
   vw_set_rx_pin(12);
   vw_setup(4000); // Bits per sec
   pinMode(5, OUTPUT);
   vw_rx_start(); // Start the receiver PLL running
}

void loop() {
   uint8_t buf[VW_MAX_MESSAGE_LEN];
   uint8_t buflen = VW_MAX_MESSAGE_LEN;
   if (vw_get_message(buf, &amp;buflen)) // Non-blocking {
      if(buf[0]=='1') {
         digitalWrite(5,1);
      }
      if(buf[0]=='0') {
         digitalWrite(5,0);
      }
   }
}
</pre>
<h2>Code to Note</h2>
<p>The LED connected to pin number 5 on the Arduino board is turned ON when character '1' is received and turned OFF when character '0' received.</p>
<h1>Arduino - Network Communication</h1>
<p>The CC3000 WiFi module from Texas Instruments is a small silver package, which finally brings easy-to-use, affordable WiFi functionality to your Arduino projects.</p>
<p>It uses SPI for communication (not UART!) so you can push data as fast as you want or as slow as you want. It has a proper interrupt system with IRQ pin so you can have asynchronous connections. It supports 802.11b/g, open/WEP/WPA/WPA2 security, TKIP & AES. A built-in TCP/IP stack with a "BSD socket" interface supports TCP and UDP in both the client and the server mode.</p>
<img src="/arduino/images/network_communication.jpg" alt="Network Communication" />
<h2>Components Required</h2>
<p>You will need the following components &minus;</p>
<ul class="list">
<li>1 &times; Arduino Uno</li>
<li>1 &times; Adafruit CC3000 breakout board</li>
<li>1 &times; 5V relay</li>
<li>1 &times; Rectifier diode</li>
<li>1 &times; LED</li>
<li>1 &times; 220 Ohm resistor</li>
<li>1 &times; Breadboard and some jumper wires</li>
</ul>
<p>For this project, you just need the usual Arduino IDE, the Adafruit’s CC3000 library, and the CC3000 MDNS library. We are also going to use the aREST library to send commands to the relay via WiFi.</p>
<h2>Procedure</h2>
<p>Follow the circuit diagram and make the connections as shown in the image given below.</p>
<img src="/arduino/images/network_communication_connections.jpg" alt="Network Communication Connections" />
<p>The hardware configuration for this project is very easy.</p>
<ul class="list">
<li>Connect the IRQ pin of the CC3000 board to pin number 3 of the Arduino board.</li>
<li>VBAT to pin 5, and CS to pin 10.</li>
<li>Connect the SPI pins to Arduino board: MOSI, MISO, and CLK to pins 11, 12, and 13, respectively.</li>
<li>V<sub>in</sub> is connected to Arduino 5V, and GND to GND.</li>
</ul>
<p>Let us now connect the relay.</p>
<p>After placing the relay on the breadboard, you can start identifying the two important parts on your relay: the coil part which commands the relay, and the switch part where we will attach the LED.</p>
<ul class="list">
<li>First, connect pin number 8 of Arduino board to one pin of the coil.</li>
<li>Connect the other pin to the ground of Arduino board.</li>
</ul>
<p>You also have to place the rectifier diode (anode connected to the ground pin) over the pins of the coil to protect your circuit when the relay is switching.</p>
<ul class="list">
<li><p>Connect the +5V of Arduino board to the common pin of the relay’s switch.</p></li>
<li><p>Finally, connect one of the other pin of the switch (usually, the one which is not connected when the relay is off) to the LED in series with the 220 Ohm resistor, and connect the other side of the LED to the ground of Arduino board.</p></li>
</ul>
<h2>Testing Individual Components</h2>
<p>You can test the relay with the following sketch &minus;</p>
<pre class="prettyprint notranslate">
const int relay_pin = 8; // Relay pin

void setup() {
   Serial.begin(9600);
   pinMode(relay_pin,OUTPUT);
}

void loop() {
   // Activate relay
   digitalWrite(relay_pin, HIGH);
   // Wait for 1 second
   delay(1000);
   // Deactivate relay
   digitalWrite(relay_pin, LOW);
   // Wait for 1 second
   delay(1000);
}
</pre>
<h2>Code to Note</h2>
<p>The code is self-explanatory. You can just upload it to the board and the relay will switch states every second, and the LED will switch ON and OFF accordingly.</p>
<h2>Adding WiFi Connectivity</h2>
<p>Let us now control the relay wirelessly using the CC3000 WiFi chip. The software for this project is based on the TCP protocol. However, for this project, Arduino board will be running a small web server, so we can “listen” for commands coming from the computer. We will first take care of Arduino sketch, and then we will see how to write the server-side code and create a nice interface.</p>
<p>First, the Arduino sketch. The goal here is to connect to your WiFi network, create a web server, check if there are incoming TCP connections, and then change the state of the relay accordingly.</p>
<h2>Important Parts of the Code</h2>
<pre class="prettyprint notranslate">
#include &lt;Adafruit_CC3000.h&gt;
#include &lt;SPI.h&gt;
#include &lt;CC3000_MDNS.h&gt;
#include &lt;Ethernet.h&gt;
#include &lt;aREST.h&gt;
</pre>
<p>You need to define inside the code what is specific to your configuration, i.e. Wi-Fi name and password, and the port for TCP communications (we have used 80 here).</p>
<pre class="prettyprint notranslate">
// WiFi network (change with your settings!)
   #define WLAN_SSID "yourNetwork" // cannot be longer than 32 characters!
   #define WLAN_PASS "yourPassword"
   #define WLAN_SECURITY WLAN_SEC_WPA2 // This can be WLAN_SEC_UNSEC, WLAN_SEC_WEP, 
   // WLAN_SEC_WPA or WLAN_SEC_WPA2

// The port to listen for incoming TCP connections
   #define LISTEN_PORT 80
</pre>
<p>We can then create the CC3000 instance, server and aREST instance &minus;</p>
<pre class="prettyprint notranslate">
// Server instance
   Adafruit_CC3000_Server restServer(LISTEN_PORT); // DNS responder instance
   MDNSResponder mdns; // Create aREST instance
   aREST rest = aREST();
</pre>
<p>In the setup() part of the sketch, we can now connect the CC3000 chip to the network &minus;</p>
<pre class="result notranslate">
cc3000.connectToAP(WLAN_SSID, WLAN_PASS, WLAN_SECURITY);
</pre>
<p>How will the computer know where to send the data? One way would be to run the sketch once, then get the IP address of the CC3000 board, and modify the server code again. However, we can do better, and that is where the CC3000 MDNS library comes into play. We will assign a fixed name to our CC3000 board with this library, so we can write down this name directly into the server code.</p>
<p>This is done with the following piece of code &minus;</p>
<pre class="prettyprint notranslate">
if (!mdns.begin("arduino", cc3000)) {
   while(1);
}
</pre>
<p>We also need to listen for incoming connections.</p>
<pre class="result notranslate">
restServer.begin();
</pre>
<p>Next, we will code the loop() function of the sketch that will be continuously executed. We first have to update the mDNS server.</p>
<pre class="result notranslate">
mdns.update();
</pre>
<p>The server running on Arduino board will wait for the incoming connections and handle the requests.</p>
<pre class="result notranslate">
Adafruit_CC3000_ClientRef client = restServer.available();
rest.handle(client);
</pre>
<p>It is now quite easy to test the projects via WiFi. Make sure you updated the sketch with your own WiFi name and password, and upload the sketch to your Arduino board. Open your Arduino IDE serial monitor, and look for the IP address of your board.</p>
<p>Let us assume for the rest here that it is something like 192.168.1.103.</p>
<p>Then, simply go to your favorite web browser, and type &minus;</p>
<p>192.168.1.103/digital/8/1</p>
<p>You should see that your relay automatically turns ON.</p>
<h2>Building the Relay Interface</h2>
<p>We will now code the interface of the project. There will be two parts here: an HTML file containing the interface, and a client-side Javascript file to handle the clicks on the interface. The interface here is based on the <b>aREST.js</b> project, which was made to easily control WiFi devices from your computer.</p>
<p>Let us first see the HTML file, called interface.html. The first part consists importing all the required libraries for the interface &minus;</p>
<pre class="prettyprint notranslate">
&lt;head&gt;
   &lt;meta charset = utf-8 /&gt;
   &lt;title&gt; Relay Control &lt;/title&gt;
   &lt;link rel = "stylesheet" type = "text/css" 
      href = "https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css"&gt;
   &lt;link rel="stylesheet" type = "text/css" href = "style.css"&gt;
   &lt;script type = "text/javascript" 
      src = "https://code.jquery.com/jquery-2.1.4.min.js"&gt;&lt;/script&gt;
   &lt;script type = "text/javascript" 
      src = "https://cdn.rawgit.com/Foliotek/AjaxQ/master/ajaxq.js"&gt;&lt;/script&gt;
   &lt;script type = "text/javascript" 
      src = "https://cdn.rawgit.com/marcoschwartz/aREST.js/master/aREST.js"&gt;&lt;/script&gt;
   &lt;script type = "text/javascript" 
      src = "script.js"&gt;&lt;/script&gt;
&lt;/head&gt;
</pre>
<p>Then, we define two buttons inside the interface, one to turn the relay on, and the other to turn it off again.</p>
<pre class="prettyprint notranslate">
&lt;div class = 'container'&gt;
   &lt;h1&gt;Relay Control&lt;/h1&gt;
   &lt;div class = 'row'&gt;
      &lt;div class = "col-md-1"&gt;Relay&lt;/div&gt;
      &lt;div class = "col-md-2"&gt;
         &lt;button id = 'on' class = 'btn btn-block btn-success'&gt;On&lt;/button&gt;
      &lt;/div&gt;
      &lt;div class = "col-md-2"&gt;
         &lt;button id = 'off' class = 'btn btn-block btn-danger'&gt;On&lt;/button&gt;
      &lt;/div&gt;
   &lt;/div&gt;
&lt;/div&gt;
</pre>
<p>Now, we also need a client-side Javascript file to handle the clicks on the buttons. We will also create a device that we will link to the mDNS name of our Arduino device. If you changed this in Arduino code, you will need to modify it here as well.</p>
<pre class="prettyprint notranslate">
// Create device
var device = new Device("arduino.local");
// Button

$('#on').click(function() {
   device.digitalWrite(8, 1);
});

$('#off').click(function() {
   device.digitalWrite(8, 0);
});
</pre>

<title>Arduino Useful Resources</title>

<h1>Arduino - Useful Resources</h1>

<p>The following resources contain additional information on Arduino. Please use them to get more in-depth knowledge on this.</p>

<h2>Useful Links on Arduino</h2>

<p><a rel="nofollow" target="_blank" href="https://en.wikipedia.org/wiki/Arduino">Arduino Wiki</a> &minus; Wikipedia Reference for Arduino.</p>

<h2>Useful Books on Arduino</h2>

<p>To enlist your site on this page, please drop an email to <b>contact@tutorialspoint.com</b></p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

<title>Discuss Arduino</title>

<h1>Discuss Arduino</h1>

<p>Arduino is a prototype platform (open-source) based on an easy-to-use hardware and software. It consists of a circuit board, which can be programed (referred to as a microcontroller) and a ready-made software called Arduino IDE (Integrated Development Environment), which is used to write and upload the computer code to the physical board.</p>

<p>Arduino provides a standard form factor that breaks the functions of the micro-controller into a more accessible package.</p>

<p>&copy; Copyright 2017. All Rights Reserved.</p>

</body></html>